diff --git a/Makefile b/Makefile
index 678b3b6..8b60113 100644
--- a/Makefile
+++ b/Makefile
@@ -360,10 +360,7 @@ KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
 		   -Wno-format-security \
 		   -fno-builtin -ffreestanding
 KBUILD_AFLAGS   := -D__ASSEMBLY__
-ifeq ($(UBOOT_PRJ),Megafon)
-  KBUILD_CFLAGS += -DUBOOT_Megafon
-  $(warning __________$(KBUILD_CFLAGS)______________)
-endif
+
 # Read UBOOTRELEASE from include/config/uboot.release (if it exists)
 UBOOTRELEASE = $(shell cat include/config/uboot.release 2> /dev/null)
 UBOOTVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
@@ -937,7 +934,8 @@ endif
 		bl2
 	$(Q)cat $(FIP_FOLDER_SOC)/bl2_new.bin  $(FIP_FOLDER_SOC)/fip.bin > $(FIP_FOLDER_SOC)/boot_new.bin
 
-ifeq ($(SOC),gxl)
+#ifeq ($(SOC),gxl)
+ifeq ($(strip $(SOC)), $(filter $(SOC), gxl txl))
 	$(Q)$(FIP_FOLDER_SOC)/aml_encrypt_$(SOC) --bl3enc  --input $(FIP_FOLDER_SOC)/bl30_new.bin
 	$(Q)$(FIP_FOLDER_SOC)/aml_encrypt_$(SOC) --bl3enc  --input $(FIP_FOLDER_SOC)/bl31.$(BL3X_SUFFIX)
 ifeq ($(FIP_BL32), bl32.$(BL3X_SUFFIX))
@@ -954,7 +952,8 @@ else
 endif
 
 ifeq ($(CONFIG_AML_CRYPTO_UBOOT), y)
-ifeq ($(SOC),gxl)
+#ifeq ($(SOC),gxl)
+ifeq ($(strip $(SOC)), $(filter $(SOC), gxl txl))
 	$(Q)$(FIP_FOLDER_SOC)/aml_encrypt_$(SOC) --efsgen --amluserkey $(srctree)/$(BOARDDIR)/aml-user-key.sig \
 			--output $(FIP_FOLDER_SOC)/u-boot.bin.encrypt.efuse
 endif
diff --git a/arch/arm/cpu/armv8/gxb/Makefile b/arch/arm/cpu/armv8/gxb/Makefile
index 83756c5..bfaa50f 100644
--- a/arch/arm/cpu/armv8/gxb/Makefile
+++ b/arch/arm/cpu/armv8/gxb/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_AML_HDMITX20) += hdmitx20/
 obj-y	+= timer.o
 obj-y	+= mailbox.o
 obj-y   += gate_init.o
+obj-$(CONFIG_AML_HDMITX20)	+= sound.o
diff --git a/arch/arm/cpu/armv8/gxb/firmware/scp_task/hdmi_cec_arc.c b/arch/arm/cpu/armv8/gxb/firmware/scp_task/hdmi_cec_arc.c
index a61723b..a26a510 100644
--- a/arch/arm/cpu/armv8/gxb/firmware/scp_task/hdmi_cec_arc.c
+++ b/arch/arm/cpu/armv8/gxb/firmware/scp_task/hdmi_cec_arc.c
@@ -184,9 +184,9 @@ void remote_cec_hw_reset(void)
 	writel(reg, P_AO_RTI_PWR_CNTL_REG0);
 
 	/* set up pinmux */
-	writel(readl(P_AO_RTI_PIN_MUX_REG) & (~(1 << 18 | 1 << 17)), P_AO_RTI_PIN_MUX_REG);
+	writel(readl(P_AO_RTI_PIN_MUX_REG) & (~(1 << 14 | 1 << 17)), P_AO_RTI_PIN_MUX_REG);
 	writel(readl(P_AO_RTI_PULL_UP_REG) & (~(1 << 9)), P_AO_RTI_PULL_UP_REG);
-	writel(readl(P_AO_RTI_PIN_MUX_REG) | (1 << 16), P_AO_RTI_PIN_MUX_REG);
+	writel(readl(P_AO_RTI_PIN_MUX_REG) | (1 << 15), P_AO_RTI_PIN_MUX_REG);
 	// Assert SW reset AO_CEC
 	writel(0x1, P_AO_CEC_GEN_CNTL);
 	// Enable gated clock (Normal mode).
diff --git a/arch/arm/cpu/armv8/gxb/firmware/scp_task/scp_remote.c b/arch/arm/cpu/armv8/gxb/firmware/scp_task/scp_remote.c
index edd8ad3..f92cc29 100644
--- a/arch/arm/cpu/armv8/gxb/firmware/scp_task/scp_remote.c
+++ b/arch/arm/cpu/armv8/gxb/firmware/scp_task/scp_remote.c
@@ -263,7 +263,6 @@ void backuremote_register(void)
 
 void resume_remote_register(void)
 {
-	int tmp = 0;
 	writel(backuAO_RTI_PIN_MUX_REG, AO_RTI_PIN_MUX_REG);
 	writel(backuAO_IR_DEC_REG0, AO_MF_IR_DEC_REG0);
 	writel(backuAO_IR_DEC_REG1, AO_MF_IR_DEC_REG1);
@@ -271,20 +270,19 @@ void resume_remote_register(void)
 	writel(backuAO_IR_DEC_LDR_IDLE, AO_MF_IR_DEC_LDR_IDLE);
 	writel(backuAO_IR_DEC_BIT_0, AO_MF_IR_DEC_BIT_0);
 	writel(bakeuAO_IR_DEC_LDR_REPEAT, AO_MF_IR_DEC_LDR_REPEAT);
-	tmp = readl(AO_MF_IR_DEC_FRAME);
+	readl(AO_MF_IR_DEC_FRAME);
 }
 
 static int ir_remote_init_32k_mode(void)
 {
-	int tmp = 0;
 	//volatile unsigned int status,data_value;
 	int val = readl(AO_RTI_PIN_MUX_REG);
 	writel((val | (1 << 0)), AO_RTI_PIN_MUX_REG);
 	set_remote_mode(CONFIG_IR_REMOTE_USE_PROTOCOL);
 	//status = readl(AO_MF_IR_DEC_STATUS);
-	tmp = readl(AO_MF_IR_DEC_STATUS);
+	readl(AO_MF_IR_DEC_STATUS);
 	//data_value = readl(AO_MF_IR_DEC_FRAME);
-	tmp = readl(AO_MF_IR_DEC_FRAME);
+	readl(AO_MF_IR_DEC_FRAME);
 
 	//step 2 : request nec_remote irq  & enable it
 	return 0;
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/enc_clk_config.c b/arch/arm/cpu/armv8/gxb/hdmitx20/enc_clk_config.c
index f639daa..089e90f 100644
--- a/arch/arm/cpu/armv8/gxb/hdmitx20/enc_clk_config.c
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/enc_clk_config.c
@@ -93,7 +93,7 @@ static void set_hpll_clk_out(unsigned clk)
 	switch (clk) {
 	case 5940:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800027b);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -105,7 +105,7 @@ static void set_hpll_clk_out(unsigned clk)
 		break;
 	case 3712:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800024d);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4580, 0, 16);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -113,10 +113,11 @@ static void set_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
 		printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4580, 0, 16);
 		break;
 	case 2970:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800023d);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -128,7 +129,7 @@ static void set_hpll_clk_out(unsigned clk)
 		break;
 	case 4320:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000259);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -138,22 +139,9 @@ static void set_hpll_clk_out(unsigned clk)
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4800025a);
 		printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
-	case 2448:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 14, 1); // div mode
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0xe00, 0, 12); // div_frac
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486b00);    //5940 0x71c86900      // 0x71486900 2970
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x00000266);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x5, 28, 3);  //reset hpll
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
-		printk("waiting HPLL lock\n");
-		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		break;
 	case 1080:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5000022d);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00890000);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		// P_HHI_HDMI_PLL_CNTL5
diff --git a/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_set.c b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_set.c
index a43230f..5c17601 100644
--- a/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_set.c
+++ b/arch/arm/cpu/armv8/gxb/hdmitx20/hdmitx_set.c
@@ -23,6 +23,7 @@
 #include <asm/io.h>
 #include <asm/arch/register.h>
 #include <amlogic/hdmi.h>
+#include <amlogic/sound.h>
 #include "hdmitx_reg.h"
 #include "hdmitx_tvenc.h"
 #include "mach_reg.h"
@@ -87,6 +88,7 @@ static void hdelay(int us)
 #define msleep(i)   hdelay(i)
 
 static void hdmitx_set_hw(struct hdmitx_dev *hdev);
+static int hdmitx_set_audmode(struct hdmitx_dev *hdev);
 
 // Internal functions:
 static void hdmitx_csc_config (unsigned char input_color_format,
@@ -195,10 +197,10 @@ static int read_edid_8bytes(unsigned char *rx_edid, unsigned char addr)
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGADDR, 0x30);
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGPTR, 0);
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, addr & 0xff);
-	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 3);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 2);
 	timeout = 0;
 	while ((!(hdmitx_rd_reg(HDMITX_DWC_IH_I2CM_STAT0) & (1 << 1))) && (timeout < 3)) {
-		mdelay(2);
+		_udelay(2000);
 		timeout ++;
 	}
 	if (timeout == 3) {
@@ -218,7 +220,8 @@ static void ddc_init(void)
 	static int ddc_init_flag;
 	unsigned int data32 = 0;
 
-
+	hdmitx_hw_init();
+	_udelay(200);
 	if (ddc_init_flag)
 		return;
 	else
@@ -387,10 +390,12 @@ void hdmi_tx_init(void)
 
 void hdmi_tx_set(struct hdmitx_dev *hdev)
 {
+	aml_audio_init(); /* Init audio hw firstly */
 	hdmitx_hw_init();
 	hdmitx_debug();
 	ddc_init();
 	hdmitx_set_hw(hdev);
+	hdmitx_set_audmode(hdev);
 	hdmitx_debug();
 	return;
 
@@ -415,6 +420,154 @@ static void hdcp14_init(void)
 	);
 }
 
+static int hdmitx_set_audmode(struct hdmitx_dev *hdev)
+{
+	int i;
+	unsigned int data32;
+	unsigned int aud_n_para;
+
+	pr_info("hdmtix: set audio\n");
+	hdmitx_set_reg_bits(HDMITX_TOP_CLK_CNTL, 3, 2, 2);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 0, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 3, 1);
+
+	/* Disable HDMI audio clock input and its I2S input */
+	hd_write_reg(P_AIU_HDMI_CLK_DATA_CTRL, 0);
+
+	/* Enable HDMI I2S input from the selected source */
+	hd_write_reg(P_AIU_HDMI_CLK_DATA_CTRL, 0x22);
+
+	/* I2S Sampler config */
+	data32 = 0;
+/* [  3] fifo_empty_mask: 0=enable int; 1=mask int. */
+	data32 |= (1 << 3);
+/* [  2] fifo_full_mask: 0=enable int; 1=mask int. */
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT, data32);
+
+	data32 = 0;
+/* [  4] fifo_overrun_mask: 0=enable int; 1=mask int.
+ * Enable it later when audio starts. */
+	data32 |= (1 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT1,  data32);
+/* [  5] 0=select SPDIF; 1=select I2S. */
+	data32 = 0;
+	data32 |= (0 << 7);  /* [  7] sw_audio_fifo_rst */
+	data32 |= (0 << 5);
+	data32 |= (0 << 0);  /* [3:0] i2s_in_en: enable it later in test.c */
+/* if enable it now, fifo_overrun will happen, because packet don't get sent
+ * out until initial DE detected. */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF0, data32);
+
+	data32 = 0;
+	data32 |= (0 << 5);  /* [7:5] i2s_mode: 0=standard I2S mode */
+	data32 |= (24 << 0);  /* [4:0] i2s_width */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF1, data32);
+
+	data32 = 0;
+	data32 |= (0 << 1);  /* [  1] NLPCM */
+	data32 |= (0 << 0);  /* [  0] HBR */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF2, data32);
+
+	/* spdif sampler config */
+	/* [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int. */
+	/* [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int. */
+	data32 = 0;
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT,  data32);
+	/* [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int. */
+	data32 = 0;
+	data32 |= (0 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT1, data32);
+
+	data32 = 0;
+	data32 |= (0 << 7);  /* [  7] sw_audio_fifo_rst */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF0, data32);
+
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0, 0, 0, 4); /* CT */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0, 1,	4, 3); /* CC */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 0, 3); /* SF */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 4, 2); /* SS */
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF3, 0);
+
+	/* audio packetizer config */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, 0);
+
+	/* 48kHz 2ch PCM as default */
+	aud_n_para = 6144;
+	switch (hdev->vic) {
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p30_256x135:
+		aud_n_para = 5120;
+		break;
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_3840x2160p50_64x27:
+	case HDMI_3840x2160p60_64x27:
+		if (hdev->para->cs == HDMI_COLOR_FORMAT_420)
+			aud_n_para = 5120;
+		break;
+	default:
+		break;
+	}
+
+	/* ACR packet configuration */
+	data32 = 0;
+	data32 |= (1 << 7);  /* [  7] ncts_atomic_write */
+	data32 |= (0 << 0);  /* [3:0] AudN[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N3, data32);
+
+	data32 = 0;
+	data32 |= (0 << 7);  /* [7:5] N_shift */
+	data32 |= (0 << 4);  /* [  4] CTS_manual */
+	data32 |= (0 << 0);  /* [3:0] manual AudCTS[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS3, data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS2, 0); /* manual AudCTS[15:8] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS1, 0); /* manual AudCTS[7:0] */
+
+	data32 = 0;
+	data32 |= (1 << 7);  /* [  7] ncts_atomic_write */
+	data32 |= (((aud_n_para>>16)&0xf) << 0);  /* [3:0] AudN[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N3, data32);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N2, (aud_n_para>>8)&0xff); /* AudN[15:8] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N1, aud_n_para&0xff); /* AudN[7:0] */
+	for (i = 0; i < 9; i++)
+		hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS0+i, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSV, 0x11);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS7, 0x02);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS8, 0xd2);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS3, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS5, 0x00);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7,
+		0x2, 0, 4); /*CSB 27:24*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7, 0x0, 6, 2); /*CSB 31:30*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7, 0x0, 4, 2); /*CSB 29:28*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS8, 0x2, 0, 4); /*CSB 35:32*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS8,  /* CSB 39:36 */
+		0xd, 4, 4);
+
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 0, 5, 1);
+	/* reset audio fifo */
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 0, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 0, 7, 1);
+	hdmitx_wr_reg(HDMITX_DWC_MC_SWRSTZREQ, 0xe7);
+	/* need reset again */
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 0, 7, 1);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N1, hdmitx_rd_reg(HDMITX_DWC_AUD_N1));
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO3, 1, 0, 1);
+	return 0;
+}
+
 #define NUM_INT_VSYNC   INT_VEC_VIU1_VSYNC
 
 static unsigned long modulo(unsigned long a, unsigned long b);
@@ -490,7 +643,7 @@ static void config_hdmi20_tx ( enum hdmi_vic vic, struct hdmi_format_para *para,
     data32 |= ((((input_color_format ==HDMI_COLOR_FORMAT_422) &&
                  (output_color_format!=HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 4);  // [5:4] intmode
     data32 |= ((((input_color_format !=HDMI_COLOR_FORMAT_422) &&
-                 (output_color_format==HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 0);  // [1:0] decmode
+                 (output_color_format==HDMI_COLOR_FORMAT_422))? 1 : 0 ) << 0);  // [1:0] decmode
 	hdmitx_wr_reg(HDMITX_DWC_CSC_CFG, data32);
 
 	hdmitx_csc_config(input_color_format, output_color_format, color_depth);
@@ -1159,7 +1312,6 @@ static void enc_vpu_bridge_reset(int mode)
 {
     unsigned int wr_clk = 0;
 
-    printk("%s[%d]\n", __func__, __LINE__);
     wr_clk = (hd_read_reg(P_VPU_HDMI_SETTING) & 0xf00) >> 8;
     if (mode) {
         hd_write_reg(P_ENCP_VIDEO_EN, 0);
diff --git a/arch/arm/cpu/armv8/gxb/sound.c b/arch/arm/cpu/armv8/gxb/sound.c
new file mode 100644
index 0000000..88da26a
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxb/sound.c
@@ -0,0 +1,197 @@
+/*
+ * arch/arm/cpu/armv8/gxb/sound.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/arch/io.h>
+#include <asm/arch/secure_apb.h>
+#include <common.h>
+#include <malloc.h>
+#include <amlogic/sound.h>
+
+static int reg_update_bits(unsigned long reg, unsigned int mask, unsigned int value)
+{
+	bool change;
+	unsigned int old, new;
+
+	old = readl(reg);
+
+	new = (old & ~mask) | (value & mask);
+	change = old != new;
+	if (change)
+		writel(new, reg);
+
+	return change;
+}
+
+struct aiu_958_channel_status {
+	unsigned short chstat0_l;
+	unsigned short chstat1_l;
+	unsigned short chstat0_r;
+	unsigned short chstat1_r;
+};
+
+struct aiu_958_raw_setting {
+	unsigned short int_flag;
+	unsigned short bpf;
+	unsigned short brst;
+	unsigned short length;
+	unsigned short paddsize;
+	struct aiu_958_channel_status *chan_stat;
+};
+
+static void aml_set_audio_spdif_clk(void)
+{
+	int i;
+	// gate the clock off
+	reg_update_bits(HHI_AUD_CLK_CNTL, 1 << 8, 0);
+
+	/*--- IEC958 clock  configuration, use MPLL1--- */
+	//IEC958_USE_CNTL
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 1 << 27, 1 << 27);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 3 << 25, 2 << 25);
+
+	// Configure Multi-Phase PLL1
+	writel(0x14d616, HHI_MPLL_CNTL8);
+	// Set the XD value
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 0xff << 16, (4-1) << 16);
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 1 << 24, 1 << 24);
+
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+
+	// gate the clock on
+	reg_update_bits(HHI_AUD_CLK_CNTL, 1 << 8, 1 << 8);
+	/* 958 divisor more, if true, divided by 2, 4, 6, 8 */
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 0, 12, 1);
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);
+	/* enable 958 divider */
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 1, 1, 1);
+}
+
+static void audio_hw_958_enable(unsigned flag)
+{
+	WRITE_CBUS_REG(AIU_RST_SOFT, 0x04);
+	WRITE_CBUS_REG(AIU_958_FORCE_LEFT, 0);
+	if (flag) {
+		WRITE_CBUS_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
+		WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
+	} else {
+		WRITE_CBUS_REG(AIU_958_DCU_FF_CTRL, 0);
+		WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);
+	}
+}
+
+static void audio_set_958outbuf(long addr, size_t size)
+{
+	WRITE_CBUS_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
+	WRITE_CBUS_REG(AIU_MEM_IEC958_RD_PTR, addr & 0xffffffc0);
+
+	/* this is for 16bit 2 channel */
+	WRITE_CBUS_REG(AIU_MEM_IEC958_END_PTR,
+				(addr & 0xffffffc0) +
+				(size & 0xffffffc0) - 8);
+
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_MASKS, 0xffff, 0, 16);
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 1, 1);
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 1);
+
+	WRITE_CBUS_REG(AIU_MEM_IEC958_BUF_CNTL, 1);
+	WRITE_CBUS_REG(AIU_MEM_IEC958_BUF_CNTL, 0);
+}
+static void set_958_channel_status(struct aiu_958_channel_status *set)
+{
+	if (set) {
+		WRITE_CBUS_REG(AIU_958_CHSTAT_L0, set->chstat0_l);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_L1, set->chstat1_l);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_R0, set->chstat0_r);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_R1, set->chstat1_r);
+	}
+}
+
+static void audio_hw_set_958_pcm24(struct aiu_958_raw_setting *set)
+{
+	if (set) {
+		/* in pcm mode, set bpf to 128 */
+		WRITE_CBUS_REG(AIU_958_BPF, 0x80);
+		set_958_channel_status(set->chan_stat);
+	}
+}
+
+static void audio_hw_958_reset(unsigned slow_domain, unsigned fast_domain)
+{
+	WRITE_CBUS_REG(AIU_958_DCU_FF_CTRL, 0);
+	WRITE_CBUS_REG(AIU_RST_SOFT, (slow_domain << 3) | (fast_domain << 2));
+}
+
+static void audio_set_958_mode(struct aiu_958_raw_setting *set)
+{
+	if (!set) {
+		printf("ERR, NULL set ptr!");
+		return;
+	}
+
+	WRITE_CBUS_REG(AIU_958_VALID_CTRL, 0);
+
+	audio_hw_set_958_pcm24(set);
+	WRITE_CBUS_REG(AIU_958_MISC, 0x2042);
+	/* pcm */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);
+#else
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);
+#endif
+	/* 16bit */
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 7, 1);
+	/* endian */
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3);
+	audio_hw_958_reset(0, 1);
+
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	if (0)
+		WRITE_CBUS_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 8, 1);
+#endif
+
+	WRITE_CBUS_REG(AIU_958_FORCE_LEFT, 1);
+}
+
+static void aml_spdif_play(void)
+{
+	struct aiu_958_raw_setting set;
+	struct aiu_958_channel_status chstat;
+	static long iec958buf[32 + 16];
+
+	set.chan_stat = &chstat;
+	set.chan_stat->chstat0_l = 0x0100;
+	set.chan_stat->chstat0_r = 0x0100;
+	set.chan_stat->chstat1_l = 0X200;
+	set.chan_stat->chstat1_r = 0X200;
+	audio_hw_958_enable(0);
+
+	memset(iec958buf, 0, sizeof(iec958buf));
+	audio_set_958outbuf(((long)iec958buf+ 63) & (~63), 128);
+	audio_set_958_mode(&set);
+
+	audio_hw_958_enable(1);
+}
+
+int aml_audio_init(void)
+{
+	aml_set_audio_spdif_clk();
+	aml_spdif_play();
+
+	return 0;
+}
+
diff --git a/arch/arm/cpu/armv8/gxl/Makefile b/arch/arm/cpu/armv8/gxl/Makefile
index 83756c5..bfaa50f 100644
--- a/arch/arm/cpu/armv8/gxl/Makefile
+++ b/arch/arm/cpu/armv8/gxl/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_AML_HDMITX20) += hdmitx20/
 obj-y	+= timer.o
 obj-y	+= mailbox.o
 obj-y   += gate_init.o
+obj-$(CONFIG_AML_HDMITX20)	+= sound.o
diff --git a/arch/arm/cpu/armv8/gxl/firmware/scp_task/Makefile b/arch/arm/cpu/armv8/gxl/firmware/scp_task/Makefile
index af2b092..62df876 100644
--- a/arch/arm/cpu/armv8/gxl/firmware/scp_task/Makefile
+++ b/arch/arm/cpu/armv8/gxl/firmware/scp_task/Makefile
@@ -42,10 +42,6 @@ VPATH_LIST=     $(buildsrc)/$(BOARDDIR)
 VPATH_LIST:=$(VPATH_LIST:%=%/firmware/scp_task/)
 
 CFLAGS=$(CFLAGS_CPU) $(CFLAGS_WARN) $(VPATH_LIST:%=-I%) $(CFLAGS_INCLUDE) $(CFLAGS_FPU-y)
-ifeq ($(UBOOT_PRJ),Megafon)
-  CFLAGS += -DUBOOT_Megafon
-  $(warning __________$(CFLAGS)______________)
-endif
 ASFLAGS= -gdwarf2 -mcpu=$(ARM_CPU)
 DUMP_FLAGS = -D -x
 
diff --git a/arch/arm/cpu/armv8/gxl/firmware/scp_task/hdmi_cec_arc.c b/arch/arm/cpu/armv8/gxl/firmware/scp_task/hdmi_cec_arc.c
index a61723b..dcf54b1 100644
--- a/arch/arm/cpu/armv8/gxl/firmware/scp_task/hdmi_cec_arc.c
+++ b/arch/arm/cpu/armv8/gxl/firmware/scp_task/hdmi_cec_arc.c
@@ -184,9 +184,9 @@ void remote_cec_hw_reset(void)
 	writel(reg, P_AO_RTI_PWR_CNTL_REG0);
 
 	/* set up pinmux */
-	writel(readl(P_AO_RTI_PIN_MUX_REG) & (~(1 << 18 | 1 << 17)), P_AO_RTI_PIN_MUX_REG);
-	writel(readl(P_AO_RTI_PULL_UP_REG) & (~(1 << 9)), P_AO_RTI_PULL_UP_REG);
-	writel(readl(P_AO_RTI_PIN_MUX_REG) | (1 << 16), P_AO_RTI_PIN_MUX_REG);
+	writel(readl(P_AO_RTI_PIN_MUX_REG) & (~((1 << 14) | (1 << 17))), P_AO_RTI_PIN_MUX_REG);
+	writel(readl(P_AO_RTI_PIN_MUX_REG2) & (~(1 << 0)), P_AO_RTI_PIN_MUX_REG2);
+	writel(readl(P_AO_RTI_PIN_MUX_REG) | (1 << 15), P_AO_RTI_PIN_MUX_REG);
 	// Assert SW reset AO_CEC
 	writel(0x1, P_AO_CEC_GEN_CNTL);
 	// Enable gated clock (Normal mode).
diff --git a/arch/arm/cpu/armv8/gxl/firmware/scp_task/scp_remote.c b/arch/arm/cpu/armv8/gxl/firmware/scp_task/scp_remote.c
index ee40a08..c89db92 100644
--- a/arch/arm/cpu/armv8/gxl/firmware/scp_task/scp_remote.c
+++ b/arch/arm/cpu/armv8/gxl/firmware/scp_task/scp_remote.c
@@ -193,7 +193,6 @@ void backuremote_register(void)
 
 void resume_remote_register(void)
 {
-	int tmp = 0;
 	writel(backuAO_RTI_PIN_MUX_REG, AO_RTI_PIN_MUX_REG);
 	writel(backuAO_IR_DEC_REG0, AO_MF_IR_DEC_REG0);
 	writel(backuAO_IR_DEC_REG1, AO_MF_IR_DEC_REG1);
@@ -201,21 +200,19 @@ void resume_remote_register(void)
 	writel(backuAO_IR_DEC_LDR_IDLE, AO_MF_IR_DEC_LDR_IDLE);
 	writel(backuAO_IR_DEC_BIT_0, AO_MF_IR_DEC_BIT_0);
 	writel(bakeuAO_IR_DEC_LDR_REPEAT, AO_MF_IR_DEC_LDR_REPEAT);
-	tmp = readl(AO_MF_IR_DEC_FRAME);
+	readl(AO_MF_IR_DEC_FRAME);
 }
 
 static int ir_remote_init_32k_mode(void)
 {
-	int tmp = 0;
 	//volatile unsigned int status,data_value;
 	int val = readl(AO_RTI_PIN_MUX_REG);
 	writel((val | (1 << 0)), AO_RTI_PIN_MUX_REG);
 	set_remote_mode(0);
 	//status = readl(AO_MF_IR_DEC_STATUS);
-	tmp = readl(AO_MF_IR_DEC_STATUS);
+	readl(AO_MF_IR_DEC_STATUS);
 	//data_value = readl(AO_MF_IR_DEC_FRAME);
-	tmp = readl(AO_MF_IR_DEC_FRAME);
-
+	readl(AO_MF_IR_DEC_FRAME);
 	//step 2 : request nec_remote irq  & enable it
 	return 0;
 }
@@ -231,11 +228,6 @@ static unsigned int kk[] = {
 	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL2,
 	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL3,
 	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL4,
-	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL5,
-	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL6,
-	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL7,
-	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL8,
-	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL9,
 };
 
 static int init_remote(void)
@@ -246,7 +238,7 @@ static int init_remote(void)
 	return 0;
 }
 
-unsigned int usr_pwr_key;
+unsigned int usr_pwr_key = CONFIG_IR_REMOTE_POWER_UP_KEY_VAL5;
 
 static int remote_detect_key(void)
 {
diff --git a/arch/arm/cpu/armv8/gxl/firmware/scp_task/suspend.c b/arch/arm/cpu/armv8/gxl/firmware/scp_task/suspend.c
index 010b030..278a0aa 100644
--- a/arch/arm/cpu/armv8/gxl/firmware/scp_task/suspend.c
+++ b/arch/arm/cpu/armv8/gxl/firmware/scp_task/suspend.c
@@ -7,8 +7,6 @@ unsigned int time;
 
 #include <pwr_ctrl.c>
 #include <hdmi_cec_arc.c>
-//#include <asm/arch/bl31_apis.h>
-//#include <linux/types.h>
 
 static struct pwr_op pwr_op_d;
 static struct pwr_op *p_pwr_op;
@@ -63,25 +61,6 @@ void suspend_get_wakeup_source(void *response, unsigned int suspend_from)
 	p_pwr_op->get_wakeup_source(response, suspend_from);
 }
 
-
-unsigned aml_reboot(unsigned int function_id, unsigned int arg0, unsigned int arg1, unsigned int arg2)
-{
-	register long x0 asm("x0") = function_id;
-	register long x1 asm("x1") = arg0;
-	register long x2 asm("x2") = arg1;
-	register long x3 asm("x3") = arg2;
-	asm volatile(
-			__asmeq("%0", "x0")
-			__asmeq("%1", "x1")
-			__asmeq("%2", "x2")
-			__asmeq("%3", "x3")
-			"smc	#0\n"
-		: "+r" (x0)
-		: "r" (x1), "r" (x2), "r" (x3));
-
-	return function_id;
-}
-
 /*
  *suspend_from defines who call this function.
  * 1: suspend
@@ -107,14 +86,7 @@ void enter_suspend(unsigned int suspend_from)
 	uart_puts("exit_reason:0x");
 	uart_put_hex(exit_reason, 8);
 	uart_puts("\n");
-
-	uart_puts("elricfu add, start reboot\n");
-        aml_reboot(0x84000009, 1, 0, 0);
 	set_wakeup_method(exit_reason);
-	//if (exit_reason==4)
-	//{
-	//	return;
-	//}
 	p_pwr_op->power_on_at_24M();
 	p_pwr_op->power_on_at_clk81();
 }
diff --git a/arch/arm/cpu/armv8/gxl/firmware/scp_task/task_apis.h b/arch/arm/cpu/armv8/gxl/firmware/scp_task/task_apis.h
index daa6a52..058c8e7 100644
--- a/arch/arm/cpu/armv8/gxl/firmware/scp_task/task_apis.h
+++ b/arch/arm/cpu/armv8/gxl/firmware/scp_task/task_apis.h
@@ -14,8 +14,8 @@ int uart_puts(const char *s);
 
 /* #define dbg_print(s,v) */
 /* #define dbg_prints(s) */
-#define writel(v, addr) (*((unsigned *)addr) = v)
-#define readl(addr) (*((unsigned *)addr))
+#define writel(v, addr) (*((volatile unsigned *)addr) = v)
+#define readl(addr) (*((volatile unsigned *)addr))
 
 #define dbg_print(s, v) {uart_puts(s); uart_put_hex(v, 32); uart_puts("\n"); }
 /* #define dbg_prints(s)  {uart_puts(s);wait_uart_empty();} */
diff --git a/arch/arm/cpu/armv8/gxl/hdmitx20/enc_clk_config.c b/arch/arm/cpu/armv8/gxl/hdmitx20/enc_clk_config.c
index 1cb0c53..cec803b 100644
--- a/arch/arm/cpu/armv8/gxl/hdmitx20/enc_clk_config.c
+++ b/arch/arm/cpu/armv8/gxl/hdmitx20/enc_clk_config.c
@@ -146,6 +146,24 @@ static void set_hpll_clk_out(unsigned clk)
 	printk("config HPLL done\n");
 }
 
+static void set_hpll_sspll(enum hdmi_vic vic)
+{
+	switch (vic) {
+	case HDMI_1920x1080p60_16x9:
+	case HDMI_1920x1080p50_16x9:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x868b48c4);
+		break;
+	case HDMI_1280x720p60_16x9:
+	case HDMI_1280x720p50_16x9:
+	case HDMI_1920x1080i60_16x9:
+	case HDMI_1920x1080i50_16x9:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x864348c4);
+		break;
+	default:
+		break;
+	}
+}
+
 static void set_hpll_od1(unsigned div)
 {
 	switch (div) {
@@ -348,6 +366,7 @@ next:
 	set_viu_path(p_enc[j].viu_path, p_enc[j].viu_type);
 	set_hdmitx_sys_clk();
 	set_hpll_clk_out(p_enc[j].hpll_clk_out);
+	set_hpll_sspll(vic);
 	set_hpll_od1(p_enc[j].od1);
 	set_hpll_od2(p_enc[j].od2);
 	set_hpll_od3(p_enc[j].od3);
diff --git a/arch/arm/cpu/armv8/gxl/hdmitx20/hdmitx_set.c b/arch/arm/cpu/armv8/gxl/hdmitx20/hdmitx_set.c
index 4661fb7..67333f8 100644
--- a/arch/arm/cpu/armv8/gxl/hdmitx20/hdmitx_set.c
+++ b/arch/arm/cpu/armv8/gxl/hdmitx20/hdmitx_set.c
@@ -23,6 +23,7 @@
 #include <asm/io.h>
 #include <asm/arch/register.h>
 #include <amlogic/hdmi.h>
+#include <amlogic/sound.h>
 #include "hdmitx_reg.h"
 #include "hdmitx_tvenc.h"
 #include "mach_reg.h"
@@ -87,6 +88,7 @@ static void hdelay(int us)
 #define msleep(i)   hdelay(i)
 
 static void hdmitx_set_hw(struct hdmitx_dev *hdev);
+static int hdmitx_set_audmode(struct hdmitx_dev *hdev);
 
 // Internal functions:
 static void hdmitx_csc_config (unsigned char input_color_format,
@@ -195,10 +197,10 @@ static int read_edid_8bytes(unsigned char *rx_edid, unsigned char addr)
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGADDR, 0x30);
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGPTR, 0);
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, addr & 0xff);
-	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 3);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 2);
 	timeout = 0;
 	while ((!(hdmitx_rd_reg(HDMITX_DWC_IH_I2CM_STAT0) & (1 << 1))) && (timeout < 3)) {
-		mdelay(2);
+		_udelay(2000);
 		timeout ++;
 	}
 	if (timeout == 3) {
@@ -218,7 +220,8 @@ static void ddc_init(void)
 	static int ddc_init_flag;
 	unsigned int data32 = 0;
 
-
+	hdmitx_hw_init();
+	_udelay(200);
 	if (ddc_init_flag)
 		return;
 	else
@@ -387,10 +390,12 @@ void hdmi_tx_init(void)
 
 void hdmi_tx_set(struct hdmitx_dev *hdev)
 {
+	aml_audio_init(); /* Init audio hw firstly */
 	hdmitx_hw_init();
 	hdmitx_debug();
 	ddc_init();
 	hdmitx_set_hw(hdev);
+	hdmitx_set_audmode(hdev);
 	hdmitx_debug();
 	return;
 
@@ -415,6 +420,154 @@ static void hdcp14_init(void)
 	);
 }
 
+static int hdmitx_set_audmode(struct hdmitx_dev *hdev)
+{
+	int i;
+	unsigned int data32;
+	unsigned int aud_n_para;
+
+	pr_info("hdmtix: set audio\n");
+	hdmitx_set_reg_bits(HDMITX_TOP_CLK_CNTL, 3, 2, 2);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 0, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 3, 1);
+
+	/* Disable HDMI audio clock input and its I2S input */
+	hd_write_reg(P_AIU_HDMI_CLK_DATA_CTRL, 0);
+
+	/* Enable HDMI I2S input from the selected source */
+	hd_write_reg(P_AIU_HDMI_CLK_DATA_CTRL, 0x22);
+
+	/* I2S Sampler config */
+	data32 = 0;
+/* [  3] fifo_empty_mask: 0=enable int; 1=mask int. */
+	data32 |= (1 << 3);
+/* [  2] fifo_full_mask: 0=enable int; 1=mask int. */
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT, data32);
+
+	data32 = 0;
+/* [  4] fifo_overrun_mask: 0=enable int; 1=mask int.
+ * Enable it later when audio starts. */
+	data32 |= (1 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT1,  data32);
+/* [  5] 0=select SPDIF; 1=select I2S. */
+	data32 = 0;
+	data32 |= (0 << 7);  /* [  7] sw_audio_fifo_rst */
+	data32 |= (0 << 5);
+	data32 |= (0 << 0);  /* [3:0] i2s_in_en: enable it later in test.c */
+/* if enable it now, fifo_overrun will happen, because packet don't get sent
+ * out until initial DE detected. */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF0, data32);
+
+	data32 = 0;
+	data32 |= (0 << 5);  /* [7:5] i2s_mode: 0=standard I2S mode */
+	data32 |= (24 << 0);  /* [4:0] i2s_width */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF1, data32);
+
+	data32 = 0;
+	data32 |= (0 << 1);  /* [  1] NLPCM */
+	data32 |= (0 << 0);  /* [  0] HBR */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF2, data32);
+
+	/* spdif sampler config */
+	/* [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int. */
+	/* [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int. */
+	data32 = 0;
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT,  data32);
+	/* [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int. */
+	data32 = 0;
+	data32 |= (0 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT1, data32);
+
+	data32 = 0;
+	data32 |= (0 << 7);  /* [  7] sw_audio_fifo_rst */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF0, data32);
+
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0, 0, 0, 4); /* CT */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0, 1,	4, 3); /* CC */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 0, 3); /* SF */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 4, 2); /* SS */
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF3, 0);
+
+	/* audio packetizer config */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, 0);
+
+	/* 48kHz 2ch PCM as default */
+	aud_n_para = 6144;
+	switch (hdev->vic) {
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p30_256x135:
+		aud_n_para = 5120;
+		break;
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_3840x2160p50_64x27:
+	case HDMI_3840x2160p60_64x27:
+		if (hdev->para->cs == HDMI_COLOR_FORMAT_420)
+			aud_n_para = 5120;
+		break;
+	default:
+		break;
+	}
+
+	/* ACR packet configuration */
+	data32 = 0;
+	data32 |= (1 << 7);  /* [  7] ncts_atomic_write */
+	data32 |= (0 << 0);  /* [3:0] AudN[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N3, data32);
+
+	data32 = 0;
+	data32 |= (0 << 7);  /* [7:5] N_shift */
+	data32 |= (0 << 4);  /* [  4] CTS_manual */
+	data32 |= (0 << 0);  /* [3:0] manual AudCTS[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS3, data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS2, 0); /* manual AudCTS[15:8] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS1, 0); /* manual AudCTS[7:0] */
+
+	data32 = 0;
+	data32 |= (1 << 7);  /* [  7] ncts_atomic_write */
+	data32 |= (((aud_n_para>>16)&0xf) << 0);  /* [3:0] AudN[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N3, data32);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N2, (aud_n_para>>8)&0xff); /* AudN[15:8] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N1, aud_n_para&0xff); /* AudN[7:0] */
+	for (i = 0; i < 9; i++)
+		hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS0+i, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSV, 0x11);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS7, 0x02);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS8, 0xd2);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS3, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS5, 0x00);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7,
+		0x2, 0, 4); /*CSB 27:24*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7, 0x0, 6, 2); /*CSB 31:30*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7, 0x0, 4, 2); /*CSB 29:28*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS8, 0x2, 0, 4); /*CSB 35:32*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS8,  /* CSB 39:36 */
+		0xd, 4, 4);
+
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 0, 5, 1);
+	/* reset audio fifo */
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 0, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 0, 7, 1);
+	hdmitx_wr_reg(HDMITX_DWC_MC_SWRSTZREQ, 0xe7);
+	/* need reset again */
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 0, 7, 1);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N1, hdmitx_rd_reg(HDMITX_DWC_AUD_N1));
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO3, 1, 0, 1);
+	return 0;
+}
+
 #define NUM_INT_VSYNC   INT_VEC_VIU1_VSYNC
 
 static unsigned long modulo(unsigned long a, unsigned long b);
@@ -490,7 +643,7 @@ static void config_hdmi20_tx ( enum hdmi_vic vic, struct hdmi_format_para *para,
     data32 |= ((((input_color_format ==HDMI_COLOR_FORMAT_422) &&
                  (output_color_format!=HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 4);  // [5:4] intmode
     data32 |= ((((input_color_format !=HDMI_COLOR_FORMAT_422) &&
-                 (output_color_format==HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 0);  // [1:0] decmode
+                 (output_color_format==HDMI_COLOR_FORMAT_422))? 1 : 0 ) << 0);  // [1:0] decmode
 	hdmitx_wr_reg(HDMITX_DWC_CSC_CFG, data32);
 
 	hdmitx_csc_config(input_color_format, output_color_format, color_depth);
@@ -1110,11 +1263,14 @@ static void set_phy_by_mode(unsigned int mode)
 		hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33303382);
 		hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2036315b);
 		break;
-	case 3: /* 1.485Gbps, and below */
-	default:
-		hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33303362);
+	case 3: /* 1.485Gbps */
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33303042);
 		hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2016315b);
 		break;
+	default: /* 742.5Mbps, and below */
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33604132);
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x0016315b);
+		break;
 	}
 }
 
@@ -1150,9 +1306,12 @@ static void hdmitx_set_phy(struct hdmitx_dev *hdev)
 			set_phy_by_mode(1);
 		break;
 	case HDMI_1920x1080p60_16x9:
-	default:
+	case HDMI_1920x1080p50_16x9:
 		set_phy_by_mode(3);
 		break;
+	default:
+		set_phy_by_mode(4);
+		break;
 	}
 /* P_HHI_HDMI_PHY_CNTL1	bit[1]: enable clock	bit[0]: soft reset */
 #define RESET_HDMI_PHY() \
@@ -1180,7 +1339,6 @@ static void enc_vpu_bridge_reset(int mode)
 {
     unsigned int wr_clk = 0;
 
-    printk("%s[%d]\n", __func__, __LINE__);
     wr_clk = (hd_read_reg(P_VPU_HDMI_SETTING) & 0xf00) >> 8;
     if (mode) {
         hd_write_reg(P_ENCP_VIDEO_EN, 0);
diff --git a/arch/arm/cpu/armv8/gxl/sound.c b/arch/arm/cpu/armv8/gxl/sound.c
new file mode 100644
index 0000000..b2b103d
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxl/sound.c
@@ -0,0 +1,197 @@
+/*
+ * arch/arm/cpu/armv8/gxl/sound.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/arch/io.h>
+#include <asm/arch/secure_apb.h>
+#include <common.h>
+#include <malloc.h>
+#include <amlogic/sound.h>
+
+static int reg_update_bits(unsigned long reg, unsigned int mask, unsigned int value)
+{
+	bool change;
+	unsigned int old, new;
+
+	old = readl(reg);
+
+	new = (old & ~mask) | (value & mask);
+	change = old != new;
+	if (change)
+		writel(new, reg);
+
+	return change;
+}
+
+struct aiu_958_channel_status {
+	unsigned short chstat0_l;
+	unsigned short chstat1_l;
+	unsigned short chstat0_r;
+	unsigned short chstat1_r;
+};
+
+struct aiu_958_raw_setting {
+	unsigned short int_flag;
+	unsigned short bpf;
+	unsigned short brst;
+	unsigned short length;
+	unsigned short paddsize;
+	struct aiu_958_channel_status *chan_stat;
+};
+
+static void aml_set_audio_spdif_clk(void)
+{
+	int i;
+	// gate the clock off
+	reg_update_bits(HHI_AUD_CLK_CNTL, 1 << 8, 0);
+
+	/*--- IEC958 clock  configuration, use MPLL1--- */
+	//IEC958_USE_CNTL
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 1 << 27, 1 << 27);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 3 << 25, 2 << 25);
+
+	// Configure Multi-Phase PLL1
+	writel(0x14d616, HHI_MPLL_CNTL8);
+	// Set the XD value
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 0xff << 16, (4-1) << 16);
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 1 << 24, 1 << 24);
+
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+
+	// gate the clock on
+	reg_update_bits(HHI_AUD_CLK_CNTL, 1 << 8, 1 << 8);
+	/* 958 divisor more, if true, divided by 2, 4, 6, 8 */
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 0, 12, 1);
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);
+	/* enable 958 divider */
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 1, 1, 1);
+}
+
+static void audio_hw_958_enable(unsigned flag)
+{
+	WRITE_CBUS_REG(AIU_RST_SOFT, 0x04);
+	WRITE_CBUS_REG(AIU_958_FORCE_LEFT, 0);
+	if (flag) {
+		WRITE_CBUS_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
+		WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
+	} else {
+		WRITE_CBUS_REG(AIU_958_DCU_FF_CTRL, 0);
+		WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);
+	}
+}
+
+static void audio_set_958outbuf(long addr, size_t size)
+{
+	WRITE_CBUS_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
+	WRITE_CBUS_REG(AIU_MEM_IEC958_RD_PTR, addr & 0xffffffc0);
+
+	/* this is for 16bit 2 channel */
+	WRITE_CBUS_REG(AIU_MEM_IEC958_END_PTR,
+				(addr & 0xffffffc0) +
+				(size & 0xffffffc0) - 8);
+
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_MASKS, 0xffff, 0, 16);
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 1, 1);
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 1);
+
+	WRITE_CBUS_REG(AIU_MEM_IEC958_BUF_CNTL, 1);
+	WRITE_CBUS_REG(AIU_MEM_IEC958_BUF_CNTL, 0);
+}
+static void set_958_channel_status(struct aiu_958_channel_status *set)
+{
+	if (set) {
+		WRITE_CBUS_REG(AIU_958_CHSTAT_L0, set->chstat0_l);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_L1, set->chstat1_l);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_R0, set->chstat0_r);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_R1, set->chstat1_r);
+	}
+}
+
+static void audio_hw_set_958_pcm24(struct aiu_958_raw_setting *set)
+{
+	if (set) {
+		/* in pcm mode, set bpf to 128 */
+		WRITE_CBUS_REG(AIU_958_BPF, 0x80);
+		set_958_channel_status(set->chan_stat);
+	}
+}
+
+static void audio_hw_958_reset(unsigned slow_domain, unsigned fast_domain)
+{
+	WRITE_CBUS_REG(AIU_958_DCU_FF_CTRL, 0);
+	WRITE_CBUS_REG(AIU_RST_SOFT, (slow_domain << 3) | (fast_domain << 2));
+}
+
+static void audio_set_958_mode(struct aiu_958_raw_setting *set)
+{
+	if (!set) {
+		printf("ERR, NULL set ptr!");
+		return;
+	}
+
+	WRITE_CBUS_REG(AIU_958_VALID_CTRL, 0);
+
+	audio_hw_set_958_pcm24(set);
+	WRITE_CBUS_REG(AIU_958_MISC, 0x2042);
+	/* pcm */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);
+#else
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);
+#endif
+	/* 16bit */
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 7, 1);
+	/* endian */
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3);
+	audio_hw_958_reset(0, 1);
+
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	if (0)
+		WRITE_CBUS_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 8, 1);
+#endif
+
+	WRITE_CBUS_REG(AIU_958_FORCE_LEFT, 1);
+}
+
+static void aml_spdif_play(void)
+{
+	struct aiu_958_raw_setting set;
+	struct aiu_958_channel_status chstat;
+	static long iec958buf[32 + 16];
+
+	set.chan_stat = &chstat;
+	set.chan_stat->chstat0_l = 0x0100;
+	set.chan_stat->chstat0_r = 0x0100;
+	set.chan_stat->chstat1_l = 0X200;
+	set.chan_stat->chstat1_r = 0X200;
+	audio_hw_958_enable(0);
+
+	memset(iec958buf, 0, sizeof(iec958buf));
+	audio_set_958outbuf(((long)iec958buf+ 63) & (~63), 128);
+	audio_set_958_mode(&set);
+
+	audio_hw_958_enable(1);
+}
+
+int aml_audio_init(void)
+{
+	aml_set_audio_spdif_clk();
+	aml_spdif_play();
+
+	return 0;
+}
+
diff --git a/arch/arm/cpu/armv8/gxtvbb/Makefile b/arch/arm/cpu/armv8/gxtvbb/Makefile
index 83756c5..bfaa50f 100644
--- a/arch/arm/cpu/armv8/gxtvbb/Makefile
+++ b/arch/arm/cpu/armv8/gxtvbb/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_AML_HDMITX20) += hdmitx20/
 obj-y	+= timer.o
 obj-y	+= mailbox.o
 obj-y   += gate_init.o
+obj-$(CONFIG_AML_HDMITX20)	+= sound.o
diff --git a/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/config.h b/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/config.h
index 6cf1a52..ccfed4d 100644
--- a/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/config.h
+++ b/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/config.h
@@ -28,14 +28,15 @@
 	* 0x1000D7FC: control wakeup enable
 	* after BL301 enable wakeup, bl30 store irq no. in share memory
 */
+#define WAKEUP_SRC_IRQ_ADDR_BASE		(CONFIG_RAM_END - 128)
 #define SECURE_TASK_SHARE_MEM_BASE		0x1000D400
-#define SECURE_TASK_SHARE_IRQ			0x1000D5FC
 #define SECURE_TASK_RESPONSE_MEM_BASE 0x1000D600
 #define SECURE_TASK_RESPONSE_WAKEUP_EN	0x1000D7FC
 #define HIGH_TASK_SHARE_MEM_BASE			0x1000D800
 #define HIGH_TASK_RESPONSE_MEM_BASE		0x1000DA00
 #define LOW_TASK_SHARE_MEM_BASE			0x1000DC00
 #define LOW_TASK_RESPONSE_MEM_BASE		0x1000DE00
+#define SCP_SHARE_TO_WARMBOOT			(0x1000DE00 - 32)
 
 /*
   * BL30/BL301 share memory command list
@@ -48,6 +49,7 @@
 #define SEC_TASK_GET_WAKEUP_SRC	0x6
 
 #define LOW_TASK_USR_DATA  0x100
+#define LOW_TASK_GET_USR_DATA  0x101
 #define LOW_TASK_USR_LED_TIMER 0x110
 
 	/*bl301 resume to BL30*/
diff --git a/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/scp_remote.c b/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/scp_remote.c
index cb001e0..1c3f59a 100644
--- a/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/scp_remote.c
+++ b/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/scp_remote.c
@@ -2,6 +2,7 @@
 #include "config.h"
 #include "registers.h"
 #include "task_apis.h"
+#include "suspend.h"
 
 #ifndef CONFIG_IR_REMOTE_USE_PROTOCOL
 #define CONFIG_IR_REMOTE_USE_PROTOCOL 0
@@ -287,7 +288,6 @@ void backuremote_register(void)
 
 void resume_remote_register(void)
 {
-	int tmp = 0;
 	writel(backuAO_RTI_PIN_MUX_REG, AO_RTI_PIN_MUX_REG);
 	writel(backuAO_IR_DEC_REG0, AO_MF_IR_DEC_REG0);
 	writel(backuAO_IR_DEC_REG1, AO_MF_IR_DEC_REG1);
@@ -295,20 +295,19 @@ void resume_remote_register(void)
 	writel(backuAO_IR_DEC_LDR_IDLE, AO_MF_IR_DEC_LDR_IDLE);
 	writel(backuAO_IR_DEC_BIT_0, AO_MF_IR_DEC_BIT_0);
 	writel(bakeuAO_IR_DEC_LDR_REPEAT, AO_MF_IR_DEC_LDR_REPEAT);
-	tmp = readl(AO_MF_IR_DEC_FRAME);
+	readl(AO_MF_IR_DEC_FRAME);
 }
 
 static int ir_remote_init_32k_mode(void)
 {
-	int tmp = 0;
 	//volatile unsigned int status,data_value;
 	int val = readl(AO_RTI_PIN_MUX_REG);
 	writel((val | (1 << 12)), AO_RTI_PIN_MUX_REG);
 	set_remote_mode(CONFIG_IR_REMOTE_USE_PROTOCOL);
 	//status = readl(AO_MF_IR_DEC_STATUS);
-	tmp = readl(AO_MF_IR_DEC_STATUS);
+	readl(AO_MF_IR_DEC_STATUS);
 	//data_value = readl(AO_MF_IR_DEC_FRAME);
-	tmp = readl(AO_MF_IR_DEC_FRAME);
+	readl(AO_MF_IR_DEC_FRAME);
 
 	//step 2 : request nec_remote irq  & enable it
 	return 0;
@@ -339,24 +338,31 @@ static int init_remote(void)
 	return 0;
 }
 
+extern unsigned int scan_remote_key[1];
+
 static int remote_detect_key(void)
 {
 	unsigned power_key;
 	int j;
+	unsigned *irq = (unsigned *)SCP_SHARE_TO_WARMBOOT;
 #if 1
 	if (((readl(AO_IR_DEC_STATUS)) >> 3) & 0x1) {
 		power_key = readl(AO_IR_DEC_FRAME);
 		for (j = 0; j < CONFIG_IR_REMOTE_POWER_UP_KEY_CNT; j++) {
-		if ((power_key & IR_POWER_KEY_MASK) == kk[j])
-		return 1;
+			if ((power_key & IR_POWER_KEY_MASK) == kk[j]) {
+				irq[IRQ_AO_IR_DEC]  = kk[j];
+				return 1;
+			}
 		}
 	}
 #endif
 	if (((readl(AO_MF_IR_DEC_STATUS)) >> 3) & 0x1) {
 		power_key = readl(AO_MF_IR_DEC_FRAME);
 		for (j = 0; j < CONFIG_IR_REMOTE_POWER_UP_KEY_CNT; j++) {
-		if ((power_key&IR_POWER_KEY_MASK) == kk[j])
-			return 1;
+			if ((power_key&IR_POWER_KEY_MASK) == kk[j]) {
+				irq[IRQ_AO_IR_DEC] = kk[j];
+				return 1;
+			}
 		}
 	}
 	return 0;
diff --git a/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/suspend.h b/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/suspend.h
index 3bcf03b..fb851ab 100644
--- a/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/suspend.h
+++ b/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/suspend.h
@@ -59,6 +59,19 @@ static void inline aml_update_bits(unsigned int  reg, unsigned int mask, unsigne
 #define GPIO_IRQ_FALLING_EDGE	2
 #define GPIO_IRQ_RISING_EDGE		3
 
+enum {
+	IRQ_TIMERA = 0,
+	IRQ_GPIO0,
+	IRQ_GPIO1,
+	IRQ_GPIO2,
+	IRQ_GPIO3,
+	IRQ_AO_IR_DEC,
+	IRQ_AO_CEC,
+	IRQ_AO_GPIO0,
+	IRQ_AO_GPIO1,
+	IRQ_AO_TIMERA,
+	WAKE_UP_MAX = 32,
+};
 
 /* M3 CPU has 2 ao-gpio-irq, 4 gpio-irq*/
 #define GPIO_WAKEUP_MAX		6
diff --git a/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/user_task.c b/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/user_task.c
index e6193fe..b0657d1 100644
--- a/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/user_task.c
+++ b/arch/arm/cpu/armv8/gxtvbb/firmware/scp_task/user_task.c
@@ -2,6 +2,8 @@
 #include "data.h"
 #include "registers.h"
 #include "task_apis.h"
+#include "suspend.h"
+
 
 #define TASK_ID_LOW_MB	2
 #define TASK_ID_HIGH_MB	3
@@ -136,6 +138,13 @@ void scp_led_register(struct scp_led *led)
 {
 	g_led = led;
 }
+unsigned int scan_remote_key[1] ={0x5A5A5A5A};
+struct user_data {
+	unsigned int status;
+#define MAX_DVFS_OPPS		16
+	unsigned int count;
+	unsigned int buf1[MAX_DVFS_OPPS];
+} buf_user;
 
 void process_low_task(unsigned command)
 {
@@ -144,6 +153,7 @@ void process_low_task(unsigned command)
 	unsigned *response =
 	    (unsigned *)(&(low_task_share_mem[TASK_RESPONSE_OFFSET]));
 	unsigned para1;
+	unsigned *irq = (unsigned *)SCP_SHARE_TO_WARMBOOT;
 	uart_puts("into process_low_task \n");
 
 	if (command == LOW_TASK_GET_DVFS_INFO) {
@@ -170,6 +180,13 @@ void process_low_task(unsigned command)
 		if (g_led && g_led->timer_proc)
 			g_led->timer_proc(g_led->count++);
 		dbg_prints("LED timer...\n");
+	}else if ((command & 0xffff) == LOW_TASK_GET_USR_DATA) {
+		if ((command >> 16) == SCPI_CL_POWER) {
+			buf_user.count = 1;
+			buf_user.buf1[0] = irq[IRQ_AO_IR_DEC];
+			*(response + 1) = sizeof(struct user_data);
+			memcpy((char *)(response+2), &buf_user, sizeof(struct user_data));
+		}
 	}
 }
 
@@ -187,7 +204,7 @@ void low_task(void)
 	while (1) {
 		/* do low task process */
 		command = *pcommand;
-		dbg_print("low task comd=0x",command);
+		dbg_print("low command=0x\n", command);
 		if (command) {
 			process_low_task(command);
 
diff --git a/arch/arm/cpu/armv8/gxtvbb/hdmitx20/hdmitx_set.c b/arch/arm/cpu/armv8/gxtvbb/hdmitx20/hdmitx_set.c
index 94d996b..05c0f4c 100644
--- a/arch/arm/cpu/armv8/gxtvbb/hdmitx20/hdmitx_set.c
+++ b/arch/arm/cpu/armv8/gxtvbb/hdmitx20/hdmitx_set.c
@@ -23,6 +23,7 @@
 #include <asm/io.h>
 #include <asm/arch/register.h>
 #include <amlogic/hdmi.h>
+#include <amlogic/sound.h>
 #include "hdmitx_reg.h"
 #include "hdmitx_tvenc.h"
 #include "mach_reg.h"
@@ -87,6 +88,7 @@ static void hdelay(int us)
 #define msleep(i)   hdelay(i)
 
 static void hdmitx_set_hw(struct hdmitx_dev *hdev);
+static int hdmitx_set_audmode(struct hdmitx_dev *hdev);
 
 // Internal functions:
 static void hdmitx_csc_config (unsigned char input_color_format,
@@ -195,10 +197,10 @@ static int read_edid_8bytes(unsigned char *rx_edid, unsigned char addr)
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGADDR, 0x30);
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGPTR, 0);
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, addr & 0xff);
-	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 3);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 2);
 	timeout = 0;
 	while ((!(hdmitx_rd_reg(HDMITX_DWC_IH_I2CM_STAT0) & (1 << 1))) && (timeout < 3)) {
-		mdelay(2);
+		_udelay(2000);
 		timeout ++;
 	}
 	if (timeout == 3) {
@@ -218,7 +220,8 @@ static void ddc_init(void)
 	static int ddc_init_flag;
 	unsigned int data32 = 0;
 
-
+	hdmitx_hw_init();
+	_udelay(200);
 	if (ddc_init_flag)
 		return;
 	else
@@ -387,10 +390,12 @@ void hdmi_tx_init(void)
 
 void hdmi_tx_set(struct hdmitx_dev *hdev)
 {
+	aml_audio_init(); /* Init audio hw firstly */
 	hdmitx_hw_init();
 	hdmitx_debug();
 	ddc_init();
 	hdmitx_set_hw(hdev);
+	hdmitx_set_audmode(hdev);
 	hdmitx_debug();
 	return;
 
@@ -415,6 +420,154 @@ static void hdcp14_init(void)
 	);
 }
 
+static int hdmitx_set_audmode(struct hdmitx_dev *hdev)
+{
+	int i;
+	unsigned int data32;
+	unsigned int aud_n_para;
+
+	pr_info("hdmtix: set audio\n");
+	hdmitx_set_reg_bits(HDMITX_TOP_CLK_CNTL, 3, 2, 2);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 0, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 3, 1);
+
+	/* Disable HDMI audio clock input and its I2S input */
+	hd_write_reg(P_AIU_HDMI_CLK_DATA_CTRL, 0);
+
+	/* Enable HDMI I2S input from the selected source */
+	hd_write_reg(P_AIU_HDMI_CLK_DATA_CTRL, 0x22);
+
+	/* I2S Sampler config */
+	data32 = 0;
+/* [  3] fifo_empty_mask: 0=enable int; 1=mask int. */
+	data32 |= (1 << 3);
+/* [  2] fifo_full_mask: 0=enable int; 1=mask int. */
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT, data32);
+
+	data32 = 0;
+/* [  4] fifo_overrun_mask: 0=enable int; 1=mask int.
+ * Enable it later when audio starts. */
+	data32 |= (1 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT1,  data32);
+/* [  5] 0=select SPDIF; 1=select I2S. */
+	data32 = 0;
+	data32 |= (0 << 7);  /* [  7] sw_audio_fifo_rst */
+	data32 |= (0 << 5);
+	data32 |= (0 << 0);  /* [3:0] i2s_in_en: enable it later in test.c */
+/* if enable it now, fifo_overrun will happen, because packet don't get sent
+ * out until initial DE detected. */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF0, data32);
+
+	data32 = 0;
+	data32 |= (0 << 5);  /* [7:5] i2s_mode: 0=standard I2S mode */
+	data32 |= (24 << 0);  /* [4:0] i2s_width */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF1, data32);
+
+	data32 = 0;
+	data32 |= (0 << 1);  /* [  1] NLPCM */
+	data32 |= (0 << 0);  /* [  0] HBR */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF2, data32);
+
+	/* spdif sampler config */
+	/* [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int. */
+	/* [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int. */
+	data32 = 0;
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT,  data32);
+	/* [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int. */
+	data32 = 0;
+	data32 |= (0 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT1, data32);
+
+	data32 = 0;
+	data32 |= (0 << 7);  /* [  7] sw_audio_fifo_rst */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF0, data32);
+
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0, 0, 0, 4); /* CT */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0, 1,	4, 3); /* CC */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 0, 3); /* SF */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 4, 2); /* SS */
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF3, 0);
+
+	/* audio packetizer config */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, 0);
+
+	/* 48kHz 2ch PCM as default */
+	aud_n_para = 6144;
+	switch (hdev->vic) {
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p30_256x135:
+		aud_n_para = 5120;
+		break;
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_3840x2160p50_64x27:
+	case HDMI_3840x2160p60_64x27:
+		if (hdev->para->cs == HDMI_COLOR_FORMAT_420)
+			aud_n_para = 5120;
+		break;
+	default:
+		break;
+	}
+
+	/* ACR packet configuration */
+	data32 = 0;
+	data32 |= (1 << 7);  /* [  7] ncts_atomic_write */
+	data32 |= (0 << 0);  /* [3:0] AudN[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N3, data32);
+
+	data32 = 0;
+	data32 |= (0 << 7);  /* [7:5] N_shift */
+	data32 |= (0 << 4);  /* [  4] CTS_manual */
+	data32 |= (0 << 0);  /* [3:0] manual AudCTS[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS3, data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS2, 0); /* manual AudCTS[15:8] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CTS1, 0); /* manual AudCTS[7:0] */
+
+	data32 = 0;
+	data32 |= (1 << 7);  /* [  7] ncts_atomic_write */
+	data32 |= (((aud_n_para>>16)&0xf) << 0);  /* [3:0] AudN[19:16] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N3, data32);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N2, (aud_n_para>>8)&0xff); /* AudN[15:8] */
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N1, aud_n_para&0xff); /* AudN[7:0] */
+	for (i = 0; i < 9; i++)
+		hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS0+i, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSV, 0x11);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS7, 0x02);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS8, 0xd2);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS3, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDSCHNLS5, 0x00);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7,
+		0x2, 0, 4); /*CSB 27:24*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7, 0x0, 6, 2); /*CSB 31:30*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS7, 0x0, 4, 2); /*CSB 29:28*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS8, 0x2, 0, 4); /*CSB 35:32*/
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCHNLS8,  /* CSB 39:36 */
+		0xd, 4, 4);
+
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 0, 5, 1);
+	/* reset audio fifo */
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_CONF0, 0, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 0, 7, 1);
+	hdmitx_wr_reg(HDMITX_DWC_MC_SWRSTZREQ, 0xe7);
+	/* need reset again */
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 1, 7, 1);
+	hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF0, 0, 7, 1);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_N1, hdmitx_rd_reg(HDMITX_DWC_AUD_N1));
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO3, 1, 0, 1);
+	return 0;
+}
+
 #define NUM_INT_VSYNC   INT_VEC_VIU1_VSYNC
 
 static unsigned long modulo(unsigned long a, unsigned long b);
@@ -490,7 +643,7 @@ static void config_hdmi20_tx ( enum hdmi_vic vic, struct hdmi_format_para *para,
     data32 |= ((((input_color_format ==HDMI_COLOR_FORMAT_422) &&
                  (output_color_format!=HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 4);  // [5:4] intmode
     data32 |= ((((input_color_format !=HDMI_COLOR_FORMAT_422) &&
-                 (output_color_format==HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 0);  // [1:0] decmode
+                 (output_color_format==HDMI_COLOR_FORMAT_422))? 1 : 0 ) << 0);  // [1:0] decmode
 	hdmitx_wr_reg(HDMITX_DWC_CSC_CFG, data32);
 
 	hdmitx_csc_config(input_color_format, output_color_format, color_depth);
@@ -1181,7 +1334,6 @@ static void enc_vpu_bridge_reset(int mode)
 {
     unsigned int wr_clk = 0;
 
-    printk("%s[%d]\n", __func__, __LINE__);
     wr_clk = (hd_read_reg(P_VPU_HDMI_SETTING) & 0xf00) >> 8;
     if (mode) {
         hd_write_reg(P_ENCP_VIDEO_EN, 0);
diff --git a/arch/arm/cpu/armv8/gxtvbb/sound.c b/arch/arm/cpu/armv8/gxtvbb/sound.c
new file mode 100644
index 0000000..331631a
--- /dev/null
+++ b/arch/arm/cpu/armv8/gxtvbb/sound.c
@@ -0,0 +1,197 @@
+/*
+ * arch/arm/cpu/armv8/gxtvbb/sound.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/arch/io.h>
+#include <asm/arch/secure_apb.h>
+#include <common.h>
+#include <malloc.h>
+#include <amlogic/sound.h>
+
+static int reg_update_bits(unsigned long reg, unsigned int mask, unsigned int value)
+{
+	bool change;
+	unsigned int old, new;
+
+	old = readl(reg);
+
+	new = (old & ~mask) | (value & mask);
+	change = old != new;
+	if (change)
+		writel(new, reg);
+
+	return change;
+}
+
+struct aiu_958_channel_status {
+	unsigned short chstat0_l;
+	unsigned short chstat1_l;
+	unsigned short chstat0_r;
+	unsigned short chstat1_r;
+};
+
+struct aiu_958_raw_setting {
+	unsigned short int_flag;
+	unsigned short bpf;
+	unsigned short brst;
+	unsigned short length;
+	unsigned short paddsize;
+	struct aiu_958_channel_status *chan_stat;
+};
+
+static void aml_set_audio_spdif_clk(void)
+{
+	int i;
+	// gate the clock off
+	reg_update_bits(HHI_AUD_CLK_CNTL, 1 << 8, 0);
+
+	/*--- IEC958 clock  configuration, use MPLL1--- */
+	//IEC958_USE_CNTL
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 1 << 27, 1 << 27);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 3 << 25, 2 << 25);
+
+	// Configure Multi-Phase PLL1
+	writel(0x14d616, HHI_MPLL_CNTL8);
+	// Set the XD value
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 0xff << 16, (4-1) << 16);
+	reg_update_bits(HHI_AUD_CLK_CNTL2, 1 << 24, 1 << 24);
+
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+
+	// gate the clock on
+	reg_update_bits(HHI_AUD_CLK_CNTL, 1 << 8, 1 << 8);
+	/* 958 divisor more, if true, divided by 2, 4, 6, 8 */
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 0, 12, 1);
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);
+	/* enable 958 divider */
+	WRITE_CBUS_REG_BITS(AIU_CLK_CTRL, 1, 1, 1);
+}
+
+static void audio_hw_958_enable(unsigned flag)
+{
+	WRITE_CBUS_REG(AIU_RST_SOFT, 0x04);
+	WRITE_CBUS_REG(AIU_958_FORCE_LEFT, 0);
+	if (flag) {
+		WRITE_CBUS_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
+		WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
+	} else {
+		WRITE_CBUS_REG(AIU_958_DCU_FF_CTRL, 0);
+		WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);
+	}
+}
+
+static void audio_set_958outbuf(long addr, size_t size)
+{
+	WRITE_CBUS_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
+	WRITE_CBUS_REG(AIU_MEM_IEC958_RD_PTR, addr & 0xffffffc0);
+
+	/* this is for 16bit 2 channel */
+	WRITE_CBUS_REG(AIU_MEM_IEC958_END_PTR,
+				(addr & 0xffffffc0) +
+				(size & 0xffffffc0) - 8);
+
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_MASKS, 0xffff, 0, 16);
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 1, 1);
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 1);
+
+	WRITE_CBUS_REG(AIU_MEM_IEC958_BUF_CNTL, 1);
+	WRITE_CBUS_REG(AIU_MEM_IEC958_BUF_CNTL, 0);
+}
+static void set_958_channel_status(struct aiu_958_channel_status *set)
+{
+	if (set) {
+		WRITE_CBUS_REG(AIU_958_CHSTAT_L0, set->chstat0_l);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_L1, set->chstat1_l);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_R0, set->chstat0_r);
+		WRITE_CBUS_REG(AIU_958_CHSTAT_R1, set->chstat1_r);
+	}
+}
+
+static void audio_hw_set_958_pcm24(struct aiu_958_raw_setting *set)
+{
+	if (set) {
+		/* in pcm mode, set bpf to 128 */
+		WRITE_CBUS_REG(AIU_958_BPF, 0x80);
+		set_958_channel_status(set->chan_stat);
+	}
+}
+
+static void audio_hw_958_reset(unsigned slow_domain, unsigned fast_domain)
+{
+	WRITE_CBUS_REG(AIU_958_DCU_FF_CTRL, 0);
+	WRITE_CBUS_REG(AIU_RST_SOFT, (slow_domain << 3) | (fast_domain << 2));
+}
+
+static void audio_set_958_mode(struct aiu_958_raw_setting *set)
+{
+	if (!set) {
+		printf("ERR, NULL set ptr!");
+		return;
+	}
+
+	WRITE_CBUS_REG(AIU_958_VALID_CTRL, 0);
+
+	audio_hw_set_958_pcm24(set);
+	WRITE_CBUS_REG(AIU_958_MISC, 0x2042);
+	/* pcm */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);
+#else
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);
+#endif
+	/* 16bit */
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 7, 1);
+	/* endian */
+	WRITE_CBUS_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3);
+	audio_hw_958_reset(0, 1);
+
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	if (0)
+		WRITE_CBUS_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 8, 1);
+#endif
+
+	WRITE_CBUS_REG(AIU_958_FORCE_LEFT, 1);
+}
+
+static void aml_spdif_play(void)
+{
+	struct aiu_958_raw_setting set;
+	struct aiu_958_channel_status chstat;
+	static long iec958buf[32 + 16];
+
+	set.chan_stat = &chstat;
+	set.chan_stat->chstat0_l = 0x0100;
+	set.chan_stat->chstat0_r = 0x0100;
+	set.chan_stat->chstat1_l = 0X200;
+	set.chan_stat->chstat1_r = 0X200;
+	audio_hw_958_enable(0);
+
+	memset(iec958buf, 0, sizeof(iec958buf));
+	audio_set_958outbuf(((long)iec958buf+ 63) & (~63), 128);
+	audio_set_958_mode(&set);
+
+	audio_hw_958_enable(1);
+}
+
+int aml_audio_init(void)
+{
+	aml_set_audio_spdif_clk();
+	aml_spdif_play();
+
+	return 0;
+}
+
diff --git a/arch/arm/cpu/armv8/txl/Makefile b/arch/arm/cpu/armv8/txl/Makefile
new file mode 100644
index 0000000..83756c5
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/Makefile
@@ -0,0 +1,9 @@
+
+obj-y	:= clock.o sdio.o gpio.o
+obj-y	+= usb.o
+obj-y   += bl31_apis.o
+obj-y	+= watchdog.o
+obj-$(CONFIG_AML_HDMITX20) += hdmitx20/
+obj-y	+= timer.o
+obj-y	+= mailbox.o
+obj-y   += gate_init.o
diff --git a/arch/arm/cpu/armv8/txl/bl31_apis.c b/arch/arm/cpu/armv8/txl/bl31_apis.c
new file mode 100644
index 0000000..91221b9
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/bl31_apis.c
@@ -0,0 +1,338 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/bl31_apis.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+/*
+ * Trustzone API
+ *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * Author: Platform-BJ@amlogic.com
+ *
+ */
+
+#include <asm/arch/io.h>
+#include <asm/arch/efuse.h>
+#include <asm/cache.h>
+/* #include <asm/system.h> */
+#include <asm/arch/bl31_apis.h>
+
+static long sharemem_input_base;
+static long sharemem_output_base;
+
+long get_sharemem_info(unsigned long function_id)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc    #0\n"
+		: "+r" (function_id));
+
+	return function_id;
+}
+
+#ifdef CONFIG_EFUSE
+int32_t meson_trustzone_efuse(struct efuse_hal_api_arg *arg)
+{
+	int ret;
+	unsigned cmd, offset, size;
+	unsigned long *retcnt = (unsigned long *)(arg->retcnt_phy);
+
+	if (!sharemem_input_base)
+		sharemem_input_base =
+			get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+	if (!sharemem_output_base)
+		sharemem_output_base =
+			get_sharemem_info(GET_SHARE_MEM_OUTPUT_BASE);
+
+	if (arg->cmd == EFUSE_HAL_API_READ)
+		cmd = EFUSE_READ;
+	else if (arg->cmd == EFUSE_HAL_API_WRITE)
+		cmd = EFUSE_WRITE;
+	else
+		cmd = EFUSE_WRITE_PATTERN;
+	offset = arg->offset;
+	size = arg->size;
+
+	if (arg->cmd == EFUSE_HAL_API_WRITE)
+		memcpy((void *)sharemem_input_base,
+		       (const void *)arg->buffer_phy, size);
+		asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = cmd;
+	register uint64_t x1 asm("x1") = offset;
+	register uint64_t x2 asm("x2") = size;
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    "smc    #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2));
+	} while (0);
+	ret = x0;
+	*retcnt = x0;
+
+	if ((arg->cmd == EFUSE_HAL_API_READ) && (ret != 0))
+		memcpy((void *)arg->buffer_phy,
+		       (const void *)sharemem_output_base, ret);
+
+	if (!ret)
+		return -1;
+	else
+		return 0;
+}
+
+int32_t meson_trustzone_efuse_get_max(struct efuse_hal_api_arg *arg)
+{
+	int32_t ret;
+	unsigned cmd;
+
+	if (arg->cmd == EFUSE_HAL_API_USER_MAX)
+		cmd = EFUSE_USER_MAX;
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = cmd;
+
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    "smc    #0\n"
+		    : "=r"(x0)
+		    : "r"(x0));
+	} while (0);
+	ret = x0;
+
+	if (!ret)
+		return -1;
+	else
+		return ret;
+}
+
+ssize_t meson_trustzone_efuse_writepattern(const char *buf, size_t count)
+{
+	struct efuse_hal_api_arg arg;
+	unsigned long retcnt;
+
+	if (count != EFUSE_BYTES)
+		return 0;	/* Past EOF */
+
+	arg.cmd = EFUSE_HAL_API_WRITE_PATTERN;
+	arg.offset = 0;
+	arg.size = count;
+	arg.buffer_phy = (unsigned long)buf;
+	arg.retcnt_phy = (unsigned long)&retcnt;
+	int ret;
+	ret = meson_trustzone_efuse(&arg);
+	return ret;
+}
+
+#endif
+
+
+
+
+uint64_t meson_trustzone_efuse_check(unsigned char *addr)
+{
+	uint64_t ret = 0;
+	struct sram_hal_api_arg arg = {};
+
+	arg.cmd = SRAM_HAL_API_CHECK_EFUSE;
+	arg.req_len = 0x1000000;
+	arg.res_len = 0;
+	arg.req_phy_addr = (unsigned long)addr;
+	arg.res_phy_addr = (unsigned long)NULL;
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = CALL_TRUSTZONE_HAL_API;
+	register uint64_t x1 asm("x1") = TRUSTZONE_HAL_API_SRAM;
+	register uint64_t x2 asm("x2") = (unsigned long)(&arg);
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    "smc #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2));
+	} while (0);
+
+	ret = x0;
+
+	return ret;
+}
+
+void debug_efuse_cmd(unsigned long cmd)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc    #0\n"
+		: : "r" (cmd));
+}
+
+
+void bl31_debug_efuse_write_pattern(const char *buf)
+{
+	if (!sharemem_input_base)
+		sharemem_input_base =
+			get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+	memcpy((void *)sharemem_input_base, (const void *)buf, 512);
+
+	debug_efuse_cmd(DEBUG_EFUSE_WRITE_PATTERN);
+}
+
+void bl31_debug_efuse_read_pattern(char *buf)
+{
+	if (!sharemem_output_base)
+		sharemem_output_base =
+			get_sharemem_info(GET_SHARE_MEM_OUTPUT_BASE);
+	debug_efuse_cmd(DEBUG_EFUSE_READ_PATTERN);
+
+	memcpy((void *)buf, (const void *)sharemem_output_base, 512);
+}
+
+void aml_set_jtag_state(unsigned state, unsigned select)
+{
+	uint64_t command;
+	if (state == JTAG_STATE_ON)
+		command = JTAG_ON;
+	else
+		command = JTAG_OFF;
+	asm __volatile__("" : : : "memory");
+
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		"smc    #0\n"
+		: : "r" (command), "r"(select));
+}
+
+unsigned aml_get_reboot_reason(void)
+{
+	unsigned reason;
+	uint64_t ret;
+
+	register uint64_t x0 asm("x0") = GET_REBOOT_REASON;
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc #0\n"
+		:"+r"(x0));
+		ret = x0;
+		reason = (unsigned)(ret&0xffffffff);
+		return reason;
+}
+
+unsigned aml_reboot(uint64_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2)
+{
+	register long x0 asm("x0") = function_id;
+	register long x1 asm("x1") = arg0;
+	register long x2 asm("x2") = arg1;
+	register long x3 asm("x3") = arg2;
+	asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+			__asmeq("%2", "x2")
+			__asmeq("%3", "x3")
+			"smc	#0\n"
+		: "+r" (x0)
+		: "r" (x1), "r" (x2), "r" (x3));
+
+	return function_id;
+}
+
+unsigned long aml_sec_boot_check(unsigned long nType,
+	unsigned long pBuffer,
+	unsigned long nLength,
+	unsigned long nOption)
+{
+	uint64_t ret = 1;
+
+//#define AML_SECURE_LOG_TE
+
+#if defined(AML_SECURE_LOG_TE)
+	#define AML_GET_TE(a) do{a = *((volatile unsigned int*)0xc1109988);}while(0);
+	unsigned nT1,nT2,nT3;
+#else
+	#define AML_GET_TE(...)
+#endif
+
+	AML_GET_TE(nT1);
+
+	asm __volatile__("" : : : "memory");
+
+	register uint64_t x0 asm("x0") = AML_DATA_PROCESS;
+	register uint64_t x1 asm("x1") = nType;
+	register uint64_t x2 asm("x2") = pBuffer;
+	register uint64_t x3 asm("x3") = nLength;
+	register uint64_t x4 asm("x4") = nOption;
+
+	do {
+		asm volatile(
+		    __asmeq("%0", "x0")
+		    __asmeq("%1", "x0")
+		    __asmeq("%2", "x1")
+		    __asmeq("%3", "x2")
+		    __asmeq("%4", "x3")
+		    __asmeq("%5", "x4")
+		    "smc #0\n"
+		    : "=r"(x0)
+		    : "r"(x0), "r"(x1), "r"(x2),"r"(x3),"r"(x4));
+	} while (0);
+
+	ret = x0;
+
+	AML_GET_TE(nT2);;
+
+	flush_dcache_range((unsigned long )pBuffer, (unsigned long )pBuffer+nLength);
+
+	AML_GET_TE(nT3);
+
+#if defined(AML_SECURE_LOG_TE)
+	printf("aml log : dec use %d(us) , flush cache used %d(us)\n",
+		nT2 - nT1, nT3 - nT2);
+#endif
+
+	return ret;
+
+}
+
+void set_usb_boot_function(unsigned long command)
+{
+	register long x0 asm("x0") = SET_USB_BOOT_FUNC;
+	register long x1 asm("x1") = command;
+
+	asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+			"smc	#0\n"
+		: "+r" (x0)
+		: "r" (x1));
+}
+void aml_system_off(void)
+{
+	/* TODO: Add poweroff capability */
+	aml_reboot(0x82000042, 1, 0, 0);
+	aml_reboot(0x84000008, 0, 0, 0);
+}
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/clock.c b/arch/arm/cpu/armv8/txl/clock.c
new file mode 100644
index 0000000..1e491b3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/clock.c
@@ -0,0 +1,163 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/clock.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+//#include <asm/arch/io.h>
+#include <asm/arch/register.h>
+#include <asm/arch/clock.h>
+
+/*  !!must use nonzero value as default value. Otherwise it linked to bss segment,
+    but this segment not cleared to zero while running "board_init_f" */
+#define CLK_UNKNOWN (0xffffffff)
+
+__u32 get_rate_xtal(void)
+{
+	unsigned long clk;
+	clk = (readl(P_PREG_CTLREG0_ADDR) >> 4) & 0x3f;
+	clk = clk * 1000 * 1000;
+	return clk;
+}
+
+
+__u32 get_cpu_clk(void)
+{
+    static __u32 sys_freq=CLK_UNKNOWN;
+    if (sys_freq == CLK_UNKNOWN)
+    {
+        sys_freq=(clk_util_clk_msr(SYS_PLL_CLK)*1000000);
+    }
+    return sys_freq;
+}
+__u32 get_clk81(void)
+{
+	static __u32 clk81_freq=CLK_UNKNOWN;
+	if (clk81_freq == CLK_UNKNOWN)
+	{
+	    clk81_freq=(clk_util_clk_msr(CLK81)*1000000);
+	}
+    return clk81_freq;
+}
+__u32 get_clk_ddr(void)
+{
+   static __u32 freq=CLK_UNKNOWN;
+	if (freq == CLK_UNKNOWN)
+	{
+	    freq=(clk_util_clk_msr(DDR_PLL_CLK)*1000000);
+	}
+    return freq;
+}
+
+__u32 get_clk_ethernet_pad(void)
+{
+    static __u32 freq=CLK_UNKNOWN;
+    if (freq == CLK_UNKNOWN)
+    {
+        freq=(clk_util_clk_msr(MOD_ETH_CLK50_I)*1000000);
+    }
+    return freq;
+}
+
+__u32 get_clk_cts_eth_rmii(void)
+{
+    static __u32 freq=CLK_UNKNOWN;
+    if (freq == CLK_UNKNOWN)
+    {
+        freq=(clk_util_clk_msr(CTS_ETH_RMII)*1000000);
+    }
+    return freq;
+}
+
+__u32 get_misc_pll_clk(void)
+{
+    static __u32 freq=CLK_UNKNOWN;
+    if (freq == CLK_UNKNOWN)
+    {
+        freq=(clk_util_clk_msr(MISC_PLL_CLK)*1000000);
+    }
+    return freq;
+}
+
+unsigned long    clk_util_clk_msr( unsigned long   clk_mux )
+{
+
+	writel(0,P_MSR_CLK_REG0);
+    // Set the measurement gate to 64uS
+	clrsetbits_le32(P_MSR_CLK_REG0,0xffff,64-1);
+    // Disable continuous measurement
+    // disable interrupts
+    clrbits_le32(P_MSR_CLK_REG0,((1 << 18) | (1 << 17)));
+	clrsetbits_le32(P_MSR_CLK_REG0,(0xf<<20),(clk_mux<<20)|(1<<19)|(1<<16));
+
+	readl(P_MSR_CLK_REG0);
+    // Wait for the measurement to be done
+    while ( readl(P_MSR_CLK_REG0) & (1 << 31))  {};
+    // disable measuring
+	clrbits_le32(P_MSR_CLK_REG0,(1 << 16));
+	__u32 msr=(readl(P_MSR_CLK_REG2)+31)&0x000FFFFF;
+    // Return value in MHz*measured_val
+    return (msr>>6);
+}
+struct __clk_rate{
+    unsigned clksrc;
+    __u32 (*get_rate)(void);
+};
+struct __clk_rate clkrate[]={
+    {
+        .clksrc=SYS_PLL_CLK,
+        .get_rate=get_cpu_clk,
+    },
+    {
+        .clksrc=CLK81,
+        .get_rate=get_clk81,
+    },
+    {
+        .clksrc=DDR_PLL_CLK,
+        .get_rate=get_clk_ddr,
+    },
+    {
+        .clksrc=MOD_ETH_CLK50_I,
+        .get_rate=get_clk_ethernet_pad,
+    },
+    {
+        .clksrc=CTS_ETH_RMII,
+        .get_rate=get_clk_cts_eth_rmii,
+    },
+    {
+        .clksrc=MISC_PLL_CLK,
+        .get_rate=get_misc_pll_clk,
+    }
+};
+
+int clk_get_rate(unsigned clksrc)
+{
+	int i;
+	for (i = 0; i < sizeof(clkrate)/sizeof(clkrate[0]); i++)
+	{
+		  if (clksrc == clkrate[i].clksrc)
+			return clkrate[i].get_rate();
+   }
+	 return -1;
+}
+
+
+
diff --git a/arch/arm/cpu/armv8/txl/firmware/acs/Makefile b/arch/arm/cpu/armv8/txl/firmware/acs/Makefile
new file mode 100644
index 0000000..647f161
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/acs/Makefile
@@ -0,0 +1,429 @@
+#
+# Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# Redistributions of source code must retain the above copyright notice, this
+# list of conditions and the following disclaimer.
+#
+# Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation
+# and/or other materials provided with the distribution.
+#
+# Neither the name of ARM nor the names of its contributors may be used
+# to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+#
+# Default values for build configurations
+#
+
+include $(buildsrc)/config.mk
+include $(buildtree)/include/autoconf.mk
+include $(buildtree)/.config
+
+# Build verbosity
+V			:= 0
+# Debug build
+BUILD_TYPE		:= ${BL2_BUILD_TYPE}
+# Build architecture
+ARCH 			:= aarch64
+# Build platform
+#DEFAULT_PLAT		:= gx
+PLAT			:= ${SOC}
+export PLAT
+# SPD choice
+SPD			:= none
+# Base commit to perform code check on
+BASE_COMMIT		:= origin/master
+# NS timer register save and restore
+NS_TIMER_SWITCH		:= 0
+# By default, Bl1 acts as the reset handler, not BL31
+RESET_TO_BL31		:= 0
+
+# Checkpatch ignores
+CHECK_IGNORE		=	--ignore COMPLEX_MACRO
+
+CHECKPATCH_ARGS		=	--no-tree --no-signoff ${CHECK_IGNORE}
+CHECKCODE_ARGS		=	--no-patch --no-tree --no-signoff ${CHECK_IGNORE}
+
+ifeq (${V},0)
+	Q=@
+	CHECKCODE_ARGS	+=	--no-summary --terse
+else
+	Q=
+endif
+export Q
+
+ifeq (${GIT_VERSION},)
+	GIT_VERSION := $(shell git describe --abbrev=7 --dirty --always --tags)
+endif
+ifeq (${BUILDER},)
+	BUILDER := ${USER}@$(shell hostname)
+endif
+
+BL_COMMON_SOURCES	:=	common/bl_common.c			\
+				common/debug.c				\
+				lib/aarch64/cache_helpers.S		\
+				lib/aarch64/misc_helpers.S		\
+				lib/aarch64/tlb_helpers.S		\
+				lib/aarch64/xlat_helpers.c		\
+				lib/stdlib/std.c			\
+				lib/io_storage.c			\
+				plat/common/aarch64/platform_helpers.S
+
+BUILD_BASE		:=	$(buildtree)/firmware
+#BUILD_PLAT		:=	${BUILD_BASE}/${PLAT}
+#BUILD_PLAT		:=	$(buildtree)/board/${BOARDDIR}/firmware
+BUILD_PLAT		:=	$(buildtree)/${BOARDDIR}/firmware
+
+# Convenience function for adding build definitions
+# $(eval $(call add_define,FOO)) will have:
+# -DFOO if $(FOO) is empty; -DFOO=$(FOO) otherwise
+define add_define
+DEFINES			+=	-D$(1)$(if $(value $(1)),=$(value $(1)),)
+endef
+
+# Convenience function for verifying option has a boolean value
+# $(eval $(call assert_boolean,FOO)) will assert FOO is 0 or 1
+define assert_boolean
+$(and $(patsubst 0,,$(value $(1))),$(patsubst 1,,$(value $(1))),$(error $(1) must be boolean))
+endef
+
+ifeq (${PLAT},)
+  $(error "Error: Unknown platform. Please use PLAT=<platform name> to specify the platform.")
+endif
+
+all: msg_start
+
+msg_start:
+	@echo "Building ${BOARDDIR}/acs.bin"
+
+#include plat/${PLAT}/platform.mk
+#ifdef BL2_SOURCES
+NEED_BL2 := yes
+include acs.mk
+#endif
+
+# Include SPD Makefile if one has been specified
+ifneq (${SPD},none)
+  # We expect to locate an spd.mk under the specified SPD directory
+  SPD_MAKE		:=	$(shell m="services/spd/${SPD}/${SPD}.mk"; [ -f "$$m" ] && echo "$$m")
+
+  ifeq (${SPD_MAKE},)
+    $(error Error: No services/spd/${SPD}/${SPD}.mk located)
+  endif
+  $(info Including ${SPD_MAKE})
+  include ${SPD_MAKE}
+
+  # If there's BL32 companion for the chosen SPD, and the SPD wants to build the
+  # BL2 from source, we expect that the SPD's Makefile would set NEED_BL32
+  # variable to "yes"
+endif
+
+.PHONY:			all msg_start clean realclean distclean cscope locate-checkpatch checkcodebase checkpatch fiptool fip
+.SUFFIXES:
+
+INCLUDES		+= -Iinclude/bl2			\
+				-Iinclude/bl31			\
+				-Iinclude/common		\
+				-Iinclude/drivers		\
+				-Iinclude/drivers/arm		\
+				-Iinclude/drivers/serial		\
+				-Iinclude/lib			\
+				-Iinclude/lib/aarch64		\
+				-Iinclude/plat/common		\
+				-Iinclude/stdlib		\
+				-Iinclude/stdlib/sys		\
+				${PLAT_INCLUDES}		\
+				${SPD_INCLUDES}
+
+# Process DEBUG flag
+$(eval $(call assert_boolean,DEBUG))
+$(eval $(call add_define,DEBUG))
+ifeq (${DEBUG},0)
+  $(eval $(call add_define,NDEBUG))
+else
+CFLAGS			+= 	-g
+ASFLAGS			+= 	-g -Wa,--gdwarf-2
+endif
+
+# Process NS_TIMER_SWITCH flag
+$(eval $(call assert_boolean,NS_TIMER_SWITCH))
+$(eval $(call add_define,NS_TIMER_SWITCH))
+
+# Process RESET_TO_BL31 flag
+$(eval $(call assert_boolean,RESET_TO_BL31))
+$(eval $(call add_define,RESET_TO_BL31))
+
+#VPATH_LIST = $(buildsrc)/board/$(BOARDDIR)
+VPATH_LIST = $(buildsrc)/$(BOARDDIR)
+VPATH_LIST:=$(VPATH_LIST:%=%/firmware/)
+
+vpath %.c $(VPATH_LIST)
+
+ASFLAGS			+= 	-nostdinc -ffreestanding -Wa,--fatal-warnings	\
+				-mgeneral-regs-only -D__ASSEMBLY__		\
+				${DEFINES} ${INCLUDES}
+CFLAGS			+= 	-nostdinc -pedantic -ffreestanding -Wall	\
+				-Werror -mgeneral-regs-only -std=c99 -c -Os	\
+				${DEFINES} ${INCLUDES} $(VPATH_LIST:%=-I%)
+CFLAGS			+=	-ffunction-sections -fdata-sections
+ASFLAGS			+= 	${FIRMWARE_CPPFLAGS}
+CFLAGS			+= 	${FIRMWARE_CPPFLAGS}
+CFLAGS			+= 	-Wno-unused
+
+LDFLAGS			+=	--fatal-warnings -O1
+LDFLAGS			+=	--gc-sections
+
+CC			:=	${CROSS_COMPILE}gcc
+CPP			:=	${CROSS_COMPILE}cpp
+AS			:=	${CROSS_COMPILE}gcc
+AR			:=	${CROSS_COMPILE}ar
+LD			:=	${CROSS_COMPILE}ld
+OC			:=	${CROSS_COMPILE}objcopy
+OD			:=	${CROSS_COMPILE}objdump
+NM			:=	${CROSS_COMPILE}nm
+PP			:=	${CROSS_COMPILE}gcc -E ${CFLAGS}
+
+# Variables for use with Firmware Image Package
+FIPTOOLPATH		?=	tools/fip_create
+FIPTOOL			?=	${FIPTOOLPATH}/fip_create
+fiptool:		${FIPTOOL}
+fip:			${BUILD_PLAT}/fip.bin
+
+locate-checkpatch:
+ifndef CHECKPATCH
+	$(error "Please set CHECKPATCH to point to the Linux checkpatch.pl file, eg: CHECKPATCH=../linux/script/checkpatch.pl")
+else
+ifeq (,$(wildcard ${CHECKPATCH}))
+	$(error "The file CHECKPATCH points to cannot be found, use eg: CHECKPATCH=../linux/script/checkpatch.pl")
+endif
+endif
+
+clean:
+			@echo "  CLEAN"
+			${Q}rm -rf ${BUILD_PLAT}
+			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH} clean
+
+realclean distclean:
+			@echo "  REALCLEAN"
+			${Q}rm -rf ${BUILD_BASE}
+			${Q}rm -f ${CURDIR}/cscope.*
+			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH} clean
+
+checkcodebase:		locate-checkpatch
+			@echo "  CHECKING STYLE"
+			@if test -d .git ; then	\
+				git ls-files | while read GIT_FILE ; do ${CHECKPATCH} ${CHECKCODE_ARGS} -f $$GIT_FILE ; done ;	\
+			 else			\
+				 find . -type f -not -iwholename "*.git*" -not -iwholename "*build*" -exec ${CHECKPATCH} ${CHECKCODE_ARGS} -f {} \; ;	\
+			 fi
+
+checkpatch:		locate-checkpatch
+			@echo "  CHECKING STYLE"
+			@git format-patch --stdout ${BASE_COMMIT} | ${CHECKPATCH} ${CHECKPATCH_ARGS} - || true
+
+${FIPTOOL}:
+			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH}
+			@echo
+			@echo "Built $@ successfully"
+			@echo
+
+define match_goals
+$(strip $(foreach goal,$(1),$(filter $(goal),$(MAKECMDGOALS))))
+endef
+
+# List of rules that involve building things
+BUILD_TARGETS := all bl1 bl2 bl31 bl32 fip
+
+# Does the list of goals specified on the command line include a build target?
+ifneq ($(call match_goals,${BUILD_TARGETS}),)
+IS_ANYTHING_TO_BUILD := 1
+endif
+
+define MAKE_C
+
+$(eval OBJ := $(1)/$(patsubst %.c,%.o,$(notdir $(2))))
+$(eval PREREQUISITES := $(patsubst %.o,%.d,$(OBJ)))
+
+$(OBJ) : $(2)
+	@echo "  CC      $$<"
+	$$(Q)$$(CC) $$(CFLAGS) -c $$< -o $$@
+
+
+$(PREREQUISITES) : $(2)
+	@echo "  DEPS    $$@"
+	@mkdir -p $(1)
+	$$(Q)$$(CC) $$(CFLAGS) -M -MT $(OBJ) -MF $$@ $$<
+
+ifdef IS_ANYTHING_TO_BUILD
+-include $(PREREQUISITES)
+endif
+
+endef
+
+
+define MAKE_S
+
+$(eval OBJ := $(1)/$(patsubst %.S,%.o,$(notdir $(2))))
+$(eval PREREQUISITES := $(patsubst %.o,%.d,$(OBJ)))
+
+$(OBJ) : $(2)
+	@echo "  AS      $$<"
+	$$(Q)$$(AS) $$(ASFLAGS) -c $$< -o $$@
+
+$(PREREQUISITES) : $(2)
+	@echo "  DEPS    $$@"
+	@mkdir -p $(1)
+	$$(Q)$$(AS) $$(ASFLAGS) -M -MT $(OBJ) -MF $$@ $$<
+
+ifdef IS_ANYTHING_TO_BUILD
+-include $(PREREQUISITES)
+endif
+
+endef
+
+
+define MAKE_LD
+
+$(eval PREREQUISITES := $(1).d)
+
+$(1) : $(2)
+	@echo "  PP      $$<"
+	$$(Q)$$(AS) $$(ASFLAGS) -P -E -o $$@ $$<
+
+$(PREREQUISITES) : $(2)
+	@echo "  DEPS    $$@"
+	@mkdir -p $$(dir $$@)
+	$$(Q)$$(AS) $$(ASFLAGS) -M -MT $(1) -MF $$@ $$<
+
+ifdef IS_ANYTHING_TO_BUILD
+-include $(PREREQUISITES)
+endif
+
+endef
+
+
+define MAKE_OBJS
+	$(eval C_OBJS := $(filter %.c,$(2)))
+	$(eval REMAIN := $(filter-out %.c,$(2)))
+	$(eval $(foreach obj,$(C_OBJS),$(call MAKE_C,$(1),$(obj))))
+
+	$(eval S_OBJS := $(filter %.S,$(REMAIN)))
+	$(eval REMAIN := $(filter-out %.S,$(REMAIN)))
+	$(eval $(foreach obj,$(S_OBJS),$(call MAKE_S,$(1),$(obj))))
+
+	$(and $(REMAIN),$(error Unexpected source files present: $(REMAIN)))
+endef
+
+
+# NOTE: The line continuation '\' is required in the next define otherwise we
+# end up with a line-feed characer at the end of the last c filename.
+# Also bare this issue in mind if extending the list of supported filetypes.
+define SOURCES_TO_OBJS
+	$(notdir $(patsubst %.c,%.o,$(filter %.c,$(1)))) \
+	$(notdir $(patsubst %.S,%.o,$(filter %.S,$(1))))
+endef
+
+define MAKE_BL
+	$(eval BUILD_DIR  := ${BUILD_PLAT})
+	$(eval SOURCES    := $(SOURCES))
+	$(eval OBJS       := $(addprefix $(BUILD_DIR)/,$(call SOURCES_TO_OBJS,$(SOURCES))))
+	$(eval LINKERFILE := $(BUILD_DIR)/acs.ld)
+	$(eval MAPFILE    := $(BUILD_DIR)/acs.map)
+	$(eval ELF        := $(BUILD_DIR)/acs.elf)
+	$(eval DUMP       := $(BUILD_DIR)/acs.dump)
+	$(eval BIN        := $(BUILD_DIR)/acs.bin)
+
+	$(eval $(call MAKE_OBJS,$(BUILD_DIR),$(SOURCES)))
+	$(eval $(call MAKE_LD,$(LINKERFILE),$(LINKERFILE_T)))
+
+$(BUILD_DIR) :
+	$$(Q)mkdir -p "$$@"
+
+$(ELF) : $(OBJS) $(LINKERFILE)
+	@echo "  LD      $$@"
+	@echo 'const char build_message[] = "Built : "__TIME__", "__DATE__". \\nver:${GIT_VERSION} - ${BUILDER}";' | \
+		$$(CC) $$(CFLAGS) -xc - -o $(BUILD_DIR)/build_message.o
+	$$(Q)$$(LD) -o $$@ $$(LDFLAGS) -Map=$(MAPFILE) --script $(LINKERFILE) \
+					$(BUILD_DIR)/build_message.o $(OBJS)
+
+$(DUMP) : $(ELF)
+	@echo "  OD      $$@"
+	$${Q}$${OD} -dxS $$< > $$@
+
+$(BIN) : $(ELF)
+	@echo "  BIN     $$@"
+	$$(Q)$$(OC) -O binary $$< $$@
+	@echo
+	@echo "Built $$@ successfully"
+	@echo
+
+.PHONY : bl$(1)
+bl$(1) : $(BUILD_DIR) $(DUMP) $(BIN)
+
+all : bl$(1)
+
+$(eval FIP_DEPS += $(if $2,$(BIN),))
+$(eval FIP_ARGS += $(if $2,--bl$(1) $(BIN),))
+
+endef
+
+ifeq (${NEED_BL2},yes)
+$(eval $(call MAKE_BL,2,in_fip))
+endif
+
+${BUILD_PLAT}/fip.bin:	${FIP_DEPS} ${BL33} ${FIPTOOL}
+			$(if ${BL33},,$(error "To build a FIP, please set BL33 to point to the Normal World binary, eg: BL33=../uefi/FVP_AARCH64_EFI.fd"))
+			${Q}${FIPTOOL} --dump \
+				${FIP_ARGS} \
+				--bl33 ${BL33} \
+				$@
+			@echo
+			@echo "Built $@ successfully"
+			@echo
+
+
+cscope:
+	@echo "  CSCOPE"
+	${Q}find ${CURDIR} -name "*.[chsS]" > cscope.files
+	${Q}cscope -b -q -k
+
+help:
+	@echo "usage: ${MAKE} PLAT=<${HELP_PLATFORMS}> <all|bl1|bl2|bl31|distclean|clean|checkcodebase|checkpatch>"
+	@echo ""
+	@echo "PLAT is used to specify which platform you wish to build."
+	@echo "If no platform is specified, PLAT defaults to: ${DEFAULT_PLAT}"
+	@echo ""
+	@echo "Supported Targets:"
+	@echo "  all            Build the BL1, BL2 and BL31 binaries"
+	@echo "  bl1            Build the BL1 binary"
+	@echo "  bl2            Build the BL2 binary"
+	@echo "  bl31           Build the BL31 binary"
+	@echo "  checkcodebase  Check the coding style of the entire source tree"
+	@echo "  checkpatch     Check the coding style on changes in the current"
+	@echo "                 branch against BASE_COMMIT (default origin/master)"
+	@echo "  clean          Clean the build for the selected platform"
+	@echo "  cscope         Generate cscope index"
+	@echo "  distclean      Remove all build artifacts for all platforms"
+	@echo "  fiptool        Build the Firmware Image Package(FIP) creation tool"
+	@echo ""
+	@echo "note: most build targets require PLAT to be set to a specific platform."
+	@echo ""
+	@echo "example: build all targets for the FVP platform:"
+	@echo "  CROSS_COMPILE=aarch64-none-elf- make PLAT=fvp all"
diff --git a/arch/arm/cpu/armv8/txl/firmware/acs/acs.c b/arch/arm/cpu/armv8/txl/firmware/acs/acs.c
new file mode 100644
index 0000000..ed1d7fa
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/acs/acs.c
@@ -0,0 +1,47 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/acs/acs.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/acs.h>
+#include <asm/arch/timing.h>
+#include "timing.c"
+
+//main acs struct
+struct acs_setting __acs_set={
+					.acs_magic		= "acs__",
+					.chip_type		= 0x24,
+					.version 		= 1,
+					.acs_set_length	= sizeof(__acs_set),
+
+					.ddr_magic		= "ddrs_",
+					.ddr_set_version= 2, //2016.01.15 update to v2, add dqs gate tuning
+					.ddr_set_length	= sizeof(ddr_set_t),
+					.ddr_set_addr	= (unsigned long)(&__ddr_setting),
+
+					.ddrt_magic		= "ddrt_",
+					.ddrt_set_version= 1,
+					.ddrt_set_length= sizeof(__ddr_timming),
+					.ddrt_set_addr	= (unsigned long)(&__ddr_timming),
+
+					.pll_magic		= "pll__",
+					.pll_set_version= 1,
+					.pll_set_length	= sizeof(__pll_setting),
+					.pll_set_addr	= (unsigned long)(&__pll_setting),
+};
diff --git a/arch/arm/cpu/armv8/txl/firmware/acs/acs.ld.S b/arch/arm/cpu/armv8/txl/firmware/acs/acs.ld.S
new file mode 100644
index 0000000..18242f7
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/acs/acs.ld.S
@@ -0,0 +1,43 @@
+
+OUTPUT_FORMAT("elf64-littleaarch64")
+OUTPUT_ARCH(aarch64)
+ENTRY(acs_entry)
+
+SECTIONS
+{
+    . = 0x0;
+
+    ro . : {
+        __RO_START__ = .;
+        *acs_entry.o(.text*)
+        *(.text*)
+        *(.rodata*)
+        *(.vectors)
+        __RO_END_UNALIGNED__ = .;
+        /*
+         * Memory page(s) mapped to this section will be marked as
+         * read-only, executable.  No RW data from the next section must
+         * creep in.  Ensure the rest of the current memory page is unused.
+         */
+        __RO_END__ = .;
+    }
+
+    .data . : {
+        __DATA_START__ = .;
+        *(.data*)
+        __DATA_END__ = .;
+    }
+
+    /*
+     * The .bss section gets initialised to 0 at runtime.
+     * Its base address must be 16-byte aligned.
+     */
+    .bss : ALIGN(16) {
+        __BSS_START__ = .;
+        *(.bss*)
+        __BSS_END__ = .;
+    }
+
+    ASSERT(. <= 0x1000, "timing image has exceeded its limit.")
+}
+
diff --git a/arch/arm/cpu/armv8/txl/firmware/acs/acs.mk b/arch/arm/cpu/armv8/txl/firmware/acs/acs.mk
new file mode 100644
index 0000000..b0ce300
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/acs/acs.mk
@@ -0,0 +1,3 @@
+SOURCES		+=	acs.c						\
+				acs_entry.S
+LINKERFILE_T		:=	acs.ld.S
diff --git a/arch/arm/cpu/armv8/txl/firmware/acs/acs_entry.S b/arch/arm/cpu/armv8/txl/firmware/acs/acs_entry.S
new file mode 100644
index 0000000..a92aef2
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/acs/acs_entry.S
@@ -0,0 +1,7 @@
+
+	.globl	acs_entry
+
+acs_entry:
+	.word 0
+	.word __acs_set
+	.word build_message
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/Makefile b/arch/arm/cpu/armv8/txl/firmware/bl21/Makefile
new file mode 100644
index 0000000..4dfe462
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/Makefile
@@ -0,0 +1,431 @@
+#
+# Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# Redistributions of source code must retain the above copyright notice, this
+# list of conditions and the following disclaimer.
+#
+# Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation
+# and/or other materials provided with the distribution.
+#
+# Neither the name of ARM nor the names of its contributors may be used
+# to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+#
+# Default values for build configurations
+#
+
+include $(buildsrc)/config.mk
+include $(buildtree)/include/autoconf.mk
+include $(buildtree)/.config
+
+# Build verbosity
+V			:= 0
+# Debug build
+BUILD_TYPE		:= ${BL2_BUILD_TYPE}
+# Build architecture
+ARCH 			:= aarch64
+# Build platform
+#DEFAULT_PLAT		:= gx
+PLAT			:= ${SOC}
+export PLAT
+# SPD choice
+SPD			:= none
+# Base commit to perform code check on
+BASE_COMMIT		:= origin/master
+# NS timer register save and restore
+NS_TIMER_SWITCH		:= 0
+# By default, Bl1 acts as the reset handler, not BL31
+RESET_TO_BL31		:= 0
+# Build name
+BUILD_NAME		:= bl21
+
+# Checkpatch ignores
+CHECK_IGNORE		=	--ignore COMPLEX_MACRO
+
+CHECKPATCH_ARGS		=	--no-tree --no-signoff ${CHECK_IGNORE}
+CHECKCODE_ARGS		=	--no-patch --no-tree --no-signoff ${CHECK_IGNORE}
+
+ifeq (${V},0)
+	Q=@
+	CHECKCODE_ARGS	+=	--no-summary --terse
+else
+	Q=
+endif
+export Q
+
+ifeq (${GIT_VERSION},)
+	GIT_VERSION := $(shell git describe --abbrev=7 --dirty --always --tags)
+endif
+ifeq (${BUILDER},)
+	BUILDER := ${USER}@$(shell hostname)
+endif
+
+BL_COMMON_SOURCES	:=	common/bl_common.c			\
+				common/debug.c				\
+				lib/aarch64/cache_helpers.S		\
+				lib/aarch64/misc_helpers.S		\
+				lib/aarch64/tlb_helpers.S		\
+				lib/aarch64/xlat_helpers.c		\
+				lib/stdlib/std.c			\
+				lib/io_storage.c			\
+				plat/common/aarch64/platform_helpers.S
+
+BUILD_BASE		:=	$(buildtree)/firmware
+#BUILD_PLAT		:=	${BUILD_BASE}/${PLAT}
+#BUILD_PLAT		:=	$(buildtree)/board/${BOARDDIR}/firmware
+BUILD_PLAT		:=	$(buildtree)/${BOARDDIR}/firmware
+
+# Convenience function for adding build definitions
+# $(eval $(call add_define,FOO)) will have:
+# -DFOO if $(FOO) is empty; -DFOO=$(FOO) otherwise
+define add_define
+DEFINES			+=	-D$(1)$(if $(value $(1)),=$(value $(1)),)
+endef
+
+# Convenience function for verifying option has a boolean value
+# $(eval $(call assert_boolean,FOO)) will assert FOO is 0 or 1
+define assert_boolean
+$(and $(patsubst 0,,$(value $(1))),$(patsubst 1,,$(value $(1))),$(error $(1) must be boolean))
+endef
+
+ifeq (${PLAT},)
+  $(error "Error: Unknown platform. Please use PLAT=<platform name> to specify the platform.")
+endif
+
+all: msg_start
+
+msg_start:
+	@echo "Building ${BOARDDIR}/${BUILD_NAME}.bin"
+
+#include plat/${PLAT}/platform.mk
+#ifdef BL2_SOURCES
+NEED_BL2 := yes
+include ${BUILD_NAME}.mk
+#endif
+
+# Include SPD Makefile if one has been specified
+ifneq (${SPD},none)
+  # We expect to locate an spd.mk under the specified SPD directory
+  SPD_MAKE		:=	$(shell m="services/spd/${SPD}/${SPD}.mk"; [ -f "$$m" ] && echo "$$m")
+
+  ifeq (${SPD_MAKE},)
+    $(error Error: No services/spd/${SPD}/${SPD}.mk located)
+  endif
+  $(info Including ${SPD_MAKE})
+  include ${SPD_MAKE}
+
+  # If there's BL32 companion for the chosen SPD, and the SPD wants to build the
+  # BL2 from source, we expect that the SPD's Makefile would set NEED_BL32
+  # variable to "yes"
+endif
+
+.PHONY:			all msg_start clean realclean distclean cscope locate-checkpatch checkcodebase checkpatch fiptool fip
+.SUFFIXES:
+
+INCLUDES		+= -Iinclude/bl2			\
+				-Iinclude/bl31			\
+				-Iinclude/common		\
+				-Iinclude/drivers		\
+				-Iinclude/drivers/arm		\
+				-Iinclude/drivers/serial		\
+				-Iinclude/lib			\
+				-Iinclude/lib/aarch64		\
+				-Iinclude/plat/common		\
+				-Iinclude/stdlib		\
+				-Iinclude/stdlib/sys		\
+				${PLAT_INCLUDES}		\
+				${SPD_INCLUDES}
+
+# Process DEBUG flag
+$(eval $(call assert_boolean,DEBUG))
+$(eval $(call add_define,DEBUG))
+ifeq (${DEBUG},0)
+  $(eval $(call add_define,NDEBUG))
+else
+CFLAGS			+= 	-g
+ASFLAGS			+= 	-g -Wa,--gdwarf-2
+endif
+
+# Process NS_TIMER_SWITCH flag
+$(eval $(call assert_boolean,NS_TIMER_SWITCH))
+$(eval $(call add_define,NS_TIMER_SWITCH))
+
+# Process RESET_TO_BL31 flag
+$(eval $(call assert_boolean,RESET_TO_BL31))
+$(eval $(call add_define,RESET_TO_BL31))
+
+#VPATH_LIST = $(buildsrc)/board/$(BOARDDIR)
+VPATH_LIST = $(buildsrc)/$(BOARDDIR)
+VPATH_LIST:=$(VPATH_LIST:%=%/firmware/)
+
+vpath %.c $(VPATH_LIST)
+
+ASFLAGS			+= 	-nostdinc -ffreestanding -Wa,--fatal-warnings	\
+				-mgeneral-regs-only -D__ASSEMBLY__		\
+				${DEFINES} ${INCLUDES}
+CFLAGS			+= 	-nostdinc -pedantic -ffreestanding -Wall	\
+				-Werror -mgeneral-regs-only -std=c99 -c -Os	\
+				${DEFINES} ${INCLUDES} $(VPATH_LIST:%=-I%)
+CFLAGS			+=	-ffunction-sections -fdata-sections
+ASFLAGS			+= 	${FIRMWARE_CPPFLAGS}
+CFLAGS			+= 	${FIRMWARE_CPPFLAGS}
+CFLAGS			+= 	-Wno-unused
+
+LDFLAGS			+=	--fatal-warnings -O1
+LDFLAGS			+=	--gc-sections
+
+CC			:=	${CROSS_COMPILE}gcc
+CPP			:=	${CROSS_COMPILE}cpp
+AS			:=	${CROSS_COMPILE}gcc
+AR			:=	${CROSS_COMPILE}ar
+LD			:=	${CROSS_COMPILE}ld
+OC			:=	${CROSS_COMPILE}objcopy
+OD			:=	${CROSS_COMPILE}objdump
+NM			:=	${CROSS_COMPILE}nm
+PP			:=	${CROSS_COMPILE}gcc -E ${CFLAGS}
+
+# Variables for use with Firmware Image Package
+FIPTOOLPATH		?=	tools/fip_create
+FIPTOOL			?=	${FIPTOOLPATH}/fip_create
+fiptool:		${FIPTOOL}
+fip:			${BUILD_PLAT}/fip.bin
+
+locate-checkpatch:
+ifndef CHECKPATCH
+	$(error "Please set CHECKPATCH to point to the Linux checkpatch.pl file, eg: CHECKPATCH=../linux/script/checkpatch.pl")
+else
+ifeq (,$(wildcard ${CHECKPATCH}))
+	$(error "The file CHECKPATCH points to cannot be found, use eg: CHECKPATCH=../linux/script/checkpatch.pl")
+endif
+endif
+
+clean:
+			@echo "  CLEAN"
+			${Q}rm -rf ${BUILD_PLAT}
+			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH} clean
+
+realclean distclean:
+			@echo "  REALCLEAN"
+			${Q}rm -rf ${BUILD_BASE}
+			${Q}rm -f ${CURDIR}/cscope.*
+			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH} clean
+
+checkcodebase:		locate-checkpatch
+			@echo "  CHECKING STYLE"
+			@if test -d .git ; then	\
+				git ls-files | while read GIT_FILE ; do ${CHECKPATCH} ${CHECKCODE_ARGS} -f $$GIT_FILE ; done ;	\
+			 else			\
+				 find . -type f -not -iwholename "*.git*" -not -iwholename "*build*" -exec ${CHECKPATCH} ${CHECKCODE_ARGS} -f {} \; ;	\
+			 fi
+
+checkpatch:		locate-checkpatch
+			@echo "  CHECKING STYLE"
+			@git format-patch --stdout ${BASE_COMMIT} | ${CHECKPATCH} ${CHECKPATCH_ARGS} - || true
+
+${FIPTOOL}:
+			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH}
+			@echo
+			@echo "Built $@ successfully"
+			@echo
+
+define match_goals
+$(strip $(foreach goal,$(1),$(filter $(goal),$(MAKECMDGOALS))))
+endef
+
+# List of rules that involve building things
+BUILD_TARGETS := all bl1 bl2 bl31 bl32 fip
+
+# Does the list of goals specified on the command line include a build target?
+ifneq ($(call match_goals,${BUILD_TARGETS}),)
+IS_ANYTHING_TO_BUILD := 1
+endif
+
+define MAKE_C
+
+$(eval OBJ := $(1)/$(patsubst %.c,%.o,$(notdir $(2))))
+$(eval PREREQUISITES := $(patsubst %.o,%.d,$(OBJ)))
+
+$(OBJ) : $(2)
+	@echo "  CC      $$<"
+	$$(Q)$$(CC) $$(CFLAGS) -c $$< -o $$@
+
+
+$(PREREQUISITES) : $(2)
+	@echo "  DEPS    $$@"
+	@mkdir -p $(1)
+	$$(Q)$$(CC) $$(CFLAGS) -M -MT $(OBJ) -MF $$@ $$<
+
+ifdef IS_ANYTHING_TO_BUILD
+-include $(PREREQUISITES)
+endif
+
+endef
+
+
+define MAKE_S
+
+$(eval OBJ := $(1)/$(patsubst %.S,%.o,$(notdir $(2))))
+$(eval PREREQUISITES := $(patsubst %.o,%.d,$(OBJ)))
+
+$(OBJ) : $(2)
+	@echo "  AS      $$<"
+	$$(Q)$$(AS) $$(ASFLAGS) -c $$< -o $$@
+
+$(PREREQUISITES) : $(2)
+	@echo "  DEPS    $$@"
+	@mkdir -p $(1)
+	$$(Q)$$(AS) $$(ASFLAGS) -M -MT $(OBJ) -MF $$@ $$<
+
+ifdef IS_ANYTHING_TO_BUILD
+-include $(PREREQUISITES)
+endif
+
+endef
+
+
+define MAKE_LD
+
+$(eval PREREQUISITES := $(1).d)
+
+$(1) : $(2)
+	@echo "  PP      $$<"
+	$$(Q)$$(AS) $$(ASFLAGS) -P -E -o $$@ $$<
+
+$(PREREQUISITES) : $(2)
+	@echo "  DEPS    $$@"
+	@mkdir -p $$(dir $$@)
+	$$(Q)$$(AS) $$(ASFLAGS) -M -MT $(1) -MF $$@ $$<
+
+ifdef IS_ANYTHING_TO_BUILD
+-include $(PREREQUISITES)
+endif
+
+endef
+
+
+define MAKE_OBJS
+	$(eval C_OBJS := $(filter %.c,$(2)))
+	$(eval REMAIN := $(filter-out %.c,$(2)))
+	$(eval $(foreach obj,$(C_OBJS),$(call MAKE_C,$(1),$(obj))))
+
+	$(eval S_OBJS := $(filter %.S,$(REMAIN)))
+	$(eval REMAIN := $(filter-out %.S,$(REMAIN)))
+	$(eval $(foreach obj,$(S_OBJS),$(call MAKE_S,$(1),$(obj))))
+
+	$(and $(REMAIN),$(error Unexpected source files present: $(REMAIN)))
+endef
+
+
+# NOTE: The line continuation '\' is required in the next define otherwise we
+# end up with a line-feed characer at the end of the last c filename.
+# Also bare this issue in mind if extending the list of supported filetypes.
+define SOURCES_TO_OBJS
+	$(notdir $(patsubst %.c,%.o,$(filter %.c,$(1)))) \
+	$(notdir $(patsubst %.S,%.o,$(filter %.S,$(1))))
+endef
+
+define MAKE_BL
+	$(eval BUILD_DIR  := ${BUILD_PLAT})
+	$(eval SOURCES    := $(SOURCES))
+	$(eval OBJS       := $(addprefix $(BUILD_DIR)/,$(call SOURCES_TO_OBJS,$(SOURCES))))
+	$(eval LINKERFILE := $(BUILD_DIR)/${BUILD_NAME}.ld)
+	$(eval MAPFILE    := $(BUILD_DIR)/${BUILD_NAME}.map)
+	$(eval ELF        := $(BUILD_DIR)/${BUILD_NAME}.elf)
+	$(eval DUMP       := $(BUILD_DIR)/${BUILD_NAME}.dump)
+	$(eval BIN        := $(BUILD_DIR)/${BUILD_NAME}.bin)
+
+	$(eval $(call MAKE_OBJS,$(BUILD_DIR),$(SOURCES)))
+	$(eval $(call MAKE_LD,$(LINKERFILE),$(LINKERFILE_T)))
+
+$(BUILD_DIR) :
+	$$(Q)mkdir -p "$$@"
+
+$(ELF) : $(OBJS) $(LINKERFILE)
+	@echo "  LD      $$@"
+	@echo 'const char build_message[] = "Built : "__TIME__", "__DATE__". \\nver:${GIT_VERSION} - ${BUILDER}";' | \
+		$$(CC) $$(CFLAGS) -xc - -o $(BUILD_DIR)/build_message.o
+	$$(Q)$$(LD) -o $$@ $$(LDFLAGS) -Map=$(MAPFILE) --script $(LINKERFILE) \
+					$(BUILD_DIR)/build_message.o $(OBJS)
+
+$(DUMP) : $(ELF)
+	@echo "  OD      $$@"
+	$${Q}$${OD} -dxS $$< > $$@
+
+$(BIN) : $(ELF)
+	@echo "  BIN     $$@"
+	$$(Q)$$(OC) -O binary $$< $$@
+	@echo
+	@echo "Built $$@ successfully"
+	@echo
+
+.PHONY : bl$(1)
+bl$(1) : $(BUILD_DIR) $(DUMP) $(BIN)
+
+all : bl$(1)
+
+$(eval FIP_DEPS += $(if $2,$(BIN),))
+$(eval FIP_ARGS += $(if $2,--bl$(1) $(BIN),))
+
+endef
+
+ifeq (${NEED_BL2},yes)
+$(eval $(call MAKE_BL,2,in_fip))
+endif
+
+${BUILD_PLAT}/fip.bin:	${FIP_DEPS} ${BL33} ${FIPTOOL}
+			$(if ${BL33},,$(error "To build a FIP, please set BL33 to point to the Normal World binary, eg: BL33=../uefi/FVP_AARCH64_EFI.fd"))
+			${Q}${FIPTOOL} --dump \
+				${FIP_ARGS} \
+				--bl33 ${BL33} \
+				$@
+			@echo
+			@echo "Built $@ successfully"
+			@echo
+
+
+cscope:
+	@echo "  CSCOPE"
+	${Q}find ${CURDIR} -name "*.[chsS]" > cscope.files
+	${Q}cscope -b -q -k
+
+help:
+	@echo "usage: ${MAKE} PLAT=<${HELP_PLATFORMS}> <all|bl1|bl2|bl31|distclean|clean|checkcodebase|checkpatch>"
+	@echo ""
+	@echo "PLAT is used to specify which platform you wish to build."
+	@echo "If no platform is specified, PLAT defaults to: ${DEFAULT_PLAT}"
+	@echo ""
+	@echo "Supported Targets:"
+	@echo "  all            Build the BL1, BL2 and BL31 binaries"
+	@echo "  bl1            Build the BL1 binary"
+	@echo "  bl2            Build the BL2 binary"
+	@echo "  bl31           Build the BL31 binary"
+	@echo "  checkcodebase  Check the coding style of the entire source tree"
+	@echo "  checkpatch     Check the coding style on changes in the current"
+	@echo "                 branch against BASE_COMMIT (default origin/master)"
+	@echo "  clean          Clean the build for the selected platform"
+	@echo "  cscope         Generate cscope index"
+	@echo "  distclean      Remove all build artifacts for all platforms"
+	@echo "  fiptool        Build the Firmware Image Package(FIP) creation tool"
+	@echo ""
+	@echo "note: most build targets require PLAT to be set to a specific platform."
+	@echo ""
+	@echo "example: build all targets for the FVP platform:"
+	@echo "  CROSS_COMPILE=aarch64-none-elf- make PLAT=fvp all"
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/_stdint.h b/arch/arm/cpu/armv8/txl/firmware/bl21/_stdint.h
new file mode 100644
index 0000000..2a17459
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/_stdint.h
@@ -0,0 +1,74 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/bl21/_stdint.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _SYS__STDINT_H_
+#define _SYS__STDINT_H_
+
+#ifndef _INT8_T_DECLARED
+typedef	__int8_t		int8_t;
+#define	_INT8_T_DECLARED
+#endif
+
+#ifndef _INT16_T_DECLARED
+typedef	__int16_t		int16_t;
+#define	_INT16_T_DECLARED
+#endif
+
+#ifndef _INT32_T_DECLARED
+typedef	__int32_t		int32_t;
+#define	_INT32_T_DECLARED
+#endif
+
+#ifndef _INT64_T_DECLARED
+typedef	__int64_t		int64_t;
+#define	_INT64_T_DECLARED
+#endif
+
+#ifndef _UINT8_T_DECLARED
+typedef	__uint8_t		uint8_t;
+#define	_UINT8_T_DECLARED
+#endif
+
+#ifndef _UINT16_T_DECLARED
+typedef	__uint16_t		uint16_t;
+#define	_UINT16_T_DECLARED
+#endif
+
+#ifndef _UINT32_T_DECLARED
+typedef	__uint32_t		uint32_t;
+#define	_UINT32_T_DECLARED
+#endif
+
+#ifndef _UINT64_T_DECLARED
+typedef	__uint64_t		uint64_t;
+#define	_UINT64_T_DECLARED
+#endif
+
+#ifndef _INTPTR_T_DECLARED
+typedef	__intptr_t		intptr_t;
+#define	_INTPTR_T_DECLARED
+#endif
+#ifndef _UINTPTR_T_DECLARED
+typedef	__uintptr_t		uintptr_t;
+#define	_UINTPTR_T_DECLARED
+#endif
+
+#endif /* !_SYS__STDINT_H_ */
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/bl21.ld.S b/arch/arm/cpu/armv8/txl/firmware/bl21/bl21.ld.S
new file mode 100644
index 0000000..61aecf3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/bl21.ld.S
@@ -0,0 +1,47 @@
+
+OUTPUT_FORMAT("elf64-littleaarch64")
+OUTPUT_ARCH(aarch64)
+ENTRY(bl21_entrypoint)
+
+SECTIONS
+{
+    . = 0xd900b400;
+    ASSERT(. == ALIGN(1024),
+           "BL21 base address is not aligned.")
+
+    ro . : {
+        __RO_START__ = .;
+        *bl21_entrypoint.o(.text*)
+        *(.text*)
+        *(.rodata*)
+        *(.vectors)
+        __RO_END_UNALIGNED__ = .;
+        /*
+         * Memory page(s) mapped to this section will be marked as
+         * read-only, executable.  No RW data from the next section must
+         * creep in.  Ensure the rest of the current memory page is unused.
+         */
+        __RO_END__ = .;
+    }
+
+    .data . : {
+        __DATA_START__ = .;
+        *(.data*)
+        __DATA_END__ = .;
+    }
+
+    /*
+     * The .bss section gets initialised to 0 at runtime.
+     * Its base address must be 16-byte aligned.
+     */
+    .bss : ALIGN(16) {
+        __BSS_START__ = .;
+        *(SORT_BY_ALIGNMENT(.bss*))
+        *(COMMON)
+        __BSS_END__ = .;
+    }
+
+    __BSS_SIZE__ = SIZEOF(.bss);
+
+    ASSERT(. <= 0xd900c000, "bl21 image has exceeded its limit.")
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/bl21.mk b/arch/arm/cpu/armv8/txl/firmware/bl21/bl21.mk
new file mode 100644
index 0000000..a43d273
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/bl21.mk
@@ -0,0 +1,6 @@
+SOURCES		+=	bl21_main.c						\
+				bl21_entrypoint.S				\
+				serial.c						\
+				timer.c
+
+LINKERFILE_T		:=	bl21.ld.S
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/bl21_entrypoint.S b/arch/arm/cpu/armv8/txl/firmware/bl21/bl21_entrypoint.S
new file mode 100644
index 0000000..74cc6bf
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/bl21_entrypoint.S
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+	.globl	bl21_entrypoint
+	.globl	zeromem16
+
+	.func
+bl21_entrypoint:
+	//stp x0, x1, x2, x3, x4, x5, x6, x7, lr, [sp]
+	//stp x0, x30, [sp]
+	/* ---------------------------------------------
+	 * Zero out NOBITS sections. There are 2 of them:
+	 *   - the .bss section;
+	 *   - the coherent memory section.
+	 * ---------------------------------------------
+	 */
+	ldr	x0, =__BSS_START__
+	ldr	x1, =__BSS_SIZE__
+
+	add	x2, x0, x1
+/* zero 16 bytes at a time */
+z_loop16:
+	sub	x3, x2, x0
+	cmp	x3, #16
+	b.lt	z_loop1
+	stp	xzr, xzr, [x0], #16
+	b	z_loop16
+/* zero byte per byte */
+z_loop1:
+	cmp	x0, x2
+	b.eq	z_end
+	strb	wzr, [x0], #1
+	b	z_loop1
+z_end:
+
+	/* ---------------------------------------------
+	 * Jump to main function.
+	 * ---------------------------------------------
+	 */
+	b	bl21_main
+	.endfunc
+
+#if 0
+/* -----------------------------------------------------------------------
+ * void zeromem16(void *mem, unsigned int length);
+ *
+ * Initialise a memory region to 0.
+ * The memory address must be 16-byte aligned.
+ * -----------------------------------------------------------------------
+ */
+func zeromem16
+	add	x2, x0, x1
+/* zero 16 bytes at a time */
+z_loop16:
+	sub	x3, x2, x0
+	cmp	x3, #16
+	b.lt	z_loop1
+	stp	xzr, xzr, [x0], #16
+	b	z_loop16
+/* zero byte per byte */
+z_loop1:
+	cmp	x0, x2
+	b.eq	z_end
+	strb	wzr, [x0], #1
+	b	z_loop1
+z_end:	ret
+#endif
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/bl21_main.c b/arch/arm/cpu/armv8/txl/firmware/bl21/bl21_main.c
new file mode 100644
index 0000000..f372440
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/bl21_main.c
@@ -0,0 +1,33 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/bl21/bl21_main.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "secure_apb.h"
+#include "serial.h" //use local serial driver
+#include "io.h"
+#include "timer.h"
+#include "board_init.c"
+
+void bl21_main(void)
+{
+	/* bl2 customer code */
+	board_init();
+	return;
+}
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/io.h b/arch/arm/cpu/armv8/txl/firmware/bl21/io.h
new file mode 100644
index 0000000..495394d
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/io.h
@@ -0,0 +1,33 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/bl21/io.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __BL2_IO_H_
+#define __BL2_IO_H_
+
+#define writel(val,reg) (*((volatile unsigned *)(reg)))=(val)
+#define readl(reg)		(*((volatile unsigned *)(reg)))
+#define setbits_le32(reg,val)	(*((volatile unsigned *)(reg)))|=(val)
+#define clrbits_le32(reg,val)	(*((volatile unsigned *)(reg)))&=(~(val))
+#define clrsetbits_le32(reg,clr,set)	{unsigned __v=readl(reg);__v&=(~(clr));__v|=(set);writel(__v,reg);}
+
+typedef unsigned int uint32_t;
+
+#endif /*__BL2_IO_H_*/
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/secure_apb.h b/arch/arm/cpu/armv8/txl/firmware/bl21/secure_apb.h
new file mode 100644
index 0000000..909c0f3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/secure_apb.h
@@ -0,0 +1,1945 @@
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+//
+// ./create_headers_from_secure_apb4_h.pl
+//
+// and was applied to the file
+//
+// ./secure_apb4_ee.h ./ao_rti_reg.h
+//
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+//
+#ifdef SECURE_APB_H
+#else
+#define SECURE_APB_H
+
+//
+// Reading file:  ./secure_apb4_ee.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//========================================================================
+//  RNG
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8834000
+//  APB4_DECODER_SECURE_BASE         32'hDA834000
+//  Non Secure Register
+#define     RNG_DATA                                           (0xc8834000 + (0x00 << 2))
+#define SEC_RNG_DATA                                           (0xda834000 + (0x00 << 2))
+#define   P_RNG_DATA                                           (volatile uint32_t *)(0xc8834000 + (0x00 << 2))
+//  Secure Register
+#define     RNG_SEC_CONFIG_REG1                                (0xc8834000 + (0x01 << 2))
+#define SEC_RNG_SEC_CONFIG_REG1                                (0xda834000 + (0x01 << 2))
+#define   P_RNG_SEC_CONFIG_REG1                                (volatile uint32_t *)(0xc8834000 + (0x01 << 2))
+#define     RNG_SEC_CONFIG_REG2                                (0xc8834000 + (0x02 << 2))
+#define SEC_RNG_SEC_CONFIG_REG2                                (0xda834000 + (0x02 << 2))
+#define   P_RNG_SEC_CONFIG_REG2                                (volatile uint32_t *)(0xc8834000 + (0x02 << 2))
+#define     RNG_SEC_SCRATCH_REG                                (0xc8834000 + (0x03 << 2))
+#define SEC_RNG_SEC_SCRATCH_REG                                (0xda834000 + (0x03 << 2))
+#define   P_RNG_SEC_SCRATCH_REG                                (volatile uint32_t *)(0xc8834000 + (0x03 << 2))
+//========================================================================
+//  ACODEC
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8832000
+//  APB4_DECODER_SECURE_BASE         32'hDA832000
+#define     ACODEC_0                                           (0xc8832000 + (0x00 << 2))
+#define SEC_ACODEC_0                                           (0xda832000 + (0x00 << 2))
+#define   P_ACODEC_0                                           (volatile uint32_t *)(0xc8832000 + (0x00 << 2))
+#define     ACODEC_1                                           (0xc8832000 + (0x01 << 2))
+#define SEC_ACODEC_1                                           (0xda832000 + (0x01 << 2))
+#define   P_ACODEC_1                                           (volatile uint32_t *)(0xc8832000 + (0x01 << 2))
+#define     ACODEC_2                                           (0xc8832000 + (0x02 << 2))
+#define SEC_ACODEC_2                                           (0xda832000 + (0x02 << 2))
+#define   P_ACODEC_2                                           (volatile uint32_t *)(0xc8832000 + (0x02 << 2))
+#define     ACODEC_3                                           (0xc8832000 + (0x03 << 2))
+#define SEC_ACODEC_3                                           (0xda832000 + (0x03 << 2))
+#define   P_ACODEC_3                                           (volatile uint32_t *)(0xc8832000 + (0x03 << 2))
+#define     ACODEC_4                                           (0xc8832000 + (0x04 << 2))
+#define SEC_ACODEC_4                                           (0xda832000 + (0x04 << 2))
+#define   P_ACODEC_4                                           (volatile uint32_t *)(0xc8832000 + (0x04 << 2))
+//========================================================================
+//  PERIPHS
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8834400
+//  APB4_DECODER_SECURE_BASE         32'hDA834400
+// The following are handled by $periphs/rtl/periphs_reg.v
+#define     PREG_CTLREG0_ADDR                                  (0xc8834400 + (0x00 << 2))
+#define SEC_PREG_CTLREG0_ADDR                                  (0xda834400 + (0x00 << 2))
+#define   P_PREG_CTLREG0_ADDR                                  (volatile uint32_t *)(0xc8834400 + (0x00 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO6_EN_N                                (0xc8834400 + (0x08 << 2))
+#define SEC_PREG_PAD_GPIO6_EN_N                                (0xda834400 + (0x08 << 2))
+#define   P_PREG_PAD_GPIO6_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x08 << 2))
+#define     PREG_PAD_GPIO6_O                                   (0xc8834400 + (0x09 << 2))
+#define SEC_PREG_PAD_GPIO6_O                                   (0xda834400 + (0x09 << 2))
+#define   P_PREG_PAD_GPIO6_O                                   (volatile uint32_t *)(0xc8834400 + (0x09 << 2))
+#define     PREG_PAD_GPIO6_I                                   (0xc8834400 + (0x0a << 2))
+#define SEC_PREG_PAD_GPIO6_I                                   (0xda834400 + (0x0a << 2))
+#define   P_PREG_PAD_GPIO6_I                                   (volatile uint32_t *)(0xc8834400 + (0x0a << 2))
+// ----------------------------
+// ----------------------------
+#define     PREG_JTAG_GPIO_ADDR                                (0xc8834400 + (0x0b << 2))
+#define SEC_PREG_JTAG_GPIO_ADDR                                (0xda834400 + (0x0b << 2))
+#define   P_PREG_JTAG_GPIO_ADDR                                (volatile uint32_t *)(0xc8834400 + (0x0b << 2))
+// ----------------------------
+// Pre-defined GPIO addresses
+// ----------------------------
+#define     PREG_PAD_GPIO0_EN_N                                (0xc8834400 + (0x0c << 2))
+#define SEC_PREG_PAD_GPIO0_EN_N                                (0xda834400 + (0x0c << 2))
+#define   P_PREG_PAD_GPIO0_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x0c << 2))
+#define     PREG_PAD_GPIO0_O                                   (0xc8834400 + (0x0d << 2))
+#define SEC_PREG_PAD_GPIO0_O                                   (0xda834400 + (0x0d << 2))
+#define   P_PREG_PAD_GPIO0_O                                   (volatile uint32_t *)(0xc8834400 + (0x0d << 2))
+#define     PREG_PAD_GPIO0_I                                   (0xc8834400 + (0x0e << 2))
+#define SEC_PREG_PAD_GPIO0_I                                   (0xda834400 + (0x0e << 2))
+#define   P_PREG_PAD_GPIO0_I                                   (volatile uint32_t *)(0xc8834400 + (0x0e << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO1_EN_N                                (0xc8834400 + (0x0f << 2))
+#define SEC_PREG_PAD_GPIO1_EN_N                                (0xda834400 + (0x0f << 2))
+#define   P_PREG_PAD_GPIO1_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x0f << 2))
+#define     PREG_PAD_GPIO1_O                                   (0xc8834400 + (0x10 << 2))
+#define SEC_PREG_PAD_GPIO1_O                                   (0xda834400 + (0x10 << 2))
+#define   P_PREG_PAD_GPIO1_O                                   (volatile uint32_t *)(0xc8834400 + (0x10 << 2))
+#define     PREG_PAD_GPIO1_I                                   (0xc8834400 + (0x11 << 2))
+#define SEC_PREG_PAD_GPIO1_I                                   (0xda834400 + (0x11 << 2))
+#define   P_PREG_PAD_GPIO1_I                                   (volatile uint32_t *)(0xc8834400 + (0x11 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO2_EN_N                                (0xc8834400 + (0x12 << 2))
+#define SEC_PREG_PAD_GPIO2_EN_N                                (0xda834400 + (0x12 << 2))
+#define   P_PREG_PAD_GPIO2_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x12 << 2))
+#define     PREG_PAD_GPIO2_O                                   (0xc8834400 + (0x13 << 2))
+#define SEC_PREG_PAD_GPIO2_O                                   (0xda834400 + (0x13 << 2))
+#define   P_PREG_PAD_GPIO2_O                                   (volatile uint32_t *)(0xc8834400 + (0x13 << 2))
+#define     PREG_PAD_GPIO2_I                                   (0xc8834400 + (0x14 << 2))
+#define SEC_PREG_PAD_GPIO2_I                                   (0xda834400 + (0x14 << 2))
+#define   P_PREG_PAD_GPIO2_I                                   (volatile uint32_t *)(0xc8834400 + (0x14 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO3_EN_N                                (0xc8834400 + (0x15 << 2))
+#define SEC_PREG_PAD_GPIO3_EN_N                                (0xda834400 + (0x15 << 2))
+#define   P_PREG_PAD_GPIO3_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x15 << 2))
+#define     PREG_PAD_GPIO3_O                                   (0xc8834400 + (0x16 << 2))
+#define SEC_PREG_PAD_GPIO3_O                                   (0xda834400 + (0x16 << 2))
+#define   P_PREG_PAD_GPIO3_O                                   (volatile uint32_t *)(0xc8834400 + (0x16 << 2))
+#define     PREG_PAD_GPIO3_I                                   (0xc8834400 + (0x17 << 2))
+#define SEC_PREG_PAD_GPIO3_I                                   (0xda834400 + (0x17 << 2))
+#define   P_PREG_PAD_GPIO3_I                                   (volatile uint32_t *)(0xc8834400 + (0x17 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO4_EN_N                                (0xc8834400 + (0x18 << 2))
+#define SEC_PREG_PAD_GPIO4_EN_N                                (0xda834400 + (0x18 << 2))
+#define   P_PREG_PAD_GPIO4_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x18 << 2))
+#define     PREG_PAD_GPIO4_O                                   (0xc8834400 + (0x19 << 2))
+#define SEC_PREG_PAD_GPIO4_O                                   (0xda834400 + (0x19 << 2))
+#define   P_PREG_PAD_GPIO4_O                                   (volatile uint32_t *)(0xc8834400 + (0x19 << 2))
+#define     PREG_PAD_GPIO4_I                                   (0xc8834400 + (0x1a << 2))
+#define SEC_PREG_PAD_GPIO4_I                                   (0xda834400 + (0x1a << 2))
+#define   P_PREG_PAD_GPIO4_I                                   (volatile uint32_t *)(0xc8834400 + (0x1a << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO5_EN_N                                (0xc8834400 + (0x1b << 2))
+#define SEC_PREG_PAD_GPIO5_EN_N                                (0xda834400 + (0x1b << 2))
+#define   P_PREG_PAD_GPIO5_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x1b << 2))
+#define     PREG_PAD_GPIO5_O                                   (0xc8834400 + (0x1c << 2))
+#define SEC_PREG_PAD_GPIO5_O                                   (0xda834400 + (0x1c << 2))
+#define   P_PREG_PAD_GPIO5_O                                   (volatile uint32_t *)(0xc8834400 + (0x1c << 2))
+#define     PREG_PAD_GPIO5_I                                   (0xc8834400 + (0x1d << 2))
+#define SEC_PREG_PAD_GPIO5_I                                   (0xda834400 + (0x1d << 2))
+#define   P_PREG_PAD_GPIO5_I                                   (volatile uint32_t *)(0xc8834400 + (0x1d << 2))
+// ----------------------------
+// ----------------------------
+// Pin Mux  (9)
+// ----------------------------
+#define     PERIPHS_PIN_MUX_0                                  (0xc8834400 + (0x2c << 2))
+#define SEC_PERIPHS_PIN_MUX_0                                  (0xda834400 + (0x2c << 2))
+#define   P_PERIPHS_PIN_MUX_0                                  (volatile uint32_t *)(0xc8834400 + (0x2c << 2))
+#define     PERIPHS_PIN_MUX_1                                  (0xc8834400 + (0x2d << 2))
+#define SEC_PERIPHS_PIN_MUX_1                                  (0xda834400 + (0x2d << 2))
+#define   P_PERIPHS_PIN_MUX_1                                  (volatile uint32_t *)(0xc8834400 + (0x2d << 2))
+#define     PERIPHS_PIN_MUX_2                                  (0xc8834400 + (0x2e << 2))
+#define SEC_PERIPHS_PIN_MUX_2                                  (0xda834400 + (0x2e << 2))
+#define   P_PERIPHS_PIN_MUX_2                                  (volatile uint32_t *)(0xc8834400 + (0x2e << 2))
+#define     PERIPHS_PIN_MUX_3                                  (0xc8834400 + (0x2f << 2))
+#define SEC_PERIPHS_PIN_MUX_3                                  (0xda834400 + (0x2f << 2))
+#define   P_PERIPHS_PIN_MUX_3                                  (volatile uint32_t *)(0xc8834400 + (0x2f << 2))
+#define     PERIPHS_PIN_MUX_4                                  (0xc8834400 + (0x30 << 2))
+#define SEC_PERIPHS_PIN_MUX_4                                  (0xda834400 + (0x30 << 2))
+#define   P_PERIPHS_PIN_MUX_4                                  (volatile uint32_t *)(0xc8834400 + (0x30 << 2))
+#define     PERIPHS_PIN_MUX_5                                  (0xc8834400 + (0x31 << 2))
+#define SEC_PERIPHS_PIN_MUX_5                                  (0xda834400 + (0x31 << 2))
+#define   P_PERIPHS_PIN_MUX_5                                  (volatile uint32_t *)(0xc8834400 + (0x31 << 2))
+#define     PERIPHS_PIN_MUX_6                                  (0xc8834400 + (0x32 << 2))
+#define SEC_PERIPHS_PIN_MUX_6                                  (0xda834400 + (0x32 << 2))
+#define   P_PERIPHS_PIN_MUX_6                                  (volatile uint32_t *)(0xc8834400 + (0x32 << 2))
+#define     PERIPHS_PIN_MUX_7                                  (0xc8834400 + (0x33 << 2))
+#define SEC_PERIPHS_PIN_MUX_7                                  (0xda834400 + (0x33 << 2))
+#define   P_PERIPHS_PIN_MUX_7                                  (volatile uint32_t *)(0xc8834400 + (0x33 << 2))
+#define     PERIPHS_PIN_MUX_8                                  (0xc8834400 + (0x34 << 2))
+#define SEC_PERIPHS_PIN_MUX_8                                  (0xda834400 + (0x34 << 2))
+#define   P_PERIPHS_PIN_MUX_8                                  (volatile uint32_t *)(0xc8834400 + (0x34 << 2))
+#define     PERIPHS_PIN_MUX_9                                  (0xc8834400 + (0x35 << 2))
+#define SEC_PERIPHS_PIN_MUX_9                                  (0xda834400 + (0x35 << 2))
+#define   P_PERIPHS_PIN_MUX_9                                  (volatile uint32_t *)(0xc8834400 + (0x35 << 2))
+#define     PERIPHS_PIN_MUX_10                                 (0xc8834400 + (0x36 << 2))
+#define SEC_PERIPHS_PIN_MUX_10                                 (0xda834400 + (0x36 << 2))
+#define   P_PERIPHS_PIN_MUX_10                                 (volatile uint32_t *)(0xc8834400 + (0x36 << 2))
+#define     PERIPHS_PIN_MUX_11                                 (0xc8834400 + (0x37 << 2))
+#define SEC_PERIPHS_PIN_MUX_11                                 (0xda834400 + (0x37 << 2))
+#define   P_PERIPHS_PIN_MUX_11                                 (volatile uint32_t *)(0xc8834400 + (0x37 << 2))
+#define     PERIPHS_PIN_MUX_12                                 (0xc8834400 + (0x38 << 2))
+#define SEC_PERIPHS_PIN_MUX_12                                 (0xda834400 + (0x38 << 2))
+#define   P_PERIPHS_PIN_MUX_12                                 (volatile uint32_t *)(0xc8834400 + (0x38 << 2))
+// ----------------------------
+// Pad conntrols
+// ----------------------------
+#define     PAD_PULL_UP_REG6                                   (0xc8834400 + (0x39 << 2))
+#define SEC_PAD_PULL_UP_REG6                                   (0xda834400 + (0x39 << 2))
+#define   P_PAD_PULL_UP_REG6                                   (volatile uint32_t *)(0xc8834400 + (0x39 << 2))
+#define     PAD_PULL_UP_REG0                                   (0xc8834400 + (0x3a << 2))
+#define SEC_PAD_PULL_UP_REG0                                   (0xda834400 + (0x3a << 2))
+#define   P_PAD_PULL_UP_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x3a << 2))
+#define     PAD_PULL_UP_REG1                                   (0xc8834400 + (0x3b << 2))
+#define SEC_PAD_PULL_UP_REG1                                   (0xda834400 + (0x3b << 2))
+#define   P_PAD_PULL_UP_REG1                                   (volatile uint32_t *)(0xc8834400 + (0x3b << 2))
+#define     PAD_PULL_UP_REG2                                   (0xc8834400 + (0x3c << 2))
+#define SEC_PAD_PULL_UP_REG2                                   (0xda834400 + (0x3c << 2))
+#define   P_PAD_PULL_UP_REG2                                   (volatile uint32_t *)(0xc8834400 + (0x3c << 2))
+#define     PAD_PULL_UP_REG3                                   (0xc8834400 + (0x3d << 2))
+#define SEC_PAD_PULL_UP_REG3                                   (0xda834400 + (0x3d << 2))
+#define   P_PAD_PULL_UP_REG3                                   (volatile uint32_t *)(0xc8834400 + (0x3d << 2))
+#define     PAD_PULL_UP_REG4                                   (0xc8834400 + (0x3e << 2))
+#define SEC_PAD_PULL_UP_REG4                                   (0xda834400 + (0x3e << 2))
+#define   P_PAD_PULL_UP_REG4                                   (volatile uint32_t *)(0xc8834400 + (0x3e << 2))
+#define     PAD_PULL_UP_REG5                                   (0xc8834400 + (0x3f << 2))
+#define SEC_PAD_PULL_UP_REG5                                   (0xda834400 + (0x3f << 2))
+#define   P_PAD_PULL_UP_REG5                                   (volatile uint32_t *)(0xc8834400 + (0x3f << 2))
+// ----------------------------
+// Random (2)
+// ----------------------------
+#define     RAND64_ADDR0                                       (0xc8834400 + (0x40 << 2))
+#define SEC_RAND64_ADDR0                                       (0xda834400 + (0x40 << 2))
+#define   P_RAND64_ADDR0                                       (volatile uint32_t *)(0xc8834400 + (0x40 << 2))
+#define     RAND64_ADDR1                                       (0xc8834400 + (0x41 << 2))
+#define SEC_RAND64_ADDR1                                       (0xda834400 + (0x41 << 2))
+#define   P_RAND64_ADDR1                                       (volatile uint32_t *)(0xc8834400 + (0x41 << 2))
+// ---------------------------
+// Ethernet (1)
+// ----------------------------
+#define     PREG_ETHERNET_ADDR0                                (0xc8834400 + (0x42 << 2))
+#define SEC_PREG_ETHERNET_ADDR0                                (0xda834400 + (0x42 << 2))
+#define   P_PREG_ETHERNET_ADDR0                                (volatile uint32_t *)(0xc8834400 + (0x42 << 2))
+// ---------------------------
+// AM_ANALOG_TOP
+// ----------------------------
+#define     PREG_AM_ANALOG_ADDR                                (0xc8834400 + (0x43 << 2))
+#define SEC_PREG_AM_ANALOG_ADDR                                (0xda834400 + (0x43 << 2))
+#define   P_PREG_AM_ANALOG_ADDR                                (volatile uint32_t *)(0xc8834400 + (0x43 << 2))
+// ---------------------------
+// Mali55 (1)
+// ----------------------------
+#define     PREG_MALI_BYTE_CNTL                                (0xc8834400 + (0x44 << 2))
+#define SEC_PREG_MALI_BYTE_CNTL                                (0xda834400 + (0x44 << 2))
+#define   P_PREG_MALI_BYTE_CNTL                                (volatile uint32_t *)(0xc8834400 + (0x44 << 2))
+// ---------------------------
+// WIFI (1)
+// ----------------------------
+#define     PREG_WIFI_CNTL                                     (0xc8834400 + (0x45 << 2))
+#define SEC_PREG_WIFI_CNTL                                     (0xda834400 + (0x45 << 2))
+#define   P_PREG_WIFI_CNTL                                     (volatile uint32_t *)(0xc8834400 + (0x45 << 2))
+#define     PAD_PULL_UP_EN_REG0                                (0xc8834400 + (0x48 << 2))
+#define SEC_PAD_PULL_UP_EN_REG0                                (0xda834400 + (0x48 << 2))
+#define   P_PAD_PULL_UP_EN_REG0                                (volatile uint32_t *)(0xc8834400 + (0x48 << 2))
+#define     PAD_PULL_UP_EN_REG1                                (0xc8834400 + (0x49 << 2))
+#define SEC_PAD_PULL_UP_EN_REG1                                (0xda834400 + (0x49 << 2))
+#define   P_PAD_PULL_UP_EN_REG1                                (volatile uint32_t *)(0xc8834400 + (0x49 << 2))
+#define     PAD_PULL_UP_EN_REG2                                (0xc8834400 + (0x4a << 2))
+#define SEC_PAD_PULL_UP_EN_REG2                                (0xda834400 + (0x4a << 2))
+#define   P_PAD_PULL_UP_EN_REG2                                (volatile uint32_t *)(0xc8834400 + (0x4a << 2))
+#define     PAD_PULL_UP_EN_REG3                                (0xc8834400 + (0x4b << 2))
+#define SEC_PAD_PULL_UP_EN_REG3                                (0xda834400 + (0x4b << 2))
+#define   P_PAD_PULL_UP_EN_REG3                                (volatile uint32_t *)(0xc8834400 + (0x4b << 2))
+#define     PAD_PULL_UP_EN_REG4                                (0xc8834400 + (0x4c << 2))
+#define SEC_PAD_PULL_UP_EN_REG4                                (0xda834400 + (0x4c << 2))
+#define   P_PAD_PULL_UP_EN_REG4                                (volatile uint32_t *)(0xc8834400 + (0x4c << 2))
+#define     PAD_PULL_UP_EN_REG5                                (0xc8834400 + (0x4d << 2))
+#define SEC_PAD_PULL_UP_EN_REG5                                (0xda834400 + (0x4d << 2))
+#define   P_PAD_PULL_UP_EN_REG5                                (volatile uint32_t *)(0xc8834400 + (0x4d << 2))
+#define     PAD_PULL_UP_EN_REG6                                (0xc8834400 + (0x4e << 2))
+#define SEC_PAD_PULL_UP_EN_REG6                                (0xda834400 + (0x4e << 2))
+#define   P_PAD_PULL_UP_EN_REG6                                (volatile uint32_t *)(0xc8834400 + (0x4e << 2))
+// ---------------------------
+#define     PREG_ETH_REG0                                      (0xc8834400 + (0x50 << 2))
+#define SEC_PREG_ETH_REG0                                      (0xda834400 + (0x50 << 2))
+#define   P_PREG_ETH_REG0                                      (volatile uint32_t *)(0xc8834400 + (0x50 << 2))
+#define     PREG_ETH_REG1                                      (0xc8834400 + (0x51 << 2))
+#define SEC_PREG_ETH_REG1                                      (0xda834400 + (0x51 << 2))
+#define   P_PREG_ETH_REG1                                      (volatile uint32_t *)(0xc8834400 + (0x51 << 2))
+#define     PREG_NAND_CFG_KEY0                                 (0xc8834400 + (0x52 << 2))
+#define SEC_PREG_NAND_CFG_KEY0                                 (0xda834400 + (0x52 << 2))
+#define   P_PREG_NAND_CFG_KEY0                                 (volatile uint32_t *)(0xc8834400 + (0x52 << 2))
+#define     PREG_NAND_CFG_KEY1                                 (0xc8834400 + (0x53 << 2))
+#define SEC_PREG_NAND_CFG_KEY1                                 (0xda834400 + (0x53 << 2))
+#define   P_PREG_NAND_CFG_KEY1                                 (volatile uint32_t *)(0xc8834400 + (0x53 << 2))
+#define     PREG_VPU_SECURE0                                   (0xc8834400 + (0x54 << 2))
+#define SEC_PREG_VPU_SECURE0                                   (0xda834400 + (0x54 << 2))
+#define   P_PREG_VPU_SECURE0                                   (volatile uint32_t *)(0xc8834400 + (0x54 << 2))
+#define     PREG_VPU_SECURE1                                   (0xc8834400 + (0x55 << 2))
+#define SEC_PREG_VPU_SECURE1                                   (0xda834400 + (0x55 << 2))
+#define   P_PREG_VPU_SECURE1                                   (volatile uint32_t *)(0xc8834400 + (0x55 << 2))
+#define     PREG_ETH_REG2                                      (0xc8834400 + (0x56 << 2))
+#define SEC_PREG_ETH_REG2                                      (0xda834400 + (0x56 << 2))
+#define   P_PREG_ETH_REG2                                      (volatile uint32_t *)(0xc8834400 + (0x56 << 2))
+#define     PREG_ETH_REG3                                      (0xc8834400 + (0x57 << 2))
+#define SEC_PREG_ETH_REG3                                      (0xda834400 + (0x57 << 2))
+#define   P_PREG_ETH_REG3                                      (volatile uint32_t *)(0xc8834400 + (0x57 << 2))
+#define     PREG_ETH_REG4                                      (0xc8834400 + (0x58 << 2))
+#define SEC_PREG_ETH_REG4                                      (0xda834400 + (0x58 << 2))
+#define   P_PREG_ETH_REG4                                      (volatile uint32_t *)(0xc8834400 + (0x58 << 2))
+// ---------------------------
+// Generic production test
+// ----------------------------
+#define     PROD_TEST_REG0                                     (0xc8834400 + (0x60 << 2))
+#define SEC_PROD_TEST_REG0                                     (0xda834400 + (0x60 << 2))
+#define   P_PROD_TEST_REG0                                     (volatile uint32_t *)(0xc8834400 + (0x60 << 2))
+#define     PROD_TEST_REG1                                     (0xc8834400 + (0x61 << 2))
+#define SEC_PROD_TEST_REG1                                     (0xda834400 + (0x61 << 2))
+#define   P_PROD_TEST_REG1                                     (volatile uint32_t *)(0xc8834400 + (0x61 << 2))
+#define     PROD_TEST_REG2                                     (0xc8834400 + (0x62 << 2))
+#define SEC_PROD_TEST_REG2                                     (0xda834400 + (0x62 << 2))
+#define   P_PROD_TEST_REG2                                     (volatile uint32_t *)(0xc8834400 + (0x62 << 2))
+#define     PROD_TEST_REG3                                     (0xc8834400 + (0x63 << 2))
+#define SEC_PROD_TEST_REG3                                     (0xda834400 + (0x63 << 2))
+#define   P_PROD_TEST_REG3                                     (volatile uint32_t *)(0xc8834400 + (0x63 << 2))
+// ---------------------------
+// am_analog_top
+// ----------------------------
+//`define METAL_REVISION                      8'h6a
+#define     ADC_TOP_MISC                                       (0xc8834400 + (0x6b << 2))
+#define SEC_ADC_TOP_MISC                                       (0xda834400 + (0x6b << 2))
+#define   P_ADC_TOP_MISC                                       (volatile uint32_t *)(0xc8834400 + (0x6b << 2))
+#define     DPLL_TOP_MISC                                      (0xc8834400 + (0x6c << 2))
+#define SEC_DPLL_TOP_MISC                                      (0xda834400 + (0x6c << 2))
+#define   P_DPLL_TOP_MISC                                      (volatile uint32_t *)(0xc8834400 + (0x6c << 2))
+#define     ANALOG_TOP_MISC                                    (0xc8834400 + (0x6d << 2))
+#define SEC_ANALOG_TOP_MISC                                    (0xda834400 + (0x6d << 2))
+#define   P_ANALOG_TOP_MISC                                    (volatile uint32_t *)(0xc8834400 + (0x6d << 2))
+#define     AM_ANALOG_TOP_REG0                                 (0xc8834400 + (0x6e << 2))
+#define SEC_AM_ANALOG_TOP_REG0                                 (0xda834400 + (0x6e << 2))
+#define   P_AM_ANALOG_TOP_REG0                                 (volatile uint32_t *)(0xc8834400 + (0x6e << 2))
+#define     AM_ANALOG_TOP_REG1                                 (0xc8834400 + (0x6f << 2))
+#define SEC_AM_ANALOG_TOP_REG1                                 (0xda834400 + (0x6f << 2))
+#define   P_AM_ANALOG_TOP_REG1                                 (volatile uint32_t *)(0xc8834400 + (0x6f << 2))
+// ---------------------------
+// Sticky regs
+// ----------------------------
+#define     PREG_STICKY_REG0                                   (0xc8834400 + (0x70 << 2))
+#define SEC_PREG_STICKY_REG0                                   (0xda834400 + (0x70 << 2))
+#define   P_PREG_STICKY_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x70 << 2))
+#define     PREG_STICKY_REG1                                   (0xc8834400 + (0x71 << 2))
+#define SEC_PREG_STICKY_REG1                                   (0xda834400 + (0x71 << 2))
+#define   P_PREG_STICKY_REG1                                   (volatile uint32_t *)(0xc8834400 + (0x71 << 2))
+#define     PREG_STICKY_REG2                                   (0xc8834400 + (0x72 << 2))
+#define SEC_PREG_STICKY_REG2                                   (0xda834400 + (0x72 << 2))
+#define   P_PREG_STICKY_REG2                                   (volatile uint32_t *)(0xc8834400 + (0x72 << 2))
+#define     PREG_STICKY_REG3                                   (0xc8834400 + (0x73 << 2))
+#define SEC_PREG_STICKY_REG3                                   (0xda834400 + (0x73 << 2))
+#define   P_PREG_STICKY_REG3                                   (volatile uint32_t *)(0xc8834400 + (0x73 << 2))
+#define     PREG_STICKY_REG4                                   (0xc8834400 + (0x74 << 2))
+#define SEC_PREG_STICKY_REG4                                   (0xda834400 + (0x74 << 2))
+#define   P_PREG_STICKY_REG4                                   (volatile uint32_t *)(0xc8834400 + (0x74 << 2))
+#define     PREG_STICKY_REG5                                   (0xc8834400 + (0x75 << 2))
+#define SEC_PREG_STICKY_REG5                                   (0xda834400 + (0x75 << 2))
+#define   P_PREG_STICKY_REG5                                   (volatile uint32_t *)(0xc8834400 + (0x75 << 2))
+#define     PREG_STICKY_REG6                                   (0xc8834400 + (0x76 << 2))
+#define SEC_PREG_STICKY_REG6                                   (0xda834400 + (0x76 << 2))
+#define   P_PREG_STICKY_REG6                                   (volatile uint32_t *)(0xc8834400 + (0x76 << 2))
+#define     PREG_STICKY_REG7                                   (0xc8834400 + (0x77 << 2))
+#define SEC_PREG_STICKY_REG7                                   (0xda834400 + (0x77 << 2))
+#define   P_PREG_STICKY_REG7                                   (volatile uint32_t *)(0xc8834400 + (0x77 << 2))
+#define     PREG_STICKY_REG8                                   (0xc8834400 + (0x78 << 2))
+#define SEC_PREG_STICKY_REG8                                   (0xda834400 + (0x78 << 2))
+#define   P_PREG_STICKY_REG8                                   (volatile uint32_t *)(0xc8834400 + (0x78 << 2))
+#define     PREG_STICKY_REG9                                   (0xc8834400 + (0x79 << 2))
+#define SEC_PREG_STICKY_REG9                                   (0xda834400 + (0x79 << 2))
+#define   P_PREG_STICKY_REG9                                   (volatile uint32_t *)(0xc8834400 + (0x79 << 2))
+#define     PREG_WRITE_ONCE_REG                                (0xc8834400 + (0x7e << 2))
+#define SEC_PREG_WRITE_ONCE_REG                                (0xda834400 + (0x7e << 2))
+#define   P_PREG_WRITE_ONCE_REG                                (volatile uint32_t *)(0xc8834400 + (0x7e << 2))
+// ---------------------------
+// AM Ring Oscillator
+// ----------------------------
+#define     AM_RING_OSC_REG0                                   (0xc8834400 + (0x7f << 2))
+#define SEC_AM_RING_OSC_REG0                                   (0xda834400 + (0x7f << 2))
+#define   P_AM_RING_OSC_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x7f << 2))
+// Control whether to provide random number to HDMITX20
+#define     HDMITX20_RNDNUM                                    (0xc8834400 + (0x80 << 2))
+#define SEC_HDMITX20_RNDNUM                                    (0xda834400 + (0x80 << 2))
+#define   P_HDMITX20_RNDNUM                                    (volatile uint32_t *)(0xc8834400 + (0x80 << 2))
+// ---------------------------
+// Bus Monitoring
+// ----------------------------
+#define     BUS_MONITOR_CNTL                                   (0xc8834400 + (0x81 << 2))
+#define SEC_BUS_MONITOR_CNTL                                   (0xda834400 + (0x81 << 2))
+#define   P_BUS_MONITOR_CNTL                                   (volatile uint32_t *)(0xc8834400 + (0x81 << 2))
+#define     BUS_MON0_ADDR                                      (0xc8834400 + (0x82 << 2))
+#define SEC_BUS_MON0_ADDR                                      (0xda834400 + (0x82 << 2))
+#define   P_BUS_MON0_ADDR                                      (volatile uint32_t *)(0xc8834400 + (0x82 << 2))
+#define     BUS_MON0_DATA                                      (0xc8834400 + (0x83 << 2))
+#define SEC_BUS_MON0_DATA                                      (0xda834400 + (0x83 << 2))
+#define   P_BUS_MON0_DATA                                      (volatile uint32_t *)(0xc8834400 + (0x83 << 2))
+#define     BUS_MON0_DATA_MSK                                  (0xc8834400 + (0x84 << 2))
+#define SEC_BUS_MON0_DATA_MSK                                  (0xda834400 + (0x84 << 2))
+#define   P_BUS_MON0_DATA_MSK                                  (volatile uint32_t *)(0xc8834400 + (0x84 << 2))
+#define     BUS_MON1_ADDR                                      (0xc8834400 + (0x85 << 2))
+#define SEC_BUS_MON1_ADDR                                      (0xda834400 + (0x85 << 2))
+#define   P_BUS_MON1_ADDR                                      (volatile uint32_t *)(0xc8834400 + (0x85 << 2))
+#define     BUS_MON1_DATA                                      (0xc8834400 + (0x86 << 2))
+#define SEC_BUS_MON1_DATA                                      (0xda834400 + (0x86 << 2))
+#define   P_BUS_MON1_DATA                                      (volatile uint32_t *)(0xc8834400 + (0x86 << 2))
+#define     BUS_MON1_DATA_MSK                                  (0xc8834400 + (0x87 << 2))
+#define SEC_BUS_MON1_DATA_MSK                                  (0xda834400 + (0x87 << 2))
+#define   P_BUS_MON1_DATA_MSK                                  (volatile uint32_t *)(0xc8834400 + (0x87 << 2))
+#define     ASYNC_FIFO_LOCK_ADR                                (0xc8834400 + (0x88 << 2))
+#define SEC_ASYNC_FIFO_LOCK_ADR                                (0xda834400 + (0x88 << 2))
+#define   P_ASYNC_FIFO_LOCK_ADR                                (volatile uint32_t *)(0xc8834400 + (0x88 << 2))
+#define     SECE_TIMER_CTRL                                    (0xc8834400 + (0x89 << 2))
+#define SEC_SECE_TIMER_CTRL                                    (0xda834400 + (0x89 << 2))
+#define   P_SECE_TIMER_CTRL                                    (volatile uint32_t *)(0xc8834400 + (0x89 << 2))
+#define     SECE_TIMER_LOW                                     (0xc8834400 + (0x8a << 2))
+#define SEC_SECE_TIMER_LOW                                     (0xda834400 + (0x8a << 2))
+#define   P_SECE_TIMER_LOW                                     (volatile uint32_t *)(0xc8834400 + (0x8a << 2))
+#define     SECE_TIMER_HIG                                     (0xc8834400 + (0x8b << 2))
+#define SEC_SECE_TIMER_HIG                                     (0xda834400 + (0x8b << 2))
+#define   P_SECE_TIMER_HIG                                     (volatile uint32_t *)(0xc8834400 + (0x8b << 2))
+// ---------------------------
+// System CPU control registers
+// ----------------------------
+#define     SYS_CPU_POR_CFG0                                   (0xc8834400 + (0x90 << 2))
+#define SEC_SYS_CPU_POR_CFG0                                   (0xda834400 + (0x90 << 2))
+#define   P_SYS_CPU_POR_CFG0                                   (volatile uint32_t *)(0xc8834400 + (0x90 << 2))
+#define     SYS_CPU_POR_CFG1                                   (0xc8834400 + (0x91 << 2))
+#define SEC_SYS_CPU_POR_CFG1                                   (0xda834400 + (0x91 << 2))
+#define   P_SYS_CPU_POR_CFG1                                   (volatile uint32_t *)(0xc8834400 + (0x91 << 2))
+#define     SYS_CPU_CFG0                                       (0xc8834400 + (0x92 << 2))
+#define SEC_SYS_CPU_CFG0                                       (0xda834400 + (0x92 << 2))
+#define   P_SYS_CPU_CFG0                                       (volatile uint32_t *)(0xc8834400 + (0x92 << 2))
+#define     SYS_CPU_CFG1                                       (0xc8834400 + (0x93 << 2))
+#define SEC_SYS_CPU_CFG1                                       (0xda834400 + (0x93 << 2))
+#define   P_SYS_CPU_CFG1                                       (volatile uint32_t *)(0xc8834400 + (0x93 << 2))
+#define     SYS_CPU_CFG2                                       (0xc8834400 + (0x94 << 2))
+#define SEC_SYS_CPU_CFG2                                       (0xda834400 + (0x94 << 2))
+#define   P_SYS_CPU_CFG2                                       (volatile uint32_t *)(0xc8834400 + (0x94 << 2))
+#define     SYS_CPU_CFG3                                       (0xc8834400 + (0x95 << 2))
+#define SEC_SYS_CPU_CFG3                                       (0xda834400 + (0x95 << 2))
+#define   P_SYS_CPU_CFG3                                       (volatile uint32_t *)(0xc8834400 + (0x95 << 2))
+#define     SYS_CPU_CFG4                                       (0xc8834400 + (0x96 << 2))
+#define SEC_SYS_CPU_CFG4                                       (0xda834400 + (0x96 << 2))
+#define   P_SYS_CPU_CFG4                                       (volatile uint32_t *)(0xc8834400 + (0x96 << 2))
+#define     SYS_CPU_CFG5                                       (0xc8834400 + (0x97 << 2))
+#define SEC_SYS_CPU_CFG5                                       (0xda834400 + (0x97 << 2))
+#define   P_SYS_CPU_CFG5                                       (volatile uint32_t *)(0xc8834400 + (0x97 << 2))
+#define     SYS_CPU_CFG6                                       (0xc8834400 + (0x98 << 2))
+#define SEC_SYS_CPU_CFG6                                       (0xda834400 + (0x98 << 2))
+#define   P_SYS_CPU_CFG6                                       (volatile uint32_t *)(0xc8834400 + (0x98 << 2))
+#define     SYS_CPU_CFG7                                       (0xc8834400 + (0x99 << 2))
+#define SEC_SYS_CPU_CFG7                                       (0xda834400 + (0x99 << 2))
+#define   P_SYS_CPU_CFG7                                       (volatile uint32_t *)(0xc8834400 + (0x99 << 2))
+#define     SYS_CPU_CFG8                                       (0xc8834400 + (0x9a << 2))
+#define SEC_SYS_CPU_CFG8                                       (0xda834400 + (0x9a << 2))
+#define   P_SYS_CPU_CFG8                                       (volatile uint32_t *)(0xc8834400 + (0x9a << 2))
+#define     SYS_CPU_CFG9                                       (0xc8834400 + (0x9b << 2))
+#define SEC_SYS_CPU_CFG9                                       (0xda834400 + (0x9b << 2))
+#define   P_SYS_CPU_CFG9                                       (volatile uint32_t *)(0xc8834400 + (0x9b << 2))
+#define     SYS_CPU_CFG10                                      (0xc8834400 + (0x9c << 2))
+#define SEC_SYS_CPU_CFG10                                      (0xda834400 + (0x9c << 2))
+#define   P_SYS_CPU_CFG10                                      (volatile uint32_t *)(0xc8834400 + (0x9c << 2))
+#define     SYS_CPU_CFG11                                      (0xc8834400 + (0x9d << 2))
+#define SEC_SYS_CPU_CFG11                                      (0xda834400 + (0x9d << 2))
+#define   P_SYS_CPU_CFG11                                      (volatile uint32_t *)(0xc8834400 + (0x9d << 2))
+#define     SYS_CPU_CFG12                                      (0xc8834400 + (0x9e << 2))
+#define SEC_SYS_CPU_CFG12                                      (0xda834400 + (0x9e << 2))
+#define   P_SYS_CPU_CFG12                                      (volatile uint32_t *)(0xc8834400 + (0x9e << 2))
+#define     SYS_CPU_CFG13                                      (0xc8834400 + (0x9f << 2))
+#define SEC_SYS_CPU_CFG13                                      (0xda834400 + (0x9f << 2))
+#define   P_SYS_CPU_CFG13                                      (volatile uint32_t *)(0xc8834400 + (0x9f << 2))
+#define     SYS_CPU_STATUS0                                    (0xc8834400 + (0xa0 << 2))
+#define SEC_SYS_CPU_STATUS0                                    (0xda834400 + (0xa0 << 2))
+#define   P_SYS_CPU_STATUS0                                    (volatile uint32_t *)(0xc8834400 + (0xa0 << 2))
+#define     SYS_CPU_STATUS1                                    (0xc8834400 + (0xa1 << 2))
+#define SEC_SYS_CPU_STATUS1                                    (0xda834400 + (0xa1 << 2))
+#define   P_SYS_CPU_STATUS1                                    (volatile uint32_t *)(0xc8834400 + (0xa1 << 2))
+#define     SYS_CPU_STATUS2                                    (0xc8834400 + (0xa2 << 2))
+#define SEC_SYS_CPU_STATUS2                                    (0xda834400 + (0xa2 << 2))
+#define   P_SYS_CPU_STATUS2                                    (volatile uint32_t *)(0xc8834400 + (0xa2 << 2))
+#define     SYS_CPU_STATUS3                                    (0xc8834400 + (0xa3 << 2))
+#define SEC_SYS_CPU_STATUS3                                    (0xda834400 + (0xa3 << 2))
+#define   P_SYS_CPU_STATUS3                                    (volatile uint32_t *)(0xc8834400 + (0xa3 << 2))
+#define     SYS_CPU_STATUS4                                    (0xc8834400 + (0xa4 << 2))
+#define SEC_SYS_CPU_STATUS4                                    (0xda834400 + (0xa4 << 2))
+#define   P_SYS_CPU_STATUS4                                    (volatile uint32_t *)(0xc8834400 + (0xa4 << 2))
+#define     SYS_CPU_STATUS5                                    (0xc8834400 + (0xa5 << 2))
+#define SEC_SYS_CPU_STATUS5                                    (0xda834400 + (0xa5 << 2))
+#define   P_SYS_CPU_STATUS5                                    (volatile uint32_t *)(0xc8834400 + (0xa5 << 2))
+#define     SYS_CPU_MISC                                       (0xc8834400 + (0xa8 << 2))
+#define SEC_SYS_CPU_MISC                                       (0xda834400 + (0xa8 << 2))
+#define   P_SYS_CPU_MISC                                       (volatile uint32_t *)(0xc8834400 + (0xa8 << 2))
+//========================================================================
+//  HIU - Registers
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hC883C000
+// APB4_DECODER_SECURE_BASE         32'hDA83C000
+#define     SCR_HIU                                            (0xc883c000 + (0x0b << 2))
+#define SEC_SCR_HIU                                            (0xda83c000 + (0x0b << 2))
+#define   P_SCR_HIU                                            (volatile uint32_t *)(0xc883c000 + (0x0b << 2))
+#define     HPG_TIMER                                          (0xc883c000 + (0x0f << 2))
+#define SEC_HPG_TIMER                                          (0xda83c000 + (0x0f << 2))
+#define   P_HPG_TIMER                                          (volatile uint32_t *)(0xc883c000 + (0x0f << 2))
+#define     HHI_GP0_PLL_CNTL                                   (0xc883c000 + (0x10 << 2))
+#define SEC_HHI_GP0_PLL_CNTL                                   (0xda83c000 + (0x10 << 2))
+#define   P_HHI_GP0_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x10 << 2))
+#define     HHI_GP0_PLL_CNTL2                                  (0xc883c000 + (0x11 << 2))
+#define SEC_HHI_GP0_PLL_CNTL2                                  (0xda83c000 + (0x11 << 2))
+#define   P_HHI_GP0_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x11 << 2))
+#define     HHI_GP0_PLL_CNTL3                                  (0xc883c000 + (0x12 << 2))
+#define SEC_HHI_GP0_PLL_CNTL3                                  (0xda83c000 + (0x12 << 2))
+#define   P_HHI_GP0_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x12 << 2))
+#define     HHI_GP0_PLL_CNTL4                                  (0xc883c000 + (0x13 << 2))
+#define SEC_HHI_GP0_PLL_CNTL4                                  (0xda83c000 + (0x13 << 2))
+#define   P_HHI_GP0_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0x13 << 2))
+#define     HHI_GP0_PLL_CNTL5                                  (0xc883c000 + (0x14 << 2))
+#define SEC_HHI_GP0_PLL_CNTL5                                  (0xda83c000 + (0x14 << 2))
+#define   P_HHI_GP0_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x14 << 2))
+#define     HHI_GP0_PLL_STS                                    (0xc883c000 + (0x15 << 2))
+#define SEC_HHI_GP0_PLL_STS                                    (0xda83c000 + (0x15 << 2))
+#define   P_HHI_GP0_PLL_STS                                    (volatile uint32_t *)(0xc883c000 + (0x15 << 2))
+#define     HHI_GP0_PLL_CNTL1                                  (0xc883c000 + (0x16 << 2))
+#define SEC_HHI_GP0_PLL_CNTL1                                  (0xda83c000 + (0x16 << 2))
+#define   P_HHI_GP0_PLL_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0x16 << 2))
+#define     HHI_GP1_PLL_CNTL                                   (0xc883c000 + (0x18 << 2))
+#define SEC_HHI_GP1_PLL_CNTL                                   (0xda83c000 + (0x18 << 2))
+#define   P_HHI_GP1_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x18 << 2))
+#define     HHI_GP1_PLL_CNTL2                                  (0xc883c000 + (0x19 << 2))
+#define SEC_HHI_GP1_PLL_CNTL2                                  (0xda83c000 + (0x19 << 2))
+#define   P_HHI_GP1_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x19 << 2))
+#define     HHI_GP1_PLL_CNTL3                                  (0xc883c000 + (0x1a << 2))
+#define SEC_HHI_GP1_PLL_CNTL3                                  (0xda83c000 + (0x1a << 2))
+#define   P_HHI_GP1_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x1a << 2))
+#define     HHI_GP1_PLL_CNTL4                                  (0xc883c000 + (0x1b << 2))
+#define SEC_HHI_GP1_PLL_CNTL4                                  (0xda83c000 + (0x1b << 2))
+#define   P_HHI_GP1_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0x1b << 2))
+#define     HHI_GP1_PLL_CNTL5                                  (0xc883c000 + (0x1c << 2))
+#define SEC_HHI_GP1_PLL_CNTL5                                  (0xda83c000 + (0x1c << 2))
+#define   P_HHI_GP1_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x1c << 2))
+#define     HHI_GP1_PLL_STS                                    (0xc883c000 + (0x1d << 2))
+#define SEC_HHI_GP1_PLL_STS                                    (0xda83c000 + (0x1d << 2))
+#define   P_HHI_GP1_PLL_STS                                    (volatile uint32_t *)(0xc883c000 + (0x1d << 2))
+#define     HHI_GP1_PLL_CNTL1                                  (0xc883c000 + (0x1e << 2))
+#define SEC_HHI_GP1_PLL_CNTL1                                  (0xda83c000 + (0x1e << 2))
+#define   P_HHI_GP1_PLL_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0x1e << 2))
+#define     HHI_CADC_CNTL                                      (0xc883c000 + (0x20 << 2))
+#define SEC_HHI_CADC_CNTL                                      (0xda83c000 + (0x20 << 2))
+#define   P_HHI_CADC_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0x20 << 2))
+#define     HHI_CADC_CNTL2                                     (0xc883c000 + (0x21 << 2))
+#define SEC_HHI_CADC_CNTL2                                     (0xda83c000 + (0x21 << 2))
+#define   P_HHI_CADC_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0x21 << 2))
+#define     HHI_CADC_CNTL3                                     (0xc883c000 + (0x22 << 2))
+#define SEC_HHI_CADC_CNTL3                                     (0xda83c000 + (0x22 << 2))
+#define   P_HHI_CADC_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0x22 << 2))
+#define     HHI_CADC_CNTL4                                     (0xc883c000 + (0x23 << 2))
+#define SEC_HHI_CADC_CNTL4                                     (0xda83c000 + (0x23 << 2))
+#define   P_HHI_CADC_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0x23 << 2))
+#define     HHI_CADC_CNTL5                                     (0xc883c000 + (0x24 << 2))
+#define SEC_HHI_CADC_CNTL5                                     (0xda83c000 + (0x24 << 2))
+#define   P_HHI_CADC_CNTL5                                     (volatile uint32_t *)(0xc883c000 + (0x24 << 2))
+#define     HHI_CADC_CNTL6                                     (0xc883c000 + (0x25 << 2))
+#define SEC_HHI_CADC_CNTL6                                     (0xda83c000 + (0x25 << 2))
+#define   P_HHI_CADC_CNTL6                                     (volatile uint32_t *)(0xc883c000 + (0x25 << 2))
+#define     HHI_DADC_CNTL                                      (0xc883c000 + (0x27 << 2))
+#define SEC_HHI_DADC_CNTL                                      (0xda83c000 + (0x27 << 2))
+#define   P_HHI_DADC_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0x27 << 2))
+#define     HHI_DADC_CNTL2                                     (0xc883c000 + (0x28 << 2))
+#define SEC_HHI_DADC_CNTL2                                     (0xda83c000 + (0x28 << 2))
+#define   P_HHI_DADC_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0x28 << 2))
+#define     HHI_DADC_RDBK0_I                                   (0xc883c000 + (0x29 << 2))
+#define SEC_HHI_DADC_RDBK0_I                                   (0xda83c000 + (0x29 << 2))
+#define   P_HHI_DADC_RDBK0_I                                   (volatile uint32_t *)(0xc883c000 + (0x29 << 2))
+#define     HHI_DADC_CNTL3                                     (0xc883c000 + (0x2a << 2))
+#define SEC_HHI_DADC_CNTL3                                     (0xda83c000 + (0x2a << 2))
+#define   P_HHI_DADC_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0x2a << 2))
+#define     HHI_DADC_CNTL4                                     (0xc883c000 + (0x2b << 2))
+#define SEC_HHI_DADC_CNTL4                                     (0xda83c000 + (0x2b << 2))
+#define   P_HHI_DADC_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0x2b << 2))
+#define     HHI_AFE_TUNNING_CNTL                               (0xc883c000 + (0x2c << 2))
+#define SEC_HHI_AFE_TUNNING_CNTL                               (0xda83c000 + (0x2c << 2))
+#define   P_HHI_AFE_TUNNING_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x2c << 2))
+#define     HHI_AFE_TUNNING_CNTL_I                             (0xc883c000 + (0x2d << 2))
+#define SEC_HHI_AFE_TUNNING_CNTL_I                             (0xda83c000 + (0x2d << 2))
+#define   P_HHI_AFE_TUNNING_CNTL_I                             (volatile uint32_t *)(0xc883c000 + (0x2d << 2))
+#define     HHI_XTAL_DIVN_CNTL                                 (0xc883c000 + (0x2f << 2))
+#define SEC_HHI_XTAL_DIVN_CNTL                                 (0xda83c000 + (0x2f << 2))
+#define   P_HHI_XTAL_DIVN_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x2f << 2))
+#define     HHI_GCLK2_MPEG0                                    (0xc883c000 + (0x30 << 2))
+#define SEC_HHI_GCLK2_MPEG0                                    (0xda83c000 + (0x30 << 2))
+#define   P_HHI_GCLK2_MPEG0                                    (volatile uint32_t *)(0xc883c000 + (0x30 << 2))
+#define     HHI_GCLK2_MPEG1                                    (0xc883c000 + (0x31 << 2))
+#define SEC_HHI_GCLK2_MPEG1                                    (0xda83c000 + (0x31 << 2))
+#define   P_HHI_GCLK2_MPEG1                                    (volatile uint32_t *)(0xc883c000 + (0x31 << 2))
+#define     HHI_GCLK2_MPEG2                                    (0xc883c000 + (0x32 << 2))
+#define SEC_HHI_GCLK2_MPEG2                                    (0xda83c000 + (0x32 << 2))
+#define   P_HHI_GCLK2_MPEG2                                    (volatile uint32_t *)(0xc883c000 + (0x32 << 2))
+#define     HHI_GCLK2_OTHER                                    (0xc883c000 + (0x34 << 2))
+#define SEC_HHI_GCLK2_OTHER                                    (0xda83c000 + (0x34 << 2))
+#define   P_HHI_GCLK2_OTHER                                    (volatile uint32_t *)(0xc883c000 + (0x34 << 2))
+#define     HHI_GCLK2_AO                                       (0xc883c000 + (0x35 << 2))
+#define SEC_HHI_GCLK2_AO                                       (0xda83c000 + (0x35 << 2))
+#define   P_HHI_GCLK2_AO                                       (volatile uint32_t *)(0xc883c000 + (0x35 << 2))
+#define     HHI_TIMER90K                                       (0xc883c000 + (0x3b << 2))
+#define SEC_HHI_TIMER90K                                       (0xda83c000 + (0x3b << 2))
+#define   P_HHI_TIMER90K                                       (volatile uint32_t *)(0xc883c000 + (0x3b << 2))
+#define     HHI_MEM_PD_REG0                                    (0xc883c000 + (0x40 << 2))
+#define SEC_HHI_MEM_PD_REG0                                    (0xda83c000 + (0x40 << 2))
+#define   P_HHI_MEM_PD_REG0                                    (volatile uint32_t *)(0xc883c000 + (0x40 << 2))
+//VIU1
+//bit 29:28 mem_pd_vi_sharp,  2'b00: Sharpness line buffer memory power on, 2'b11: power down
+//bit 29:28 mem_pd_vi_dipost, 2'b00: Deinterlace - di_post memory power on, 2'b11: power down
+//bit 27:26 mem_pd_vi_dipre,  2'b00: Deinterlace - di_pre memory power on, 2'b11: power down
+//bit 25:24 mem_pd_vi_prot3,  2'b00: picture rotation3 memory power on, 2'b11: power down
+//bit 23:22 mem_pd_vi_prot2,  2'b00: picture rotation2 memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vi_prot1,  2'b00: picture rotation1 memory power on, 2'b11: power down
+//bit 19:18 mem_pd_vi_vdin1,  2'b00: vdin1 memory power on, 2'b11: power down
+//bit 17:16 mem_pd_vi_vdin0,  2'b00: vdin0 memory power on, 2'b11: power down
+//bit 15:14 mem_pd_vi_osd_sc, 2'b00: osd_scaler memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi_scale,  2'b00: scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi_ofifo,  2'b00: vpp output fifo memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi_chroma, 2'b00: color management module memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi_vd2,    2'b00: vd2 memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi_vd1,    2'b00: vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi_osd2,   2'b00: osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi_osd1,   2'b00: osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG0                                (0xc883c000 + (0x41 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG0                                (0xda83c000 + (0x41 << 2))
+#define   P_HHI_VPU_MEM_PD_REG0                                (volatile uint32_t *)(0xc883c000 + (0x41 << 2))
+//bit 29:28 mem_pd_atv_dmd,   2'b00: ATV DMD memory power on, 2'b11: power down
+//bit 29:28 mem_pd_cvd2,      2'b00: CVD2 memory power on, 2'b11: power down
+//bit 27:26 mem_pd_isp,       2'b00: ISP memory power on, 2'b11: power down
+//bit 25:24 mem_pd_venci_int, 2'b00: cvbs- enci interface memory power on, 2'b11: power down
+//bit 23:22 mem_pd_venc_l_top,2'b00: panel - encl top memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vencp_int, 2'b00: hdmi - encp interface memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi2_osd_sc,2'b00: viu2 OSD scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi2_scale, 2'b00: viu2 scaler memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi2_ofifo, 2'b00: viu2 vpp output fifo memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi2_chroma,2'b00: viu2 color management module memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi2_vd1,   2'b00: viu2 vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi2_osd2,  2'b00: viu2 osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi2_osd1,  2'b00: viu2 osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG1                                (0xc883c000 + (0x42 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG1                                (0xda83c000 + (0x42 << 2))
+#define   P_HHI_VPU_MEM_PD_REG1                                (volatile uint32_t *)(0xc883c000 + (0x42 << 2))
+#define     HHI_DEMOD_MEM_PD_REG                               (0xc883c000 + (0x43 << 2))
+#define SEC_HHI_DEMOD_MEM_PD_REG                               (0xda83c000 + (0x43 << 2))
+#define   P_HHI_DEMOD_MEM_PD_REG                               (volatile uint32_t *)(0xc883c000 + (0x43 << 2))
+#define     HHI_AUD_DAC_CTRL                                   (0xc883c000 + (0x44 << 2))
+#define SEC_HHI_AUD_DAC_CTRL                                   (0xda83c000 + (0x44 << 2))
+#define   P_HHI_AUD_DAC_CTRL                                   (volatile uint32_t *)(0xc883c000 + (0x44 << 2))
+// `define HHI_VIID_PLL_CNTL4      8'h46 // video PLL read back
+// `define HHI_VIID_PLL_CNTL       8'h47 // Video PLL control, word 1
+// `define HHI_VIID_PLL_CNTL2      8'h48 // Video PLL control, word 2
+// `define HHI_VIID_PLL_CNTL3      8'h49 // Video PLL control, word 3
+#define     HHI_VIID_CLK_DIV                                   (0xc883c000 + (0x4a << 2))
+#define SEC_HHI_VIID_CLK_DIV                                   (0xda83c000 + (0x4a << 2))
+#define   P_HHI_VIID_CLK_DIV                                   (volatile uint32_t *)(0xc883c000 + (0x4a << 2))
+#define     HHI_VIID_CLK_CNTL                                  (0xc883c000 + (0x4b << 2))
+#define SEC_HHI_VIID_CLK_CNTL                                  (0xda83c000 + (0x4b << 2))
+#define   P_HHI_VIID_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x4b << 2))
+#define     HHI_VIID_DIVIDER_CNTL                              (0xc883c000 + (0x4c << 2))
+#define SEC_HHI_VIID_DIVIDER_CNTL                              (0xda83c000 + (0x4c << 2))
+#define   P_HHI_VIID_DIVIDER_CNTL                              (volatile uint32_t *)(0xc883c000 + (0x4c << 2))
+//bit 1:0   mem_pd_vi_wm,  2'b00: viu1 wm memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG2                                (0xc883c000 + (0x4d << 2))
+#define SEC_HHI_VPU_MEM_PD_REG2                                (0xda83c000 + (0x4d << 2))
+#define   P_HHI_VPU_MEM_PD_REG2                                (volatile uint32_t *)(0xc883c000 + (0x4d << 2))
+// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
+#define     HHI_GCLK_MPEG0                                     (0xc883c000 + (0x50 << 2))
+#define SEC_HHI_GCLK_MPEG0                                     (0xda83c000 + (0x50 << 2))
+#define   P_HHI_GCLK_MPEG0                                     (volatile uint32_t *)(0xc883c000 + (0x50 << 2))
+#define     HHI_GCLK_MPEG1                                     (0xc883c000 + (0x51 << 2))
+#define SEC_HHI_GCLK_MPEG1                                     (0xda83c000 + (0x51 << 2))
+#define   P_HHI_GCLK_MPEG1                                     (volatile uint32_t *)(0xc883c000 + (0x51 << 2))
+#define     HHI_GCLK_MPEG2                                     (0xc883c000 + (0x52 << 2))
+#define SEC_HHI_GCLK_MPEG2                                     (0xda83c000 + (0x52 << 2))
+#define   P_HHI_GCLK_MPEG2                                     (volatile uint32_t *)(0xc883c000 + (0x52 << 2))
+#define     HHI_GCLK_OTHER                                     (0xc883c000 + (0x54 << 2))
+#define SEC_HHI_GCLK_OTHER                                     (0xda83c000 + (0x54 << 2))
+#define   P_HHI_GCLK_OTHER                                     (volatile uint32_t *)(0xc883c000 + (0x54 << 2))
+#define     HHI_GCLK_AO                                        (0xc883c000 + (0x55 << 2))
+#define SEC_HHI_GCLK_AO                                        (0xda83c000 + (0x55 << 2))
+#define   P_HHI_GCLK_AO                                        (volatile uint32_t *)(0xc883c000 + (0x55 << 2))
+//`define HHI_SYS_OSCIN_CNTL      8'h56
+#define     HHI_SYS_CPU_CLK_CNTL1                              (0xc883c000 + (0x57 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL1                              (0xda83c000 + (0x57 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0x57 << 2))
+#define     HHI_SYS_CPU_RESET_CNTL                             (0xc883c000 + (0x58 << 2))
+#define SEC_HHI_SYS_CPU_RESET_CNTL                             (0xda83c000 + (0x58 << 2))
+#define   P_HHI_SYS_CPU_RESET_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x58 << 2))
+// PLL Controls
+#define     HHI_VID_CLK_DIV                                    (0xc883c000 + (0x59 << 2))
+#define SEC_HHI_VID_CLK_DIV                                    (0xda83c000 + (0x59 << 2))
+#define   P_HHI_VID_CLK_DIV                                    (volatile uint32_t *)(0xc883c000 + (0x59 << 2))
+#define     HHI_MPEG_CLK_CNTL                                  (0xc883c000 + (0x5d << 2))
+#define SEC_HHI_MPEG_CLK_CNTL                                  (0xda83c000 + (0x5d << 2))
+#define   P_HHI_MPEG_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x5d << 2))
+#define     HHI_AUD_CLK_CNTL                                   (0xc883c000 + (0x5e << 2))
+#define SEC_HHI_AUD_CLK_CNTL                                   (0xda83c000 + (0x5e << 2))
+#define   P_HHI_AUD_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x5e << 2))
+#define     HHI_VID_CLK_CNTL                                   (0xc883c000 + (0x5f << 2))
+#define SEC_HHI_VID_CLK_CNTL                                   (0xda83c000 + (0x5f << 2))
+#define   P_HHI_VID_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x5f << 2))
+#define     HHI_WIFI_CLK_CNTL                                  (0xc883c000 + (0x60 << 2))
+#define SEC_HHI_WIFI_CLK_CNTL                                  (0xda83c000 + (0x60 << 2))
+#define   P_HHI_WIFI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x60 << 2))
+#define     HHI_WIFI_PLL_CNTL                                  (0xc883c000 + (0x61 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL                                  (0xda83c000 + (0x61 << 2))
+#define   P_HHI_WIFI_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x61 << 2))
+#define     HHI_WIFI_PLL_CNTL2                                 (0xc883c000 + (0x62 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL2                                 (0xda83c000 + (0x62 << 2))
+#define   P_HHI_WIFI_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0x62 << 2))
+#define     HHI_WIFI_PLL_CNTL3                                 (0xc883c000 + (0x63 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL3                                 (0xda83c000 + (0x63 << 2))
+#define   P_HHI_WIFI_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0x63 << 2))
+#define     HHI_AUD_CLK_CNTL2                                  (0xc883c000 + (0x64 << 2))
+#define SEC_HHI_AUD_CLK_CNTL2                                  (0xda83c000 + (0x64 << 2))
+#define   P_HHI_AUD_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x64 << 2))
+#define     HHI_VID_CLK_CNTL2                                  (0xc883c000 + (0x65 << 2))
+#define SEC_HHI_VID_CLK_CNTL2                                  (0xda83c000 + (0x65 << 2))
+#define   P_HHI_VID_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x65 << 2))
+#define     HHI_VID_DIVIDER_CNTL                               (0xc883c000 + (0x66 << 2))
+#define SEC_HHI_VID_DIVIDER_CNTL                               (0xda83c000 + (0x66 << 2))
+#define   P_HHI_VID_DIVIDER_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x66 << 2))
+#define     HHI_SYS_CPU_CLK_CNTL                               (0xc883c000 + (0x67 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL                               (0xda83c000 + (0x67 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x67 << 2))
+#define     HHI_VID_PLL_CLK_DIV                                (0xc883c000 + (0x68 << 2))
+#define SEC_HHI_VID_PLL_CLK_DIV                                (0xda83c000 + (0x68 << 2))
+#define   P_HHI_VID_PLL_CLK_DIV                                (volatile uint32_t *)(0xc883c000 + (0x68 << 2))
+#define     HHI_AUD_CLK_CNTL3                                  (0xc883c000 + (0x69 << 2))
+#define SEC_HHI_AUD_CLK_CNTL3                                  (0xda83c000 + (0x69 << 2))
+#define   P_HHI_AUD_CLK_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x69 << 2))
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL        8'h68 // DDR PLL control, word 1
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL2       8'h69 // DDR PLL control, word 2
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL3       8'h6a // DDR PLL control, word 3
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL4       8'h6b // DDR PLL control, word 3
+#define     HHI_MALI_CLK_CNTL                                  (0xc883c000 + (0x6c << 2))
+#define SEC_HHI_MALI_CLK_CNTL                                  (0xda83c000 + (0x6c << 2))
+#define   P_HHI_MALI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x6c << 2))
+#define     HHI_MIPI_PHY_CLK_CNTL                              (0xc883c000 + (0x6e << 2))
+#define SEC_HHI_MIPI_PHY_CLK_CNTL                              (0xda83c000 + (0x6e << 2))
+#define   P_HHI_MIPI_PHY_CLK_CNTL                              (volatile uint32_t *)(0xc883c000 + (0x6e << 2))
+#define     HHI_VPU_CLK_CNTL                                   (0xc883c000 + (0x6f << 2))
+#define SEC_HHI_VPU_CLK_CNTL                                   (0xda83c000 + (0x6f << 2))
+#define   P_HHI_VPU_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x6f << 2))
+#define     HHI_OTHER_PLL_CNTL                                 (0xc883c000 + (0x70 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL                                 (0xda83c000 + (0x70 << 2))
+#define   P_HHI_OTHER_PLL_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x70 << 2))
+#define     HHI_OTHER_PLL_CNTL2                                (0xc883c000 + (0x71 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL2                                (0xda83c000 + (0x71 << 2))
+#define   P_HHI_OTHER_PLL_CNTL2                                (volatile uint32_t *)(0xc883c000 + (0x71 << 2))
+#define     HHI_OTHER_PLL_CNTL3                                (0xc883c000 + (0x72 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL3                                (0xda83c000 + (0x72 << 2))
+#define   P_HHI_OTHER_PLL_CNTL3                                (volatile uint32_t *)(0xc883c000 + (0x72 << 2))
+#define     HHI_HDMI_CLK_CNTL                                  (0xc883c000 + (0x73 << 2))
+#define SEC_HHI_HDMI_CLK_CNTL                                  (0xda83c000 + (0x73 << 2))
+#define   P_HHI_HDMI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x73 << 2))
+#define     HHI_DEMOD_CLK_CNTL                                 (0xc883c000 + (0x74 << 2))
+#define SEC_HHI_DEMOD_CLK_CNTL                                 (0xda83c000 + (0x74 << 2))
+#define   P_HHI_DEMOD_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x74 << 2))
+#define     HHI_SATA_CLK_CNTL                                  (0xc883c000 + (0x75 << 2))
+#define SEC_HHI_SATA_CLK_CNTL                                  (0xda83c000 + (0x75 << 2))
+#define   P_HHI_SATA_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x75 << 2))
+#define     HHI_ETH_CLK_CNTL                                   (0xc883c000 + (0x76 << 2))
+#define SEC_HHI_ETH_CLK_CNTL                                   (0xda83c000 + (0x76 << 2))
+#define   P_HHI_ETH_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x76 << 2))
+#define     HHI_CLK_DOUBLE_CNTL                                (0xc883c000 + (0x77 << 2))
+#define SEC_HHI_CLK_DOUBLE_CNTL                                (0xda83c000 + (0x77 << 2))
+#define   P_HHI_CLK_DOUBLE_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x77 << 2))
+#define     HHI_VDEC_CLK_CNTL                                  (0xc883c000 + (0x78 << 2))
+#define SEC_HHI_VDEC_CLK_CNTL                                  (0xda83c000 + (0x78 << 2))
+#define   P_HHI_VDEC_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x78 << 2))
+#define     HHI_VDEC2_CLK_CNTL                                 (0xc883c000 + (0x79 << 2))
+#define SEC_HHI_VDEC2_CLK_CNTL                                 (0xda83c000 + (0x79 << 2))
+#define   P_HHI_VDEC2_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x79 << 2))
+#define     HHI_VDEC3_CLK_CNTL                                 (0xc883c000 + (0x7a << 2))
+#define SEC_HHI_VDEC3_CLK_CNTL                                 (0xda83c000 + (0x7a << 2))
+#define   P_HHI_VDEC3_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x7a << 2))
+#define     HHI_VDEC4_CLK_CNTL                                 (0xc883c000 + (0x7b << 2))
+#define SEC_HHI_VDEC4_CLK_CNTL                                 (0xda83c000 + (0x7b << 2))
+#define   P_HHI_VDEC4_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x7b << 2))
+#define     HHI_HDCP22_CLK_CNTL                                (0xc883c000 + (0x7c << 2))
+#define SEC_HHI_HDCP22_CLK_CNTL                                (0xda83c000 + (0x7c << 2))
+#define   P_HHI_HDCP22_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x7c << 2))
+#define     HHI_VAPBCLK_CNTL                                   (0xc883c000 + (0x7d << 2))
+#define SEC_HHI_VAPBCLK_CNTL                                   (0xda83c000 + (0x7d << 2))
+#define   P_HHI_VAPBCLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x7d << 2))
+#define     HHI_VP9DEC_CLK_CNTL                                (0xc883c000 + (0x7e << 2))
+#define SEC_HHI_VP9DEC_CLK_CNTL                                (0xda83c000 + (0x7e << 2))
+#define   P_HHI_VP9DEC_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x7e << 2))
+// `define HHI_SYS_CPU_AUTO_CLK0        8'h78   never used
+// `define HHI_SYS_CPU_AUTO_CLK1        8'h79   never used
+// `define HHI_MEDIA_CPU_AUTO_CLK0    8'h7a     never used
+// `define HHI_MEDIA_CPU_AUTO_CLK1    8'h7b     never used
+#define     HHI_HDMI_AFC_CNTL                                  (0xc883c000 + (0x7f << 2))
+#define SEC_HHI_HDMI_AFC_CNTL                                  (0xda83c000 + (0x7f << 2))
+#define   P_HHI_HDMI_AFC_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x7f << 2))
+#define     HHI_HDMIRX_CLK_CNTL                                (0xc883c000 + (0x80 << 2))
+#define SEC_HHI_HDMIRX_CLK_CNTL                                (0xda83c000 + (0x80 << 2))
+#define   P_HHI_HDMIRX_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x80 << 2))
+#define     HHI_HDMIRX_AUD_CLK_CNTL                            (0xc883c000 + (0x81 << 2))
+#define SEC_HHI_HDMIRX_AUD_CLK_CNTL                            (0xda83c000 + (0x81 << 2))
+#define   P_HHI_HDMIRX_AUD_CLK_CNTL                            (volatile uint32_t *)(0xc883c000 + (0x81 << 2))
+#define     HHI_EDP_APB_CLK_CNTL                               (0xc883c000 + (0x82 << 2))
+#define SEC_HHI_EDP_APB_CLK_CNTL                               (0xda83c000 + (0x82 << 2))
+#define   P_HHI_EDP_APB_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x82 << 2))
+#define     HHI_VPU_CLKB_CNTL                                  (0xc883c000 + (0x83 << 2))
+#define SEC_HHI_VPU_CLKB_CNTL                                  (0xda83c000 + (0x83 << 2))
+#define   P_HHI_VPU_CLKB_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x83 << 2))
+#define     HHI_VID_PLL_MOD_CNTL0                              (0xc883c000 + (0x84 << 2))
+#define SEC_HHI_VID_PLL_MOD_CNTL0                              (0xda83c000 + (0x84 << 2))
+#define   P_HHI_VID_PLL_MOD_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0x84 << 2))
+#define     HHI_VID_PLL_MOD_LOW_TCNT                           (0xc883c000 + (0x85 << 2))
+#define SEC_HHI_VID_PLL_MOD_LOW_TCNT                           (0xda83c000 + (0x85 << 2))
+#define   P_HHI_VID_PLL_MOD_LOW_TCNT                           (volatile uint32_t *)(0xc883c000 + (0x85 << 2))
+#define     HHI_VID_PLL_MOD_HIGH_TCNT                          (0xc883c000 + (0x86 << 2))
+#define SEC_HHI_VID_PLL_MOD_HIGH_TCNT                          (0xda83c000 + (0x86 << 2))
+#define   P_HHI_VID_PLL_MOD_HIGH_TCNT                          (volatile uint32_t *)(0xc883c000 + (0x86 << 2))
+#define     HHI_VID_PLL_MOD_NOM_TCNT                           (0xc883c000 + (0x87 << 2))
+#define SEC_HHI_VID_PLL_MOD_NOM_TCNT                           (0xda83c000 + (0x87 << 2))
+#define   P_HHI_VID_PLL_MOD_NOM_TCNT                           (volatile uint32_t *)(0xc883c000 + (0x87 << 2))
+#define     HHI_USB_CLK_CNTL                                   (0xc883c000 + (0x88 << 2))
+#define SEC_HHI_USB_CLK_CNTL                                   (0xda83c000 + (0x88 << 2))
+#define   P_HHI_USB_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x88 << 2))
+// Removed `define HHI_DDR_CLK_CNTL            8'h88
+#define     HHI_32K_CLK_CNTL                                   (0xc883c000 + (0x89 << 2))
+#define SEC_HHI_32K_CLK_CNTL                                   (0xda83c000 + (0x89 << 2))
+#define   P_HHI_32K_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x89 << 2))
+#define     HHI_GEN_CLK_CNTL                                   (0xc883c000 + (0x8a << 2))
+#define SEC_HHI_GEN_CLK_CNTL                                   (0xda83c000 + (0x8a << 2))
+#define   P_HHI_GEN_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x8a << 2))
+#define     HHI_GEN_CLK_CNTL2                                  (0xc883c000 + (0x8b << 2))
+#define SEC_HHI_GEN_CLK_CNTL2                                  (0xda83c000 + (0x8b << 2))
+#define   P_HHI_GEN_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x8b << 2))
+#define     HHI_JTAG_CONFIG                                    (0xc883c000 + (0x8e << 2))
+#define SEC_HHI_JTAG_CONFIG                                    (0xda83c000 + (0x8e << 2))
+#define   P_HHI_JTAG_CONFIG                                    (volatile uint32_t *)(0xc883c000 + (0x8e << 2))
+#define     HHI_VAFE_CLKXTALIN_CNTL                            (0xc883c000 + (0x8f << 2))
+#define SEC_HHI_VAFE_CLKXTALIN_CNTL                            (0xda83c000 + (0x8f << 2))
+#define   P_HHI_VAFE_CLKXTALIN_CNTL                            (volatile uint32_t *)(0xc883c000 + (0x8f << 2))
+#define     HHI_VAFE_CLKOSCIN_CNTL                             (0xc883c000 + (0x90 << 2))
+#define SEC_HHI_VAFE_CLKOSCIN_CNTL                             (0xda83c000 + (0x90 << 2))
+#define   P_HHI_VAFE_CLKOSCIN_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x90 << 2))
+#define     HHI_VAFE_CLKIN_CNTL                                (0xc883c000 + (0x91 << 2))
+#define SEC_HHI_VAFE_CLKIN_CNTL                                (0xda83c000 + (0x91 << 2))
+#define   P_HHI_VAFE_CLKIN_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x91 << 2))
+#define     HHI_TVFE_AUTOMODE_CLK_CNTL                         (0xc883c000 + (0x92 << 2))
+#define SEC_HHI_TVFE_AUTOMODE_CLK_CNTL                         (0xda83c000 + (0x92 << 2))
+#define   P_HHI_TVFE_AUTOMODE_CLK_CNTL                         (volatile uint32_t *)(0xc883c000 + (0x92 << 2))
+#define     HHI_VAFE_CLKPI_CNTL                                (0xc883c000 + (0x93 << 2))
+#define SEC_HHI_VAFE_CLKPI_CNTL                                (0xda83c000 + (0x93 << 2))
+#define   P_HHI_VAFE_CLKPI_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x93 << 2))
+#define     HHI_VDIN_MEAS_CLK_CNTL                             (0xc883c000 + (0x94 << 2))
+#define SEC_HHI_VDIN_MEAS_CLK_CNTL                             (0xda83c000 + (0x94 << 2))
+#define   P_HHI_VDIN_MEAS_CLK_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x94 << 2))
+// `define HHI_PCM2_CLK_CNTL           8'h95
+#define     HHI_PCM_CLK_CNTL                                   (0xc883c000 + (0x96 << 2))
+#define SEC_HHI_PCM_CLK_CNTL                                   (0xda83c000 + (0x96 << 2))
+#define   P_HHI_PCM_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x96 << 2))
+#define     HHI_NAND_CLK_CNTL                                  (0xc883c000 + (0x97 << 2))
+#define SEC_HHI_NAND_CLK_CNTL                                  (0xda83c000 + (0x97 << 2))
+#define   P_HHI_NAND_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x97 << 2))
+#define     HHI_ISP_LED_CLK_CNTL                               (0xc883c000 + (0x98 << 2))
+#define SEC_HHI_ISP_LED_CLK_CNTL                               (0xda83c000 + (0x98 << 2))
+#define   P_HHI_ISP_LED_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x98 << 2))
+#define     HHI_SD_EMMC_CLK_CNTL                               (0xc883c000 + (0x99 << 2))
+#define SEC_HHI_SD_EMMC_CLK_CNTL                               (0xda83c000 + (0x99 << 2))
+#define   P_HHI_SD_EMMC_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x99 << 2))
+#define     HHI_EDP_TX_PHY_CNTL0                               (0xc883c000 + (0x9c << 2))
+#define SEC_HHI_EDP_TX_PHY_CNTL0                               (0xda83c000 + (0x9c << 2))
+#define   P_HHI_EDP_TX_PHY_CNTL0                               (volatile uint32_t *)(0xc883c000 + (0x9c << 2))
+#define     HHI_EDP_TX_PHY_CNTL1                               (0xc883c000 + (0x9d << 2))
+#define SEC_HHI_EDP_TX_PHY_CNTL1                               (0xda83c000 + (0x9d << 2))
+#define   P_HHI_EDP_TX_PHY_CNTL1                               (volatile uint32_t *)(0xc883c000 + (0x9d << 2))
+#define     HHI_ADC_PLL_CNTL5                                  (0xc883c000 + (0x9e << 2))
+#define SEC_HHI_ADC_PLL_CNTL5                                  (0xda83c000 + (0x9e << 2))
+#define   P_HHI_ADC_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x9e << 2))
+#define     HHI_ADC_PLL_CNTL6                                  (0xc883c000 + (0x9f << 2))
+#define SEC_HHI_ADC_PLL_CNTL6                                  (0xda83c000 + (0x9f << 2))
+#define   P_HHI_ADC_PLL_CNTL6                                  (volatile uint32_t *)(0xc883c000 + (0x9f << 2))
+#define     HHI_MPLL_CNTL                                      (0xc883c000 + (0xa0 << 2))
+#define SEC_HHI_MPLL_CNTL                                      (0xda83c000 + (0xa0 << 2))
+#define   P_HHI_MPLL_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0xa0 << 2))
+#define     HHI_MPLL_CNTL2                                     (0xc883c000 + (0xa1 << 2))
+#define SEC_HHI_MPLL_CNTL2                                     (0xda83c000 + (0xa1 << 2))
+#define   P_HHI_MPLL_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0xa1 << 2))
+#define     HHI_MPLL_CNTL3                                     (0xc883c000 + (0xa2 << 2))
+#define SEC_HHI_MPLL_CNTL3                                     (0xda83c000 + (0xa2 << 2))
+#define   P_HHI_MPLL_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0xa2 << 2))
+#define     HHI_MPLL_CNTL4                                     (0xc883c000 + (0xa3 << 2))
+#define SEC_HHI_MPLL_CNTL4                                     (0xda83c000 + (0xa3 << 2))
+#define   P_HHI_MPLL_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0xa3 << 2))
+#define     HHI_MPLL_CNTL5                                     (0xc883c000 + (0xa4 << 2))
+#define SEC_HHI_MPLL_CNTL5                                     (0xda83c000 + (0xa4 << 2))
+#define   P_HHI_MPLL_CNTL5                                     (volatile uint32_t *)(0xc883c000 + (0xa4 << 2))
+#define     HHI_MPLL_CNTL6                                     (0xc883c000 + (0xa5 << 2))
+#define SEC_HHI_MPLL_CNTL6                                     (0xda83c000 + (0xa5 << 2))
+#define   P_HHI_MPLL_CNTL6                                     (volatile uint32_t *)(0xc883c000 + (0xa5 << 2))
+#define     HHI_MPLL_CNTL7                                     (0xc883c000 + (0xa6 << 2))
+#define SEC_HHI_MPLL_CNTL7                                     (0xda83c000 + (0xa6 << 2))
+#define   P_HHI_MPLL_CNTL7                                     (volatile uint32_t *)(0xc883c000 + (0xa6 << 2))
+#define     HHI_MPLL_CNTL8                                     (0xc883c000 + (0xa7 << 2))
+#define SEC_HHI_MPLL_CNTL8                                     (0xda83c000 + (0xa7 << 2))
+#define   P_HHI_MPLL_CNTL8                                     (volatile uint32_t *)(0xc883c000 + (0xa7 << 2))
+#define     HHI_MPLL_CNTL9                                     (0xc883c000 + (0xa8 << 2))
+#define SEC_HHI_MPLL_CNTL9                                     (0xda83c000 + (0xa8 << 2))
+#define   P_HHI_MPLL_CNTL9                                     (volatile uint32_t *)(0xc883c000 + (0xa8 << 2))
+#define     HHI_MPLL_CNTL10                                    (0xc883c000 + (0xa9 << 2))
+#define SEC_HHI_MPLL_CNTL10                                    (0xda83c000 + (0xa9 << 2))
+#define   P_HHI_MPLL_CNTL10                                    (volatile uint32_t *)(0xc883c000 + (0xa9 << 2))
+#define     HHI_ADC_PLL_CNTL                                   (0xc883c000 + (0xaa << 2))
+#define SEC_HHI_ADC_PLL_CNTL                                   (0xda83c000 + (0xaa << 2))
+#define   P_HHI_ADC_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xaa << 2))
+#define     HHI_ADC_PLL_CNTL2                                  (0xc883c000 + (0xab << 2))
+#define SEC_HHI_ADC_PLL_CNTL2                                  (0xda83c000 + (0xab << 2))
+#define   P_HHI_ADC_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xab << 2))
+#define     HHI_ADC_PLL_CNTL3                                  (0xc883c000 + (0xac << 2))
+#define SEC_HHI_ADC_PLL_CNTL3                                  (0xda83c000 + (0xac << 2))
+#define   P_HHI_ADC_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xac << 2))
+#define     HHI_ADC_PLL_CNTL4                                  (0xc883c000 + (0xad << 2))
+#define SEC_HHI_ADC_PLL_CNTL4                                  (0xda83c000 + (0xad << 2))
+#define   P_HHI_ADC_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xad << 2))
+#define     HHI_ADC_PLL_STS                                    (0xc883c000 + (0xae << 2))
+#define SEC_HHI_ADC_PLL_STS                                    (0xda83c000 + (0xae << 2))
+#define   P_HHI_ADC_PLL_STS                                    (volatile uint32_t *)(0xc883c000 + (0xae << 2))
+#define     HHI_ADC_PLL_CNTL1                                  (0xc883c000 + (0xaf << 2))
+#define SEC_HHI_ADC_PLL_CNTL1                                  (0xda83c000 + (0xaf << 2))
+#define   P_HHI_ADC_PLL_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0xaf << 2))
+#define     HHI_AUDCLK_PLL_CNTL                                (0xc883c000 + (0xb0 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL                                (0xda83c000 + (0xb0 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL                                (volatile uint32_t *)(0xc883c000 + (0xb0 << 2))
+#define     HHI_AUDCLK_PLL_CNTL2                               (0xc883c000 + (0xb1 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL2                               (0xda83c000 + (0xb1 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL2                               (volatile uint32_t *)(0xc883c000 + (0xb1 << 2))
+#define     HHI_AUDCLK_PLL_CNTL3                               (0xc883c000 + (0xb2 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL3                               (0xda83c000 + (0xb2 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL3                               (volatile uint32_t *)(0xc883c000 + (0xb2 << 2))
+#define     HHI_AUDCLK_PLL_CNTL4                               (0xc883c000 + (0xb3 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL4                               (0xda83c000 + (0xb3 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL4                               (volatile uint32_t *)(0xc883c000 + (0xb3 << 2))
+#define     HHI_AUDCLK_PLL_CNTL5                               (0xc883c000 + (0xb4 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL5                               (0xda83c000 + (0xb4 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL5                               (volatile uint32_t *)(0xc883c000 + (0xb4 << 2))
+#define     HHI_AUDCLK_PLL_CNTL6                               (0xc883c000 + (0xb5 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL6                               (0xda83c000 + (0xb5 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL6                               (volatile uint32_t *)(0xc883c000 + (0xb5 << 2))
+#define     HHI_L2_DDR_CLK_CNTL                                (0xc883c000 + (0xb6 << 2))
+#define SEC_HHI_L2_DDR_CLK_CNTL                                (0xda83c000 + (0xb6 << 2))
+#define   P_HHI_L2_DDR_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0xb6 << 2))
+#define     HHI_MPLL3_CNTL0                                    (0xc883c000 + (0xb8 << 2))
+#define SEC_HHI_MPLL3_CNTL0                                    (0xda83c000 + (0xb8 << 2))
+#define   P_HHI_MPLL3_CNTL0                                    (volatile uint32_t *)(0xc883c000 + (0xb8 << 2))
+#define     HHI_MPLL3_CNTL1                                    (0xc883c000 + (0xb9 << 2))
+#define SEC_HHI_MPLL3_CNTL1                                    (0xda83c000 + (0xb9 << 2))
+#define   P_HHI_MPLL3_CNTL1                                    (volatile uint32_t *)(0xc883c000 + (0xb9 << 2))
+#define     HHI_PLL_TOP_MISC                                   (0xc883c000 + (0xba << 2))
+#define SEC_HHI_PLL_TOP_MISC                                   (0xda83c000 + (0xba << 2))
+#define   P_HHI_PLL_TOP_MISC                                   (volatile uint32_t *)(0xc883c000 + (0xba << 2))
+#define     HHI_VDAC_CNTL0                                     (0xc883c000 + (0xbd << 2))
+#define SEC_HHI_VDAC_CNTL0                                     (0xda83c000 + (0xbd << 2))
+#define   P_HHI_VDAC_CNTL0                                     (volatile uint32_t *)(0xc883c000 + (0xbd << 2))
+#define     HHI_VDAC_CNTL1                                     (0xc883c000 + (0xbe << 2))
+#define SEC_HHI_VDAC_CNTL1                                     (0xda83c000 + (0xbe << 2))
+#define   P_HHI_VDAC_CNTL1                                     (volatile uint32_t *)(0xc883c000 + (0xbe << 2))
+#define     HHI_SYS_PLL_CNTL1                                  (0xc883c000 + (0xbf << 2))
+#define SEC_HHI_SYS_PLL_CNTL1                                  (0xda83c000 + (0xbf << 2))
+#define   P_HHI_SYS_PLL_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0xbf << 2))
+#define     HHI_SYS_PLL_CNTL                                   (0xc883c000 + (0xc0 << 2))
+#define SEC_HHI_SYS_PLL_CNTL                                   (0xda83c000 + (0xc0 << 2))
+#define   P_HHI_SYS_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xc0 << 2))
+#define     HHI_SYS_PLL_CNTL2                                  (0xc883c000 + (0xc1 << 2))
+#define SEC_HHI_SYS_PLL_CNTL2                                  (0xda83c000 + (0xc1 << 2))
+#define   P_HHI_SYS_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xc1 << 2))
+#define     HHI_SYS_PLL_CNTL3                                  (0xc883c000 + (0xc2 << 2))
+#define SEC_HHI_SYS_PLL_CNTL3                                  (0xda83c000 + (0xc2 << 2))
+#define   P_HHI_SYS_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xc2 << 2))
+#define     HHI_SYS_PLL_CNTL4                                  (0xc883c000 + (0xc3 << 2))
+#define SEC_HHI_SYS_PLL_CNTL4                                  (0xda83c000 + (0xc3 << 2))
+#define   P_HHI_SYS_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xc3 << 2))
+#define     HHI_SYS_PLL_CNTL5                                  (0xc883c000 + (0xc4 << 2))
+#define SEC_HHI_SYS_PLL_CNTL5                                  (0xda83c000 + (0xc4 << 2))
+#define   P_HHI_SYS_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0xc4 << 2))
+#define     HHI_SYS_PLL_STS                                    (0xc883c000 + (0xc5 << 2))
+#define SEC_HHI_SYS_PLL_STS                                    (0xda83c000 + (0xc5 << 2))
+#define   P_HHI_SYS_PLL_STS                                    (volatile uint32_t *)(0xc883c000 + (0xc5 << 2))
+#define     HHI_DPLL_TOP_I                                     (0xc883c000 + (0xc6 << 2))
+#define SEC_HHI_DPLL_TOP_I                                     (0xda83c000 + (0xc6 << 2))
+#define   P_HHI_DPLL_TOP_I                                     (volatile uint32_t *)(0xc883c000 + (0xc6 << 2))
+#define     HHI_DPLL_TOP2_I                                    (0xc883c000 + (0xc7 << 2))
+#define SEC_HHI_DPLL_TOP2_I                                    (0xda83c000 + (0xc7 << 2))
+#define   P_HHI_DPLL_TOP2_I                                    (volatile uint32_t *)(0xc883c000 + (0xc7 << 2))
+#define     HHI_HDMI_PLL_CNTL                                  (0xc883c000 + (0xc8 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL                                  (0xda83c000 + (0xc8 << 2))
+#define   P_HHI_HDMI_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0xc8 << 2))
+#define     HHI_HDMI_PLL_CNTL1                                 (0xc883c000 + (0xc9 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL1                                 (0xda83c000 + (0xc9 << 2))
+#define   P_HHI_HDMI_PLL_CNTL1                                 (volatile uint32_t *)(0xc883c000 + (0xc9 << 2))
+#define     HHI_HDMI_PLL_CNTL2                                 (0xc883c000 + (0xca << 2))
+#define SEC_HHI_HDMI_PLL_CNTL2                                 (0xda83c000 + (0xca << 2))
+#define   P_HHI_HDMI_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xca << 2))
+#define     HHI_HDMI_PLL_CNTL3                                 (0xc883c000 + (0xcb << 2))
+#define SEC_HHI_HDMI_PLL_CNTL3                                 (0xda83c000 + (0xcb << 2))
+#define   P_HHI_HDMI_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xcb << 2))
+#define     HHI_HDMI_PLL_CNTL4                                 (0xc883c000 + (0xcc << 2))
+#define SEC_HHI_HDMI_PLL_CNTL4                                 (0xda83c000 + (0xcc << 2))
+#define   P_HHI_HDMI_PLL_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xcc << 2))
+#define     HHI_HDMI_PLL_CNTL5                                 (0xc883c000 + (0xcd << 2))
+#define SEC_HHI_HDMI_PLL_CNTL5                                 (0xda83c000 + (0xcd << 2))
+#define   P_HHI_HDMI_PLL_CNTL5                                 (volatile uint32_t *)(0xc883c000 + (0xcd << 2))
+#define     HHI_HDMI_PLL_STS                                   (0xc883c000 + (0xce << 2))
+#define SEC_HHI_HDMI_PLL_STS                                   (0xda83c000 + (0xce << 2))
+#define   P_HHI_HDMI_PLL_STS                                   (volatile uint32_t *)(0xc883c000 + (0xce << 2))
+#define     HHI_DSI_LVDS_EDP_CNTL0                             (0xc883c000 + (0xd1 << 2))
+#define SEC_HHI_DSI_LVDS_EDP_CNTL0                             (0xda83c000 + (0xd1 << 2))
+#define   P_HHI_DSI_LVDS_EDP_CNTL0                             (volatile uint32_t *)(0xc883c000 + (0xd1 << 2))
+#define     HHI_DSI_LVDS_EDP_CNTL1                             (0xc883c000 + (0xd2 << 2))
+#define SEC_HHI_DSI_LVDS_EDP_CNTL1                             (0xda83c000 + (0xd2 << 2))
+#define   P_HHI_DSI_LVDS_EDP_CNTL1                             (volatile uint32_t *)(0xc883c000 + (0xd2 << 2))
+#define     HHI_CSI_PHY_CNTL0                                  (0xc883c000 + (0xd3 << 2))
+#define SEC_HHI_CSI_PHY_CNTL0                                  (0xda83c000 + (0xd3 << 2))
+#define   P_HHI_CSI_PHY_CNTL0                                  (volatile uint32_t *)(0xc883c000 + (0xd3 << 2))
+#define     HHI_CSI_PHY_CNTL1                                  (0xc883c000 + (0xd4 << 2))
+#define SEC_HHI_CSI_PHY_CNTL1                                  (0xda83c000 + (0xd4 << 2))
+#define   P_HHI_CSI_PHY_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0xd4 << 2))
+#define     HHI_CSI_PHY_CNTL2                                  (0xc883c000 + (0xd5 << 2))
+#define SEC_HHI_CSI_PHY_CNTL2                                  (0xda83c000 + (0xd5 << 2))
+#define   P_HHI_CSI_PHY_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xd5 << 2))
+#define     HHI_CSI_PHY_CNTL3                                  (0xc883c000 + (0xd6 << 2))
+#define SEC_HHI_CSI_PHY_CNTL3                                  (0xda83c000 + (0xd6 << 2))
+#define   P_HHI_CSI_PHY_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xd6 << 2))
+#define     HHI_CSI_PHY_CNTL4                                  (0xc883c000 + (0xd7 << 2))
+#define SEC_HHI_CSI_PHY_CNTL4                                  (0xda83c000 + (0xd7 << 2))
+#define   P_HHI_CSI_PHY_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xd7 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL0                              (0xc883c000 + (0xd8 << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL0                              (0xda83c000 + (0xd8 << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0xd8 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL1                              (0xc883c000 + (0xd9 << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL1                              (0xda83c000 + (0xd9 << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0xd9 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL2                              (0xc883c000 + (0xda << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL2                              (0xda83c000 + (0xda << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL2                              (volatile uint32_t *)(0xc883c000 + (0xda << 2))
+#define     HHI_DIF_CSI_PHY_CNTL3                              (0xc883c000 + (0xdb << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL3                              (0xda83c000 + (0xdb << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL3                              (volatile uint32_t *)(0xc883c000 + (0xdb << 2))
+#define     HHI_DIF_CSI_PHY_CNTL4                              (0xc883c000 + (0xdc << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL4                              (0xda83c000 + (0xdc << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL4                              (volatile uint32_t *)(0xc883c000 + (0xdc << 2))
+#define     HHI_DIF_CSI_PHY_CNTL5                              (0xc883c000 + (0xdd << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL5                              (0xda83c000 + (0xdd << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL5                              (volatile uint32_t *)(0xc883c000 + (0xdd << 2))
+#define     HHI_LVDS_TX_PHY_CNTL0                              (0xc883c000 + (0xde << 2))
+#define SEC_HHI_LVDS_TX_PHY_CNTL0                              (0xda83c000 + (0xde << 2))
+#define   P_HHI_LVDS_TX_PHY_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0xde << 2))
+#define     HHI_LVDS_TX_PHY_CNTL1                              (0xc883c000 + (0xdf << 2))
+#define SEC_HHI_LVDS_TX_PHY_CNTL1                              (0xda83c000 + (0xdf << 2))
+#define   P_HHI_LVDS_TX_PHY_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0xdf << 2))
+#define     HHI_VID2_PLL_CNTL                                  (0xc883c000 + (0xe0 << 2))
+#define SEC_HHI_VID2_PLL_CNTL                                  (0xda83c000 + (0xe0 << 2))
+#define   P_HHI_VID2_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0xe0 << 2))
+#define     HHI_VID2_PLL_CNTL2                                 (0xc883c000 + (0xe1 << 2))
+#define SEC_HHI_VID2_PLL_CNTL2                                 (0xda83c000 + (0xe1 << 2))
+#define   P_HHI_VID2_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xe1 << 2))
+#define     HHI_VID2_PLL_CNTL3                                 (0xc883c000 + (0xe2 << 2))
+#define SEC_HHI_VID2_PLL_CNTL3                                 (0xda83c000 + (0xe2 << 2))
+#define   P_HHI_VID2_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xe2 << 2))
+#define     HHI_VID2_PLL_CNTL4                                 (0xc883c000 + (0xe3 << 2))
+#define SEC_HHI_VID2_PLL_CNTL4                                 (0xda83c000 + (0xe3 << 2))
+#define   P_HHI_VID2_PLL_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xe3 << 2))
+#define     HHI_VID2_PLL_CNTL5                                 (0xc883c000 + (0xe4 << 2))
+#define SEC_HHI_VID2_PLL_CNTL5                                 (0xda83c000 + (0xe4 << 2))
+#define   P_HHI_VID2_PLL_CNTL5                                 (volatile uint32_t *)(0xc883c000 + (0xe4 << 2))
+#define     HHI_VID2_PLL_CNTL_I                                (0xc883c000 + (0xe5 << 2))
+#define SEC_HHI_VID2_PLL_CNTL_I                                (0xda83c000 + (0xe5 << 2))
+#define   P_HHI_VID2_PLL_CNTL_I                                (volatile uint32_t *)(0xc883c000 + (0xe5 << 2))
+#define     HHI_HDMI_PHY_CNTL0                                 (0xc883c000 + (0xe8 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL0                                 (0xda83c000 + (0xe8 << 2))
+#define   P_HHI_HDMI_PHY_CNTL0                                 (volatile uint32_t *)(0xc883c000 + (0xe8 << 2))
+#define     HHI_HDMI_PHY_CNTL1                                 (0xc883c000 + (0xe9 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL1                                 (0xda83c000 + (0xe9 << 2))
+#define   P_HHI_HDMI_PHY_CNTL1                                 (volatile uint32_t *)(0xc883c000 + (0xe9 << 2))
+#define     HHI_HDMI_PHY_CNTL2                                 (0xc883c000 + (0xea << 2))
+#define SEC_HHI_HDMI_PHY_CNTL2                                 (0xda83c000 + (0xea << 2))
+#define   P_HHI_HDMI_PHY_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xea << 2))
+#define     HHI_HDMI_PHY_CNTL3                                 (0xc883c000 + (0xeb << 2))
+#define SEC_HHI_HDMI_PHY_CNTL3                                 (0xda83c000 + (0xeb << 2))
+#define   P_HHI_HDMI_PHY_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xeb << 2))
+#define     HHI_HDMI_PHY_CNTL4                                 (0xc883c000 + (0xec << 2))
+#define SEC_HHI_HDMI_PHY_CNTL4                                 (0xda83c000 + (0xec << 2))
+#define   P_HHI_HDMI_PHY_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xec << 2))
+#define     HHI_HDMI_PHY_STATUS                                (0xc883c000 + (0xed << 2))
+#define SEC_HHI_HDMI_PHY_STATUS                                (0xda83c000 + (0xed << 2))
+#define   P_HHI_HDMI_PHY_STATUS                                (volatile uint32_t *)(0xc883c000 + (0xed << 2))
+#define     HHI_VID_LOCK_CLK_CNTL                              (0xc883c000 + (0xf2 << 2))
+#define SEC_HHI_VID_LOCK_CLK_CNTL                              (0xda83c000 + (0xf2 << 2))
+#define   P_HHI_VID_LOCK_CLK_CNTL                              (volatile uint32_t *)(0xc883c000 + (0xf2 << 2))
+#define     HHI_ATV_DMD_SYS_CLK_CNTL                           (0xc883c000 + (0xf3 << 2))
+#define SEC_HHI_ATV_DMD_SYS_CLK_CNTL                           (0xda83c000 + (0xf3 << 2))
+#define   P_HHI_ATV_DMD_SYS_CLK_CNTL                           (volatile uint32_t *)(0xc883c000 + (0xf3 << 2))
+#define     HHI_EE_MISC_CNTL                                   (0xc883c000 + (0xf4 << 2))
+#define SEC_HHI_EE_MISC_CNTL                                   (0xda83c000 + (0xf4 << 2))
+#define   P_HHI_EE_MISC_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xf4 << 2))
+#define     HHI_BT656_CLK_CNTL                                 (0xc883c000 + (0xf5 << 2))
+#define SEC_HHI_BT656_CLK_CNTL                                 (0xda83c000 + (0xf5 << 2))
+#define   P_HHI_BT656_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0xf5 << 2))
+//`define HHI_SAR_CLK_CNTL            8'hf6
+#define     HHI_HDMIRX_AUD_PLL_CNTL                            (0xc883c000 + (0xf8 << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL                            (0xda83c000 + (0xf8 << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL                            (volatile uint32_t *)(0xc883c000 + (0xf8 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL2                           (0xc883c000 + (0xf9 << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL2                           (0xda83c000 + (0xf9 << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL2                           (volatile uint32_t *)(0xc883c000 + (0xf9 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL3                           (0xc883c000 + (0xfa << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL3                           (0xda83c000 + (0xfa << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL3                           (volatile uint32_t *)(0xc883c000 + (0xfa << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL4                           (0xc883c000 + (0xfb << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL4                           (0xda83c000 + (0xfb << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL4                           (volatile uint32_t *)(0xc883c000 + (0xfb << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL5                           (0xc883c000 + (0xfc << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL5                           (0xda83c000 + (0xfc << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL5                           (volatile uint32_t *)(0xc883c000 + (0xfc << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL6                           (0xc883c000 + (0xfd << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL6                           (0xda83c000 + (0xfd << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL6                           (volatile uint32_t *)(0xc883c000 + (0xfd << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL_I                          (0xc883c000 + (0xfe << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL_I                          (0xda83c000 + (0xfe << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL_I                          (volatile uint32_t *)(0xc883c000 + (0xfe << 2))
+//========================================================================
+//  HIU - Mailbox
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hC883C400
+// APB4_DECODER_SECURE_BASE         32'hDA83C400
+#define     HIU_MAILBOX_SET_0                                  (0xc883c400 + (0x01 << 2))
+#define SEC_HIU_MAILBOX_SET_0                                  (0xda83c400 + (0x01 << 2))
+#define   P_HIU_MAILBOX_SET_0                                  (volatile uint32_t *)(0xc883c400 + (0x01 << 2))
+#define     HIU_MAILBOX_STAT_0                                 (0xc883c400 + (0x02 << 2))
+#define SEC_HIU_MAILBOX_STAT_0                                 (0xda83c400 + (0x02 << 2))
+#define   P_HIU_MAILBOX_STAT_0                                 (volatile uint32_t *)(0xc883c400 + (0x02 << 2))
+#define     HIU_MAILBOX_CLR_0                                  (0xc883c400 + (0x03 << 2))
+#define SEC_HIU_MAILBOX_CLR_0                                  (0xda83c400 + (0x03 << 2))
+#define   P_HIU_MAILBOX_CLR_0                                  (volatile uint32_t *)(0xc883c400 + (0x03 << 2))
+#define     HIU_MAILBOX_SET_1                                  (0xc883c400 + (0x04 << 2))
+#define SEC_HIU_MAILBOX_SET_1                                  (0xda83c400 + (0x04 << 2))
+#define   P_HIU_MAILBOX_SET_1                                  (volatile uint32_t *)(0xc883c400 + (0x04 << 2))
+#define     HIU_MAILBOX_STAT_1                                 (0xc883c400 + (0x05 << 2))
+#define SEC_HIU_MAILBOX_STAT_1                                 (0xda83c400 + (0x05 << 2))
+#define   P_HIU_MAILBOX_STAT_1                                 (volatile uint32_t *)(0xc883c400 + (0x05 << 2))
+#define     HIU_MAILBOX_CLR_1                                  (0xc883c400 + (0x06 << 2))
+#define SEC_HIU_MAILBOX_CLR_1                                  (0xda83c400 + (0x06 << 2))
+#define   P_HIU_MAILBOX_CLR_1                                  (volatile uint32_t *)(0xc883c400 + (0x06 << 2))
+#define     HIU_MAILBOX_SET_2                                  (0xc883c400 + (0x07 << 2))
+#define SEC_HIU_MAILBOX_SET_2                                  (0xda83c400 + (0x07 << 2))
+#define   P_HIU_MAILBOX_SET_2                                  (volatile uint32_t *)(0xc883c400 + (0x07 << 2))
+#define     HIU_MAILBOX_STAT_2                                 (0xc883c400 + (0x08 << 2))
+#define SEC_HIU_MAILBOX_STAT_2                                 (0xda83c400 + (0x08 << 2))
+#define   P_HIU_MAILBOX_STAT_2                                 (volatile uint32_t *)(0xc883c400 + (0x08 << 2))
+#define     HIU_MAILBOX_CLR_2                                  (0xc883c400 + (0x09 << 2))
+#define SEC_HIU_MAILBOX_CLR_2                                  (0xda83c400 + (0x09 << 2))
+#define   P_HIU_MAILBOX_CLR_2                                  (volatile uint32_t *)(0xc883c400 + (0x09 << 2))
+#define     HIU_MAILBOX_SET_3                                  (0xc883c400 + (0x0a << 2))
+#define SEC_HIU_MAILBOX_SET_3                                  (0xda83c400 + (0x0a << 2))
+#define   P_HIU_MAILBOX_SET_3                                  (volatile uint32_t *)(0xc883c400 + (0x0a << 2))
+#define     HIU_MAILBOX_STAT_3                                 (0xc883c400 + (0x0b << 2))
+#define SEC_HIU_MAILBOX_STAT_3                                 (0xda83c400 + (0x0b << 2))
+#define   P_HIU_MAILBOX_STAT_3                                 (volatile uint32_t *)(0xc883c400 + (0x0b << 2))
+#define     HIU_MAILBOX_CLR_3                                  (0xc883c400 + (0x0c << 2))
+#define SEC_HIU_MAILBOX_CLR_3                                  (0xda83c400 + (0x0c << 2))
+#define   P_HIU_MAILBOX_CLR_3                                  (volatile uint32_t *)(0xc883c400 + (0x0c << 2))
+#define     HIU_MAILBOX_SET_4                                  (0xc883c400 + (0x0d << 2))
+#define SEC_HIU_MAILBOX_SET_4                                  (0xda83c400 + (0x0d << 2))
+#define   P_HIU_MAILBOX_SET_4                                  (volatile uint32_t *)(0xc883c400 + (0x0d << 2))
+#define     HIU_MAILBOX_STAT_4                                 (0xc883c400 + (0x0e << 2))
+#define SEC_HIU_MAILBOX_STAT_4                                 (0xda83c400 + (0x0e << 2))
+#define   P_HIU_MAILBOX_STAT_4                                 (volatile uint32_t *)(0xc883c400 + (0x0e << 2))
+#define     HIU_MAILBOX_CLR_4                                  (0xc883c400 + (0x0f << 2))
+#define SEC_HIU_MAILBOX_CLR_4                                  (0xda83c400 + (0x0f << 2))
+#define   P_HIU_MAILBOX_CLR_4                                  (volatile uint32_t *)(0xc883c400 + (0x0f << 2))
+#define     HIU_MAILBOX_SET_5                                  (0xc883c400 + (0x10 << 2))
+#define SEC_HIU_MAILBOX_SET_5                                  (0xda83c400 + (0x10 << 2))
+#define   P_HIU_MAILBOX_SET_5                                  (volatile uint32_t *)(0xc883c400 + (0x10 << 2))
+#define     HIU_MAILBOX_STAT_5                                 (0xc883c400 + (0x11 << 2))
+#define SEC_HIU_MAILBOX_STAT_5                                 (0xda83c400 + (0x11 << 2))
+#define   P_HIU_MAILBOX_STAT_5                                 (volatile uint32_t *)(0xc883c400 + (0x11 << 2))
+#define     HIU_MAILBOX_CLR_5                                  (0xc883c400 + (0x12 << 2))
+#define SEC_HIU_MAILBOX_CLR_5                                  (0xda83c400 + (0x12 << 2))
+#define   P_HIU_MAILBOX_CLR_5                                  (volatile uint32_t *)(0xc883c400 + (0x12 << 2))
+//========================================================================
+//  EFUSE
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8830000
+//  APB4_DECODER_SECURE_BASE         32'hDA830000
+#define     EFUSE_CNTL0                                        (0xc8830000 + (0x00 << 2))
+#define SEC_EFUSE_CNTL0                                        (0xda830000 + (0x00 << 2))
+#define   P_EFUSE_CNTL0                                        (volatile uint32_t *)(0xc8830000 + (0x00 << 2))
+#define     EFUSE_CNTL1                                        (0xc8830000 + (0x01 << 2))
+#define SEC_EFUSE_CNTL1                                        (0xda830000 + (0x01 << 2))
+#define   P_EFUSE_CNTL1                                        (volatile uint32_t *)(0xc8830000 + (0x01 << 2))
+#define     EFUSE_CNTL2                                        (0xc8830000 + (0x02 << 2))
+#define SEC_EFUSE_CNTL2                                        (0xda830000 + (0x02 << 2))
+#define   P_EFUSE_CNTL2                                        (volatile uint32_t *)(0xc8830000 + (0x02 << 2))
+#define     EFUSE_CNTL3                                        (0xc8830000 + (0x03 << 2))
+#define SEC_EFUSE_CNTL3                                        (0xda830000 + (0x03 << 2))
+#define   P_EFUSE_CNTL3                                        (volatile uint32_t *)(0xc8830000 + (0x03 << 2))
+#define     EFUSE_CNTL4                                        (0xc8830000 + (0x04 << 2))
+#define SEC_EFUSE_CNTL4                                        (0xda830000 + (0x04 << 2))
+#define   P_EFUSE_CNTL4                                        (volatile uint32_t *)(0xc8830000 + (0x04 << 2))
+#define     EFUSE_WDATA0                                       (0xc8830000 + (0x05 << 2))
+#define SEC_EFUSE_WDATA0                                       (0xda830000 + (0x05 << 2))
+#define   P_EFUSE_WDATA0                                       (volatile uint32_t *)(0xc8830000 + (0x05 << 2))
+#define     EFUSE_WDATA1                                       (0xc8830000 + (0x06 << 2))
+#define SEC_EFUSE_WDATA1                                       (0xda830000 + (0x06 << 2))
+#define   P_EFUSE_WDATA1                                       (volatile uint32_t *)(0xc8830000 + (0x06 << 2))
+#define     EFUSE_WDATA2                                       (0xc8830000 + (0x07 << 2))
+#define SEC_EFUSE_WDATA2                                       (0xda830000 + (0x07 << 2))
+#define   P_EFUSE_WDATA2                                       (volatile uint32_t *)(0xc8830000 + (0x07 << 2))
+#define     EFUSE_WDATA3                                       (0xc8830000 + (0x08 << 2))
+#define SEC_EFUSE_WDATA3                                       (0xda830000 + (0x08 << 2))
+#define   P_EFUSE_WDATA3                                       (volatile uint32_t *)(0xc8830000 + (0x08 << 2))
+#define     EFUSE_RDATA0                                       (0xc8830000 + (0x09 << 2))
+#define SEC_EFUSE_RDATA0                                       (0xda830000 + (0x09 << 2))
+#define   P_EFUSE_RDATA0                                       (volatile uint32_t *)(0xc8830000 + (0x09 << 2))
+#define     EFUSE_RDATA1                                       (0xc8830000 + (0x0a << 2))
+#define SEC_EFUSE_RDATA1                                       (0xda830000 + (0x0a << 2))
+#define   P_EFUSE_RDATA1                                       (volatile uint32_t *)(0xc8830000 + (0x0a << 2))
+#define     EFUSE_RDATA2                                       (0xc8830000 + (0x0b << 2))
+#define SEC_EFUSE_RDATA2                                       (0xda830000 + (0x0b << 2))
+#define   P_EFUSE_RDATA2                                       (volatile uint32_t *)(0xc8830000 + (0x0b << 2))
+#define     EFUSE_RDATA3                                       (0xc8830000 + (0x0c << 2))
+#define SEC_EFUSE_RDATA3                                       (0xda830000 + (0x0c << 2))
+#define   P_EFUSE_RDATA3                                       (volatile uint32_t *)(0xc8830000 + (0x0c << 2))
+#define     EFUSE_RD_DISABLE                                   (0xc8830000 + (0x10 << 2))
+#define SEC_EFUSE_RD_DISABLE                                   (0xda830000 + (0x10 << 2))
+#define   P_EFUSE_RD_DISABLE                                   (volatile uint32_t *)(0xc8830000 + (0x10 << 2))
+#define     EFUSE_WR_DISABLE                                   (0xc8830000 + (0x11 << 2))
+#define SEC_EFUSE_WR_DISABLE                                   (0xda830000 + (0x11 << 2))
+#define   P_EFUSE_WR_DISABLE                                   (volatile uint32_t *)(0xc8830000 + (0x11 << 2))
+#define     EFUSE_OBFUSCATE                                    (0xc8830000 + (0x12 << 2))
+#define SEC_EFUSE_OBFUSCATE                                    (0xda830000 + (0x12 << 2))
+#define   P_EFUSE_OBFUSCATE                                    (volatile uint32_t *)(0xc8830000 + (0x12 << 2))
+#define     EFUSE_AES_KEY32                                    (0xc8830000 + (0x13 << 2))
+#define SEC_EFUSE_AES_KEY32                                    (0xda830000 + (0x13 << 2))
+#define   P_EFUSE_AES_KEY32                                    (volatile uint32_t *)(0xc8830000 + (0x13 << 2))
+#define     KEY_LDR_USR_CNTL                                   (0xc8830000 + (0x20 << 2))
+#define SEC_KEY_LDR_USR_CNTL                                   (0xda830000 + (0x20 << 2))
+#define   P_KEY_LDR_USR_CNTL                                   (volatile uint32_t *)(0xc8830000 + (0x20 << 2))
+#define     KEY_LDR_USR_RAM_W                                  (0xc8830000 + (0x21 << 2))
+#define SEC_KEY_LDR_USR_RAM_W                                  (0xda830000 + (0x21 << 2))
+#define   P_KEY_LDR_USR_RAM_W                                  (volatile uint32_t *)(0xc8830000 + (0x21 << 2))
+#define     KEY_LDR_VENDOR_ID                                  (0xc8830000 + (0x22 << 2))
+#define SEC_KEY_LDR_VENDOR_ID                                  (0xda830000 + (0x22 << 2))
+#define   P_KEY_LDR_VENDOR_ID                                  (volatile uint32_t *)(0xc8830000 + (0x22 << 2))
+#define     KEY_LDR_SEC_REG0                                   (0xc8830000 + (0x23 << 2))
+#define SEC_KEY_LDR_SEC_REG0                                   (0xda830000 + (0x23 << 2))
+#define   P_KEY_LDR_SEC_REG0                                   (volatile uint32_t *)(0xc8830000 + (0x23 << 2))
+#define     KEY_LDR_SEC_CFG                                    (0xc8830000 + (0x24 << 2))
+#define SEC_KEY_LDR_SEC_CFG                                    (0xda830000 + (0x24 << 2))
+#define   P_KEY_LDR_SEC_CFG                                    (volatile uint32_t *)(0xc8830000 + (0x24 << 2))
+#define     KEY_LDR_SEC_BLK_NUM                                (0xc8830000 + (0x25 << 2))
+#define SEC_KEY_LDR_SEC_BLK_NUM                                (0xda830000 + (0x25 << 2))
+#define   P_KEY_LDR_SEC_BLK_NUM                                (volatile uint32_t *)(0xc8830000 + (0x25 << 2))
+#define     KEY_LDR_NONCE_0                                    (0xc8830000 + (0x26 << 2))
+#define SEC_KEY_LDR_NONCE_0                                    (0xda830000 + (0x26 << 2))
+#define   P_KEY_LDR_NONCE_0                                    (volatile uint32_t *)(0xc8830000 + (0x26 << 2))
+#define     KEY_LDR_NONCE_1                                    (0xc8830000 + (0x27 << 2))
+#define SEC_KEY_LDR_NONCE_1                                    (0xda830000 + (0x27 << 2))
+#define   P_KEY_LDR_NONCE_1                                    (volatile uint32_t *)(0xc8830000 + (0x27 << 2))
+#define     KEY_LDR_NONCE_2                                    (0xc8830000 + (0x28 << 2))
+#define SEC_KEY_LDR_NONCE_2                                    (0xda830000 + (0x28 << 2))
+#define   P_KEY_LDR_NONCE_2                                    (volatile uint32_t *)(0xc8830000 + (0x28 << 2))
+#define     KEY_LDR_NONCE_3                                    (0xc8830000 + (0x29 << 2))
+#define SEC_KEY_LDR_NONCE_3                                    (0xda830000 + (0x29 << 2))
+#define   P_KEY_LDR_NONCE_3                                    (volatile uint32_t *)(0xc8830000 + (0x29 << 2))
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./secure_apb4_ee.h
+//
+//
+// Reading file:  ./ao_rti_reg.h
+//
+// -------------------------------------------------------------------
+// PSEL #0
+// -------------------------------------------------------------------
+// APB4_DECODER_NON_SECURE_BASE     32'hC8100000
+// APB4_DECODER_SECURE_BASE         32'hDA100000
+// Registers not affected by the Watchdog timer
+#define     AO_RTI_STATUS_REG0                                 (0xc8100000 + (0x00 << 2))
+#define SEC_AO_RTI_STATUS_REG0                                 (0xda100000 + (0x00 << 2))
+#define   P_AO_RTI_STATUS_REG0                                 (volatile uint32_t *)(0xc8100000 + (0x00 << 2))
+#define     AO_RTI_STATUS_REG1                                 (0xc8100000 + (0x01 << 2))
+#define SEC_AO_RTI_STATUS_REG1                                 (0xda100000 + (0x01 << 2))
+#define   P_AO_RTI_STATUS_REG1                                 (volatile uint32_t *)(0xc8100000 + (0x01 << 2))
+#define     AO_RTI_STATUS_REG2                                 (0xc8100000 + (0x02 << 2))
+#define SEC_AO_RTI_STATUS_REG2                                 (0xda100000 + (0x02 << 2))
+#define   P_AO_RTI_STATUS_REG2                                 (volatile uint32_t *)(0xc8100000 + (0x02 << 2))
+#define     AO_RTI_PWR_CNTL_REG1                               (0xc8100000 + (0x03 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG1                               (0xda100000 + (0x03 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG1                               (volatile uint32_t *)(0xc8100000 + (0x03 << 2))
+#define     AO_RTI_PWR_CNTL_REG0                               (0xc8100000 + (0x04 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG0                               (0xda100000 + (0x04 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG0                               (volatile uint32_t *)(0xc8100000 + (0x04 << 2))
+#define     AO_RTI_PIN_MUX_REG                                 (0xc8100000 + (0x05 << 2))
+#define SEC_AO_RTI_PIN_MUX_REG                                 (0xda100000 + (0x05 << 2))
+#define   P_AO_RTI_PIN_MUX_REG                                 (volatile uint32_t *)(0xc8100000 + (0x05 << 2))
+#define     AO_RTI_PIN_MUX_REG2                                (0xc8100000 + (0x06 << 2))
+#define SEC_AO_RTI_PIN_MUX_REG2                                (0xda100000 + (0x06 << 2))
+#define   P_AO_RTI_PIN_MUX_REG2                                (volatile uint32_t *)(0xc8100000 + (0x06 << 2))
+#define     AO_RTI_STATUS_REG3                                 (0xc8100000 + (0x07 << 2))
+#define SEC_AO_RTI_STATUS_REG3                                 (0xda100000 + (0x07 << 2))
+#define   P_AO_RTI_STATUS_REG3                                 (volatile uint32_t *)(0xc8100000 + (0x07 << 2))
+//`define AO_REMAP_REG0               8'h07 //TODO: DELETE. NOT USED
+#define     AO_REMAP_REG1                                      (0xc8100000 + (0x08 << 2))
+#define SEC_AO_REMAP_REG1                                      (0xda100000 + (0x08 << 2))
+#define   P_AO_REMAP_REG1                                      (volatile uint32_t *)(0xc8100000 + (0x08 << 2))
+#define     AO_GPIO_O_EN_N                                     (0xc8100000 + (0x09 << 2))
+#define SEC_AO_GPIO_O_EN_N                                     (0xda100000 + (0x09 << 2))
+#define   P_AO_GPIO_O_EN_N                                     (volatile uint32_t *)(0xc8100000 + (0x09 << 2))
+#define     AO_GPIO_I                                          (0xc8100000 + (0x0a << 2))
+#define SEC_AO_GPIO_I                                          (0xda100000 + (0x0a << 2))
+#define   P_AO_GPIO_I                                          (volatile uint32_t *)(0xc8100000 + (0x0a << 2))
+#define     AO_RTI_PULL_UP_REG                                 (0xc8100000 + (0x0b << 2))
+#define SEC_AO_RTI_PULL_UP_REG                                 (0xda100000 + (0x0b << 2))
+#define   P_AO_RTI_PULL_UP_REG                                 (volatile uint32_t *)(0xc8100000 + (0x0b << 2))
+#define     AO_RTI_JTAG_CONFIG_REG                             (0xc8100000 + (0x0c << 2))
+#define SEC_AO_RTI_JTAG_CONFIG_REG                             (0xda100000 + (0x0c << 2))
+#define   P_AO_RTI_JTAG_CONFIG_REG                             (volatile uint32_t *)(0xc8100000 + (0x0c << 2))
+#define     AO_RTI_WD_MARK                                     (0xc8100000 + (0x0d << 2))
+#define SEC_AO_RTI_WD_MARK                                     (0xda100000 + (0x0d << 2))
+#define   P_AO_RTI_WD_MARK                                     (volatile uint32_t *)(0xc8100000 + (0x0d << 2))
+// sando add for AO CPU
+#define     AO_CPU_CNTL                                        (0xc8100000 + (0x0e << 2))
+#define SEC_AO_CPU_CNTL                                        (0xda100000 + (0x0e << 2))
+#define   P_AO_CPU_CNTL                                        (volatile uint32_t *)(0xc8100000 + (0x0e << 2))
+#define     AO_CPU_CNTL2                                       (0xc8100000 + (0x0f << 2))
+#define SEC_AO_CPU_CNTL2                                       (0xda100000 + (0x0f << 2))
+#define   P_AO_CPU_CNTL2                                       (volatile uint32_t *)(0xc8100000 + (0x0f << 2))
+#define     AO_RTI_GEN_CNTL_REG0                               (0xc8100000 + (0x10 << 2))
+#define SEC_AO_RTI_GEN_CNTL_REG0                               (0xda100000 + (0x10 << 2))
+#define   P_AO_RTI_GEN_CNTL_REG0                               (volatile uint32_t *)(0xc8100000 + (0x10 << 2))
+#define     AO_CPU_CNTL_NS                                     (0xc8100000 + (0x11 << 2))
+#define SEC_AO_CPU_CNTL_NS                                     (0xda100000 + (0x11 << 2))
+#define   P_AO_CPU_CNTL_NS                                     (volatile uint32_t *)(0xc8100000 + (0x11 << 2))
+#define     AO_TIMER_REG                                       (0xc8100000 + (0x13 << 2))
+#define SEC_AO_TIMER_REG                                       (0xda100000 + (0x13 << 2))
+#define   P_AO_TIMER_REG                                       (volatile uint32_t *)(0xc8100000 + (0x13 << 2))
+#define     AO_TIMERA_REG                                      (0xc8100000 + (0x14 << 2))
+#define SEC_AO_TIMERA_REG                                      (0xda100000 + (0x14 << 2))
+#define   P_AO_TIMERA_REG                                      (volatile uint32_t *)(0xc8100000 + (0x14 << 2))
+#define     AO_TIMERE_REG                                      (0xc8100000 + (0x15 << 2))
+#define SEC_AO_TIMERE_REG                                      (0xda100000 + (0x15 << 2))
+#define   P_AO_TIMERE_REG                                      (volatile uint32_t *)(0xc8100000 + (0x15 << 2))
+#define     AO_OSCIN_CNTL                                      (0xc8100000 + (0x16 << 2))
+#define SEC_AO_OSCIN_CNTL                                      (0xda100000 + (0x16 << 2))
+#define   P_AO_OSCIN_CNTL                                      (volatile uint32_t *)(0xc8100000 + (0x16 << 2))
+#define     AO_AHB2DDR_CNTL                                    (0xc8100000 + (0x18 << 2))
+#define SEC_AO_AHB2DDR_CNTL                                    (0xda100000 + (0x18 << 2))
+#define   P_AO_AHB2DDR_CNTL                                    (volatile uint32_t *)(0xc8100000 + (0x18 << 2))
+#define     AO_TIMEBASE_CNTL                                   (0xc8100000 + (0x19 << 2))
+#define SEC_AO_TIMEBASE_CNTL                                   (0xda100000 + (0x19 << 2))
+#define   P_AO_TIMEBASE_CNTL                                   (volatile uint32_t *)(0xc8100000 + (0x19 << 2))
+#define     AO_CRT_CLK_CNTL1                                   (0xc8100000 + (0x1a << 2))
+#define SEC_AO_CRT_CLK_CNTL1                                   (0xda100000 + (0x1a << 2))
+#define   P_AO_CRT_CLK_CNTL1                                   (volatile uint32_t *)(0xc8100000 + (0x1a << 2))
+#define     AO_RTI_INTER_OSC_CTL0                              (0xc8100000 + (0x1b << 2))
+#define SEC_AO_RTI_INTER_OSC_CTL0                              (0xda100000 + (0x1b << 2))
+#define   P_AO_RTI_INTER_OSC_CTL0                              (volatile uint32_t *)(0xc8100000 + (0x1b << 2))
+#define     AO_RTI_INTER_OSC_CTL1                              (0xc8100000 + (0x1c << 2))
+#define SEC_AO_RTI_INTER_OSC_CTL1                              (0xda100000 + (0x1c << 2))
+#define   P_AO_RTI_INTER_OSC_CTL1                              (volatile uint32_t *)(0xc8100000 + (0x1c << 2))
+#define     AO_METAL_REVISION                                  (0xc8100000 + (0x1f << 2))
+#define SEC_AO_METAL_REVISION                                  (0xda100000 + (0x1f << 2))
+#define   P_AO_METAL_REVISION                                  (volatile uint32_t *)(0xc8100000 + (0x1f << 2))
+#define     AO_IRQ_MASK_FIQ_SEL                                (0xc8100000 + (0x20 << 2))
+#define SEC_AO_IRQ_MASK_FIQ_SEL                                (0xda100000 + (0x20 << 2))
+#define   P_AO_IRQ_MASK_FIQ_SEL                                (volatile uint32_t *)(0xc8100000 + (0x20 << 2))
+#define     AO_IRQ_GPIO_REG                                    (0xc8100000 + (0x21 << 2))
+#define SEC_AO_IRQ_GPIO_REG                                    (0xda100000 + (0x21 << 2))
+#define   P_AO_IRQ_GPIO_REG                                    (volatile uint32_t *)(0xc8100000 + (0x21 << 2))
+#define     AO_IRQ_STAT                                        (0xc8100000 + (0x22 << 2))
+#define SEC_AO_IRQ_STAT                                        (0xda100000 + (0x22 << 2))
+#define   P_AO_IRQ_STAT                                        (volatile uint32_t *)(0xc8100000 + (0x22 << 2))
+#define     AO_IRQ_STAT_CLR                                    (0xc8100000 + (0x23 << 2))
+#define SEC_AO_IRQ_STAT_CLR                                    (0xda100000 + (0x23 << 2))
+#define   P_AO_IRQ_STAT_CLR                                    (volatile uint32_t *)(0xc8100000 + (0x23 << 2))
+#define     AO_SAR_CLK                                         (0xc8100000 + (0x24 << 2))
+#define SEC_AO_SAR_CLK                                         (0xda100000 + (0x24 << 2))
+#define   P_AO_SAR_CLK                                         (volatile uint32_t *)(0xc8100000 + (0x24 << 2))
+#define     AO_RTC_ALT_CLK_CNTL0                               (0xc8100000 + (0x25 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL0                               (0xda100000 + (0x25 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL0                               (volatile uint32_t *)(0xc8100000 + (0x25 << 2))
+#define     AO_RTC_ALT_CLK_CNTL1                               (0xc8100000 + (0x26 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL1                               (0xda100000 + (0x26 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL1                               (volatile uint32_t *)(0xc8100000 + (0x26 << 2))
+#define     AO_DEBUG_REG0                                      (0xc8100000 + (0x28 << 2))
+#define SEC_AO_DEBUG_REG0                                      (0xda100000 + (0x28 << 2))
+#define   P_AO_DEBUG_REG0                                      (volatile uint32_t *)(0xc8100000 + (0x28 << 2))
+#define     AO_DEBUG_REG1                                      (0xc8100000 + (0x29 << 2))
+#define SEC_AO_DEBUG_REG1                                      (0xda100000 + (0x29 << 2))
+#define   P_AO_DEBUG_REG1                                      (volatile uint32_t *)(0xc8100000 + (0x29 << 2))
+#define     AO_DEBUG_REG2                                      (0xc8100000 + (0x2a << 2))
+#define SEC_AO_DEBUG_REG2                                      (0xda100000 + (0x2a << 2))
+#define   P_AO_DEBUG_REG2                                      (volatile uint32_t *)(0xc8100000 + (0x2a << 2))
+#define     AO_DEBUG_REG3                                      (0xc8100000 + (0x2b << 2))
+#define SEC_AO_DEBUG_REG3                                      (0xda100000 + (0x2b << 2))
+#define   P_AO_DEBUG_REG3                                      (volatile uint32_t *)(0xc8100000 + (0x2b << 2))
+#define     AO_TIMESTAMP_CNTL                                  (0xc8100000 + (0x2d << 2))
+#define SEC_AO_TIMESTAMP_CNTL                                  (0xda100000 + (0x2d << 2))
+#define   P_AO_TIMESTAMP_CNTL                                  (volatile uint32_t *)(0xc8100000 + (0x2d << 2))
+#define     AO_TIMESTAMP_RD0                                   (0xc8100000 + (0x2e << 2))
+#define SEC_AO_TIMESTAMP_RD0                                   (0xda100000 + (0x2e << 2))
+#define   P_AO_TIMESTAMP_RD0                                   (volatile uint32_t *)(0xc8100000 + (0x2e << 2))
+#define     AO_TIMESTAMP_RD1                                   (0xc8100000 + (0x2f << 2))
+#define SEC_AO_TIMESTAMP_RD1                                   (0xda100000 + (0x2f << 2))
+#define   P_AO_TIMESTAMP_RD1                                   (volatile uint32_t *)(0xc8100000 + (0x2f << 2))
+#define     AO_IR_BLASTER_ADDR0                                (0xc8100000 + (0x30 << 2))
+#define SEC_AO_IR_BLASTER_ADDR0                                (0xda100000 + (0x30 << 2))
+#define   P_AO_IR_BLASTER_ADDR0                                (volatile uint32_t *)(0xc8100000 + (0x30 << 2))
+#define     AO_IR_BLASTER_ADDR1                                (0xc8100000 + (0x31 << 2))
+#define SEC_AO_IR_BLASTER_ADDR1                                (0xda100000 + (0x31 << 2))
+#define   P_AO_IR_BLASTER_ADDR1                                (volatile uint32_t *)(0xc8100000 + (0x31 << 2))
+#define     AO_IR_BLASTER_ADDR2                                (0xc8100000 + (0x32 << 2))
+#define SEC_AO_IR_BLASTER_ADDR2                                (0xda100000 + (0x32 << 2))
+#define   P_AO_IR_BLASTER_ADDR2                                (volatile uint32_t *)(0xc8100000 + (0x32 << 2))
+#define     AO_CPU_STAT1                                       (0xc8100000 + (0x33 << 2))
+#define SEC_AO_CPU_STAT1                                       (0xda100000 + (0x33 << 2))
+#define   P_AO_CPU_STAT1                                       (volatile uint32_t *)(0xc8100000 + (0x33 << 2))
+#define     AO_CPU_STAT2                                       (0xc8100000 + (0x34 << 2))
+#define SEC_AO_CPU_STAT2                                       (0xda100000 + (0x34 << 2))
+#define   P_AO_CPU_STAT2                                       (volatile uint32_t *)(0xc8100000 + (0x34 << 2))
+#define     AO_CPU_TIMESTAMP                                   (0xc8100000 + (0x35 << 2))
+#define SEC_AO_CPU_TIMESTAMP                                   (0xda100000 + (0x35 << 2))
+#define   P_AO_CPU_TIMESTAMP                                   (volatile uint32_t *)(0xc8100000 + (0x35 << 2))
+#define     AO_CPU_TIMESTAMP2                                  (0xc8100000 + (0x36 << 2))
+#define SEC_AO_CPU_TIMESTAMP2                                  (0xda100000 + (0x36 << 2))
+#define   P_AO_CPU_TIMESTAMP2                                  (volatile uint32_t *)(0xc8100000 + (0x36 << 2))
+#define     AO_CPU_CNTL3                                       (0xc8100000 + (0x37 << 2))
+#define SEC_AO_CPU_CNTL3                                       (0xda100000 + (0x37 << 2))
+#define   P_AO_CPU_CNTL3                                       (volatile uint32_t *)(0xc8100000 + (0x37 << 2))
+// general Power control
+#define     AO_RTI_PWR_SYS_CPU_CNTL0                           (0xc8100000 + (0x38 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL0                           (0xda100000 + (0x38 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL0                           (volatile uint32_t *)(0xc8100000 + (0x38 << 2))
+#define     AO_RTI_PWR_SYS_CPU_CNTL1                           (0xc8100000 + (0x39 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL1                           (0xda100000 + (0x39 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL1                           (volatile uint32_t *)(0xc8100000 + (0x39 << 2))
+#define     AO_RTI_GEN_PWR_SLEEP0                              (0xc8100000 + (0x3a << 2))
+#define SEC_AO_RTI_GEN_PWR_SLEEP0                              (0xda100000 + (0x3a << 2))
+#define   P_AO_RTI_GEN_PWR_SLEEP0                              (volatile uint32_t *)(0xc8100000 + (0x3a << 2))
+#define     AO_RTI_GEN_PWR_ISO0                                (0xc8100000 + (0x3b << 2))
+#define SEC_AO_RTI_GEN_PWR_ISO0                                (0xda100000 + (0x3b << 2))
+#define   P_AO_RTI_GEN_PWR_ISO0                                (volatile uint32_t *)(0xc8100000 + (0x3b << 2))
+#define     AO_RTI_GEN_PWR_ACK0                                (0xc8100000 + (0x3c << 2))
+#define SEC_AO_RTI_GEN_PWR_ACK0                                (0xda100000 + (0x3c << 2))
+#define   P_AO_RTI_GEN_PWR_ACK0                                (volatile uint32_t *)(0xc8100000 + (0x3c << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xc8100000 + (0x3d << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xda100000 + (0x3d << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (volatile uint32_t *)(0xc8100000 + (0x3d << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xc8100000 + (0x3e << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xda100000 + (0x3e << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (volatile uint32_t *)(0xc8100000 + (0x3e << 2))
+#define     AO_CPU_CNTL4                                       (0xc8100000 + (0x3f << 2))
+#define SEC_AO_CPU_CNTL4                                       (0xda100000 + (0x3f << 2))
+#define   P_AO_CPU_CNTL4                                       (volatile uint32_t *)(0xc8100000 + (0x3f << 2))
+#define     AO_CEC_GEN_CNTL                                    (0xc8100000 + (0x40 << 2))
+#define SEC_AO_CEC_GEN_CNTL                                    (0xda100000 + (0x40 << 2))
+#define   P_AO_CEC_GEN_CNTL                                    (volatile uint32_t *)(0xc8100000 + (0x40 << 2))
+#define     AO_CEC_RW_REG                                      (0xc8100000 + (0x41 << 2))
+#define SEC_AO_CEC_RW_REG                                      (0xda100000 + (0x41 << 2))
+#define   P_AO_CEC_RW_REG                                      (volatile uint32_t *)(0xc8100000 + (0x41 << 2))
+#define     AO_CEC_INTR_MASKN                                  (0xc8100000 + (0x42 << 2))
+#define SEC_AO_CEC_INTR_MASKN                                  (0xda100000 + (0x42 << 2))
+#define   P_AO_CEC_INTR_MASKN                                  (volatile uint32_t *)(0xc8100000 + (0x42 << 2))
+#define     AO_CEC_INTR_CLR                                    (0xc8100000 + (0x43 << 2))
+#define SEC_AO_CEC_INTR_CLR                                    (0xda100000 + (0x43 << 2))
+#define   P_AO_CEC_INTR_CLR                                    (volatile uint32_t *)(0xc8100000 + (0x43 << 2))
+#define     AO_CEC_INTR_STAT                                   (0xc8100000 + (0x44 << 2))
+#define SEC_AO_CEC_INTR_STAT                                   (0xda100000 + (0x44 << 2))
+#define   P_AO_CEC_INTR_STAT                                   (volatile uint32_t *)(0xc8100000 + (0x44 << 2))
+#define     AO_CPU_CNTL5                                       (0xc8100000 + (0x45 << 2))
+#define SEC_AO_CPU_CNTL5                                       (0xda100000 + (0x45 << 2))
+#define   P_AO_CPU_CNTL5                                       (volatile uint32_t *)(0xc8100000 + (0x45 << 2))
+#define     AO_WATCHDOG_CNTL                                   (0xc8100000 + (0x48 << 2))
+#define SEC_AO_WATCHDOG_CNTL                                   (0xda100000 + (0x48 << 2))
+#define   P_AO_WATCHDOG_CNTL                                   (volatile uint32_t *)(0xc8100000 + (0x48 << 2))
+#define     AO_WATCHDOG_CNTL1                                  (0xc8100000 + (0x49 << 2))
+#define SEC_AO_WATCHDOG_CNTL1                                  (0xda100000 + (0x49 << 2))
+#define   P_AO_WATCHDOG_CNTL1                                  (volatile uint32_t *)(0xc8100000 + (0x49 << 2))
+#define     AO_WATCHDOG_TCNT                                   (0xc8100000 + (0x4a << 2))
+#define SEC_AO_WATCHDOG_TCNT                                   (0xda100000 + (0x4a << 2))
+#define   P_AO_WATCHDOG_TCNT                                   (volatile uint32_t *)(0xc8100000 + (0x4a << 2))
+#define     AO_WATCHDOG_RESET                                  (0xc8100000 + (0x4b << 2))
+#define SEC_AO_WATCHDOG_RESET                                  (0xda100000 + (0x4b << 2))
+#define   P_AO_WATCHDOG_RESET                                  (volatile uint32_t *)(0xc8100000 + (0x4b << 2))
+#define     AO_RTI_STICKY_REG0                                 (0xc8100000 + (0x4c << 2))
+#define SEC_AO_RTI_STICKY_REG0                                 (0xda100000 + (0x4c << 2))
+#define   P_AO_RTI_STICKY_REG0                                 (volatile uint32_t *)(0xc8100000 + (0x4c << 2))
+#define     AO_RTI_STICKY_REG1                                 (0xc8100000 + (0x4d << 2))
+#define SEC_AO_RTI_STICKY_REG1                                 (0xda100000 + (0x4d << 2))
+#define   P_AO_RTI_STICKY_REG1                                 (volatile uint32_t *)(0xc8100000 + (0x4d << 2))
+#define     AO_RTI_STICKY_REG2                                 (0xc8100000 + (0x4e << 2))
+#define SEC_AO_RTI_STICKY_REG2                                 (0xda100000 + (0x4e << 2))
+#define   P_AO_RTI_STICKY_REG2                                 (volatile uint32_t *)(0xc8100000 + (0x4e << 2))
+#define     AO_RTI_STICKY_REG3                                 (0xc8100000 + (0x4f << 2))
+#define SEC_AO_RTI_STICKY_REG3                                 (0xda100000 + (0x4f << 2))
+#define   P_AO_RTI_STICKY_REG3                                 (volatile uint32_t *)(0xc8100000 + (0x4f << 2))
+//
+// Secure APB3 Slot 2 registers
+//
+#define     AO_SEC_REG0                                        (0xc8100000 + (0x50 << 2))
+#define SEC_AO_SEC_REG0                                        (0xda100000 + (0x50 << 2))
+#define   P_AO_SEC_REG0                                        (volatile uint32_t *)(0xc8100000 + (0x50 << 2))
+#define     AO_SEC_REG1                                        (0xc8100000 + (0x51 << 2))
+#define SEC_AO_SEC_REG1                                        (0xda100000 + (0x51 << 2))
+#define   P_AO_SEC_REG1                                        (volatile uint32_t *)(0xc8100000 + (0x51 << 2))
+#define     AO_SEC_REG2                                        (0xc8100000 + (0x52 << 2))
+#define SEC_AO_SEC_REG2                                        (0xda100000 + (0x52 << 2))
+#define   P_AO_SEC_REG2                                        (volatile uint32_t *)(0xc8100000 + (0x52 << 2))
+#define     AO_SEC_TMODE_PWD0                                  (0xc8100000 + (0x58 << 2))
+#define SEC_AO_SEC_TMODE_PWD0                                  (0xda100000 + (0x58 << 2))
+#define   P_AO_SEC_TMODE_PWD0                                  (volatile uint32_t *)(0xc8100000 + (0x58 << 2))
+#define     AO_SEC_TMODE_PWD1                                  (0xc8100000 + (0x59 << 2))
+#define SEC_AO_SEC_TMODE_PWD1                                  (0xda100000 + (0x59 << 2))
+#define   P_AO_SEC_TMODE_PWD1                                  (volatile uint32_t *)(0xc8100000 + (0x59 << 2))
+#define     AO_SEC_TMODE_PWD2                                  (0xc8100000 + (0x5a << 2))
+#define SEC_AO_SEC_TMODE_PWD2                                  (0xda100000 + (0x5a << 2))
+#define   P_AO_SEC_TMODE_PWD2                                  (volatile uint32_t *)(0xc8100000 + (0x5a << 2))
+#define     AO_SEC_TMODE_PWD3                                  (0xc8100000 + (0x5b << 2))
+#define SEC_AO_SEC_TMODE_PWD3                                  (0xda100000 + (0x5b << 2))
+#define   P_AO_SEC_TMODE_PWD3                                  (volatile uint32_t *)(0xc8100000 + (0x5b << 2))
+#define     AO_SEC_SCRATCH                                     (0xc8100000 + (0x5f << 2))
+#define SEC_AO_SEC_SCRATCH                                     (0xda100000 + (0x5f << 2))
+#define   P_AO_SEC_SCRATCH                                     (volatile uint32_t *)(0xc8100000 + (0x5f << 2))
+#define     AO_SEC_JTAG_PWD0                                   (0xc8100000 + (0x60 << 2))
+#define SEC_AO_SEC_JTAG_PWD0                                   (0xda100000 + (0x60 << 2))
+#define   P_AO_SEC_JTAG_PWD0                                   (volatile uint32_t *)(0xc8100000 + (0x60 << 2))
+#define     AO_SEC_JTAG_PWD1                                   (0xc8100000 + (0x61 << 2))
+#define SEC_AO_SEC_JTAG_PWD1                                   (0xda100000 + (0x61 << 2))
+#define   P_AO_SEC_JTAG_PWD1                                   (volatile uint32_t *)(0xc8100000 + (0x61 << 2))
+#define     AO_SEC_JTAG_PWD2                                   (0xc8100000 + (0x62 << 2))
+#define SEC_AO_SEC_JTAG_PWD2                                   (0xda100000 + (0x62 << 2))
+#define   P_AO_SEC_JTAG_PWD2                                   (volatile uint32_t *)(0xc8100000 + (0x62 << 2))
+#define     AO_SEC_JTAG_PWD3                                   (0xc8100000 + (0x63 << 2))
+#define SEC_AO_SEC_JTAG_PWD3                                   (0xda100000 + (0x63 << 2))
+#define   P_AO_SEC_JTAG_PWD3                                   (volatile uint32_t *)(0xc8100000 + (0x63 << 2))
+#define     AO_SEC_JTAG_SEC_CNTL                               (0xc8100000 + (0x64 << 2))
+#define SEC_AO_SEC_JTAG_SEC_CNTL                               (0xda100000 + (0x64 << 2))
+#define   P_AO_SEC_JTAG_SEC_CNTL                               (volatile uint32_t *)(0xc8100000 + (0x64 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR0                              (0xc8100000 + (0x65 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR0                              (0xda100000 + (0x65 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR0                              (volatile uint32_t *)(0xc8100000 + (0x65 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR1                              (0xc8100000 + (0x66 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR1                              (0xda100000 + (0x66 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR1                              (volatile uint32_t *)(0xc8100000 + (0x66 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR2                              (0xc8100000 + (0x67 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR2                              (0xda100000 + (0x67 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR2                              (volatile uint32_t *)(0xc8100000 + (0x67 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR3                              (0xc8100000 + (0x68 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR3                              (0xda100000 + (0x68 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR3                              (volatile uint32_t *)(0xc8100000 + (0x68 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xc8100000 + (0x70 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xda100000 + (0x70 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (volatile uint32_t *)(0xc8100000 + (0x70 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xc8100000 + (0x71 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xda100000 + (0x71 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (volatile uint32_t *)(0xc8100000 + (0x71 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xc8100000 + (0x72 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xda100000 + (0x72 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (volatile uint32_t *)(0xc8100000 + (0x72 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xc8100000 + (0x73 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xda100000 + (0x73 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (volatile uint32_t *)(0xc8100000 + (0x73 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xc8100000 + (0x74 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xda100000 + (0x74 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (volatile uint32_t *)(0xc8100000 + (0x74 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xc8100000 + (0x75 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xda100000 + (0x75 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (volatile uint32_t *)(0xc8100000 + (0x75 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xc8100000 + (0x76 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xda100000 + (0x76 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (volatile uint32_t *)(0xc8100000 + (0x76 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xc8100000 + (0x77 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xda100000 + (0x77 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (volatile uint32_t *)(0xc8100000 + (0x77 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xc8100000 + (0x78 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xda100000 + (0x78 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (volatile uint32_t *)(0xc8100000 + (0x78 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xc8100000 + (0x79 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xda100000 + (0x79 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (volatile uint32_t *)(0xc8100000 + (0x79 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xc8100000 + (0x7a << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xda100000 + (0x7a << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (volatile uint32_t *)(0xc8100000 + (0x7a << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xc8100000 + (0x7b << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xda100000 + (0x7b << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (volatile uint32_t *)(0xc8100000 + (0x7b << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG0_0                          (0xc8100000 + (0x7c << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG0_0                          (0xda100000 + (0x7c << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG0_0                          (volatile uint32_t *)(0xc8100000 + (0x7c << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG0_1                          (0xc8100000 + (0x7d << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG0_1                          (0xda100000 + (0x7d << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG0_1                          (volatile uint32_t *)(0xc8100000 + (0x7d << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG1_0                          (0xc8100000 + (0x7e << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG1_0                          (0xda100000 + (0x7e << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG1_0                          (volatile uint32_t *)(0xc8100000 + (0x7e << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG1_1                          (0xc8100000 + (0x7f << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG1_1                          (0xda100000 + (0x7f << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG1_1                          (volatile uint32_t *)(0xc8100000 + (0x7f << 2))
+#define     AO_SEC_SD_CFG8                                     (0xc8100000 + (0x88 << 2))
+#define SEC_AO_SEC_SD_CFG8                                     (0xda100000 + (0x88 << 2))
+#define   P_AO_SEC_SD_CFG8                                     (volatile uint32_t *)(0xc8100000 + (0x88 << 2))
+#define     AO_SEC_SD_CFG9                                     (0xc8100000 + (0x89 << 2))
+#define SEC_AO_SEC_SD_CFG9                                     (0xda100000 + (0x89 << 2))
+#define   P_AO_SEC_SD_CFG9                                     (volatile uint32_t *)(0xc8100000 + (0x89 << 2))
+#define     AO_SEC_SD_CFG10                                    (0xc8100000 + (0x8a << 2))
+#define SEC_AO_SEC_SD_CFG10                                    (0xda100000 + (0x8a << 2))
+#define   P_AO_SEC_SD_CFG10                                    (volatile uint32_t *)(0xc8100000 + (0x8a << 2))
+#define     AO_SEC_SD_CFG11                                    (0xc8100000 + (0x8b << 2))
+#define SEC_AO_SEC_SD_CFG11                                    (0xda100000 + (0x8b << 2))
+#define   P_AO_SEC_SD_CFG11                                    (volatile uint32_t *)(0xc8100000 + (0x8b << 2))
+#define     AO_SEC_SD_CFG12                                    (0xc8100000 + (0x8c << 2))
+#define SEC_AO_SEC_SD_CFG12                                    (0xda100000 + (0x8c << 2))
+#define   P_AO_SEC_SD_CFG12                                    (volatile uint32_t *)(0xc8100000 + (0x8c << 2))
+#define     AO_SEC_SD_CFG13                                    (0xc8100000 + (0x8d << 2))
+#define SEC_AO_SEC_SD_CFG13                                    (0xda100000 + (0x8d << 2))
+#define   P_AO_SEC_SD_CFG13                                    (volatile uint32_t *)(0xc8100000 + (0x8d << 2))
+#define     AO_SEC_SD_CFG14                                    (0xc8100000 + (0x8e << 2))
+#define SEC_AO_SEC_SD_CFG14                                    (0xda100000 + (0x8e << 2))
+#define   P_AO_SEC_SD_CFG14                                    (volatile uint32_t *)(0xc8100000 + (0x8e << 2))
+#define     AO_SEC_SD_CFG15                                    (0xc8100000 + (0x8f << 2))
+#define SEC_AO_SEC_SD_CFG15                                    (0xda100000 + (0x8f << 2))
+#define   P_AO_SEC_SD_CFG15                                    (volatile uint32_t *)(0xc8100000 + (0x8f << 2))
+#define     AO_SEC_GP_CFG0                                     (0xc8100000 + (0x90 << 2))
+#define SEC_AO_SEC_GP_CFG0                                     (0xda100000 + (0x90 << 2))
+#define   P_AO_SEC_GP_CFG0                                     (volatile uint32_t *)(0xc8100000 + (0x90 << 2))
+#define     AO_SEC_GP_CFG1                                     (0xc8100000 + (0x91 << 2))
+#define SEC_AO_SEC_GP_CFG1                                     (0xda100000 + (0x91 << 2))
+#define   P_AO_SEC_GP_CFG1                                     (volatile uint32_t *)(0xc8100000 + (0x91 << 2))
+#define     AO_SEC_GP_CFG2                                     (0xc8100000 + (0x92 << 2))
+#define SEC_AO_SEC_GP_CFG2                                     (0xda100000 + (0x92 << 2))
+#define   P_AO_SEC_GP_CFG2                                     (volatile uint32_t *)(0xc8100000 + (0x92 << 2))
+#define     AO_SEC_GP_CFG3                                     (0xc8100000 + (0x93 << 2))
+#define SEC_AO_SEC_GP_CFG3                                     (0xda100000 + (0x93 << 2))
+#define   P_AO_SEC_GP_CFG3                                     (volatile uint32_t *)(0xc8100000 + (0x93 << 2))
+#define     AO_SEC_GP_CFG4                                     (0xc8100000 + (0x94 << 2))
+#define SEC_AO_SEC_GP_CFG4                                     (0xda100000 + (0x94 << 2))
+#define   P_AO_SEC_GP_CFG4                                     (volatile uint32_t *)(0xc8100000 + (0x94 << 2))
+#define     AO_SEC_GP_CFG5                                     (0xc8100000 + (0x95 << 2))
+#define SEC_AO_SEC_GP_CFG5                                     (0xda100000 + (0x95 << 2))
+#define   P_AO_SEC_GP_CFG5                                     (volatile uint32_t *)(0xc8100000 + (0x95 << 2))
+#define     AO_SEC_GP_CFG6                                     (0xc8100000 + (0x96 << 2))
+#define SEC_AO_SEC_GP_CFG6                                     (0xda100000 + (0x96 << 2))
+#define   P_AO_SEC_GP_CFG6                                     (volatile uint32_t *)(0xc8100000 + (0x96 << 2))
+#define     AO_SEC_GP_CFG7                                     (0xc8100000 + (0x97 << 2))
+#define SEC_AO_SEC_GP_CFG7                                     (0xda100000 + (0x97 << 2))
+#define   P_AO_SEC_GP_CFG7                                     (volatile uint32_t *)(0xc8100000 + (0x97 << 2))
+#define     AO_SEC_GP_CFG8                                     (0xc8100000 + (0x98 << 2))
+#define SEC_AO_SEC_GP_CFG8                                     (0xda100000 + (0x98 << 2))
+#define   P_AO_SEC_GP_CFG8                                     (volatile uint32_t *)(0xc8100000 + (0x98 << 2))
+#define     AO_SEC_GP_CFG9                                     (0xc8100000 + (0x99 << 2))
+#define SEC_AO_SEC_GP_CFG9                                     (0xda100000 + (0x99 << 2))
+#define   P_AO_SEC_GP_CFG9                                     (volatile uint32_t *)(0xc8100000 + (0x99 << 2))
+#define     AO_SEC_GP_CFG10                                    (0xc8100000 + (0x9a << 2))
+#define SEC_AO_SEC_GP_CFG10                                    (0xda100000 + (0x9a << 2))
+#define   P_AO_SEC_GP_CFG10                                    (volatile uint32_t *)(0xc8100000 + (0x9a << 2))
+#define     AO_SEC_GP_CFG11                                    (0xc8100000 + (0x9b << 2))
+#define SEC_AO_SEC_GP_CFG11                                    (0xda100000 + (0x9b << 2))
+#define   P_AO_SEC_GP_CFG11                                    (volatile uint32_t *)(0xc8100000 + (0x9b << 2))
+#define     AO_SEC_GP_CFG12                                    (0xc8100000 + (0x9c << 2))
+#define SEC_AO_SEC_GP_CFG12                                    (0xda100000 + (0x9c << 2))
+#define   P_AO_SEC_GP_CFG12                                    (volatile uint32_t *)(0xc8100000 + (0x9c << 2))
+#define     AO_SEC_GP_CFG13                                    (0xc8100000 + (0x9d << 2))
+#define SEC_AO_SEC_GP_CFG13                                    (0xda100000 + (0x9d << 2))
+#define   P_AO_SEC_GP_CFG13                                    (volatile uint32_t *)(0xc8100000 + (0x9d << 2))
+#define     AO_SEC_GP_CFG14                                    (0xc8100000 + (0x9e << 2))
+#define SEC_AO_SEC_GP_CFG14                                    (0xda100000 + (0x9e << 2))
+#define   P_AO_SEC_GP_CFG14                                    (volatile uint32_t *)(0xc8100000 + (0x9e << 2))
+#define     AO_SEC_GP_CFG15                                    (0xc8100000 + (0x9f << 2))
+#define SEC_AO_SEC_GP_CFG15                                    (0xda100000 + (0x9f << 2))
+#define   P_AO_SEC_GP_CFG15                                    (volatile uint32_t *)(0xc8100000 + (0x9f << 2))
+//`define AO_RTC_ADDR0                    8'h70 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR1                    8'h71 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR2                    8'h72 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR3                    8'h73 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR4                    8'h74 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+// -------------------------------------------------------------------
+// PSEL #1
+// -------------------------------------------------------------------
+// APB4_DECODER_NON_SECURE_BASE     32'hC8100400
+// APB4_DECODER_SECURE_BASE         32'hDA100400
+// ----------------------------
+// IR Remote (8)
+// ----------------------------
+#define     AO_IR_DEC_LDR_ACTIVE                               (0xc8100400 + (0x20 << 2))
+#define SEC_AO_IR_DEC_LDR_ACTIVE                               (0xda100400 + (0x20 << 2))
+#define   P_AO_IR_DEC_LDR_ACTIVE                               (volatile uint32_t *)(0xc8100400 + (0x20 << 2))
+#define     AO_IR_DEC_LDR_IDLE                                 (0xc8100400 + (0x21 << 2))
+#define SEC_AO_IR_DEC_LDR_IDLE                                 (0xda100400 + (0x21 << 2))
+#define   P_AO_IR_DEC_LDR_IDLE                                 (volatile uint32_t *)(0xc8100400 + (0x21 << 2))
+#define     AO_IR_DEC_LDR_REPEAT                               (0xc8100400 + (0x22 << 2))
+#define SEC_AO_IR_DEC_LDR_REPEAT                               (0xda100400 + (0x22 << 2))
+#define   P_AO_IR_DEC_LDR_REPEAT                               (volatile uint32_t *)(0xc8100400 + (0x22 << 2))
+#define     AO_IR_DEC_BIT_0                                    (0xc8100400 + (0x23 << 2))
+#define SEC_AO_IR_DEC_BIT_0                                    (0xda100400 + (0x23 << 2))
+#define   P_AO_IR_DEC_BIT_0                                    (volatile uint32_t *)(0xc8100400 + (0x23 << 2))
+#define     AO_IR_DEC_REG0                                     (0xc8100400 + (0x24 << 2))
+#define SEC_AO_IR_DEC_REG0                                     (0xda100400 + (0x24 << 2))
+#define   P_AO_IR_DEC_REG0                                     (volatile uint32_t *)(0xc8100400 + (0x24 << 2))
+#define     AO_IR_DEC_FRAME                                    (0xc8100400 + (0x25 << 2))
+#define SEC_AO_IR_DEC_FRAME                                    (0xda100400 + (0x25 << 2))
+#define   P_AO_IR_DEC_FRAME                                    (volatile uint32_t *)(0xc8100400 + (0x25 << 2))
+#define     AO_IR_DEC_STATUS                                   (0xc8100400 + (0x26 << 2))
+#define SEC_AO_IR_DEC_STATUS                                   (0xda100400 + (0x26 << 2))
+#define   P_AO_IR_DEC_STATUS                                   (volatile uint32_t *)(0xc8100400 + (0x26 << 2))
+#define     AO_IR_DEC_REG1                                     (0xc8100400 + (0x27 << 2))
+#define SEC_AO_IR_DEC_REG1                                     (0xda100400 + (0x27 << 2))
+#define   P_AO_IR_DEC_REG1                                     (volatile uint32_t *)(0xc8100400 + (0x27 << 2))
+// ----------------------------
+// UART
+// ----------------------------
+#define     AO_UART_WFIFO                                      (0xc8100400 + (0x30 << 2))
+#define SEC_AO_UART_WFIFO                                      (0xda100400 + (0x30 << 2))
+#define   P_AO_UART_WFIFO                                      (volatile uint32_t *)(0xc8100400 + (0x30 << 2))
+#define     AO_UART_RFIFO                                      (0xc8100400 + (0x31 << 2))
+#define SEC_AO_UART_RFIFO                                      (0xda100400 + (0x31 << 2))
+#define   P_AO_UART_RFIFO                                      (volatile uint32_t *)(0xc8100400 + (0x31 << 2))
+#define     AO_UART_CONTROL                                    (0xc8100400 + (0x32 << 2))
+#define SEC_AO_UART_CONTROL                                    (0xda100400 + (0x32 << 2))
+#define   P_AO_UART_CONTROL                                    (volatile uint32_t *)(0xc8100400 + (0x32 << 2))
+#define     AO_UART_STATUS                                     (0xc8100400 + (0x33 << 2))
+#define SEC_AO_UART_STATUS                                     (0xda100400 + (0x33 << 2))
+#define   P_AO_UART_STATUS                                     (volatile uint32_t *)(0xc8100400 + (0x33 << 2))
+#define     AO_UART_MISC                                       (0xc8100400 + (0x34 << 2))
+#define SEC_AO_UART_MISC                                       (0xda100400 + (0x34 << 2))
+#define   P_AO_UART_MISC                                       (volatile uint32_t *)(0xc8100400 + (0x34 << 2))
+#define     AO_UART_REG5                                       (0xc8100400 + (0x35 << 2))
+#define SEC_AO_UART_REG5                                       (0xda100400 + (0x35 << 2))
+#define   P_AO_UART_REG5                                       (volatile uint32_t *)(0xc8100400 + (0x35 << 2))
+// ----------------------------
+// UART2
+// ----------------------------
+#define     AO_UART2_WFIFO                                     (0xc8100400 + (0x38 << 2))
+#define SEC_AO_UART2_WFIFO                                     (0xda100400 + (0x38 << 2))
+#define   P_AO_UART2_WFIFO                                     (volatile uint32_t *)(0xc8100400 + (0x38 << 2))
+#define     AO_UART2_RFIFO                                     (0xc8100400 + (0x39 << 2))
+#define SEC_AO_UART2_RFIFO                                     (0xda100400 + (0x39 << 2))
+#define   P_AO_UART2_RFIFO                                     (volatile uint32_t *)(0xc8100400 + (0x39 << 2))
+#define     AO_UART2_CONTROL                                   (0xc8100400 + (0x3a << 2))
+#define SEC_AO_UART2_CONTROL                                   (0xda100400 + (0x3a << 2))
+#define   P_AO_UART2_CONTROL                                   (volatile uint32_t *)(0xc8100400 + (0x3a << 2))
+#define     AO_UART2_STATUS                                    (0xc8100400 + (0x3b << 2))
+#define SEC_AO_UART2_STATUS                                    (0xda100400 + (0x3b << 2))
+#define   P_AO_UART2_STATUS                                    (volatile uint32_t *)(0xc8100400 + (0x3b << 2))
+#define     AO_UART2_MISC                                      (0xc8100400 + (0x3c << 2))
+#define SEC_AO_UART2_MISC                                      (0xda100400 + (0x3c << 2))
+#define   P_AO_UART2_MISC                                      (volatile uint32_t *)(0xc8100400 + (0x3c << 2))
+#define     AO_UART2_REG5                                      (0xc8100400 + (0x3d << 2))
+#define SEC_AO_UART2_REG5                                      (0xda100400 + (0x3d << 2))
+#define   P_AO_UART2_REG5                                      (volatile uint32_t *)(0xc8100400 + (0x3d << 2))
+// ----------------------------
+// I2C Master (8)
+// ----------------------------
+#define     AO_I2C_M_0_CONTROL_REG                             (0xc8100400 + (0x40 << 2))
+#define SEC_AO_I2C_M_0_CONTROL_REG                             (0xda100400 + (0x40 << 2))
+#define   P_AO_I2C_M_0_CONTROL_REG                             (volatile uint32_t *)(0xc8100400 + (0x40 << 2))
+#define     AO_I2C_M_0_SLAVE_ADDR                              (0xc8100400 + (0x41 << 2))
+#define SEC_AO_I2C_M_0_SLAVE_ADDR                              (0xda100400 + (0x41 << 2))
+#define   P_AO_I2C_M_0_SLAVE_ADDR                              (volatile uint32_t *)(0xc8100400 + (0x41 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST0                             (0xc8100400 + (0x42 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST0                             (0xda100400 + (0x42 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST0                             (volatile uint32_t *)(0xc8100400 + (0x42 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST1                             (0xc8100400 + (0x43 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST1                             (0xda100400 + (0x43 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST1                             (volatile uint32_t *)(0xc8100400 + (0x43 << 2))
+#define     AO_I2C_M_0_WDATA_REG0                              (0xc8100400 + (0x44 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG0                              (0xda100400 + (0x44 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG0                              (volatile uint32_t *)(0xc8100400 + (0x44 << 2))
+#define     AO_I2C_M_0_WDATA_REG1                              (0xc8100400 + (0x45 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG1                              (0xda100400 + (0x45 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG1                              (volatile uint32_t *)(0xc8100400 + (0x45 << 2))
+#define     AO_I2C_M_0_RDATA_REG0                              (0xc8100400 + (0x46 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG0                              (0xda100400 + (0x46 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG0                              (volatile uint32_t *)(0xc8100400 + (0x46 << 2))
+#define     AO_I2C_M_0_RDATA_REG1                              (0xc8100400 + (0x47 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG1                              (0xda100400 + (0x47 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG1                              (volatile uint32_t *)(0xc8100400 + (0x47 << 2))
+// ----------------------------
+// I2C Slave (3)
+// ----------------------------
+#define     AO_I2C_S_CONTROL_REG                               (0xc8100400 + (0x50 << 2))
+#define SEC_AO_I2C_S_CONTROL_REG                               (0xda100400 + (0x50 << 2))
+#define   P_AO_I2C_S_CONTROL_REG                               (volatile uint32_t *)(0xc8100400 + (0x50 << 2))
+#define     AO_I2C_S_SEND_REG                                  (0xc8100400 + (0x51 << 2))
+#define SEC_AO_I2C_S_SEND_REG                                  (0xda100400 + (0x51 << 2))
+#define   P_AO_I2C_S_SEND_REG                                  (volatile uint32_t *)(0xc8100400 + (0x51 << 2))
+#define     AO_I2C_S_RECV_REG                                  (0xc8100400 + (0x52 << 2))
+#define SEC_AO_I2C_S_RECV_REG                                  (0xda100400 + (0x52 << 2))
+#define   P_AO_I2C_S_RECV_REG                                  (volatile uint32_t *)(0xc8100400 + (0x52 << 2))
+#define     AO_I2C_S_CNTL1_REG                                 (0xc8100400 + (0x53 << 2))
+#define SEC_AO_I2C_S_CNTL1_REG                                 (0xda100400 + (0x53 << 2))
+#define   P_AO_I2C_S_CNTL1_REG                                 (volatile uint32_t *)(0xc8100400 + (0x53 << 2))
+// ----------------------------
+// PWM A-B
+// ----------------------------
+#define     AO_PWM_PWM_A                                       (0xc8100400 + (0x54 << 2))
+#define SEC_AO_PWM_PWM_A                                       (0xda100400 + (0x54 << 2))
+#define   P_AO_PWM_PWM_A                                       (volatile uint32_t *)(0xc8100400 + (0x54 << 2))
+#define     AO_PWM_PWM_B                                       (0xc8100400 + (0x55 << 2))
+#define SEC_AO_PWM_PWM_B                                       (0xda100400 + (0x55 << 2))
+#define   P_AO_PWM_PWM_B                                       (volatile uint32_t *)(0xc8100400 + (0x55 << 2))
+#define     AO_PWM_MISC_REG_AB                                 (0xc8100400 + (0x56 << 2))
+#define SEC_AO_PWM_MISC_REG_AB                                 (0xda100400 + (0x56 << 2))
+#define   P_AO_PWM_MISC_REG_AB                                 (volatile uint32_t *)(0xc8100400 + (0x56 << 2))
+#define     AO_PWM_DELTA_SIGMA_AB                              (0xc8100400 + (0x57 << 2))
+#define SEC_AO_PWM_DELTA_SIGMA_AB                              (0xda100400 + (0x57 << 2))
+#define   P_AO_PWM_DELTA_SIGMA_AB                              (volatile uint32_t *)(0xc8100400 + (0x57 << 2))
+#define     AO_PWM_TIME_AB                                     (0xc8100400 + (0x58 << 2))
+#define SEC_AO_PWM_TIME_AB                                     (0xda100400 + (0x58 << 2))
+#define   P_AO_PWM_TIME_AB                                     (volatile uint32_t *)(0xc8100400 + (0x58 << 2))
+#define     AO_PWM_A2                                          (0xc8100400 + (0x59 << 2))
+#define SEC_AO_PWM_A2                                          (0xda100400 + (0x59 << 2))
+#define   P_AO_PWM_A2                                          (volatile uint32_t *)(0xc8100400 + (0x59 << 2))
+#define     AO_PWM_B2                                          (0xc8100400 + (0x5a << 2))
+#define SEC_AO_PWM_B2                                          (0xda100400 + (0x5a << 2))
+#define   P_AO_PWM_B2                                          (volatile uint32_t *)(0xc8100400 + (0x5a << 2))
+// ----------------------------
+// Multiformat IR Remote
+// ----------------------------
+#define     AO_MF_IR_DEC_LDR_ACTIVE                            (0xc8100400 + (0x60 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_ACTIVE                            (0xda100400 + (0x60 << 2))
+#define   P_AO_MF_IR_DEC_LDR_ACTIVE                            (volatile uint32_t *)(0xc8100400 + (0x60 << 2))
+#define     AO_MF_IR_DEC_LDR_IDLE                              (0xc8100400 + (0x61 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_IDLE                              (0xda100400 + (0x61 << 2))
+#define   P_AO_MF_IR_DEC_LDR_IDLE                              (volatile uint32_t *)(0xc8100400 + (0x61 << 2))
+#define     AO_MF_IR_DEC_LDR_REPEAT                            (0xc8100400 + (0x62 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_REPEAT                            (0xda100400 + (0x62 << 2))
+#define   P_AO_MF_IR_DEC_LDR_REPEAT                            (volatile uint32_t *)(0xc8100400 + (0x62 << 2))
+#define     AO_MF_IR_DEC_BIT_0                                 (0xc8100400 + (0x63 << 2))
+#define SEC_AO_MF_IR_DEC_BIT_0                                 (0xda100400 + (0x63 << 2))
+#define   P_AO_MF_IR_DEC_BIT_0                                 (volatile uint32_t *)(0xc8100400 + (0x63 << 2))
+#define     AO_MF_IR_DEC_REG0                                  (0xc8100400 + (0x64 << 2))
+#define SEC_AO_MF_IR_DEC_REG0                                  (0xda100400 + (0x64 << 2))
+#define   P_AO_MF_IR_DEC_REG0                                  (volatile uint32_t *)(0xc8100400 + (0x64 << 2))
+#define     AO_MF_IR_DEC_FRAME                                 (0xc8100400 + (0x65 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME                                 (0xda100400 + (0x65 << 2))
+#define   P_AO_MF_IR_DEC_FRAME                                 (volatile uint32_t *)(0xc8100400 + (0x65 << 2))
+#define     AO_MF_IR_DEC_STATUS                                (0xc8100400 + (0x66 << 2))
+#define SEC_AO_MF_IR_DEC_STATUS                                (0xda100400 + (0x66 << 2))
+#define   P_AO_MF_IR_DEC_STATUS                                (volatile uint32_t *)(0xc8100400 + (0x66 << 2))
+#define     AO_MF_IR_DEC_REG1                                  (0xc8100400 + (0x67 << 2))
+#define SEC_AO_MF_IR_DEC_REG1                                  (0xda100400 + (0x67 << 2))
+#define   P_AO_MF_IR_DEC_REG1                                  (volatile uint32_t *)(0xc8100400 + (0x67 << 2))
+#define     AO_MF_IR_DEC_REG2                                  (0xc8100400 + (0x68 << 2))
+#define SEC_AO_MF_IR_DEC_REG2                                  (0xda100400 + (0x68 << 2))
+#define   P_AO_MF_IR_DEC_REG2                                  (volatile uint32_t *)(0xc8100400 + (0x68 << 2))
+#define     AO_MF_IR_DEC_DURATN2                               (0xc8100400 + (0x69 << 2))
+#define SEC_AO_MF_IR_DEC_DURATN2                               (0xda100400 + (0x69 << 2))
+#define   P_AO_MF_IR_DEC_DURATN2                               (volatile uint32_t *)(0xc8100400 + (0x69 << 2))
+#define     AO_MF_IR_DEC_DURATN3                               (0xc8100400 + (0x6a << 2))
+#define SEC_AO_MF_IR_DEC_DURATN3                               (0xda100400 + (0x6a << 2))
+#define   P_AO_MF_IR_DEC_DURATN3                               (volatile uint32_t *)(0xc8100400 + (0x6a << 2))
+#define     AO_MF_IR_DEC_FRAME1                                (0xc8100400 + (0x6b << 2))
+#define SEC_AO_MF_IR_DEC_FRAME1                                (0xda100400 + (0x6b << 2))
+#define   P_AO_MF_IR_DEC_FRAME1                                (volatile uint32_t *)(0xc8100400 + (0x6b << 2))
+#define     AO_MF_IR_DEC_STATUS1                               (0xc8100400 + (0x6c << 2))
+#define SEC_AO_MF_IR_DEC_STATUS1                               (0xda100400 + (0x6c << 2))
+#define   P_AO_MF_IR_DEC_STATUS1                               (volatile uint32_t *)(0xc8100400 + (0x6c << 2))
+#define     AO_MF_IR_DEC_STATUS2                               (0xc8100400 + (0x6d << 2))
+#define SEC_AO_MF_IR_DEC_STATUS2                               (0xda100400 + (0x6d << 2))
+#define   P_AO_MF_IR_DEC_STATUS2                               (volatile uint32_t *)(0xc8100400 + (0x6d << 2))
+#define     AO_MF_IR_DEC_REG3                                  (0xc8100400 + (0x6e << 2))
+#define SEC_AO_MF_IR_DEC_REG3                                  (0xda100400 + (0x6e << 2))
+#define   P_AO_MF_IR_DEC_REG3                                  (volatile uint32_t *)(0xc8100400 + (0x6e << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV0                            (0xc8100400 + (0x6f << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV0                            (0xda100400 + (0x6f << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV0                            (volatile uint32_t *)(0xc8100400 + (0x6f << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV1                            (0xc8100400 + (0x70 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV1                            (0xda100400 + (0x70 << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV1                            (volatile uint32_t *)(0xc8100400 + (0x70 << 2))
+#define     AO_MF_IR_DEC_FILTE                                 (0xc8100400 + (0x71 << 2))
+#define SEC_AO_MF_IR_DEC_FILTE                                 (0xda100400 + (0x71 << 2))
+#define   P_AO_MF_IR_DEC_FILTE                                 (volatile uint32_t *)(0xc8100400 + (0x71 << 2))
+#define     AO_MF_IR_DEC_IRQ_CTL                               (0xc8100400 + (0x72 << 2))
+#define SEC_AO_MF_IR_DEC_IRQ_CTL                               (0xda100400 + (0x72 << 2))
+#define   P_AO_MF_IR_DEC_IRQ_CTL                               (volatile uint32_t *)(0xc8100400 + (0x72 << 2))
+#define     AO_MF_IR_DEC_FIFO_CTL                              (0xc8100400 + (0x73 << 2))
+#define SEC_AO_MF_IR_DEC_FIFO_CTL                              (0xda100400 + (0x73 << 2))
+#define   P_AO_MF_IR_DEC_FIFO_CTL                              (volatile uint32_t *)(0xc8100400 + (0x73 << 2))
+#define     AO_MF_IR_DEC_WIDTH_NEW                             (0xc8100400 + (0x74 << 2))
+#define SEC_AO_MF_IR_DEC_WIDTH_NEW                             (0xda100400 + (0x74 << 2))
+#define   P_AO_MF_IR_DEC_WIDTH_NEW                             (volatile uint32_t *)(0xc8100400 + (0x74 << 2))
+#define     AO_MF_IR_DEC_REPEAT_DET                            (0xc8100400 + (0x75 << 2))
+#define SEC_AO_MF_IR_DEC_REPEAT_DET                            (0xda100400 + (0x75 << 2))
+#define   P_AO_MF_IR_DEC_REPEAT_DET                            (volatile uint32_t *)(0xc8100400 + (0x75 << 2))
+// ---------------------------
+// SAR ADC
+// ---------------------------
+#define     AO_SAR_ADC_REG0                                    (0xc8100400 + (0x80 << 2))
+#define SEC_AO_SAR_ADC_REG0                                    (0xda100400 + (0x80 << 2))
+#define   P_AO_SAR_ADC_REG0                                    (volatile uint32_t *)(0xc8100400 + (0x80 << 2))
+#define     AO_SAR_ADC_CHAN_LIST                               (0xc8100400 + (0x81 << 2))
+#define SEC_AO_SAR_ADC_CHAN_LIST                               (0xda100400 + (0x81 << 2))
+#define   P_AO_SAR_ADC_CHAN_LIST                               (volatile uint32_t *)(0xc8100400 + (0x81 << 2))
+#define     AO_SAR_ADC_AVG_CNTL                                (0xc8100400 + (0x82 << 2))
+#define SEC_AO_SAR_ADC_AVG_CNTL                                (0xda100400 + (0x82 << 2))
+#define   P_AO_SAR_ADC_AVG_CNTL                                (volatile uint32_t *)(0xc8100400 + (0x82 << 2))
+#define     AO_SAR_ADC_REG3                                    (0xc8100400 + (0x83 << 2))
+#define SEC_AO_SAR_ADC_REG3                                    (0xda100400 + (0x83 << 2))
+#define   P_AO_SAR_ADC_REG3                                    (volatile uint32_t *)(0xc8100400 + (0x83 << 2))
+#define     AO_SAR_ADC_DELAY                                   (0xc8100400 + (0x84 << 2))
+#define SEC_AO_SAR_ADC_DELAY                                   (0xda100400 + (0x84 << 2))
+#define   P_AO_SAR_ADC_DELAY                                   (volatile uint32_t *)(0xc8100400 + (0x84 << 2))
+#define     AO_SAR_ADC_LAST_RD                                 (0xc8100400 + (0x85 << 2))
+#define SEC_AO_SAR_ADC_LAST_RD                                 (0xda100400 + (0x85 << 2))
+#define   P_AO_SAR_ADC_LAST_RD                                 (volatile uint32_t *)(0xc8100400 + (0x85 << 2))
+#define     AO_SAR_ADC_FIFO_RD                                 (0xc8100400 + (0x86 << 2))
+#define SEC_AO_SAR_ADC_FIFO_RD                                 (0xda100400 + (0x86 << 2))
+#define   P_AO_SAR_ADC_FIFO_RD                                 (volatile uint32_t *)(0xc8100400 + (0x86 << 2))
+#define     AO_SAR_ADC_AUX_SW                                  (0xc8100400 + (0x87 << 2))
+#define SEC_AO_SAR_ADC_AUX_SW                                  (0xda100400 + (0x87 << 2))
+#define   P_AO_SAR_ADC_AUX_SW                                  (volatile uint32_t *)(0xc8100400 + (0x87 << 2))
+#define     AO_SAR_ADC_CHAN_10_SW                              (0xc8100400 + (0x88 << 2))
+#define SEC_AO_SAR_ADC_CHAN_10_SW                              (0xda100400 + (0x88 << 2))
+#define   P_AO_SAR_ADC_CHAN_10_SW                              (volatile uint32_t *)(0xc8100400 + (0x88 << 2))
+#define     AO_SAR_ADC_DETECT_IDLE_SW                          (0xc8100400 + (0x89 << 2))
+#define SEC_AO_SAR_ADC_DETECT_IDLE_SW                          (0xda100400 + (0x89 << 2))
+#define   P_AO_SAR_ADC_DETECT_IDLE_SW                          (volatile uint32_t *)(0xc8100400 + (0x89 << 2))
+#define     AO_SAR_ADC_DELTA_10                                (0xc8100400 + (0x8a << 2))
+#define SEC_AO_SAR_ADC_DELTA_10                                (0xda100400 + (0x8a << 2))
+#define   P_AO_SAR_ADC_DELTA_10                                (volatile uint32_t *)(0xc8100400 + (0x8a << 2))
+#define     AO_SAR_ADC_REG11                                   (0xc8100400 + (0x8b << 2))
+#define SEC_AO_SAR_ADC_REG11                                   (0xda100400 + (0x8b << 2))
+#define   P_AO_SAR_ADC_REG11                                   (volatile uint32_t *)(0xc8100400 + (0x8b << 2))
+#define     AO_SAR_ADC_REG12                                   (0xc8100400 + (0x8c << 2))
+#define SEC_AO_SAR_ADC_REG12                                   (0xda100400 + (0x8c << 2))
+#define   P_AO_SAR_ADC_REG12                                   (volatile uint32_t *)(0xc8100400 + (0x8c << 2))
+#define     AO_SAR_ADC_REG13                                   (0xc8100400 + (0x8d << 2))
+#define SEC_AO_SAR_ADC_REG13                                   (0xda100400 + (0x8d << 2))
+#define   P_AO_SAR_ADC_REG13                                   (volatile uint32_t *)(0xc8100400 + (0x8d << 2))
+// ---------------------------
+// RTC (4)
+// ---------------------------
+// Moved to the secure APB3 bus
+// `define AO_RTC_ADDR0                8'hd0
+// `define AO_RTC_ADDR1                8'hd1
+// `define AO_RTC_ADDR2                8'hd2
+// `define AO_RTC_ADDR3                8'hd3
+// `define AO_RTC_ADDR4                8'hd4
+//
+// Closing file:  ./ao_rti_reg.h
+//
+
+#endif // SECURE_APB_H
+
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/serial.c b/arch/arm/cpu/armv8/txl/firmware/bl21/serial.c
new file mode 100644
index 0000000..a2e8e98
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/serial.c
@@ -0,0 +1,121 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/bl21/serial.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "serial.h"
+#include "io.h"
+#include "secure_apb.h"
+
+void serial_set_pin_port(unsigned port_base)
+{
+    setbits_le32(AO_RTI_PIN_MUX_REG,3<<11);
+}
+
+#define UART_STP_BIT UART_CNTL_MASK_STP_1BIT
+#define UART_PRTY_BIT 0
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_8BIT
+
+void serial_init(unsigned set)
+{
+    /* baud rate */
+    writel(set| UART_STP_BIT
+	        | UART_PRTY_BIT
+	        | UART_CHAR_LEN
+	        //please do not remove these setting , jerry.yu
+	        | UART_CNTL_MASK_TX_EN
+	        | UART_CNTL_MASK_RX_EN
+	        | UART_CNTL_MASK_RST_TX
+	        | UART_CNTL_MASK_RST_RX
+	        | UART_CNTL_MASK_CLR_ERR
+	,P_UART_CONTROL(UART_PORT_CONS));
+    serial_set_pin_port(UART_PORT_CONS);
+    clrbits_le32(P_UART_CONTROL(UART_PORT_CONS),
+	    UART_CNTL_MASK_RST_TX | UART_CNTL_MASK_RST_RX | UART_CNTL_MASK_CLR_ERR);
+}
+
+int serial_putc(int c)
+{
+    if (c == '\n') {
+        while ((readl(P_UART_STATUS(UART_PORT_CONS)) & UART_STAT_MASK_TFIFO_FULL));
+        writel('\r', P_UART_WFIFO(UART_PORT_CONS));
+    }
+    /* Wait till dataTx register is not full */
+    while ((readl(P_UART_STATUS(UART_PORT_CONS)) & UART_STAT_MASK_TFIFO_FULL));
+    writel(c, P_UART_WFIFO(UART_PORT_CONS));
+    /* Wait till dataTx register is empty */
+    return c;
+}
+
+int serial_getc(void)
+{
+   unsigned char ch;
+    /* Wait till character is placed in fifo */
+	while ((readl(P_UART_STATUS(UART_PORT_CONS)) & UART_STAT_MASK_RFIFO_CNT) == 0) ;
+
+    /* Also check for overflow errors */
+    if (readl(P_UART_STATUS(UART_PORT_CONS)) & (UART_STAT_MASK_PRTY_ERR | UART_STAT_MASK_FRAM_ERR))
+	{
+	    setbits_le32(P_UART_CONTROL(UART_PORT_CONS),UART_CNTL_MASK_CLR_ERR);
+	    clrbits_le32(P_UART_CONTROL(UART_PORT_CONS),UART_CNTL_MASK_CLR_ERR);
+	}
+
+    ch = readl(P_UART_RFIFO(UART_PORT_CONS)) & 0x00ff;
+    return ((int)ch);
+}
+
+int serial_puts(const char *s){
+	while (*s) {
+		serial_putc(*s++);
+	}
+	return 0;
+}
+
+//support 64bit number, serial_put_hex(data, 64);
+void serial_put_hex(unsigned long data,unsigned int bitlen)
+{
+	int i;
+	for (i=bitlen-4;i>=0;i-=4) {
+        if ((data>>i) == 0)
+        {
+            serial_putc(0x30);
+            continue;
+        }
+        unsigned char s = (data>>i)&0xf;
+        if (s<10)
+            serial_putc(0x30+s);
+        else
+            serial_putc(0x61+s-10);
+    }
+}
+
+void serial_put_dec(unsigned long data)
+{
+	char szTxt[10];
+	szTxt[0] = 0x30;
+	int i = 0;
+
+	do {
+		szTxt[i++] = (data % 10) + 0x30;
+		data = data / 10;
+	} while(data);
+
+	for (--i;i >=0;--i)
+		serial_putc(szTxt[i]);
+}
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/serial.h b/arch/arm/cpu/armv8/txl/firmware/bl21/serial.h
new file mode 100644
index 0000000..9a66125
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/serial.h
@@ -0,0 +1,86 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/bl21/serial.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __SERIAL_H__
+#define __SERIAL_H__
+
+
+//#define P_AO_UART_WFIFO                 (0xc81004c0)
+//#define P_AO_RTI_PIN_MUX_REG	        (0xc8100014)
+#define UART_WFIFO      (0<<2)
+#define UART_RFIFO      (1<<2)
+#define UART_CONTROL    (2<<2)
+#define UART_STATUS     (3<<2)
+#define UART_MISC       (4<<2)
+#define UART_PORT_CONS AO_UART_WFIFO
+//#define UART_CLK_SRC CLK_CLK81
+
+#define P_UART(uart_base,reg)    	(uart_base+reg)
+#define P_UART_WFIFO(uart_base)   	P_UART(uart_base,UART_WFIFO)
+#define P_UART_RFIFO(uart_base)   	P_UART(uart_base,UART_RFIFO)
+
+#define P_UART_CONTROL(uart_base)    P_UART(uart_base,UART_CONTROL)
+    #define UART_CNTL_MASK_BAUD_RATE                (0xfff)
+    #define UART_CNTL_MASK_TX_EN                    (1<<12)
+    #define UART_CNTL_MASK_RX_EN                    (1<<13)
+    #define UART_CNTL_MASK_2WIRE                    (1<<15)
+    #define UART_CNTL_MASK_STP_BITS                 (3<<16)
+    #define UART_CNTL_MASK_STP_1BIT                 (0<<16)
+    #define UART_CNTL_MASK_STP_2BIT                 (1<<16)
+    #define UART_CNTL_MASK_PRTY_EVEN                (0<<18)
+    #define UART_CNTL_MASK_PRTY_ODD                 (1<<18)
+    #define UART_CNTL_MASK_PRTY_TYPE                (1<<18)
+    #define UART_CNTL_MASK_PRTY_EN                  (1<<19)
+    #define UART_CNTL_MASK_CHAR_LEN                 (3<<20)
+    #define UART_CNTL_MASK_CHAR_8BIT                (0<<20)
+    #define UART_CNTL_MASK_CHAR_7BIT                (1<<20)
+    #define UART_CNTL_MASK_CHAR_6BIT                (2<<20)
+    #define UART_CNTL_MASK_CHAR_5BIT                (3<<20)
+    #define UART_CNTL_MASK_RST_TX                   (1<<22)
+    #define UART_CNTL_MASK_RST_RX                   (1<<23)
+    #define UART_CNTL_MASK_CLR_ERR                  (1<<24)
+    #define UART_CNTL_MASK_INV_RX                   (1<<25)
+    #define UART_CNTL_MASK_INV_TX                   (1<<26)
+    #define UART_CNTL_MASK_RINT_EN                  (1<<27)
+    #define UART_CNTL_MASK_TINT_EN                  (1<<28)
+    #define UART_CNTL_MASK_INV_CTS                  (1<<29)
+    #define UART_CNTL_MASK_MASK_ERR                 (1<<30)
+    #define UART_CNTL_MASK_INV_RTS                  (1<<31)
+#define P_UART_STATUS(uart_base)  P_UART(uart_base,UART_STATUS )
+    #define UART_STAT_MASK_RFIFO_CNT                (0x3f<<0)
+    #define UART_STAT_MASK_TFIFO_CNT                (0x3f<<8)
+    #define UART_STAT_MASK_PRTY_ERR                 (1<<16)
+    #define UART_STAT_MASK_FRAM_ERR                 (1<<17)
+    #define UART_STAT_MASK_WFULL_ERR                (1<<18)
+    #define UART_STAT_MASK_RFIFO_FULL               (1<<19)
+    #define UART_STAT_MASK_RFIFO_EMPTY              (1<<20)
+    #define UART_STAT_MASK_TFIFO_FULL               (1<<21)
+    #define UART_STAT_MASK_TFIFO_EMPTY              (1<<22)
+#define P_UART_MISC(uart_base)    P_UART(uart_base,UART_MISC)
+
+void serial_init(unsigned set);
+int serial_putc(int c);
+int serial_getc(void);
+int serial_puts(const char *s);
+void serial_put_hex(unsigned long data,unsigned int bitlen);
+void serial_put_dec(unsigned long data);
+
+#endif /* __SERIAL_H__ */
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/timer.c b/arch/arm/cpu/armv8/txl/firmware/bl21/timer.c
new file mode 100644
index 0000000..88060e3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/timer.c
@@ -0,0 +1,41 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/bl21/timer.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "io.h"
+#include "timer.h"
+
+#define P_ISA_TIMERE                 (volatile unsigned int *)0xc1109988
+#define P_EE_TIMER_E		P_ISA_TIMERE
+
+unsigned int get_time(void)
+{
+	return readl(P_EE_TIMER_E);
+}
+
+void _udelay(unsigned int us)
+{
+#ifndef CONFIG_PXP_EMULATOR
+	unsigned int t0 = get_time();
+
+	while (get_time() - t0 <= us)
+		;
+#endif
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/bl21/timer.h b/arch/arm/cpu/armv8/txl/firmware/bl21/timer.h
new file mode 100644
index 0000000..36586ab
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/bl21/timer.h
@@ -0,0 +1,47 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/bl21/timer.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __TIMER_H
+#define __TIMER_H
+
+/**
+ * Get the current timestamp from the system timer.
+ */
+unsigned int get_time(void);
+
+/**
+ * Busy-wait.
+ *
+ * @param us            Number of microseconds to delay.
+ */
+void _udelay(unsigned int us);
+
+/**
+ * time counter
+ * usage:
+ *     timer_start();
+ *     func(); //func that you want measure time consumption
+ *     timer_end("func"); //will print "func Time: xxxx us"
+ */
+//void timer_start(void);
+//void timer_end(const char * name);
+
+#endif /* __TIMER_H */
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/Makefile b/arch/arm/cpu/armv8/txl/firmware/scp_task/Makefile
new file mode 100644
index 0000000..62df876
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/Makefile
@@ -0,0 +1,117 @@
+# ------------------------------------------------------------
+# Makefile for BL301 SCP User Task
+# ------------------------------------------------------------
+include $(buildsrc)/config.mk
+include $(buildtree)/include/autoconf.mk
+include $(buildtree)/.config
+
+# Select ARMv7-m bare-metal toolchain
+CROSS_COMPILE=arm-none-eabi-
+ASM=$(CROSS_COMPILE)as
+CC=$(CROSS_COMPILE)gcc
+CPP=$(CROSS_COMPILE)cpp
+LD=$(CROSS_COMPILE)ld
+OBJCOPY=$(CROSS_COMPILE)objcopy
+OBJDUMP=$(CROSS_COMPILE)objdump
+
+ARM_ARCH=armv7-m
+ARM_CPU=cortex-m3
+CFLAGS_WARN=-Wall -Werror -Wundef -Wstrict-prototypes -Wno-trigraphs      \
+            -fno-strict-aliasing -fno-common -fomit-frame-pointer         \
+            -Werror-implicit-function-declaration -Wno-format-security    \
+            -fno-delete-null-pointer-checks -Wdeclaration-after-statement \
+            -Wno-pointer-sign -fno-strict-overflow -fconserve-stack
+CFLAGS_DEBUG=-g
+
+# CPU specific compilation flags
+CFLAGS_CPU=-march=$(ARM_ARCH) -mcpu=$(ARM_CPU) -mthumb -Os -mno-sched-prolog
+
+# FPU compilation flags
+CFLAGS_FPU-$(CONFIG_FPU)=-mfpu=fpv4-sp-d16 -mfloat-abi=hard
+
+CFLAGS_INCLUDE=-I$(buildsrc)/build/include/ \
+               -I$(buildsrc)/include/ \
+               -I$(buildsrc)/arch/arm/include/ \
+               -I. \
+               -I./include \
+               -I./build
+
+#VPATH_LIST=     $(buildsrc)/board/$(BOARDDIR)
+VPATH_LIST=     $(buildsrc)/$(BOARDDIR)
+
+VPATH_LIST:=$(VPATH_LIST:%=%/firmware/scp_task/)
+
+CFLAGS=$(CFLAGS_CPU) $(CFLAGS_WARN) $(VPATH_LIST:%=-I%) $(CFLAGS_INCLUDE) $(CFLAGS_FPU-y)
+ASFLAGS= -gdwarf2 -mcpu=$(ARM_CPU)
+DUMP_FLAGS = -D -x
+
+LDFLAGS=-Bstatic
+#LDFLAGS+=$(LD_LIB_PATH_ARM:%=-L%) -lm -lc -lgcc
+
+# Output directory for build objects
+obj=$(buildtree)/scp_task
+
+vpath %.lds ./
+vpath %.S ./
+vpath %.c $(VPATH_LIST)
+vpath %.c ./
+
+#OBJS = user_task_entry.o
+OBJS = task_entry.o
+OBJS += user_task.o
+OBJS += misc.o
+OBJS += uart.o
+OBJS += suspend.o
+OBJS += dvfs.o
+OBJS += lib/string.o
+OBJS += lib/delay.o
+
+OBJS := $(OBJS:%=$(obj)/%)
+
+all : clean $(obj)/bl301.out $(obj)/bl301.bin
+
+$(obj)/bl301.bin: $(obj)/bl301.out
+	@echo "	OBJCOPY $@"
+	@$(OBJCOPY)  --gap-fill=0xff -O binary $< $@
+
+$(obj)/bl301.out: $(obj)/user_task.lds Makefile $(OBJS)
+	@echo "	LD $@"
+	@echo "	OBJDUMP $(obj)/bl301.dis"
+	@$(LD) $(OBJS) $(LDFLAGS) -T $(obj)/user_task.lds -Map $(obj)/bl301.map -o $@
+	@$(OBJDUMP) $(DUMP_FLAGS) $@ > $(obj)/bl301.dis
+
+$(obj)/%.o : %.c
+	@echo "	CC $(subst $(obj)/,,$@)"
+	@mkdir -p $(@D)
+	@$(CC) $(CFLAGS) -MD  -c $< -o $@
+
+$(obj)/misc.o:	$(obj)/misc.s
+	@echo "	CC $(subst $(obj)/,,$@)"
+	@mkdir -p $(@D)
+	@$(CC) $(CFLAGS) -MD  -c $< -o $@
+
+$(obj)/task_entry.o:	$(obj)/task_entry.s
+	@echo "	CC $(subst $(obj)/,,$@)"
+	@mkdir -p $(@D)
+	@$(CC) $(CFLAGS) -MD  -c $< -o $@
+
+$(obj)/misc.s:	misc.S
+	@mkdir -p $(@D)
+	@echo "	CPP $(subst $(obj)/,,$@)"
+	@$(CPP) -D__ASSEMBLY__ -E $< -o $@
+
+$(obj)/task_entry.s:  task_entry.S
+	@mkdir -p $(@D)
+	@echo "	CPP $(subst $(obj)/,,$@)"
+	@$(CPP) -D__ASSEMBLY__ -E $< -o $@
+
+$(obj)/user_task.lds : user_task.lds
+	@mkdir -p $(@D)
+	@echo "	CPP $(subst $(obj)/,,$@)"
+	@$(CPP) $(CFLAGS) -P $< $@
+
+clean:
+	@-rm -f $(OBJS)
+	@-rm -rf $(obj)/
+
+-include $(wildcard $(obj)/*.d)
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/aml_led.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/aml_led.c
new file mode 100644
index 0000000..e899729
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/aml_led.c
@@ -0,0 +1,162 @@
+/*
+ * uboot/aml_led.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+*/
+
+#include <amlogic/aml_led.h>
+
+#define LED_STA_IDLE 0
+#define LED_STA_FLASH_ON 1
+#define LED_STA_FLASH_OFF 2
+#define LED_STA_BREATH 3
+
+
+static int curve_approximate(struct coord *c, int num, int x)
+{
+	int x0, y0, x1, y1, y=-1;
+	int i;
+
+	for (i=1; i<num; i++) {
+		if (x < c[i].x) {
+			x0 = c[i-1].x;
+			y0 = c[i-1].y;
+			x1 = c[i].x;
+			y1 = c[i].y;
+			if (y1 == y0)
+				y = y0;
+			else
+				y = y0 + (y1-y0)*(x-x0)/(x1-x0);
+			break;
+		}
+	}
+	return y;
+}
+
+void aml_led_init(struct aml_led *led, struct aml_led_config *config)
+{
+	int i;
+
+	led->config = config;
+	for (i=0; i<LED_EVENT_BUF_SIZE; i++)
+		led->event[i] = LED_EVENT_NULL;
+	led->count = 0;
+	led->time = 0;
+	led->state = LED_STA_IDLE;
+}
+
+
+void aml_led_event(struct aml_led *led, int event, int event_data)
+{
+	int i;
+
+	for (i=0; i<LED_EVENT_BUF_SIZE; i++) {
+		if (led->event[i] == LED_EVENT_NULL) {
+			led->event[i] = event;
+			led->event_data[i] = event_data;
+			break;
+		}
+	}
+}
+
+static void aml_led_event_handle(struct aml_led *led)
+{
+	struct aml_led_config *config = led->config;
+	int event;
+	int i;
+
+	for (i=0; i<LED_EVENT_BUF_SIZE; i++) {
+		event = led->event[i];
+		if (event != LED_EVENT_NULL) {
+			led->event[i] = LED_EVENT_NULL;
+			switch (event) {
+				case LED_EVENT_ON:
+				led->brightness = config->on_brightness;
+				config->set_brightness(led->brightness);
+				led->state = LED_STA_IDLE;
+				break;
+
+				case LED_EVENT_OFF:
+				led->brightness = config->off_brightness;
+				config->set_brightness(led->brightness);
+				led->state = LED_STA_IDLE;
+				break;
+
+				case LED_EVENT_FLASH:
+				led->count = led->event_data[i];
+				if (led->event_data[i])
+					led->count++;
+				led->time = config->flash_off_time/LED_TIMER_INTERVAL;
+				led->brightness = config->flash_off_brightness;
+				config->set_brightness(led->brightness);
+				led->state = LED_STA_FLASH_OFF;
+				break;
+
+				case LED_EVENT_BREATH:
+				led->time = 0;
+				led->state = LED_STA_BREATH;
+				break;
+
+				default:
+				break;
+			}
+			break;
+		}
+	}
+}
+
+void aml_led_timer_proc(struct aml_led *led)
+{
+	struct aml_led_config *config = led->config;
+
+	switch (led->state) {
+		case LED_STA_IDLE:
+		aml_led_event_handle(led);
+		break;
+
+		case LED_STA_FLASH_ON:
+		if (--led->time == 0) {
+			led->time = config->flash_off_time/LED_TIMER_INTERVAL;
+			led->brightness = config->flash_off_brightness;
+			config->set_brightness(led->brightness);
+			led->state = LED_STA_FLASH_OFF;
+		}
+		break;
+
+		case LED_STA_FLASH_OFF:
+		if (--led->time == 0) {
+			if ((led->count == 0)
+			|| ((led->count>0) && (--led->count))) {
+				led->time = config->flash_on_time/LED_TIMER_INTERVAL;
+				led->brightness = config->flash_on_brightness;
+				config->set_brightness(led->brightness);
+				led->state = LED_STA_FLASH_ON;
+				if (led->count == 0)
+					aml_led_event_handle(led);
+			}
+			else {
+				led->state = LED_STA_IDLE;
+				aml_led_event_handle(led);
+			}
+		}
+		break;
+
+		case LED_STA_BREATH:
+		led->brightness = curve_approximate(
+			config->breath_inflections,
+			config->breath_inflections_num,
+			led->time);
+		if (led->brightness < 0)
+			led->time = 0;
+		else {
+			config->set_brightness(led->brightness);
+			led->time += LED_TIMER_INTERVAL;
+		}
+		aml_led_event_handle(led);
+		break;
+
+		default:
+		break;
+	}
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/cec_tx_reg.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/cec_tx_reg.h
new file mode 100644
index 0000000..bc35374
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/cec_tx_reg.h
@@ -0,0 +1,299 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/cec_tx_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _CEC_TX_REG_H
+#define _CEC_TX_REG_H
+
+#ifndef CONFIG_CEC_OSD_NAME
+#define CONFIG_CEC_OSD_NAME "Mbox"
+#endif
+
+typedef unsigned int uint32_t;
+
+#define IO_AOBUS_BASE		(0xC8100000)
+#define AOBUS_REG_ADDR(reg)	((IO_AOBUS_BASE << OFFSET) + reg)
+
+//#define AO_DEBUG_REG0 ((0x00 << 10) | (0x28 << 2))
+//#define P_AO_DEBUG_REG0     AOBUS_REG_ADDR(AO_DEBUG_REG0)
+//#define AO_DEBUG_REG1 ((0x00 << 10) | (0x29 << 2))
+//#define P_AO_DEBUG_REG1     AOBUS_REG_ADDR(AO_DEBUG_REG1)
+//#define AO_DEBUG_REG2 ((0x00 << 10) | (0x2a << 2))
+//#define P_AO_DEBUG_REG2     AOBUS_REG_ADDR(AO_DEBUG_REG2)
+//#define AO_DEBUG_REG3 ((0x00 << 10) | (0x2b << 2))
+//#define P_AO_DEBUG_REG3     AOBUS_REG_ADDR(AO_DEBUG_REG3)
+//#define AO_CEC_GEN_CNTL ((0x00 << 10) | (0x40 << 2))
+//#define P_AO_CEC_GEN_CNTL       AOBUS_REG_ADDR(AO_CEC_GEN_CNTL)
+//#define AO_CEC_RW_REG ((0x00 << 10) | (0x41 << 2))
+//#define P_AO_CEC_RW_REG     AOBUS_REG_ADDR(AO_CEC_RW_REG)
+//#define AO_CEC_INTR_MASKN ((0x00 << 10) | (0x42 << 2))
+//#define P_AO_CEC_INTR_MASKN     AOBUS_REG_ADDR(AO_CEC_INTR_MASKN)
+//#define AO_CEC_INTR_CLR ((0x00 << 10) | (0x43 << 2))
+//#define P_AO_CEC_INTR_CLR       AOBUS_REG_ADDR(AO_CEC_INTR_CLR)
+//#define AO_CEC_INTR_STAT ((0x00 << 10) | (0x44 << 2))
+//#define P_AO_CEC_INTR_STAT      AOBUS_REG_ADDR(AO_CEC_INTR_STAT)
+
+//#define P_AO_RTI_GEN_PWR_SLEEP0 (0xc8100000 + (0x3a << 2))
+
+//********** OTHER BASE related **********//
+#define HDMI_OTHER_CTRL0            0x0
+#define HDMI_OTHER_CTRL1            0x1
+#define HDMI_OTHER_STATUS0          0x2
+#define HDMI_OTHER_CTRL2            0x3
+#define HDMI_OTHER_INTR_MASKN       0x4
+#define HDMI_OTHER_INTR_STAT        0x5
+#define HDMI_OTHER_INTR_STAT_CLR    0x6
+
+
+//********** CEC related **********//
+//read/write
+#define CEC_TX_MSG_0_HEADER        0x00
+//#define CEC_TX_MSG_1_OPCODE        0x01
+//#define CEC_TX_MSG_2_OP1           0x02
+//#define CEC_TX_MSG_3_OP2           0x03
+//#define CEC_TX_MSG_4_OP3           0x04
+//#define CEC_TX_MSG_5_OP4           0x05
+//#define CEC_TX_MSG_6_OP5           0x06
+//#define CEC_TX_MSG_7_OP6           0x07
+//#define CEC_TX_MSG_8_OP7           0x08
+//#define CEC_TX_MSG_9_OP8           0x09
+//#define CEC_TX_MSG_A_OP9           0x0A
+//#define CEC_TX_MSG_B_OP10          0x0B
+//#define CEC_TX_MSG_C_OP11          0x0C
+//#define CEC_TX_MSG_D_OP12          0x0D
+//#define CEC_TX_MSG_E_OP13          0x0E
+//#define CEC_TX_MSG_F_OP14          0x0F
+
+//read only
+#define CEC_TX_MSG_LENGTH          0x10
+#define CEC_TX_MSG_CMD             0x11
+#define CEC_TX_WRITE_BUF           0x12
+#define CEC_TX_CLEAR_BUF           0x13
+#define CEC_RX_MSG_CMD             0x14
+#define CEC_RX_CLEAR_BUF           0x15
+#define CEC_LOGICAL_ADDR0          0x16
+//#define CEC_LOGICAL_ADDR1          0x17
+//#define CEC_LOGICAL_ADDR2          0x18
+//#define CEC_LOGICAL_ADDR3          0x19
+//#define CEC_LOGICAL_ADDR4          0x1A
+#define CEC_CLOCK_DIV_H            0x1B
+#define CEC_CLOCK_DIV_L            0x1C
+
+//read/write
+#define CEC_RX_MSG_0_HEADER        0x80
+//#define CEC_RX_MSG_1_OPCODE        0x81
+//#define CEC_RX_MSG_2_OP1           0x82
+//#define CEC_RX_MSG_3_OP2           0x83
+//#define CEC_RX_MSG_4_OP3           0x84
+//#define CEC_RX_MSG_5_OP4           0x85
+//#define CEC_RX_MSG_6_OP5           0x86
+//#define CEC_RX_MSG_7_OP6           0x87
+//#define CEC_RX_MSG_8_OP7           0x88
+//#define CEC_RX_MSG_9_OP8           0x89
+//#define CEC_RX_MSG_A_OP9           0x8A
+//#define CEC_RX_MSG_B_OP10          0x8B
+//#define CEC_RX_MSG_C_OP11          0x8C
+//#define CEC_RX_MSG_D_OP12          0x8D
+//#define CEC_RX_MSG_E_OP13          0x8E
+//#define CEC_RX_MSG_F_OP14          0x8F
+
+//read only
+#define CEC_RX_MSG_LENGTH          0x90
+#define CEC_RX_MSG_STATUS          0x91
+#define CEC_RX_NUM_MSG             0x92
+#define CEC_TX_MSG_STATUS          0x93
+#define CEC_TX_NUM_MSG             0x94
+
+// tx_msg_cmd definition
+#define TX_NO_OP                0  // No transaction
+#define TX_REQ_CURRENT          1  // Transmit earliest message in buffer
+#define TX_ABORT                2  // Abort transmitting earliest message
+#define TX_REQ_NEXT             3  // Overwrite earliest message in buffer and transmit next message
+
+// tx_msg_status definition
+#define TX_IDLE                 0  // No transaction
+#define TX_BUSY                 1  // Transmitter is busy
+#define TX_DONE                 2  // Message has been successfully transmitted
+#define TX_ERROR                3  // Message has been transmitted with error
+
+// rx_msg_cmd
+#define RX_NO_OP                0  // No transaction
+#define RX_ACK_CURRENT          1  // Read earliest message in buffer
+#define RX_DISABLE              2  // Disable receiving latest message
+#define RX_ACK_NEXT             3  // Clear earliest message from buffer and read next message
+
+// rx_msg_status
+#define RX_IDLE                 0  // No transaction
+#define RX_BUSY                 1  // Receiver is busy
+#define RX_DONE                 2  // Message has been received successfully
+#define RX_ERROR                3  // Message has been received with error
+
+
+/*
+ * CEC OPCODES
+ */
+#define	CEC_OC_ABORT_MESSAGE 					0xFF
+#define	CEC_OC_ACTIVE_SOURCE 					0x82
+#define	CEC_OC_CEC_VERSION 					0x9E
+#define	CEC_OC_CLEAR_ANALOGUE_TIMER 				0x33
+#define	CEC_OC_CLEAR_DIGITAL_TIMER 				0x99
+#define	CEC_OC_CLEAR_EXTERNAL_TIMER 				0xA1
+#define	CEC_OC_DECK_CONTROL 					0x42
+#define	CEC_OC_DECK_STATUS 					0x1B
+#define	CEC_OC_DEVICE_VENDOR_ID 				0x87
+#define	CEC_OC_FEATURE_ABORT 					0x00
+#define	CEC_OC_GET_CEC_VERSION 					0x9F
+#define	CEC_OC_GET_MENU_LANGUAGE 				0x91
+#define	CEC_OC_GIVE_AUDIO_STATUS 				0x71
+#define	CEC_OC_GIVE_DECK_STATUS 				0x1A
+#define	CEC_OC_GIVE_DEVICE_POWER_STATUS 			0x8F
+#define	CEC_OC_GIVE_DEVICE_VENDOR_ID 				0x8C
+#define	CEC_OC_GIVE_OSD_NAME 					0x46
+#define	CEC_OC_GIVE_PHYSICAL_ADDRESS 				0x83
+#define	CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS 			0x7D
+#define	CEC_OC_GIVE_TUNER_DEVICE_STATUS 			0x08
+#define	CEC_OC_IMAGE_VIEW_ON 					0x04
+#define	CEC_OC_INACTIVE_SOURCE 					0x9D
+#define	CEC_OC_MENU_REQUEST 					0x8D
+#define	CEC_OC_MENU_STATUS 					0x8E
+#define	CEC_OC_PLAY 						0x41
+#define	CEC_OC_POLLING_MESSAGE 					0xFC	/* Fake Code - <Poll Message> has no OP Code and requires only the header byte */
+#define	CEC_OC_RECORD_OFF 					0x0B
+#define	CEC_OC_RECORD_ON 					0x09
+#define	CEC_OC_RECORD_STATUS 					0x0A
+#define	CEC_OC_RECORD_TV_SCREEN 				0x0F
+#define	CEC_OC_REPORT_AUDIO_STATUS 				0x7A
+#define	CEC_OC_REPORT_PHYSICAL_ADDRESS 				0x84
+#define	CEC_OC_REPORT_POWER_STATUS 				0x90
+#define	CEC_OC_REQUEST_ACTIVE_SOURCE 				0x85
+#define	CEC_OC_ROUTING_CHANGE 					0x80
+#define	CEC_OC_ROUTING_INFORMATION 				0x81
+#define	CEC_OC_SELECT_ANALOGUE_SERVICE 				0x92
+#define	CEC_OC_SELECT_DIGITAL_SERVICE 				0x93
+#define	CEC_OC_SET_ANALOGUE_TIMER 				0x34
+#define	CEC_OC_SET_AUDIO_RATE 					0x9A
+#define	CEC_OC_SET_DIGITAL_TIMER 				0x97
+#define	CEC_OC_SET_EXTERNAL_TIMER 				0xA2
+#define	CEC_OC_SET_MENU_LANGUAGE 				0x32
+#define	CEC_OC_SET_OSD_NAME 					0x47
+#define	CEC_OC_SET_OSD_STRING 					0x64
+#define	CEC_OC_SET_STREAM_PATH 					0x86
+#define	CEC_OC_SET_SYSTEM_AUDIO_MODE 				0x72
+#define	CEC_OC_SET_TIMER_PROGRAM_TITLE 				0x67
+#define	CEC_OC_STANDBY 						0x36
+#define	CEC_OC_SYSTEM_AUDIO_MODE_REQUEST 			0x70
+#define	CEC_OC_SYSTEM_AUDIO_MODE_STATUS 			0x7E
+#define	CEC_OC_TEXT_VIEW_ON 					0x0D
+#define	CEC_OC_TIMER_CLEARED_STATUS 				0x43
+#define	CEC_OC_TIMER_STATUS 					0x35
+#define	CEC_OC_TUNER_DEVICE_STATUS 				0x07
+#define	CEC_OC_TUNER_STEP_DECREMENT 				0x06
+#define	CEC_OC_TUNER_STEP_INCREMENT 				0x05
+#define	CEC_OC_USER_CONTROL_PRESSED 				0x44
+#define	CEC_OC_USER_CONTROL_RELEASED 				0x45
+#define	CEC_OC_VENDOR_COMMAND 					0x89
+#define	CEC_OC_VENDOR_COMMAND_WITH_ID 				0xA0
+#define	CEC_OC_VENDOR_REMOTE_BUTTON_DOWN 			0x8A
+#define	CEC_OC_VENDOR_REMOTE_BUTTON_UP 				0x8B
+
+/*CEC UI MASK*/
+#define CEC_FUNC_MASK                        0
+#define ONE_TOUCH_PLAY_MASK                  1
+#define ONE_TOUCH_STANDBY_MASK               2
+#define AUTO_POWER_ON_MASK                   3
+
+//#define P_HHI_GCLK_MPEG2 CBUS_REG_ADDR(HHI_GCLK_MPEG2)
+//#define P_HHI_HDMI_CLK_CNTL CBUS_REG_ADDR(HHI_HDMI_CLK_CNTL)
+#define MAX_MSG 16
+#define CEC_PLAYBACK_DEVICE_TYPE 4
+#define CEC_BROADCAST_ADDR 0xf
+#define CEC_VERSION_14A 5
+
+enum _cec_log_dev_addr_e {
+    CEC_TV_ADDR = 0x00,
+    CEC_RECORDING_DEVICE_1_ADDR,
+    CEC_RECORDING_DEVICE_2_ADDR,
+    CEC_TUNER_1_ADDR,
+    CEC_PLAYBACK_DEVICE_1_ADDR,
+    CEC_AUDIO_SYSTEM_ADDR,
+    CEC_TUNER_2_ADDR,
+    CEC_TUNER_3_ADDR,
+    CEC_PLAYBACK_DEVICE_2_ADDR,
+    CEC_RECORDING_DEVICE_3_ADDR,
+    CEC_TUNER_4_ADDR,
+    CEC_PLAYBACK_DEVICE_3_ADDR,
+    CEC_RESERVED_1_ADDR,
+    CEC_RESERVED_2_ADDR,
+    CEC_FREE_USE_ADDR,
+    CEC_UNREGISTERED_ADDR
+};
+
+typedef enum  {
+    CEC_UNRECONIZED_OPCODE = 0x0,
+    CEC_NOT_CORRECT_MODE_TO_RESPOND,
+    CEC_CANNOT_PROVIDE_SOURCE,
+    CEC_INVALID_OPERAND,
+    CEC_REFUSED,
+    CEC_UNABLE_TO_DETERMINE,
+} cec_feature_abort_e;
+
+typedef enum {
+    DEVICE_MENU_ACTIVE = 0,
+    DEVICE_MENU_INACTIVE,
+} cec_device_menu_state_e;
+
+/* cec message structure */
+typedef struct {
+    unsigned char msg[16];
+    unsigned char msg_len;
+} cec_msg_buf_t;
+
+typedef struct {
+    cec_msg_buf_t buf[2];          // message memory
+    unsigned char power_status;
+    unsigned char log_addr;
+    unsigned char cec_power;
+    unsigned char rx_write_pos;
+    unsigned char rx_read_pos;
+    unsigned char rx_buf_size;
+} cec_msg_t;
+
+cec_msg_t cec_msg;
+unsigned char hdmi_cec_func_config;
+void cec_node_init(void);
+unsigned int cec_handler(void);
+void remote_cec_hw_reset(void);
+//void cec_give_device_power_status(void);
+extern void udelay(int i);
+
+// The following registers are for fine tuning CEC bit timing parameters.
+// They are only valid in AO CEC, NOT valid in HDMITX CEC.
+// The AO CEC's timing parameters are already set default to work with 32768Hz clock, so hopefully
+// SW never need to program these registers. The timing registers are made programmable just in case.
+
+#define AO_CEC_TXTIME_17MS_BIT7_0               0x40
+#define AO_CEC_TXTIME_17MS_BIT10_8              0x41
+#define AO_CEC_TXTIME_2BIT_BIT7_0               0x42
+#define AO_CEC_TXTIME_2BIT_BIT10_8              0x43
+#define AO_CEC_TXTIME_4BIT_BIT7_0               0x44
+#define AO_CEC_TXTIME_4BIT_BIT10_8              0x45
+
+#endif  // _HDMI_RX_REG_H
+
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/config.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/config.h
new file mode 100644
index 0000000..62bd986
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/config.h
@@ -0,0 +1,62 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/config.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+#define CONFIG_RAM_BASE        (0x10000000 + 41 * 1024)
+#define CONFIG_RAM_SIZE         (12 * 1024)
+#define CONFIG_RAM_END		(CONFIG_RAM_BASE+CONFIG_RAM_SIZE)
+
+#define CONFIG_TASK_STACK_SIZE	512
+#define TASK_SHARE_MEM_SIZE	1024
+
+/* secure share memory last unsigned are used
+	* for wakeup communication between BL30/BL301
+	* 0x1000D5FC: store irq number
+	* 0x1000D7FC: control wakeup enable
+	* after BL301 enable wakeup, bl30 store irq no. in share memory
+*/
+#define WAKEUP_SRC_IRQ_ADDR_BASE		(CONFIG_RAM_END - 128)
+#define SECURE_TASK_SHARE_MEM_BASE		0x1000D400
+#define SECURE_TASK_RESPONSE_MEM_BASE 0x1000D600
+#define SECURE_TASK_RESPONSE_WAKEUP_EN	0x1000D7FC
+#define HIGH_TASK_SHARE_MEM_BASE			0x1000D800
+#define HIGH_TASK_RESPONSE_MEM_BASE		0x1000DA00
+#define LOW_TASK_SHARE_MEM_BASE			0x1000DC00
+#define LOW_TASK_RESPONSE_MEM_BASE		0x1000DE00
+/*
+  * BL30/BL301 share memory command list
+*/
+#define COMMAND_SUSPEND_ENTER			0x1
+#define HIGH_TASK_SET_CLOCK	0x2
+#define LOW_TASK_GET_DVFS_INFO 0x3
+#define HIGH_TASK_GET_DVFS 0x4
+#define HIGH_TASK_SET_DVFS 0x5
+#define SEC_TASK_GET_WAKEUP_SRC	0x6
+
+#define LOW_TASK_USR_DATA  0x100
+
+	/*bl301 resume to BL30*/
+#define RESPONSE_OK					0x0
+#define RESPONSE_SUSPEND_LEAVE			0x1
+
+#endif//_CONFIG_H_
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/data.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/data.h
new file mode 100644
index 0000000..5c67a97
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/data.h
@@ -0,0 +1,36 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/data.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "config.h"
+
+#define TASK_COMMAND_OFFSET 0
+#define TASK_RESPONSE_OFFSET  0x200
+
+unsigned char
+	*secure_task_share_mem = (unsigned char *)SECURE_TASK_SHARE_MEM_BASE;
+unsigned char *high_task_share_mem = (unsigned char *)HIGH_TASK_SHARE_MEM_BASE;
+unsigned char *low_task_share_mem = (unsigned char *)LOW_TASK_SHARE_MEM_BASE;
+
+struct resume_param {
+/* wakeup method: remote, ..., */
+	unsigned int method;
+};
+struct resume_param resume_data;
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/dvfs.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/dvfs.c
new file mode 100644
index 0000000..40349d9
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/dvfs.c
@@ -0,0 +1,34 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/dvfs.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "config.h"
+#include "registers.h"
+#include "task_apis.h"
+
+#include "dvfs.h"
+#include <dvfs_board.c>
+
+void get_dvfs_info(unsigned int domain,
+		unsigned char *info_out, unsigned int *size_out)
+{
+	get_dvfs_info_board(domain, info_out, size_out);
+	return;
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/dvfs.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/dvfs.h
new file mode 100644
index 0000000..45d22d9
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/dvfs.h
@@ -0,0 +1,47 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/dvfs.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __SCP_DVFS_H__
+#define __SCP_DVFS_H__
+
+struct scpi_opp_entry {
+	unsigned int freq_hz;
+	unsigned int volt_mv;
+};
+#define DVFS(_freq, _volt) \
+{ \
+	.freq_hz = _freq, \
+	.volt_mv = _volt, \
+}
+
+#define SCPI_SUCCESS 0
+#define MAX_DVFS_OPPS		16
+#define DVFS_LATENCY(hdr)	((hdr) << 16)
+#define DVFS_OPP_COUNT(hdr)	((hdr) << 8)
+struct scpi_opp {
+	unsigned int latency; /* in usecs */
+	int count;
+	struct scpi_opp_entry opp[MAX_DVFS_OPPS];
+} buf_opp;
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+#endif
+
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/gpio-gxbb.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/gpio-gxbb.h
new file mode 100644
index 0000000..4222652
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/gpio-gxbb.h
@@ -0,0 +1,150 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/gpio-gxbb.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ARCH_GXBB_GPIO_H__
+#define __ARCH_GXBB_GPIO_H__
+/*AO Bank*/
+#define	GPIOAO_0    0
+#define	GPIOAO_1    1
+#define	GPIOAO_2    2
+#define	GPIOAO_3    3
+#define	GPIOAO_4    4
+#define	GPIOAO_5    5
+#define	GPIOAO_6    6
+#define	GPIOAO_7    7
+#define	GPIOAO_8    8
+#define	GPIOAO_9    9
+
+/*EE Bank*/
+#define	GPIOZ_0    0
+#define	GPIOZ_1    1
+#define	GPIOZ_2    2
+#define	GPIOZ_3    3
+#define	GPIOZ_4    4
+#define	GPIOZ_5    5
+#define	GPIOZ_6    6
+#define	GPIOZ_7    7
+#define	GPIOZ_8    8
+#define	GPIOZ_9    9
+#define	GPIOZ_10    10
+#define	GPIOZ_11    11
+#define	GPIOZ_12    12
+#define	GPIOZ_13    13
+#define	GPIOZ_14    14
+#define	GPIOZ_15    15
+
+#define	GPIOH_0    16
+#define	GPIOH_1    17
+#define	GPIOH_2    18
+#define	GPIOH_3    19
+#define	GPIOH_4    20
+#define	GPIOH_5    21
+#define	GPIOH_6    22
+#define	GPIOH_7    23
+#define	GPIOH_8    24
+#define	GPIOH_9    25
+
+#define	BOOT_0    26
+#define	BOOT_1    27
+#define	BOOT_2    28
+#define	BOOT_3    29
+#define	BOOT_4    30
+#define	BOOT_5    31
+#define	BOOT_6    32
+#define	BOOT_7    33
+#define	BOOT_8    34
+#define	BOOT_9    35
+#define	BOOT_10    36
+#define	BOOT_11    37
+#define	BOOT_12    38
+#define	BOOT_13    39
+#define	BOOT_14    40
+#define	BOOT_15    41
+
+#define	CARD_0    42
+#define	CARD_1    43
+#define	CARD_2    44
+#define	CARD_3    45
+#define	CARD_4    46
+#define	CARD_5    47
+#define	CARD_6    48
+
+#define	GPIODV_0    49
+#define	GPIODV_1    50
+#define	GPIODV_2    51
+#define	GPIODV_3    52
+#define	GPIODV_4    53
+#define	GPIODV_5    54
+#define	GPIODV_6    55
+#define	GPIODV_7    56
+#define	GPIODV_8    57
+#define	GPIODV_9    58
+#define	GPIODV_10    59
+#define	GPIODV_11    60
+#define	GPIODV_12    61
+#define	GPIODV_13    62
+#define	GPIODV_14    63
+#define	GPIODV_15    64
+#define	GPIODV_16    65
+#define	GPIODV_17    66
+#define	GPIODV_18    67
+#define	GPIODV_19    68
+#define	GPIODV_20    69
+#define	GPIODV_21    70
+#define	GPIODV_22    71
+#define	GPIODV_23    72
+#define	GPIODV_24    73
+#define	GPIODV_25    74
+#define	GPIODV_26    75
+#define	GPIODV_27    76
+#define	GPIODV_28    77
+#define	GPIODV_29    78
+
+#define	GPIOX_0    79
+#define	GPIOX_1    80
+#define	GPIOX_2    81
+#define	GPIOX_3    82
+#define	GPIOX_4    83
+#define	GPIOX_5    84
+#define	GPIOX_6    85
+#define	GPIOX_7    86
+#define	GPIOX_8    87
+#define	GPIOX_9    88
+#define	GPIOX_10    89
+#define	GPIOX_11    90
+#define	GPIOX_12    91
+#define	GPIOX_13    92
+#define	GPIOX_14    93
+#define	GPIOX_15    94
+#define	GPIOX_16    95
+#define	GPIOX_17    96
+#define	GPIOX_18    97
+
+#define	GPIOCLK_0    98
+#define	GPIOCLK_1    99
+
+#define	GPIO_TEST_N    100
+
+
+/*AO REG */
+#define AO 0x10
+#define AO2 0x11
+#endif
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/hdmi_cec_arc.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/hdmi_cec_arc.c
new file mode 100644
index 0000000..878bd20
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/hdmi_cec_arc.c
@@ -0,0 +1,828 @@
+/**************************************************
+ *           HDMI CEC uboot code                  *
+ *                                                *
+ **************************************************/
+#ifdef CONFIG_CEC_WAKEUP
+#include "secure_apb.h"
+#include "cec_tx_reg.h"
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+#define CEC_DBG_PRINT
+#ifdef CEC_DBG_PRINT
+static void cec_dbg_print(char *s, int v)
+{
+	uart_puts(s);
+	uart_put_hex(v,8);
+	_udelay(100);
+}
+static void cec_dbg_prints(char *s)
+{
+	uart_puts(s);
+	_udelay(100);
+}
+#else
+	#define cec_dbg_print(s,v)
+	#define cec_dbg_prints(s)
+#endif
+
+static void cec_reset_addr(void);
+struct cec_tx_msg_t {
+	unsigned char buf[16];
+	unsigned char retry;
+	unsigned char len;
+};
+
+#define CEX_TX_MSG_BUF_NUM	  4
+#define CEC_TX_MSG_BUF_MASK	 (CEX_TX_MSG_BUF_NUM - 1)
+
+struct cec_tx_msg {
+	struct cec_tx_msg_t msg[CEX_TX_MSG_BUF_NUM];
+	unsigned char send_idx;
+	unsigned char queue_idx;
+};
+
+struct cec_tx_msg cec_tx_msgs = {};
+
+
+static int cec_strlen(char *p)
+{
+	int i=0;
+
+	while (*p++)
+		i++;
+	return i;
+}
+
+static void *cec_memcpy(void *memto, const void *memfrom, unsigned int size)
+{
+	char *tempfrom = (char *)memfrom;
+	char *tempto = (char *)memto;
+
+	if ((memto == NULL) || (memfrom == NULL))
+		return NULL;
+	while (size -- > 0)
+		*tempto++ = *tempfrom++;
+	return memto;
+}
+
+static void waiting_aocec_free(void) {
+	do {
+		unsigned long cnt = 0;
+		while (readl(P_AO_CEC_RW_REG) & (1<<23))
+		{
+			if (5000 == cnt++)
+			{
+				break;
+			}
+		}
+	} while(0);
+}
+
+static unsigned long cec_rd_reg(unsigned long addr)
+{
+	unsigned long data32;
+	waiting_aocec_free();
+	data32  = 0;
+	data32 |= 0    << 16;  // [16]   cec_reg_wr
+	data32 |= 0    << 8;   // [15:8] cec_reg_wrdata
+	data32 |= addr << 0;   // [7:0]  cec_reg_addr
+	writel(data32, P_AO_CEC_RW_REG);
+	waiting_aocec_free();
+	data32 = ((readl(P_AO_CEC_RW_REG)) >> 24) & 0xff;
+	return (data32);
+} /* cec_rd_reg */
+
+static void cec_wr_reg (unsigned long addr, unsigned long data)
+{
+	unsigned long data32;
+	waiting_aocec_free();
+	data32  = 0;
+	data32 |= 1    << 16;  // [16]   cec_reg_wr
+	data32 |= data << 8;   // [15:8] cec_reg_wrdata
+	data32 |= addr << 0;   // [7:0]  cec_reg_addr
+	writel(data32, P_AO_CEC_RW_REG);
+} /* aocec_wr_only_reg */
+
+static void cec_rx_read_pos_plus(void)
+{
+	(cec_msg.rx_read_pos ==  cec_msg.rx_buf_size - 1) ?
+				(cec_msg.rx_read_pos = 0) :
+				(cec_msg.rx_read_pos++);
+}
+
+static void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set)
+{
+	//11bit:bit[10:0]
+	switch (bit_set) {
+	case 3:
+		//3 bit
+		cec_wr_reg(AO_CEC_TXTIME_4BIT_BIT7_0, time_set & 0xff);
+		cec_wr_reg(AO_CEC_TXTIME_4BIT_BIT10_8, (time_set >> 8) & 0x7);
+		break;
+		//5 bit
+	case 5:
+		cec_wr_reg(AO_CEC_TXTIME_2BIT_BIT7_0, time_set & 0xff);
+		cec_wr_reg(AO_CEC_TXTIME_2BIT_BIT10_8, (time_set >> 8) & 0x7);
+		//7 bit
+	case 7:
+		cec_wr_reg(AO_CEC_TXTIME_17MS_BIT7_0, time_set & 0xff);
+		cec_wr_reg(AO_CEC_TXTIME_17MS_BIT10_8, (time_set >> 8) & 0x7);
+		break;
+	default:
+		break;
+	}
+}
+
+static void cec_hw_buf_clear(void)
+{
+	cec_wr_reg(CEC_RX_MSG_CMD, RX_DISABLE);
+	cec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+	cec_wr_reg(CEC_RX_CLEAR_BUF, 1);
+	cec_wr_reg(CEC_TX_CLEAR_BUF, 1);
+	_udelay(100);
+	cec_wr_reg(CEC_RX_CLEAR_BUF, 0);
+	cec_wr_reg(CEC_TX_CLEAR_BUF, 0);
+	_udelay(100);
+	cec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+	cec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+}
+
+void remote_cec_hw_reset(void)
+{
+	unsigned int reg;
+	cec_dbg_prints("cec reset\n");
+
+	reg = readl(P_AO_CRT_CLK_CNTL1);
+	/* 24MHz/ (731 + 1) = 32786.885Hz */
+	reg &= ~(0x7ff << 16);
+	reg |= (731 << 16);     /* divider from 24MHz */
+	reg |= (0x1 << 26);
+	reg &= ~(0x800 << 16);  /* select divider */
+	writel(reg, P_AO_CRT_CLK_CNTL1);
+
+	/* set up pinmux */
+	writel(readl(P_AO_RTI_PIN_MUX_REG) & (~(1 << 14 | 1 << 17)), P_AO_RTI_PIN_MUX_REG);
+	writel(readl(P_AO_RTI_PULL_UP_REG) & (~(1 << 9)), P_AO_RTI_PULL_UP_REG);
+	writel(readl(P_AO_RTI_PIN_MUX_REG) | (1 << 15), P_AO_RTI_PIN_MUX_REG);
+	// Assert SW reset AO_CEC
+	writel(0x1, P_AO_CEC_GEN_CNTL);
+	// Enable gated clock (Normal mode).
+	writel(readl(P_AO_CEC_GEN_CNTL) | (1<<1), P_AO_CEC_GEN_CNTL);
+	_udelay(100);
+	// Release SW reset
+	writel(readl(P_AO_CEC_GEN_CNTL) & ~(1<<0), P_AO_CEC_GEN_CNTL);
+	writel(readl(P_AO_CEC_INTR_MASKN) | (0x03 << 1), P_AO_CEC_INTR_MASKN);
+
+	cec_arbit_bit_time_set(3, 0x118);
+	cec_arbit_bit_time_set(5, 0x000);
+	cec_arbit_bit_time_set(7, 0x2aa);
+}
+
+static unsigned char remote_cec_ll_rx(void)
+{
+	int i;
+	int print = 1;
+	unsigned char rx_msg_length = cec_rd_reg(CEC_RX_MSG_LENGTH) + 1;
+
+	cec_dbg_prints("cec R:");
+	for (i = 0; i < rx_msg_length; i++) {
+		cec_msg.buf[cec_msg.rx_write_pos].msg[i] = cec_rd_reg(CEC_RX_MSG_0_HEADER + i);
+		if (print) {
+			cec_dbg_print(" ", cec_msg.buf[cec_msg.rx_write_pos].msg[i]);
+		}
+		if (i == 1 && cec_msg.buf[cec_msg.rx_write_pos].msg[i] == CEC_OC_VENDOR_COMMAND_WITH_ID) {
+			/* do not print command with ID */
+			print = 0;
+		}
+	}
+	cec_msg.buf[cec_msg.rx_write_pos].msg_len = rx_msg_length;
+	cec_dbg_prints("\n");
+
+	return 0;
+}
+static void cec_buf_clear(void)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		cec_msg.buf[cec_msg.rx_read_pos].msg[i] = 0;
+}
+
+static void cec_tx_buf_init(void)
+{
+	int i, j;
+	for (j = 0; j < CEX_TX_MSG_BUF_NUM; j++) {
+		for (i = 0; i < 16; i++) {
+			cec_tx_msgs.msg[j].buf[i] = 0;
+		}
+		cec_tx_msgs.msg[j].retry = 0;
+		cec_tx_msgs.msg[j].len = 0;
+	}
+}
+
+static int cec_queue_tx_msg(unsigned char *msg, unsigned char len)
+{
+	int s_idx, q_idx;
+
+	s_idx = cec_tx_msgs.send_idx;
+	q_idx = cec_tx_msgs.queue_idx;
+	if (((q_idx + 1) & CEC_TX_MSG_BUF_MASK) == s_idx) {
+		cec_dbg_prints("tx buffer full, abort msg\n");
+		cec_reset_addr();
+		return -1;
+	}
+	if (len && msg) {
+		cec_memcpy(cec_tx_msgs.msg[q_idx].buf, msg, len);
+		cec_tx_msgs.msg[q_idx].len = len;
+		cec_tx_msgs.queue_idx = (q_idx + 1) & CEC_TX_MSG_BUF_MASK;
+	}
+	return 0;
+}
+
+static int cec_triggle_tx(unsigned char *msg, unsigned char len)
+{
+	int i;
+
+	if ((TX_IDLE == cec_rd_reg(CEC_TX_MSG_STATUS)) ||
+	    (TX_DONE == cec_rd_reg(CEC_TX_MSG_STATUS))) {
+		cec_dbg_prints("cec T:");
+		for (i = 0; i < len; i++) {
+			cec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+			cec_dbg_print(" ", msg[i]);
+		}
+		cec_dbg_prints("\n");
+		cec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+		cec_wr_reg(CEC_TX_MSG_CMD, TX_REQ_CURRENT); //TX_REQ_NEXT
+		return 0;
+	}
+	return -1;
+}
+
+static int remote_cec_ll_tx(unsigned char *msg, unsigned char len)
+{
+	cec_queue_tx_msg(msg, len);
+	cec_triggle_tx(msg, len);
+
+	return 0;
+}
+
+static int ping_cec_ll_tx(unsigned char *msg, unsigned char len)
+{
+	int i;
+	int ret = 0;
+	unsigned int n = 900;
+	unsigned int reg;
+
+	ret = cec_rd_reg(CEC_RX_MSG_STATUS);
+	cec_dbg_print("rx stat:", ret);
+	ret = cec_rd_reg(CEC_TX_MSG_STATUS);
+	cec_dbg_print(", tx stat:", ret);
+	cec_dbg_prints("\n");
+
+	while (cec_rd_reg(CEC_TX_MSG_STATUS) == TX_BUSY) {
+		/*
+		 * waiting tx to idle if it is busy, other device may in tx state
+		 */
+	}
+	if (cec_rd_reg(CEC_TX_MSG_STATUS) == TX_ERROR)
+		cec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+
+	for (i = 0; i < len; i++) {
+		cec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+	}
+	cec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+	cec_wr_reg(CEC_TX_MSG_CMD, TX_REQ_CURRENT); //TX_REQ_NEXT
+	ret = cec_rd_reg(CEC_RX_MSG_STATUS);
+	cec_dbg_print("rx stat:", ret);
+	ret = cec_rd_reg(CEC_TX_MSG_STATUS);
+	cec_dbg_print(", tx stat:", ret);
+	cec_dbg_prints("\n");
+
+	while (1) {
+		reg = cec_rd_reg(CEC_TX_MSG_STATUS);
+		if ( reg == TX_DONE ) {
+			ret = TX_DONE;
+			cec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+			cec_dbg_prints("ping_cec_ll_tx:TX_DONE\n");
+			break;
+		}
+
+		if (reg == TX_ERROR) {
+			ret = TX_ERROR;
+			cec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+			cec_dbg_prints("ping_cec_ll_tx:TX_ERROR\n");
+			break;
+		}
+		if (!(n--)) {
+			cec_dbg_prints("ping_cec_ll_tx:TX_BUSY\n");
+			ret = TX_BUSY;
+			cec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+			break;
+		}
+		if (reg != TX_BUSY) {
+			break;
+		}
+		_udelay(500);
+	}
+
+	return ret;
+}
+
+#define DEVICE_TV		0
+#define DEVICE_RECORDER		1
+#define DEVICE_RESERVED		2
+#define DEVICE_TUNER		3
+#define DEVICE_PLAYBACK		4
+#define DEVICE_AUDIO_SYSTEM	5
+#define DEVICE_PURE_CEC_SWITCH	6
+#define DEVICE_VIDEO_PROCESSOR	7
+
+static unsigned char log_addr_to_devtye(unsigned int addr)
+{
+	static unsigned char addr_map[] = {
+		DEVICE_TV,
+		DEVICE_RECORDER,
+		DEVICE_RECORDER,
+		DEVICE_TUNER,
+		DEVICE_PLAYBACK,
+		DEVICE_AUDIO_SYSTEM,
+		DEVICE_TUNER,
+		DEVICE_TUNER,
+		DEVICE_PLAYBACK,
+		DEVICE_RECORDER,
+		DEVICE_TUNER,
+		DEVICE_PLAYBACK,
+		DEVICE_RESERVED,
+		DEVICE_RESERVED,
+		DEVICE_TV
+	};
+	return addr_map[addr & 0xf];
+}
+
+static void cec_report_physical_address(void)
+{
+	unsigned char msg[5];
+	unsigned char phy_addr_ab = (readl(P_AO_DEBUG_REG1) >> 8) & 0xff;
+	unsigned char phy_addr_cd = readl(P_AO_DEBUG_REG1) & 0xff;
+
+	msg[0] = ((cec_msg.log_addr & 0xf) << 4)| CEC_BROADCAST_ADDR;
+	msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
+	msg[2] = phy_addr_ab;
+	msg[3] = phy_addr_cd;
+	msg[4] = log_addr_to_devtye(cec_msg.log_addr);
+
+	remote_cec_ll_tx(msg, 5);
+}
+
+static void cec_report_device_power_status(int dst)
+{
+	unsigned char msg[3];
+
+	msg[0] = ((cec_msg.log_addr & 0xf) << 4)| (dst & 0xf);
+	msg[1] = CEC_OC_REPORT_POWER_STATUS;
+	msg[2] = cec_msg.power_status;
+
+	remote_cec_ll_tx(msg, 3);
+}
+
+static void cec_set_stream_path(void)
+{
+	unsigned char phy_addr_ab = (readl(P_AO_DEBUG_REG1) >> 8) & 0xff;
+	unsigned char phy_addr_cd = readl(P_AO_DEBUG_REG1) & 0xff;
+
+	if ((hdmi_cec_func_config >> CEC_FUNC_MASK) & 0x1) {
+		if ((hdmi_cec_func_config >> AUTO_POWER_ON_MASK) & 0x1) {
+			if ((phy_addr_ab == cec_msg.buf[cec_msg.rx_read_pos].msg[2]) &&
+			    (phy_addr_cd == cec_msg.buf[cec_msg.rx_read_pos].msg[3]))  {
+				cec_msg.cec_power = 0x1;
+			}
+		}
+	}
+}
+
+static void cec_device_vendor_id(void)
+{
+	unsigned char msg[5];
+
+	msg[0] = ((cec_msg.log_addr & 0xf) << 4)| CEC_BROADCAST_ADDR;
+	msg[1] = CEC_OC_DEVICE_VENDOR_ID;
+	msg[2] = 0x00;
+	msg[3] = 0x00;
+	msg[4] = 0x00;
+
+	remote_cec_ll_tx(msg, 5);
+}
+
+static void cec_menu_status_smp(int menu_status, int dst)
+{
+	unsigned char msg[3];
+
+	msg[0] = ((cec_msg.log_addr & 0xf) << 4)| (dst & 0xf);
+	msg[1] = CEC_OC_MENU_STATUS;
+	msg[2] = menu_status;
+
+	remote_cec_ll_tx(msg, 3);
+}
+
+static void cec_give_deck_status(int dst)
+{
+	unsigned char msg[3];
+
+	msg[0] = ((cec_msg.log_addr & 0xf) << 4) | (dst & 0xf);
+	msg[1] = CEC_OC_DECK_STATUS;
+	msg[2] = 0x1a;
+
+	remote_cec_ll_tx(msg, 3);
+}
+
+static void cec_standby(void)
+{
+	unsigned char msg[2];
+
+	msg[0] = ((cec_msg.log_addr & 0xf) << 4) | CEC_BROADCAST_ADDR;
+	msg[1] = CEC_OC_STANDBY;
+
+	remote_cec_ll_tx(msg, 2);
+}
+
+static void cec_set_osd_name(int dst)
+{
+	unsigned char msg[16];
+	unsigned char osd_len = cec_strlen(CONFIG_CEC_OSD_NAME);
+
+	msg[0] = ((cec_msg.log_addr & 0xf) << 4) | (dst & 0xf);
+	msg[1] = CEC_OC_SET_OSD_NAME;
+	cec_memcpy(&msg[2], CONFIG_CEC_OSD_NAME, osd_len);
+
+	remote_cec_ll_tx(msg, osd_len + 2);
+}
+
+static void cec_get_version(int dst)
+{
+	unsigned char dest_log_addr = cec_msg.log_addr & 0xf;
+	unsigned char msg[3];
+
+	if (0xf != dest_log_addr) {
+		msg[0] = ((cec_msg.log_addr & 0xf) << 4) | (dst & 0xf);
+		msg[1] = CEC_OC_CEC_VERSION;
+		msg[2] = CEC_VERSION_14A;
+		remote_cec_ll_tx(msg, 3);
+	}
+}
+
+static int check_addr(int phy_addr)
+{
+	unsigned int local_addr = (readl(P_AO_DEBUG_REG1)) & 0xffff;
+	unsigned int i, mask = 0xf000, a, b;
+
+	for (i = 0; i < 4; i++) {
+		if (!(local_addr & mask)) {
+			break;
+		}
+		a = local_addr & mask;
+		b = phy_addr & mask;
+		if (a != b)	{// node is not same
+			cec_dbg_prints("addr fail 1\n");
+			return 0;
+		}
+		mask >>= 4;
+	}
+	cec_dbg_prints("addr ok\n");
+	return 1;
+}
+
+static int is_playback_dev(int addr)
+{
+	if (addr != CEC_PLAYBACK_DEVICE_1_ADDR &&
+	    addr != CEC_PLAYBACK_DEVICE_2_ADDR &&
+	    addr != CEC_PLAYBACK_DEVICE_3_ADDR) {
+		return 0;
+	}
+	return 1;
+}
+
+
+static unsigned int cec_handle_message(void)
+{
+	unsigned char opcode;
+	unsigned char source;
+	unsigned int  phy_addr, wake;
+
+	source = (cec_msg.buf[cec_msg.rx_read_pos].msg[0] >> 4) & 0xf;
+	if (((hdmi_cec_func_config>>CEC_FUNC_MASK) & 0x1) &&
+		(cec_msg.buf[cec_msg.rx_read_pos].msg_len > 1)) {
+		opcode = cec_msg.buf[cec_msg.rx_read_pos].msg[1];
+		switch (opcode) {
+		case CEC_OC_GET_CEC_VERSION:
+			cec_get_version(source);
+			break;
+		case CEC_OC_GIVE_DECK_STATUS:
+			cec_give_deck_status(source);
+			break;
+		case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+			cec_report_physical_address();
+			break;
+		case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+			cec_device_vendor_id();
+			break;
+		case CEC_OC_GIVE_OSD_NAME:
+			cec_set_osd_name(source);
+			break;
+		case CEC_OC_SET_STREAM_PATH:
+			cec_set_stream_path();
+			break;
+		case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+			cec_report_device_power_status(source);
+			break;
+		case CEC_OC_USER_CONTROL_PRESSED:
+			if (((hdmi_cec_func_config >> CEC_FUNC_MASK) & 0x1) &&
+			    ((hdmi_cec_func_config >> AUTO_POWER_ON_MASK) & 0x1) &&
+			     (cec_msg.buf[cec_msg.rx_read_pos].msg_len == 3) &&
+			    ((0x40 == cec_msg.buf[cec_msg.rx_read_pos].msg[2]) ||
+			     (0x6d == cec_msg.buf[cec_msg.rx_read_pos].msg[2]) ||
+			     (0x09 == cec_msg.buf[cec_msg.rx_read_pos].msg[2]) )) {
+				cec_msg.cec_power = 0x1;
+			}
+			break;
+		case CEC_OC_MENU_REQUEST:
+			cec_menu_status_smp(DEVICE_MENU_INACTIVE, source);
+			break;
+
+		/* TV Wake up by image/text view on */
+		case CEC_OC_IMAGE_VIEW_ON:
+		case CEC_OC_TEXT_VIEW_ON:
+			if (((hdmi_cec_func_config >> CEC_FUNC_MASK) & 0x1) &&
+			    ((hdmi_cec_func_config >> AUTO_POWER_ON_MASK) & 0x1) &&
+			    (!is_playback_dev(cec_msg.log_addr))) {
+				/* request active source needed */
+				phy_addr = 0xffff;
+				cec_msg.cec_power = 0x1;
+				wake =  (phy_addr << 0) |
+					(source << 16);
+				writel(wake, P_AO_RTI_STATUS_REG1);
+			}
+			break;
+
+		/* TV Wake up by active source*/
+		case CEC_OC_ACTIVE_SOURCE:
+			phy_addr = (cec_msg.buf[cec_msg.rx_read_pos].msg[2] << 8) |
+				   (cec_msg.buf[cec_msg.rx_read_pos].msg[3] << 0);
+			if (((hdmi_cec_func_config >> CEC_FUNC_MASK) & 0x1) &&
+			    ((hdmi_cec_func_config >> AUTO_POWER_ON_MASK) & 0x1) &&
+			    (!is_playback_dev(cec_msg.log_addr) && check_addr(phy_addr))) {
+				cec_msg.cec_power = 0x1;
+				wake =  (phy_addr << 0) |
+					(source << 16);
+				writel(wake, P_AO_RTI_STATUS_REG1);
+			}
+			break;
+
+		default:
+			break;
+		}
+	}
+	cec_rx_read_pos_plus();
+	return 0;
+}
+
+static void cec_reset_addr(void)
+{
+	remote_cec_hw_reset();
+	cec_wr_reg(CEC_LOGICAL_ADDR0, 0);
+	cec_hw_buf_clear();
+	cec_wr_reg(CEC_LOGICAL_ADDR0, cec_msg.log_addr & 0x0f);
+	_udelay(100);
+	cec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | (cec_msg.log_addr & 0x0f));
+}
+
+unsigned int cec_handler(void)
+{
+	unsigned char s_idx;
+	static int busy_count = 0;
+
+	if (0xf == cec_rd_reg(CEC_RX_NUM_MSG)) {
+		cec_wr_reg(CEC_RX_CLEAR_BUF, 0x1);
+		cec_wr_reg(CEC_RX_CLEAR_BUF, 0x0);
+		cec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+		cec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+		cec_dbg_prints("error:hw_buf overflow\n");
+	}
+
+	switch (cec_rd_reg(CEC_RX_MSG_STATUS)) {
+	case RX_DONE:
+		if (1 == cec_rd_reg(CEC_RX_NUM_MSG)) {
+			remote_cec_ll_rx();
+			(cec_msg.rx_write_pos == cec_msg.rx_buf_size - 1) ? (cec_msg.rx_write_pos = 0) : (cec_msg.rx_write_pos++);
+		}
+		cec_wr_reg(CEC_RX_MSG_CMD, RX_ACK_CURRENT);
+		cec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+		cec_dbg_prints("RX_OK\n");
+		break;
+	case RX_ERROR:
+		cec_dbg_prints("RX_ERROR\n");
+		if (TX_ERROR == cec_rd_reg(CEC_TX_MSG_STATUS)) {
+			cec_dbg_prints("TX_ERROR\n");
+			cec_reset_addr();
+		} else {
+			cec_dbg_prints("TX_other\n");
+			cec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+			cec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (cec_rd_reg(CEC_TX_MSG_STATUS)) {
+	case TX_DONE:
+		cec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+		cec_tx_msgs.send_idx = (cec_tx_msgs.send_idx + 1) & CEC_TX_MSG_BUF_MASK;
+		s_idx = cec_tx_msgs.send_idx;
+		if (cec_tx_msgs.send_idx != cec_tx_msgs.queue_idx) {
+			cec_dbg_prints("TX_OK\n");
+			cec_triggle_tx(cec_tx_msgs.msg[s_idx].buf,
+				       cec_tx_msgs.msg[s_idx].len);
+		} else {
+			cec_dbg_prints("TX_END\n");
+		}
+		busy_count = 0;
+		break;
+
+	case TX_ERROR:
+		cec_dbg_prints("@TX_ERROR\n");
+		if (RX_ERROR == cec_rd_reg(CEC_RX_MSG_STATUS)) {
+			cec_dbg_prints("@RX_ERROR\n");
+			cec_reset_addr();
+		} else {
+			cec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+			s_idx = cec_tx_msgs.send_idx;
+			if (cec_tx_msgs.msg[s_idx].retry < 5) {
+				cec_tx_msgs.msg[s_idx].retry++;
+				cec_triggle_tx(cec_tx_msgs.msg[s_idx].buf,
+					       cec_tx_msgs.msg[s_idx].len);
+			} else {
+				cec_dbg_prints("TX retry too much, abort msg\n");
+				cec_tx_msgs.send_idx = (cec_tx_msgs.send_idx + 1) & CEC_TX_MSG_BUF_MASK;
+			}
+		}
+		busy_count = 0;
+		break;
+
+	 case TX_IDLE:
+		s_idx = cec_tx_msgs.send_idx;
+		if (cec_tx_msgs.send_idx != cec_tx_msgs.queue_idx) { // triggle tx if idle
+			cec_triggle_tx(cec_tx_msgs.msg[s_idx].buf,
+				       cec_tx_msgs.msg[s_idx].len);
+		}
+		busy_count = 0;
+		break;
+
+	case TX_BUSY:
+		busy_count++;
+		if (busy_count >= 2000) {
+			uart_puts("busy too long, reset hw\n");
+			cec_reset_addr();
+			busy_count = 0;
+		}
+		break;
+
+	 default:
+		break;
+	}
+	if (cec_msg.rx_read_pos != cec_msg.rx_write_pos) {
+		cec_handle_message();
+	}
+
+	return 0;
+}
+
+static void check_standby(void)
+{
+	if (((cec_msg.log_addr & 0xf) == 0) &&
+	    ((hdmi_cec_func_config >> CEC_FUNC_MASK) & 0x1) &&
+	    ((hdmi_cec_func_config >> ONE_TOUCH_STANDBY_MASK) & 0x1)) {
+		cec_standby();
+	}
+}
+
+void cec_node_init(void)
+{
+	static int i = 0;
+	static unsigned int retry = 0;
+	static int regist_devs = 0;
+	static enum _cec_log_dev_addr_e *probe = NULL;
+
+	int tx_stat;
+	unsigned char msg[1];
+	unsigned int kern_log_addr = (readl(P_AO_DEBUG_REG1) >> 16) & 0xf;
+	enum _cec_log_dev_addr_e player_dev[3][3] =
+		{{CEC_PLAYBACK_DEVICE_1_ADDR, CEC_PLAYBACK_DEVICE_2_ADDR, CEC_PLAYBACK_DEVICE_3_ADDR},
+		 {CEC_PLAYBACK_DEVICE_2_ADDR, CEC_PLAYBACK_DEVICE_3_ADDR, CEC_PLAYBACK_DEVICE_1_ADDR},
+		 {CEC_PLAYBACK_DEVICE_3_ADDR, CEC_PLAYBACK_DEVICE_1_ADDR, CEC_PLAYBACK_DEVICE_2_ADDR}};
+
+	if (retry >= 12) {  // retry all device addr
+		cec_msg.log_addr = 0x0f;
+		uart_puts("failed on retried all possible address\n");
+		return ;
+	}
+	writel(0, P_AO_RTI_STATUS_REG1);
+	if (probe == NULL) {
+		cec_msg.rx_read_pos = 0;
+		cec_msg.rx_write_pos = 0;
+		cec_msg.rx_buf_size = 2;
+
+		cec_msg.power_status = 1;
+		cec_msg.cec_power = 0;
+		cec_tx_msgs.send_idx = 0;
+		cec_tx_msgs.queue_idx = 0;
+		cec_tx_buf_init();
+		cec_buf_clear();
+		cec_wr_reg(CEC_LOGICAL_ADDR0, 0);
+		cec_hw_buf_clear();
+		cec_wr_reg(CEC_LOGICAL_ADDR0, 0xf);
+		_udelay(100);
+		cec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+		/*
+		 * use kernel cec logic address to detect which logic address is the
+		 * started one to allocate.
+		 */
+		cec_dbg_print("kern log_addr:0x", kern_log_addr);
+		uart_puts("\n");
+		/* we don't need probe TV address */
+		if (!is_playback_dev(kern_log_addr)) {
+			msg[0] = (kern_log_addr << 4) | kern_log_addr;
+			ping_cec_ll_tx(msg, 1);
+			cec_msg.log_addr = 0x10 | kern_log_addr;
+			cec_wr_reg(CEC_LOGICAL_ADDR0, 0);
+			cec_hw_buf_clear();
+			cec_wr_reg(CEC_LOGICAL_ADDR0, kern_log_addr);
+			_udelay(100);
+			cec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | kern_log_addr);
+			cec_dbg_print("Set cec log_addr:0x", cec_msg.log_addr);
+			cec_dbg_print(",ADDR0:", cec_rd_reg(CEC_LOGICAL_ADDR0));
+			uart_puts("\n");
+			probe = NULL;
+			regist_devs = 0;
+			i = 0;
+			retry = 0;
+			check_standby();
+			return ;
+		}
+		for (i = 0; i < 3; i++) {
+			if (kern_log_addr == player_dev[i][0]) {
+				probe = player_dev[i];
+				break;
+			}
+		}
+		if (probe == NULL) {
+			probe = player_dev[0];
+		}
+		i = 0;
+	}
+
+	msg[0] = (probe[i]<<4) | probe[i];
+	tx_stat = ping_cec_ll_tx(msg, 1);
+	if (tx_stat == TX_BUSY) {   // can't get cec bus
+		retry++;
+		remote_cec_hw_reset();
+		if (!(retry & 0x03)) {
+			cec_dbg_print("retry too much, log_addr:0x", probe[i]);
+			uart_puts("\n");
+		} else {
+			i -= 1;
+		}
+	} else if (tx_stat == TX_ERROR) {
+		cec_wr_reg(CEC_LOGICAL_ADDR0, 0);
+		cec_hw_buf_clear();
+		cec_wr_reg(CEC_LOGICAL_ADDR0, probe[i]);
+		_udelay(100);
+		cec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | probe[i]);
+		cec_msg.log_addr = probe[i];
+		cec_dbg_print("Set cec log_addr:0x", cec_msg.log_addr);
+		cec_dbg_print(", ADDR0:", cec_rd_reg(CEC_LOGICAL_ADDR0));
+		uart_puts("\n");
+		probe = NULL;
+		regist_devs = 0;
+		i = 0;
+		retry = 0;
+		return ;
+	} else if (tx_stat == TX_DONE) {
+		cec_dbg_print("sombody takes cec log_addr:0x", probe[i]);
+		uart_puts("\n");
+		regist_devs |= (1 << i);
+		retry += (4 - (retry & 0x03));
+		if (regist_devs == 0x07) {
+			// No avilable logical address
+			cec_msg.log_addr = 0x0f;
+			cec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+			uart_puts("CEC allocate logic address failed\n");
+		}
+	}
+	i++;
+	if (i == 3) {
+		i = 0;
+	}
+}
+
+#endif
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/lib/delay.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/lib/delay.c
new file mode 100644
index 0000000..18099ed
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/lib/delay.c
@@ -0,0 +1,36 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/lib/delay.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#define P_EE_TIMER_E		(*((volatile unsigned *)(0xc1100000 + (0x2662 << 2))))
+
+unsigned int get_time(void)
+{
+	return P_EE_TIMER_E;
+}
+
+void _udelay(unsigned int us)
+{
+	unsigned int t0 = get_time();
+
+	while (get_time() - t0 <= us)
+		;
+}
+
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/lib/string.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/lib/string.c
new file mode 100644
index 0000000..2e551f4
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/lib/string.c
@@ -0,0 +1,39 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/lib/string.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+void *memcpy(void *dest, const void *src, unsigned int count)
+{
+	char *tmp = dest;
+	const char *s = src;
+
+	while (count--)
+		*tmp++ = *s++;
+	return dest;
+}
+void *memset(void *s, int c, unsigned int count)
+{
+	char *xs = s;
+
+	while (count--)
+		*xs++ = c;
+	return s;
+}
+
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/misc.S b/arch/arm/cpu/armv8/txl/firmware/scp_task/misc.S
new file mode 100644
index 0000000..9b97da3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/misc.S
@@ -0,0 +1,24 @@
+.text
+
+.syntax unified
+.code 16
+
+.global bss_init
+.thumb_func
+
+bss_init:
+	mov r0, #0
+	ldr r1, _bss_start
+	ldr r2, _bss_end
+bss_loop:
+	cmp r1, r2
+	it lt
+	strlt r0, [r1], #4
+	blt bss_loop
+	bx lr
+
+.align 2
+_bss_start:
+.long _bssstart
+_bss_end:
+.long _bssend
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/registers.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/registers.h
new file mode 100644
index 0000000..810cd5d
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/registers.h
@@ -0,0 +1,86 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/registers.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _SCP_REGISTER_DEFINES_
+#define _SCP_REGISTER_DEFINES_
+#include "secure_apb.h"
+
+/* CBUS Registers */
+ /*TIMER*/
+#define P_ISA_TIMER_MUX                              ((0x2650  << 2) + 0xc1100000)
+#define P_ISA_TIMERA                                 ((0x2651  << 2) + 0xc1100000)
+#define P_ISA_TIMERB                                 ((0x2652  << 2) + 0xc1100000)
+#define P_ISA_TIMERC                                 ((0x2653  << 2) + 0xc1100000)
+#define P_ISA_TIMERD                                 ((0x2654  << 2) + 0xc1100000)
+#define P_ISA_TIMERE                                 ((0x2662  << 2) + 0xc1100000)
+#define P_ISA_TIMERE_HI                              ((0x2663  << 2) + 0xc1100000)
+#define P_ISA_TIMER_MUX1                             ((0x2664  << 2) + 0xc1100000)
+#define P_ISA_TIMERF                                 ((0x2665  << 2) + 0xc1100000)
+#define P_ISA_TIMERG                                 ((0x2666  << 2) + 0xc1100000)
+#define P_ISA_TIMERH                                 ((0x2667  << 2) + 0xc1100000)
+#define P_ISA_TIMERI                                 ((0x2668  << 2) + 0xc1100000)
+/* 80K share SRAM base address*/
+#define P_SHARE_SRAM_BASE	0xd9000000
+/*Interrupt number list*/
+#define IRQ_TIMERC_NUM      0
+#define IRQ_TIMERA_NUM      1
+#define IRQ_TIMERB_NUM      2
+#define IRQ_TIMERD_NUM      3
+#define IRQ_TIMERF_NUM      4
+#define IRQ_TIMERG_NUM      5
+#define IRQ_TIMERH_NUM      6
+#define IRQ_TIMERI_NUM      7
+#define IRQ_GPIO0_NUM       8
+#define IRQ_GPIO1_NUM       9
+#define IRQ_GPIO2_NUM       10
+#define IRQ_GPIO3_NUM       11
+#define IRQ_SAR_ADC_NUM     12
+#define IRQ_ASIT_MBOX0_NUM  13
+#define IRQ_ASIT_MBOX1_NUM  14
+#define IRQ_ASIT_MBOX2_NUM  15
+#define IRQ_MBOX3_NUM       16
+//17 reserve
+#define IRQ_ETH_GMAC_NUM    18
+#define IRQ_ETH_PMT_NUM     19
+#define IRQ_ETH_LIP_NUM     20
+//21~31 reserve
+#define IRQ_MBOX3_RECV_NUM  32
+#define IRQ_MBOX4_RECV_NUM  33
+#define IRQ_MBOX5_RECV_NUM  34
+#define IRQ_MBOX0_SEND_NUM  35
+#define IRQ_MBOX1_SEND_NUM  36
+#define IRQ_MBOX2_SEND_NUM  37
+//38 reserve
+#define IRQ_AO_UART_NUM     39
+#define IRQ_AO_I2C_S_NUM    40
+#define IRQ_AO_I2C_M_NUM    41
+#define IRQ_AO_IR_DEC_NUM   42
+#define IRQ_AO_UART2_NUM    43
+#define IRQ_AO_IR_BLST_NUM  44
+#define IRQ_AO_CEC_NUM      45
+#define IRQ_AO_GPIO0_NUM    46
+#define IRQ_AO_GPIO1_NUM    47
+//48 reserve
+#define IRQ_JTGPWD_FST_NUM  49
+#define IRQ_WATCHDOG_NUM    50
+//51 reserve
+#define IRQ_AO_TIMERA_NUM   52
+#endif				//_SCP_REGISTER_DEFINES_
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/scp_adc.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/scp_adc.c
new file mode 100644
index 0000000..0b3c5ef
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/scp_adc.c
@@ -0,0 +1,327 @@
+
+enum{AML_ADC_CHAN_0 = 0, AML_ADC_CHAN_1, AML_ADC_CHAN_2, AML_ADC_CHAN_3,
+         AML_ADC_CHAN_4,         AML_ADC_CHAN_5, AML_ADC_CHAN_6, AML_ADC_CHAN_7,
+         AML_ADC_SARADC_CHAN_NUM,
+};
+
+enum{AML_ADC_NO_AVG = 0,  AML_ADC_SIMPLE_AVG_1, AML_ADC_SIMPLE_AVG_2,
+         AML_ADC_SIMPLE_AVG_4,AML_ADC_SIMPLE_AVG_8, AML_ADC_MEDIAN_AVG_8,
+};
+
+#define AML_ADC_CHAN_XP AML_ADC_CHAN_0
+#define AML_ADC_CHAN_YP AML_ADC_CHAN_1
+#define AML_ADC_CHAN_XN AML_ADC_CHAN_2
+#define AML_ADC_CHAN_YN AML_ADC_CHAN_3
+
+
+
+typedef struct adckey_info{
+        const char *key;
+        int   value;    /* voltage/3.3v * 1023 */
+        int   tolerance;
+}adckey_info_t;
+
+typedef struct adc_info{
+        char * tint;
+        int    chan;
+        int    adc_type;
+        void * adc_data;
+}adc_info_t;
+
+struct adc_device{
+        adc_info_t * adc_device_info;
+        unsigned dev_num;
+};
+
+
+#define CONFIG_GXBB 1
+
+#define WRITE_REG(reg, val) writel(val, reg)
+#define READ_REG(reg)       readl(reg)
+
+#define GXBB_ADC   1
+#define AML_ADC_SAMPLE_DEBUG 0
+
+#define FLAG_BUSY_KERNEL    (1<<14) /* for bl30 */
+#define FLAG_BUSY_BL30      (1<<15) /* for bl30 */
+
+#define FLAG_INITIALIZED (1<<28)
+//#define FLAG_BUSY (1<<29)
+
+
+#if 0
+#define GXBB_CLK_REG                (volatile unsigned int *)0xc883c3d8
+#define P_SAR_SAR_ADC_REG0		    (volatile unsigned int *)0xc1108680
+#define P_SAR_ADC_CHAN_LIST		    (volatile unsigned int *)0xc1108684
+#define P_SAR_ADC_AVG_CNTL		    (volatile unsigned int *)0xc1108688
+#define P_SAR_ADC_REG3				(volatile unsigned int *)0xc110868c
+#define P_SAR_ADC_DELAY			    (volatile unsigned int *)0xc1108690
+#define P_SAR_ADC_LAST_RD			(volatile unsigned int *)0xc1108694
+#define P_SAR_ADC_FIFO_RD			(volatile unsigned int *)0xc1108698
+#define P_SAR_ADC_AUX_SW			(volatile unsigned int *)0xc110869c
+#define P_SAR_ADC_CHAN_10_SW		(volatile unsigned int *)0xc11086a0
+#define P_SAR_ADC_DETECT_IDLE_SW	(volatile unsigned int *)0xc11086a4
+#define P_SAR_ADC_DELTA_10	        (volatile unsigned int *)0xc11086a8
+#define P_SAR_ADC_DELTA_11          (volatile unsigned int *)0xc11086aC
+#endif
+
+#define GXBB_CLK_REG                (volatile unsigned int *)0xc8100090
+#define P_SAR_SAR_ADC_REG0		    (volatile unsigned int *)0xc8100600
+#define P_SAR_ADC_CHAN_LIST		    (volatile unsigned int *)0xc8100604
+#define P_SAR_ADC_AVG_CNTL		    (volatile unsigned int *)0xc8100608
+#define P_SAR_ADC_REG3				(volatile unsigned int *)0xc810060c
+#define P_SAR_ADC_DELAY			    (volatile unsigned int *)0xc8100610
+#define P_SAR_ADC_LAST_RD			(volatile unsigned int *)0xc8100614
+#define P_SAR_ADC_FIFO_RD			(volatile unsigned int *)0xc8100618
+#define P_SAR_ADC_AUX_SW			(volatile unsigned int *)0xc810061c
+#define P_SAR_ADC_CHAN_10_SW		(volatile unsigned int *)0xc8100620
+#define P_SAR_ADC_DETECT_IDLE_SW	(volatile unsigned int *)0xc8100624
+#define P_SAR_ADC_DELTA_10	        (volatile unsigned int *)0xc8100628
+#define P_SAR_ADC_DELTA_11          (volatile unsigned int *)0xc810062c
+
+
+
+#define PP_SAR_ADC_REG0					P_SAR_SAR_ADC_REG0
+#define PP_SAR_ADC_CHAN_LIST 			P_SAR_ADC_CHAN_LIST
+#define PP_SAR_ADC_AVG_CNTL				P_SAR_ADC_AVG_CNTL
+#define PP_SAR_ADC_REG3					P_SAR_ADC_REG3
+#define PP_SAR_ADC_DELAY				P_SAR_ADC_DELAY
+#define PP_SAR_ADC_LAST_RD				P_SAR_ADC_LAST_RD
+#define PP_SAR_ADC_FIFO_RD				P_SAR_ADC_FIFO_RD
+#define PP_SAR_ADC_AUX_SW				P_SAR_ADC_AUX_SW
+#define PP_SAR_ADC_CHAN_10_SW			P_SAR_ADC_CHAN_10_SW
+#define PP_SAR_ADC_DETECT_IDLE_SW	    P_SAR_ADC_DETECT_IDLE_SW
+#define PP_SAR_ADC_DELTA_10				P_SAR_ADC_DELTA_10
+#define PP_SAR_ADC_DELTA_11				P_SAR_ADC_DELTA_11
+
+typedef unsigned int uint32_t;
+
+static void aml_set_reg32_bits(volatile unsigned int *_reg, const uint32_t _value, const uint32_t _start, const uint32_t _len)
+{
+	writel(( (readl((volatile unsigned int *)_reg) & ~((( 1L << (_len) )-1) << (_start))) | ((unsigned)((_value)&((1L<<(_len))-1)) << (_start))), (volatile void *)_reg );
+}
+static uint32_t aml_get_reg32_bits(volatile unsigned int *_reg, const uint32_t _start, const uint32_t _len)
+{
+	return	( (readl((volatile unsigned int *)_reg) >> (_start)) & (( 1L << (_len) ) - 1) );
+}
+static void aml_write_reg32( volatile unsigned int *_reg, const uint32_t _value)
+{
+	writel( _value,(volatile unsigned int *)_reg );
+};
+static uint32_t aml_read_reg32(volatile unsigned int *_reg)
+{
+	return readl((volatile unsigned int *)_reg);
+};
+
+
+#define set_bits	aml_set_reg32_bits
+#define get_bits	aml_get_reg32_bits
+#define set_reg	    aml_write_reg32
+#define get_reg	    aml_read_reg32
+
+
+#define SARADC_STATE_IDLE 0
+#define SARADC_STATE_BUSY 1
+#define SARADC_STATE_SUSPEND 2
+
+
+
+
+static inline void saradc_power_control(int on)
+{
+	//struct saradc_reg3 *reg3 = (struct saradc_reg3 *)&adc->regs->reg3;
+	//int nn=0;
+	if (on) {
+        aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,1,13,1);
+        aml_set_reg32_bits(PP_SAR_ADC_REG3,1,21,1);
+		//nn=100;
+		//while(nn--);
+		_udelay(5);
+
+        #if GXBB_ADC
+            aml_set_reg32_bits(GXBB_CLK_REG,1,8,1);
+        #else
+            aml_set_reg32_bits(PP_SAR_ADC_REG3,1,30,1);
+        #endif
+	}	else {
+		#if GXBB_ADC
+			aml_set_reg32_bits(GXBB_CLK_REG,0,8,1);
+		#else
+			aml_set_reg32_bits(PP_SAR_ADC_REG3,0,30,1);
+        #endif
+		aml_set_reg32_bits(PP_SAR_ADC_REG3,0,30,1);
+        aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,0,13,1); /* disable bandgap */
+	}
+}
+
+void saradc_enable(void)
+{
+    set_reg(P_SAR_SAR_ADC_REG0, 0x84004040);
+    set_reg(PP_SAR_ADC_CHAN_LIST, 0);
+    /* REG2: all chanel set to 8-samples & median averaging mode */
+    set_reg(PP_SAR_ADC_AVG_CNTL, 0);
+
+    set_reg(PP_SAR_ADC_REG3, 0x9388000a);
+    aml_set_reg32_bits(PP_SAR_ADC_REG3, 0x14,10,5);
+
+    #if GXBB_ADC
+    aml_write_reg32(GXBB_CLK_REG, (0<<9) | (20 << 0));
+    #endif
+    set_reg(PP_SAR_ADC_DELAY, 0x10a000a);
+    set_reg(PP_SAR_ADC_AUX_SW, 0x3eb1a0c);
+    set_reg(PP_SAR_ADC_CHAN_10_SW, 0x8c000c);
+    set_reg(PP_SAR_ADC_DETECT_IDLE_SW, 0xc000c);
+
+#if AML_ADC_SAMPLE_DEBUG
+	printf("ADCREG reg0 =%x\n",   get_reg(PP_SAR_ADC_REG0));
+	printf("ADCREG ch list =%x\n",get_reg(PP_SAR_ADC_CHAN_LIST));
+	printf("ADCREG avg  =%x\n",   get_reg(PP_SAR_ADC_AVG_CNTL));
+	printf("ADCREG reg3 =%x\n",   get_reg(PP_SAR_ADC_REG3));
+	printf("ADCREG ch72 sw =%x\n",get_reg(PP_SAR_ADC_AUX_SW));
+	printf("ADCREG ch10 sw =%x\n",get_reg(PP_SAR_ADC_CHAN_10_SW));
+	printf("ADCREG detect&idle=%x\n",get_reg(PP_SAR_ADC_DETECT_IDLE_SW));
+    printf("ADCREG GXBB_CLK_REG=%x\n",get_reg(GXBB_CLK_REG));
+#endif //AML_ADC_SAMPLE_DEBUG
+
+
+    saradc_power_control(1);
+}
+
+
+/*
+static int saradc_get_cal_value(struct saradc *adc, int val)
+{
+	int nominal;
+
+//	((nominal - ref_nominal) << 10) / (val - ref_val) = coef
+//	==> nominal = ((val - ref_val) * coef >> 10) + ref_nominal
+
+	nominal = val;
+	if ((adc->coef > 0) && (val > 0)) {
+		nominal = (val - adc->ref_val) * adc->coef;
+		nominal >>= 12;
+		nominal += adc->ref_nominal;
+	}
+	if (nominal < 0)
+		nominal = 0;
+	if (nominal > 1023)
+		nominal = 1023;
+	return nominal;
+}
+*/
+
+int get_adc_sample_gxbb(int ch)
+{
+	int value=0;
+	int count=0;
+	int sum=0;
+	//int nn=0;
+	//unsigned long flags;
+
+	//int adc_state = SARADC_STATE_BUSY;
+
+	count = 0;
+	while (aml_read_reg32(PP_SAR_ADC_DELAY) & FLAG_BUSY_BL30) {
+		_udelay(100);
+		if (++count > 100) {
+			//printf("bl30 busy error\n");
+			uart_puts(".bl30 busy error");
+			uart_puts("\n");
+			value = -1;
+			goto end1;
+		}
+	}
+	aml_set_reg32_bits(PP_SAR_ADC_DELAY,1,FLAG_BUSY_KERNEL,1);
+
+
+	count = 0;
+	while (aml_get_reg32_bits(PP_SAR_ADC_REG0,21,5) && (count < 32)) {
+		value = aml_read_reg32(PP_SAR_ADC_FIFO_RD);
+		count++;
+	}
+
+	//aml_set_reg32_bits(PP_SAR_ADC_REG3,1,29,1);
+
+    set_reg(PP_SAR_ADC_CHAN_LIST, ch);
+    set_reg(PP_SAR_ADC_DETECT_IDLE_SW, (0xc000c | (ch<<23) | (ch<<7)));
+    aml_set_reg32_bits(PP_SAR_ADC_REG0, 1,0,1);
+    aml_set_reg32_bits(PP_SAR_ADC_REG0, 1,2,1);
+
+    count = 0;
+	do {
+		_udelay(10);
+		//nn=10000;
+		//while(nn--);
+		if (!(aml_read_reg32(P_SAR_SAR_ADC_REG0) & 0x70000000))
+			break;
+		else if (++count > 10000) {
+			uart_puts("busy error");
+			uart_puts("\n");
+			value = -1;
+			goto end;
+		}
+	} while (1);
+
+	count = 0;
+	sum = 0;
+	while (aml_get_reg32_bits(PP_SAR_ADC_REG0,21,5) && (count < 32)) {
+		if (aml_get_reg32_bits(PP_SAR_ADC_REG0,26,1)) {
+			uart_puts("fifo_count, but fifo empty");
+			uart_puts("\n");
+		}
+        value = aml_read_reg32(PP_SAR_ADC_FIFO_RD);
+		if (((value>>12) & 0x07) == ch) {
+			sum += value & 0x3ff;
+			count++;
+		}	else {
+			uart_puts("chanel error");
+			uart_puts("\n");
+		}
+	}
+	if (!aml_get_reg32_bits(PP_SAR_ADC_REG0,26,1)) {
+		uart_puts("fifo_count=0, but fifo not empty");
+		uart_puts("\n");
+	}
+	if (!count) {
+		value = -1;
+		goto end;
+	}
+	value = sum / count;
+	//printf("before cal: %d, count=%d\n", value, count);
+	//uart_puts("before cal:");
+	//uart_put_hex(value, 32);
+	//uart_puts("\n");
+    //value = saradc_get_cal_value(adc, value);
+end:
+    aml_set_reg32_bits(PP_SAR_ADC_REG0,1,14,1);
+    aml_set_reg32_bits(PP_SAR_ADC_REG0,0,0,1);
+
+end1:
+    //aml_set_reg32_bits(PP_SAR_ADC_REG3,0,29,1);
+    //adc_state = SARADC_STATE_IDLE;
+	aml_set_reg32_bits(PP_SAR_ADC_DELAY,0,FLAG_BUSY_KERNEL,1);
+
+	return value;
+}
+
+int saradc_disable(void)
+{
+	saradc_power_control(0);
+	return 0;
+}
+
+int check_adc_key_resume(void)
+{
+	int value;
+	int rang=30;
+	value = get_adc_sample_gxbb(2);
+	if ((value >= 0) && (value <= 40))
+		return 1;
+	else if (((value>=(217-rang)) && (value<=217+rang)) ||
+		     ((value>=(414-rang)) && (value<=414+rang)) ||
+		     ((value>=(616-rang)) && (value<=616+rang)) ||
+		     ((value>=(822-rang)) && (value<=822+rang)))
+		return 2;
+	else
+		return 0;
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/scp_remote.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/scp_remote.c
new file mode 100644
index 0000000..be35ae9
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/scp_remote.c
@@ -0,0 +1,288 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/scp_remote.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include "config.h"
+#include "registers.h"
+#include "task_apis.h"
+
+enum {
+	DECODEMODE_NEC = 0,
+	DECODEMODE_DUOKAN = 1,
+	DECODEMODE_RCMM,
+	DECODEMODE_SONYSIRC,
+	DECODEMODE_SKIPLEADER,
+	DECODEMODE_MITSUBISHI,
+	DECODEMODE_THOMSON,
+	DECODEMODE_TOSHIBA,
+	DECODEMODE_RC5,
+	DECODEMODE_RC6,
+	DECODEMODE_COMCAST,
+	DECODEMODE_SANYO,
+	DECODEMODE_MAX
+};
+typedef struct reg_remote {
+	int reg;
+	unsigned int val;
+} reg_remote;
+#define CONFIG_END 0xffffffff
+#define IR_POWER_KEY_MASK 0xffffffff
+#if 0
+//32K
+static const reg_remote RDECODEMODE_NEC[] = {
+	{AO_MF_IR_DEC_LDR_ACTIVE, 350 << 16 | 260 << 0},
+	{AO_MF_IR_DEC_LDR_IDLE, 200 << 16 | 120 << 0},
+	{AO_MF_IR_DEC_LDR_REPEAT, 100 << 16 | 70 << 0},
+	{AO_MF_IR_DEC_BIT_0, 50 << 16 | 20 << 0},
+	{AO_MF_IR_DEC_REG0, 3 << 28 | (0xFA0 << 12)},
+	{AO_MF_IR_DEC_STATUS, (100 << 20) | (45 << 10)},
+	{AO_MF_IR_DEC_REG1, 0x600fdf00},
+	{AO_MF_IR_DEC_REG2, 0x0},
+	{AO_MF_IR_DEC_DURATN2, 0},
+	{AO_MF_IR_DEC_DURATN3, 0},
+	{CONFIG_END, 0}
+};
+
+static const reg_remote RDECODEMODE_TOSHIBA[] = {
+	{AO_MF_IR_DEC_LDR_ACTIVE, 175 << 16 | 130 << 0},	//TOSHIBA leader 9000us
+	{AO_MF_IR_DEC_LDR_IDLE, 175 << 16 | 130 << 0},	// leader idle
+	{AO_MF_IR_DEC_LDR_REPEAT, 200 << 16 | 1220 << 0},	// leader repeat
+	{AO_MF_IR_DEC_BIT_0, 50 << 16 | 20 << 0},	// logic '0' or '00'
+	{AO_MF_IR_DEC_REG0, 3 << 28 | (0xFA0 << 12)},
+	{AO_MF_IR_DEC_STATUS, 100 << 20 | 55 << 10},	// logic '1' or '01'
+	{AO_MF_IR_DEC_REG1, 0x600fdf00},	// boby long decode (8-13)
+	//{AO_MF_IR_DEC_REG1,0xbe40},// boby long decode (8-13)
+	{AO_MF_IR_DEC_REG2, 0x0},	// hard decode mode
+	{AO_MF_IR_DEC_DURATN2, 0},
+	{AO_MF_IR_DEC_DURATN3, 0},
+	{CONFIG_END, 0}
+};
+
+static const reg_remote RDECODEMODE_DUOKAN[] = {
+	{AO_MF_IR_DEC_LDR_ACTIVE,},
+	{AO_MF_IR_DEC_LDR_IDLE,},
+	{AO_MF_IR_DEC_LDR_REPEAT,},
+	{AO_MF_IR_DEC_BIT_0,},
+	{AO_MF_IR_DEC_REG0,},	//body frame 30ms
+	{AO_MF_IR_DEC_STATUS,},
+	{AO_MF_IR_DEC_REG1,},
+	{AO_MF_IR_DEC_REG2,},
+	{AO_MF_IR_DEC_DURATN2,},
+	{AO_MF_IR_DEC_DURATN3,},
+	{CONFIG_END, 0}
+};
+
+static const reg_remote RDECODEMODE_RCA[] = {
+	{AO_MF_IR_DEC_LDR_ACTIVE,},	//rca leader 4000us,200* timebase
+	{AO_MF_IR_DEC_LDR_IDLE,},	// leader idle 400
+	{AO_MF_IR_DEC_LDR_REPEAT,},	// leader repeat
+	{AO_MF_IR_DEC_BIT_0,},	// logic '0' or '00' 1500us
+	{AO_MF_IR_DEC_REG0,},	// sys clock boby time.base time = 20 body frame
+	{AO_MF_IR_DEC_STATUS,},	// logic '1' or '01'   2500us
+	{AO_MF_IR_DEC_REG1,},	// boby long decode (8-13) //framn len = 24bit
+	/*it may get the wrong customer value and key value from register if the value is set to 0x4,so the register value must set to 0x104 */
+	{AO_MF_IR_DEC_REG2,},
+	{AO_MF_IR_DEC_DURATN2,},
+	{AO_MF_IR_DEC_DURATN3,},
+	{CONFIG_END, 0}
+};
+#else
+//24M
+static const reg_remote RDECODEMODE_NEC[] = {
+	{AO_MF_IR_DEC_LDR_ACTIVE, 477 << 16 | 400 << 0},
+	{AO_MF_IR_DEC_LDR_IDLE, 248 << 16 | 202 << 0},
+	{AO_MF_IR_DEC_LDR_REPEAT, 130 << 16 | 110 << 0},
+	{AO_MF_IR_DEC_BIT_0, 60 << 16 | 48 << 0},
+	{AO_MF_IR_DEC_REG0, 3 << 28 | (0xFA0 << 12) | 0x13},
+	{AO_MF_IR_DEC_STATUS, (111 << 20) | (100 << 10)},
+	{AO_MF_IR_DEC_REG1, 0x9f50},
+	{AO_MF_IR_DEC_REG2, 0x0},
+	{AO_MF_IR_DEC_DURATN2, 0},
+	{AO_MF_IR_DEC_DURATN3, 0},
+	{CONFIG_END, 0}
+};
+
+static const reg_remote RDECODEMODE_DUOKAN[] = {
+	{AO_MF_IR_DEC_LDR_ACTIVE, 53 << 16 | 50 << 0},
+	{AO_MF_IR_DEC_LDR_IDLE, 31 << 16 | 25 << 0},
+	{AO_MF_IR_DEC_LDR_REPEAT, 30 << 16 | 26 << 0},
+	{AO_MF_IR_DEC_BIT_0, 61 << 16 | 55 << 0},
+	{AO_MF_IR_DEC_REG0, 3 << 28 | (0x5DC << 12) | 0x13},	//body frame 30ms
+	{AO_MF_IR_DEC_STATUS, (76 << 20) | 69 << 10},
+	{AO_MF_IR_DEC_REG1, 0x9300},
+	{AO_MF_IR_DEC_REG2, 0x10b},
+	{AO_MF_IR_DEC_DURATN2, 91 << 16 | 79 << 0},
+	{AO_MF_IR_DEC_DURATN3, 111 << 16 | 99 << 0},
+	{CONFIG_END, 0}
+};
+
+static const reg_remote RDECODEMODE_TOSHIBA[] = {
+	{AO_MF_IR_DEC_LDR_ACTIVE, 263 << 16 | 194 << 0},
+	{AO_MF_IR_DEC_LDR_IDLE, 263 << 16 | 194 << 0},
+	{AO_MF_IR_DEC_LDR_REPEAT, 263 << 16 | 194 << 0},
+	{AO_MF_IR_DEC_BIT_0, 60 << 16 | 40 << 0},
+	{AO_MF_IR_DEC_REG0, 3 << 28 | (0xFA0 << 12) | 0x13},
+	{AO_MF_IR_DEC_STATUS, (124 << 20) | (100 << 10)},
+	{AO_MF_IR_DEC_REG1, 0x9f50},
+	{AO_MF_IR_DEC_REG2, 0x5},
+	{AO_MF_IR_DEC_DURATN2, 0},
+	{AO_MF_IR_DEC_DURATN3, 0},
+	{CONFIG_END, 0}
+};
+
+static const reg_remote RDECODEMODE_RCA[] = {
+	{AO_MF_IR_DEC_LDR_ACTIVE, ((unsigned)250 << 16) | ((unsigned)160 << 0)},	//rca leader 4000us,200* timebase
+	{AO_MF_IR_DEC_LDR_IDLE, 250 << 16 | 160 << 0},	// leader idle 400
+	{AO_MF_IR_DEC_LDR_REPEAT, 250 << 16 | 160 << 0},	// leader repeat
+	{AO_MF_IR_DEC_BIT_0, 100 << 16 | 48 << 0},	// logic '0' or '00' 1500us
+	{AO_MF_IR_DEC_REG0, 3 << 28 | (0xFA0 << 12) | 0x13},	// sys clock boby time.base time = 20 body frame
+	{AO_MF_IR_DEC_STATUS, (150 << 20) | (110 << 10)},	// logic '1' or '01'    2500us
+	{AO_MF_IR_DEC_REG1, 0x9740},	// boby long decode (8-13) //framn len = 24bit
+	/*it may get the wrong customer value and key value from register if the value is set to 0x4,so the register value must set to 0x104 */
+	{AO_MF_IR_DEC_REG2, 0x104},
+	{AO_MF_IR_DEC_DURATN2, 0},
+	{AO_MF_IR_DEC_DURATN3, 0},
+	{CONFIG_END, 0}
+};
+
+#endif
+
+static const reg_remote *remoteregsTab[] = {
+	RDECODEMODE_NEC,
+	RDECODEMODE_DUOKAN,
+	RDECODEMODE_TOSHIBA,
+	RDECODEMODE_RCA,
+};
+
+void setremotereg(const reg_remote * r)
+{
+	writel(r->val, r->reg);
+}
+
+int set_remote_mode(int mode)
+{
+	const reg_remote *reg;
+	reg = remoteregsTab[mode];
+	while (CONFIG_END != reg->reg)
+		setremotereg(reg++);
+	return 0;
+}
+
+unsigned backuAO_RTI_PIN_MUX_REG;
+unsigned backuAO_IR_DEC_REG0;
+unsigned backuAO_IR_DEC_REG1;
+unsigned backuAO_IR_DEC_LDR_ACTIVE;
+unsigned backuAO_IR_DEC_LDR_IDLE;
+unsigned backuAO_IR_DEC_BIT_0;
+unsigned bakeuAO_IR_DEC_LDR_REPEAT;
+/*****************************************************************
+**
+** func : ir_remote_init
+**       in this function will do pin configuration and and initialize for
+**       IR Remote hardware decoder mode at 32kHZ on ARC.
+**
+********************************************************************/
+#if 1
+void backuremote_register(void)
+{
+	backuAO_RTI_PIN_MUX_REG = readl(AO_RTI_PIN_MUX_REG);
+	backuAO_IR_DEC_REG0 = readl(AO_MF_IR_DEC_REG0);
+	backuAO_IR_DEC_REG1 = readl(AO_MF_IR_DEC_REG1);
+	backuAO_IR_DEC_LDR_ACTIVE = readl(AO_MF_IR_DEC_LDR_ACTIVE);
+	backuAO_IR_DEC_LDR_IDLE = readl(AO_MF_IR_DEC_LDR_IDLE);
+	backuAO_IR_DEC_BIT_0 = readl(AO_MF_IR_DEC_BIT_0);
+	bakeuAO_IR_DEC_LDR_REPEAT = readl(AO_MF_IR_DEC_LDR_REPEAT);
+}
+
+void resume_remote_register(void)
+{
+	writel(backuAO_RTI_PIN_MUX_REG, AO_RTI_PIN_MUX_REG);
+	writel(backuAO_IR_DEC_REG0, AO_MF_IR_DEC_REG0);
+	writel(backuAO_IR_DEC_REG1, AO_MF_IR_DEC_REG1);
+	writel(backuAO_IR_DEC_LDR_ACTIVE, AO_MF_IR_DEC_LDR_ACTIVE);
+	writel(backuAO_IR_DEC_LDR_IDLE, AO_MF_IR_DEC_LDR_IDLE);
+	writel(backuAO_IR_DEC_BIT_0, AO_MF_IR_DEC_BIT_0);
+	writel(bakeuAO_IR_DEC_LDR_REPEAT, AO_MF_IR_DEC_LDR_REPEAT);
+	readl(AO_MF_IR_DEC_FRAME);
+}
+
+static int ir_remote_init_32k_mode(void)
+{
+	//volatile unsigned int status,data_value;
+	int val = readl(AO_RTI_PIN_MUX_REG);
+	writel((val | (1 << 0)), AO_RTI_PIN_MUX_REG);
+	set_remote_mode(0);
+	//status = readl(AO_MF_IR_DEC_STATUS);
+	readl(AO_MF_IR_DEC_STATUS);
+	//data_value = readl(AO_MF_IR_DEC_FRAME);
+	readl(AO_MF_IR_DEC_FRAME);
+
+	//step 2 : request nec_remote irq  & enable it
+	return 0;
+}
+
+void init_custom_trigger(void)
+{
+	ir_remote_init_32k_mode();
+}
+#endif
+
+static unsigned int kk[] = {
+	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL1,
+	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL2,
+	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL3,
+	CONFIG_IR_REMOTE_POWER_UP_KEY_VAL4,
+};
+
+static int init_remote(void)
+{
+	uart_put_hex(readl(AO_IR_DEC_STATUS), 32);
+	uart_put_hex(readl(AO_IR_DEC_FRAME), 32);
+	init_custom_trigger();
+	return 0;
+}
+
+unsigned int usr_pwr_key = CONFIG_IR_REMOTE_POWER_UP_KEY_VAL5;
+
+static int remote_detect_key(void)
+{
+	unsigned power_key;
+	int j;
+#if 0
+	if (((readl(AO_IR_DEC_STATUS)) >> 3) & 0x1) {
+		power_key = readl(AO_IR_DEC_FRAME);
+		if ((power_key & IR_POWER_KEY_MASK) == kk[j])
+			return 1;
+
+	}
+#endif
+	if (((readl(AO_MF_IR_DEC_STATUS)) >> 3) & 0x1) {
+		power_key = readl(AO_MF_IR_DEC_FRAME);
+		for (j = 0; j < CONFIG_IR_REMOTE_POWER_UP_KEY_CNT; j++) {
+			if ((power_key & IR_POWER_KEY_MASK) == kk[j]) {
+				return 1;
+			}
+			if (((power_key&IR_POWER_KEY_MASK) == usr_pwr_key))
+				return 2;
+		}
+	}
+	return 0;
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/secure_apb.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/secure_apb.h
new file mode 100644
index 0000000..c0cc3e9
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/secure_apb.h
@@ -0,0 +1,2038 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/secure_apb.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __SECURE_APB_H_
+#define __SECURE_APB_H_
+
+//========================================================================
+//  RNG
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8834000
+//  APB4_DECODER_SECURE_BASE         32'hDA834000
+//  Non Secure Register
+#define     RNG_DATA                                           (0xc8834000 + (0x00 << 2))
+#define SEC_RNG_DATA                                           (0xda834000 + (0x00 << 2))
+#define   P_RNG_DATA                                           (volatile uint32_t *)(0xc8834000 + (0x00 << 2))
+//  Secure Register
+#define     RNG_SEC_CONFIG_REG1                                (0xc8834000 + (0x01 << 2))
+#define SEC_RNG_SEC_CONFIG_REG1                                (0xda834000 + (0x01 << 2))
+#define   P_RNG_SEC_CONFIG_REG1                                (volatile uint32_t *)(0xc8834000 + (0x01 << 2))
+#define     RNG_SEC_CONFIG_REG2                                (0xc8834000 + (0x02 << 2))
+#define SEC_RNG_SEC_CONFIG_REG2                                (0xda834000 + (0x02 << 2))
+#define   P_RNG_SEC_CONFIG_REG2                                (volatile uint32_t *)(0xc8834000 + (0x02 << 2))
+#define     RNG_SEC_SCRATCH_REG                                (0xc8834000 + (0x03 << 2))
+#define SEC_RNG_SEC_SCRATCH_REG                                (0xda834000 + (0x03 << 2))
+#define   P_RNG_SEC_SCRATCH_REG                                (volatile uint32_t *)(0xc8834000 + (0x03 << 2))
+//========================================================================
+//  PERIPHS
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8834400
+//  APB4_DECODER_SECURE_BASE         32'hDA834400
+// The following are handled by $periphs/rtl/periphs_reg.v
+#define     PREG_CTLREG0_ADDR                                  (0xc8834400 + (0x00 << 2))
+#define SEC_PREG_CTLREG0_ADDR                                  (0xda834400 + (0x00 << 2))
+#define   P_PREG_CTLREG0_ADDR                                  (volatile uint32_t *)(0xc8834400 + (0x00 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO6_EN_N                                (0xc8834400 + (0x08 << 2))
+#define SEC_PREG_PAD_GPIO6_EN_N                                (0xda834400 + (0x08 << 2))
+#define   P_PREG_PAD_GPIO6_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x08 << 2))
+#define     PREG_PAD_GPIO6_O                                   (0xc8834400 + (0x09 << 2))
+#define SEC_PREG_PAD_GPIO6_O                                   (0xda834400 + (0x09 << 2))
+#define   P_PREG_PAD_GPIO6_O                                   (volatile uint32_t *)(0xc8834400 + (0x09 << 2))
+#define     PREG_PAD_GPIO6_I                                   (0xc8834400 + (0x0a << 2))
+#define SEC_PREG_PAD_GPIO6_I                                   (0xda834400 + (0x0a << 2))
+#define   P_PREG_PAD_GPIO6_I                                   (volatile uint32_t *)(0xc8834400 + (0x0a << 2))
+// ----------------------------
+// ----------------------------
+#define     PREG_JTAG_GPIO_ADDR                                (0xc8834400 + (0x0b << 2))
+#define SEC_PREG_JTAG_GPIO_ADDR                                (0xda834400 + (0x0b << 2))
+#define   P_PREG_JTAG_GPIO_ADDR                                (volatile uint32_t *)(0xc8834400 + (0x0b << 2))
+// ----------------------------
+// Pre-defined GPIO addresses
+// ----------------------------
+#define     PREG_PAD_GPIO0_EN_N                                (0xc8834400 + (0x0c << 2))
+#define SEC_PREG_PAD_GPIO0_EN_N                                (0xda834400 + (0x0c << 2))
+#define   P_PREG_PAD_GPIO0_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x0c << 2))
+#define     PREG_PAD_GPIO0_O                                   (0xc8834400 + (0x0d << 2))
+#define SEC_PREG_PAD_GPIO0_O                                   (0xda834400 + (0x0d << 2))
+#define   P_PREG_PAD_GPIO0_O                                   (volatile uint32_t *)(0xc8834400 + (0x0d << 2))
+#define     PREG_PAD_GPIO0_I                                   (0xc8834400 + (0x0e << 2))
+#define SEC_PREG_PAD_GPIO0_I                                   (0xda834400 + (0x0e << 2))
+#define   P_PREG_PAD_GPIO0_I                                   (volatile uint32_t *)(0xc8834400 + (0x0e << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO1_EN_N                                (0xc8834400 + (0x0f << 2))
+#define SEC_PREG_PAD_GPIO1_EN_N                                (0xda834400 + (0x0f << 2))
+#define   P_PREG_PAD_GPIO1_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x0f << 2))
+#define     PREG_PAD_GPIO1_O                                   (0xc8834400 + (0x10 << 2))
+#define SEC_PREG_PAD_GPIO1_O                                   (0xda834400 + (0x10 << 2))
+#define   P_PREG_PAD_GPIO1_O                                   (volatile uint32_t *)(0xc8834400 + (0x10 << 2))
+#define     PREG_PAD_GPIO1_I                                   (0xc8834400 + (0x11 << 2))
+#define SEC_PREG_PAD_GPIO1_I                                   (0xda834400 + (0x11 << 2))
+#define   P_PREG_PAD_GPIO1_I                                   (volatile uint32_t *)(0xc8834400 + (0x11 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO2_EN_N                                (0xc8834400 + (0x12 << 2))
+#define SEC_PREG_PAD_GPIO2_EN_N                                (0xda834400 + (0x12 << 2))
+#define   P_PREG_PAD_GPIO2_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x12 << 2))
+#define     PREG_PAD_GPIO2_O                                   (0xc8834400 + (0x13 << 2))
+#define SEC_PREG_PAD_GPIO2_O                                   (0xda834400 + (0x13 << 2))
+#define   P_PREG_PAD_GPIO2_O                                   (volatile uint32_t *)(0xc8834400 + (0x13 << 2))
+#define     PREG_PAD_GPIO2_I                                   (0xc8834400 + (0x14 << 2))
+#define SEC_PREG_PAD_GPIO2_I                                   (0xda834400 + (0x14 << 2))
+#define   P_PREG_PAD_GPIO2_I                                   (volatile uint32_t *)(0xc8834400 + (0x14 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO3_EN_N                                (0xc8834400 + (0x15 << 2))
+#define SEC_PREG_PAD_GPIO3_EN_N                                (0xda834400 + (0x15 << 2))
+#define   P_PREG_PAD_GPIO3_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x15 << 2))
+#define     PREG_PAD_GPIO3_O                                   (0xc8834400 + (0x16 << 2))
+#define SEC_PREG_PAD_GPIO3_O                                   (0xda834400 + (0x16 << 2))
+#define   P_PREG_PAD_GPIO3_O                                   (volatile uint32_t *)(0xc8834400 + (0x16 << 2))
+#define     PREG_PAD_GPIO3_I                                   (0xc8834400 + (0x17 << 2))
+#define SEC_PREG_PAD_GPIO3_I                                   (0xda834400 + (0x17 << 2))
+#define   P_PREG_PAD_GPIO3_I                                   (volatile uint32_t *)(0xc8834400 + (0x17 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO4_EN_N                                (0xc8834400 + (0x18 << 2))
+#define SEC_PREG_PAD_GPIO4_EN_N                                (0xda834400 + (0x18 << 2))
+#define   P_PREG_PAD_GPIO4_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x18 << 2))
+#define     PREG_PAD_GPIO4_O                                   (0xc8834400 + (0x19 << 2))
+#define SEC_PREG_PAD_GPIO4_O                                   (0xda834400 + (0x19 << 2))
+#define   P_PREG_PAD_GPIO4_O                                   (volatile uint32_t *)(0xc8834400 + (0x19 << 2))
+#define     PREG_PAD_GPIO4_I                                   (0xc8834400 + (0x1a << 2))
+#define SEC_PREG_PAD_GPIO4_I                                   (0xda834400 + (0x1a << 2))
+#define   P_PREG_PAD_GPIO4_I                                   (volatile uint32_t *)(0xc8834400 + (0x1a << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO5_EN_N                                (0xc8834400 + (0x1b << 2))
+#define SEC_PREG_PAD_GPIO5_EN_N                                (0xda834400 + (0x1b << 2))
+#define   P_PREG_PAD_GPIO5_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x1b << 2))
+#define     PREG_PAD_GPIO5_O                                   (0xc8834400 + (0x1c << 2))
+#define SEC_PREG_PAD_GPIO5_O                                   (0xda834400 + (0x1c << 2))
+#define   P_PREG_PAD_GPIO5_O                                   (volatile uint32_t *)(0xc8834400 + (0x1c << 2))
+#define     PREG_PAD_GPIO5_I                                   (0xc8834400 + (0x1d << 2))
+#define SEC_PREG_PAD_GPIO5_I                                   (0xda834400 + (0x1d << 2))
+#define   P_PREG_PAD_GPIO5_I                                   (volatile uint32_t *)(0xc8834400 + (0x1d << 2))
+// ----------------------------
+// ----------------------------
+// Pin Mux  (9)
+// ----------------------------
+#define     PERIPHS_PIN_MUX_0                                  (0xc8834400 + (0x2c << 2))
+#define SEC_PERIPHS_PIN_MUX_0                                  (0xda834400 + (0x2c << 2))
+#define   P_PERIPHS_PIN_MUX_0                                  (volatile uint32_t *)(0xc8834400 + (0x2c << 2))
+#define     PERIPHS_PIN_MUX_1                                  (0xc8834400 + (0x2d << 2))
+#define SEC_PERIPHS_PIN_MUX_1                                  (0xda834400 + (0x2d << 2))
+#define   P_PERIPHS_PIN_MUX_1                                  (volatile uint32_t *)(0xc8834400 + (0x2d << 2))
+#define     PERIPHS_PIN_MUX_2                                  (0xc8834400 + (0x2e << 2))
+#define SEC_PERIPHS_PIN_MUX_2                                  (0xda834400 + (0x2e << 2))
+#define   P_PERIPHS_PIN_MUX_2                                  (volatile uint32_t *)(0xc8834400 + (0x2e << 2))
+#define     PERIPHS_PIN_MUX_3                                  (0xc8834400 + (0x2f << 2))
+#define SEC_PERIPHS_PIN_MUX_3                                  (0xda834400 + (0x2f << 2))
+#define   P_PERIPHS_PIN_MUX_3                                  (volatile uint32_t *)(0xc8834400 + (0x2f << 2))
+#define     PERIPHS_PIN_MUX_4                                  (0xc8834400 + (0x30 << 2))
+#define SEC_PERIPHS_PIN_MUX_4                                  (0xda834400 + (0x30 << 2))
+#define   P_PERIPHS_PIN_MUX_4                                  (volatile uint32_t *)(0xc8834400 + (0x30 << 2))
+#define     PERIPHS_PIN_MUX_5                                  (0xc8834400 + (0x31 << 2))
+#define SEC_PERIPHS_PIN_MUX_5                                  (0xda834400 + (0x31 << 2))
+#define   P_PERIPHS_PIN_MUX_5                                  (volatile uint32_t *)(0xc8834400 + (0x31 << 2))
+#define     PERIPHS_PIN_MUX_6                                  (0xc8834400 + (0x32 << 2))
+#define SEC_PERIPHS_PIN_MUX_6                                  (0xda834400 + (0x32 << 2))
+#define   P_PERIPHS_PIN_MUX_6                                  (volatile uint32_t *)(0xc8834400 + (0x32 << 2))
+#define     PERIPHS_PIN_MUX_7                                  (0xc8834400 + (0x33 << 2))
+#define SEC_PERIPHS_PIN_MUX_7                                  (0xda834400 + (0x33 << 2))
+#define   P_PERIPHS_PIN_MUX_7                                  (volatile uint32_t *)(0xc8834400 + (0x33 << 2))
+#define     PERIPHS_PIN_MUX_8                                  (0xc8834400 + (0x34 << 2))
+#define SEC_PERIPHS_PIN_MUX_8                                  (0xda834400 + (0x34 << 2))
+#define   P_PERIPHS_PIN_MUX_8                                  (volatile uint32_t *)(0xc8834400 + (0x34 << 2))
+#define     PERIPHS_PIN_MUX_9                                  (0xc8834400 + (0x35 << 2))
+#define SEC_PERIPHS_PIN_MUX_9                                  (0xda834400 + (0x35 << 2))
+#define   P_PERIPHS_PIN_MUX_9                                  (volatile uint32_t *)(0xc8834400 + (0x35 << 2))
+#define     PERIPHS_PIN_MUX_10                                 (0xc8834400 + (0x36 << 2))
+#define SEC_PERIPHS_PIN_MUX_10                                 (0xda834400 + (0x36 << 2))
+#define   P_PERIPHS_PIN_MUX_10                                 (volatile uint32_t *)(0xc8834400 + (0x36 << 2))
+#define     PERIPHS_PIN_MUX_11                                 (0xc8834400 + (0x37 << 2))
+#define SEC_PERIPHS_PIN_MUX_11                                 (0xda834400 + (0x37 << 2))
+#define   P_PERIPHS_PIN_MUX_11                                 (volatile uint32_t *)(0xc8834400 + (0x37 << 2))
+#define     PERIPHS_PIN_MUX_12                                 (0xc8834400 + (0x38 << 2))
+#define SEC_PERIPHS_PIN_MUX_12                                 (0xda834400 + (0x38 << 2))
+#define   P_PERIPHS_PIN_MUX_12                                 (volatile uint32_t *)(0xc8834400 + (0x38 << 2))
+// ----------------------------
+// Pad conntrols
+// ----------------------------
+#define     PAD_PULL_UP_REG6                                   (0xc8834400 + (0x39 << 2))
+#define SEC_PAD_PULL_UP_REG6                                   (0xda834400 + (0x39 << 2))
+#define   P_PAD_PULL_UP_REG6                                   (volatile uint32_t *)(0xc8834400 + (0x39 << 2))
+#define     PAD_PULL_UP_REG0                                   (0xc8834400 + (0x3a << 2))
+#define SEC_PAD_PULL_UP_REG0                                   (0xda834400 + (0x3a << 2))
+#define   P_PAD_PULL_UP_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x3a << 2))
+#define     PAD_PULL_UP_REG1                                   (0xc8834400 + (0x3b << 2))
+#define SEC_PAD_PULL_UP_REG1                                   (0xda834400 + (0x3b << 2))
+#define   P_PAD_PULL_UP_REG1                                   (volatile uint32_t *)(0xc8834400 + (0x3b << 2))
+#define     PAD_PULL_UP_REG2                                   (0xc8834400 + (0x3c << 2))
+#define SEC_PAD_PULL_UP_REG2                                   (0xda834400 + (0x3c << 2))
+#define   P_PAD_PULL_UP_REG2                                   (volatile uint32_t *)(0xc8834400 + (0x3c << 2))
+#define     PAD_PULL_UP_REG3                                   (0xc8834400 + (0x3d << 2))
+#define SEC_PAD_PULL_UP_REG3                                   (0xda834400 + (0x3d << 2))
+#define   P_PAD_PULL_UP_REG3                                   (volatile uint32_t *)(0xc8834400 + (0x3d << 2))
+#define     PAD_PULL_UP_REG4                                   (0xc8834400 + (0x3e << 2))
+#define SEC_PAD_PULL_UP_REG4                                   (0xda834400 + (0x3e << 2))
+#define   P_PAD_PULL_UP_REG4                                   (volatile uint32_t *)(0xc8834400 + (0x3e << 2))
+#define     PAD_PULL_UP_REG5                                   (0xc8834400 + (0x3f << 2))
+#define SEC_PAD_PULL_UP_REG5                                   (0xda834400 + (0x3f << 2))
+#define   P_PAD_PULL_UP_REG5                                   (volatile uint32_t *)(0xc8834400 + (0x3f << 2))
+// ----------------------------
+// Random (2)
+// ----------------------------
+#define     RAND64_ADDR0                                       (0xc8834400 + (0x40 << 2))
+#define SEC_RAND64_ADDR0                                       (0xda834400 + (0x40 << 2))
+#define   P_RAND64_ADDR0                                       (volatile uint32_t *)(0xc8834400 + (0x40 << 2))
+#define     RAND64_ADDR1                                       (0xc8834400 + (0x41 << 2))
+#define SEC_RAND64_ADDR1                                       (0xda834400 + (0x41 << 2))
+#define   P_RAND64_ADDR1                                       (volatile uint32_t *)(0xc8834400 + (0x41 << 2))
+// ---------------------------
+// Ethernet (1)
+// ----------------------------
+#define     PREG_ETHERNET_ADDR0                                (0xc8834400 + (0x42 << 2))
+#define SEC_PREG_ETHERNET_ADDR0                                (0xda834400 + (0x42 << 2))
+#define   P_PREG_ETHERNET_ADDR0                                (volatile uint32_t *)(0xc8834400 + (0x42 << 2))
+// ---------------------------
+// AM_ANALOG_TOP
+// ----------------------------
+#define     PREG_AM_ANALOG_ADDR                                (0xc8834400 + (0x43 << 2))
+#define SEC_PREG_AM_ANALOG_ADDR                                (0xda834400 + (0x43 << 2))
+#define   P_PREG_AM_ANALOG_ADDR                                (volatile uint32_t *)(0xc8834400 + (0x43 << 2))
+// ---------------------------
+// Mali55 (1)
+// ----------------------------
+#define     PREG_MALI_BYTE_CNTL                                (0xc8834400 + (0x44 << 2))
+#define SEC_PREG_MALI_BYTE_CNTL                                (0xda834400 + (0x44 << 2))
+#define   P_PREG_MALI_BYTE_CNTL                                (volatile uint32_t *)(0xc8834400 + (0x44 << 2))
+// ---------------------------
+// WIFI (1)
+// ----------------------------
+#define     PREG_WIFI_CNTL                                     (0xc8834400 + (0x45 << 2))
+#define SEC_PREG_WIFI_CNTL                                     (0xda834400 + (0x45 << 2))
+#define   P_PREG_WIFI_CNTL                                     (volatile uint32_t *)(0xc8834400 + (0x45 << 2))
+#define     PAD_PULL_UP_EN_REG0                                (0xc8834400 + (0x48 << 2))
+#define SEC_PAD_PULL_UP_EN_REG0                                (0xda834400 + (0x48 << 2))
+#define   P_PAD_PULL_UP_EN_REG0                                (volatile uint32_t *)(0xc8834400 + (0x48 << 2))
+#define     PAD_PULL_UP_EN_REG1                                (0xc8834400 + (0x49 << 2))
+#define SEC_PAD_PULL_UP_EN_REG1                                (0xda834400 + (0x49 << 2))
+#define   P_PAD_PULL_UP_EN_REG1                                (volatile uint32_t *)(0xc8834400 + (0x49 << 2))
+#define     PAD_PULL_UP_EN_REG2                                (0xc8834400 + (0x4a << 2))
+#define SEC_PAD_PULL_UP_EN_REG2                                (0xda834400 + (0x4a << 2))
+#define   P_PAD_PULL_UP_EN_REG2                                (volatile uint32_t *)(0xc8834400 + (0x4a << 2))
+#define     PAD_PULL_UP_EN_REG3                                (0xc8834400 + (0x4b << 2))
+#define SEC_PAD_PULL_UP_EN_REG3                                (0xda834400 + (0x4b << 2))
+#define   P_PAD_PULL_UP_EN_REG3                                (volatile uint32_t *)(0xc8834400 + (0x4b << 2))
+#define     PAD_PULL_UP_EN_REG4                                (0xc8834400 + (0x4c << 2))
+#define SEC_PAD_PULL_UP_EN_REG4                                (0xda834400 + (0x4c << 2))
+#define   P_PAD_PULL_UP_EN_REG4                                (volatile uint32_t *)(0xc8834400 + (0x4c << 2))
+#define     PAD_PULL_UP_EN_REG5                                (0xc8834400 + (0x4d << 2))
+#define SEC_PAD_PULL_UP_EN_REG5                                (0xda834400 + (0x4d << 2))
+#define   P_PAD_PULL_UP_EN_REG5                                (volatile uint32_t *)(0xc8834400 + (0x4d << 2))
+#define     PAD_PULL_UP_EN_REG6                                (0xc8834400 + (0x4e << 2))
+#define SEC_PAD_PULL_UP_EN_REG6                                (0xda834400 + (0x4e << 2))
+#define   P_PAD_PULL_UP_EN_REG6                                (volatile uint32_t *)(0xc8834400 + (0x4e << 2))
+// ---------------------------
+#define     PREG_ETH_REG0                                      (0xc8834400 + (0x50 << 2))
+#define SEC_PREG_ETH_REG0                                      (0xda834400 + (0x50 << 2))
+#define   P_PREG_ETH_REG0                                      (volatile uint32_t *)(0xc8834400 + (0x50 << 2))
+#define     PREG_ETH_REG1                                      (0xc8834400 + (0x51 << 2))
+#define SEC_PREG_ETH_REG1                                      (0xda834400 + (0x51 << 2))
+#define   P_PREG_ETH_REG1                                      (volatile uint32_t *)(0xc8834400 + (0x51 << 2))
+#define     PREG_NAND_CFG_KEY0                                 (0xc8834400 + (0x52 << 2))
+#define SEC_PREG_NAND_CFG_KEY0                                 (0xda834400 + (0x52 << 2))
+#define   P_PREG_NAND_CFG_KEY0                                 (volatile uint32_t *)(0xc8834400 + (0x52 << 2))
+#define     PREG_NAND_CFG_KEY1                                 (0xc8834400 + (0x53 << 2))
+#define SEC_PREG_NAND_CFG_KEY1                                 (0xda834400 + (0x53 << 2))
+#define   P_PREG_NAND_CFG_KEY1                                 (volatile uint32_t *)(0xc8834400 + (0x53 << 2))
+#define     PREG_VPU_SECURE0                                   (0xc8834400 + (0x54 << 2))
+#define SEC_PREG_VPU_SECURE0                                   (0xda834400 + (0x54 << 2))
+#define   P_PREG_VPU_SECURE0                                   (volatile uint32_t *)(0xc8834400 + (0x54 << 2))
+#define     PREG_VPU_SECURE1                                   (0xc8834400 + (0x55 << 2))
+#define SEC_PREG_VPU_SECURE1                                   (0xda834400 + (0x55 << 2))
+#define   P_PREG_VPU_SECURE1                                   (volatile uint32_t *)(0xc8834400 + (0x55 << 2))
+// ---------------------------
+// Generic production test
+// ----------------------------
+#define     PROD_TEST_REG0                                     (0xc8834400 + (0x60 << 2))
+#define SEC_PROD_TEST_REG0                                     (0xda834400 + (0x60 << 2))
+#define   P_PROD_TEST_REG0                                     (volatile uint32_t *)(0xc8834400 + (0x60 << 2))
+#define     PROD_TEST_REG1                                     (0xc8834400 + (0x61 << 2))
+#define SEC_PROD_TEST_REG1                                     (0xda834400 + (0x61 << 2))
+#define   P_PROD_TEST_REG1                                     (volatile uint32_t *)(0xc8834400 + (0x61 << 2))
+#define     PROD_TEST_REG2                                     (0xc8834400 + (0x62 << 2))
+#define SEC_PROD_TEST_REG2                                     (0xda834400 + (0x62 << 2))
+#define   P_PROD_TEST_REG2                                     (volatile uint32_t *)(0xc8834400 + (0x62 << 2))
+#define     PROD_TEST_REG3                                     (0xc8834400 + (0x63 << 2))
+#define SEC_PROD_TEST_REG3                                     (0xda834400 + (0x63 << 2))
+#define   P_PROD_TEST_REG3                                     (volatile uint32_t *)(0xc8834400 + (0x63 << 2))
+// ---------------------------
+// am_analog_top
+// ----------------------------
+#define     METAL_REVISION                                     (0xc8834400 + (0x6a << 2))
+#define SEC_METAL_REVISION                                     (0xda834400 + (0x6a << 2))
+#define   P_METAL_REVISION                                     (volatile uint32_t *)(0xc8834400 + (0x6a << 2))
+#define     ADC_TOP_MISC                                       (0xc8834400 + (0x6b << 2))
+#define SEC_ADC_TOP_MISC                                       (0xda834400 + (0x6b << 2))
+#define   P_ADC_TOP_MISC                                       (volatile uint32_t *)(0xc8834400 + (0x6b << 2))
+#define     DPLL_TOP_MISC                                      (0xc8834400 + (0x6c << 2))
+#define SEC_DPLL_TOP_MISC                                      (0xda834400 + (0x6c << 2))
+#define   P_DPLL_TOP_MISC                                      (volatile uint32_t *)(0xc8834400 + (0x6c << 2))
+#define     ANALOG_TOP_MISC                                    (0xc8834400 + (0x6d << 2))
+#define SEC_ANALOG_TOP_MISC                                    (0xda834400 + (0x6d << 2))
+#define   P_ANALOG_TOP_MISC                                    (volatile uint32_t *)(0xc8834400 + (0x6d << 2))
+#define     AM_ANALOG_TOP_REG0                                 (0xc8834400 + (0x6e << 2))
+#define SEC_AM_ANALOG_TOP_REG0                                 (0xda834400 + (0x6e << 2))
+#define   P_AM_ANALOG_TOP_REG0                                 (volatile uint32_t *)(0xc8834400 + (0x6e << 2))
+#define     AM_ANALOG_TOP_REG1                                 (0xc8834400 + (0x6f << 2))
+#define SEC_AM_ANALOG_TOP_REG1                                 (0xda834400 + (0x6f << 2))
+#define   P_AM_ANALOG_TOP_REG1                                 (volatile uint32_t *)(0xc8834400 + (0x6f << 2))
+// ---------------------------
+// Sticky regs
+// ----------------------------
+#define     PREG_STICKY_REG0                                   (0xc8834400 + (0x7c << 2))
+#define SEC_PREG_STICKY_REG0                                   (0xda834400 + (0x7c << 2))
+#define   P_PREG_STICKY_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x7c << 2))
+#define     PREG_STICKY_REG1                                   (0xc8834400 + (0x7d << 2))
+#define SEC_PREG_STICKY_REG1                                   (0xda834400 + (0x7d << 2))
+#define   P_PREG_STICKY_REG1                                   (volatile uint32_t *)(0xc8834400 + (0x7d << 2))
+#define     PREG_WRITE_ONCE_REG                                (0xc8834400 + (0x7e << 2))
+#define SEC_PREG_WRITE_ONCE_REG                                (0xda834400 + (0x7e << 2))
+#define   P_PREG_WRITE_ONCE_REG                                (volatile uint32_t *)(0xc8834400 + (0x7e << 2))
+// ---------------------------
+// AM Ring Oscillator
+// ----------------------------
+#define     AM_RING_OSC_REG0                                   (0xc8834400 + (0x7f << 2))
+#define SEC_AM_RING_OSC_REG0                                   (0xda834400 + (0x7f << 2))
+#define   P_AM_RING_OSC_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x7f << 2))
+// Control whether to provide random number to HDMITX20
+#define     HDMITX20_RNDNUM                                    (0xc8834400 + (0x80 << 2))
+#define SEC_HDMITX20_RNDNUM                                    (0xda834400 + (0x80 << 2))
+#define   P_HDMITX20_RNDNUM                                    (volatile uint32_t *)(0xc8834400 + (0x80 << 2))
+// ---------------------------
+// System CPU control registers
+// ----------------------------
+#define     SYS_CPU_POR_CFG0                                   (0xc8834400 + (0x90 << 2))
+#define SEC_SYS_CPU_POR_CFG0                                   (0xda834400 + (0x90 << 2))
+#define   P_SYS_CPU_POR_CFG0                                   (volatile uint32_t *)(0xc8834400 + (0x90 << 2))
+#define     SYS_CPU_POR_CFG1                                   (0xc8834400 + (0x91 << 2))
+#define SEC_SYS_CPU_POR_CFG1                                   (0xda834400 + (0x91 << 2))
+#define   P_SYS_CPU_POR_CFG1                                   (volatile uint32_t *)(0xc8834400 + (0x91 << 2))
+#define     SYS_CPU_CFG0                                       (0xc8834400 + (0x92 << 2))
+#define SEC_SYS_CPU_CFG0                                       (0xda834400 + (0x92 << 2))
+#define   P_SYS_CPU_CFG0                                       (volatile uint32_t *)(0xc8834400 + (0x92 << 2))
+#define     SYS_CPU_CFG1                                       (0xc8834400 + (0x93 << 2))
+#define SEC_SYS_CPU_CFG1                                       (0xda834400 + (0x93 << 2))
+#define   P_SYS_CPU_CFG1                                       (volatile uint32_t *)(0xc8834400 + (0x93 << 2))
+#define     SYS_CPU_CFG2                                       (0xc8834400 + (0x94 << 2))
+#define SEC_SYS_CPU_CFG2                                       (0xda834400 + (0x94 << 2))
+#define   P_SYS_CPU_CFG2                                       (volatile uint32_t *)(0xc8834400 + (0x94 << 2))
+#define     SYS_CPU_CFG3                                       (0xc8834400 + (0x95 << 2))
+#define SEC_SYS_CPU_CFG3                                       (0xda834400 + (0x95 << 2))
+#define   P_SYS_CPU_CFG3                                       (volatile uint32_t *)(0xc8834400 + (0x95 << 2))
+#define     SYS_CPU_CFG4                                       (0xc8834400 + (0x96 << 2))
+#define SEC_SYS_CPU_CFG4                                       (0xda834400 + (0x96 << 2))
+#define   P_SYS_CPU_CFG4                                       (volatile uint32_t *)(0xc8834400 + (0x96 << 2))
+#define     SYS_CPU_CFG5                                       (0xc8834400 + (0x97 << 2))
+#define SEC_SYS_CPU_CFG5                                       (0xda834400 + (0x97 << 2))
+#define   P_SYS_CPU_CFG5                                       (volatile uint32_t *)(0xc8834400 + (0x97 << 2))
+#define     SYS_CPU_CFG6                                       (0xc8834400 + (0x98 << 2))
+#define SEC_SYS_CPU_CFG6                                       (0xda834400 + (0x98 << 2))
+#define   P_SYS_CPU_CFG6                                       (volatile uint32_t *)(0xc8834400 + (0x98 << 2))
+#define     SYS_CPU_CFG7                                       (0xc8834400 + (0x99 << 2))
+#define SEC_SYS_CPU_CFG7                                       (0xda834400 + (0x99 << 2))
+#define   P_SYS_CPU_CFG7                                       (volatile uint32_t *)(0xc8834400 + (0x99 << 2))
+#define     SYS_CPU_CFG8                                       (0xc8834400 + (0x9a << 2))
+#define SEC_SYS_CPU_CFG8                                       (0xda834400 + (0x9a << 2))
+#define   P_SYS_CPU_CFG8                                       (volatile uint32_t *)(0xc8834400 + (0x9a << 2))
+#define     SYS_CPU_CFG9                                       (0xc8834400 + (0x9b << 2))
+#define SEC_SYS_CPU_CFG9                                       (0xda834400 + (0x9b << 2))
+#define   P_SYS_CPU_CFG9                                       (volatile uint32_t *)(0xc8834400 + (0x9b << 2))
+#define     SYS_CPU_CFG10                                      (0xc8834400 + (0x9c << 2))
+#define SEC_SYS_CPU_CFG10                                      (0xda834400 + (0x9c << 2))
+#define   P_SYS_CPU_CFG10                                      (volatile uint32_t *)(0xc8834400 + (0x9c << 2))
+#define     SYS_CPU_CFG11                                      (0xc8834400 + (0x9d << 2))
+#define SEC_SYS_CPU_CFG11                                      (0xda834400 + (0x9d << 2))
+#define   P_SYS_CPU_CFG11                                      (volatile uint32_t *)(0xc8834400 + (0x9d << 2))
+#define     SYS_CPU_CFG12                                      (0xc8834400 + (0x9e << 2))
+#define SEC_SYS_CPU_CFG12                                      (0xda834400 + (0x9e << 2))
+#define   P_SYS_CPU_CFG12                                      (volatile uint32_t *)(0xc8834400 + (0x9e << 2))
+#define     SYS_CPU_CFG13                                      (0xc8834400 + (0x9f << 2))
+#define SEC_SYS_CPU_CFG13                                      (0xda834400 + (0x9f << 2))
+#define   P_SYS_CPU_CFG13                                      (volatile uint32_t *)(0xc8834400 + (0x9f << 2))
+#define     SYS_CPU_STATUS0                                    (0xc8834400 + (0xa0 << 2))
+#define SEC_SYS_CPU_STATUS0                                    (0xda834400 + (0xa0 << 2))
+#define   P_SYS_CPU_STATUS0                                    (volatile uint32_t *)(0xc8834400 + (0xa0 << 2))
+#define     SYS_CPU_STATUS1                                    (0xc8834400 + (0xa1 << 2))
+#define SEC_SYS_CPU_STATUS1                                    (0xda834400 + (0xa1 << 2))
+#define   P_SYS_CPU_STATUS1                                    (volatile uint32_t *)(0xc8834400 + (0xa1 << 2))
+#define     SYS_CPU_STATUS2                                    (0xc8834400 + (0xa2 << 2))
+#define SEC_SYS_CPU_STATUS2                                    (0xda834400 + (0xa2 << 2))
+#define   P_SYS_CPU_STATUS2                                    (volatile uint32_t *)(0xc8834400 + (0xa2 << 2))
+#define     SYS_CPU_STATUS3                                    (0xc8834400 + (0xa3 << 2))
+#define SEC_SYS_CPU_STATUS3                                    (0xda834400 + (0xa3 << 2))
+#define   P_SYS_CPU_STATUS3                                    (volatile uint32_t *)(0xc8834400 + (0xa3 << 2))
+#define     SYS_CPU_STATUS4                                    (0xc8834400 + (0xa4 << 2))
+#define SEC_SYS_CPU_STATUS4                                    (0xda834400 + (0xa4 << 2))
+#define   P_SYS_CPU_STATUS4                                    (volatile uint32_t *)(0xc8834400 + (0xa4 << 2))
+#define     SYS_CPU_STATUS5                                    (0xc8834400 + (0xa5 << 2))
+#define SEC_SYS_CPU_STATUS5                                    (0xda834400 + (0xa5 << 2))
+#define   P_SYS_CPU_STATUS5                                    (volatile uint32_t *)(0xc8834400 + (0xa5 << 2))
+#define     SYS_CPU_MISC                                       (0xc8834400 + (0xa8 << 2))
+#define SEC_SYS_CPU_MISC                                       (0xda834400 + (0xa8 << 2))
+#define   P_SYS_CPU_MISC                                       (volatile uint32_t *)(0xc8834400 + (0xa8 << 2))
+//========================================================================
+//  HIU - Registers
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hC883C000
+// APB4_DECODER_SECURE_BASE         32'hDA83C000
+#define     SCR_HIU                                            (0xc883c000 + (0x0b << 2))
+#define SEC_SCR_HIU                                            (0xda83c000 + (0x0b << 2))
+#define   P_SCR_HIU                                            (volatile uint32_t *)(0xc883c000 + (0x0b << 2))
+#define     HPG_TIMER                                          (0xc883c000 + (0x0f << 2))
+#define SEC_HPG_TIMER                                          (0xda83c000 + (0x0f << 2))
+#define   P_HPG_TIMER                                          (volatile uint32_t *)(0xc883c000 + (0x0f << 2))
+#define     HHI_GP0_PLL_CNTL                                   (0xc883c000 + (0x10 << 2))
+#define SEC_HHI_GP0_PLL_CNTL                                   (0xda83c000 + (0x10 << 2))
+#define   P_HHI_GP0_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x10 << 2))
+#define     HHI_GP0_PLL_CNTL2                                  (0xc883c000 + (0x11 << 2))
+#define SEC_HHI_GP0_PLL_CNTL2                                  (0xda83c000 + (0x11 << 2))
+#define   P_HHI_GP0_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x11 << 2))
+#define     HHI_GP0_PLL_CNTL3                                  (0xc883c000 + (0x12 << 2))
+#define SEC_HHI_GP0_PLL_CNTL3                                  (0xda83c000 + (0x12 << 2))
+#define   P_HHI_GP0_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x12 << 2))
+#define     HHI_GP0_PLL_CNTL4                                  (0xc883c000 + (0x13 << 2))
+#define SEC_HHI_GP0_PLL_CNTL4                                  (0xda83c000 + (0x13 << 2))
+#define   P_HHI_GP0_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0x13 << 2))
+#define     HHI_GP0_PLL_CNTL5                                  (0xc883c000 + (0x14 << 2))
+#define SEC_HHI_GP0_PLL_CNTL5                                  (0xda83c000 + (0x14 << 2))
+#define   P_HHI_GP0_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x14 << 2))
+#define     HHI_GP1_PLL_CNTL                                   (0xc883c000 + (0x16 << 2))
+#define SEC_HHI_GP1_PLL_CNTL                                   (0xda83c000 + (0x16 << 2))
+#define   P_HHI_GP1_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x16 << 2))
+#define     HHI_GP1_PLL_CNTL2                                  (0xc883c000 + (0x17 << 2))
+#define SEC_HHI_GP1_PLL_CNTL2                                  (0xda83c000 + (0x17 << 2))
+#define   P_HHI_GP1_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x17 << 2))
+#define     HHI_GP1_PLL_CNTL3                                  (0xc883c000 + (0x18 << 2))
+#define SEC_HHI_GP1_PLL_CNTL3                                  (0xda83c000 + (0x18 << 2))
+#define   P_HHI_GP1_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x18 << 2))
+#define     HHI_GP1_PLL_CNTL4                                  (0xc883c000 + (0x19 << 2))
+#define SEC_HHI_GP1_PLL_CNTL4                                  (0xda83c000 + (0x19 << 2))
+#define   P_HHI_GP1_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0x19 << 2))
+#define     HHI_GP1_PLL_CNTL5                                  (0xc883c000 + (0x1a << 2))
+#define SEC_HHI_GP1_PLL_CNTL5                                  (0xda83c000 + (0x1a << 2))
+#define   P_HHI_GP1_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x1a << 2))
+#define     HHI_CADC_CNTL                                      (0xc883c000 + (0x20 << 2))
+#define SEC_HHI_CADC_CNTL                                      (0xda83c000 + (0x20 << 2))
+#define   P_HHI_CADC_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0x20 << 2))
+#define     HHI_CADC_CNTL2                                     (0xc883c000 + (0x21 << 2))
+#define SEC_HHI_CADC_CNTL2                                     (0xda83c000 + (0x21 << 2))
+#define   P_HHI_CADC_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0x21 << 2))
+#define     HHI_CADC_CNTL3                                     (0xc883c000 + (0x22 << 2))
+#define SEC_HHI_CADC_CNTL3                                     (0xda83c000 + (0x22 << 2))
+#define   P_HHI_CADC_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0x22 << 2))
+#define     HHI_CADC_CNTL4                                     (0xc883c000 + (0x23 << 2))
+#define SEC_HHI_CADC_CNTL4                                     (0xda83c000 + (0x23 << 2))
+#define   P_HHI_CADC_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0x23 << 2))
+#define     HHI_CADC_CNTL5                                     (0xc883c000 + (0x24 << 2))
+#define SEC_HHI_CADC_CNTL5                                     (0xda83c000 + (0x24 << 2))
+#define   P_HHI_CADC_CNTL5                                     (volatile uint32_t *)(0xc883c000 + (0x24 << 2))
+#define     HHI_CADC_CNTL6                                     (0xc883c000 + (0x25 << 2))
+#define SEC_HHI_CADC_CNTL6                                     (0xda83c000 + (0x25 << 2))
+#define   P_HHI_CADC_CNTL6                                     (volatile uint32_t *)(0xc883c000 + (0x25 << 2))
+#define     HHI_DADC_CNTL                                      (0xc883c000 + (0x27 << 2))
+#define SEC_HHI_DADC_CNTL                                      (0xda83c000 + (0x27 << 2))
+#define   P_HHI_DADC_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0x27 << 2))
+#define     HHI_DADC_CNTL2                                     (0xc883c000 + (0x28 << 2))
+#define SEC_HHI_DADC_CNTL2                                     (0xda83c000 + (0x28 << 2))
+#define   P_HHI_DADC_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0x28 << 2))
+#define     HHI_DADC_RDBK0_I                                   (0xc883c000 + (0x29 << 2))
+#define SEC_HHI_DADC_RDBK0_I                                   (0xda83c000 + (0x29 << 2))
+#define   P_HHI_DADC_RDBK0_I                                   (volatile uint32_t *)(0xc883c000 + (0x29 << 2))
+#define     HHI_DADC_CNTL3                                     (0xc883c000 + (0x2a << 2))
+#define SEC_HHI_DADC_CNTL3                                     (0xda83c000 + (0x2a << 2))
+#define   P_HHI_DADC_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0x2a << 2))
+#define     HHI_DADC_CNTL4                                     (0xc883c000 + (0x2b << 2))
+#define SEC_HHI_DADC_CNTL4                                     (0xda83c000 + (0x2b << 2))
+#define   P_HHI_DADC_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0x2b << 2))
+#define     HHI_XTAL_DIVN_CNTL                                 (0xc883c000 + (0x2f << 2))
+#define SEC_HHI_XTAL_DIVN_CNTL                                 (0xda83c000 + (0x2f << 2))
+#define   P_HHI_XTAL_DIVN_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x2f << 2))
+#define     HHI_TIMER90K                                       (0xc883c000 + (0x3b << 2))
+#define SEC_HHI_TIMER90K                                       (0xda83c000 + (0x3b << 2))
+#define   P_HHI_TIMER90K                                       (volatile uint32_t *)(0xc883c000 + (0x3b << 2))
+#define     HHI_MEM_PD_REG0                                    (0xc883c000 + (0x40 << 2))
+#define SEC_HHI_MEM_PD_REG0                                    (0xda83c000 + (0x40 << 2))
+#define   P_HHI_MEM_PD_REG0                                    (volatile uint32_t *)(0xc883c000 + (0x40 << 2))
+//VIU1
+//bit 29:28 mem_pd_vi_sharp,  2'b00: Sharpness line buffer memory power on, 2'b11: power down
+//bit 29:28 mem_pd_vi_dipost, 2'b00: Deinterlace - di_post memory power on, 2'b11: power down
+//bit 27:26 mem_pd_vi_dipre,  2'b00: Deinterlace - di_pre memory power on, 2'b11: power down
+//bit 25:24 mem_pd_vi_prot3,  2'b00: picture rotation3 memory power on, 2'b11: power down
+//bit 23:22 mem_pd_vi_prot2,  2'b00: picture rotation2 memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vi_prot1,  2'b00: picture rotation1 memory power on, 2'b11: power down
+//bit 19:18 mem_pd_vi_vdin1,  2'b00: vdin1 memory power on, 2'b11: power down
+//bit 17:16 mem_pd_vi_vdin0,  2'b00: vdin0 memory power on, 2'b11: power down
+//bit 15:14 mem_pd_vi_osd_sc, 2'b00: osd_scaler memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi_scale,  2'b00: scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi_ofifo,  2'b00: vpp output fifo memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi_chroma, 2'b00: color management module memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi_vd2,    2'b00: vd2 memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi_vd1,    2'b00: vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi_osd2,   2'b00: osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi_osd1,   2'b00: osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG0                                (0xc883c000 + (0x41 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG0                                (0xda83c000 + (0x41 << 2))
+#define   P_HHI_VPU_MEM_PD_REG0                                (volatile uint32_t *)(0xc883c000 + (0x41 << 2))
+//bit 29:28 mem_pd_atv_dmd,   2'b00: ATV DMD memory power on, 2'b11: power down
+//bit 29:28 mem_pd_cvd2,      2'b00: CVD2 memory power on, 2'b11: power down
+//bit 27:26 mem_pd_isp,       2'b00: ISP memory power on, 2'b11: power down
+//bit 25:24 mem_pd_venci_int, 2'b00: cvbs- enci interface memory power on, 2'b11: power down
+//bit 23:22 mem_pd_venc_l_top,2'b00: panel - encl top memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vencp_int, 2'b00: hdmi - encp interface memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi2_osd_sc,2'b00: viu2 OSD scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi2_scale, 2'b00: viu2 scaler memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi2_ofifo, 2'b00: viu2 vpp output fifo memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi2_chroma,2'b00: viu2 color management module memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi2_vd1,   2'b00: viu2 vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi2_osd2,  2'b00: viu2 osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi2_osd1,  2'b00: viu2 osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG1                                (0xc883c000 + (0x42 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG1                                (0xda83c000 + (0x42 << 2))
+#define   P_HHI_VPU_MEM_PD_REG1                                (volatile uint32_t *)(0xc883c000 + (0x42 << 2))
+#define     HHI_DEMOD_MEM_PD_REG                               (0xc883c000 + (0x43 << 2))
+#define SEC_HHI_DEMOD_MEM_PD_REG                               (0xda83c000 + (0x43 << 2))
+#define   P_HHI_DEMOD_MEM_PD_REG                               (volatile uint32_t *)(0xc883c000 + (0x43 << 2))
+#define     HHI_AUD_DAC_CTRL                                   (0xc883c000 + (0x44 << 2))
+#define SEC_HHI_AUD_DAC_CTRL                                   (0xda83c000 + (0x44 << 2))
+#define   P_HHI_AUD_DAC_CTRL                                   (volatile uint32_t *)(0xc883c000 + (0x44 << 2))
+// `define HHI_VIID_PLL_CNTL4      8'h46 // video PLL read back
+// `define HHI_VIID_PLL_CNTL       8'h47 // Video PLL control, word 1
+// `define HHI_VIID_PLL_CNTL2      8'h48 // Video PLL control, word 2
+// `define HHI_VIID_PLL_CNTL3      8'h49 // Video PLL control, word 3
+#define     HHI_VIID_CLK_DIV                                   (0xc883c000 + (0x4a << 2))
+#define SEC_HHI_VIID_CLK_DIV                                   (0xda83c000 + (0x4a << 2))
+#define   P_HHI_VIID_CLK_DIV                                   (volatile uint32_t *)(0xc883c000 + (0x4a << 2))
+#define     HHI_VIID_CLK_CNTL                                  (0xc883c000 + (0x4b << 2))
+#define SEC_HHI_VIID_CLK_CNTL                                  (0xda83c000 + (0x4b << 2))
+#define   P_HHI_VIID_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x4b << 2))
+#define     HHI_VIID_DIVIDER_CNTL                              (0xc883c000 + (0x4c << 2))
+#define SEC_HHI_VIID_DIVIDER_CNTL                              (0xda83c000 + (0x4c << 2))
+#define   P_HHI_VIID_DIVIDER_CNTL                              (volatile uint32_t *)(0xc883c000 + (0x4c << 2))
+// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
+#define     HHI_GCLK_MPEG0                                     (0xc883c000 + (0x50 << 2))
+#define SEC_HHI_GCLK_MPEG0                                     (0xda83c000 + (0x50 << 2))
+#define   P_HHI_GCLK_MPEG0                                     (volatile uint32_t *)(0xc883c000 + (0x50 << 2))
+#define     HHI_GCLK_MPEG1                                     (0xc883c000 + (0x51 << 2))
+#define SEC_HHI_GCLK_MPEG1                                     (0xda83c000 + (0x51 << 2))
+#define   P_HHI_GCLK_MPEG1                                     (volatile uint32_t *)(0xc883c000 + (0x51 << 2))
+#define     HHI_GCLK_MPEG2                                     (0xc883c000 + (0x52 << 2))
+#define SEC_HHI_GCLK_MPEG2                                     (0xda83c000 + (0x52 << 2))
+#define   P_HHI_GCLK_MPEG2                                     (volatile uint32_t *)(0xc883c000 + (0x52 << 2))
+#define     HHI_GCLK_OTHER                                     (0xc883c000 + (0x54 << 2))
+#define SEC_HHI_GCLK_OTHER                                     (0xda83c000 + (0x54 << 2))
+#define   P_HHI_GCLK_OTHER                                     (volatile uint32_t *)(0xc883c000 + (0x54 << 2))
+#define     HHI_GCLK_AO                                        (0xc883c000 + (0x55 << 2))
+#define SEC_HHI_GCLK_AO                                        (0xda83c000 + (0x55 << 2))
+#define   P_HHI_GCLK_AO                                        (volatile uint32_t *)(0xc883c000 + (0x55 << 2))
+#define     HHI_SYS_OSCIN_CNTL                                 (0xc883c000 + (0x56 << 2))
+#define SEC_HHI_SYS_OSCIN_CNTL                                 (0xda83c000 + (0x56 << 2))
+#define   P_HHI_SYS_OSCIN_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x56 << 2))
+#define     HHI_SYS_CPU_CLK_CNTL1                              (0xc883c000 + (0x57 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL1                              (0xda83c000 + (0x57 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0x57 << 2))
+#define     HHI_SYS_CPU_RESET_CNTL                             (0xc883c000 + (0x58 << 2))
+#define SEC_HHI_SYS_CPU_RESET_CNTL                             (0xda83c000 + (0x58 << 2))
+#define   P_HHI_SYS_CPU_RESET_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x58 << 2))
+// PLL Controls
+#define     HHI_VID_CLK_DIV                                    (0xc883c000 + (0x59 << 2))
+#define SEC_HHI_VID_CLK_DIV                                    (0xda83c000 + (0x59 << 2))
+#define   P_HHI_VID_CLK_DIV                                    (volatile uint32_t *)(0xc883c000 + (0x59 << 2))
+#define     HHI_MPEG_CLK_CNTL                                  (0xc883c000 + (0x5d << 2))
+#define SEC_HHI_MPEG_CLK_CNTL                                  (0xda83c000 + (0x5d << 2))
+#define   P_HHI_MPEG_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x5d << 2))
+#define     HHI_AUD_CLK_CNTL                                   (0xc883c000 + (0x5e << 2))
+#define SEC_HHI_AUD_CLK_CNTL                                   (0xda83c000 + (0x5e << 2))
+#define   P_HHI_AUD_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x5e << 2))
+#define     HHI_VID_CLK_CNTL                                   (0xc883c000 + (0x5f << 2))
+#define SEC_HHI_VID_CLK_CNTL                                   (0xda83c000 + (0x5f << 2))
+#define   P_HHI_VID_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x5f << 2))
+#define     HHI_WIFI_CLK_CNTL                                  (0xc883c000 + (0x60 << 2))
+#define SEC_HHI_WIFI_CLK_CNTL                                  (0xda83c000 + (0x60 << 2))
+#define   P_HHI_WIFI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x60 << 2))
+#define     HHI_WIFI_PLL_CNTL                                  (0xc883c000 + (0x61 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL                                  (0xda83c000 + (0x61 << 2))
+#define   P_HHI_WIFI_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x61 << 2))
+#define     HHI_WIFI_PLL_CNTL2                                 (0xc883c000 + (0x62 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL2                                 (0xda83c000 + (0x62 << 2))
+#define   P_HHI_WIFI_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0x62 << 2))
+#define     HHI_WIFI_PLL_CNTL3                                 (0xc883c000 + (0x63 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL3                                 (0xda83c000 + (0x63 << 2))
+#define   P_HHI_WIFI_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0x63 << 2))
+#define     HHI_AUD_CLK_CNTL2                                  (0xc883c000 + (0x64 << 2))
+#define SEC_HHI_AUD_CLK_CNTL2                                  (0xda83c000 + (0x64 << 2))
+#define   P_HHI_AUD_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x64 << 2))
+#define     HHI_VID_CLK_CNTL2                                  (0xc883c000 + (0x65 << 2))
+#define SEC_HHI_VID_CLK_CNTL2                                  (0xda83c000 + (0x65 << 2))
+#define   P_HHI_VID_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x65 << 2))
+#define     HHI_VID_DIVIDER_CNTL                               (0xc883c000 + (0x66 << 2))
+#define SEC_HHI_VID_DIVIDER_CNTL                               (0xda83c000 + (0x66 << 2))
+#define   P_HHI_VID_DIVIDER_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x66 << 2))
+#define     HHI_SYS_CPU_CLK_CNTL                               (0xc883c000 + (0x67 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL                               (0xda83c000 + (0x67 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x67 << 2))
+#define     HHI_VID_PLL_CLK_DIV                                (0xc883c000 + (0x68 << 2))
+#define SEC_HHI_VID_PLL_CLK_DIV                                (0xda83c000 + (0x68 << 2))
+#define   P_HHI_VID_PLL_CLK_DIV                                (volatile uint32_t *)(0xc883c000 + (0x68 << 2))
+#define     HHI_AUD_CLK_CNTL3                                  (0xc883c000 + (0x69 << 2))
+#define SEC_HHI_AUD_CLK_CNTL3                                  (0xda83c000 + (0x69 << 2))
+#define   P_HHI_AUD_CLK_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x69 << 2))
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL        8'h68 // DDR PLL control, word 1
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL2       8'h69 // DDR PLL control, word 2
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL3       8'h6a // DDR PLL control, word 3
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL4       8'h6b // DDR PLL control, word 3
+#define     HHI_MALI_CLK_CNTL                                  (0xc883c000 + (0x6c << 2))
+#define SEC_HHI_MALI_CLK_CNTL                                  (0xda83c000 + (0x6c << 2))
+#define   P_HHI_MALI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x6c << 2))
+#define     HHI_MIPI_PHY_CLK_CNTL                              (0xc883c000 + (0x6e << 2))
+#define SEC_HHI_MIPI_PHY_CLK_CNTL                              (0xda83c000 + (0x6e << 2))
+#define   P_HHI_MIPI_PHY_CLK_CNTL                              (volatile uint32_t *)(0xc883c000 + (0x6e << 2))
+#define     HHI_VPU_CLK_CNTL                                   (0xc883c000 + (0x6f << 2))
+#define SEC_HHI_VPU_CLK_CNTL                                   (0xda83c000 + (0x6f << 2))
+#define   P_HHI_VPU_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x6f << 2))
+#define     HHI_OTHER_PLL_CNTL                                 (0xc883c000 + (0x70 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL                                 (0xda83c000 + (0x70 << 2))
+#define   P_HHI_OTHER_PLL_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x70 << 2))
+#define     HHI_OTHER_PLL_CNTL2                                (0xc883c000 + (0x71 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL2                                (0xda83c000 + (0x71 << 2))
+#define   P_HHI_OTHER_PLL_CNTL2                                (volatile uint32_t *)(0xc883c000 + (0x71 << 2))
+#define     HHI_OTHER_PLL_CNTL3                                (0xc883c000 + (0x72 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL3                                (0xda83c000 + (0x72 << 2))
+#define   P_HHI_OTHER_PLL_CNTL3                                (volatile uint32_t *)(0xc883c000 + (0x72 << 2))
+#define     HHI_HDMI_CLK_CNTL                                  (0xc883c000 + (0x73 << 2))
+#define SEC_HHI_HDMI_CLK_CNTL                                  (0xda83c000 + (0x73 << 2))
+#define   P_HHI_HDMI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x73 << 2))
+#define     HHI_DEMOD_CLK_CNTL                                 (0xc883c000 + (0x74 << 2))
+#define SEC_HHI_DEMOD_CLK_CNTL                                 (0xda83c000 + (0x74 << 2))
+#define   P_HHI_DEMOD_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x74 << 2))
+#define     HHI_SATA_CLK_CNTL                                  (0xc883c000 + (0x75 << 2))
+#define SEC_HHI_SATA_CLK_CNTL                                  (0xda83c000 + (0x75 << 2))
+#define   P_HHI_SATA_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x75 << 2))
+#define     HHI_ETH_CLK_CNTL                                   (0xc883c000 + (0x76 << 2))
+#define SEC_HHI_ETH_CLK_CNTL                                   (0xda83c000 + (0x76 << 2))
+#define   P_HHI_ETH_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x76 << 2))
+#define     HHI_CLK_DOUBLE_CNTL                                (0xc883c000 + (0x77 << 2))
+#define SEC_HHI_CLK_DOUBLE_CNTL                                (0xda83c000 + (0x77 << 2))
+#define   P_HHI_CLK_DOUBLE_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x77 << 2))
+#define     HHI_VDEC_CLK_CNTL                                  (0xc883c000 + (0x78 << 2))
+#define SEC_HHI_VDEC_CLK_CNTL                                  (0xda83c000 + (0x78 << 2))
+#define   P_HHI_VDEC_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x78 << 2))
+#define     HHI_VDEC2_CLK_CNTL                                 (0xc883c000 + (0x79 << 2))
+#define SEC_HHI_VDEC2_CLK_CNTL                                 (0xda83c000 + (0x79 << 2))
+#define   P_HHI_VDEC2_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x79 << 2))
+#define     HHI_VDEC3_CLK_CNTL                                 (0xc883c000 + (0x7a << 2))
+#define SEC_HHI_VDEC3_CLK_CNTL                                 (0xda83c000 + (0x7a << 2))
+#define   P_HHI_VDEC3_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x7a << 2))
+#define     HHI_VDEC4_CLK_CNTL                                 (0xc883c000 + (0x7b << 2))
+#define SEC_HHI_VDEC4_CLK_CNTL                                 (0xda83c000 + (0x7b << 2))
+#define   P_HHI_VDEC4_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x7b << 2))
+#define     HHI_HDCP22_CLK_CNTL                                (0xc883c000 + (0x7c << 2))
+#define SEC_HHI_HDCP22_CLK_CNTL                                (0xda83c000 + (0x7c << 2))
+#define   P_HHI_HDCP22_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x7c << 2))
+#define     HHI_VAPBCLK_CNTL                                   (0xc883c000 + (0x7d << 2))
+#define SEC_HHI_VAPBCLK_CNTL                                   (0xda83c000 + (0x7d << 2))
+#define   P_HHI_VAPBCLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x7d << 2))
+#define     HHI_VP9DEC_CLK_CNTL                                (0xc883c000 + (0x7e << 2))
+#define SEC_HHI_VP9DEC_CLK_CNTL                                (0xda83c000 + (0x7e << 2))
+#define   P_HHI_VP9DEC_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x7e << 2))
+// `define HHI_SYS_CPU_AUTO_CLK0        8'h78   never used
+// `define HHI_SYS_CPU_AUTO_CLK1        8'h79   never used
+// `define HHI_MEDIA_CPU_AUTO_CLK0    8'h7a     never used
+// `define HHI_MEDIA_CPU_AUTO_CLK1    8'h7b     never used
+#define     HHI_HDMI_AFC_CNTL                                  (0xc883c000 + (0x7f << 2))
+#define SEC_HHI_HDMI_AFC_CNTL                                  (0xda83c000 + (0x7f << 2))
+#define   P_HHI_HDMI_AFC_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x7f << 2))
+#define     HHI_HDMIRX_CLK_CNTL                                (0xc883c000 + (0x80 << 2))
+#define SEC_HHI_HDMIRX_CLK_CNTL                                (0xda83c000 + (0x80 << 2))
+#define   P_HHI_HDMIRX_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x80 << 2))
+#define     HHI_HDMIRX_AUD_CLK_CNTL                            (0xc883c000 + (0x81 << 2))
+#define SEC_HHI_HDMIRX_AUD_CLK_CNTL                            (0xda83c000 + (0x81 << 2))
+#define   P_HHI_HDMIRX_AUD_CLK_CNTL                            (volatile uint32_t *)(0xc883c000 + (0x81 << 2))
+#define     HHI_EDP_APB_CLK_CNTL                               (0xc883c000 + (0x82 << 2))
+#define SEC_HHI_EDP_APB_CLK_CNTL                               (0xda83c000 + (0x82 << 2))
+#define   P_HHI_EDP_APB_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x82 << 2))
+#define     HHI_VPU_CLKB_CNTL                                  (0xc883c000 + (0x83 << 2))
+#define SEC_HHI_VPU_CLKB_CNTL                                  (0xda83c000 + (0x83 << 2))
+#define   P_HHI_VPU_CLKB_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x83 << 2))
+#define     HHI_VID_PLL_MOD_CNTL0                              (0xc883c000 + (0x84 << 2))
+#define SEC_HHI_VID_PLL_MOD_CNTL0                              (0xda83c000 + (0x84 << 2))
+#define   P_HHI_VID_PLL_MOD_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0x84 << 2))
+#define     HHI_VID_PLL_MOD_LOW_TCNT                           (0xc883c000 + (0x85 << 2))
+#define SEC_HHI_VID_PLL_MOD_LOW_TCNT                           (0xda83c000 + (0x85 << 2))
+#define   P_HHI_VID_PLL_MOD_LOW_TCNT                           (volatile uint32_t *)(0xc883c000 + (0x85 << 2))
+#define     HHI_VID_PLL_MOD_HIGH_TCNT                          (0xc883c000 + (0x86 << 2))
+#define SEC_HHI_VID_PLL_MOD_HIGH_TCNT                          (0xda83c000 + (0x86 << 2))
+#define   P_HHI_VID_PLL_MOD_HIGH_TCNT                          (volatile uint32_t *)(0xc883c000 + (0x86 << 2))
+#define     HHI_VID_PLL_MOD_NOM_TCNT                           (0xc883c000 + (0x87 << 2))
+#define SEC_HHI_VID_PLL_MOD_NOM_TCNT                           (0xda83c000 + (0x87 << 2))
+#define   P_HHI_VID_PLL_MOD_NOM_TCNT                           (volatile uint32_t *)(0xc883c000 + (0x87 << 2))
+#define     HHI_USB_CLK_CNTL                                   (0xc883c000 + (0x88 << 2))
+#define SEC_HHI_USB_CLK_CNTL                                   (0xda83c000 + (0x88 << 2))
+#define   P_HHI_USB_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x88 << 2))
+// Removed `define HHI_DDR_CLK_CNTL            8'h88
+#define     HHI_32K_CLK_CNTL                                   (0xc883c000 + (0x89 << 2))
+#define SEC_HHI_32K_CLK_CNTL                                   (0xda83c000 + (0x89 << 2))
+#define   P_HHI_32K_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x89 << 2))
+#define     HHI_GEN_CLK_CNTL                                   (0xc883c000 + (0x8a << 2))
+#define SEC_HHI_GEN_CLK_CNTL                                   (0xda83c000 + (0x8a << 2))
+#define   P_HHI_GEN_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x8a << 2))
+#define     HHI_GEN_CLK_CNTL2                                  (0xc883c000 + (0x8b << 2))
+#define SEC_HHI_GEN_CLK_CNTL2                                  (0xda83c000 + (0x8b << 2))
+#define   P_HHI_GEN_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x8b << 2))
+#define     HHI_JTAG_CONFIG                                    (0xc883c000 + (0x8e << 2))
+#define SEC_HHI_JTAG_CONFIG                                    (0xda83c000 + (0x8e << 2))
+#define   P_HHI_JTAG_CONFIG                                    (volatile uint32_t *)(0xc883c000 + (0x8e << 2))
+#define     HHI_VAFE_CLKXTALIN_CNTL                            (0xc883c000 + (0x8f << 2))
+#define SEC_HHI_VAFE_CLKXTALIN_CNTL                            (0xda83c000 + (0x8f << 2))
+#define   P_HHI_VAFE_CLKXTALIN_CNTL                            (volatile uint32_t *)(0xc883c000 + (0x8f << 2))
+#define     HHI_VAFE_CLKOSCIN_CNTL                             (0xc883c000 + (0x90 << 2))
+#define SEC_HHI_VAFE_CLKOSCIN_CNTL                             (0xda83c000 + (0x90 << 2))
+#define   P_HHI_VAFE_CLKOSCIN_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x90 << 2))
+#define     HHI_VAFE_CLKIN_CNTL                                (0xc883c000 + (0x91 << 2))
+#define SEC_HHI_VAFE_CLKIN_CNTL                                (0xda83c000 + (0x91 << 2))
+#define   P_HHI_VAFE_CLKIN_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x91 << 2))
+#define     HHI_TVFE_AUTOMODE_CLK_CNTL                         (0xc883c000 + (0x92 << 2))
+#define SEC_HHI_TVFE_AUTOMODE_CLK_CNTL                         (0xda83c000 + (0x92 << 2))
+#define   P_HHI_TVFE_AUTOMODE_CLK_CNTL                         (volatile uint32_t *)(0xc883c000 + (0x92 << 2))
+#define     HHI_VAFE_CLKPI_CNTL                                (0xc883c000 + (0x93 << 2))
+#define SEC_HHI_VAFE_CLKPI_CNTL                                (0xda83c000 + (0x93 << 2))
+#define   P_HHI_VAFE_CLKPI_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x93 << 2))
+#define     HHI_VDIN_MEAS_CLK_CNTL                             (0xc883c000 + (0x94 << 2))
+#define SEC_HHI_VDIN_MEAS_CLK_CNTL                             (0xda83c000 + (0x94 << 2))
+#define   P_HHI_VDIN_MEAS_CLK_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x94 << 2))
+// `define HHI_PCM2_CLK_CNTL           8'h95
+#define     HHI_PCM_CLK_CNTL                                   (0xc883c000 + (0x96 << 2))
+#define SEC_HHI_PCM_CLK_CNTL                                   (0xda83c000 + (0x96 << 2))
+#define   P_HHI_PCM_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x96 << 2))
+#define     HHI_NAND_CLK_CNTL                                  (0xc883c000 + (0x97 << 2))
+#define SEC_HHI_NAND_CLK_CNTL                                  (0xda83c000 + (0x97 << 2))
+#define   P_HHI_NAND_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x97 << 2))
+#define     HHI_ISP_LED_CLK_CNTL                               (0xc883c000 + (0x98 << 2))
+#define SEC_HHI_ISP_LED_CLK_CNTL                               (0xda83c000 + (0x98 << 2))
+#define   P_HHI_ISP_LED_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x98 << 2))
+#define     HHI_SD_EMMC_CLK_CNTL                               (0xc883c000 + (0x99 << 2))
+#define SEC_HHI_SD_EMMC_CLK_CNTL                               (0xda83c000 + (0x99 << 2))
+#define   P_HHI_SD_EMMC_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x99 << 2))
+#define     HHI_EDP_TX_PHY_CNTL0                               (0xc883c000 + (0x9c << 2))
+#define SEC_HHI_EDP_TX_PHY_CNTL0                               (0xda83c000 + (0x9c << 2))
+#define   P_HHI_EDP_TX_PHY_CNTL0                               (volatile uint32_t *)(0xc883c000 + (0x9c << 2))
+#define     HHI_EDP_TX_PHY_CNTL1                               (0xc883c000 + (0x9d << 2))
+#define SEC_HHI_EDP_TX_PHY_CNTL1                               (0xda83c000 + (0x9d << 2))
+#define   P_HHI_EDP_TX_PHY_CNTL1                               (volatile uint32_t *)(0xc883c000 + (0x9d << 2))
+#define     HHI_MPLL_CNTL                                      (0xc883c000 + (0xa0 << 2))
+#define SEC_HHI_MPLL_CNTL                                      (0xda83c000 + (0xa0 << 2))
+#define   P_HHI_MPLL_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0xa0 << 2))
+#define     HHI_MPLL_CNTL2                                     (0xc883c000 + (0xa1 << 2))
+#define SEC_HHI_MPLL_CNTL2                                     (0xda83c000 + (0xa1 << 2))
+#define   P_HHI_MPLL_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0xa1 << 2))
+#define     HHI_MPLL_CNTL3                                     (0xc883c000 + (0xa2 << 2))
+#define SEC_HHI_MPLL_CNTL3                                     (0xda83c000 + (0xa2 << 2))
+#define   P_HHI_MPLL_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0xa2 << 2))
+#define     HHI_MPLL_CNTL4                                     (0xc883c000 + (0xa3 << 2))
+#define SEC_HHI_MPLL_CNTL4                                     (0xda83c000 + (0xa3 << 2))
+#define   P_HHI_MPLL_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0xa3 << 2))
+#define     HHI_MPLL_CNTL5                                     (0xc883c000 + (0xa4 << 2))
+#define SEC_HHI_MPLL_CNTL5                                     (0xda83c000 + (0xa4 << 2))
+#define   P_HHI_MPLL_CNTL5                                     (volatile uint32_t *)(0xc883c000 + (0xa4 << 2))
+#define     HHI_MPLL_CNTL6                                     (0xc883c000 + (0xa5 << 2))
+#define SEC_HHI_MPLL_CNTL6                                     (0xda83c000 + (0xa5 << 2))
+#define   P_HHI_MPLL_CNTL6                                     (volatile uint32_t *)(0xc883c000 + (0xa5 << 2))
+#define     HHI_MPLL_CNTL7                                     (0xc883c000 + (0xa6 << 2))
+#define SEC_HHI_MPLL_CNTL7                                     (0xda83c000 + (0xa6 << 2))
+#define   P_HHI_MPLL_CNTL7                                     (volatile uint32_t *)(0xc883c000 + (0xa6 << 2))
+#define     HHI_MPLL_CNTL8                                     (0xc883c000 + (0xa7 << 2))
+#define SEC_HHI_MPLL_CNTL8                                     (0xda83c000 + (0xa7 << 2))
+#define   P_HHI_MPLL_CNTL8                                     (volatile uint32_t *)(0xc883c000 + (0xa7 << 2))
+#define     HHI_MPLL_CNTL9                                     (0xc883c000 + (0xa8 << 2))
+#define SEC_HHI_MPLL_CNTL9                                     (0xda83c000 + (0xa8 << 2))
+#define   P_HHI_MPLL_CNTL9                                     (volatile uint32_t *)(0xc883c000 + (0xa8 << 2))
+#define     HHI_MPLL_CNTL10                                    (0xc883c000 + (0xa9 << 2))
+#define SEC_HHI_MPLL_CNTL10                                    (0xda83c000 + (0xa9 << 2))
+#define   P_HHI_MPLL_CNTL10                                    (volatile uint32_t *)(0xc883c000 + (0xa9 << 2))
+#define     HHI_ADC_PLL_CNTL                                   (0xc883c000 + (0xaa << 2))
+#define SEC_HHI_ADC_PLL_CNTL                                   (0xda83c000 + (0xaa << 2))
+#define   P_HHI_ADC_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xaa << 2))
+#define     HHI_ADC_PLL_CNTL2                                  (0xc883c000 + (0xab << 2))
+#define SEC_HHI_ADC_PLL_CNTL2                                  (0xda83c000 + (0xab << 2))
+#define   P_HHI_ADC_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xab << 2))
+#define     HHI_ADC_PLL_CNTL3                                  (0xc883c000 + (0xac << 2))
+#define SEC_HHI_ADC_PLL_CNTL3                                  (0xda83c000 + (0xac << 2))
+#define   P_HHI_ADC_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xac << 2))
+#define     HHI_ADC_PLL_CNTL4                                  (0xc883c000 + (0xad << 2))
+#define SEC_HHI_ADC_PLL_CNTL4                                  (0xda83c000 + (0xad << 2))
+#define   P_HHI_ADC_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xad << 2))
+#define     HHI_ADC_PLL_CNTL_I                                 (0xc883c000 + (0xae << 2))
+#define SEC_HHI_ADC_PLL_CNTL_I                                 (0xda83c000 + (0xae << 2))
+#define   P_HHI_ADC_PLL_CNTL_I                                 (volatile uint32_t *)(0xc883c000 + (0xae << 2))
+#define     HHI_AUDCLK_PLL_CNTL                                (0xc883c000 + (0xb0 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL                                (0xda83c000 + (0xb0 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL                                (volatile uint32_t *)(0xc883c000 + (0xb0 << 2))
+#define     HHI_AUDCLK_PLL_CNTL2                               (0xc883c000 + (0xb1 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL2                               (0xda83c000 + (0xb1 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL2                               (volatile uint32_t *)(0xc883c000 + (0xb1 << 2))
+#define     HHI_AUDCLK_PLL_CNTL3                               (0xc883c000 + (0xb2 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL3                               (0xda83c000 + (0xb2 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL3                               (volatile uint32_t *)(0xc883c000 + (0xb2 << 2))
+#define     HHI_AUDCLK_PLL_CNTL4                               (0xc883c000 + (0xb3 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL4                               (0xda83c000 + (0xb3 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL4                               (volatile uint32_t *)(0xc883c000 + (0xb3 << 2))
+#define     HHI_AUDCLK_PLL_CNTL5                               (0xc883c000 + (0xb4 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL5                               (0xda83c000 + (0xb4 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL5                               (volatile uint32_t *)(0xc883c000 + (0xb4 << 2))
+#define     HHI_AUDCLK_PLL_CNTL6                               (0xc883c000 + (0xb5 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL6                               (0xda83c000 + (0xb5 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL6                               (volatile uint32_t *)(0xc883c000 + (0xb5 << 2))
+#define     HHI_L2_DDR_CLK_CNTL                                (0xc883c000 + (0xb6 << 2))
+#define SEC_HHI_L2_DDR_CLK_CNTL                                (0xda83c000 + (0xb6 << 2))
+#define   P_HHI_L2_DDR_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0xb6 << 2))
+#define     HHI_MPLL3_CNTL0                                    (0xc883c000 + (0xb8 << 2))
+#define SEC_HHI_MPLL3_CNTL0                                    (0xda83c000 + (0xb8 << 2))
+#define   P_HHI_MPLL3_CNTL0                                    (volatile uint32_t *)(0xc883c000 + (0xb8 << 2))
+#define     HHI_MPLL3_CNTL1                                    (0xc883c000 + (0xb9 << 2))
+#define SEC_HHI_MPLL3_CNTL1                                    (0xda83c000 + (0xb9 << 2))
+#define   P_HHI_MPLL3_CNTL1                                    (volatile uint32_t *)(0xc883c000 + (0xb9 << 2))
+#define     HHI_VDAC_CNTL0                                     (0xc883c000 + (0xbd << 2))
+#define SEC_HHI_VDAC_CNTL0                                     (0xda83c000 + (0xbd << 2))
+#define   P_HHI_VDAC_CNTL0                                     (volatile uint32_t *)(0xc883c000 + (0xbd << 2))
+#define     HHI_VDAC_CNTL1                                     (0xc883c000 + (0xbe << 2))
+#define SEC_HHI_VDAC_CNTL1                                     (0xda83c000 + (0xbe << 2))
+#define   P_HHI_VDAC_CNTL1                                     (volatile uint32_t *)(0xc883c000 + (0xbe << 2))
+#define     HHI_SYS_PLL_CNTL                                   (0xc883c000 + (0xc0 << 2))
+#define SEC_HHI_SYS_PLL_CNTL                                   (0xda83c000 + (0xc0 << 2))
+#define   P_HHI_SYS_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xc0 << 2))
+#define     HHI_SYS_PLL_CNTL2                                  (0xc883c000 + (0xc1 << 2))
+#define SEC_HHI_SYS_PLL_CNTL2                                  (0xda83c000 + (0xc1 << 2))
+#define   P_HHI_SYS_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xc1 << 2))
+#define     HHI_SYS_PLL_CNTL3                                  (0xc883c000 + (0xc2 << 2))
+#define SEC_HHI_SYS_PLL_CNTL3                                  (0xda83c000 + (0xc2 << 2))
+#define   P_HHI_SYS_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xc2 << 2))
+#define     HHI_SYS_PLL_CNTL4                                  (0xc883c000 + (0xc3 << 2))
+#define SEC_HHI_SYS_PLL_CNTL4                                  (0xda83c000 + (0xc3 << 2))
+#define   P_HHI_SYS_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xc3 << 2))
+#define     HHI_SYS_PLL_CNTL5                                  (0xc883c000 + (0xc4 << 2))
+#define SEC_HHI_SYS_PLL_CNTL5                                  (0xda83c000 + (0xc4 << 2))
+#define   P_HHI_SYS_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0xc4 << 2))
+#define     HHI_DPLL_TOP_I                                     (0xc883c000 + (0xc6 << 2))
+#define SEC_HHI_DPLL_TOP_I                                     (0xda83c000 + (0xc6 << 2))
+#define   P_HHI_DPLL_TOP_I                                     (volatile uint32_t *)(0xc883c000 + (0xc6 << 2))
+#define     HHI_DPLL_TOP2_I                                    (0xc883c000 + (0xc7 << 2))
+#define SEC_HHI_DPLL_TOP2_I                                    (0xda83c000 + (0xc7 << 2))
+#define   P_HHI_DPLL_TOP2_I                                    (volatile uint32_t *)(0xc883c000 + (0xc7 << 2))
+#define     HHI_HDMI_PLL_CNTL                                  (0xc883c000 + (0xc8 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL                                  (0xda83c000 + (0xc8 << 2))
+#define   P_HHI_HDMI_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0xc8 << 2))
+#define     HHI_HDMI_PLL_CNTL2                                 (0xc883c000 + (0xc9 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL2                                 (0xda83c000 + (0xc9 << 2))
+#define   P_HHI_HDMI_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xc9 << 2))
+#define     HHI_HDMI_PLL_CNTL3                                 (0xc883c000 + (0xca << 2))
+#define SEC_HHI_HDMI_PLL_CNTL3                                 (0xda83c000 + (0xca << 2))
+#define   P_HHI_HDMI_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xca << 2))
+#define     HHI_HDMI_PLL_CNTL4                                 (0xc883c000 + (0xcb << 2))
+#define SEC_HHI_HDMI_PLL_CNTL4                                 (0xda83c000 + (0xcb << 2))
+#define   P_HHI_HDMI_PLL_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xcb << 2))
+#define     HHI_HDMI_PLL_CNTL5                                 (0xc883c000 + (0xcc << 2))
+#define SEC_HHI_HDMI_PLL_CNTL5                                 (0xda83c000 + (0xcc << 2))
+#define   P_HHI_HDMI_PLL_CNTL5                                 (volatile uint32_t *)(0xc883c000 + (0xcc << 2))
+#define     HHI_HDMI_PLL_CNTL6                                 (0xc883c000 + (0xcd << 2))
+#define SEC_HHI_HDMI_PLL_CNTL6                                 (0xda83c000 + (0xcd << 2))
+#define   P_HHI_HDMI_PLL_CNTL6                                 (volatile uint32_t *)(0xc883c000 + (0xcd << 2))
+#define     HHI_HDMI_PLL_CNTL_I                                (0xc883c000 + (0xce << 2))
+#define SEC_HHI_HDMI_PLL_CNTL_I                                (0xda83c000 + (0xce << 2))
+#define   P_HHI_HDMI_PLL_CNTL_I                                (volatile uint32_t *)(0xc883c000 + (0xce << 2))
+#define     HHI_HDMI_PLL_CNTL7                                 (0xc883c000 + (0xcf << 2))
+#define SEC_HHI_HDMI_PLL_CNTL7                                 (0xda83c000 + (0xcf << 2))
+#define   P_HHI_HDMI_PLL_CNTL7                                 (volatile uint32_t *)(0xc883c000 + (0xcf << 2))
+#define     HHI_DSI_LVDS_EDP_CNTL0                             (0xc883c000 + (0xd1 << 2))
+#define SEC_HHI_DSI_LVDS_EDP_CNTL0                             (0xda83c000 + (0xd1 << 2))
+#define   P_HHI_DSI_LVDS_EDP_CNTL0                             (volatile uint32_t *)(0xc883c000 + (0xd1 << 2))
+#define     HHI_DSI_LVDS_EDP_CNTL1                             (0xc883c000 + (0xd2 << 2))
+#define SEC_HHI_DSI_LVDS_EDP_CNTL1                             (0xda83c000 + (0xd2 << 2))
+#define   P_HHI_DSI_LVDS_EDP_CNTL1                             (volatile uint32_t *)(0xc883c000 + (0xd2 << 2))
+#define     HHI_CSI_PHY_CNTL0                                  (0xc883c000 + (0xd3 << 2))
+#define SEC_HHI_CSI_PHY_CNTL0                                  (0xda83c000 + (0xd3 << 2))
+#define   P_HHI_CSI_PHY_CNTL0                                  (volatile uint32_t *)(0xc883c000 + (0xd3 << 2))
+#define     HHI_CSI_PHY_CNTL1                                  (0xc883c000 + (0xd4 << 2))
+#define SEC_HHI_CSI_PHY_CNTL1                                  (0xda83c000 + (0xd4 << 2))
+#define   P_HHI_CSI_PHY_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0xd4 << 2))
+#define     HHI_CSI_PHY_CNTL2                                  (0xc883c000 + (0xd5 << 2))
+#define SEC_HHI_CSI_PHY_CNTL2                                  (0xda83c000 + (0xd5 << 2))
+#define   P_HHI_CSI_PHY_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xd5 << 2))
+#define     HHI_CSI_PHY_CNTL3                                  (0xc883c000 + (0xd6 << 2))
+#define SEC_HHI_CSI_PHY_CNTL3                                  (0xda83c000 + (0xd6 << 2))
+#define   P_HHI_CSI_PHY_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xd6 << 2))
+#define     HHI_CSI_PHY_CNTL4                                  (0xc883c000 + (0xd7 << 2))
+#define SEC_HHI_CSI_PHY_CNTL4                                  (0xda83c000 + (0xd7 << 2))
+#define   P_HHI_CSI_PHY_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xd7 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL0                              (0xc883c000 + (0xd8 << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL0                              (0xda83c000 + (0xd8 << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0xd8 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL1                              (0xc883c000 + (0xd9 << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL1                              (0xda83c000 + (0xd9 << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0xd9 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL2                              (0xc883c000 + (0xda << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL2                              (0xda83c000 + (0xda << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL2                              (volatile uint32_t *)(0xc883c000 + (0xda << 2))
+#define     HHI_DIF_CSI_PHY_CNTL3                              (0xc883c000 + (0xdb << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL3                              (0xda83c000 + (0xdb << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL3                              (volatile uint32_t *)(0xc883c000 + (0xdb << 2))
+#define     HHI_DIF_CSI_PHY_CNTL4                              (0xc883c000 + (0xdc << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL4                              (0xda83c000 + (0xdc << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL4                              (volatile uint32_t *)(0xc883c000 + (0xdc << 2))
+#define     HHI_DIF_CSI_PHY_CNTL5                              (0xc883c000 + (0xdd << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL5                              (0xda83c000 + (0xdd << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL5                              (volatile uint32_t *)(0xc883c000 + (0xdd << 2))
+#define     HHI_LVDS_TX_PHY_CNTL0                              (0xc883c000 + (0xde << 2))
+#define SEC_HHI_LVDS_TX_PHY_CNTL0                              (0xda83c000 + (0xde << 2))
+#define   P_HHI_LVDS_TX_PHY_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0xde << 2))
+#define     HHI_LVDS_TX_PHY_CNTL1                              (0xc883c000 + (0xdf << 2))
+#define SEC_HHI_LVDS_TX_PHY_CNTL1                              (0xda83c000 + (0xdf << 2))
+#define   P_HHI_LVDS_TX_PHY_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0xdf << 2))
+#define     HHI_VID2_PLL_CNTL                                  (0xc883c000 + (0xe0 << 2))
+#define SEC_HHI_VID2_PLL_CNTL                                  (0xda83c000 + (0xe0 << 2))
+#define   P_HHI_VID2_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0xe0 << 2))
+#define     HHI_VID2_PLL_CNTL2                                 (0xc883c000 + (0xe1 << 2))
+#define SEC_HHI_VID2_PLL_CNTL2                                 (0xda83c000 + (0xe1 << 2))
+#define   P_HHI_VID2_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xe1 << 2))
+#define     HHI_VID2_PLL_CNTL3                                 (0xc883c000 + (0xe2 << 2))
+#define SEC_HHI_VID2_PLL_CNTL3                                 (0xda83c000 + (0xe2 << 2))
+#define   P_HHI_VID2_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xe2 << 2))
+#define     HHI_VID2_PLL_CNTL4                                 (0xc883c000 + (0xe3 << 2))
+#define SEC_HHI_VID2_PLL_CNTL4                                 (0xda83c000 + (0xe3 << 2))
+#define   P_HHI_VID2_PLL_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xe3 << 2))
+#define     HHI_VID2_PLL_CNTL5                                 (0xc883c000 + (0xe4 << 2))
+#define SEC_HHI_VID2_PLL_CNTL5                                 (0xda83c000 + (0xe4 << 2))
+#define   P_HHI_VID2_PLL_CNTL5                                 (volatile uint32_t *)(0xc883c000 + (0xe4 << 2))
+#define     HHI_VID2_PLL_CNTL_I                                (0xc883c000 + (0xe5 << 2))
+#define SEC_HHI_VID2_PLL_CNTL_I                                (0xda83c000 + (0xe5 << 2))
+#define   P_HHI_VID2_PLL_CNTL_I                                (volatile uint32_t *)(0xc883c000 + (0xe5 << 2))
+#define     HHI_HDMI_PHY_CNTL0                                 (0xc883c000 + (0xe8 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL0                                 (0xda83c000 + (0xe8 << 2))
+#define   P_HHI_HDMI_PHY_CNTL0                                 (volatile uint32_t *)(0xc883c000 + (0xe8 << 2))
+#define     HHI_HDMI_PHY_CNTL1                                 (0xc883c000 + (0xe9 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL1                                 (0xda83c000 + (0xe9 << 2))
+#define   P_HHI_HDMI_PHY_CNTL1                                 (volatile uint32_t *)(0xc883c000 + (0xe9 << 2))
+#define     HHI_HDMI_PHY_CNTL2                                 (0xc883c000 + (0xea << 2))
+#define SEC_HHI_HDMI_PHY_CNTL2                                 (0xda83c000 + (0xea << 2))
+#define   P_HHI_HDMI_PHY_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xea << 2))
+#define     HHI_HDMI_PHY_CNTL3                                 (0xc883c000 + (0xeb << 2))
+#define SEC_HHI_HDMI_PHY_CNTL3                                 (0xda83c000 + (0xeb << 2))
+#define   P_HHI_HDMI_PHY_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xeb << 2))
+#define     HHI_VID_LOCK_CLK_CNTL                              (0xc883c000 + (0xf2 << 2))
+#define SEC_HHI_VID_LOCK_CLK_CNTL                              (0xda83c000 + (0xf2 << 2))
+#define   P_HHI_VID_LOCK_CLK_CNTL                              (volatile uint32_t *)(0xc883c000 + (0xf2 << 2))
+#define     HHI_ATV_DMD_SYS_CLK_CNTL                           (0xc883c000 + (0xf3 << 2))
+#define SEC_HHI_ATV_DMD_SYS_CLK_CNTL                           (0xda83c000 + (0xf3 << 2))
+#define   P_HHI_ATV_DMD_SYS_CLK_CNTL                           (volatile uint32_t *)(0xc883c000 + (0xf3 << 2))
+// `define HHI_EE_MISC_CNTL            8'hf4
+#define     HHI_BT656_CLK_CNTL                                 (0xc883c000 + (0xf5 << 2))
+#define SEC_HHI_BT656_CLK_CNTL                                 (0xda83c000 + (0xf5 << 2))
+#define   P_HHI_BT656_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0xf5 << 2))
+#define     HHI_SAR_CLK_CNTL                                   (0xc883c000 + (0xf6 << 2))
+#define SEC_HHI_SAR_CLK_CNTL                                   (0xda83c000 + (0xf6 << 2))
+#define   P_HHI_SAR_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xf6 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL                            (0xc883c000 + (0xf8 << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL                            (0xda83c000 + (0xf8 << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL                            (volatile uint32_t *)(0xc883c000 + (0xf8 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL2                           (0xc883c000 + (0xf9 << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL2                           (0xda83c000 + (0xf9 << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL2                           (volatile uint32_t *)(0xc883c000 + (0xf9 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL3                           (0xc883c000 + (0xfa << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL3                           (0xda83c000 + (0xfa << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL3                           (volatile uint32_t *)(0xc883c000 + (0xfa << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL4                           (0xc883c000 + (0xfb << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL4                           (0xda83c000 + (0xfb << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL4                           (volatile uint32_t *)(0xc883c000 + (0xfb << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL5                           (0xc883c000 + (0xfc << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL5                           (0xda83c000 + (0xfc << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL5                           (volatile uint32_t *)(0xc883c000 + (0xfc << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL6                           (0xc883c000 + (0xfd << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL6                           (0xda83c000 + (0xfd << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL6                           (volatile uint32_t *)(0xc883c000 + (0xfd << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL_I                          (0xc883c000 + (0xfe << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL_I                          (0xda83c000 + (0xfe << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL_I                          (volatile uint32_t *)(0xc883c000 + (0xfe << 2))
+//========================================================================
+//  HIU - Mailbox
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hC883C400
+// APB4_DECODER_SECURE_BASE         32'hDA83C400
+#define     HIU_MAILBOX_SET_0                                  (0xc883c400 + (0x01 << 2))
+#define SEC_HIU_MAILBOX_SET_0                                  (0xda83c400 + (0x01 << 2))
+#define   P_HIU_MAILBOX_SET_0                                  (volatile uint32_t *)(0xc883c400 + (0x01 << 2))
+#define     HIU_MAILBOX_STAT_0                                 (0xc883c400 + (0x02 << 2))
+#define SEC_HIU_MAILBOX_STAT_0                                 (0xda83c400 + (0x02 << 2))
+#define   P_HIU_MAILBOX_STAT_0                                 (volatile uint32_t *)(0xc883c400 + (0x02 << 2))
+#define     HIU_MAILBOX_CLR_0                                  (0xc883c400 + (0x03 << 2))
+#define SEC_HIU_MAILBOX_CLR_0                                  (0xda83c400 + (0x03 << 2))
+#define   P_HIU_MAILBOX_CLR_0                                  (volatile uint32_t *)(0xc883c400 + (0x03 << 2))
+#define     HIU_MAILBOX_SET_1                                  (0xc883c400 + (0x04 << 2))
+#define SEC_HIU_MAILBOX_SET_1                                  (0xda83c400 + (0x04 << 2))
+#define   P_HIU_MAILBOX_SET_1                                  (volatile uint32_t *)(0xc883c400 + (0x04 << 2))
+#define     HIU_MAILBOX_STAT_1                                 (0xc883c400 + (0x05 << 2))
+#define SEC_HIU_MAILBOX_STAT_1                                 (0xda83c400 + (0x05 << 2))
+#define   P_HIU_MAILBOX_STAT_1                                 (volatile uint32_t *)(0xc883c400 + (0x05 << 2))
+#define     HIU_MAILBOX_CLR_1                                  (0xc883c400 + (0x06 << 2))
+#define SEC_HIU_MAILBOX_CLR_1                                  (0xda83c400 + (0x06 << 2))
+#define   P_HIU_MAILBOX_CLR_1                                  (volatile uint32_t *)(0xc883c400 + (0x06 << 2))
+#define     HIU_MAILBOX_SET_2                                  (0xc883c400 + (0x07 << 2))
+#define SEC_HIU_MAILBOX_SET_2                                  (0xda83c400 + (0x07 << 2))
+#define   P_HIU_MAILBOX_SET_2                                  (volatile uint32_t *)(0xc883c400 + (0x07 << 2))
+#define     HIU_MAILBOX_STAT_2                                 (0xc883c400 + (0x08 << 2))
+#define SEC_HIU_MAILBOX_STAT_2                                 (0xda83c400 + (0x08 << 2))
+#define   P_HIU_MAILBOX_STAT_2                                 (volatile uint32_t *)(0xc883c400 + (0x08 << 2))
+#define     HIU_MAILBOX_CLR_2                                  (0xc883c400 + (0x09 << 2))
+#define SEC_HIU_MAILBOX_CLR_2                                  (0xda83c400 + (0x09 << 2))
+#define   P_HIU_MAILBOX_CLR_2                                  (volatile uint32_t *)(0xc883c400 + (0x09 << 2))
+#define     HIU_MAILBOX_SET_3                                  (0xc883c400 + (0x0a << 2))
+#define SEC_HIU_MAILBOX_SET_3                                  (0xda83c400 + (0x0a << 2))
+#define   P_HIU_MAILBOX_SET_3                                  (volatile uint32_t *)(0xc883c400 + (0x0a << 2))
+#define     HIU_MAILBOX_STAT_3                                 (0xc883c400 + (0x0b << 2))
+#define SEC_HIU_MAILBOX_STAT_3                                 (0xda83c400 + (0x0b << 2))
+#define   P_HIU_MAILBOX_STAT_3                                 (volatile uint32_t *)(0xc883c400 + (0x0b << 2))
+#define     HIU_MAILBOX_CLR_3                                  (0xc883c400 + (0x0c << 2))
+#define SEC_HIU_MAILBOX_CLR_3                                  (0xda83c400 + (0x0c << 2))
+#define   P_HIU_MAILBOX_CLR_3                                  (volatile uint32_t *)(0xc883c400 + (0x0c << 2))
+#define     HIU_MAILBOX_SET_4                                  (0xc883c400 + (0x0d << 2))
+#define SEC_HIU_MAILBOX_SET_4                                  (0xda83c400 + (0x0d << 2))
+#define   P_HIU_MAILBOX_SET_4                                  (volatile uint32_t *)(0xc883c400 + (0x0d << 2))
+#define     HIU_MAILBOX_STAT_4                                 (0xc883c400 + (0x0e << 2))
+#define SEC_HIU_MAILBOX_STAT_4                                 (0xda83c400 + (0x0e << 2))
+#define   P_HIU_MAILBOX_STAT_4                                 (volatile uint32_t *)(0xc883c400 + (0x0e << 2))
+#define     HIU_MAILBOX_CLR_4                                  (0xc883c400 + (0x0f << 2))
+#define SEC_HIU_MAILBOX_CLR_4                                  (0xda83c400 + (0x0f << 2))
+#define   P_HIU_MAILBOX_CLR_4                                  (volatile uint32_t *)(0xc883c400 + (0x0f << 2))
+#define     HIU_MAILBOX_SET_5                                  (0xc883c400 + (0x10 << 2))
+#define SEC_HIU_MAILBOX_SET_5                                  (0xda83c400 + (0x10 << 2))
+#define   P_HIU_MAILBOX_SET_5                                  (volatile uint32_t *)(0xc883c400 + (0x10 << 2))
+#define     HIU_MAILBOX_STAT_5                                 (0xc883c400 + (0x11 << 2))
+#define SEC_HIU_MAILBOX_STAT_5                                 (0xda83c400 + (0x11 << 2))
+#define   P_HIU_MAILBOX_STAT_5                                 (volatile uint32_t *)(0xc883c400 + (0x11 << 2))
+#define     HIU_MAILBOX_CLR_5                                  (0xc883c400 + (0x12 << 2))
+#define SEC_HIU_MAILBOX_CLR_5                                  (0xda83c400 + (0x12 << 2))
+#define   P_HIU_MAILBOX_CLR_5                                  (volatile uint32_t *)(0xc883c400 + (0x12 << 2))
+//========================================================================
+//  EFUSE
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8830000
+//  APB4_DECODER_SECURE_BASE         32'hDA830000
+#define     EFUSE_CNTL0                                        (0xc8830000 + (0x00 << 2))
+#define SEC_EFUSE_CNTL0                                        (0xda830000 + (0x00 << 2))
+#define   P_EFUSE_CNTL0                                        (volatile uint32_t *)(0xc8830000 + (0x00 << 2))
+#define     EFUSE_CNTL1                                        (0xc8830000 + (0x01 << 2))
+#define SEC_EFUSE_CNTL1                                        (0xda830000 + (0x01 << 2))
+#define   P_EFUSE_CNTL1                                        (volatile uint32_t *)(0xc8830000 + (0x01 << 2))
+#define     EFUSE_CNTL2                                        (0xc8830000 + (0x02 << 2))
+#define SEC_EFUSE_CNTL2                                        (0xda830000 + (0x02 << 2))
+#define   P_EFUSE_CNTL2                                        (volatile uint32_t *)(0xc8830000 + (0x02 << 2))
+#define     EFUSE_CNTL3                                        (0xc8830000 + (0x03 << 2))
+#define SEC_EFUSE_CNTL3                                        (0xda830000 + (0x03 << 2))
+#define   P_EFUSE_CNTL3                                        (volatile uint32_t *)(0xc8830000 + (0x03 << 2))
+#define     EFUSE_CNTL4                                        (0xc8830000 + (0x04 << 2))
+#define SEC_EFUSE_CNTL4                                        (0xda830000 + (0x04 << 2))
+#define   P_EFUSE_CNTL4                                        (volatile uint32_t *)(0xc8830000 + (0x04 << 2))
+#define     EFUSE_WDATA0                                       (0xc8830000 + (0x05 << 2))
+#define SEC_EFUSE_WDATA0                                       (0xda830000 + (0x05 << 2))
+#define   P_EFUSE_WDATA0                                       (volatile uint32_t *)(0xc8830000 + (0x05 << 2))
+#define     EFUSE_WDATA1                                       (0xc8830000 + (0x06 << 2))
+#define SEC_EFUSE_WDATA1                                       (0xda830000 + (0x06 << 2))
+#define   P_EFUSE_WDATA1                                       (volatile uint32_t *)(0xc8830000 + (0x06 << 2))
+#define     EFUSE_WDATA2                                       (0xc8830000 + (0x07 << 2))
+#define SEC_EFUSE_WDATA2                                       (0xda830000 + (0x07 << 2))
+#define   P_EFUSE_WDATA2                                       (volatile uint32_t *)(0xc8830000 + (0x07 << 2))
+#define     EFUSE_WDATA3                                       (0xc8830000 + (0x08 << 2))
+#define SEC_EFUSE_WDATA3                                       (0xda830000 + (0x08 << 2))
+#define   P_EFUSE_WDATA3                                       (volatile uint32_t *)(0xc8830000 + (0x08 << 2))
+#define     EFUSE_RDATA0                                       (0xc8830000 + (0x09 << 2))
+#define SEC_EFUSE_RDATA0                                       (0xda830000 + (0x09 << 2))
+#define   P_EFUSE_RDATA0                                       (volatile uint32_t *)(0xc8830000 + (0x09 << 2))
+#define     EFUSE_RDATA1                                       (0xc8830000 + (0x0a << 2))
+#define SEC_EFUSE_RDATA1                                       (0xda830000 + (0x0a << 2))
+#define   P_EFUSE_RDATA1                                       (volatile uint32_t *)(0xc8830000 + (0x0a << 2))
+#define     EFUSE_RDATA2                                       (0xc8830000 + (0x0b << 2))
+#define SEC_EFUSE_RDATA2                                       (0xda830000 + (0x0b << 2))
+#define   P_EFUSE_RDATA2                                       (volatile uint32_t *)(0xc8830000 + (0x0b << 2))
+#define     EFUSE_RDATA3                                       (0xc8830000 + (0x0c << 2))
+#define SEC_EFUSE_RDATA3                                       (0xda830000 + (0x0c << 2))
+#define   P_EFUSE_RDATA3                                       (volatile uint32_t *)(0xc8830000 + (0x0c << 2))
+#define     EFUSE_RD_DISABLE                                   (0xc8830000 + (0x10 << 2))
+#define SEC_EFUSE_RD_DISABLE                                   (0xda830000 + (0x10 << 2))
+#define   P_EFUSE_RD_DISABLE                                   (volatile uint32_t *)(0xc8830000 + (0x10 << 2))
+#define     EFUSE_WR_DISABLE                                   (0xc8830000 + (0x11 << 2))
+#define SEC_EFUSE_WR_DISABLE                                   (0xda830000 + (0x11 << 2))
+#define   P_EFUSE_WR_DISABLE                                   (volatile uint32_t *)(0xc8830000 + (0x11 << 2))
+#define     EFUSE_OBFUSCATE                                    (0xc8830000 + (0x12 << 2))
+#define SEC_EFUSE_OBFUSCATE                                    (0xda830000 + (0x12 << 2))
+#define   P_EFUSE_OBFUSCATE                                    (volatile uint32_t *)(0xc8830000 + (0x12 << 2))
+#define     EFUSE_AES_KEY32                                    (0xc8830000 + (0x13 << 2))
+#define SEC_EFUSE_AES_KEY32                                    (0xda830000 + (0x13 << 2))
+#define   P_EFUSE_AES_KEY32                                    (volatile uint32_t *)(0xc8830000 + (0x13 << 2))
+#define     KEY_LDR_USR_CNTL                                   (0xc8830000 + (0x20 << 2))
+#define SEC_KEY_LDR_USR_CNTL                                   (0xda830000 + (0x20 << 2))
+#define   P_KEY_LDR_USR_CNTL                                   (volatile uint32_t *)(0xc8830000 + (0x20 << 2))
+#define     KEY_LDR_USR_RAM_W                                  (0xc8830000 + (0x21 << 2))
+#define SEC_KEY_LDR_USR_RAM_W                                  (0xda830000 + (0x21 << 2))
+#define   P_KEY_LDR_USR_RAM_W                                  (volatile uint32_t *)(0xc8830000 + (0x21 << 2))
+#define     KEY_LDR_VENDOR_ID                                  (0xc8830000 + (0x22 << 2))
+#define SEC_KEY_LDR_VENDOR_ID                                  (0xda830000 + (0x22 << 2))
+#define   P_KEY_LDR_VENDOR_ID                                  (volatile uint32_t *)(0xc8830000 + (0x22 << 2))
+#define     KEY_LDR_SEC_REG0                                   (0xc8830000 + (0x23 << 2))
+#define SEC_KEY_LDR_SEC_REG0                                   (0xda830000 + (0x23 << 2))
+#define   P_KEY_LDR_SEC_REG0                                   (volatile uint32_t *)(0xc8830000 + (0x23 << 2))
+#define     KEY_LDR_SEC_CFG                                    (0xc8830000 + (0x24 << 2))
+#define SEC_KEY_LDR_SEC_CFG                                    (0xda830000 + (0x24 << 2))
+#define   P_KEY_LDR_SEC_CFG                                    (volatile uint32_t *)(0xc8830000 + (0x24 << 2))
+#define     KEY_LDR_SEC_BLK_NUM                                (0xc8830000 + (0x25 << 2))
+#define SEC_KEY_LDR_SEC_BLK_NUM                                (0xda830000 + (0x25 << 2))
+#define   P_KEY_LDR_SEC_BLK_NUM                                (volatile uint32_t *)(0xc8830000 + (0x25 << 2))
+#define     KEY_LDR_NONCE_0                                    (0xc8830000 + (0x26 << 2))
+#define SEC_KEY_LDR_NONCE_0                                    (0xda830000 + (0x26 << 2))
+#define   P_KEY_LDR_NONCE_0                                    (volatile uint32_t *)(0xc8830000 + (0x26 << 2))
+#define     KEY_LDR_NONCE_1                                    (0xc8830000 + (0x27 << 2))
+#define SEC_KEY_LDR_NONCE_1                                    (0xda830000 + (0x27 << 2))
+#define   P_KEY_LDR_NONCE_1                                    (volatile uint32_t *)(0xc8830000 + (0x27 << 2))
+#define     KEY_LDR_NONCE_2                                    (0xc8830000 + (0x28 << 2))
+#define SEC_KEY_LDR_NONCE_2                                    (0xda830000 + (0x28 << 2))
+#define   P_KEY_LDR_NONCE_2                                    (volatile uint32_t *)(0xc8830000 + (0x28 << 2))
+#define     KEY_LDR_NONCE_3                                    (0xc8830000 + (0x29 << 2))
+#define SEC_KEY_LDR_NONCE_3                                    (0xda830000 + (0x29 << 2))
+#define   P_KEY_LDR_NONCE_3                                    (volatile uint32_t *)(0xc8830000 + (0x29 << 2))
+//========================================================================
+//  BLKMV
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8832000
+//  APB4_DECODER_SECURE_BASE         32'hDA832000
+//
+// Secure APB3 Slot 3 registers
+//
+#define     SEC_BLKMV_AES_REG0                                 (0xc8832000 + (0x00 << 2))
+#define SEC_SEC_BLKMV_AES_REG0                                 (0xda832000 + (0x00 << 2))
+#define   P_SEC_BLKMV_AES_REG0                                 (volatile uint32_t *)(0xc8832000 + (0x00 << 2))
+#define     SEC_BLKMV_AES_PIO_W0                               (0xc8832000 + (0x01 << 2))
+#define SEC_SEC_BLKMV_AES_PIO_W0                               (0xda832000 + (0x01 << 2))
+#define   P_SEC_BLKMV_AES_PIO_W0                               (volatile uint32_t *)(0xc8832000 + (0x01 << 2))
+#define     SEC_BLKMV_AES_PIO_W1                               (0xc8832000 + (0x02 << 2))
+#define SEC_SEC_BLKMV_AES_PIO_W1                               (0xda832000 + (0x02 << 2))
+#define   P_SEC_BLKMV_AES_PIO_W1                               (volatile uint32_t *)(0xc8832000 + (0x02 << 2))
+#define     SEC_BLKMV_AES_PIO_W2                               (0xc8832000 + (0x03 << 2))
+#define SEC_SEC_BLKMV_AES_PIO_W2                               (0xda832000 + (0x03 << 2))
+#define   P_SEC_BLKMV_AES_PIO_W2                               (volatile uint32_t *)(0xc8832000 + (0x03 << 2))
+#define     SEC_BLKMV_AES_PIO_W3                               (0xc8832000 + (0x04 << 2))
+#define SEC_SEC_BLKMV_AES_PIO_W3                               (0xda832000 + (0x04 << 2))
+#define   P_SEC_BLKMV_AES_PIO_W3                               (volatile uint32_t *)(0xc8832000 + (0x04 << 2))
+#define     SEC_BLKMV_TDES_KEY_LO                              (0xc8832000 + (0x08 << 2))
+#define SEC_SEC_BLKMV_TDES_KEY_LO                              (0xda832000 + (0x08 << 2))
+#define   P_SEC_BLKMV_TDES_KEY_LO                              (volatile uint32_t *)(0xc8832000 + (0x08 << 2))
+#define     SEC_BLKMV_TDES_KEY_HI                              (0xc8832000 + (0x09 << 2))
+#define SEC_SEC_BLKMV_TDES_KEY_HI                              (0xda832000 + (0x09 << 2))
+#define   P_SEC_BLKMV_TDES_KEY_HI                              (volatile uint32_t *)(0xc8832000 + (0x09 << 2))
+#define     SEC_BLKMV_TDES_CONTROL                             (0xc8832000 + (0x0a << 2))
+#define SEC_SEC_BLKMV_TDES_CONTROL                             (0xda832000 + (0x0a << 2))
+#define   P_SEC_BLKMV_TDES_CONTROL                             (volatile uint32_t *)(0xc8832000 + (0x0a << 2))
+#define     SEC_BLKMV_AES_IV_0                                 (0xc8832000 + (0x0b << 2))
+#define SEC_SEC_BLKMV_AES_IV_0                                 (0xda832000 + (0x0b << 2))
+#define   P_SEC_BLKMV_AES_IV_0                                 (volatile uint32_t *)(0xc8832000 + (0x0b << 2))
+#define     SEC_BLKMV_AES_IV_1                                 (0xc8832000 + (0x0c << 2))
+#define SEC_SEC_BLKMV_AES_IV_1                                 (0xda832000 + (0x0c << 2))
+#define   P_SEC_BLKMV_AES_IV_1                                 (volatile uint32_t *)(0xc8832000 + (0x0c << 2))
+#define     SEC_BLKMV_AES_IV_2                                 (0xc8832000 + (0x0d << 2))
+#define SEC_SEC_BLKMV_AES_IV_2                                 (0xda832000 + (0x0d << 2))
+#define   P_SEC_BLKMV_AES_IV_2                                 (volatile uint32_t *)(0xc8832000 + (0x0d << 2))
+#define     SEC_BLKMV_AES_IV_3                                 (0xc8832000 + (0x0e << 2))
+#define SEC_SEC_BLKMV_AES_IV_3                                 (0xda832000 + (0x0e << 2))
+#define   P_SEC_BLKMV_AES_IV_3                                 (volatile uint32_t *)(0xc8832000 + (0x0e << 2))
+#define     SEC_BLKMV_AES_KEY_0                                (0xc8832000 + (0x10 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_0                                (0xda832000 + (0x10 << 2))
+#define   P_SEC_BLKMV_AES_KEY_0                                (volatile uint32_t *)(0xc8832000 + (0x10 << 2))
+#define     SEC_BLKMV_AES_KEY_1                                (0xc8832000 + (0x11 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_1                                (0xda832000 + (0x11 << 2))
+#define   P_SEC_BLKMV_AES_KEY_1                                (volatile uint32_t *)(0xc8832000 + (0x11 << 2))
+#define     SEC_BLKMV_AES_KEY_2                                (0xc8832000 + (0x12 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_2                                (0xda832000 + (0x12 << 2))
+#define   P_SEC_BLKMV_AES_KEY_2                                (volatile uint32_t *)(0xc8832000 + (0x12 << 2))
+#define     SEC_BLKMV_AES_KEY_3                                (0xc8832000 + (0x13 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_3                                (0xda832000 + (0x13 << 2))
+#define   P_SEC_BLKMV_AES_KEY_3                                (volatile uint32_t *)(0xc8832000 + (0x13 << 2))
+#define     SEC_BLKMV_AES_KEY_4                                (0xc8832000 + (0x14 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_4                                (0xda832000 + (0x14 << 2))
+#define   P_SEC_BLKMV_AES_KEY_4                                (volatile uint32_t *)(0xc8832000 + (0x14 << 2))
+#define     SEC_BLKMV_AES_KEY_5                                (0xc8832000 + (0x15 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_5                                (0xda832000 + (0x15 << 2))
+#define   P_SEC_BLKMV_AES_KEY_5                                (volatile uint32_t *)(0xc8832000 + (0x15 << 2))
+#define     SEC_BLKMV_AES_KEY_6                                (0xc8832000 + (0x16 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_6                                (0xda832000 + (0x16 << 2))
+#define   P_SEC_BLKMV_AES_KEY_6                                (volatile uint32_t *)(0xc8832000 + (0x16 << 2))
+#define     SEC_BLKMV_AES_KEY_7                                (0xc8832000 + (0x17 << 2))
+#define SEC_SEC_BLKMV_AES_KEY_7                                (0xda832000 + (0x17 << 2))
+#define   P_SEC_BLKMV_AES_KEY_7                                (volatile uint32_t *)(0xc8832000 + (0x17 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_START0                      (0xc8832000 + (0x18 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_START0                      (0xda832000 + (0x18 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_START0                      (volatile uint32_t *)(0xc8832000 + (0x18 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_CURR0                       (0xc8832000 + (0x19 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_CURR0                       (0xda832000 + (0x19 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_CURR0                       (volatile uint32_t *)(0xc8832000 + (0x19 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_END0                        (0xc8832000 + (0x1a << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_END0                        (0xda832000 + (0x1a << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_END0                        (volatile uint32_t *)(0xc8832000 + (0x1a << 2))
+#define     SEC_BLKMV_THREAD_TABLE_START1                      (0xc8832000 + (0x1b << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_START1                      (0xda832000 + (0x1b << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_START1                      (volatile uint32_t *)(0xc8832000 + (0x1b << 2))
+#define     SEC_BLKMV_THREAD_TABLE_CURR1                       (0xc8832000 + (0x1c << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_CURR1                       (0xda832000 + (0x1c << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_CURR1                       (volatile uint32_t *)(0xc8832000 + (0x1c << 2))
+#define     SEC_BLKMV_THREAD_TABLE_END1                        (0xc8832000 + (0x1d << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_END1                        (0xda832000 + (0x1d << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_END1                        (volatile uint32_t *)(0xc8832000 + (0x1d << 2))
+#define     SEC_BLKMV_THREAD_TABLE_START2                      (0xc8832000 + (0x1e << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_START2                      (0xda832000 + (0x1e << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_START2                      (volatile uint32_t *)(0xc8832000 + (0x1e << 2))
+#define     SEC_BLKMV_THREAD_TABLE_CURR2                       (0xc8832000 + (0x1f << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_CURR2                       (0xda832000 + (0x1f << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_CURR2                       (volatile uint32_t *)(0xc8832000 + (0x1f << 2))
+#define     SEC_BLKMV_THREAD_TABLE_END2                        (0xc8832000 + (0x20 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_END2                        (0xda832000 + (0x20 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_END2                        (volatile uint32_t *)(0xc8832000 + (0x20 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_START3                      (0xc8832000 + (0x21 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_START3                      (0xda832000 + (0x21 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_START3                      (volatile uint32_t *)(0xc8832000 + (0x21 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_CURR3                       (0xc8832000 + (0x22 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_CURR3                       (0xda832000 + (0x22 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_CURR3                       (volatile uint32_t *)(0xc8832000 + (0x22 << 2))
+#define     SEC_BLKMV_THREAD_TABLE_END3                        (0xc8832000 + (0x23 << 2))
+#define SEC_SEC_BLKMV_THREAD_TABLE_END3                        (0xda832000 + (0x23 << 2))
+#define   P_SEC_BLKMV_THREAD_TABLE_END3                        (volatile uint32_t *)(0xc8832000 + (0x23 << 2))
+#define     SEC_BLKMV_GEN_REG0                                 (0xc8832000 + (0x24 << 2))
+#define SEC_SEC_BLKMV_GEN_REG0                                 (0xda832000 + (0x24 << 2))
+#define   P_SEC_BLKMV_GEN_REG0                                 (volatile uint32_t *)(0xc8832000 + (0x24 << 2))
+#define     SEC_BLKMV_PIO_CNTL0                                (0xc8832000 + (0x25 << 2))
+#define SEC_SEC_BLKMV_PIO_CNTL0                                (0xda832000 + (0x25 << 2))
+#define   P_SEC_BLKMV_PIO_CNTL0                                (volatile uint32_t *)(0xc8832000 + (0x25 << 2))
+#define     SEC_BLKMV_PIO_DATA0                                (0xc8832000 + (0x26 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA0                                (0xda832000 + (0x26 << 2))
+#define   P_SEC_BLKMV_PIO_DATA0                                (volatile uint32_t *)(0xc8832000 + (0x26 << 2))
+#define     SEC_BLKMV_PIO_DATA1                                (0xc8832000 + (0x27 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA1                                (0xda832000 + (0x27 << 2))
+#define   P_SEC_BLKMV_PIO_DATA1                                (volatile uint32_t *)(0xc8832000 + (0x27 << 2))
+#define     SEC_BLKMV_PIO_DATA2                                (0xc8832000 + (0x28 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA2                                (0xda832000 + (0x28 << 2))
+#define   P_SEC_BLKMV_PIO_DATA2                                (volatile uint32_t *)(0xc8832000 + (0x28 << 2))
+#define     SEC_BLKMV_PIO_DATA3                                (0xc8832000 + (0x29 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA3                                (0xda832000 + (0x29 << 2))
+#define   P_SEC_BLKMV_PIO_DATA3                                (volatile uint32_t *)(0xc8832000 + (0x29 << 2))
+#define     SEC_BLKMV_PIO_DATA4                                (0xc8832000 + (0x2a << 2))
+#define SEC_SEC_BLKMV_PIO_DATA4                                (0xda832000 + (0x2a << 2))
+#define   P_SEC_BLKMV_PIO_DATA4                                (volatile uint32_t *)(0xc8832000 + (0x2a << 2))
+#define     SEC_BLKMV_PIO_DATA5                                (0xc8832000 + (0x2b << 2))
+#define SEC_SEC_BLKMV_PIO_DATA5                                (0xda832000 + (0x2b << 2))
+#define   P_SEC_BLKMV_PIO_DATA5                                (volatile uint32_t *)(0xc8832000 + (0x2b << 2))
+#define     SEC_BLKMV_PIO_DATA6                                (0xc8832000 + (0x2c << 2))
+#define SEC_SEC_BLKMV_PIO_DATA6                                (0xda832000 + (0x2c << 2))
+#define   P_SEC_BLKMV_PIO_DATA6                                (volatile uint32_t *)(0xc8832000 + (0x2c << 2))
+#define     SEC_BLKMV_PIO_DATA7                                (0xc8832000 + (0x2d << 2))
+#define SEC_SEC_BLKMV_PIO_DATA7                                (0xda832000 + (0x2d << 2))
+#define   P_SEC_BLKMV_PIO_DATA7                                (volatile uint32_t *)(0xc8832000 + (0x2d << 2))
+#define     SEC_BLKMV_PIO_DATA8                                (0xc8832000 + (0x2e << 2))
+#define SEC_SEC_BLKMV_PIO_DATA8                                (0xda832000 + (0x2e << 2))
+#define   P_SEC_BLKMV_PIO_DATA8                                (volatile uint32_t *)(0xc8832000 + (0x2e << 2))
+#define     SEC_BLKMV_PIO_DATA9                                (0xc8832000 + (0x2f << 2))
+#define SEC_SEC_BLKMV_PIO_DATA9                                (0xda832000 + (0x2f << 2))
+#define   P_SEC_BLKMV_PIO_DATA9                                (volatile uint32_t *)(0xc8832000 + (0x2f << 2))
+#define     SEC_BLKMV_PIO_DATA10                               (0xc8832000 + (0x30 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA10                               (0xda832000 + (0x30 << 2))
+#define   P_SEC_BLKMV_PIO_DATA10                               (volatile uint32_t *)(0xc8832000 + (0x30 << 2))
+#define     SEC_BLKMV_PIO_DATA11                               (0xc8832000 + (0x31 << 2))
+#define SEC_SEC_BLKMV_PIO_DATA11                               (0xda832000 + (0x31 << 2))
+#define   P_SEC_BLKMV_PIO_DATA11                               (volatile uint32_t *)(0xc8832000 + (0x31 << 2))
+#define     SEC_BLKMV_SHA_CONTROL                              (0xc8832000 + (0x32 << 2))
+#define SEC_SEC_BLKMV_SHA_CONTROL                              (0xda832000 + (0x32 << 2))
+#define   P_SEC_BLKMV_SHA_CONTROL                              (volatile uint32_t *)(0xc8832000 + (0x32 << 2))
+#define     SEC_BLKMV_SHA_PIO_WDATA                            (0xc8832000 + (0x33 << 2))
+#define SEC_SEC_BLKMV_SHA_PIO_WDATA                            (0xda832000 + (0x33 << 2))
+#define   P_SEC_BLKMV_SHA_PIO_WDATA                            (volatile uint32_t *)(0xc8832000 + (0x33 << 2))
+#define     SEC_BLKMV_SHA_DMA_MSG_IN                           (0xc8832000 + (0x34 << 2))
+#define SEC_SEC_BLKMV_SHA_DMA_MSG_IN                           (0xda832000 + (0x34 << 2))
+#define   P_SEC_BLKMV_SHA_DMA_MSG_IN                           (volatile uint32_t *)(0xc8832000 + (0x34 << 2))
+#define     SEC_BLKMV_SHA_DMA_DATALEN_IN                       (0xc8832000 + (0x35 << 2))
+#define SEC_SEC_BLKMV_SHA_DMA_DATALEN_IN                       (0xda832000 + (0x35 << 2))
+#define   P_SEC_BLKMV_SHA_DMA_DATALEN_IN                       (volatile uint32_t *)(0xc8832000 + (0x35 << 2))
+#define     SEC_BLKMV_AES_CW_WR                                (0xc8832000 + (0x38 << 2))
+#define SEC_SEC_BLKMV_AES_CW_WR                                (0xda832000 + (0x38 << 2))
+#define   P_SEC_BLKMV_AES_CW_WR                                (volatile uint32_t *)(0xc8832000 + (0x38 << 2))
+#define     SEC_BLKMV_TDES_CW_WR                               (0xc8832000 + (0x39 << 2))
+#define SEC_SEC_BLKMV_TDES_CW_WR                               (0xda832000 + (0x39 << 2))
+#define   P_SEC_BLKMV_TDES_CW_WR                               (volatile uint32_t *)(0xc8832000 + (0x39 << 2))
+// ----------------------------
+// Non-Secure
+// ----------------------------
+#define     NDMA_CNTL_REG0                                     (0xc8832000 + (0x70 << 2))
+#define SEC_NDMA_CNTL_REG0                                     (0xda832000 + (0x70 << 2))
+#define   P_NDMA_CNTL_REG0                                     (volatile uint32_t *)(0xc8832000 + (0x70 << 2))
+#define NDMA_STATUS                 26
+#define NDMA_PERIODIC_INT_DLY_MSB   25
+#define NDMA_PERIODIC_INT_DLY_LSB   16
+#define NDMA_PERIODIC_INT_EN        15
+#define NDMA_ENABLE                 14
+#define NDMA_AHB_DELAY_MSB          13
+#define NDMA_AHB_DELAY_LSB          0
+#define     NDMA_TABLE_ADD_REG                                 (0xc8832000 + (0x72 << 2))
+#define SEC_NDMA_TABLE_ADD_REG                                 (0xda832000 + (0x72 << 2))
+#define   P_NDMA_TABLE_ADD_REG                                 (volatile uint32_t *)(0xc8832000 + (0x72 << 2))
+#define     NDMA_TDES_KEY_LO                                   (0xc8832000 + (0x73 << 2))
+#define SEC_NDMA_TDES_KEY_LO                                   (0xda832000 + (0x73 << 2))
+#define   P_NDMA_TDES_KEY_LO                                   (volatile uint32_t *)(0xc8832000 + (0x73 << 2))
+#define     NDMA_TDES_KEY_HI                                   (0xc8832000 + (0x74 << 2))
+#define SEC_NDMA_TDES_KEY_HI                                   (0xda832000 + (0x74 << 2))
+#define   P_NDMA_TDES_KEY_HI                                   (volatile uint32_t *)(0xc8832000 + (0x74 << 2))
+#define     NDMA_TDES_CONTROL                                  (0xc8832000 + (0x75 << 2))
+#define SEC_NDMA_TDES_CONTROL                                  (0xda832000 + (0x75 << 2))
+#define   P_NDMA_TDES_CONTROL                                  (volatile uint32_t *)(0xc8832000 + (0x75 << 2))
+#define     NDMA_RIJNDAEL_CONTROL                              (0xc8832000 + (0x76 << 2))
+#define SEC_NDMA_RIJNDAEL_CONTROL                              (0xda832000 + (0x76 << 2))
+#define   P_NDMA_RIJNDAEL_CONTROL                              (volatile uint32_t *)(0xc8832000 + (0x76 << 2))
+#define     NDMA_RIJNDAEL_RK_FIFO                              (0xc8832000 + (0x77 << 2))
+#define SEC_NDMA_RIJNDAEL_RK_FIFO                              (0xda832000 + (0x77 << 2))
+#define   P_NDMA_RIJNDAEL_RK_FIFO                              (volatile uint32_t *)(0xc8832000 + (0x77 << 2))
+#define     NDMA_CRC_OUT                                       (0xc8832000 + (0x78 << 2))
+#define SEC_NDMA_CRC_OUT                                       (0xda832000 + (0x78 << 2))
+#define   P_NDMA_CRC_OUT                                       (volatile uint32_t *)(0xc8832000 + (0x78 << 2))
+#define     NDMA_THREAD_REG                                    (0xc8832000 + (0x79 << 2))
+#define SEC_NDMA_THREAD_REG                                    (0xda832000 + (0x79 << 2))
+#define   P_NDMA_THREAD_REG                                    (volatile uint32_t *)(0xc8832000 + (0x79 << 2))
+#define     NDMA_THREAD_TABLE_START0                           (0xc8832000 + (0x80 << 2))
+#define SEC_NDMA_THREAD_TABLE_START0                           (0xda832000 + (0x80 << 2))
+#define   P_NDMA_THREAD_TABLE_START0                           (volatile uint32_t *)(0xc8832000 + (0x80 << 2))
+#define     NDMA_THREAD_TABLE_CURR0                            (0xc8832000 + (0x81 << 2))
+#define SEC_NDMA_THREAD_TABLE_CURR0                            (0xda832000 + (0x81 << 2))
+#define   P_NDMA_THREAD_TABLE_CURR0                            (volatile uint32_t *)(0xc8832000 + (0x81 << 2))
+#define     NDMA_THREAD_TABLE_END0                             (0xc8832000 + (0x82 << 2))
+#define SEC_NDMA_THREAD_TABLE_END0                             (0xda832000 + (0x82 << 2))
+#define   P_NDMA_THREAD_TABLE_END0                             (volatile uint32_t *)(0xc8832000 + (0x82 << 2))
+#define     NDMA_THREAD_TABLE_START1                           (0xc8832000 + (0x83 << 2))
+#define SEC_NDMA_THREAD_TABLE_START1                           (0xda832000 + (0x83 << 2))
+#define   P_NDMA_THREAD_TABLE_START1                           (volatile uint32_t *)(0xc8832000 + (0x83 << 2))
+#define     NDMA_THREAD_TABLE_CURR1                            (0xc8832000 + (0x84 << 2))
+#define SEC_NDMA_THREAD_TABLE_CURR1                            (0xda832000 + (0x84 << 2))
+#define   P_NDMA_THREAD_TABLE_CURR1                            (volatile uint32_t *)(0xc8832000 + (0x84 << 2))
+#define     NDMA_THREAD_TABLE_END1                             (0xc8832000 + (0x85 << 2))
+#define SEC_NDMA_THREAD_TABLE_END1                             (0xda832000 + (0x85 << 2))
+#define   P_NDMA_THREAD_TABLE_END1                             (volatile uint32_t *)(0xc8832000 + (0x85 << 2))
+#define     NDMA_THREAD_TABLE_START2                           (0xc8832000 + (0x86 << 2))
+#define SEC_NDMA_THREAD_TABLE_START2                           (0xda832000 + (0x86 << 2))
+#define   P_NDMA_THREAD_TABLE_START2                           (volatile uint32_t *)(0xc8832000 + (0x86 << 2))
+#define     NDMA_THREAD_TABLE_CURR2                            (0xc8832000 + (0x87 << 2))
+#define SEC_NDMA_THREAD_TABLE_CURR2                            (0xda832000 + (0x87 << 2))
+#define   P_NDMA_THREAD_TABLE_CURR2                            (volatile uint32_t *)(0xc8832000 + (0x87 << 2))
+#define     NDMA_THREAD_TABLE_END2                             (0xc8832000 + (0x88 << 2))
+#define SEC_NDMA_THREAD_TABLE_END2                             (0xda832000 + (0x88 << 2))
+#define   P_NDMA_THREAD_TABLE_END2                             (volatile uint32_t *)(0xc8832000 + (0x88 << 2))
+#define     NDMA_THREAD_TABLE_START3                           (0xc8832000 + (0x89 << 2))
+#define SEC_NDMA_THREAD_TABLE_START3                           (0xda832000 + (0x89 << 2))
+#define   P_NDMA_THREAD_TABLE_START3                           (volatile uint32_t *)(0xc8832000 + (0x89 << 2))
+#define     NDMA_THREAD_TABLE_CURR3                            (0xc8832000 + (0x8a << 2))
+#define SEC_NDMA_THREAD_TABLE_CURR3                            (0xda832000 + (0x8a << 2))
+#define   P_NDMA_THREAD_TABLE_CURR3                            (volatile uint32_t *)(0xc8832000 + (0x8a << 2))
+#define     NDMA_THREAD_TABLE_END3                             (0xc8832000 + (0x8b << 2))
+#define SEC_NDMA_THREAD_TABLE_END3                             (0xda832000 + (0x8b << 2))
+#define   P_NDMA_THREAD_TABLE_END3                             (volatile uint32_t *)(0xc8832000 + (0x8b << 2))
+#define     NDMA_CNTL_REG1                                     (0xc8832000 + (0x8c << 2))
+#define SEC_NDMA_CNTL_REG1                                     (0xda832000 + (0x8c << 2))
+#define   P_NDMA_CNTL_REG1                                     (volatile uint32_t *)(0xc8832000 + (0x8c << 2))
+// Non-secure AES Key Writes
+#define     NDMA_AES_KEY_0                                     (0xc8832000 + (0x90 << 2))
+#define SEC_NDMA_AES_KEY_0                                     (0xda832000 + (0x90 << 2))
+#define   P_NDMA_AES_KEY_0                                     (volatile uint32_t *)(0xc8832000 + (0x90 << 2))
+#define     NDMA_AES_KEY_1                                     (0xc8832000 + (0x91 << 2))
+#define SEC_NDMA_AES_KEY_1                                     (0xda832000 + (0x91 << 2))
+#define   P_NDMA_AES_KEY_1                                     (volatile uint32_t *)(0xc8832000 + (0x91 << 2))
+#define     NDMA_AES_KEY_2                                     (0xc8832000 + (0x92 << 2))
+#define SEC_NDMA_AES_KEY_2                                     (0xda832000 + (0x92 << 2))
+#define   P_NDMA_AES_KEY_2                                     (volatile uint32_t *)(0xc8832000 + (0x92 << 2))
+#define     NDMA_AES_KEY_3                                     (0xc8832000 + (0x93 << 2))
+#define SEC_NDMA_AES_KEY_3                                     (0xda832000 + (0x93 << 2))
+#define   P_NDMA_AES_KEY_3                                     (volatile uint32_t *)(0xc8832000 + (0x93 << 2))
+#define     NDMA_AES_KEY_4                                     (0xc8832000 + (0x94 << 2))
+#define SEC_NDMA_AES_KEY_4                                     (0xda832000 + (0x94 << 2))
+#define   P_NDMA_AES_KEY_4                                     (volatile uint32_t *)(0xc8832000 + (0x94 << 2))
+#define     NDMA_AES_KEY_5                                     (0xc8832000 + (0x95 << 2))
+#define SEC_NDMA_AES_KEY_5                                     (0xda832000 + (0x95 << 2))
+#define   P_NDMA_AES_KEY_5                                     (volatile uint32_t *)(0xc8832000 + (0x95 << 2))
+#define     NDMA_AES_KEY_6                                     (0xc8832000 + (0x96 << 2))
+#define SEC_NDMA_AES_KEY_6                                     (0xda832000 + (0x96 << 2))
+#define   P_NDMA_AES_KEY_6                                     (volatile uint32_t *)(0xc8832000 + (0x96 << 2))
+#define     NDMA_AES_KEY_7                                     (0xc8832000 + (0x97 << 2))
+#define SEC_NDMA_AES_KEY_7                                     (0xda832000 + (0x97 << 2))
+#define   P_NDMA_AES_KEY_7                                     (volatile uint32_t *)(0xc8832000 + (0x97 << 2))
+// Non-secure AES IV Writes
+#define     NDMA_AES_IV_0                                      (0xc8832000 + (0x98 << 2))
+#define SEC_NDMA_AES_IV_0                                      (0xda832000 + (0x98 << 2))
+#define   P_NDMA_AES_IV_0                                      (volatile uint32_t *)(0xc8832000 + (0x98 << 2))
+#define     NDMA_AES_IV_1                                      (0xc8832000 + (0x99 << 2))
+#define SEC_NDMA_AES_IV_1                                      (0xda832000 + (0x99 << 2))
+#define   P_NDMA_AES_IV_1                                      (volatile uint32_t *)(0xc8832000 + (0x99 << 2))
+#define     NDMA_AES_IV_2                                      (0xc8832000 + (0x9a << 2))
+#define SEC_NDMA_AES_IV_2                                      (0xda832000 + (0x9a << 2))
+#define   P_NDMA_AES_IV_2                                      (volatile uint32_t *)(0xc8832000 + (0x9a << 2))
+#define     NDMA_AES_IV_3                                      (0xc8832000 + (0x9b << 2))
+#define SEC_NDMA_AES_IV_3                                      (0xda832000 + (0x9b << 2))
+#define   P_NDMA_AES_IV_3                                      (volatile uint32_t *)(0xc8832000 + (0x9b << 2))
+#define     NDMA_AES_REG0                                      (0xc8832000 + (0x9c << 2))
+#define SEC_NDMA_AES_REG0                                      (0xda832000 + (0x9c << 2))
+#define   P_NDMA_AES_REG0                                      (volatile uint32_t *)(0xc8832000 + (0x9c << 2))
+// Non-secure SHA Message In writes
+#define     NDMA_SHA_MSG_IN                                    (0xc8832000 + (0x9d << 2))
+#define SEC_NDMA_SHA_MSG_IN                                    (0xda832000 + (0x9d << 2))
+#define   P_NDMA_SHA_MSG_IN                                    (volatile uint32_t *)(0xc8832000 + (0x9d << 2))
+// Non-secure SHA Datalenth In writes
+#define     NDMA_SHA_DATALEN_IN                                (0xc8832000 + (0x9e << 2))
+#define SEC_NDMA_SHA_DATALEN_IN                                (0xda832000 + (0x9e << 2))
+#define   P_NDMA_SHA_DATALEN_IN                                (volatile uint32_t *)(0xc8832000 + (0x9e << 2))
+#define     NDMA_SHA_CONTROL                                   (0xc8832000 + (0x9f << 2))
+#define SEC_NDMA_SHA_CONTROL                                   (0xda832000 + (0x9f << 2))
+#define   P_NDMA_SHA_CONTROL                                   (volatile uint32_t *)(0xc8832000 + (0x9f << 2))
+// Non-secure SHA Reads
+#define     NDMA_CRYPTO_OUT_0                                  (0xc8832000 + (0xa0 << 2))
+#define SEC_NDMA_CRYPTO_OUT_0                                  (0xda832000 + (0xa0 << 2))
+#define   P_NDMA_CRYPTO_OUT_0                                  (volatile uint32_t *)(0xc8832000 + (0xa0 << 2))
+#define     NDMA_CRYPTO_OUT_1                                  (0xc8832000 + (0xa1 << 2))
+#define SEC_NDMA_CRYPTO_OUT_1                                  (0xda832000 + (0xa1 << 2))
+#define   P_NDMA_CRYPTO_OUT_1                                  (volatile uint32_t *)(0xc8832000 + (0xa1 << 2))
+#define     NDMA_CRYPTO_OUT_2                                  (0xc8832000 + (0xa2 << 2))
+#define SEC_NDMA_CRYPTO_OUT_2                                  (0xda832000 + (0xa2 << 2))
+#define   P_NDMA_CRYPTO_OUT_2                                  (volatile uint32_t *)(0xc8832000 + (0xa2 << 2))
+#define     NDMA_CRYPTO_OUT_3                                  (0xc8832000 + (0xa3 << 2))
+#define SEC_NDMA_CRYPTO_OUT_3                                  (0xda832000 + (0xa3 << 2))
+#define   P_NDMA_CRYPTO_OUT_3                                  (volatile uint32_t *)(0xc8832000 + (0xa3 << 2))
+#define     NDMA_CRYPTO_OUT_4                                  (0xc8832000 + (0xa4 << 2))
+#define SEC_NDMA_CRYPTO_OUT_4                                  (0xda832000 + (0xa4 << 2))
+#define   P_NDMA_CRYPTO_OUT_4                                  (volatile uint32_t *)(0xc8832000 + (0xa4 << 2))
+#define     NDMA_CRYPTO_OUT_5                                  (0xc8832000 + (0xa5 << 2))
+#define SEC_NDMA_CRYPTO_OUT_5                                  (0xda832000 + (0xa5 << 2))
+#define   P_NDMA_CRYPTO_OUT_5                                  (volatile uint32_t *)(0xc8832000 + (0xa5 << 2))
+#define     NDMA_CRYPTO_OUT_6                                  (0xc8832000 + (0xa6 << 2))
+#define SEC_NDMA_CRYPTO_OUT_6                                  (0xda832000 + (0xa6 << 2))
+#define   P_NDMA_CRYPTO_OUT_6                                  (volatile uint32_t *)(0xc8832000 + (0xa6 << 2))
+#define     NDMA_CRYPTO_OUT_7                                  (0xc8832000 + (0xa7 << 2))
+#define SEC_NDMA_CRYPTO_OUT_7                                  (0xda832000 + (0xa7 << 2))
+#define   P_NDMA_CRYPTO_OUT_7                                  (volatile uint32_t *)(0xc8832000 + (0xa7 << 2))
+#define     NDMA_CRYPTO_OUT_8                                  (0xc8832000 + (0xa8 << 2))
+#define SEC_NDMA_CRYPTO_OUT_8                                  (0xda832000 + (0xa8 << 2))
+#define   P_NDMA_CRYPTO_OUT_8                                  (volatile uint32_t *)(0xc8832000 + (0xa8 << 2))
+#define     NDMA_CRYPTO_OUT_9                                  (0xc8832000 + (0xa9 << 2))
+#define SEC_NDMA_CRYPTO_OUT_9                                  (0xda832000 + (0xa9 << 2))
+#define   P_NDMA_CRYPTO_OUT_9                                  (volatile uint32_t *)(0xc8832000 + (0xa9 << 2))
+#define     NDMA_CRYPTO_OUT_10                                 (0xc8832000 + (0xaa << 2))
+#define SEC_NDMA_CRYPTO_OUT_10                                 (0xda832000 + (0xaa << 2))
+#define   P_NDMA_CRYPTO_OUT_10                                 (volatile uint32_t *)(0xc8832000 + (0xaa << 2))
+#define     NDMA_CRYPTO_OUT_11                                 (0xc8832000 + (0xab << 2))
+#define SEC_NDMA_CRYPTO_OUT_11                                 (0xda832000 + (0xab << 2))
+#define   P_NDMA_CRYPTO_OUT_11                                 (volatile uint32_t *)(0xc8832000 + (0xab << 2))
+#define     NON_SEC_BLKMV_AES_CW_WR                            (0xc8832000 + (0xb0 << 2))
+#define SEC_NON_SEC_BLKMV_AES_CW_WR                            (0xda832000 + (0xb0 << 2))
+#define   P_NON_SEC_BLKMV_AES_CW_WR                            (volatile uint32_t *)(0xc8832000 + (0xb0 << 2))
+#define     NON_SEC_BLKMV_TDES_CW_WR                           (0xc8832000 + (0xb1 << 2))
+#define SEC_NON_SEC_BLKMV_TDES_CW_WR                           (0xda832000 + (0xb1 << 2))
+#define   P_NON_SEC_BLKMV_TDES_CW_WR                           (volatile uint32_t *)(0xc8832000 + (0xb1 << 2))
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./secure_apb4_ee.h
+//
+//
+// Reading file:  ./ao_rti_reg.h
+//
+// -------------------------------------------------------------------
+// PSEL #0
+// -------------------------------------------------------------------
+// APB4_DECODER_NON_SECURE_BASE     32'hC8100000
+// APB4_DECODER_SECURE_BASE         32'hDA100000
+// Registers not affected by the Watchdog timer
+#define     AO_RTI_STATUS_REG0                                 (0xc8100000 + (0x00 << 2))
+#define SEC_AO_RTI_STATUS_REG0                                 (0xda100000 + (0x00 << 2))
+#define   P_AO_RTI_STATUS_REG0                                 (volatile uint32_t *)(0xc8100000 + (0x00 << 2))
+#define     AO_RTI_STATUS_REG1                                 (0xc8100000 + (0x01 << 2))
+#define SEC_AO_RTI_STATUS_REG1                                 (0xda100000 + (0x01 << 2))
+#define   P_AO_RTI_STATUS_REG1                                 (volatile uint32_t *)(0xc8100000 + (0x01 << 2))
+#define     AO_RTI_STATUS_REG2                                 (0xc8100000 + (0x02 << 2))
+#define SEC_AO_RTI_STATUS_REG2                                 (0xda100000 + (0x02 << 2))
+#define   P_AO_RTI_STATUS_REG2                                 (volatile uint32_t *)(0xc8100000 + (0x02 << 2))
+#define     AO_RTI_PWR_CNTL_REG1                               (0xc8100000 + (0x03 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG1                               (0xda100000 + (0x03 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG1                               (volatile uint32_t *)(0xc8100000 + (0x03 << 2))
+#define     AO_RTI_PWR_CNTL_REG0                               (0xc8100000 + (0x04 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG0                               (0xda100000 + (0x04 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG0                               (volatile uint32_t *)(0xc8100000 + (0x04 << 2))
+#define     AO_RTI_PIN_MUX_REG                                 (0xc8100000 + (0x05 << 2))
+#define SEC_AO_RTI_PIN_MUX_REG                                 (0xda100000 + (0x05 << 2))
+#define   P_AO_RTI_PIN_MUX_REG                                 (volatile uint32_t *)(0xc8100000 + (0x05 << 2))
+#define     AO_RTI_PIN_MUX_REG2                                (0xc8100000 + (0x06 << 2))
+#define SEC_AO_RTI_PIN_MUX_REG2                                (0xda100000 + (0x06 << 2))
+#define   P_AO_RTI_PIN_MUX_REG2                                (volatile uint32_t *)(0xc8100000 + (0x06 << 2))
+#define     AO_RTI_STATUS_REG3                                 (0xc8100000 + (0x07 << 2))
+#define SEC_AO_RTI_STATUS_REG3                                 (0xda100000 + (0x07 << 2))
+#define   P_AO_RTI_STATUS_REG3                                 (volatile uint32_t *)(0xc8100000 + (0x07 << 2))
+//`define AO_REMAP_REG0               8'h07 //TODO: DELETE. NOT USED
+#define     AO_REMAP_REG1                                      (0xc8100000 + (0x08 << 2))
+#define SEC_AO_REMAP_REG1                                      (0xda100000 + (0x08 << 2))
+#define   P_AO_REMAP_REG1                                      (volatile uint32_t *)(0xc8100000 + (0x08 << 2))
+#define     AO_GPIO_O_EN_N                                     (0xc8100000 + (0x09 << 2))
+#define SEC_AO_GPIO_O_EN_N                                     (0xda100000 + (0x09 << 2))
+#define   P_AO_GPIO_O_EN_N                                     (volatile uint32_t *)(0xc8100000 + (0x09 << 2))
+#define     AO_GPIO_I                                          (0xc8100000 + (0x0a << 2))
+#define SEC_AO_GPIO_I                                          (0xda100000 + (0x0a << 2))
+#define   P_AO_GPIO_I                                          (volatile uint32_t *)(0xc8100000 + (0x0a << 2))
+#define     AO_RTI_PULL_UP_REG                                 (0xc8100000 + (0x0b << 2))
+#define SEC_AO_RTI_PULL_UP_REG                                 (0xda100000 + (0x0b << 2))
+#define   P_AO_RTI_PULL_UP_REG                                 (volatile uint32_t *)(0xc8100000 + (0x0b << 2))
+#define     AO_RTI_JTAG_CONFIG_REG                             (0xc8100000 + (0x0c << 2))
+#define SEC_AO_RTI_JTAG_CONFIG_REG                             (0xda100000 + (0x0c << 2))
+#define   P_AO_RTI_JTAG_CONFIG_REG                             (volatile uint32_t *)(0xc8100000 + (0x0c << 2))
+#define     AO_RTI_WD_MARK                                     (0xc8100000 + (0x0d << 2))
+#define SEC_AO_RTI_WD_MARK                                     (0xda100000 + (0x0d << 2))
+#define   P_AO_RTI_WD_MARK                                     (volatile uint32_t *)(0xc8100000 + (0x0d << 2))
+// sando add for AO CPU
+#define     AO_CPU_CNTL                                        (0xc8100000 + (0x0e << 2))
+#define SEC_AO_CPU_CNTL                                        (0xda100000 + (0x0e << 2))
+#define   P_AO_CPU_CNTL                                        (volatile uint32_t *)(0xc8100000 + (0x0e << 2))
+#define     AO_CPU_CNTL2                                       (0xc8100000 + (0x0f << 2))
+#define SEC_AO_CPU_CNTL2                                       (0xda100000 + (0x0f << 2))
+#define   P_AO_CPU_CNTL2                                       (volatile uint32_t *)(0xc8100000 + (0x0f << 2))
+#define     AO_RTI_GEN_CNTL_REG0                               (0xc8100000 + (0x10 << 2))
+#define SEC_AO_RTI_GEN_CNTL_REG0                               (0xda100000 + (0x10 << 2))
+#define   P_AO_RTI_GEN_CNTL_REG0                               (volatile uint32_t *)(0xc8100000 + (0x10 << 2))
+#define     AO_CPU_CNTL_NS                                     (0xc8100000 + (0x11 << 2))
+#define SEC_AO_CPU_CNTL_NS                                     (0xda100000 + (0x11 << 2))
+#define   P_AO_CPU_CNTL_NS                                     (volatile uint32_t *)(0xc8100000 + (0x11 << 2))
+#define     AO_TIMER_REG                                       (0xc8100000 + (0x13 << 2))
+#define SEC_AO_TIMER_REG                                       (0xda100000 + (0x13 << 2))
+#define   P_AO_TIMER_REG                                       (volatile uint32_t *)(0xc8100000 + (0x13 << 2))
+#define     AO_TIMERA_REG                                      (0xc8100000 + (0x14 << 2))
+#define SEC_AO_TIMERA_REG                                      (0xda100000 + (0x14 << 2))
+#define   P_AO_TIMERA_REG                                      (volatile uint32_t *)(0xc8100000 + (0x14 << 2))
+#define     AO_TIMERE_REG                                      (0xc8100000 + (0x15 << 2))
+#define SEC_AO_TIMERE_REG                                      (0xda100000 + (0x15 << 2))
+#define   P_AO_TIMERE_REG                                      (volatile uint32_t *)(0xc8100000 + (0x15 << 2))
+#define     AO_AHB2DDR_CNTL                                    (0xc8100000 + (0x18 << 2))
+#define SEC_AO_AHB2DDR_CNTL                                    (0xda100000 + (0x18 << 2))
+#define   P_AO_AHB2DDR_CNTL                                    (volatile uint32_t *)(0xc8100000 + (0x18 << 2))
+#define     AO_TIMEBASE_CNTL                                   (0xc8100000 + (0x19 << 2))
+#define SEC_AO_TIMEBASE_CNTL                                   (0xda100000 + (0x19 << 2))
+#define   P_AO_TIMEBASE_CNTL                                   (volatile uint32_t *)(0xc8100000 + (0x19 << 2))
+#define     AO_CRT_CLK_CNTL1                                   (0xc8100000 + (0x1a << 2))
+#define SEC_AO_CRT_CLK_CNTL1                                   (0xda100000 + (0x1a << 2))
+#define   P_AO_CRT_CLK_CNTL1                                   (volatile uint32_t *)(0xc8100000 + (0x1a << 2))
+#define     AO_RTI_INTER_OSC_CTL0                              (0xc8100000 + (0x1b << 2))
+#define SEC_AO_RTI_INTER_OSC_CTL0                              (0xda100000 + (0x1b << 2))
+#define   P_AO_RTI_INTER_OSC_CTL0                              (volatile uint32_t *)(0xc8100000 + (0x1b << 2))
+#define     AO_RTI_INTER_OSC_CTL1                              (0xc8100000 + (0x1c << 2))
+#define SEC_AO_RTI_INTER_OSC_CTL1                              (0xda100000 + (0x1c << 2))
+#define   P_AO_RTI_INTER_OSC_CTL1                              (volatile uint32_t *)(0xc8100000 + (0x1c << 2))
+#define     AO_IRQ_MASK_FIQ_SEL                                (0xc8100000 + (0x20 << 2))
+#define SEC_AO_IRQ_MASK_FIQ_SEL                                (0xda100000 + (0x20 << 2))
+#define   P_AO_IRQ_MASK_FIQ_SEL                                (volatile uint32_t *)(0xc8100000 + (0x20 << 2))
+#define     AO_IRQ_GPIO_REG                                    (0xc8100000 + (0x21 << 2))
+#define SEC_AO_IRQ_GPIO_REG                                    (0xda100000 + (0x21 << 2))
+#define   P_AO_IRQ_GPIO_REG                                    (volatile uint32_t *)(0xc8100000 + (0x21 << 2))
+#define     AO_IRQ_STAT                                        (0xc8100000 + (0x22 << 2))
+#define SEC_AO_IRQ_STAT                                        (0xda100000 + (0x22 << 2))
+#define   P_AO_IRQ_STAT                                        (volatile uint32_t *)(0xc8100000 + (0x22 << 2))
+#define     AO_IRQ_STAT_CLR                                    (0xc8100000 + (0x23 << 2))
+#define SEC_AO_IRQ_STAT_CLR                                    (0xda100000 + (0x23 << 2))
+#define   P_AO_IRQ_STAT_CLR                                    (volatile uint32_t *)(0xc8100000 + (0x23 << 2))
+// `define AO_SAR_CLK                  8'h24 moved to the EE domain in Gx
+#define     AO_RTC_ALT_CLK_CNTL0                               (0xc8100000 + (0x25 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL0                               (0xda100000 + (0x25 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL0                               (volatile uint32_t *)(0xc8100000 + (0x25 << 2))
+#define     AO_RTC_ALT_CLK_CNTL1                               (0xc8100000 + (0x26 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL1                               (0xda100000 + (0x26 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL1                               (volatile uint32_t *)(0xc8100000 + (0x26 << 2))
+#define     AO_DEBUG_REG0                                      (0xc8100000 + (0x28 << 2))
+#define SEC_AO_DEBUG_REG0                                      (0xda100000 + (0x28 << 2))
+#define   P_AO_DEBUG_REG0                                      (volatile uint32_t *)(0xc8100000 + (0x28 << 2))
+#define     AO_DEBUG_REG1                                      (0xc8100000 + (0x29 << 2))
+#define SEC_AO_DEBUG_REG1                                      (0xda100000 + (0x29 << 2))
+#define   P_AO_DEBUG_REG1                                      (volatile uint32_t *)(0xc8100000 + (0x29 << 2))
+#define     AO_DEBUG_REG2                                      (0xc8100000 + (0x2a << 2))
+#define SEC_AO_DEBUG_REG2                                      (0xda100000 + (0x2a << 2))
+#define   P_AO_DEBUG_REG2                                      (volatile uint32_t *)(0xc8100000 + (0x2a << 2))
+#define     AO_DEBUG_REG3                                      (0xc8100000 + (0x2b << 2))
+#define SEC_AO_DEBUG_REG3                                      (0xda100000 + (0x2b << 2))
+#define   P_AO_DEBUG_REG3                                      (volatile uint32_t *)(0xc8100000 + (0x2b << 2))
+#define     AO_TIMESTAMP_CNTL                                  (0xc8100000 + (0x2d << 2))
+#define SEC_AO_TIMESTAMP_CNTL                                  (0xda100000 + (0x2d << 2))
+#define   P_AO_TIMESTAMP_CNTL                                  (volatile uint32_t *)(0xc8100000 + (0x2d << 2))
+#define     AO_TIMESTAMP_RD0                                   (0xc8100000 + (0x2e << 2))
+#define SEC_AO_TIMESTAMP_RD0                                   (0xda100000 + (0x2e << 2))
+#define   P_AO_TIMESTAMP_RD0                                   (volatile uint32_t *)(0xc8100000 + (0x2e << 2))
+#define     AO_TIMESTAMP_RD1                                   (0xc8100000 + (0x2f << 2))
+#define SEC_AO_TIMESTAMP_RD1                                   (0xda100000 + (0x2f << 2))
+#define   P_AO_TIMESTAMP_RD1                                   (volatile uint32_t *)(0xc8100000 + (0x2f << 2))
+#define     AO_IR_BLASTER_ADDR0                                (0xc8100000 + (0x30 << 2))
+#define SEC_AO_IR_BLASTER_ADDR0                                (0xda100000 + (0x30 << 2))
+#define   P_AO_IR_BLASTER_ADDR0                                (volatile uint32_t *)(0xc8100000 + (0x30 << 2))
+#define     AO_IR_BLASTER_ADDR1                                (0xc8100000 + (0x31 << 2))
+#define SEC_AO_IR_BLASTER_ADDR1                                (0xda100000 + (0x31 << 2))
+#define   P_AO_IR_BLASTER_ADDR1                                (volatile uint32_t *)(0xc8100000 + (0x31 << 2))
+#define     AO_IR_BLASTER_ADDR2                                (0xc8100000 + (0x32 << 2))
+#define SEC_AO_IR_BLASTER_ADDR2                                (0xda100000 + (0x32 << 2))
+#define   P_AO_IR_BLASTER_ADDR2                                (volatile uint32_t *)(0xc8100000 + (0x32 << 2))
+#define     AO_CPU_STAT1                                       (0xc8100000 + (0x33 << 2))
+#define SEC_AO_CPU_STAT1                                       (0xda100000 + (0x33 << 2))
+#define   P_AO_CPU_STAT1                                       (volatile uint32_t *)(0xc8100000 + (0x33 << 2))
+#define     AO_CPU_STAT2                                       (0xc8100000 + (0x34 << 2))
+#define SEC_AO_CPU_STAT2                                       (0xda100000 + (0x34 << 2))
+#define   P_AO_CPU_STAT2                                       (volatile uint32_t *)(0xc8100000 + (0x34 << 2))
+#define     AO_CPU_TIMESTAMP                                   (0xc8100000 + (0x35 << 2))
+#define SEC_AO_CPU_TIMESTAMP                                   (0xda100000 + (0x35 << 2))
+#define   P_AO_CPU_TIMESTAMP                                   (volatile uint32_t *)(0xc8100000 + (0x35 << 2))
+#define     AO_CPU_TIMESTAMP2                                  (0xc8100000 + (0x36 << 2))
+#define SEC_AO_CPU_TIMESTAMP2                                  (0xda100000 + (0x36 << 2))
+#define   P_AO_CPU_TIMESTAMP2                                  (volatile uint32_t *)(0xc8100000 + (0x36 << 2))
+#define     AO_CPU_CNTL3                                       (0xc8100000 + (0x37 << 2))
+#define SEC_AO_CPU_CNTL3                                       (0xda100000 + (0x37 << 2))
+#define   P_AO_CPU_CNTL3                                       (volatile uint32_t *)(0xc8100000 + (0x37 << 2))
+// general Power control
+#define     AO_RTI_PWR_SYS_CPU_CNTL0                           (0xc8100000 + (0x38 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL0                           (0xda100000 + (0x38 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL0                           (volatile uint32_t *)(0xc8100000 + (0x38 << 2))
+#define     AO_RTI_PWR_SYS_CPU_CNTL1                           (0xc8100000 + (0x39 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL1                           (0xda100000 + (0x39 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL1                           (volatile uint32_t *)(0xc8100000 + (0x39 << 2))
+#define     AO_RTI_GEN_PWR_SLEEP0                              (0xc8100000 + (0x3a << 2))
+#define SEC_AO_RTI_GEN_PWR_SLEEP0                              (0xda100000 + (0x3a << 2))
+#define   P_AO_RTI_GEN_PWR_SLEEP0                              (volatile uint32_t *)(0xc8100000 + (0x3a << 2))
+#define     AO_RTI_GEN_PWR_ISO0                                (0xc8100000 + (0x3b << 2))
+#define SEC_AO_RTI_GEN_PWR_ISO0                                (0xda100000 + (0x3b << 2))
+#define   P_AO_RTI_GEN_PWR_ISO0                                (volatile uint32_t *)(0xc8100000 + (0x3b << 2))
+#define     AO_RTI_GEN_PWR_ACK0                                (0xc8100000 + (0x3c << 2))
+#define SEC_AO_RTI_GEN_PWR_ACK0                                (0xda100000 + (0x3c << 2))
+#define   P_AO_RTI_GEN_PWR_ACK0                                (volatile uint32_t *)(0xc8100000 + (0x3c << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xc8100000 + (0x3d << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xda100000 + (0x3d << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (volatile uint32_t *)(0xc8100000 + (0x3d << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xc8100000 + (0x3e << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xda100000 + (0x3e << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (volatile uint32_t *)(0xc8100000 + (0x3e << 2))
+#define     AO_CPU_CNTL4                                       (0xc8100000 + (0x3f << 2))
+#define SEC_AO_CPU_CNTL4                                       (0xda100000 + (0x3f << 2))
+#define   P_AO_CPU_CNTL4                                       (volatile uint32_t *)(0xc8100000 + (0x3f << 2))
+#define     AO_CEC_GEN_CNTL                                    (0xc8100000 + (0x40 << 2))
+#define SEC_AO_CEC_GEN_CNTL                                    (0xda100000 + (0x40 << 2))
+#define   P_AO_CEC_GEN_CNTL                                    (volatile uint32_t *)(0xc8100000 + (0x40 << 2))
+#define     AO_CEC_RW_REG                                      (0xc8100000 + (0x41 << 2))
+#define SEC_AO_CEC_RW_REG                                      (0xda100000 + (0x41 << 2))
+#define   P_AO_CEC_RW_REG                                      (volatile uint32_t *)(0xc8100000 + (0x41 << 2))
+#define     AO_CEC_INTR_MASKN                                  (0xc8100000 + (0x42 << 2))
+#define SEC_AO_CEC_INTR_MASKN                                  (0xda100000 + (0x42 << 2))
+#define   P_AO_CEC_INTR_MASKN                                  (volatile uint32_t *)(0xc8100000 + (0x42 << 2))
+#define     AO_CEC_INTR_CLR                                    (0xc8100000 + (0x43 << 2))
+#define SEC_AO_CEC_INTR_CLR                                    (0xda100000 + (0x43 << 2))
+#define   P_AO_CEC_INTR_CLR                                    (volatile uint32_t *)(0xc8100000 + (0x43 << 2))
+#define     AO_CEC_INTR_STAT                                   (0xc8100000 + (0x44 << 2))
+#define SEC_AO_CEC_INTR_STAT                                   (0xda100000 + (0x44 << 2))
+#define   P_AO_CEC_INTR_STAT                                   (volatile uint32_t *)(0xc8100000 + (0x44 << 2))
+#define     AO_CPU_CNTL5                                       (0xc8100000 + (0x45 << 2))
+#define SEC_AO_CPU_CNTL5                                       (0xda100000 + (0x45 << 2))
+#define   P_AO_CPU_CNTL5                                       (volatile uint32_t *)(0xc8100000 + (0x45 << 2))
+#define     AO_WATCHDOG_CNTL                                   (0xc8100000 + (0x48 << 2))
+#define SEC_AO_WATCHDOG_CNTL                                   (0xda100000 + (0x48 << 2))
+#define   P_AO_WATCHDOG_CNTL                                   (volatile uint32_t *)(0xc8100000 + (0x48 << 2))
+#define     AO_WATCHDOG_CNTL1                                  (0xc8100000 + (0x49 << 2))
+#define SEC_AO_WATCHDOG_CNTL1                                  (0xda100000 + (0x49 << 2))
+#define   P_AO_WATCHDOG_CNTL1                                  (volatile uint32_t *)(0xc8100000 + (0x49 << 2))
+#define     AO_WATCHDOG_TCNT                                   (0xc8100000 + (0x4a << 2))
+#define SEC_AO_WATCHDOG_TCNT                                   (0xda100000 + (0x4a << 2))
+#define   P_AO_WATCHDOG_TCNT                                   (volatile uint32_t *)(0xc8100000 + (0x4a << 2))
+#define     AO_WATCHDOG_RESET                                  (0xc8100000 + (0x4b << 2))
+#define SEC_AO_WATCHDOG_RESET                                  (0xda100000 + (0x4b << 2))
+#define   P_AO_WATCHDOG_RESET                                  (volatile uint32_t *)(0xc8100000 + (0x4b << 2))
+//
+// Secure APB3 Slot 2 registers
+//
+#define     AO_SEC_REG0                                        (0xc8100000 + (0x50 << 2))
+#define SEC_AO_SEC_REG0                                        (0xda100000 + (0x50 << 2))
+#define   P_AO_SEC_REG0                                        (volatile uint32_t *)(0xc8100000 + (0x50 << 2))
+#define     AO_SEC_REG1                                        (0xc8100000 + (0x51 << 2))
+#define SEC_AO_SEC_REG1                                        (0xda100000 + (0x51 << 2))
+#define   P_AO_SEC_REG1                                        (volatile uint32_t *)(0xc8100000 + (0x51 << 2))
+#define     AO_SEC_REG2                                        (0xc8100000 + (0x52 << 2))
+#define SEC_AO_SEC_REG2                                        (0xda100000 + (0x52 << 2))
+#define   P_AO_SEC_REG2                                        (volatile uint32_t *)(0xc8100000 + (0x52 << 2))
+#define     AO_SEC_TMODE_PWD0                                  (0xc8100000 + (0x58 << 2))
+#define SEC_AO_SEC_TMODE_PWD0                                  (0xda100000 + (0x58 << 2))
+#define   P_AO_SEC_TMODE_PWD0                                  (volatile uint32_t *)(0xc8100000 + (0x58 << 2))
+#define     AO_SEC_TMODE_PWD1                                  (0xc8100000 + (0x59 << 2))
+#define SEC_AO_SEC_TMODE_PWD1                                  (0xda100000 + (0x59 << 2))
+#define   P_AO_SEC_TMODE_PWD1                                  (volatile uint32_t *)(0xc8100000 + (0x59 << 2))
+#define     AO_SEC_TMODE_PWD2                                  (0xc8100000 + (0x5a << 2))
+#define SEC_AO_SEC_TMODE_PWD2                                  (0xda100000 + (0x5a << 2))
+#define   P_AO_SEC_TMODE_PWD2                                  (volatile uint32_t *)(0xc8100000 + (0x5a << 2))
+#define     AO_SEC_TMODE_PWD3                                  (0xc8100000 + (0x5b << 2))
+#define SEC_AO_SEC_TMODE_PWD3                                  (0xda100000 + (0x5b << 2))
+#define   P_AO_SEC_TMODE_PWD3                                  (volatile uint32_t *)(0xc8100000 + (0x5b << 2))
+#define     AO_SEC_SCRATCH                                     (0xc8100000 + (0x5f << 2))
+#define SEC_AO_SEC_SCRATCH                                     (0xda100000 + (0x5f << 2))
+#define   P_AO_SEC_SCRATCH                                     (volatile uint32_t *)(0xc8100000 + (0x5f << 2))
+#define     AO_SEC_JTAG_PWD0                                   (0xc8100000 + (0x60 << 2))
+#define SEC_AO_SEC_JTAG_PWD0                                   (0xda100000 + (0x60 << 2))
+#define   P_AO_SEC_JTAG_PWD0                                   (volatile uint32_t *)(0xc8100000 + (0x60 << 2))
+#define     AO_SEC_JTAG_PWD1                                   (0xc8100000 + (0x61 << 2))
+#define SEC_AO_SEC_JTAG_PWD1                                   (0xda100000 + (0x61 << 2))
+#define   P_AO_SEC_JTAG_PWD1                                   (volatile uint32_t *)(0xc8100000 + (0x61 << 2))
+#define     AO_SEC_JTAG_PWD2                                   (0xc8100000 + (0x62 << 2))
+#define SEC_AO_SEC_JTAG_PWD2                                   (0xda100000 + (0x62 << 2))
+#define   P_AO_SEC_JTAG_PWD2                                   (volatile uint32_t *)(0xc8100000 + (0x62 << 2))
+#define     AO_SEC_JTAG_PWD3                                   (0xc8100000 + (0x63 << 2))
+#define SEC_AO_SEC_JTAG_PWD3                                   (0xda100000 + (0x63 << 2))
+#define   P_AO_SEC_JTAG_PWD3                                   (volatile uint32_t *)(0xc8100000 + (0x63 << 2))
+#define     AO_SEC_JTAG_SEC_CNTL                               (0xc8100000 + (0x64 << 2))
+#define SEC_AO_SEC_JTAG_SEC_CNTL                               (0xda100000 + (0x64 << 2))
+#define   P_AO_SEC_JTAG_SEC_CNTL                               (volatile uint32_t *)(0xc8100000 + (0x64 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR0                              (0xc8100000 + (0x65 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR0                              (0xda100000 + (0x65 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR0                              (volatile uint32_t *)(0xc8100000 + (0x65 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR1                              (0xc8100000 + (0x66 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR1                              (0xda100000 + (0x66 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR1                              (volatile uint32_t *)(0xc8100000 + (0x66 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR2                              (0xc8100000 + (0x67 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR2                              (0xda100000 + (0x67 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR2                              (volatile uint32_t *)(0xc8100000 + (0x67 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR3                              (0xc8100000 + (0x68 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR3                              (0xda100000 + (0x68 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR3                              (volatile uint32_t *)(0xc8100000 + (0x68 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xc8100000 + (0x70 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xda100000 + (0x70 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (volatile uint32_t *)(0xc8100000 + (0x70 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xc8100000 + (0x71 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xda100000 + (0x71 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (volatile uint32_t *)(0xc8100000 + (0x71 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xc8100000 + (0x72 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xda100000 + (0x72 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (volatile uint32_t *)(0xc8100000 + (0x72 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xc8100000 + (0x73 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xda100000 + (0x73 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (volatile uint32_t *)(0xc8100000 + (0x73 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xc8100000 + (0x74 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xda100000 + (0x74 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (volatile uint32_t *)(0xc8100000 + (0x74 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xc8100000 + (0x75 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xda100000 + (0x75 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (volatile uint32_t *)(0xc8100000 + (0x75 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xc8100000 + (0x76 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xda100000 + (0x76 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (volatile uint32_t *)(0xc8100000 + (0x76 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xc8100000 + (0x77 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xda100000 + (0x77 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (volatile uint32_t *)(0xc8100000 + (0x77 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xc8100000 + (0x78 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xda100000 + (0x78 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (volatile uint32_t *)(0xc8100000 + (0x78 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xc8100000 + (0x79 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xda100000 + (0x79 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (volatile uint32_t *)(0xc8100000 + (0x79 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xc8100000 + (0x7a << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xda100000 + (0x7a << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (volatile uint32_t *)(0xc8100000 + (0x7a << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xc8100000 + (0x7b << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xda100000 + (0x7b << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (volatile uint32_t *)(0xc8100000 + (0x7b << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG0_0                          (0xc8100000 + (0x7c << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG0_0                          (0xda100000 + (0x7c << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG0_0                          (volatile uint32_t *)(0xc8100000 + (0x7c << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG0_1                          (0xc8100000 + (0x7d << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG0_1                          (0xda100000 + (0x7d << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG0_1                          (volatile uint32_t *)(0xc8100000 + (0x7d << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG1_0                          (0xc8100000 + (0x7e << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG1_0                          (0xda100000 + (0x7e << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG1_0                          (volatile uint32_t *)(0xc8100000 + (0x7e << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG1_1                          (0xc8100000 + (0x7f << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG1_1                          (0xda100000 + (0x7f << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG1_1                          (volatile uint32_t *)(0xc8100000 + (0x7f << 2))
+#define     AO_SEC_SD_CFG0                                     (0xc8100000 + (0x80 << 2))
+#define SEC_AO_SEC_SD_CFG0                                     (0xda100000 + (0x80 << 2))
+#define   P_AO_SEC_SD_CFG0                                     (volatile uint32_t *)(0xc8100000 + (0x80 << 2))
+#define     AO_SEC_SD_CFG1                                     (0xc8100000 + (0x81 << 2))
+#define SEC_AO_SEC_SD_CFG1                                     (0xda100000 + (0x81 << 2))
+#define   P_AO_SEC_SD_CFG1                                     (volatile uint32_t *)(0xc8100000 + (0x81 << 2))
+#define     AO_SEC_SD_CFG2                                     (0xc8100000 + (0x82 << 2))
+#define SEC_AO_SEC_SD_CFG2                                     (0xda100000 + (0x82 << 2))
+#define   P_AO_SEC_SD_CFG2                                     (volatile uint32_t *)(0xc8100000 + (0x82 << 2))
+#define     AO_SEC_SD_CFG3                                     (0xc8100000 + (0x83 << 2))
+#define SEC_AO_SEC_SD_CFG3                                     (0xda100000 + (0x83 << 2))
+#define   P_AO_SEC_SD_CFG3                                     (volatile uint32_t *)(0xc8100000 + (0x83 << 2))
+#define     AO_SEC_SD_CFG4                                     (0xc8100000 + (0x84 << 2))
+#define SEC_AO_SEC_SD_CFG4                                     (0xda100000 + (0x84 << 2))
+#define   P_AO_SEC_SD_CFG4                                     (volatile uint32_t *)(0xc8100000 + (0x84 << 2))
+#define     AO_SEC_SD_CFG5                                     (0xc8100000 + (0x85 << 2))
+#define SEC_AO_SEC_SD_CFG5                                     (0xda100000 + (0x85 << 2))
+#define   P_AO_SEC_SD_CFG5                                     (volatile uint32_t *)(0xc8100000 + (0x85 << 2))
+#define     AO_SEC_SD_CFG6                                     (0xc8100000 + (0x86 << 2))
+#define SEC_AO_SEC_SD_CFG6                                     (0xda100000 + (0x86 << 2))
+#define   P_AO_SEC_SD_CFG6                                     (volatile uint32_t *)(0xc8100000 + (0x86 << 2))
+#define     AO_SEC_SD_CFG7                                     (0xc8100000 + (0x87 << 2))
+#define SEC_AO_SEC_SD_CFG7                                     (0xda100000 + (0x87 << 2))
+#define   P_AO_SEC_SD_CFG7                                     (volatile uint32_t *)(0xc8100000 + (0x87 << 2))
+#define     AO_SEC_SD_CFG8                                     (0xc8100000 + (0x88 << 2))
+#define SEC_AO_SEC_SD_CFG8                                     (0xda100000 + (0x88 << 2))
+#define   P_AO_SEC_SD_CFG8                                     (volatile uint32_t *)(0xc8100000 + (0x88 << 2))
+#define     AO_SEC_SD_CFG9                                     (0xc8100000 + (0x89 << 2))
+#define SEC_AO_SEC_SD_CFG9                                     (0xda100000 + (0x89 << 2))
+#define   P_AO_SEC_SD_CFG9                                     (volatile uint32_t *)(0xc8100000 + (0x89 << 2))
+#define     AO_SEC_SD_CFG10                                    (0xc8100000 + (0x8a << 2))
+#define SEC_AO_SEC_SD_CFG10                                    (0xda100000 + (0x8a << 2))
+#define   P_AO_SEC_SD_CFG10                                    (volatile uint32_t *)(0xc8100000 + (0x8a << 2))
+#define     AO_SEC_SD_CFG11                                    (0xc8100000 + (0x8b << 2))
+#define SEC_AO_SEC_SD_CFG11                                    (0xda100000 + (0x8b << 2))
+#define   P_AO_SEC_SD_CFG11                                    (volatile uint32_t *)(0xc8100000 + (0x8b << 2))
+#define     AO_SEC_SD_CFG12                                    (0xc8100000 + (0x8c << 2))
+#define SEC_AO_SEC_SD_CFG12                                    (0xda100000 + (0x8c << 2))
+#define   P_AO_SEC_SD_CFG12                                    (volatile uint32_t *)(0xc8100000 + (0x8c << 2))
+#define     AO_SEC_SD_CFG13                                    (0xc8100000 + (0x8d << 2))
+#define SEC_AO_SEC_SD_CFG13                                    (0xda100000 + (0x8d << 2))
+#define   P_AO_SEC_SD_CFG13                                    (volatile uint32_t *)(0xc8100000 + (0x8d << 2))
+#define     AO_SEC_SD_CFG14                                    (0xc8100000 + (0x8e << 2))
+#define SEC_AO_SEC_SD_CFG14                                    (0xda100000 + (0x8e << 2))
+#define   P_AO_SEC_SD_CFG14                                    (volatile uint32_t *)(0xc8100000 + (0x8e << 2))
+#define     AO_SEC_SD_CFG15                                    (0xc8100000 + (0x8f << 2))
+#define SEC_AO_SEC_SD_CFG15                                    (0xda100000 + (0x8f << 2))
+#define   P_AO_SEC_SD_CFG15                                    (volatile uint32_t *)(0xc8100000 + (0x8f << 2))
+#define     AO_SEC_GP_CFG0                                     (0xc8100000 + (0x90 << 2))
+#define SEC_AO_SEC_GP_CFG0                                     (0xda100000 + (0x90 << 2))
+#define   P_AO_SEC_GP_CFG0                                     (volatile uint32_t *)(0xc8100000 + (0x90 << 2))
+#define     AO_SEC_GP_CFG1                                     (0xc8100000 + (0x91 << 2))
+#define SEC_AO_SEC_GP_CFG1                                     (0xda100000 + (0x91 << 2))
+#define   P_AO_SEC_GP_CFG1                                     (volatile uint32_t *)(0xc8100000 + (0x91 << 2))
+#define     AO_SEC_GP_CFG2                                     (0xc8100000 + (0x92 << 2))
+#define SEC_AO_SEC_GP_CFG2                                     (0xda100000 + (0x92 << 2))
+#define   P_AO_SEC_GP_CFG2                                     (volatile uint32_t *)(0xc8100000 + (0x92 << 2))
+#define     AO_SEC_GP_CFG3                                     (0xc8100000 + (0x93 << 2))
+#define SEC_AO_SEC_GP_CFG3                                     (0xda100000 + (0x93 << 2))
+#define   P_AO_SEC_GP_CFG3                                     (volatile uint32_t *)(0xc8100000 + (0x93 << 2))
+#define     AO_SEC_GP_CFG4                                     (0xc8100000 + (0x94 << 2))
+#define SEC_AO_SEC_GP_CFG4                                     (0xda100000 + (0x94 << 2))
+#define   P_AO_SEC_GP_CFG4                                     (volatile uint32_t *)(0xc8100000 + (0x94 << 2))
+#define     AO_SEC_GP_CFG5                                     (0xc8100000 + (0x95 << 2))
+#define SEC_AO_SEC_GP_CFG5                                     (0xda100000 + (0x95 << 2))
+#define   P_AO_SEC_GP_CFG5                                     (volatile uint32_t *)(0xc8100000 + (0x95 << 2))
+#define     AO_SEC_GP_CFG6                                     (0xc8100000 + (0x96 << 2))
+#define SEC_AO_SEC_GP_CFG6                                     (0xda100000 + (0x96 << 2))
+#define   P_AO_SEC_GP_CFG6                                     (volatile uint32_t *)(0xc8100000 + (0x96 << 2))
+#define     AO_SEC_GP_CFG7                                     (0xc8100000 + (0x97 << 2))
+#define SEC_AO_SEC_GP_CFG7                                     (0xda100000 + (0x97 << 2))
+#define   P_AO_SEC_GP_CFG7                                     (volatile uint32_t *)(0xc8100000 + (0x97 << 2))
+//`define AO_RTC_ADDR0                    8'h70 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR1                    8'h71 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR2                    8'h72 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR3                    8'h73 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR4                    8'h74 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+// -------------------------------------------------------------------
+// PSEL #1
+// -------------------------------------------------------------------
+// APB4_DECODER_NON_SECURE_BASE     32'hC8100400
+// APB4_DECODER_SECURE_BASE         32'hDA100400
+// ----------------------------
+// IR Remote (8)
+// ----------------------------
+#define     AO_IR_DEC_LDR_ACTIVE                               (0xc8100400 + (0x20 << 2))
+#define SEC_AO_IR_DEC_LDR_ACTIVE                               (0xda100400 + (0x20 << 2))
+#define   P_AO_IR_DEC_LDR_ACTIVE                               (volatile uint32_t *)(0xc8100400 + (0x20 << 2))
+#define     AO_IR_DEC_LDR_IDLE                                 (0xc8100400 + (0x21 << 2))
+#define SEC_AO_IR_DEC_LDR_IDLE                                 (0xda100400 + (0x21 << 2))
+#define   P_AO_IR_DEC_LDR_IDLE                                 (volatile uint32_t *)(0xc8100400 + (0x21 << 2))
+#define     AO_IR_DEC_LDR_REPEAT                               (0xc8100400 + (0x22 << 2))
+#define SEC_AO_IR_DEC_LDR_REPEAT                               (0xda100400 + (0x22 << 2))
+#define   P_AO_IR_DEC_LDR_REPEAT                               (volatile uint32_t *)(0xc8100400 + (0x22 << 2))
+#define     AO_IR_DEC_BIT_0                                    (0xc8100400 + (0x23 << 2))
+#define SEC_AO_IR_DEC_BIT_0                                    (0xda100400 + (0x23 << 2))
+#define   P_AO_IR_DEC_BIT_0                                    (volatile uint32_t *)(0xc8100400 + (0x23 << 2))
+#define     AO_IR_DEC_REG0                                     (0xc8100400 + (0x24 << 2))
+#define SEC_AO_IR_DEC_REG0                                     (0xda100400 + (0x24 << 2))
+#define   P_AO_IR_DEC_REG0                                     (volatile uint32_t *)(0xc8100400 + (0x24 << 2))
+#define     AO_IR_DEC_FRAME                                    (0xc8100400 + (0x25 << 2))
+#define SEC_AO_IR_DEC_FRAME                                    (0xda100400 + (0x25 << 2))
+#define   P_AO_IR_DEC_FRAME                                    (volatile uint32_t *)(0xc8100400 + (0x25 << 2))
+#define     AO_IR_DEC_STATUS                                   (0xc8100400 + (0x26 << 2))
+#define SEC_AO_IR_DEC_STATUS                                   (0xda100400 + (0x26 << 2))
+#define   P_AO_IR_DEC_STATUS                                   (volatile uint32_t *)(0xc8100400 + (0x26 << 2))
+#define     AO_IR_DEC_REG1                                     (0xc8100400 + (0x27 << 2))
+#define SEC_AO_IR_DEC_REG1                                     (0xda100400 + (0x27 << 2))
+#define   P_AO_IR_DEC_REG1                                     (volatile uint32_t *)(0xc8100400 + (0x27 << 2))
+// ----------------------------
+// UART
+// ----------------------------
+#define     AO_UART_WFIFO                                      (0xc8100400 + (0x30 << 2))
+#define SEC_AO_UART_WFIFO                                      (0xda100400 + (0x30 << 2))
+#define   P_AO_UART_WFIFO                                      (volatile uint32_t *)(0xc8100400 + (0x30 << 2))
+#define     AO_UART_RFIFO                                      (0xc8100400 + (0x31 << 2))
+#define SEC_AO_UART_RFIFO                                      (0xda100400 + (0x31 << 2))
+#define   P_AO_UART_RFIFO                                      (volatile uint32_t *)(0xc8100400 + (0x31 << 2))
+#define     AO_UART_CONTROL                                    (0xc8100400 + (0x32 << 2))
+#define SEC_AO_UART_CONTROL                                    (0xda100400 + (0x32 << 2))
+#define   P_AO_UART_CONTROL                                    (volatile uint32_t *)(0xc8100400 + (0x32 << 2))
+#define     AO_UART_STATUS                                     (0xc8100400 + (0x33 << 2))
+#define SEC_AO_UART_STATUS                                     (0xda100400 + (0x33 << 2))
+#define   P_AO_UART_STATUS                                     (volatile uint32_t *)(0xc8100400 + (0x33 << 2))
+#define     AO_UART_MISC                                       (0xc8100400 + (0x34 << 2))
+#define SEC_AO_UART_MISC                                       (0xda100400 + (0x34 << 2))
+#define   P_AO_UART_MISC                                       (volatile uint32_t *)(0xc8100400 + (0x34 << 2))
+#define     AO_UART_REG5                                       (0xc8100400 + (0x35 << 2))
+#define SEC_AO_UART_REG5                                       (0xda100400 + (0x35 << 2))
+#define   P_AO_UART_REG5                                       (volatile uint32_t *)(0xc8100400 + (0x35 << 2))
+// ----------------------------
+// UART2
+// ----------------------------
+#define     AO_UART2_WFIFO                                     (0xc8100400 + (0x38 << 2))
+#define SEC_AO_UART2_WFIFO                                     (0xda100400 + (0x38 << 2))
+#define   P_AO_UART2_WFIFO                                     (volatile uint32_t *)(0xc8100400 + (0x38 << 2))
+#define     AO_UART2_RFIFO                                     (0xc8100400 + (0x39 << 2))
+#define SEC_AO_UART2_RFIFO                                     (0xda100400 + (0x39 << 2))
+#define   P_AO_UART2_RFIFO                                     (volatile uint32_t *)(0xc8100400 + (0x39 << 2))
+#define     AO_UART2_CONTROL                                   (0xc8100400 + (0x3a << 2))
+#define SEC_AO_UART2_CONTROL                                   (0xda100400 + (0x3a << 2))
+#define   P_AO_UART2_CONTROL                                   (volatile uint32_t *)(0xc8100400 + (0x3a << 2))
+#define     AO_UART2_STATUS                                    (0xc8100400 + (0x3b << 2))
+#define SEC_AO_UART2_STATUS                                    (0xda100400 + (0x3b << 2))
+#define   P_AO_UART2_STATUS                                    (volatile uint32_t *)(0xc8100400 + (0x3b << 2))
+#define     AO_UART2_MISC                                      (0xc8100400 + (0x3c << 2))
+#define SEC_AO_UART2_MISC                                      (0xda100400 + (0x3c << 2))
+#define   P_AO_UART2_MISC                                      (volatile uint32_t *)(0xc8100400 + (0x3c << 2))
+#define     AO_UART2_REG5                                      (0xc8100400 + (0x3d << 2))
+#define SEC_AO_UART2_REG5                                      (0xda100400 + (0x3d << 2))
+#define   P_AO_UART2_REG5                                      (volatile uint32_t *)(0xc8100400 + (0x3d << 2))
+// ----------------------------
+// I2C Master (8)
+// ----------------------------
+#define     AO_I2C_M_0_CONTROL_REG                             (0xc8100400 + (0x40 << 2))
+#define SEC_AO_I2C_M_0_CONTROL_REG                             (0xda100400 + (0x40 << 2))
+#define   P_AO_I2C_M_0_CONTROL_REG                             (volatile uint32_t *)(0xc8100400 + (0x40 << 2))
+#define     AO_I2C_M_0_SLAVE_ADDR                              (0xc8100400 + (0x41 << 2))
+#define SEC_AO_I2C_M_0_SLAVE_ADDR                              (0xda100400 + (0x41 << 2))
+#define   P_AO_I2C_M_0_SLAVE_ADDR                              (volatile uint32_t *)(0xc8100400 + (0x41 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST0                             (0xc8100400 + (0x42 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST0                             (0xda100400 + (0x42 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST0                             (volatile uint32_t *)(0xc8100400 + (0x42 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST1                             (0xc8100400 + (0x43 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST1                             (0xda100400 + (0x43 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST1                             (volatile uint32_t *)(0xc8100400 + (0x43 << 2))
+#define     AO_I2C_M_0_WDATA_REG0                              (0xc8100400 + (0x44 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG0                              (0xda100400 + (0x44 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG0                              (volatile uint32_t *)(0xc8100400 + (0x44 << 2))
+#define     AO_I2C_M_0_WDATA_REG1                              (0xc8100400 + (0x45 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG1                              (0xda100400 + (0x45 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG1                              (volatile uint32_t *)(0xc8100400 + (0x45 << 2))
+#define     AO_I2C_M_0_RDATA_REG0                              (0xc8100400 + (0x46 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG0                              (0xda100400 + (0x46 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG0                              (volatile uint32_t *)(0xc8100400 + (0x46 << 2))
+#define     AO_I2C_M_0_RDATA_REG1                              (0xc8100400 + (0x47 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG1                              (0xda100400 + (0x47 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG1                              (volatile uint32_t *)(0xc8100400 + (0x47 << 2))
+// ----------------------------
+// I2C Slave (3)
+// ----------------------------
+#define     AO_I2C_S_CONTROL_REG                               (0xc8100400 + (0x50 << 2))
+#define SEC_AO_I2C_S_CONTROL_REG                               (0xda100400 + (0x50 << 2))
+#define   P_AO_I2C_S_CONTROL_REG                               (volatile uint32_t *)(0xc8100400 + (0x50 << 2))
+#define     AO_I2C_S_SEND_REG                                  (0xc8100400 + (0x51 << 2))
+#define SEC_AO_I2C_S_SEND_REG                                  (0xda100400 + (0x51 << 2))
+#define   P_AO_I2C_S_SEND_REG                                  (volatile uint32_t *)(0xc8100400 + (0x51 << 2))
+#define     AO_I2C_S_RECV_REG                                  (0xc8100400 + (0x52 << 2))
+#define SEC_AO_I2C_S_RECV_REG                                  (0xda100400 + (0x52 << 2))
+#define   P_AO_I2C_S_RECV_REG                                  (volatile uint32_t *)(0xc8100400 + (0x52 << 2))
+#define     AO_I2C_S_CNTL1_REG                                 (0xc8100400 + (0x53 << 2))
+#define SEC_AO_I2C_S_CNTL1_REG                                 (0xda100400 + (0x53 << 2))
+#define   P_AO_I2C_S_CNTL1_REG                                 (volatile uint32_t *)(0xc8100400 + (0x53 << 2))
+// ----------------------------
+// PWM A-B
+// ----------------------------
+#define     AO_PWM_PWM_A                                       (0xc8100400 + (0x54 << 2))
+#define SEC_AO_PWM_PWM_A                                       (0xda100400 + (0x54 << 2))
+#define   P_AO_PWM_PWM_A                                       (volatile uint32_t *)(0xc8100400 + (0x54 << 2))
+#define     AO_PWM_PWM_B                                       (0xc8100400 + (0x55 << 2))
+#define SEC_AO_PWM_PWM_B                                       (0xda100400 + (0x55 << 2))
+#define   P_AO_PWM_PWM_B                                       (volatile uint32_t *)(0xc8100400 + (0x55 << 2))
+#define     AO_PWM_MISC_REG_AB                                 (0xc8100400 + (0x56 << 2))
+#define SEC_AO_PWM_MISC_REG_AB                                 (0xda100400 + (0x56 << 2))
+#define   P_AO_PWM_MISC_REG_AB                                 (volatile uint32_t *)(0xc8100400 + (0x56 << 2))
+#define     AO_PWM_DELTA_SIGMA_AB                              (0xc8100400 + (0x57 << 2))
+#define SEC_AO_PWM_DELTA_SIGMA_AB                              (0xda100400 + (0x57 << 2))
+#define   P_AO_PWM_DELTA_SIGMA_AB                              (volatile uint32_t *)(0xc8100400 + (0x57 << 2))
+// ----------------------------
+// Multiformat IR Remote
+// ----------------------------
+#define     AO_MF_IR_DEC_LDR_ACTIVE                            (0xc8100400 + (0x60 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_ACTIVE                            (0xda100400 + (0x60 << 2))
+#define   P_AO_MF_IR_DEC_LDR_ACTIVE                            (volatile uint32_t *)(0xc8100400 + (0x60 << 2))
+#define     AO_MF_IR_DEC_LDR_IDLE                              (0xc8100400 + (0x61 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_IDLE                              (0xda100400 + (0x61 << 2))
+#define   P_AO_MF_IR_DEC_LDR_IDLE                              (volatile uint32_t *)(0xc8100400 + (0x61 << 2))
+#define     AO_MF_IR_DEC_LDR_REPEAT                            (0xc8100400 + (0x62 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_REPEAT                            (0xda100400 + (0x62 << 2))
+#define   P_AO_MF_IR_DEC_LDR_REPEAT                            (volatile uint32_t *)(0xc8100400 + (0x62 << 2))
+#define     AO_MF_IR_DEC_BIT_0                                 (0xc8100400 + (0x63 << 2))
+#define SEC_AO_MF_IR_DEC_BIT_0                                 (0xda100400 + (0x63 << 2))
+#define   P_AO_MF_IR_DEC_BIT_0                                 (volatile uint32_t *)(0xc8100400 + (0x63 << 2))
+#define     AO_MF_IR_DEC_REG0                                  (0xc8100400 + (0x64 << 2))
+#define SEC_AO_MF_IR_DEC_REG0                                  (0xda100400 + (0x64 << 2))
+#define   P_AO_MF_IR_DEC_REG0                                  (volatile uint32_t *)(0xc8100400 + (0x64 << 2))
+#define     AO_MF_IR_DEC_FRAME                                 (0xc8100400 + (0x65 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME                                 (0xda100400 + (0x65 << 2))
+#define   P_AO_MF_IR_DEC_FRAME                                 (volatile uint32_t *)(0xc8100400 + (0x65 << 2))
+#define     AO_MF_IR_DEC_STATUS                                (0xc8100400 + (0x66 << 2))
+#define SEC_AO_MF_IR_DEC_STATUS                                (0xda100400 + (0x66 << 2))
+#define   P_AO_MF_IR_DEC_STATUS                                (volatile uint32_t *)(0xc8100400 + (0x66 << 2))
+#define     AO_MF_IR_DEC_REG1                                  (0xc8100400 + (0x67 << 2))
+#define SEC_AO_MF_IR_DEC_REG1                                  (0xda100400 + (0x67 << 2))
+#define   P_AO_MF_IR_DEC_REG1                                  (volatile uint32_t *)(0xc8100400 + (0x67 << 2))
+#define     AO_MF_IR_DEC_REG2                                  (0xc8100400 + (0x68 << 2))
+#define SEC_AO_MF_IR_DEC_REG2                                  (0xda100400 + (0x68 << 2))
+#define   P_AO_MF_IR_DEC_REG2                                  (volatile uint32_t *)(0xc8100400 + (0x68 << 2))
+#define     AO_MF_IR_DEC_DURATN2                               (0xc8100400 + (0x69 << 2))
+#define SEC_AO_MF_IR_DEC_DURATN2                               (0xda100400 + (0x69 << 2))
+#define   P_AO_MF_IR_DEC_DURATN2                               (volatile uint32_t *)(0xc8100400 + (0x69 << 2))
+#define     AO_MF_IR_DEC_DURATN3                               (0xc8100400 + (0x6a << 2))
+#define SEC_AO_MF_IR_DEC_DURATN3                               (0xda100400 + (0x6a << 2))
+#define   P_AO_MF_IR_DEC_DURATN3                               (volatile uint32_t *)(0xc8100400 + (0x6a << 2))
+#define     AO_MF_IR_DEC_FRAME1                                (0xc8100400 + (0x6b << 2))
+#define SEC_AO_MF_IR_DEC_FRAME1                                (0xda100400 + (0x6b << 2))
+#define   P_AO_MF_IR_DEC_FRAME1                                (volatile uint32_t *)(0xc8100400 + (0x6b << 2))
+#define     AO_MF_IR_DEC_STATUS1                               (0xc8100400 + (0x6c << 2))
+#define SEC_AO_MF_IR_DEC_STATUS1                               (0xda100400 + (0x6c << 2))
+#define   P_AO_MF_IR_DEC_STATUS1                               (volatile uint32_t *)(0xc8100400 + (0x6c << 2))
+#define     AO_MF_IR_DEC_STATUS2                               (0xc8100400 + (0x6d << 2))
+#define SEC_AO_MF_IR_DEC_STATUS2                               (0xda100400 + (0x6d << 2))
+#define   P_AO_MF_IR_DEC_STATUS2                               (volatile uint32_t *)(0xc8100400 + (0x6d << 2))
+#define     AO_MF_IR_DEC_REG3                                  (0xc8100400 + (0x6e << 2))
+#define SEC_AO_MF_IR_DEC_REG3                                  (0xda100400 + (0x6e << 2))
+#define   P_AO_MF_IR_DEC_REG3                                  (volatile uint32_t *)(0xc8100400 + (0x6e << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV0                            (0xc8100400 + (0x6f << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV0                            (0xda100400 + (0x6f << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV0                            (volatile uint32_t *)(0xc8100400 + (0x6f << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV1                            (0xc8100400 + (0x70 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV1                            (0xda100400 + (0x70 << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV1                            (volatile uint32_t *)(0xc8100400 + (0x70 << 2))
+
+#endif				//__SECURE_APB_H_
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/suspend.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/suspend.c
new file mode 100644
index 0000000..68119cc
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/suspend.c
@@ -0,0 +1,113 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/suspend.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "config.h"
+#include "registers.h"
+#include "task_apis.h"
+#include "suspend.h"
+unsigned int time;
+#include <scp_remote.c>
+
+#include <pwr_ctrl.c>
+#include <hdmi_cec_arc.c>
+
+static struct pwr_op pwr_op_d;
+static struct pwr_op *p_pwr_op;
+
+static void gxbb_com_gate_off(void)
+{
+	/* gate off fix_clk_div2*/
+	aml_update_bits(HHI_MPLL_CNTL6, 1<<27, 0);
+	/* gate off fix_clk_div4*/
+	aml_update_bits(HHI_MPLL_CNTL6, 1<<29, 0);
+	/* gate off fix_clk_div5*/
+	aml_update_bits(HHI_MPLL_CNTL6, 1<<30, 0);
+	/* gate off fix_clk_div7*/
+	aml_update_bits(HHI_MPLL_CNTL6, 1<<31, 0);
+	/* switch vpu to fclk_div4 */
+	aml_update_bits(HHI_VPU_CLK_CNTL, 7 << 9, 0);
+	/* gate off mpll 0 ~ 3 */
+	aml_update_bits(HHI_MPLL_CNTL7, 1 << 15, 0);
+	aml_update_bits(HHI_MPLL_CNTL8, 1 << 15, 0);
+	aml_update_bits(HHI_MPLL_CNTL9, 1 << 15, 0);
+	aml_update_bits(HHI_MPLL3_CNTL0, 1 << 10, 0);
+}
+static void gxbb_com_gate_on(void)
+{
+	/* gate on mpll 0 ~ 3 */
+	aml_update_bits(HHI_MPLL_CNTL7, 1 << 15, 1 << 15);
+	aml_update_bits(HHI_MPLL_CNTL8, 1 << 15, 1 << 15);
+	aml_update_bits(HHI_MPLL_CNTL9, 1 << 15, 1 << 15);
+	aml_update_bits(HHI_MPLL3_CNTL0, 1 << 10, 1 << 10);
+	/* switch vpu to fclk_div3 */
+	aml_update_bits(HHI_VPU_CLK_CNTL, 7 << 9, 1 << 9);
+	/* gate on fix_clk_div2*/
+	aml_update_bits(HHI_MPLL_CNTL6, 1<<27, 1<<27);
+	/* gate on fix_clk_div4*/
+	aml_update_bits(HHI_MPLL_CNTL6, 1<<29, 1<<29);
+	/* gate on fix_clk_div5*/
+	aml_update_bits(HHI_MPLL_CNTL6, 1<<30, 1<<30);
+	/* gate on fix_clk_div7*/
+	aml_update_bits(HHI_MPLL_CNTL6, 1<<31, 1<<31);
+}
+
+void suspend_pwr_ops_init(void)
+{
+	p_pwr_op = &pwr_op_d;
+	pwr_op_init(p_pwr_op);
+}
+
+void suspend_get_wakeup_source(void *response, unsigned int suspend_from)
+{
+	if (!p_pwr_op->get_wakeup_source)
+		return;
+	p_pwr_op->get_wakeup_source(response, suspend_from);
+}
+
+/*
+ *suspend_from defines who call this function.
+ * 1: suspend
+ * 0: power off
+*/
+void enter_suspend(unsigned int suspend_from)
+{
+	int exit_reason = UDEFINED_WAKEUP;
+#ifdef CONFIG_CEC_WAKEUP
+	hdmi_cec_func_config = readl(P_AO_DEBUG_REG0);
+	uart_puts("CEC cfg:0x");
+	uart_put_hex(hdmi_cec_func_config, 16);
+	uart_puts("\n");
+#endif
+	p_pwr_op->power_off_at_clk81();
+	p_pwr_op->power_off_at_24M();
+
+	gxbb_com_gate_off();
+	p_pwr_op->power_off_at_32k();
+	exit_reason = p_pwr_op->detect_key(suspend_from);
+	p_pwr_op->power_on_at_32k();
+	gxbb_com_gate_on();
+	uart_puts("exit_reason:0x");
+	uart_put_hex(exit_reason, 8);
+	uart_puts("\n");
+	set_wakeup_method(exit_reason);
+	p_pwr_op->power_on_at_24M();
+	p_pwr_op->power_on_at_clk81();
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/suspend.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/suspend.h
new file mode 100644
index 0000000..ac322f3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/suspend.h
@@ -0,0 +1,122 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/suspend.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __SCP_SUSPEND_H_
+#define __SCP_SUSPEND_H_
+/* wake up reason*/
+#define	UDEFINED_WAKEUP	0
+#define	CHARGING_WAKEUP	1
+#define	REMOTE_WAKEUP		2
+#define	RTC_WAKEUP			3
+#define	BT_WAKEUP			4
+#define	WIFI_WAKEUP			5
+#define	POWER_KEY_WAKEUP	6
+#define	AUTO_WAKEUP			7
+#define CEC_WAKEUP		8
+#define	REMOTE_CUS_WAKEUP		9
+
+/* wake up source*/
+#define UDEFINED_WAKEUP_SRC	(1<<0)
+#define CHARGING_WAKEUP_SRC (1<<1)
+#define REMOTE_WAKEUP_SRC (1<<2)
+#define RTC_WAKEUP_SRC	(1<<3)
+#define BT_WAKEUP_SRC	(1<<4)
+#define WIFI_WAKEUP_SRC	(1<<5)
+#define POWER_KEY_WAKEUP_SRC	(1<<6)
+#define AUTO_WAKEUP_SRC	(1<<7)
+#define CEC_WAKEUP_SRC	(1<<8)
+
+struct pwr_op {
+	void (*power_off_at_clk81)(void);
+	void (*power_on_at_clk81)(void);
+
+	void (*power_off_at_24M)(void);
+	void (*power_on_at_24M)(void);
+
+	void (*power_off_at_32k)(void);
+	void (*power_on_at_32k)(void);
+
+	void (*shut_down)(void);
+
+	unsigned int (*detect_key)(unsigned int);
+	void (*get_wakeup_source)(void *, unsigned int);
+};
+static void inline aml_update_bits(unsigned int  reg, unsigned int mask, unsigned int val)
+{
+	unsigned int tmp, orig;
+	orig = readl(reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	writel(tmp, reg);
+}
+
+#define IRQ_TIMERA_NUM      1
+#define IRQ_GPIO0_NUM       8
+#define IRQ_GPIO1_NUM       9
+#define IRQ_AO_IR_DEC_NUM   42
+#define IRQ_AO_CEC_NUM      45
+#define IRQ_AO_GPIO0_NUM    46
+
+/* GPIO trigger type*/
+#define GPIO_IRQ_LOW_LEVEL		0
+#define GPIO_IRQ_HIGH_LEVEL		1
+#define GPIO_IRQ_FALLING_EDGE	2
+#define GPIO_IRQ_RISING_EDGE		3
+
+enum {
+	IRQ_TIMERA = 0,
+	IRQ_GPIO0,
+	IRQ_GPIO1,
+	IRQ_GPIO2,
+	IRQ_GPIO3,
+	IRQ_AO_IR_DEC,
+	IRQ_AO_CEC,
+	IRQ_AO_GPIO0,
+	IRQ_AO_GPIO1,
+	IRQ_AO_TIMERA,
+	WAKE_UP_MAX = 32,
+};
+
+/* M3 CPU has 2 ao-gpio-irq, 4 gpio-irq*/
+#define GPIO_WAKEUP_MAX		6
+struct wakeup_gpio_info {
+	int wakeup_id;
+	int gpio_in_idx;
+	int gpio_in_ao;
+	int gpio_out_idx;
+	int gpio_out_ao;
+	int irq;
+	int trig_type;
+};
+struct wakeup_info {
+	unsigned status;
+	unsigned sources;
+	unsigned gpio_info_count;
+	struct wakeup_gpio_info gpio_info[GPIO_WAKEUP_MAX];
+};
+
+#define DIRECTION_IN		1
+#define DIRECTION_OUT	0
+
+#define SYS_SUSPEND 1
+#define SYS_POWEROFF 0
+
+#endif
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/task_apis.h b/arch/arm/cpu/armv8/txl/firmware/scp_task/task_apis.h
new file mode 100644
index 0000000..f9976b3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/task_apis.h
@@ -0,0 +1,57 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/task_apis.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __TASK_APIS_H_
+#define __TASK_APIS_H_
+
+void secure_task(void);
+void high_task(void);
+void low_task(void);
+
+void bss_init(void);
+
+int uart_putc(int c);
+void wait_uart_empty(void);
+void uart_put_hex(unsigned int data, unsigned bitlen);
+int uart_puts(const char *s);
+
+/* #define dbg_print(s,v) */
+/* #define dbg_prints(s) */
+#define writel(v, addr) (*((volatile unsigned *)addr) = v)
+#define readl(addr) (*((volatile unsigned *)addr))
+
+#define dbg_print(s, v) {uart_puts(s); uart_put_hex(v, 32); uart_puts("\n"); }
+/* #define dbg_prints(s)  {uart_puts(s);wait_uart_empty();} */
+#define dbg_prints(s)  {uart_puts(s); }
+
+void enter_suspend(unsigned int suspend_from);
+void get_dvfs_info(unsigned int domain,
+		unsigned char *info_out, unsigned int *size_out);
+void set_dvfs(unsigned int domain, unsigned int index);
+void *memcpy(void *dest, const void *src, unsigned int count);
+void *memset(void *s, int c, unsigned int count);
+void _udelay(unsigned int us);
+unsigned int get_time(void);
+
+void set_wakeup_method(unsigned int method);
+void suspend_pwr_ops_init(void);
+void suspend_get_wakeup_source(void *reponse, unsigned int suspend_from);
+#endif
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/task_entry.S b/arch/arm/cpu/armv8/txl/firmware/scp_task/task_entry.S
new file mode 100644
index 0000000..dc4b6a3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/task_entry.S
@@ -0,0 +1,17 @@
+#include "config.h"
+#include "registers.h"
+
+.text
+.syntax unified
+.code 16
+
+	.global task_entry
+.thumb_func
+task_entry:
+	b secure_task
+	b high_task
+	b low_task
+
+.section .bss_stack.usr_stack
+usr_stack:
+.space 3*CONFIG_TASK_STACK_SIZE
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/uart.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/uart.c
new file mode 100644
index 0000000..f53d221
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/uart.c
@@ -0,0 +1,122 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/uart.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "registers.h"
+#include <stdint.h>
+#include "task_apis.h"
+
+/* #define P_AO_UART_WFIFO                 (0xc81004c0) */
+/* #define P_AO_RTI_PIN_MUX_REG          (0xc8100014) */
+
+#define UART_PORT_CONS P_AO_UART_WFIFO
+
+#define UART_STP_BIT UART_MODE_MASK_STP_1BIT
+#define UART_PRTY_BIT 0
+#define UART_CHAR_LEN   UART_MODE_MASK_CHAR_8BIT
+#define UART_MODE_RESET_MASK	\
+					(UART_MODE_MASK_RST_TX \
+					| UART_MODE_MASK_RST_RX \
+					| UART_MODE_MASK_CLR_ERR)
+
+#define UART_WFIFO      (0<<2)
+#define UART_RFIFO	(1<<2)
+#define UART_MODE	(2<<2)
+#define UART_STATUS     (3<<2)
+#define UART_IRQCTL	(4<<2)
+#define UART_CTRL	(5<<2)
+#define UART_MODE_MASK_STP_1BIT                 (0<<16)
+#define UART_MODE_MASK_CHAR_8BIT                (0<<20)
+#define UART_MODE_MASK_TX_EN                    (1<<12)
+#define UART_MODE_MASK_RX_EN                    (1<<13)
+#define UART_MODE_MASK_RST_TX                   (1<<22)
+#define UART_MODE_MASK_RST_RX                   (1<<23)
+#define UART_MODE_MASK_CLR_ERR                  (1<<24)
+#define UART_STAT_MASK_TFIFO_FULL               (1<<21)
+#define UART_CTRL_USE_XTAL_CLK			(1<<24)
+#define UART_CTRL_USE_NEW_BAUD_RATE		(1<<23)
+
+#define P_UART(uart_base, reg)		(uart_base+reg)
+#define P_UART_WFIFO(uart_base)		P_UART(uart_base, UART_WFIFO)
+#define P_UART_MODE(uart_base)		P_UART(uart_base, UART_MODE)
+#define P_UART_CTRL(uart_base)		P_UART(uart_base, UART_CTRL)
+#define P_UART_STATUS(uart_base)	P_UART(uart_base, UART_STATUS)
+
+
+static int uart_tx_isfull(void)
+{
+	return readl(P_UART_STATUS(UART_PORT_CONS)) &
+		UART_STAT_MASK_TFIFO_FULL;
+}
+
+void wait_uart_empty(void)
+{
+#if 0
+	while (!(readl(P_UART_STATUS(UART_PORT_CONS)) & (1 << 22)))
+		;
+#else
+	unsigned int count=0;
+	do {
+		if ((readl(P_UART_STATUS(UART_PORT_CONS)) & (1 << 22)) == 0)
+			_udelay(4);
+		else
+			break;
+		count++;
+	} while ( count < 20000);
+#endif
+}
+
+int uart_putc(int c)
+{
+	if (c == '\n')
+		uart_putc('\r');
+
+	/* Wait until TX is not full */
+	while (uart_tx_isfull())
+		;
+
+	writel((char)c, P_UART_WFIFO(UART_PORT_CONS));
+	/*wait_uart_empty();*/
+	return c;
+}
+
+int uart_puts(const char *s)
+{
+	while (*s)
+		uart_putc(*s++);
+	return 1;
+}
+
+void uart_put_hex(unsigned int data, unsigned bitlen)
+{
+	int i;
+	unsigned char s;
+	for (i = bitlen - 4; i >= 0; i -= 4) {
+		if ((data >> i) == 0) {
+			uart_putc(0x30);
+			continue;
+		}
+		s = (data >> i) & 0xf;
+		if (s < 10)
+			uart_putc(0x30 + s);
+		else
+			uart_putc(0x61 + s - 10);
+	}
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/user_task.c b/arch/arm/cpu/armv8/txl/firmware/scp_task/user_task.c
new file mode 100644
index 0000000..189c096
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/user_task.c
@@ -0,0 +1,187 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/firmware/scp_task/user_task.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "config.h"
+#include "data.h"
+#include "registers.h"
+#include "task_apis.h"
+
+#define TASK_ID_LOW_MB	2
+#define TASK_ID_HIGH_MB	3
+#define TASK_ID_SECURE_MB  4
+
+enum scpi_client_id {
+	SCPI_CL_NONE,
+	SCPI_CL_CLOCKS,
+	SCPI_CL_DVFS,
+	SCPI_CL_POWER,
+	SCPI_CL_THERMAL,
+	SCPI_CL_REMOTE,
+	SCPI_MAX,
+};
+
+void __switch_back_securemb(void)
+{
+	register int p0 asm("r0") = 2;
+	register int p1 asm("r1") = TASK_ID_SECURE_MB;
+
+	asm("svc 0" :  : "r"(p0), "r"(p1));
+}
+void __switch_back_highmb(void)
+{
+	register int p0 asm("r0") = 2;
+	register int p1 asm("r1") = TASK_ID_HIGH_MB;
+
+	asm("svc 0" :  : "r"(p0), "r"(p1));
+}
+
+void __switch_back_lowmb(void)
+{
+	register int p0 asm("r0") = 2;
+	register int p1 asm("r1") = TASK_ID_LOW_MB;
+
+	asm("svc 0" :  : "r"(p0), "r"(p1));
+}
+
+void secure_task(void)
+{
+	unsigned *pcommand =
+	    (unsigned *)(&(secure_task_share_mem[TASK_COMMAND_OFFSET]));
+	unsigned *response =
+	    (unsigned *)(&(secure_task_share_mem[TASK_RESPONSE_OFFSET]));
+	unsigned command;
+	struct resume_param *presume;
+	unsigned int state;
+
+	/*init bss */
+	bss_init();
+	dbg_prints("secure task start!\n");
+
+	/* suspend pwr ops init*/
+	suspend_pwr_ops_init();
+	*pcommand = 0;
+
+	while (1) {
+		/* do secure task process */
+		command = *pcommand;
+		if (command) {
+			dbg_print("process command ", command);
+			if (command == SEC_TASK_GET_WAKEUP_SRC) {
+				state = *(pcommand+1);
+				suspend_get_wakeup_source(
+						(void *)response,  state);
+			} else if (command == COMMAND_SUSPEND_ENTER) {
+				state = *(pcommand+1);
+				enter_suspend(state);
+				*pcommand = 0;
+				*response = RESPONSE_SUSPEND_LEAVE;
+				presume = (struct resume_param *)(response+1);
+				presume->method = resume_data.method;
+			}
+	}
+		__switch_back_securemb();
+	}
+}
+
+void set_wakeup_method(unsigned int method)
+{
+	resume_data.method = method;
+}
+
+void process_high_task(unsigned command)
+{
+	unsigned *pcommand =
+	    (unsigned *)(&(high_task_share_mem[TASK_COMMAND_OFFSET]));
+/*	unsigned *response =
+	    (unsigned *)(&(high_task_share_mem[TASK_RESPONSE_OFFSET]));
+*/
+	if (command == HIGH_TASK_SET_DVFS)
+		set_dvfs(*(pcommand + 1), *(pcommand + 2));
+}
+
+void high_task(void)
+{
+	unsigned *pcommand =
+	    (unsigned *)(&(high_task_share_mem[TASK_COMMAND_OFFSET]));
+	unsigned *response =
+	    (unsigned *)(&(high_task_share_mem[TASK_RESPONSE_OFFSET]));
+	unsigned command;
+
+	dbg_prints("high task start!\n");
+	*pcommand = 0;
+
+	while (1) {
+		/* do high task process */
+		command = *pcommand;
+		if (command) {
+			/*dbg_print("process command ", command);*/
+			process_high_task(command);
+			*pcommand = 0;
+			*response = 0;
+		}
+		__switch_back_highmb();
+	}
+}
+
+extern unsigned int usr_pwr_key;
+void process_low_task(unsigned command)
+{
+	unsigned *pcommand =
+	    (unsigned *)(&(low_task_share_mem[TASK_COMMAND_OFFSET]));
+	unsigned *response =
+	    (unsigned *)(&(low_task_share_mem[TASK_RESPONSE_OFFSET]));
+	unsigned para1;
+
+	if (command == LOW_TASK_GET_DVFS_INFO) {
+		para1 = *(pcommand + 1);
+		get_dvfs_info(para1,
+			(unsigned char *)(response+2), (response+1));
+	} else if ((command & 0xffff) == LOW_TASK_USR_DATA) {/*0-15bit: comd; 16-31bit: client_id*/
+		if ((command >> 16) == SCPI_CL_REMOTE) {
+			usr_pwr_key = *(pcommand + 2);/*tx_size locates at *(pcommand + 1)*/
+			dbg_print("pwr_key=",usr_pwr_key);
+		}
+	}
+}
+
+void low_task(void)
+{
+	unsigned *pcommand =
+	    (unsigned *)(&(low_task_share_mem[TASK_COMMAND_OFFSET]));
+	unsigned *response =
+	    (unsigned *)(&(low_task_share_mem[TASK_RESPONSE_OFFSET]));
+	unsigned command;
+
+	*pcommand = 0;
+	dbg_prints("low task start!\n");
+
+	while (1) {
+		/* do low task process */
+		command = *pcommand;
+		if (command) {
+			process_low_task(command);
+
+			*pcommand = 0;
+			*response = 0;
+		}
+		__switch_back_lowmb();
+	}
+}
diff --git a/arch/arm/cpu/armv8/txl/firmware/scp_task/user_task.lds b/arch/arm/cpu/armv8/txl/firmware/scp_task/user_task.lds
new file mode 100644
index 0000000..52bc3c3
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/firmware/scp_task/user_task.lds
@@ -0,0 +1,35 @@
+#include "config.h"
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(task_entry)
+
+SECTIONS
+{
+	. = CONFIG_RAM_BASE;
+	.text		:
+	{
+		*task_entry.o (.text)
+		*(.text .text*)
+		*(.ARM.*)
+	}
+	.common :
+	{
+		*(.commo*)
+	}
+	.data	:
+	{
+		*(.bss .data .rodata*)
+	}
+
+	. = ALIGN(4);
+	_bssstart = . ;
+	.bss : { *(.bss) }
+	. = ALIGN(4);
+	_bssend = . ;
+
+	. = CONFIG_RAM_END - 3*CONFIG_TASK_STACK_SIZE - 128;
+	.bss_stack : { *(.bss_stack.usr_stack) }
+
+}
+ASSERT(_bssend <= CONFIG_RAM_END, "Data is too big. Please fine-tune start address and LENGTH!");
diff --git a/arch/arm/cpu/armv8/txl/gate_init.c b/arch/arm/cpu/armv8/txl/gate_init.c
new file mode 100644
index 0000000..a8bd060
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/gate_init.c
@@ -0,0 +1,382 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/gate_init.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "power_gate.h"
+
+#define SECUREBOOT_FLAG_ADDR 0xc8100228
+
+#ifdef CONFIG_AML_CVBS
+extern unsigned int cvbs_mode;
+#endif
+void ee_gate_off(void)
+{
+	printf("ee_gate_off ...\n");
+	return;
+/*	int secureboot = readl(SECUREBOOT_FLAG_ADDR)&(1<<5);*/
+
+#ifdef CONFIG_AML_CVBS
+	unsigned int cvbs_opened = 0;
+#endif
+
+#ifdef CONFIG_AML_CVBS
+	if ((cvbs_mode == 0) || (cvbs_mode == 1))
+		cvbs_opened = 1;
+#endif
+
+	/*
+	//if close , audio maybe have noise
+	CLK_GATE_OFF(AUD);
+	CLK_GATE_OFF(AUD2);
+	CLK_GATE_OFF(AUD_CLK_2);
+	CLK_GATE_OFF(AUD_CLK_3);
+	*/
+	CLK_GATE_OFF(AUD_IN);
+	CLK_GATE_OFF(AIU_AUD_MIXER);
+	CLK_GATE_OFF(SANA);
+
+	/*kernel will reopen */
+	CLK_GATE_OFF(CTS_ENCL);
+	/* CLK_GATE_OFF(CTS_ENCT); */
+#if 0    /* HDMITX 480i60hz/576i50hz need this gate */
+#ifdef CONFIG_AML_CVBS
+	if (cvbs_opened == 0)
+		CLK_GATE_OFF(CTS_ENCI);
+#else
+	CLK_GATE_OFF(CTS_ENCI);
+#endif
+#endif
+	/* CLK_GATE_OFF(CTS_ENCP); */
+
+	/*close cvbs clock*/
+#ifdef CONFIG_AML_CVBS
+	if (cvbs_opened == 0) {
+		CLK_GATE_OFF(DAC_CLK);
+		CLK_GATE_OFF(CTS_VDAC);
+	}
+#else
+	CLK_GATE_OFF(DAC_CLK);
+	CLK_GATE_OFF(CTS_VDAC);
+#endif
+
+	/* usb clock close */
+	CLK_GATE_OFF(USB0);
+	CLK_GATE_OFF(USB1);
+	CLK_GATE_OFF(USB_CLK);
+	CLK_GATE_OFF(MISC_USB0_TO_DDR);
+	CLK_GATE_OFF(MISC_USB1_TO_DDR);
+
+	/* uarts close */
+	CLK_GATE_OFF(UART0);
+	CLK_GATE_OFF(UART1);
+	CLK_GATE_OFF(UART2);
+	CLK_GATE_OFF(UART3);
+
+	CLK_GATE_OFF(VCLK2_VENCP);
+	CLK_GATE_OFF(VCLK2_VENCT);
+	CLK_GATE_OFF(VCLK2_VENCT1);
+	CLK_GATE_OFF(VCLK2_OTHER);
+#if 0    /* HDMITX 480i60hz/576i50hz need HHI_GCLK_OTHER[8][2] */
+#ifdef CONFIG_AML_CVBS
+	if (cvbs_opened == 0) {
+		CLK_GATE_OFF(VCLK2_VENCI);
+		CLK_GATE_OFF(VCLK2_VENCI1);
+	}
+#else
+	CLK_GATE_OFF(VCLK2_VENCI);
+	CLK_GATE_OFF(VCLK2_VENCI1);
+#endif
+#endif
+	CLK_GATE_OFF(VCLK2_VENCL);
+	CLK_GATE_OFF(VCLK2_OTHER1);
+#if 0    /* HDMITX 480i60hz/576i50hz need HHI_GCLK_OTHER[8][2] */
+#ifdef CONFIG_AML_CVBS
+	if (cvbs_opened == 0)
+		CLK_GATE_OFF(VCLK2_ENCI);
+#else
+	CLK_GATE_OFF(VCLK2_ENCI);
+#endif
+#endif
+	CLK_GATE_OFF(VCLK2_ENCL);
+	CLK_GATE_OFF(VCLK2_ENCT);
+
+	CLK_GATE_OFF(VDEC_CLK_1);
+	CLK_GATE_OFF(VDEC_CLK_2);
+	CLK_GATE_OFF(VDEC2_CLK_1);
+	CLK_GATE_OFF(VDEC2_CLK_2);
+	CLK_GATE_OFF(HCODEC_CLK_1);
+	CLK_GATE_OFF(HCODEC_CLK_2);
+	/* CLK_GATE_OFF(HEVC_CLK_1 ); */
+	/* CLK_GATE_OFF(HEVC_CLK_2 ); */
+
+	CLK_GATE_OFF(MMC_A_PCLK);
+	CLK_GATE_OFF(MMC_B_PCLK);
+	CLK_GATE_OFF(MMC_C_PCLK);
+
+	CLK_GATE_OFF(LCD_AN_PHY2);
+	CLK_GATE_OFF(LCD_AN_PHY3);
+
+	CLK_GATE_OFF(ETHERNET);
+	CLK_GATE_OFF(ETH_CLK);
+
+	CLK_GATE_OFF(GE2D);
+	CLK_GATE_OFF(GEN_CLK);
+	CLK_GATE_OFF(PCM_MCLK);
+	CLK_GATE_OFF(PCM_SCLK);
+
+
+	CLK_GATE_OFF(HIU_PARSER_TOP);
+
+
+	/* can not off nand_clk */
+	/* CLK_GATE_OFF(NAND_CLK); */
+	/*
+	//HDMI no output
+	CLK_GATE_OFF(VCLK2_VENCP1);
+	CLK_GATE_OFF(VCLK2_ENCP);
+	*/
+
+	/*
+	//if OFF, HDMI will report error!
+	CLK_GATE_OFF(HDMI_PCLK);
+	CLK_GATE_OFF(HDMI_PLL_CNTL);
+	CLK_GATE_OFF(HDMITX_CLK);
+	*/
+
+	/*
+	//PWM B used for VCCK,PWM D used for VDDEE,ignoring
+	CLK_GATE_OFF(PWM_A_CLK);
+	CLK_GATE_OFF(PWM_B_CLK);
+	CLK_GATE_OFF(PWM_C_CLK);
+	CLK_GATE_OFF(PWM_D_CLK);
+	CLK_GATE_OFF(PWM_E_CLK);
+	CLK_GATE_OFF(PWM_F_CLK);
+	*/
+
+
+	/*  can not close
+	    CLK_GATE_OFF(VPU_CLK_1);
+	    CLK_GATE_OFF(VPU_CLK_2);
+	    CLK_GATE_OFF(VPU_CLKB);
+	    CLK_GATE_OFF(MALI_CLK_1);
+	    CLK_GATE_OFF(MALI_CLK_2);
+	    CLK_GATE_OFF(ATV_DEMO_VDAC);
+	    CLK_GATE_OFF(EMMC_A);
+	    CLK_GATE_OFF(EMMC_B);
+	    CLK_GATE_OFF(EMMC_C);
+	    CLK_GATE_OFF(EMMC_A_CLK);
+	    CLK_GATE_OFF(EMMC_B_CLK);
+
+	    CLK_GATE_OFF(MSR_CLK);
+	    CLK_GATE_OFF(MSR_HS_CLK);
+	    CLK_GATE_OFF(32K_CLK);
+	    CLK_GATE_OFF(VAPB_CLK_1);
+	    CLK_GATE_OFF(VAPB_CLK_2);
+	    CLK_GATE_OFF(GIC);
+	    CLK_GATE_OFF(I2C_AO); //no close for to use
+	    CLK_GATE_OFF(AO_CPU);
+	    CLK_GATE_OFF(ASSIST_MISC);
+	    CLK_GATE_OFF(HIU_PARSER);
+	    CLK_GATE_OFF(PERIPHS_TOP);
+	    CLK_GATE_OFF(PL310_CBUS);
+	    CLK_GATE_OFF(ISA);
+	    CLK_GATE_OFF(SECURE_AHP_APB3);
+	    CLK_GATE_OFF(VPU_INTR);
+	    CLK_GATE_OFF(MMC_PCLK); //can not close
+	    CLK_GATE_OFF(AIU_PCLK);
+	//can not connect pc
+	CLK_GATE_OFF(USB_GENERAL);
+	CLK_GATE_OFF(AHB_DATA_BUS);
+	CLK_GATE_OFF(AHB_CONTROL_BUS);
+	CLK_GATE_OFF(HDMI_INTR_SYNC); //should open
+	//can't suspend @ 2nd time
+	//CLK_GATE_OFF(RESET);
+
+	// close rom
+	//disable this bit will make other cpu can not be booted.
+	//CLK_GATE_OFF(ROM_CLK);
+
+*/
+	/*************************/
+	CLK_GATE_OFF(AHB_ARB0);
+	CLK_GATE_OFF(ASYNC_FIFO);
+	CLK_GATE_OFF(STREAM);
+	CLK_GATE_OFF(RANDOM_NUM_GEN);
+	CLK_GATE_OFF(RANDOM_NUM_GEN1);
+	CLK_GATE_OFF(SMART_CARD_MPEG_DOMAIN);
+	CLK_GATE_OFF(I2C);
+	CLK_GATE_OFF(SPI);
+	CLK_GATE_OFF(SPICC);
+	CLK_GATE_OFF(DOS);
+	CLK_GATE_OFF(SAR_ADC);
+	CLK_GATE_OFF(MISC_DVIN);
+	CLK_GATE_OFF(BT656);
+	CLK_GATE_OFF(BT656_2);
+	CLK_GATE_OFF(PDM);
+
+	/* close AIU */
+	CLK_GATE_OFF(AIU_IEC958);
+	CLK_GATE_OFF(AIU_ICE958_AMCLK);
+
+	CLK_GATE_OFF(AIU_AMCLK_MEASURE);
+	CLK_GATE_OFF(AIU_AIFIFO2);
+	CLK_GATE_OFF(AIU_MIXER_REG);
+	CLK_GATE_OFF(AIU_ADC);
+	CLK_GATE_OFF(AIU_TOP_LEVEL);
+	CLK_GATE_OFF(AIU_AOCLK);
+	CLK_GATE_OFF(AIU_AI_TOP_GLUE);
+	CLK_GATE_OFF(AIU_I2S_OUT);
+
+	CLK_GATE_OFF(ENC480P);
+
+	CLK_GATE_OFF(DEMUX);
+/*
+*	EFUSE/BLK_MOV clock gate must be on,
+	kernel storage ops depend on them.
+	it can be reference PD#112732
+*/
+/*
+	if (secureboot) {
+		printf("secure boot ignore [ BLK_MOV, efuse ] clk gate\n");
+	} else {
+		CLK_GATE_OFF(EFUSE);
+		CLK_GATE_OFF(BLK_MOV);
+	}
+*/
+}
+
+void ee_gate_on(void)
+{
+
+	printf("ee_gate_on ...\n");
+
+	/*
+	//if close , audio maybe have noise
+	CLK_GATE_ON(AUD);
+	CLK_GATE_ON(AUD2);
+	CLK_GATE_ON(AUD_CLK_2);
+	CLK_GATE_ON(AUD_CLK_3);
+	*/
+	CLK_GATE_ON(AUD_IN);
+	CLK_GATE_ON(AIU_AUD_MIXER);
+	CLK_GATE_ON(SANA);
+
+	/*kernel will reopen */
+	CLK_GATE_ON(CTS_ENCL);
+	/* CLK_GATE_ON(CTS_ENCT); */
+	CLK_GATE_ON(CTS_ENCI);
+	/* CLK_GATE_ON(CTS_ENCP); */
+
+	/*close cvbs clock*/
+	CLK_GATE_ON(DAC_CLK);
+	CLK_GATE_ON(CTS_VDAC);
+
+	/* usb clock close */
+	CLK_GATE_ON(USB0);
+	CLK_GATE_ON(USB1);
+	CLK_GATE_ON(USB_CLK);
+	CLK_GATE_ON(MISC_USB0_TO_DDR);
+	CLK_GATE_ON(MISC_USB1_TO_DDR);
+
+	/* uarts close */
+	CLK_GATE_ON(UART0);
+	CLK_GATE_ON(UART1);
+	CLK_GATE_ON(UART2);
+	CLK_GATE_ON(UART3);
+
+	CLK_GATE_ON(VCLK2_VENCP);
+	CLK_GATE_ON(VCLK2_VENCT);
+	CLK_GATE_ON(VCLK2_VENCT1);
+	CLK_GATE_ON(VCLK2_OTHER);
+	CLK_GATE_ON(VCLK2_VENCI);
+	CLK_GATE_ON(VCLK2_VENCI1);
+	CLK_GATE_ON(VCLK2_VENCL);
+	CLK_GATE_ON(VCLK2_OTHER1);
+
+
+	CLK_GATE_ON(VCLK2_ENCI);
+	CLK_GATE_ON(VCLK2_ENCL);
+	CLK_GATE_ON(VCLK2_ENCT);
+
+	CLK_GATE_ON(VDEC_CLK_1);
+	CLK_GATE_ON(VDEC_CLK_2);
+	CLK_GATE_ON(VDEC2_CLK_1);
+	CLK_GATE_ON(VDEC2_CLK_2);
+	CLK_GATE_ON(HCODEC_CLK_1);
+	CLK_GATE_ON(HCODEC_CLK_2);
+	/* CLK_GATE_ON(HEVC_CLK_1 ); */
+	/* CLK_GATE_ON(HEVC_CLK_2 ); */
+
+	CLK_GATE_ON(MMC_A_PCLK);
+	CLK_GATE_ON(MMC_B_PCLK);
+	CLK_GATE_ON(MMC_C_PCLK);
+
+	CLK_GATE_ON(LCD_AN_PHY2);
+	CLK_GATE_ON(LCD_AN_PHY3);
+
+	CLK_GATE_ON(ETHERNET);
+	CLK_GATE_ON(ETH_CLK);
+
+	CLK_GATE_ON(GE2D);
+	CLK_GATE_ON(GEN_CLK);
+	CLK_GATE_ON(PCM_MCLK);
+	CLK_GATE_ON(PCM_SCLK);
+
+
+	CLK_GATE_ON(HIU_PARSER_TOP);
+
+	/*************************/
+	CLK_GATE_ON(AHB_ARB0);
+	CLK_GATE_ON(ASYNC_FIFO);
+	CLK_GATE_ON(STREAM);
+	CLK_GATE_ON(RANDOM_NUM_GEN);
+	CLK_GATE_ON(RANDOM_NUM_GEN1);
+	CLK_GATE_ON(SMART_CARD_MPEG_DOMAIN);
+	CLK_GATE_ON(I2C);
+	CLK_GATE_ON(SPI);
+	CLK_GATE_ON(SPICC);
+	CLK_GATE_ON(DOS);
+	CLK_GATE_ON(SAR_ADC);
+	CLK_GATE_ON(MISC_DVIN);
+	CLK_GATE_ON(BT656);
+	CLK_GATE_ON(BT656_2);
+	CLK_GATE_ON(PDM);
+
+	/* close AIU */
+	CLK_GATE_ON(AIU_IEC958);
+	CLK_GATE_ON(AIU_ICE958_AMCLK);
+
+	CLK_GATE_ON(AIU_AMCLK_MEASURE);
+	CLK_GATE_ON(AIU_AIFIFO2);
+	CLK_GATE_ON(AIU_MIXER_REG);
+	CLK_GATE_ON(AIU_ADC);
+	CLK_GATE_ON(AIU_TOP_LEVEL);
+	CLK_GATE_ON(AIU_AOCLK);
+	CLK_GATE_ON(AIU_AI_TOP_GLUE);
+	CLK_GATE_ON(AIU_I2S_OUT);
+
+	CLK_GATE_ON(ENC480P);
+
+	CLK_GATE_ON(DEMUX);
+
+	CLK_GATE_ON(EFUSE);
+	CLK_GATE_ON(BLK_MOV);
+}
+
diff --git a/arch/arm/cpu/armv8/txl/gpio.c b/arch/arm/cpu/armv8/txl/gpio.c
new file mode 100644
index 0000000..1974f58
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/gpio.c
@@ -0,0 +1,237 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/gpio.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <dm.h>
+#include <linux/compiler.h>
+#include <aml_gpio.h>
+#include <asm/arch/gpio.h>
+
+#define NE 0xffffffff
+#define PK(reg, bit) ((reg<<5)|bit)
+/*AO REG */
+#define AO 0x10
+#define AO2 0x11
+
+static unsigned int gpio_to_pin[][6] = {
+		[PIN_GPIOX_0] = {PK(5, 31), NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_1] = {PK(5, 30), NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_2] = {PK(5, 29), NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_3] = {PK(5, 28), NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_4] = {PK(5, 27), NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_5] = {PK(5, 26), NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_6] = {PK(5, 25), NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_7] = {PK(5, 24), PK(5, 14), NE, NE, NE, NE,},
+		[PIN_GPIOX_8] = {PK(5, 23), PK(5, 13), PK(5, 3), NE, NE, NE,},
+		[PIN_GPIOX_9] = {PK(5, 22), PK(5, 12), PK(5, 2), NE, NE, NE,},
+		[PIN_GPIOX_10] = {PK(5, 21), PK(5, 11), PK(5, 5), PK(5, 1), NE, NE,},
+		[PIN_GPIOX_11] = {PK(5, 20), PK(5, 10), PK(5, 4), PK(5, 0), NE, NE,},
+		[PIN_GPIOX_12] = {PK(5, 19), PK(5, 9), NE, NE, NE, NE,},
+		[PIN_GPIOX_13] = {PK(5, 18), PK(5, 8), NE, NE, NE, NE,},
+		[PIN_GPIOX_14] = {PK(5, 17), PK(5, 7), NE, NE, NE, NE,},
+		[PIN_GPIOX_15] = {PK(5, 16), PK(5, 6), NE, NE, NE, NE,},
+		[PIN_GPIOX_16] = {PK(5, 15), NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_17] = {NE, NE, NE, NE, NE, NE,},
+		[PIN_GPIOX_18] = {NE, NE, NE, NE, NE, NE,},
+
+		[PIN_BOOT_0] = {PK(7, 31), NE, NE, NE, NE, NE,},
+		[PIN_BOOT_1] = {PK(7, 31), NE, NE, NE, NE, NE,},
+		[PIN_BOOT_2] = {PK(7, 31), NE, NE, NE, NE, NE,},
+		[PIN_BOOT_3] = {PK(7, 23), PK(7, 31), NE, NE, NE, NE,},
+		[PIN_BOOT_4] = {PK(7, 22), PK(7, 31), NE, NE, NE, NE,},
+		[PIN_BOOT_5] = {PK(7, 21), PK(7, 31), NE, NE, NE, NE,},
+		[PIN_BOOT_6] = {PK(7, 20), PK(7, 31), NE, NE, NE, NE,},
+		[PIN_BOOT_7] = {PK(7, 19), PK(7, 31), NE, NE, NE, NE,},
+		[PIN_BOOT_8] = {PK(7, 18), PK(7, 30), PK(7, 7), NE, NE, NE,},
+		[PIN_BOOT_9] = {PK(7, 17), PK(7, 6), NE, NE, NE, NE,},
+		[PIN_BOOT_10] = {PK(7, 16), PK(7, 29), PK(7, 5), NE, NE, NE,},
+		[PIN_BOOT_11] = {PK(7, 15), PK(7, 4), PK(7, 13), NE, NE, NE,},
+		[PIN_BOOT_12] = {PK(7, 3), PK(7, 12), NE, NE, NE, NE,},
+		[PIN_BOOT_13] = {PK(7, 2), PK(7, 11), NE, NE, NE, NE,},
+		[PIN_BOOT_14] = {PK(7, 1), NE, NE, NE, NE, NE,},
+		[PIN_BOOT_15] = {PK(7, 28), PK(7, 0), PK(7, 10), NE, NE, NE,},
+
+		[PIN_GPIOH_0] = {PK(6, 31), NE, NE, NE, NE, NE,},
+		[PIN_GPIOH_1] = {PK(6, 30), NE, NE, NE, NE, NE,},
+		[PIN_GPIOH_2] = {PK(6, 29), NE, NE, NE, NE, NE,},
+		[PIN_GPIOH_3] = {NE, NE, NE, NE, NE, NE,},
+		[PIN_GPIOH_4] = {PK(6, 28), PK(6, 27), NE, NE, NE, NE,},
+		[PIN_GPIOH_5] = {NE, NE, NE, NE, NE, NE,},
+		[PIN_GPIOH_6] = {PK(6, 26), PK(6, 20), NE, NE, NE, NE,},
+		[PIN_GPIOH_7] = {PK(6, 25), PK(6, 22), PK(6, 19), NE, NE, NE,},
+		[PIN_GPIOH_8] = {PK(6, 24), PK(6, 21), PK(6, 18), NE, NE, NE,},
+		[PIN_GPIOH_9] = {PK(6, 23), PK(6, 17), NE, NE, NE, NE,},
+
+		[PIN_GPIOZ_0] = {PK(4, 23), PK(3, 31), PK(3, 19), PK(3, 14), NE, NE,},
+		[PIN_GPIOZ_1] = {PK(4, 22), PK(3, 30), PK(3, 18), PK(3, 13), NE, NE,},
+		[PIN_GPIOZ_2] = {PK(4, 21), PK(3, 29), PK(3, 17), NE, NE, NE,},
+		[PIN_GPIOZ_3] = {PK(4, 20), PK(3, 28), PK(3, 16), PK(3, 12), NE, NE,},
+		[PIN_GPIOZ_4] = {PK(4, 19), PK(3, 27), PK(3, 15), PK(3, 11), NE, NE,},
+		[PIN_GPIOZ_5] = {PK(4, 18), PK(3, 26), PK(3, 11), NE, NE, NE,},
+		[PIN_GPIOZ_6] = {PK(4, 17), PK(4, 9), PK(3, 25), PK(3, 11), NE, NE,},
+		[PIN_GPIOZ_7] = {PK(4, 16), PK(4, 8), PK(3, 24), PK(3, 11), NE, NE,},
+		[PIN_GPIOZ_8] = {PK(4, 15), PK(4, 7), PK(3, 23), PK(3, 11), NE, NE,},
+		[PIN_GPIOZ_9] = {PK(4, 14), PK(4, 6), PK(3, 22), PK(3, 11), NE, NE,},
+		[PIN_GPIOZ_10] = {PK(4, 13), PK(4, 5), PK(3, 11), NE, NE, NE,},
+		[PIN_GPIOZ_11] = {PK(4, 12), PK(4, 4), PK(3, 11), NE, NE, NE,},
+		[PIN_GPIOZ_12] = {PK(4, 11), PK(4, 3), NE, NE, NE, NE,},
+		[PIN_GPIOZ_13] = {PK(4, 10), PK(4, 2), NE, NE, NE, NE,},
+		[PIN_GPIOZ_14] = {PK(3, 21), PK(4, 25), NE, NE, NE, NE,},
+		[PIN_GPIOZ_15] = {PK(3, 20), PK(4, 24), NE, NE, NE, NE,},
+
+		[PIN_GPIODV_0] = {PK(3, 10), PK(3, 2), PK(2, 10), PK(2, 4), PK(1, 8),
+					NE,},
+		[PIN_GPIODV_1] = {PK(3, 10), PK(3, 1), PK(2, 10), PK(2, 3), NE, NE,},
+		[PIN_GPIODV_2] = {PK(3, 9), PK(3, 0), PK(2, 10), PK(2, 3), NE, NE,},
+		[PIN_GPIODV_3] = {PK(3, 9), PK(2, 31), PK(2, 10), PK(2, 3), NE, NE,},
+		[PIN_GPIODV_4] = {PK(3, 9), PK(2, 30), PK(2, 10), PK(2, 3), NE, NE,},
+		[PIN_GPIODV_5] = {PK(3, 9), PK(2, 29), PK(2, 10), PK(2, 3), NE, NE,},
+		[PIN_GPIODV_6] = {PK(3, 9), PK(2, 28), PK(2, 10), PK(2, 3), NE, NE,},
+		[PIN_GPIODV_7] = {PK(3, 9), PK(2, 27), PK(2, 10), PK(2, 3), NE, NE,},
+		[PIN_GPIODV_8] = {PK(3, 8), PK(2, 26), PK(2, 10), PK(2, 2), NE, NE,},
+		[PIN_GPIODV_9] = {PK(3, 8), PK(2, 25), PK(2, 10), PK(2, 1), NE, NE,},
+		[PIN_GPIODV_10] = {PK(3, 7), PK(2, 24), PK(2, 10), PK(2, 0), NE, NE,},
+		[PIN_GPIODV_11] = {PK(3, 7), PK(2, 23), PK(2, 10), PK(1, 31), NE, NE,},
+		[PIN_GPIODV_12] = {PK(3, 7), PK(2, 22), PK(2, 10), PK(1, 30), NE, NE,},
+		[PIN_GPIODV_13] = {PK(3, 7), PK(2, 21), PK(2, 10), PK(1, 29), NE, NE,},
+		[PIN_GPIODV_14] = {PK(3, 7), PK(2, 20), PK(2, 10), PK(1, 28), NE, NE,},
+		[PIN_GPIODV_15] = {PK(3, 7), PK(2, 19), PK(2, 10), PK(1, 27), NE, NE,},
+		[PIN_GPIODV_16] = {PK(3, 6), PK(2, 9), PK(1, 26), PK(1, 24), NE, NE,},
+		[PIN_GPIODV_17] = {PK(3, 6), PK(2, 8), PK(1, 25), PK(1, 23), NE, NE,},
+		[PIN_GPIODV_18] = {PK(3, 5), PK(1, 25), PK(1, 17), NE, NE, NE,},
+		[PIN_GPIODV_19] = {PK(3, 5), PK(1, 25), PK(1, 16), NE, NE, NE,},
+		[PIN_GPIODV_20] = {PK(3, 5), PK(1, 25), NE, NE, NE, NE,},
+		[PIN_GPIODV_21] = {PK(3, 5), PK(1, 25), NE, NE, NE, NE,},
+		[PIN_GPIODV_22] = {PK(3, 5), PK(2, 18), PK(1, 25), NE, NE, NE,},
+		[PIN_GPIODV_23] = {PK(3, 5), PK(2, 17), PK(1, 25), NE, NE, NE,},
+		[PIN_GPIODV_24] = {PK(3, 4), PK(2, 16), PK(2, 7), PK(1, 22), PK(1, 15),
+					NE,},
+		[PIN_GPIODV_25] = {PK(3, 3), PK(2, 15), PK(2, 6), PK(1, 21), PK(1, 14),
+					NE,},
+		[PIN_GPIODV_26] = {PK(2, 14), PK(1, 20), PK(1, 13), NE, NE, NE,},
+		[PIN_GPIODV_27] = {PK(2, 13), PK(1, 18), PK(1, 19), PK(1, 12), NE, NE,},
+		[PIN_GPIODV_28] = {PK(2, 12), PK(1, 9), PK(1, 11), NE, NE, NE,},
+		[PIN_GPIODV_29] = {PK(2, 11), PK(2, 5), PK(1, 10), NE, NE, NE,},
+
+		[GPIOAO_0] = {PK(AO, 12), PK(AO, 26), NE, NE, NE, NE,},
+		[GPIOAO_1] = {PK(AO, 11), PK(AO, 25), NE, NE, NE, NE,},
+		[GPIOAO_2] = {PK(AO, 10), PK(AO, 8), NE, NE, NE, NE,},
+		[GPIOAO_3] = {PK(AO, 9), PK(AO, 7), PK(AO, 22), NE, NE, NE,},
+		[GPIOAO_4] = {PK(AO, 24), PK(AO, 6), PK(AO, 2), NE, NE, NE,},
+		[GPIOAO_5] = {PK(AO, 23), PK(AO, 5), PK(AO, 1), NE, NE, NE,},
+		[GPIOAO_6] = {PK(AO, 16), PK(AO, 18), NE, NE, NE, NE,},
+		[GPIOAO_7] = {PK(AO, 0), PK(AO, 21), NE, NE, NE, NE,},
+		[GPIOAO_8] = {PK(AO, 15), PK(AO, 14), PK(AO2, 0), PK(AO, 17), NE, NE,},
+		[GPIOAO_9] = {PK(AO, 31), PK(AO, 4), PK(AO2, 1), PK(AO, 3), NE, NE,},
+
+		[PIN_CARD_0] = {PK(6, 5), NE, NE, NE, NE, NE,},
+		[PIN_CARD_1] = {PK(6, 4), NE, NE, NE, NE, NE,},
+		[PIN_CARD_2] = {PK(6, 3), NE, NE, NE, NE, NE,},
+		[PIN_CARD_3] = {PK(6, 2), NE, NE, NE, NE, NE,},
+		[PIN_CARD_4] = {PK(6, 1), PK(6, 9), PK(6, 11), PK(6, 7
+		), NE, NE,},
+		[PIN_CARD_5] = {PK(6, 0), PK(6, 8), PK(6, 10), PK(6, 6
+		), NE, NE,},
+		[PIN_CARD_6] = {NE, NE, NE, NE, NE, NE,},
+
+		[PIN_GPIO_TEST_N] = {PK(AO, 13), PK(AO2, 2), NE, NE, NE, NE,},
+};
+
+#define BANK(n, f, l, per, peb, pr, pb, dr, db, or, ob, ir, ib)		\
+	{								\
+		.name	= n,						\
+		.first	= f,						\
+		.last	= l,						\
+		.regs	= {						\
+			[REG_PULLEN]	= { (0xc8834120 + (per<<2)), peb },			\
+			[REG_PULL]	= { (0xc88344e8 + (pr<<2)), pb },			\
+			[REG_DIR]	= { (0xc8834430 + (dr<<2)), db },			\
+			[REG_OUT]	= { (0xc8834430 + (or<<2)), ob },			\
+			[REG_IN]	= { (0xc8834430 + (ir<<2)), ib },			\
+		},							\
+	 }
+#define AOBANK(n, f, l, per, peb, pr, pb, dr, db, or, ob, ir, ib)		\
+	{								\
+		.name	= n,						\
+		.first	= f,						\
+		.last	= l,						\
+		.regs	= {						\
+			[REG_PULLEN]	= { (0xc810002c + (per<<2)), peb },			\
+			[REG_PULL]	= { (0xc810002c + (pr<<2)), pb },			\
+			[REG_DIR]	= { (0xc8100024 + (dr<<2)), db },			\
+			[REG_OUT]	= { (0xc8100024 + (or<<2)), ob },			\
+			[REG_IN]	= { (0xc8100024 + (ir<<2)), ib },			\
+		},							\
+	 }
+
+static struct meson_bank mesongxbb_banks[] = {
+	/*   name    first         last
+	 *   pullen  pull     dir     out     in  */
+		BANK("GPIOX_",    PIN_GPIOX_0,  PIN_GPIOX_18,
+		     4,  0,  4,  0,  12,  0,  13,  0,  14,  0),
+		BANK("GPIODV_",  PIN_GPIODV_0, PIN_GPIODV_29,
+		     0,  0,  0,  0,  0,  0,  1,  0,  2,  0),
+		BANK("GPIOH_",    PIN_GPIOH_0,  PIN_GPIOH_9,
+		     1, 20,  1, 20,  3, 20, 4, 20, 5, 20),
+		BANK("GPIOZ_",    PIN_GPIOZ_0,  PIN_GPIOZ_15,
+		     3,  0,  3,  0,  9, 0,  10, 0,  11, 0),
+		BANK("CARD_", PIN_CARD_0,   PIN_CARD_6,
+		     2, 20,  2, 20,  6, 20,  7, 20,  8, 20),
+		BANK("BOOT_", PIN_BOOT_0,   PIN_BOOT_15,
+		     2,  0,  2,  0,  6,  0, 7,  0, 8,  0),
+		BANK("GPIOCLK_", PIN_GPIOCLK_0,   PIN_GPIOCLK_1,
+		     3,  28,  3,  28,  9,  28, 10,  28, 11,  28),
+		AOBANK("GPIOAO_",   GPIOAO_0, GPIOAO_9,
+		     0,  0,  0, 16,  0,  0,  0, 16,  1,  0),
+};
+
+U_BOOT_DEVICES(gxbb_gpios) = {
+	{ "gpio_aml", &mesongxbb_banks[0] },
+	{ "gpio_aml", &mesongxbb_banks[1] },
+	{ "gpio_aml", &mesongxbb_banks[2] },
+	{ "gpio_aml", &mesongxbb_banks[3] },
+	{ "gpio_aml", &mesongxbb_banks[4] },
+	{ "gpio_aml", &mesongxbb_banks[5] },
+	{ "gpio_aml", &mesongxbb_banks[6] },
+	{ "gpio_aml", &mesongxbb_banks[7] },
+};
+static unsigned long domain[]={
+	[0] = 0xc88344b0,
+	[1] = 0xc8100014,
+};
+int  clear_pinmux(unsigned int pin)
+{
+	unsigned int *gpio_reg =  &gpio_to_pin[pin][0];
+	int i, dom, reg, bit;
+	for (i = 0;
+	     i < sizeof(gpio_to_pin[pin])/sizeof(gpio_to_pin[pin][0]); i++) {
+		if (gpio_reg[i] != NE) {
+			reg = GPIO_REG(gpio_reg[i])&0xf;
+			bit = GPIO_BIT(gpio_reg[i]);
+			dom = GPIO_REG(gpio_reg[i])>>4;
+			regmap_update_bits(domain[dom]+reg*4,BIT(bit),0);
+		}
+	}
+	return 0;
+
+}
+
+
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/Makefile b/arch/arm/cpu/armv8/txl/hdmitx20/Makefile
new file mode 100644
index 0000000..1ee4930
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/Makefile
@@ -0,0 +1,11 @@
+#
+# (C) Copyright 2015
+#
+
+#EXTRA_CFLAGS = -Idrivers/video/include/
+
+obj-$(CONFIG_AML_HDMITX20) += hdmitx20.o
+
+hdmitx20-y := reg_ops.o hdmitx_set.o hdmitx_tvenc.o enc_clk_config.o
+#aml_hdmitx20-$(CONFIG_AML_HDMITX20_HDCP) += hdmitx_hdcp.o
+
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/enc_clk_config.c b/arch/arm/cpu/armv8/txl/hdmitx20/enc_clk_config.c
new file mode 100644
index 0000000..ec2ac57
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/enc_clk_config.c
@@ -0,0 +1,393 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/enc_clk_config.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <amlogic/enc_clk_config.h>
+#include <asm/arch/io.h>
+#include <asm/io.h>
+#include "hw_enc_clk_config.h"
+#include "mach_reg.h"
+#include <amlogic/hdmi.h>
+
+#define msleep(i) udelay(i*1000)
+
+#define check_clk_config(para)\
+	if (para == -1)\
+		return;
+
+#define check_div() \
+	if (div == -1)\
+		return ;\
+	switch (div) {\
+	case 1:\
+		div = 0; break;\
+	case 2:\
+		div = 1; break;\
+	case 4:\
+		div = 2; break;\
+	case 6:\
+		div = 3; break;\
+	case 12:\
+		div = 4; break;\
+	default:\
+		break;\
+	}
+
+#define WAIT_FOR_PLL_LOCKED(reg)                        \
+	do {                                                \
+		unsigned int cnt = 10;                          \
+		unsigned int time_out = 0;                      \
+		while (cnt --) {                                 \
+		time_out = 0;                               \
+		while ((!(hd_read_reg(reg) & (1 << 31)))\
+			& (time_out < 10000))               \
+			time_out ++;                            \
+		}                                               \
+		if (cnt < 9)                                     \
+			printk("pll[0x%x] reset %d times\n", reg, 9 - cnt);\
+	} while(0);
+
+// viu_channel_sel: 1 or 2
+// viu_type_sel: 0: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT.
+int set_viu_path(unsigned viu_channel_sel, enum viu_type viu_type_sel)
+{
+	if ((viu_channel_sel > 2) || (viu_channel_sel == 0))
+		return -1;
+	if (viu_channel_sel == 1)
+		hd_set_reg_bits(P_VPU_VIU_VENC_MUX_CTRL, viu_type_sel, 0, 2);
+	else
+		//viu_channel_sel ==2
+		hd_set_reg_bits(P_VPU_VIU_VENC_MUX_CTRL, viu_type_sel, 2, 2);
+	return 0;
+}
+
+static void set_hdmitx_sys_clk(void)
+{
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 0, 9, 3);
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 0, 0, 7);
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 1, 8, 1);
+}
+
+static void set_hpll_clk_out(unsigned clk)
+{
+	check_clk_config(clk);
+	printk("config HPLL = %d\n", clk);
+	switch (clk) {
+	case 5940:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x400002f7);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb200);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 3712:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000029a);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb2c0);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 2970:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000027b);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb300);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 4320:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x400002b4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		printk("HPLL: 0x%lx\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	default:
+		printk("error hpll clk: %d\n", clk);
+		break;
+	}
+	printk("config HPLL done\n");
+}
+
+static void set_hpll_od1(unsigned div)
+{
+	switch (div) {
+	case 1:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 21, 2);
+		break;
+	case 2:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 1, 21, 2);
+		break;
+	case 4:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 2, 21, 2);
+		break;
+	default:
+		printk("Err %s[%d]\n", __func__, __LINE__);
+		break;
+	}
+}
+
+static void set_hpll_od2(unsigned div)
+{
+	switch (div) {
+	case 1:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 23, 2);
+		break;
+	case 2:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 1, 23, 2);
+		break;
+	case 4:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 2, 23, 2);
+		break;
+	default:
+		printk("Err %s[%d]\n", __func__, __LINE__);
+		break;
+	}
+}
+
+static void set_hpll_od3(unsigned div)
+{
+	switch (div) {
+	case 1:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 19, 2);
+		break;
+	case 2:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 1, 19, 2);
+		break;
+	case 4:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 2, 19, 2);
+		break;
+	default:
+		printk("Err %s[%d]\n", __func__, __LINE__);
+		break;
+	}
+}
+
+// --------------------------------------------------
+//              clocks_set_vid_clk_div
+// --------------------------------------------------
+// wire            clk_final_en    = control[19];
+// wire            clk_div1        = control[18];
+// wire    [1:0]   clk_sel         = control[17:16];
+// wire            set_preset      = control[15];
+// wire    [14:0]  shift_preset    = control[14:0];
+static void set_hpll_od3_clk_div(int div_sel)
+{
+	int shift_val = 0;
+	int shift_sel = 0;
+
+	// Disable the output clock
+	hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+	hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+
+	switch (div_sel) {
+	case CLK_UTIL_VID_PLL_DIV_1:      shift_val = 0xFFFF; shift_sel = 0; break;
+	case CLK_UTIL_VID_PLL_DIV_2:      shift_val = 0x0aaa; shift_sel = 0; break;
+	case CLK_UTIL_VID_PLL_DIV_3:      shift_val = 0x0db6; shift_sel = 0; break;
+	case CLK_UTIL_VID_PLL_DIV_3p5:    shift_val = 0x36cc; shift_sel = 1; break;
+	case CLK_UTIL_VID_PLL_DIV_3p75:   shift_val = 0x6666; shift_sel = 2; break;
+	case CLK_UTIL_VID_PLL_DIV_4:      shift_val = 0x0ccc; shift_sel = 0; break;
+	case CLK_UTIL_VID_PLL_DIV_5:      shift_val = 0x739c; shift_sel = 2; break;
+	case CLK_UTIL_VID_PLL_DIV_6:      shift_val = 0x0e38; shift_sel = 0; break;
+	case CLK_UTIL_VID_PLL_DIV_6p25:   shift_val = 0x0000; shift_sel = 3; break;
+	case CLK_UTIL_VID_PLL_DIV_7:      shift_val = 0x3c78; shift_sel = 1; break;
+	case CLK_UTIL_VID_PLL_DIV_7p5:    shift_val = 0x78f0; shift_sel = 2; break;
+	case CLK_UTIL_VID_PLL_DIV_12:     shift_val = 0x0fc0; shift_sel = 0; break;
+	case CLK_UTIL_VID_PLL_DIV_14:     shift_val = 0x3f80; shift_sel = 1; break;
+	case CLK_UTIL_VID_PLL_DIV_15:     shift_val = 0x7f80; shift_sel = 2; break;
+	case CLK_UTIL_VID_PLL_DIV_2p5:    shift_val = 0x5294; shift_sel = 2; break;
+	default:
+		printk("Error: clocks_set_vid_clk_div:  Invalid parameter\n");
+		break;
+	}
+
+	if (shift_val == 0xffff ) {      // if divide by 1
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+	} else {
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 18, 1);
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 16, 2);
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 0, 14);
+
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 1, 15, 1);
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, shift_val, 0, 14);
+		hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+	}
+	// Enable the final output clock
+	hd_set_reg_bits(P_HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+}
+
+static void set_vid_clk_div(unsigned div)
+{
+	check_clk_config(div);
+	if (div == 0)
+		div = 1;
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL, 0, 16, 3);   // select vid_pll_clk
+	hd_set_reg_bits(P_HHI_VID_CLK_DIV, div-1, 0, 8);
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL, 7, 0, 3);
+}
+
+static void set_hdmi_tx_pixel_div(unsigned div)
+{
+	check_div();
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, div, 16, 4);
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL2, 1, 5, 1);   //enable gate
+}
+
+static void set_encp_div(unsigned div)
+{
+	check_div();
+	hd_set_reg_bits(P_HHI_VID_CLK_DIV, div, 24, 4);
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL2, 1, 2, 1);   //enable gate
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);
+}
+
+static void set_enci_div(unsigned div)
+{
+	check_div();
+	hd_set_reg_bits(P_HHI_VID_CLK_DIV, div, 28, 4);
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL2, 1, 0, 1);   //enable gate
+	hd_set_reg_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);
+}
+
+// mode viu_path viu_type hpll_clk_out od1 od2 od3
+// vid_pll_div vid_clk_div hdmi_tx_pixel_div encp_div enci_div
+static struct hw_enc_clk_val_group setting_enc_clk_val[] = {
+	{{HDMI_720x480i60_16x9, HDMI_720x576i50_16x9, GROUP_END},
+		1, VIU_ENCI, 4320, 4, 4, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, -1, 2},
+	{{HDMI_720x576p50_16x9, HDMI_720x480p60_16x9, GROUP_END},
+		1, VIU_ENCP, 4320, 4, 4, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+	{{HDMI_1280x720p50_16x9, HDMI_1280x720p60_16x9, GROUP_END},
+		1, VIU_ENCP, 2970, 4, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+	{{HDMI_1920x1080i60_16x9, HDMI_1920x1080i50_16x9, GROUP_END},
+		1, VIU_ENCP, 2970, 4, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 1, 2, 1, -1},
+	{{HDMI_1920x1080p60_16x9, HDMI_1920x1080p50_16x9, GROUP_END},
+		1, VIU_ENCP, 2970, 1, 2, 2, CLK_UTIL_VID_PLL_DIV_5, 1, 1, 1, -1},
+	{{HDMI_1920x1080p30_16x9, HDMI_1920x1080p24_16x9, HDMI_1920x1080p25_16x9, GROUP_END},
+		1, VIU_ENCP, 2970, 2, 2, 2, CLK_UTIL_VID_PLL_DIV_5, 1, 1, 1, -1},
+	{{HDMI_3840x2160p30_16x9, HDMI_3840x2160p25_16x9, HDMI_3840x2160p24_16x9,
+		HDMI_4096x2160p24_256x135, HDMI_4096x2160p25_256x135, HDMI_4096x2160p30_256x135, GROUP_END},
+		1, VIU_ENCP, 2970, 1, 1, 1, CLK_UTIL_VID_PLL_DIV_5, 2, 1, 1, -1},
+	{{HDMI_3840x2160p60_16x9, HDMI_3840x2160p50_16x9, HDMI_4096x2160p60_256x135,
+		HDMI_4096x2160p50_256x135, GROUP_END},
+		1, VIU_ENCP, 5940, 1, 1, 2, CLK_UTIL_VID_PLL_DIV_5, 1, 1, 1, -1},
+};
+
+/* mode hpll_clk_out od1 od2(PHY) od3
+ * vid_pll_div vid_clk_div hdmi_tx_pixel_div encp_div enci_div
+ */
+static struct hw_enc_clk_val_group setting_enc_clk_val_30[] = {
+	{{HDMI_1920x1080p60_16x9, HDMI_1920x1080p50_16x9,
+	GROUP_END},
+		1, VIU_ENCP, 3712, 1, 2, 2, CLK_UTIL_VID_PLL_DIV_6p25, 1, 1, 1, -1},
+	{{HDMI_4096x2160p60_256x135, HDMI_4096x2160p50_256x135, HDMI_3840x2160p60_16x9, HDMI_3840x2160p50_16x9,
+	GROUP_END},
+		1, VIU_ENCP, 3712, 1, 1, 1, CLK_UTIL_VID_PLL_DIV_6p25, 1, 2, 1, -1},
+	{{HDMI_3840x2160p24_16x9, HDMI_3840x2160p24_64x27, HDMI_3840x2160p25_16x9, HDMI_3840x2160p25_64x27,
+	HDMI_3840x2160p30_16x9, HDMI_3840x2160p30_64x27,
+	GROUP_END},
+		1, VIU_ENCP, 3712, 1, 1, 1, CLK_UTIL_VID_PLL_DIV_6p25, 1, 2, 2, -1},
+};
+
+void set_hdmitx_clk(enum hdmi_vic vic)
+{
+	int i = 0;
+	int j = 0;
+	struct hw_enc_clk_val_group *p_enc =NULL;
+
+	p_enc = &setting_enc_clk_val[0];
+	for (j = 0; j < ARRAY_SIZE(setting_enc_clk_val); j++) {
+		for (i = 0; ((i < GROUP_MAX) && (p_enc[j].group[i] != GROUP_END)); i ++) {
+			if (vic == p_enc[j].group[i])
+				goto next;
+		}
+	}
+	if (j == ARRAY_SIZE(setting_enc_clk_val)) {
+		printf("Not find VIC = %d for hpll setting\n", vic);
+		return;
+	}
+next:
+	set_viu_path(p_enc[j].viu_path, p_enc[j].viu_type);
+	set_hdmitx_sys_clk();
+	set_hpll_clk_out(p_enc[j].hpll_clk_out);
+	set_hpll_od1(p_enc[j].od1);
+	set_hpll_od2(p_enc[j].od2);
+	set_hpll_od3(p_enc[j].od3);
+	set_hpll_od3_clk_div(p_enc[j].vid_pll_div);
+	printk("j = %d  vid_clk_div = %d\n", j, p_enc[j].vid_clk_div);
+	set_vid_clk_div(p_enc[j].vid_clk_div);
+	set_hdmi_tx_pixel_div(p_enc[j].hdmi_tx_pixel_div);
+	set_encp_div(p_enc[j].encp_div);
+	set_enci_div(p_enc[j].enci_div);
+}
+
+void hdmitx_set_clk_30b(enum hdmi_vic vic)
+{
+	int i = 0;
+	int j = 0;
+	struct hw_enc_clk_val_group *p_enc = NULL;
+
+	p_enc = &setting_enc_clk_val_30[0];
+	for (j = 0; j < sizeof(setting_enc_clk_val_30)
+		/ sizeof(struct hw_enc_clk_val_group); j++) {
+		for (i = 0; ((i < GROUP_MAX) && (p_enc[j].group[i]
+			!= GROUP_END)); i++) {
+			if (vic == p_enc[j].group[i])
+				goto next;
+		}
+	}
+	if (j == sizeof(setting_enc_clk_val_30) /
+		sizeof(struct hw_enc_clk_val_group)) {
+		printk("Not find VIC = %d for hpll setting\n", vic);
+		return;
+	}
+next:
+	set_hdmitx_sys_clk();
+	set_hpll_clk_out(p_enc[j].hpll_clk_out);
+	set_hpll_od1(p_enc[j].od1);
+	set_hpll_od2(p_enc[j].od2);
+	set_hpll_od3(p_enc[j].od3);
+	set_hpll_od3_clk_div(p_enc[j].vid_pll_div);
+	set_vid_clk_div(p_enc[j].vid_clk_div);
+	set_hdmi_tx_pixel_div(p_enc[j].hdmi_tx_pixel_div);
+	set_encp_div(p_enc[j].encp_div);
+	set_enci_div(p_enc[j].enci_div);
+}
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_hdcp.c b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_hdcp.c
new file mode 100644
index 0000000..c64c121
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_hdcp.c
@@ -0,0 +1,85 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_hdcp.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/io.h>
+#include <common.h>
+#include "hdmi_tx_reg.h"
+
+// if the following bits are 0, then access HDMI IP Port will cause system hungup
+#define GATE_NUM    2
+
+static struct Hdmi_Gate_s{
+    unsigned short cbus_addr;
+    unsigned char gate_bit;
+}hdmi_gate[GATE_NUM] =   {   {HHI_HDMI_CLK_CNTL, 8},
+                            {HHI_GCLK_MPEG2   , 4},
+                            };
+
+// In order to prevent system hangup, add check_cts_hdmi_sys_clk_status() to check
+static void check_cts_hdmi_sys_clk_status(void)
+{
+    int i;
+
+    for (i = 0; i < GATE_NUM; i++) {
+        if (!(READ_CBUS_REG(hdmi_gate[i].cbus_addr) & (1<<hdmi_gate[i].gate_bit))) {
+//            printf("HDMI Gate Clock is off, turn on now\n");
+            WRITE_CBUS_REG_BITS(hdmi_gate[i].cbus_addr, 1, hdmi_gate[i].gate_bit, 1);
+        }
+    }
+}
+
+unsigned long hdmi_hdcp_rd_reg(unsigned long addr)
+{
+    unsigned long data;
+    check_cts_hdmi_sys_clk_status();
+    WRITE_APB_REG(HDMI_ADDR_PORT, addr);
+    WRITE_APB_REG(HDMI_ADDR_PORT, addr);
+
+    data = READ_APB_REG(HDMI_DATA_PORT);
+
+    return (data);
+}
+
+void hdmi_hdcp_wr_reg(unsigned long addr, unsigned long data)
+{
+    check_cts_hdmi_sys_clk_status();
+    WRITE_APB_REG(HDMI_ADDR_PORT, addr);
+    WRITE_APB_REG(HDMI_ADDR_PORT, addr);
+
+    WRITE_APB_REG(HDMI_DATA_PORT, data);
+}
+
+#define TX_HDCP_KSV_OFFSET          0x540
+#define TX_HDCP_KSV_SIZE            5
+// Must be done by system init
+// In kenrel hdmi driver, it will get AKSV value
+// If equals to 0, then kernel won't enable HDCP
+extern int hdmi_hdcp_clear_ksv_ram(void);
+int hdmi_hdcp_clear_ksv_ram(void)
+{
+    int i;
+    for (i = 0; i < TX_HDCP_KSV_SIZE; i++) {
+        hdmi_hdcp_wr_reg(TX_HDCP_KSV_OFFSET + i, 0x00);
+    }
+    printf("clr h-ram\n");
+    return 0;
+}
+
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_reg.h b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_reg.h
new file mode 100644
index 0000000..42af9d2
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_reg.h
@@ -0,0 +1,1012 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _HDMI_TX_REG_H
+#define _HDMI_TX_REG_H
+
+/* Use the following functions to access the on-chip HDMITX modules
+ * by default
+ */
+void hdmitx_wr_reg(unsigned int addr, unsigned int data);
+void hdmitx_poll_reg(unsigned int addr, unsigned int val,
+	unsigned long timeout);
+void hdmitx_set_reg_bits(unsigned int addr, unsigned int value,
+	unsigned int offset, unsigned int len);
+unsigned int hdmitx_rd_reg(unsigned int addr);
+void hdmitx_rd_check_reg (unsigned long addr, unsigned long exp_data,
+	unsigned long mask);
+unsigned long aocec_rd_reg(unsigned long addr);
+void aocec_wr_reg(unsigned long addr, unsigned long data);
+
+/* TOP-level wrapper registers addresses */
+/* bit24: 1 means secure access */
+/* bit28: 1 means DWC, 0 means TOP */
+#define SEC_OFFSET           (0x1UL << 24)
+#define TOP_OFFSET_MASK      (0x0UL << 24)
+#define TOP_SEC_OFFSET_MASK  ((TOP_OFFSET_MASK) | (SEC_OFFSET))
+#define DWC_OFFSET_MASK      (0x10UL << 24)
+#define DWC_SEC_OFFSET_MASK  ((DWC_OFFSET_MASK) | (SEC_OFFSET))
+
+/* Bit 7 RW Reserved. Default 1. */
+/* Bit 6 RW Reserved. Default 1. */
+/* Bit 5 RW Reserved. Default 1. */
+/* Bit 4 RW sw_reset_phyif: PHY interface. 1=Apply reset; 0=Release from reset.
+ *     Default 1. */
+/* Bit 3 RW sw_reset_intr:  interrupt module. 1=Apply reset;
+ *     0=Release from reset. Default 1. */
+/* Bit 2 RW sw_reset_mem:   KSV/REVOC mem. 1=Apply reset; 0=Release from reset.
+ *     Default 1. */
+/* Bit 1 RW sw_reset_rnd:   random number interface to HDCP. 1=Apply reset;
+ *     0=Release from reset. Default 1. */
+/* Bit 0 RW sw_reset_core: connects to IP's ~irstz. 1=Apply reset;
+ *     0=Release from reset. Default 1. */
+#define HDMITX_TOP_SW_RESET                     (TOP_OFFSET_MASK + 0x000)
+
+/* Bit 12 RW i2s_ws_inv:1=Invert i2s_ws; 0=No invert. Default 0. */
+/* Bit 11 RW i2s_clk_inv: 1=Invert i2s_clk; 0=No invert. Default 0. */
+/* Bit 10 RW spdif_clk_inv: 1=Invert spdif_clk; 0=No invert. Default 0. */
+/* Bit 9 RW tmds_clk_inv: 1=Invert tmds_clk; 0=No invert. Default 0. */
+/* Bit 8 RW pixel_clk_inv: 1=Invert pixel_clk; 0=No invert. Default 0. */
+/* Bit 4 RW cec_clk_en: 1=enable cec_clk; 0=disable. Default 0. */
+/* Bit 3 RW i2s_clk_en: 1=enable i2s_clk; 0=disable. Default 0. */
+/* Bit 2 RW spdif_clk_en: 1=enable spdif_clk; 0=disable. Default 0. */
+/* Bit 1 RW tmds_clk_en: 1=enable tmds_clk;  0=disable. Default 0. */
+/* Bit 0 RW pixel_clk_en: 1=enable pixel_clk; 0=disable. Default 0. */
+#define HDMITX_TOP_CLK_CNTL                     (TOP_OFFSET_MASK + 0x001)
+
+/* Bit 11: 0 RW hpd_valid_width: filter out width <= M*1024.    Default 0. */
+/* Bit 15:12 RW hpd_glitch_width: filter out glitch <= N.       Default 0. */
+#define HDMITX_TOP_HPD_FILTER                   (TOP_OFFSET_MASK + 0x002)
+
+/* intr_maskn: MASK_N, one bit per interrupt source.
+ *     1=Enable interrupt source; 0=Disable interrupt source. Default 0.
+ * [  4] hdcp22_rndnum_err
+ * [  3] nonce_rfrsh_rise
+ * [  2] hpd_fall_intr
+ * [  1] hpd_rise_intr
+ * [  0] core_intr
+ */
+#define HDMITX_TOP_INTR_MASKN                   (TOP_OFFSET_MASK + 0x003)
+
+/* Bit 30: 0 RW intr_stat: For each bit, write 1 to manually set the interrupt
+ *     bit, read back the interrupt status. */
+/* Bit    31 R  IP interrupt status */
+/* Bit     2 RW hpd_fall */
+/* Bit     1 RW hpd_rise */
+/* Bit     0 RW IP interrupt */
+#define HDMITX_TOP_INTR_STAT                    (TOP_OFFSET_MASK + 0x004)
+
+/* [4]	  hdcp22_rndnum_err */
+/* [3]	  nonce_rfrsh_rise */
+/* [2]	  hpd_fall */
+/* [1]	  hpd_rise */
+/* [0]	  core_intr_rise */
+#define HDMITX_TOP_INTR_STAT_CLR                (TOP_OFFSET_MASK + 0x005)
+
+/* Bit 14:12 RW tmds_sel: 3'b000=Output zero; 3'b001=Output normal TMDS data;
+ *     3'b010=Output PRBS data; 3'b100=Output shift pattern.         Default 0.
+ * Bit 11: 9 RW shift_pttn_repeat: 0=New pattern every clk cycle; 1=New pattern
+ *     every 2 clk cycles; ...; 7=New pattern every 8 clk cycles.  Default 0.
+ * Bit 8 RW shift_pttn_en: 1= Eanble shift pattern generator; 0=Disable.
+ *     Default 0.
+ * Bit 4: 3 RW prbs_pttn_mode: 0=PRBS11; 1=PRBS15; 2=PRBS7; 3=PRBS31. Default 0.
+ * Bit 2: 1 RW prbs_pttn_width: 0=idle; 1=output 8-bit pattern;
+ *     2=Output 1-bit pattern; 3=output 10-bit pattern. Default 0.
+ * Bit 0 RW prbs_pttn_en: 1=Enable PRBS generator; 0=Disable. Default 0.
+ */
+#define HDMITX_TOP_BIST_CNTL                    (TOP_OFFSET_MASK + 0x006)
+
+/* Bit 29:20 RW shift_pttn_data[59:50]. Default 0. */
+/* Bit 19:10 RW shift_pttn_data[69:60]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[79:70]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_012               (TOP_OFFSET_MASK + 0x007)
+
+/* Bit 29:20 RW shift_pttn_data[29:20]. Default 0. */
+/* Bit 19:10 RW shift_pttn_data[39:30]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[49:40]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_345               (TOP_OFFSET_MASK + 0x008)
+
+/* Bit 19:10 RW shift_pttn_data[ 9: 0]. Default 0. */
+/* Bit  9: 0 RW shift_pttn_data[19:10]. Default 0. */
+#define HDMITX_TOP_SHIFT_PTTN_67                (TOP_OFFSET_MASK + 0x009)
+
+/* Bit 25:16 RW tmds_clk_pttn[19:10]. Default 0. */
+/* Bit  9: 0 RW tmds_clk_pttn[ 9: 0]. Default 0. */
+#define HDMITX_TOP_TMDS_CLK_PTTN_01             (TOP_OFFSET_MASK + 0x00A)
+
+/* Bit 25:16 RW tmds_clk_pttn[39:30]. Default 0. */
+/* Bit  9: 0 RW tmds_clk_pttn[29:20]. Default 0. */
+#define HDMITX_TOP_TMDS_CLK_PTTN_23             (TOP_OFFSET_MASK + 0x00B)
+
+/* Bit 1 RW shift_tmds_clk_pttn:1=Enable shifting clk pattern,
+ * used when TMDS CLK rate = TMDS character rate /4.    Default 0.
+ * Bit 0 R  Reserved. Default 0.
+ */
+/* [	1] shift_tmds_clk_pttn */
+/* [	0] load_tmds_clk_pttn */
+#define HDMITX_TOP_TMDS_CLK_PTTN_CNTL           (TOP_OFFSET_MASK + 0x00C)
+
+/* Bit 0 RW revocmem_wr_fail: Read back 1 to indicate Host write REVOC MEM
+ * failure, write 1 to clear the failure flag.  Default 0.
+ */
+#define HDMITX_TOP_REVOCMEM_STAT                (TOP_OFFSET_MASK + 0x00D)
+
+/* Bit     0 R  filtered HPD status. */
+#define HDMITX_TOP_STAT0                        (TOP_OFFSET_MASK + 0x00E)
+#define HDMITX_TOP_SKP_CNTL_STAT                (TOP_SEC_OFFSET_MASK + 0x010)
+#define HDMITX_TOP_NONCE_0                      (TOP_SEC_OFFSET_MASK + 0x011)
+#define HDMITX_TOP_NONCE_1                      (TOP_SEC_OFFSET_MASK + 0x012)
+#define HDMITX_TOP_NONCE_2                      (TOP_SEC_OFFSET_MASK + 0x013)
+#define HDMITX_TOP_NONCE_3                      (TOP_SEC_OFFSET_MASK + 0x014)
+#define HDMITX_TOP_PKF_0                        (TOP_SEC_OFFSET_MASK + 0x015)
+#define HDMITX_TOP_PKF_1                        (TOP_SEC_OFFSET_MASK + 0x016)
+#define HDMITX_TOP_PKF_2                        (TOP_SEC_OFFSET_MASK + 0x017)
+#define HDMITX_TOP_PKF_3                        (TOP_SEC_OFFSET_MASK + 0x018)
+#define HDMITX_TOP_DUK_0                        (TOP_SEC_OFFSET_MASK + 0x019)
+#define HDMITX_TOP_DUK_1                        (TOP_SEC_OFFSET_MASK + 0x01A)
+#define HDMITX_TOP_DUK_2                        (TOP_SEC_OFFSET_MASK + 0x01B)
+#define HDMITX_TOP_DUK_3                        (TOP_SEC_OFFSET_MASK + 0x01C)
+/* [26:24] infilter_ddc_intern_clk_divide */
+/* [23:16] infilter_ddc_sample_clk_divide */
+/* [10: 8] infilter_cec_intern_clk_divide */
+/* [ 7: 0] infilter_cec_sample_clk_divide */
+#define HDMITX_TOP_INFILTER                     (TOP_OFFSET_MASK + 0x01D)
+#define HDMITX_TOP_NSEC_SCRATCH                 (TOP_OFFSET_MASK + 0x01E)
+#define HDMITX_TOP_SEC_SCRATCH                  (TOP_SEC_OFFSET_MASK + 0x01F)
+
+#define HDMITX_TOP_DONT_TOUCH0                  (TOP_OFFSET_MASK + 0x0FE)
+#define HDMITX_TOP_DONT_TOUCH1                  (TOP_OFFSET_MASK + 0x0FF)
+
+/* DWC_HDMI_TX Controller registers addresses */
+
+/* Identification Registers */
+#define HDMITX_DWC_DESIGN_ID                    (DWC_OFFSET_MASK + 0x0000)
+#define HDMITX_DWC_REVISION_ID                  (DWC_OFFSET_MASK + 0x0001)
+#define HDMITX_DWC_PRODUCT_ID0                  (DWC_OFFSET_MASK + 0x0002)
+#define HDMITX_DWC_PRODUCT_ID1                  (DWC_OFFSET_MASK + 0x0003)
+#define HDMITX_DWC_CONFIG0_ID                   (DWC_OFFSET_MASK + 0x0004)
+#define HDMITX_DWC_CONFIG1_ID                   (DWC_OFFSET_MASK + 0x0005)
+#define HDMITX_DWC_CONFIG2_ID                   (DWC_OFFSET_MASK + 0x0006)
+#define HDMITX_DWC_CONFIG3_ID                   (DWC_OFFSET_MASK + 0x0007)
+
+/* Interrupt Registers */
+#define HDMITX_DWC_IH_FC_STAT0                  (DWC_OFFSET_MASK + 0x0100)
+#define HDMITX_DWC_IH_FC_STAT1                  (DWC_OFFSET_MASK + 0x0101)
+#define HDMITX_DWC_IH_FC_STAT2                  (DWC_OFFSET_MASK + 0x0102)
+#define HDMITX_DWC_IH_AS_STAT0                  (DWC_OFFSET_MASK + 0x0103)
+#define HDMITX_DWC_IH_PHY_STAT0                 (DWC_OFFSET_MASK + 0x0104)
+#define HDMITX_DWC_IH_I2CM_STAT0                (DWC_OFFSET_MASK + 0x0105)
+#define HDMITX_DWC_IH_CEC_STAT0                 (DWC_OFFSET_MASK + 0x0106)
+#define HDMITX_DWC_IH_VP_STAT0                  (DWC_OFFSET_MASK + 0x0107)
+#define HDMITX_DWC_IH_I2CMPHY_STAT0             (DWC_OFFSET_MASK + 0x0108)
+#define HDMITX_DWC_IH_DECODE                    (DWC_OFFSET_MASK + 0x0170)
+/* [  7] mute_AUDI */
+/* [  6] mute_ACP */
+/* [  5] mute_HBR */
+/* [  4] mute_MAS */
+/* [  3] mute_NVBI */
+/* [  2] mute_AUDS */
+/* [  1] mute_ACR */
+/* [  0] mute_NULL */
+#define HDMITX_DWC_IH_MUTE_FC_STAT0             (DWC_OFFSET_MASK + 0x0180)
+/* [  7] mute_GMD */
+/* [  6] mute_ISRC1 */
+/* [  5] mute_ISRC2 */
+/* [  4] mute_VSD */
+/* [  3] mute_SPD */
+/* [  2] mute_AMP */
+/* [  1] mute_AVI */
+/* [  0] mute_GCP */
+#define HDMITX_DWC_IH_MUTE_FC_STAT1             (DWC_OFFSET_MASK + 0x0181)
+/* [  1] mute_LowPriority_fifo_full */
+/* [  0] mute_HighPriority_fifo_full */
+#define HDMITX_DWC_IH_MUTE_FC_STAT2             (DWC_OFFSET_MASK + 0x0182)
+/* [  4] mute_aud_fifo_underrun */
+/* [  3] mute_aud_fifo_overrun */
+/* [  2] mute_aud_fifo_empty_thr. oififoemptythr tied to 0. */
+/* [  1] mute_aud_fifo_empty */
+/* [  0] mute_aud_fifo_full */
+#define HDMITX_DWC_IH_MUTE_AS_STAT0             (DWC_OFFSET_MASK + 0x0183)
+#define HDMITX_DWC_IH_MUTE_PHY_STAT0            (DWC_OFFSET_MASK + 0x0184)
+/* [  2] mute_scdc_readreq */
+/* [  1] mute_edid_i2c_master_done */
+/* [  0] mute_edid_i2c_master_error */
+#define HDMITX_DWC_IH_MUTE_I2CM_STAT0           (DWC_OFFSET_MASK + 0x0185)
+/* [  6] cec_wakeup */
+/* [  5] cec_error_follower */
+/* [  4] cec_error_initiator */
+/* [  3] cec_arb_lost */
+/* [  2] cec_nack */
+/* [  1] cec_eom */
+/* [  0] cec_done */
+#define HDMITX_DWC_IH_MUTE_CEC_STAT0            (DWC_OFFSET_MASK + 0x0186)
+#define HDMITX_DWC_IH_MUTE_VP_STAT0             (DWC_OFFSET_MASK + 0x0187)
+#define HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0        (DWC_OFFSET_MASK + 0x0188)
+/* [  1] mute_wakeup_interrupt */
+/* [  0] mute_all_interrupt */
+#define HDMITX_DWC_IH_MUTE                      (DWC_OFFSET_MASK + 0x01FF)
+
+/* Video Sampler Registers */
+/* [  7] internal_de_generator */
+/* [4:0] video_mapping */
+#define HDMITX_DWC_TX_INVID0                    (DWC_OFFSET_MASK + 0x0200)
+/* [  2] bcbdata_stuffing */
+/* [  1] rcrdata_stuffing */
+/* [  0] gydata_stuffing */
+#define HDMITX_DWC_TX_INSTUFFING                (DWC_OFFSET_MASK + 0x0201)
+#define HDMITX_DWC_TX_GYDATA0                   (DWC_OFFSET_MASK + 0x0202)
+#define HDMITX_DWC_TX_GYDATA1                   (DWC_OFFSET_MASK + 0x0203)
+#define HDMITX_DWC_TX_RCRDATA0                  (DWC_OFFSET_MASK + 0x0204)
+#define HDMITX_DWC_TX_RCRDATA1                  (DWC_OFFSET_MASK + 0x0205)
+#define HDMITX_DWC_TX_BCBDATA0                  (DWC_OFFSET_MASK + 0x0206)
+#define HDMITX_DWC_TX_BCBDATA1                  (DWC_OFFSET_MASK + 0x0207)
+
+/* Video Packetizer Registers */
+#define HDMITX_DWC_VP_STATUS                    (DWC_OFFSET_MASK + 0x0800)
+/* [3:0] desired_pr_factor */
+#define HDMITX_DWC_VP_PR_CD                     (DWC_OFFSET_MASK + 0x0801)
+/* [  5] default_phase */
+/* [  2] ycc422_stuffing */
+/* [  1] pp_stuffing */
+/* [  0] pr_stuffing */
+#define HDMITX_DWC_VP_STUFF                     (DWC_OFFSET_MASK + 0x0802)
+#define HDMITX_DWC_VP_REMAP                     (DWC_OFFSET_MASK + 0x0803)
+#define HDMITX_DWC_VP_CONF                      (DWC_OFFSET_MASK + 0x0804)
+/* [  7] mask_int_full_prpt */
+/* [  6] mask_int_empty_prpt */
+/* [  5] mask_int_full_ppack */
+/* [  4] mask_int_empty_ppack */
+/* [  3] mask_int_full_remap */
+/* [  2] mask_int_empty_remap */
+/* [  1] mask_int_full_byp */
+/* [  0] mask_int_empty_byp */
+#define HDMITX_DWC_VP_MASK                      (DWC_OFFSET_MASK + 0x0807)
+
+/* Frmae Composer Registers */
+/* [  7] HDCP_keepout */
+/* [  6] vs_in_pol: 0=active low; 1=active high. */
+/* [  5] hs_in_pol: 0=active low; 1=active high. */
+/* [  4] de_in_pol: 0=active low; 1=active high. */
+/* [  3] dvi_modez: 0=dvi; 1=hdmi. */
+/* [  1] r_v_blank_in_osc */
+/* [  0] in_I_P: 0=progressive; 1=interlaced. */
+#define HDMITX_DWC_FC_INVIDCONF                 (DWC_OFFSET_MASK + 0x1000)
+/* [7:0] H_in_active[7:0] */
+#define HDMITX_DWC_FC_INHACTV0                  (DWC_OFFSET_MASK + 0x1001)
+/* [5:0] H_in_active[13:8] */
+#define HDMITX_DWC_FC_INHACTV1                  (DWC_OFFSET_MASK + 0x1002)
+/* [7:0] H_in_blank[7:0] */
+#define HDMITX_DWC_FC_INHBLANK0                 (DWC_OFFSET_MASK + 0x1003)
+/* [4:0] H_in_blank[12:8] */
+#define HDMITX_DWC_FC_INHBLANK1                 (DWC_OFFSET_MASK + 0x1004)
+/* [7:0] V_in_active[7:0] */
+#define HDMITX_DWC_FC_INVACTV0                  (DWC_OFFSET_MASK + 0x1005)
+/* [4:0] V_in_active[12:8] */
+#define HDMITX_DWC_FC_INVACTV1                  (DWC_OFFSET_MASK + 0x1006)
+/* [7:0] V_in_blank */
+#define HDMITX_DWC_FC_INVBLANK                  (DWC_OFFSET_MASK + 0x1007)
+/* [7:0] H_in_delay[7:0] */
+#define HDMITX_DWC_FC_HSYNCINDELAY0             (DWC_OFFSET_MASK + 0x1008)
+/* [4:0] H_in_delay[12:8] */
+#define HDMITX_DWC_FC_HSYNCINDELAY1             (DWC_OFFSET_MASK + 0x1009)
+/* [7:0] H_in_width[7:0] */
+#define HDMITX_DWC_FC_HSYNCINWIDTH0             (DWC_OFFSET_MASK + 0x100A)
+/* [1:0] H_in_width[9:8] */
+#define HDMITX_DWC_FC_HSYNCINWIDTH1             (DWC_OFFSET_MASK + 0x100B)
+/* [7:0] V_in_delay */
+#define HDMITX_DWC_FC_VSYNCINDELAY              (DWC_OFFSET_MASK + 0x100C)
+/* [5:0] V_in_width */
+#define HDMITX_DWC_FC_VSYNCINWIDTH              (DWC_OFFSET_MASK + 0x100D)
+#define HDMITX_DWC_FC_INFREQ0                   (DWC_OFFSET_MASK + 0x100E)
+#define HDMITX_DWC_FC_INFREQ1                   (DWC_OFFSET_MASK + 0x100F)
+#define HDMITX_DWC_FC_INFREQ2                   (DWC_OFFSET_MASK + 0x1010)
+#define HDMITX_DWC_FC_CTRLDUR                   (DWC_OFFSET_MASK + 0x1011)
+#define HDMITX_DWC_FC_EXCTRLDUR                 (DWC_OFFSET_MASK + 0x1012)
+#define HDMITX_DWC_FC_EXCTRLSPAC                (DWC_OFFSET_MASK + 0x1013)
+#define HDMITX_DWC_FC_CH0PREAM                  (DWC_OFFSET_MASK + 0x1014)
+#define HDMITX_DWC_FC_CH1PREAM                  (DWC_OFFSET_MASK + 0x1015)
+#define HDMITX_DWC_FC_CH2PREAM                  (DWC_OFFSET_MASK + 0x1016)
+/* [3:2] YQ */
+/* [1:0] CN */
+#define HDMITX_DWC_FC_AVICONF3                  (DWC_OFFSET_MASK + 0x1017)
+/* [  2] default_phase */
+/* [  1] set_avmute */
+/* [  0] clear_avmute */
+#define HDMITX_DWC_FC_GCP                       (DWC_OFFSET_MASK + 0x1018)
+/* [  7] rgb_ycc_indication[2] */
+/* [  6] active_format_present */
+/* [5:4] scan_information */
+/* [3:2] bar_information */
+/* [1:0] rgb_ycc_indication[1:0] */
+#define HDMITX_DWC_FC_AVICONF0                  (DWC_OFFSET_MASK + 0x1019)
+/* [7:6] colorimetry */
+/* [5:4] picture_aspect_ratio */
+/* [3:0] active_aspect_ratio */
+#define HDMITX_DWC_FC_AVICONF1                  (DWC_OFFSET_MASK + 0x101A)
+/* [  7] IT_content */
+/* [6:4] extended_colorimetry */
+/* [3:2] quantization_range */
+/* [1:0] non_uniform_picture_scaling */
+#define HDMITX_DWC_FC_AVICONF2                  (DWC_OFFSET_MASK + 0x101B)
+#define HDMITX_DWC_FC_AVIVID                    (DWC_OFFSET_MASK + 0x101C)
+#define HDMITX_DWC_FC_AVIETB0                   (DWC_OFFSET_MASK + 0x101D)
+#define HDMITX_DWC_FC_AVIETB1                   (DWC_OFFSET_MASK + 0x101E)
+#define HDMITX_DWC_FC_AVISBB0                   (DWC_OFFSET_MASK + 0x101F)
+#define HDMITX_DWC_FC_AVISBB1                   (DWC_OFFSET_MASK + 0x1020)
+#define HDMITX_DWC_FC_AVIELB0                   (DWC_OFFSET_MASK + 0x1021)
+#define HDMITX_DWC_FC_AVIELB1                   (DWC_OFFSET_MASK + 0x1022)
+#define HDMITX_DWC_FC_AVISRB0                   (DWC_OFFSET_MASK + 0x1023)
+#define HDMITX_DWC_FC_AVISRB1                   (DWC_OFFSET_MASK + 0x1024)
+/* [3:0] CT: coding type */
+#define HDMITX_DWC_FC_AUDICONF0                 (DWC_OFFSET_MASK + 0x1025)
+/* [5:4] SS: sampling size */
+/* [2:0] SF: sampling frequency */
+#define HDMITX_DWC_FC_AUDICONF1                 (DWC_OFFSET_MASK + 0x1026)
+/* CA: channel allocation */
+#define HDMITX_DWC_FC_AUDICONF2                 (DWC_OFFSET_MASK + 0x1027)
+/* [6:5] LFEPBL: LFE playback info */
+/* [  4] DM_INH: down mix enable */
+/* [3:0] LSv: Level shift value */
+#define HDMITX_DWC_FC_AUDICONF3                 (DWC_OFFSET_MASK + 0x1028)
+#define HDMITX_DWC_FC_VSDIEEEID0                (DWC_OFFSET_MASK + 0x1029)
+#define HDMITX_DWC_FC_VSDSIZE                   (DWC_OFFSET_MASK + 0x102A)
+#define HDMITX_DWC_FC_VSDIEEEID1                (DWC_OFFSET_MASK + 0x1030)
+#define HDMITX_DWC_FC_VSDIEEEID2                (DWC_OFFSET_MASK + 0x1031)
+#define HDMITX_DWC_FC_VSDPAYLOAD0               (DWC_OFFSET_MASK + 0x1032)
+#define HDMITX_DWC_FC_VSDPAYLOAD1               (DWC_OFFSET_MASK + 0x1033)
+#define HDMITX_DWC_FC_VSDPAYLOAD2               (DWC_OFFSET_MASK + 0x1034)
+#define HDMITX_DWC_FC_VSDPAYLOAD3               (DWC_OFFSET_MASK + 0x1035)
+#define HDMITX_DWC_FC_VSDPAYLOAD4               (DWC_OFFSET_MASK + 0x1036)
+#define HDMITX_DWC_FC_VSDPAYLOAD5               (DWC_OFFSET_MASK + 0x1037)
+#define HDMITX_DWC_FC_VSDPAYLOAD6               (DWC_OFFSET_MASK + 0x1038)
+#define HDMITX_DWC_FC_VSDPAYLOAD7               (DWC_OFFSET_MASK + 0x1039)
+#define HDMITX_DWC_FC_VSDPAYLOAD8               (DWC_OFFSET_MASK + 0x103A)
+#define HDMITX_DWC_FC_VSDPAYLOAD9               (DWC_OFFSET_MASK + 0x103B)
+#define HDMITX_DWC_FC_VSDPAYLOAD10              (DWC_OFFSET_MASK + 0x103C)
+#define HDMITX_DWC_FC_VSDPAYLOAD11              (DWC_OFFSET_MASK + 0x103D)
+#define HDMITX_DWC_FC_VSDPAYLOAD12              (DWC_OFFSET_MASK + 0x103E)
+#define HDMITX_DWC_FC_VSDPAYLOAD13              (DWC_OFFSET_MASK + 0x103F)
+#define HDMITX_DWC_FC_VSDPAYLOAD14              (DWC_OFFSET_MASK + 0x1040)
+#define HDMITX_DWC_FC_VSDPAYLOAD15              (DWC_OFFSET_MASK + 0x1041)
+#define HDMITX_DWC_FC_VSDPAYLOAD16              (DWC_OFFSET_MASK + 0x1042)
+#define HDMITX_DWC_FC_VSDPAYLOAD17              (DWC_OFFSET_MASK + 0x1043)
+#define HDMITX_DWC_FC_VSDPAYLOAD18              (DWC_OFFSET_MASK + 0x1044)
+#define HDMITX_DWC_FC_VSDPAYLOAD19              (DWC_OFFSET_MASK + 0x1045)
+#define HDMITX_DWC_FC_VSDPAYLOAD20              (DWC_OFFSET_MASK + 0x1046)
+#define HDMITX_DWC_FC_VSDPAYLOAD21              (DWC_OFFSET_MASK + 0x1047)
+#define HDMITX_DWC_FC_VSDPAYLOAD22              (DWC_OFFSET_MASK + 0x1048)
+#define HDMITX_DWC_FC_VSDPAYLOAD23              (DWC_OFFSET_MASK + 0x1049)
+#define HDMITX_DWC_FC_SPDVENDORNAME0            (DWC_OFFSET_MASK + 0x104A)
+#define HDMITX_DWC_FC_SPDVENDORNAME1            (DWC_OFFSET_MASK + 0x104B)
+#define HDMITX_DWC_FC_SPDVENDORNAME2            (DWC_OFFSET_MASK + 0x104C)
+#define HDMITX_DWC_FC_SPDVENDORNAME3            (DWC_OFFSET_MASK + 0x104D)
+#define HDMITX_DWC_FC_SPDVENDORNAME4            (DWC_OFFSET_MASK + 0x104E)
+#define HDMITX_DWC_FC_SPDVENDORNAME5            (DWC_OFFSET_MASK + 0x104F)
+#define HDMITX_DWC_FC_SPDVENDORNAME6            (DWC_OFFSET_MASK + 0x1050)
+#define HDMITX_DWC_FC_SPDVENDORNAME7            (DWC_OFFSET_MASK + 0x1051)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME0           (DWC_OFFSET_MASK + 0x1052)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME1           (DWC_OFFSET_MASK + 0x1053)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME2           (DWC_OFFSET_MASK + 0x1054)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME3           (DWC_OFFSET_MASK + 0x1055)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME4           (DWC_OFFSET_MASK + 0x1056)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME5           (DWC_OFFSET_MASK + 0x1057)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME6           (DWC_OFFSET_MASK + 0x1058)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME7           (DWC_OFFSET_MASK + 0x1059)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME8           (DWC_OFFSET_MASK + 0x105A)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME9           (DWC_OFFSET_MASK + 0x105B)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME10          (DWC_OFFSET_MASK + 0x105C)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME11          (DWC_OFFSET_MASK + 0x105D)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME12          (DWC_OFFSET_MASK + 0x105E)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME13          (DWC_OFFSET_MASK + 0x105F)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME14          (DWC_OFFSET_MASK + 0x1060)
+#define HDMITX_DWC_FC_SPDPRODUCTNAME15          (DWC_OFFSET_MASK + 0x1061)
+#define HDMITX_DWC_FC_SPDDEVICEINF              (DWC_OFFSET_MASK + 0x1062)
+/* [7:4] aud_packet_sampflat */
+/* [  0] aud_packet_layout */
+#define HDMITX_DWC_FC_AUDSCONF                  (DWC_OFFSET_MASK + 0x1063)
+#define HDMITX_DWC_FC_AUDSSTAT                  (DWC_OFFSET_MASK + 0x1064)
+/* [  7] V3r */
+/* [  6] V2r */
+/* [  5] V1r */
+/* [  4] V0r */
+/* [  3] V3l */
+/* [  2] V2l */
+/* [  1] V1l */
+/* [  0] V0l */
+#define HDMITX_DWC_FC_AUDSV                     (DWC_OFFSET_MASK + 0x1065)
+#define HDMITX_DWC_FC_AUDSU                     (DWC_OFFSET_MASK + 0x1066)
+#define HDMITX_DWC_FC_AUDSCHNLS0                (DWC_OFFSET_MASK + 0x1067)
+#define HDMITX_DWC_FC_AUDSCHNLS1                (DWC_OFFSET_MASK + 0x1068)
+#define HDMITX_DWC_FC_AUDSCHNLS2                (DWC_OFFSET_MASK + 0x1069)
+#define HDMITX_DWC_FC_AUDSCHNLS3                (DWC_OFFSET_MASK + 0x106A)
+#define HDMITX_DWC_FC_AUDSCHNLS4                (DWC_OFFSET_MASK + 0x106B)
+#define HDMITX_DWC_FC_AUDSCHNLS5                (DWC_OFFSET_MASK + 0x106C)
+#define HDMITX_DWC_FC_AUDSCHNLS6                (DWC_OFFSET_MASK + 0x106D)
+#define HDMITX_DWC_FC_AUDSCHNLS7                (DWC_OFFSET_MASK + 0x106E)
+#define HDMITX_DWC_FC_AUDSCHNLS8                (DWC_OFFSET_MASK + 0x106F)
+#define HDMITX_DWC_FC_DATACH0FILL               (DWC_OFFSET_MASK + 0x1070)
+#define HDMITX_DWC_FC_DATACH1FILL               (DWC_OFFSET_MASK + 0x1071)
+#define HDMITX_DWC_FC_DATACH2FILL               (DWC_OFFSET_MASK + 0x1072)
+#define HDMITX_DWC_FC_CTRLQHIGH                 (DWC_OFFSET_MASK + 0x1073)
+#define HDMITX_DWC_FC_CTRLQLOW                  (DWC_OFFSET_MASK + 0x1074)
+#define HDMITX_DWC_FC_ACP0                      (DWC_OFFSET_MASK + 0x1075)
+#define HDMITX_DWC_FC_ACP16                     (DWC_OFFSET_MASK + 0x1082)
+#define HDMITX_DWC_FC_ACP15                     (DWC_OFFSET_MASK + 0x1083)
+#define HDMITX_DWC_FC_ACP14                     (DWC_OFFSET_MASK + 0x1084)
+#define HDMITX_DWC_FC_ACP13                     (DWC_OFFSET_MASK + 0x1085)
+#define HDMITX_DWC_FC_ACP12                     (DWC_OFFSET_MASK + 0x1086)
+#define HDMITX_DWC_FC_ACP11                     (DWC_OFFSET_MASK + 0x1087)
+#define HDMITX_DWC_FC_ACP10                     (DWC_OFFSET_MASK + 0x1088)
+#define HDMITX_DWC_FC_ACP9                      (DWC_OFFSET_MASK + 0x1089)
+#define HDMITX_DWC_FC_ACP8                      (DWC_OFFSET_MASK + 0x108A)
+#define HDMITX_DWC_FC_ACP7                      (DWC_OFFSET_MASK + 0x108B)
+#define HDMITX_DWC_FC_ACP6                      (DWC_OFFSET_MASK + 0x108C)
+#define HDMITX_DWC_FC_ACP5                      (DWC_OFFSET_MASK + 0x108D)
+#define HDMITX_DWC_FC_ACP4                      (DWC_OFFSET_MASK + 0x108E)
+#define HDMITX_DWC_FC_ACP3                      (DWC_OFFSET_MASK + 0x108F)
+#define HDMITX_DWC_FC_ACP2                      (DWC_OFFSET_MASK + 0x1090)
+#define HDMITX_DWC_FC_ACP1                      (DWC_OFFSET_MASK + 0x1091)
+#define HDMITX_DWC_FC_ISCR1_0                   (DWC_OFFSET_MASK + 0x1092)
+#define HDMITX_DWC_FC_ISCR1_16                  (DWC_OFFSET_MASK + 0x1093)
+#define HDMITX_DWC_FC_ISCR1_15                  (DWC_OFFSET_MASK + 0x1094)
+#define HDMITX_DWC_FC_ISCR1_14                  (DWC_OFFSET_MASK + 0x1095)
+#define HDMITX_DWC_FC_ISCR1_13                  (DWC_OFFSET_MASK + 0x1096)
+#define HDMITX_DWC_FC_ISCR1_12                  (DWC_OFFSET_MASK + 0x1097)
+#define HDMITX_DWC_FC_ISCR1_11                  (DWC_OFFSET_MASK + 0x1098)
+#define HDMITX_DWC_FC_ISCR1_10                  (DWC_OFFSET_MASK + 0x1099)
+#define HDMITX_DWC_FC_ISCR1_9                   (DWC_OFFSET_MASK + 0x109A)
+#define HDMITX_DWC_FC_ISCR1_8                   (DWC_OFFSET_MASK + 0x109B)
+#define HDMITX_DWC_FC_ISCR1_7                   (DWC_OFFSET_MASK + 0x109C)
+#define HDMITX_DWC_FC_ISCR1_6                   (DWC_OFFSET_MASK + 0x109D)
+#define HDMITX_DWC_FC_ISCR1_5                   (DWC_OFFSET_MASK + 0x109E)
+#define HDMITX_DWC_FC_ISCR1_4                   (DWC_OFFSET_MASK + 0x109F)
+#define HDMITX_DWC_FC_ISCR1_3                   (DWC_OFFSET_MASK + 0x10A0)
+#define HDMITX_DWC_FC_ISCR1_2                   (DWC_OFFSET_MASK + 0x10A1)
+#define HDMITX_DWC_FC_ISCR1_1                   (DWC_OFFSET_MASK + 0x10A2)
+#define HDMITX_DWC_FC_ISCR0_15                  (DWC_OFFSET_MASK + 0x10A3)
+#define HDMITX_DWC_FC_ISCR0_14                  (DWC_OFFSET_MASK + 0x10A4)
+#define HDMITX_DWC_FC_ISCR0_13                  (DWC_OFFSET_MASK + 0x10A5)
+#define HDMITX_DWC_FC_ISCR0_12                  (DWC_OFFSET_MASK + 0x10A6)
+#define HDMITX_DWC_FC_ISCR0_11                  (DWC_OFFSET_MASK + 0x10A7)
+#define HDMITX_DWC_FC_ISCR0_10                  (DWC_OFFSET_MASK + 0x10A8)
+#define HDMITX_DWC_FC_ISCR0_9                   (DWC_OFFSET_MASK + 0x10A9)
+#define HDMITX_DWC_FC_ISCR0_8                   (DWC_OFFSET_MASK + 0x10AA)
+#define HDMITX_DWC_FC_ISCR0_7                   (DWC_OFFSET_MASK + 0x10AB)
+#define HDMITX_DWC_FC_ISCR0_6                   (DWC_OFFSET_MASK + 0x10AC)
+#define HDMITX_DWC_FC_ISCR0_5                   (DWC_OFFSET_MASK + 0x10AD)
+#define HDMITX_DWC_FC_ISCR0_4                   (DWC_OFFSET_MASK + 0x10AE)
+#define HDMITX_DWC_FC_ISCR0_3                   (DWC_OFFSET_MASK + 0x10AF)
+#define HDMITX_DWC_FC_ISCR0_2                   (DWC_OFFSET_MASK + 0x10B0)
+#define HDMITX_DWC_FC_ISCR0_1                   (DWC_OFFSET_MASK + 0x10B1)
+#define HDMITX_DWC_FC_ISCR0_0                   (DWC_OFFSET_MASK + 0x10B2)
+/* [  4] spd_auto */
+/* [  3] vsd_auto */
+/* [  2] isrc2_auto */
+/* [  1] isrc1_auto */
+/* [  0] acp_auto */
+#define HDMITX_DWC_FC_DATAUTO0                  (DWC_OFFSET_MASK + 0x10B3)
+#define HDMITX_DWC_FC_DATAUTO1                  (DWC_OFFSET_MASK + 0x10B4)
+#define HDMITX_DWC_FC_DATAUTO2                  (DWC_OFFSET_MASK + 0x10B5)
+#define HDMITX_DWC_FC_DATMAN                    (DWC_OFFSET_MASK + 0x10B6)
+/* [  5] nvbi_auto: insert on Vsync */
+/* [  4] amp_auto: insert on Vsync */
+/* [  3] avi_auto: insert on Vsync */
+/* [  2] gcp_auto: insert on Vsync */
+/* [  1] audi_auto: insert on Vsync */
+/* [  0] acr_auto: insert on CTS update. Assert this bit later to avoid
+ * inital packets with false CTS value
+ */
+#define HDMITX_DWC_FC_DATAUTO3                  (DWC_OFFSET_MASK + 0x10B7)
+#define HDMITX_DWC_FC_RDRB0                     (DWC_OFFSET_MASK + 0x10B8)
+#define HDMITX_DWC_FC_RDRB1                     (DWC_OFFSET_MASK + 0x10B9)
+#define HDMITX_DWC_FC_RDRB2                     (DWC_OFFSET_MASK + 0x10BA)
+#define HDMITX_DWC_FC_RDRB3                     (DWC_OFFSET_MASK + 0x10BB)
+#define HDMITX_DWC_FC_RDRB4                     (DWC_OFFSET_MASK + 0x10BC)
+#define HDMITX_DWC_FC_RDRB5                     (DWC_OFFSET_MASK + 0x10BD)
+#define HDMITX_DWC_FC_RDRB6                     (DWC_OFFSET_MASK + 0x10BE)
+#define HDMITX_DWC_FC_RDRB7                     (DWC_OFFSET_MASK + 0x10BF)
+#define HDMITX_DWC_FC_RDRB8                     (DWC_OFFSET_MASK + 0x10C0)
+#define HDMITX_DWC_FC_RDRB9                     (DWC_OFFSET_MASK + 0x10C1)
+#define HDMITX_DWC_FC_RDRB10                    (DWC_OFFSET_MASK + 0x10C2)
+#define HDMITX_DWC_FC_RDRB11                    (DWC_OFFSET_MASK + 0x10C3)
+/* [  7] AUDI_int_mask */
+/* [  6] ACP_int_mask */
+/* [  5] HBR_int_mask */
+/* [  2] AUDS_int_mask */
+/* [  1] ACR_int_mask */
+/* [  0] NULL_int_mask */
+#define HDMITX_DWC_FC_MASK0                     (DWC_OFFSET_MASK + 0x10D2)
+/* [  7] GMD_int_mask */
+/* [  6] ISRC1_int_mask */
+/* [  5] ISRC2_int_mask */
+/* [  4] VSD_int_mask */
+/* [  3] SPD_int_mask */
+/* [  1] AVI_int_mask */
+/* [  0] GCP_int_mask */
+#define HDMITX_DWC_FC_MASK1                     (DWC_OFFSET_MASK + 0x10D6)
+/* [  1] LowPriority_fifo_full */
+/* [  0] HighPriority_fifo_full */
+#define HDMITX_DWC_FC_MASK2                     (DWC_OFFSET_MASK + 0x10DA)
+/* [7:4] incoming_pr_factor */
+/* [3:0] output_pr_factor */
+#define HDMITX_DWC_FC_PRCONF                    (DWC_OFFSET_MASK + 0x10E0)
+/* [  4] scrambler_ucp_line */
+/* [  0] scrambler_en. Only update this bit once we've sent SCDC message*/
+#define HDMITX_DWC_FC_SCRAMBLER_CTRL            (DWC_OFFSET_MASK + 0x10E1)
+#define HDMITX_DWC_FC_MULTISTREAM_CTRL          (DWC_OFFSET_MASK + 0x10E2)
+/* [  6] nvbi_tx_en */
+/* [  5] amp_tx_en */
+/* [  4] aut_tx_en */
+/* [  3] audi_tx_en */
+/* [  2] avi_tx_en */
+/* [  1] gcp_tx_en */
+/* [  0] acr_tx_en */
+#define HDMITX_DWC_FC_PACKET_TX_EN              (DWC_OFFSET_MASK + 0x10E3)
+/* [  1] actspc_hdlr_tgl */
+/* [  0] actspc_hdlr_en */
+#define HDMITX_DWC_FC_ACTSPC_HDLR_CFG           (DWC_OFFSET_MASK + 0x10E8)
+#define HDMITX_DWC_FC_INVACT_2D_0               (DWC_OFFSET_MASK + 0x10E9)
+/* [3:0] fc_invact_2d_0[11:8] */
+/* [7:0] fc_invact_2d_0[7:0] */
+#define HDMITX_DWC_FC_INVACT_2D_1               (DWC_OFFSET_MASK + 0x10EA)
+
+#define HDMITX_DWC_FC_GMD_STAT                  (DWC_OFFSET_MASK + 0x1100)
+#define HDMITX_DWC_FC_GMD_EN                    (DWC_OFFSET_MASK + 0x1101)
+#define HDMITX_DWC_FC_GMD_UP                    (DWC_OFFSET_MASK + 0x1102)
+#define HDMITX_DWC_FC_GMD_CONF                  (DWC_OFFSET_MASK + 0x1103)
+#define HDMITX_DWC_FC_GMD_HB                    (DWC_OFFSET_MASK + 0x1104)
+#define HDMITX_DWC_FC_GMD_PB0                   (DWC_OFFSET_MASK + 0x1105)
+#define HDMITX_DWC_FC_GMD_PB1                   (DWC_OFFSET_MASK + 0x1106)
+#define HDMITX_DWC_FC_GMD_PB2                   (DWC_OFFSET_MASK + 0x1107)
+#define HDMITX_DWC_FC_GMD_PB3                   (DWC_OFFSET_MASK + 0x1108)
+#define HDMITX_DWC_FC_GMD_PB4                   (DWC_OFFSET_MASK + 0x1109)
+#define HDMITX_DWC_FC_GMD_PB5                   (DWC_OFFSET_MASK + 0x110A)
+#define HDMITX_DWC_FC_GMD_PB6                   (DWC_OFFSET_MASK + 0x110B)
+#define HDMITX_DWC_FC_GMD_PB7                   (DWC_OFFSET_MASK + 0x110C)
+#define HDMITX_DWC_FC_GMD_PB8                   (DWC_OFFSET_MASK + 0x110D)
+#define HDMITX_DWC_FC_GMD_PB9                   (DWC_OFFSET_MASK + 0x110E)
+#define HDMITX_DWC_FC_GMD_PB10                  (DWC_OFFSET_MASK + 0x110F)
+#define HDMITX_DWC_FC_GMD_PB11                  (DWC_OFFSET_MASK + 0x1110)
+#define HDMITX_DWC_FC_GMD_PB12                  (DWC_OFFSET_MASK + 0x1111)
+#define HDMITX_DWC_FC_GMD_PB13                  (DWC_OFFSET_MASK + 0x1112)
+#define HDMITX_DWC_FC_GMD_PB14                  (DWC_OFFSET_MASK + 0x1113)
+#define HDMITX_DWC_FC_GMD_PB15                  (DWC_OFFSET_MASK + 0x1114)
+#define HDMITX_DWC_FC_GMD_PB16                  (DWC_OFFSET_MASK + 0x1115)
+#define HDMITX_DWC_FC_GMD_PB17                  (DWC_OFFSET_MASK + 0x1116)
+#define HDMITX_DWC_FC_GMD_PB18                  (DWC_OFFSET_MASK + 0x1117)
+#define HDMITX_DWC_FC_GMD_PB19                  (DWC_OFFSET_MASK + 0x1118)
+#define HDMITX_DWC_FC_GMD_PB20                  (DWC_OFFSET_MASK + 0x1119)
+#define HDMITX_DWC_FC_GMD_PB21                  (DWC_OFFSET_MASK + 0x111A)
+#define HDMITX_DWC_FC_GMD_PB22                  (DWC_OFFSET_MASK + 0x111B)
+#define HDMITX_DWC_FC_GMD_PB23                  (DWC_OFFSET_MASK + 0x111C)
+#define HDMITX_DWC_FC_GMD_PB24                  (DWC_OFFSET_MASK + 0x111D)
+#define HDMITX_DWC_FC_GMD_PB25                  (DWC_OFFSET_MASK + 0x111E)
+#define HDMITX_DWC_FC_GMD_PB26                  (DWC_OFFSET_MASK + 0x111F)
+#define HDMITX_DWC_FC_GMD_PB27                  (DWC_OFFSET_MASK + 0x1120)
+
+/* Audio Metadata Packet Registers */
+#define HDMITX_DWC_FC_AMP_HB01                  (DWC_OFFSET_MASK + 0x1128)
+#define HDMITX_DWC_FC_AMP_HB02                  (DWC_OFFSET_MASK + 0x1129)
+#define HDMITX_DWC_FC_AMP_PB00                  (DWC_OFFSET_MASK + 0x112A)
+#define HDMITX_DWC_FC_AMP_PB01                  (DWC_OFFSET_MASK + 0x112B)
+#define HDMITX_DWC_FC_AMP_PB02                  (DWC_OFFSET_MASK + 0x112C)
+#define HDMITX_DWC_FC_AMP_PB03                  (DWC_OFFSET_MASK + 0x112D)
+#define HDMITX_DWC_FC_AMP_PB04                  (DWC_OFFSET_MASK + 0x112E)
+#define HDMITX_DWC_FC_AMP_PB05                  (DWC_OFFSET_MASK + 0x112F)
+#define HDMITX_DWC_FC_AMP_PB06                  (DWC_OFFSET_MASK + 0x1130)
+#define HDMITX_DWC_FC_AMP_PB07                  (DWC_OFFSET_MASK + 0x1131)
+#define HDMITX_DWC_FC_AMP_PB08                  (DWC_OFFSET_MASK + 0x1132)
+#define HDMITX_DWC_FC_AMP_PB09                  (DWC_OFFSET_MASK + 0x1133)
+#define HDMITX_DWC_FC_AMP_PB10                  (DWC_OFFSET_MASK + 0x1134)
+#define HDMITX_DWC_FC_AMP_PB11                  (DWC_OFFSET_MASK + 0x1135)
+#define HDMITX_DWC_FC_AMP_PB12                  (DWC_OFFSET_MASK + 0x1136)
+#define HDMITX_DWC_FC_AMP_PB13                  (DWC_OFFSET_MASK + 0x1137)
+#define HDMITX_DWC_FC_AMP_PB14                  (DWC_OFFSET_MASK + 0x1138)
+#define HDMITX_DWC_FC_AMP_PB15                  (DWC_OFFSET_MASK + 0x1139)
+#define HDMITX_DWC_FC_AMP_PB16                  (DWC_OFFSET_MASK + 0x113A)
+#define HDMITX_DWC_FC_AMP_PB17                  (DWC_OFFSET_MASK + 0x113B)
+#define HDMITX_DWC_FC_AMP_PB18                  (DWC_OFFSET_MASK + 0x113C)
+#define HDMITX_DWC_FC_AMP_PB19                  (DWC_OFFSET_MASK + 0x113D)
+#define HDMITX_DWC_FC_AMP_PB20                  (DWC_OFFSET_MASK + 0x113E)
+#define HDMITX_DWC_FC_AMP_PB21                  (DWC_OFFSET_MASK + 0x113F)
+#define HDMITX_DWC_FC_AMP_PB22                  (DWC_OFFSET_MASK + 0x1140)
+#define HDMITX_DWC_FC_AMP_PB23                  (DWC_OFFSET_MASK + 0x1141)
+#define HDMITX_DWC_FC_AMP_PB24                  (DWC_OFFSET_MASK + 0x1142)
+#define HDMITX_DWC_FC_AMP_PB25                  (DWC_OFFSET_MASK + 0x1143)
+#define HDMITX_DWC_FC_AMP_PB26                  (DWC_OFFSET_MASK + 0x1144)
+#define HDMITX_DWC_FC_AMP_PB27                  (DWC_OFFSET_MASK + 0x1145)
+
+/* NTSC VBI Packet Registers */
+#define HDMITX_DWC_FC_NVBI_HB01                 (DWC_OFFSET_MASK + 0x1148)
+#define HDMITX_DWC_FC_NVBI_HB02                 (DWC_OFFSET_MASK + 0x1149)
+#define HDMITX_DWC_FC_NVBI_PB01                 (DWC_OFFSET_MASK + 0x114A)
+#define HDMITX_DWC_FC_NVBI_PB02                 (DWC_OFFSET_MASK + 0x114B)
+#define HDMITX_DWC_FC_NVBI_PB03                 (DWC_OFFSET_MASK + 0x114C)
+#define HDMITX_DWC_FC_NVBI_PB04                 (DWC_OFFSET_MASK + 0x114D)
+#define HDMITX_DWC_FC_NVBI_PB05                 (DWC_OFFSET_MASK + 0x114E)
+#define HDMITX_DWC_FC_NVBI_PB06                 (DWC_OFFSET_MASK + 0x114F)
+#define HDMITX_DWC_FC_NVBI_PB07                 (DWC_OFFSET_MASK + 0x1150)
+#define HDMITX_DWC_FC_NVBI_PB08                 (DWC_OFFSET_MASK + 0x1151)
+#define HDMITX_DWC_FC_NVBI_PB09                 (DWC_OFFSET_MASK + 0x1152)
+#define HDMITX_DWC_FC_NVBI_PB10                 (DWC_OFFSET_MASK + 0x1153)
+#define HDMITX_DWC_FC_NVBI_PB11                 (DWC_OFFSET_MASK + 0x1154)
+#define HDMITX_DWC_FC_NVBI_PB12                 (DWC_OFFSET_MASK + 0x1155)
+#define HDMITX_DWC_FC_NVBI_PB13                 (DWC_OFFSET_MASK + 0x1156)
+#define HDMITX_DWC_FC_NVBI_PB14                 (DWC_OFFSET_MASK + 0x1157)
+#define HDMITX_DWC_FC_NVBI_PB15                 (DWC_OFFSET_MASK + 0x1158)
+#define HDMITX_DWC_FC_NVBI_PB16                 (DWC_OFFSET_MASK + 0x1159)
+#define HDMITX_DWC_FC_NVBI_PB17                 (DWC_OFFSET_MASK + 0x115A)
+#define HDMITX_DWC_FC_NVBI_PB18                 (DWC_OFFSET_MASK + 0x115B)
+#define HDMITX_DWC_FC_NVBI_PB19                 (DWC_OFFSET_MASK + 0x115C)
+#define HDMITX_DWC_FC_NVBI_PB20                 (DWC_OFFSET_MASK + 0x115D)
+#define HDMITX_DWC_FC_NVBI_PB21                 (DWC_OFFSET_MASK + 0x115E)
+#define HDMITX_DWC_FC_NVBI_PB22                 (DWC_OFFSET_MASK + 0x115F)
+#define HDMITX_DWC_FC_NVBI_PB23                 (DWC_OFFSET_MASK + 0x1160)
+#define HDMITX_DWC_FC_NVBI_PB24                 (DWC_OFFSET_MASK + 0x1161)
+#define HDMITX_DWC_FC_NVBI_PB25                 (DWC_OFFSET_MASK + 0x1162)
+#define HDMITX_DWC_FC_NVBI_PB26                 (DWC_OFFSET_MASK + 0x1163)
+#define HDMITX_DWC_FC_NVBI_PB27                 (DWC_OFFSET_MASK + 0x1164)
+
+#define HDMITX_DWC_FC_DBGFORCE                  (DWC_OFFSET_MASK + 0x1200)
+#define HDMITX_DWC_FC_DBGAUD0CH0                (DWC_OFFSET_MASK + 0x1201)
+#define HDMITX_DWC_FC_DBGAUD1CH0                (DWC_OFFSET_MASK + 0x1202)
+#define HDMITX_DWC_FC_DBGAUD2CH0                (DWC_OFFSET_MASK + 0x1203)
+#define HDMITX_DWC_FC_DBGAUD0CH1                (DWC_OFFSET_MASK + 0x1204)
+#define HDMITX_DWC_FC_DBGAUD1CH1                (DWC_OFFSET_MASK + 0x1205)
+#define HDMITX_DWC_FC_DBGAUD2CH1                (DWC_OFFSET_MASK + 0x1206)
+#define HDMITX_DWC_FC_DBGAUD0CH2                (DWC_OFFSET_MASK + 0x1207)
+#define HDMITX_DWC_FC_DBGAUD1CH2                (DWC_OFFSET_MASK + 0x1208)
+#define HDMITX_DWC_FC_DBGAUD2CH2                (DWC_OFFSET_MASK + 0x1209)
+#define HDMITX_DWC_FC_DBGAUD0CH3                (DWC_OFFSET_MASK + 0x120A)
+#define HDMITX_DWC_FC_DBGAUD1CH3                (DWC_OFFSET_MASK + 0x120B)
+#define HDMITX_DWC_FC_DBGAUD2CH3                (DWC_OFFSET_MASK + 0x120C)
+#define HDMITX_DWC_FC_DBGAUD0CH4                (DWC_OFFSET_MASK + 0x120D)
+#define HDMITX_DWC_FC_DBGAUD1CH4                (DWC_OFFSET_MASK + 0x120E)
+#define HDMITX_DWC_FC_DBGAUD2CH4                (DWC_OFFSET_MASK + 0x120F)
+#define HDMITX_DWC_FC_DBGAUD0CH5                (DWC_OFFSET_MASK + 0x1210)
+#define HDMITX_DWC_FC_DBGAUD1CH5                (DWC_OFFSET_MASK + 0x1211)
+#define HDMITX_DWC_FC_DBGAUD2CH5                (DWC_OFFSET_MASK + 0x1212)
+#define HDMITX_DWC_FC_DBGAUD0CH6                (DWC_OFFSET_MASK + 0x1213)
+#define HDMITX_DWC_FC_DBGAUD1CH6                (DWC_OFFSET_MASK + 0x1214)
+#define HDMITX_DWC_FC_DBGAUD2CH6                (DWC_OFFSET_MASK + 0x1215)
+#define HDMITX_DWC_FC_DBGAUD0CH7                (DWC_OFFSET_MASK + 0x1216)
+#define HDMITX_DWC_FC_DBGAUD1CH7                (DWC_OFFSET_MASK + 0x1217)
+#define HDMITX_DWC_FC_DBGAUD2CH7                (DWC_OFFSET_MASK + 0x1218)
+#define HDMITX_DWC_FC_DBGTMDS0                  (DWC_OFFSET_MASK + 0x1219)
+#define HDMITX_DWC_FC_DBGTMDS1                  (DWC_OFFSET_MASK + 0x121A)
+#define HDMITX_DWC_FC_DBGTMDS2                  (DWC_OFFSET_MASK + 0x121B)
+
+/* HDMI Source PHY Registers */
+#define HDMITX_DWC_PHY_CONF0                    (DWC_OFFSET_MASK + 0x3000)
+#define HDMITX_DWC_PHY_TST0                     (DWC_OFFSET_MASK + 0x3001)
+#define HDMITX_DWC_PHY_TST1                     (DWC_OFFSET_MASK + 0x3002)
+#define HDMITX_DWC_PHY_TST2                     (DWC_OFFSET_MASK + 0x3003)
+#define HDMITX_DWC_PHY_STAT0                    (DWC_OFFSET_MASK + 0x3004)
+#define HDMITX_DWC_PHY_INT0                     (DWC_OFFSET_MASK + 0x3005)
+#define HDMITX_DWC_PHY_MASK0                    (DWC_OFFSET_MASK + 0x3006)
+#define HDMITX_DWC_PHY_POL0                     (DWC_OFFSET_MASK + 0x3007)
+
+/* I2C Master PHY Registers */
+#define HDMITX_DWC_I2CM_PHY_SLAVE               (DWC_OFFSET_MASK + 0x3020)
+#define HDMITX_DWC_I2CM_PHY_ADDRESS             (DWC_OFFSET_MASK + 0x3021)
+#define HDMITX_DWC_I2CM_PHY_DATAO_1             (DWC_OFFSET_MASK + 0x3022)
+#define HDMITX_DWC_I2CM_PHY_DATAO_0             (DWC_OFFSET_MASK + 0x3023)
+#define HDMITX_DWC_I2CM_PHY_DATAI_1             (DWC_OFFSET_MASK + 0x3024)
+#define HDMITX_DWC_I2CM_PHY_DATAI_0             (DWC_OFFSET_MASK + 0x3025)
+#define HDMITX_DWC_I2CM_PHY_OPERATION           (DWC_OFFSET_MASK + 0x3026)
+#define HDMITX_DWC_I2CM_PHY_INT                 (DWC_OFFSET_MASK + 0x3027)
+#define HDMITX_DWC_I2CM_PHY_CTLINT              (DWC_OFFSET_MASK + 0x3028)
+#define HDMITX_DWC_I2CM_PHY_DIV                 (DWC_OFFSET_MASK + 0x3029)
+#define HDMITX_DWC_I2CM_PHY_SOFTRSTZ            (DWC_OFFSET_MASK + 0x302A)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302B)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x302C)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x302D)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x302E)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302F)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x3030)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x3031)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x3032)
+#define HDMITX_DWC_I2CM_PHY_SDA_HOLD            (DWC_OFFSET_MASK + 0x3033)
+
+/* Audio Sampler Registers */
+
+  /* [  7] sw_audio_fifo_rst */
+  /* [  5] 0=select SPDIF; 1=select I2S. */
+  /* [3:0] i2s_in_en: enable it later in test.c */
+
+#define HDMITX_DWC_AUD_CONF0                    (DWC_OFFSET_MASK + 0x3100)
+/* [4:0] i2s_width */
+/* [7:5] i2s_mode: 0=standard I2S mode */
+#define HDMITX_DWC_AUD_CONF1                    (DWC_OFFSET_MASK + 0x3101)
+/* [  3] fifo_empty_mask: 0=enable int; 1=mask int. */
+/* [  2] fifo_full_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_INT                      (DWC_OFFSET_MASK + 0x3102)
+  /* [  1] NLPCM */
+#define HDMITX_DWC_AUD_CONF2                    (DWC_OFFSET_MASK + 0x3103)
+
+/* [  4] fifo_overrun_mask: 0=enable int; 1=mask int.
+ * Enable it later when audio starts.
+ */
+#define HDMITX_DWC_AUD_INT1                     (DWC_OFFSET_MASK + 0x3104)
+
+#define HDMITX_DWC_AUD_N1                       (DWC_OFFSET_MASK + 0x3200)
+#define HDMITX_DWC_AUD_N2                       (DWC_OFFSET_MASK + 0x3201)
+#define HDMITX_DWC_AUD_N3                       (DWC_OFFSET_MASK + 0x3202)
+#define HDMITX_DWC_AUD_CTS1                     (DWC_OFFSET_MASK + 0x3203)
+#define HDMITX_DWC_AUD_CTS2                     (DWC_OFFSET_MASK + 0x3204)
+#define HDMITX_DWC_AUD_CTS3                     (DWC_OFFSET_MASK + 0x3205)
+#define HDMITX_DWC_AUD_INPUTCLKFS               (DWC_OFFSET_MASK + 0x3206)
+/* [  7] sw_audio_fifo_rst */
+#define HDMITX_DWC_AUD_SPDIF0                   (DWC_OFFSET_MASK + 0x3300)
+/* [4:0] spdif_width */
+/* [  7] setnlpcm */
+#define HDMITX_DWC_AUD_SPDIF1                   (DWC_OFFSET_MASK + 0x3301)
+/* [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int. */
+/* [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_SPDIFINT                 (DWC_OFFSET_MASK + 0x3302)
+/* [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int. */
+#define HDMITX_DWC_AUD_SPDIFINT1                (DWC_OFFSET_MASK + 0x3303)
+
+/* Generic Parallel Audio Interface Registers   (DWC_OFFSET_MASK + 0x3500) */
+/* Audio DMA Registers                          (DWC_OFFSET_MASK + 0x3600) */
+
+/* Main Controller Registers */
+/* [  6] hdcpclk_disable */
+/* [  5] cecclk_disable */
+/* [  4] cscclk_disable */
+/* [  3] audclk_disable */
+/* [  2] prepclk_disable */
+/* [  1] tmdsclk_disable */
+/* [  0] pixelclk_disable */
+#define HDMITX_DWC_MC_CLKDIS                    (DWC_OFFSET_MASK + 0x4001)
+/*
+ * [  7] gpaswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  6] cecswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  4] spdifswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  3] i2sswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  2] prepswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  1] tmdsswrst_req: 0=generate reset pulse; 1=no reset.
+ * [  0] pixelswrst_req: 0=generate reset pulse; 1=no reset.
+ */
+#define HDMITX_DWC_MC_SWRSTZREQ                 (DWC_OFFSET_MASK + 0x4002)
+#define HDMITX_DWC_MC_OPCTRL                    (DWC_OFFSET_MASK + 0x4003)
+/* [  0] CSC enable */
+#define HDMITX_DWC_MC_FLOWCTRL                  (DWC_OFFSET_MASK + 0x4004)
+#define HDMITX_DWC_MC_PHYRSTZ                   (DWC_OFFSET_MASK + 0x4005)
+#define HDMITX_DWC_MC_LOCKONCLOCK               (DWC_OFFSET_MASK + 0x4006)
+
+/* Color Space Converter Registers */
+/* [  7] csc_limit */
+#define HDMITX_DWC_CSC_CFG                      (DWC_OFFSET_MASK + 0x4100)
+#define HDMITX_DWC_CSC_SCALE                    (DWC_OFFSET_MASK + 0x4101)
+#define HDMITX_DWC_CSC_COEF_A1_MSB              (DWC_OFFSET_MASK + 0x4102)
+#define HDMITX_DWC_CSC_COEF_A1_LSB              (DWC_OFFSET_MASK + 0x4103)
+#define HDMITX_DWC_CSC_COEF_A2_MSB              (DWC_OFFSET_MASK + 0x4104)
+#define HDMITX_DWC_CSC_COEF_A2_LSB              (DWC_OFFSET_MASK + 0x4105)
+#define HDMITX_DWC_CSC_COEF_A3_MSB              (DWC_OFFSET_MASK + 0x4106)
+#define HDMITX_DWC_CSC_COEF_A3_LSB              (DWC_OFFSET_MASK + 0x4107)
+#define HDMITX_DWC_CSC_COEF_A4_MSB              (DWC_OFFSET_MASK + 0x4108)
+#define HDMITX_DWC_CSC_COEF_A4_LSB              (DWC_OFFSET_MASK + 0x4109)
+#define HDMITX_DWC_CSC_COEF_B1_MSB              (DWC_OFFSET_MASK + 0x410A)
+#define HDMITX_DWC_CSC_COEF_B1_LSB              (DWC_OFFSET_MASK + 0x410B)
+#define HDMITX_DWC_CSC_COEF_B2_MSB              (DWC_OFFSET_MASK + 0x410C)
+#define HDMITX_DWC_CSC_COEF_B2_LSB              (DWC_OFFSET_MASK + 0x410D)
+#define HDMITX_DWC_CSC_COEF_B3_MSB              (DWC_OFFSET_MASK + 0x410E)
+#define HDMITX_DWC_CSC_COEF_B3_LSB              (DWC_OFFSET_MASK + 0x410F)
+#define HDMITX_DWC_CSC_COEF_B4_MSB              (DWC_OFFSET_MASK + 0x4110)
+#define HDMITX_DWC_CSC_COEF_B4_LSB              (DWC_OFFSET_MASK + 0x4111)
+#define HDMITX_DWC_CSC_COEF_C1_MSB              (DWC_OFFSET_MASK + 0x4112)
+#define HDMITX_DWC_CSC_COEF_C1_LSB              (DWC_OFFSET_MASK + 0x4113)
+#define HDMITX_DWC_CSC_COEF_C2_MSB              (DWC_OFFSET_MASK + 0x4114)
+#define HDMITX_DWC_CSC_COEF_C2_LSB              (DWC_OFFSET_MASK + 0x4115)
+#define HDMITX_DWC_CSC_COEF_C3_MSB              (DWC_OFFSET_MASK + 0x4116)
+#define HDMITX_DWC_CSC_COEF_C3_LSB              (DWC_OFFSET_MASK + 0x4117)
+#define HDMITX_DWC_CSC_COEF_C4_MSB              (DWC_OFFSET_MASK + 0x4118)
+#define HDMITX_DWC_CSC_COEF_C4_LSB              (DWC_OFFSET_MASK + 0x4119)
+#define HDMITX_DWC_CSC_LIMIT_UP_MSB             (DWC_OFFSET_MASK + 0x411A)
+#define HDMITX_DWC_CSC_LIMIT_UP_LSB             (DWC_OFFSET_MASK + 0x411B)
+#define HDMITX_DWC_CSC_LIMIT_DN_MSB             (DWC_OFFSET_MASK + 0x411C)
+#define HDMITX_DWC_CSC_LIMIT_DN_LSB             (DWC_OFFSET_MASK + 0x411D)
+
+/* HDCP Encryption Engine Registers */
+#define HDMITX_DWC_A_HDCPCFG0                   (DWC_SEC_OFFSET_MASK + 0x5000)
+/* [  4] hdcp_lock */
+/* [  3] dissha1check */
+/* [  2] ph2upshiftenc */
+/* [  1] encryptiondisable */
+/* [  0] swresetn. Write 0 to activate, self-clear to 1. */
+#define HDMITX_DWC_A_HDCPCFG1                   (DWC_SEC_OFFSET_MASK + 0x5001)
+#define HDMITX_DWC_A_HDCPOBS0                   (DWC_OFFSET_MASK + 0x5002)
+#define HDMITX_DWC_A_HDCPOBS1                   (DWC_OFFSET_MASK + 0x5003)
+#define HDMITX_DWC_A_HDCPOBS2                   (DWC_OFFSET_MASK + 0x5004)
+#define HDMITX_DWC_A_HDCPOBS3                   (DWC_OFFSET_MASK + 0x5005)
+#define HDMITX_DWC_A_APIINTCLR                  (DWC_OFFSET_MASK + 0x5006)
+#define HDMITX_DWC_A_APIINTSTAT                 (DWC_OFFSET_MASK + 0x5007)
+/* [  7] hdcp_engaged_int_mask */
+/* [  6] hdcp_failed_int_mask */
+/* [  4] i2c_nack_int_mask */
+/* [  3] lost_arbitration_int_mask */
+/* [  2] keepout_error_int_mask */
+/* [  1] ksv_sha1_calc_int_mask */
+/* [  0] ksv_access_int_mask */
+#define HDMITX_DWC_A_APIINTMSK                  (DWC_OFFSET_MASK + 0x5008)
+/* [6:5] unencryptconf */
+/* [  4] dataenpol */
+/* [  3] vsyncpol */
+/* [  1] hsyncpol */
+#define HDMITX_DWC_A_VIDPOLCFG                  (DWC_OFFSET_MASK + 0x5009)
+#define HDMITX_DWC_A_OESSWCFG                   (DWC_OFFSET_MASK + 0x500A)
+#define HDMITX_DWC_A_COREVERLSB                 (DWC_OFFSET_MASK + 0x5014)
+#define HDMITX_DWC_A_COREVERMSB                 (DWC_OFFSET_MASK + 0x5015)
+/* [  3] sha1_fail */
+/* [  2] ksv_ctrl_update */
+/* [  1] Rsvd for read-only ksv_mem_access */
+/* [  0] ksv_mem_request */
+#define HDMITX_DWC_A_KSVMEMCTRL                 (DWC_OFFSET_MASK + 0x5016)
+
+#define HDMITX_DWC_HDCP_BSTATUS_0               (DWC_OFFSET_MASK + 0x5020)
+#define HDMITX_DWC_HDCP_BSTATUS_1               (DWC_OFFSET_MASK + 0x5021)
+#define HDMITX_DWC_HDCP_M0_0                    (DWC_OFFSET_MASK + 0x5022)
+#define HDMITX_DWC_HDCP_M0_1                    (DWC_OFFSET_MASK + 0x5023)
+#define HDMITX_DWC_HDCP_M0_2                    (DWC_OFFSET_MASK + 0x5024)
+#define HDMITX_DWC_HDCP_M0_3                    (DWC_OFFSET_MASK + 0x5025)
+#define HDMITX_DWC_HDCP_M0_4                    (DWC_OFFSET_MASK + 0x5026)
+#define HDMITX_DWC_HDCP_M0_5                    (DWC_OFFSET_MASK + 0x5027)
+#define HDMITX_DWC_HDCP_M0_6                    (DWC_OFFSET_MASK + 0x5028)
+#define HDMITX_DWC_HDCP_M0_7                    (DWC_OFFSET_MASK + 0x5029)
+#define HDMITX_DWC_HDCP_KSV                     (DWC_OFFSET_MASK + 0x502A)
+#define HDMITX_DWC_HDCP_VH                      (DWC_OFFSET_MASK + 0x52A5)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_0            (DWC_OFFSET_MASK + 0x52B9)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_1            (DWC_OFFSET_MASK + 0x52BA)
+#define HDMITX_DWC_HDCP_REVOC_LIST              (DWC_OFFSET_MASK + 0x52BB)
+
+/* HDCP BKSV Registers */
+#define HDMITX_DWC_HDCPREG_BKSV0                (DWC_OFFSET_MASK + 0x7800)
+#define HDMITX_DWC_HDCPREG_BKSV1                (DWC_OFFSET_MASK + 0x7801)
+#define HDMITX_DWC_HDCPREG_BKSV2                (DWC_OFFSET_MASK + 0x7802)
+#define HDMITX_DWC_HDCPREG_BKSV3                (DWC_OFFSET_MASK + 0x7803)
+#define HDMITX_DWC_HDCPREG_BKSV4                (DWC_OFFSET_MASK + 0x7804)
+
+/* HDCP AN Registers */
+#define HDMITX_DWC_HDCPREG_ANCONF               (DWC_OFFSET_MASK + 0x7805)
+#define HDMITX_DWC_HDCPREG_AN0                  (DWC_OFFSET_MASK + 0x7806)
+#define HDMITX_DWC_HDCPREG_AN1                  (DWC_OFFSET_MASK + 0x7807)
+#define HDMITX_DWC_HDCPREG_AN2                  (DWC_OFFSET_MASK + 0x7808)
+#define HDMITX_DWC_HDCPREG_AN3                  (DWC_OFFSET_MASK + 0x7809)
+#define HDMITX_DWC_HDCPREG_AN4                  (DWC_OFFSET_MASK + 0x780A)
+#define HDMITX_DWC_HDCPREG_AN5                  (DWC_OFFSET_MASK + 0x780B)
+#define HDMITX_DWC_HDCPREG_AN6                  (DWC_OFFSET_MASK + 0x780C)
+#define HDMITX_DWC_HDCPREG_AN7                  (DWC_OFFSET_MASK + 0x780D)
+#define HDMITX_DWC_HDCPREG_RMLCTL               (DWC_OFFSET_MASK + 0x780E)
+
+/* Encrypted DPK Embedded Storage Registers */
+#define HDMITX_DWC_HDCPREG_RMLSTS               (DWC_OFFSET_MASK + 0x780F)
+#define HDMITX_DWC_HDCPREG_SEED0                (DWC_SEC_OFFSET_MASK + 0x7810)
+#define HDMITX_DWC_HDCPREG_SEED1                (DWC_SEC_OFFSET_MASK + 0x7811)
+#define HDMITX_DWC_HDCPREG_DPK0                 (DWC_SEC_OFFSET_MASK + 0x7812)
+#define HDMITX_DWC_HDCPREG_DPK1                 (DWC_SEC_OFFSET_MASK + 0x7813)
+#define HDMITX_DWC_HDCPREG_DPK2                 (DWC_SEC_OFFSET_MASK + 0x7814)
+#define HDMITX_DWC_HDCPREG_DPK3                 (DWC_SEC_OFFSET_MASK + 0x7815)
+#define HDMITX_DWC_HDCPREG_DPK4                 (DWC_SEC_OFFSET_MASK + 0x7816)
+#define HDMITX_DWC_HDCPREG_DPK5                 (DWC_SEC_OFFSET_MASK + 0x7817)
+#define HDMITX_DWC_HDCPREG_DPK6                 (DWC_SEC_OFFSET_MASK + 0x7818)
+
+/* HDCP22 Registers */
+#define HDMITX_DWC_HDCP22REG_ID                 (DWC_OFFSET_MASK + 0x7900)
+#define HDMITX_DWC_HDCP22REG_CTRL               (DWC_SEC_OFFSET_MASK + 0x7904)
+#define HDMITX_DWC_HDCP22REG_CTRL1              (DWC_OFFSET_MASK + 0x7905)
+#define HDMITX_DWC_HDCP22REG_STS                (DWC_OFFSET_MASK + 0x7908)
+#define HDMITX_DWC_HDCP22REG_MASK               (DWC_OFFSET_MASK + 0x790C)
+#define HDMITX_DWC_HDCP22REG_STAT               (DWC_OFFSET_MASK + 0x790D)
+#define HDMITX_DWC_HDCP22REG_MUTE               (DWC_OFFSET_MASK + 0x790E)
+
+
+/* ********** CEC related ********** */
+
+/* CEC 2.0 Engine Registers */
+#define HDMITX_DWC_CEC_CTRL                     (DWC_OFFSET_MASK + 0x7D00)
+#define HDMITX_DWC_CEC_INTR_MASK                (DWC_OFFSET_MASK + 0x7D02)
+#define HDMITX_DWC_CEC_LADD_LOW                 (DWC_OFFSET_MASK + 0x7D05)
+#define HDMITX_DWC_CEC_LADD_HIGH                (DWC_OFFSET_MASK + 0x7D06)
+#define HDMITX_DWC_CEC_TX_CNT                   (DWC_OFFSET_MASK + 0x7D07)
+#define HDMITX_DWC_CEC_RX_CNT                   (DWC_OFFSET_MASK + 0x7D08)
+#define HDMITX_DWC_CEC_TX_DATA00                (DWC_OFFSET_MASK + 0x7D10)
+#define HDMITX_DWC_CEC_TX_DATA01                (DWC_OFFSET_MASK + 0x7D11)
+#define HDMITX_DWC_CEC_TX_DATA02                (DWC_OFFSET_MASK + 0x7D12)
+#define HDMITX_DWC_CEC_TX_DATA03                (DWC_OFFSET_MASK + 0x7D13)
+#define HDMITX_DWC_CEC_TX_DATA04                (DWC_OFFSET_MASK + 0x7D14)
+#define HDMITX_DWC_CEC_TX_DATA05                (DWC_OFFSET_MASK + 0x7D15)
+#define HDMITX_DWC_CEC_TX_DATA06                (DWC_OFFSET_MASK + 0x7D16)
+#define HDMITX_DWC_CEC_TX_DATA07                (DWC_OFFSET_MASK + 0x7D17)
+#define HDMITX_DWC_CEC_TX_DATA08                (DWC_OFFSET_MASK + 0x7D18)
+#define HDMITX_DWC_CEC_TX_DATA09                (DWC_OFFSET_MASK + 0x7D19)
+#define HDMITX_DWC_CEC_TX_DATA10                (DWC_OFFSET_MASK + 0x7D1A)
+#define HDMITX_DWC_CEC_TX_DATA11                (DWC_OFFSET_MASK + 0x7D1B)
+#define HDMITX_DWC_CEC_TX_DATA12                (DWC_OFFSET_MASK + 0x7D1C)
+#define HDMITX_DWC_CEC_TX_DATA13                (DWC_OFFSET_MASK + 0x7D1D)
+#define HDMITX_DWC_CEC_TX_DATA14                (DWC_OFFSET_MASK + 0x7D1E)
+#define HDMITX_DWC_CEC_TX_DATA15                (DWC_OFFSET_MASK + 0x7D1F)
+#define HDMITX_DWC_CEC_RX_DATA00                (DWC_OFFSET_MASK + 0x7D20)
+#define HDMITX_DWC_CEC_RX_DATA01                (DWC_OFFSET_MASK + 0x7D21)
+#define HDMITX_DWC_CEC_RX_DATA02                (DWC_OFFSET_MASK + 0x7D22)
+#define HDMITX_DWC_CEC_RX_DATA03                (DWC_OFFSET_MASK + 0x7D23)
+#define HDMITX_DWC_CEC_RX_DATA04                (DWC_OFFSET_MASK + 0x7D24)
+#define HDMITX_DWC_CEC_RX_DATA05                (DWC_OFFSET_MASK + 0x7D25)
+#define HDMITX_DWC_CEC_RX_DATA06                (DWC_OFFSET_MASK + 0x7D26)
+#define HDMITX_DWC_CEC_RX_DATA07                (DWC_OFFSET_MASK + 0x7D27)
+#define HDMITX_DWC_CEC_RX_DATA08                (DWC_OFFSET_MASK + 0x7D28)
+#define HDMITX_DWC_CEC_RX_DATA09                (DWC_OFFSET_MASK + 0x7D29)
+#define HDMITX_DWC_CEC_RX_DATA10                (DWC_OFFSET_MASK + 0x7D2A)
+#define HDMITX_DWC_CEC_RX_DATA11                (DWC_OFFSET_MASK + 0x7D2B)
+#define HDMITX_DWC_CEC_RX_DATA12                (DWC_OFFSET_MASK + 0x7D2C)
+#define HDMITX_DWC_CEC_RX_DATA13                (DWC_OFFSET_MASK + 0x7D2D)
+#define HDMITX_DWC_CEC_RX_DATA14                (DWC_OFFSET_MASK + 0x7D2E)
+#define HDMITX_DWC_CEC_RX_DATA15                (DWC_OFFSET_MASK + 0x7D2F)
+#define HDMITX_DWC_CEC_LOCK_BUF                 (DWC_OFFSET_MASK + 0x7D30)
+#define HDMITX_DWC_CEC_WAKEUPCTRL               (DWC_OFFSET_MASK + 0x7D31)
+
+/* I2C Master Registers(E-DDC/SCDC) */
+#define HDMITX_DWC_I2CM_SLAVE                   (DWC_OFFSET_MASK + 0x7E00)
+#define HDMITX_DWC_I2CM_ADDRESS                 (DWC_OFFSET_MASK + 0x7E01)
+#define HDMITX_DWC_I2CM_DATAO                   (DWC_OFFSET_MASK + 0x7E02)
+#define HDMITX_DWC_I2CM_DATAI                   (DWC_OFFSET_MASK + 0x7E03)
+#define HDMITX_DWC_I2CM_OPERATION               (DWC_OFFSET_MASK + 0x7E04)
+/* [  2] done_mask */
+/* [  6] read_req_mask */
+#define HDMITX_DWC_I2CM_INT                     (DWC_OFFSET_MASK + 0x7E05)
+/* [  6] nack_mask */
+/* [  2] arbitration_error_mask */
+#define HDMITX_DWC_I2CM_CTLINT                  (DWC_OFFSET_MASK + 0x7E06)
+/* [  3] i2c_fast_mode: 0=standard mode; 1=fast mode. */
+#define HDMITX_DWC_I2CM_DIV                     (DWC_OFFSET_MASK + 0x7E07)
+#define HDMITX_DWC_I2CM_SEGADDR                 (DWC_OFFSET_MASK + 0x7E08)
+#define HDMITX_DWC_I2CM_SOFTRSTZ                (DWC_OFFSET_MASK + 0x7E09)
+#define HDMITX_DWC_I2CM_SEGPTR                  (DWC_OFFSET_MASK + 0x7E0A)
+/* I2CM_SS_SCL_HCNT = RndUp(min_ss_scl_htime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_SS_SCL_LCNT = RndUp(min_ss_scl_ltime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_FS_SCL_HCNT = RndUp(min_fs_scl_htime*Freq(sfrclkInMHz)/1000) */
+/* I2CM_FS_SCL_LCNT = RndUp(min_fs_scl_ltime*Freq(sfrclkInMHz)/1000) */
+/* Where Freq(sfrclkInMHz)=24; */
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0B)
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E0C)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E0D)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E0E)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0F)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E10)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E11)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E12)
+#define HDMITX_DWC_I2CM_SDA_HOLD                (DWC_OFFSET_MASK + 0x7E13)
+/* [  5] updt_rd_vsyncpoll_en */
+/* [  4] read_request_en */
+/* [  0] read_update */
+#define HDMITX_DWC_I2CM_SCDC_UPDATE             (DWC_OFFSET_MASK + 0x7E14)
+#define HDMITX_DWC_I2CM_READ_BUFF0              (DWC_OFFSET_MASK + 0x7E20)
+#define HDMITX_DWC_I2CM_READ_BUFF1              (DWC_OFFSET_MASK + 0x7E21)
+#define HDMITX_DWC_I2CM_READ_BUFF2              (DWC_OFFSET_MASK + 0x7E22)
+#define HDMITX_DWC_I2CM_READ_BUFF3              (DWC_OFFSET_MASK + 0x7E23)
+#define HDMITX_DWC_I2CM_READ_BUFF4              (DWC_OFFSET_MASK + 0x7E24)
+#define HDMITX_DWC_I2CM_READ_BUFF5              (DWC_OFFSET_MASK + 0x7E25)
+#define HDMITX_DWC_I2CM_READ_BUFF6              (DWC_OFFSET_MASK + 0x7E26)
+#define HDMITX_DWC_I2CM_READ_BUFF7              (DWC_OFFSET_MASK + 0x7E27)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE0            (DWC_OFFSET_MASK + 0x7E30)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE1            (DWC_OFFSET_MASK + 0x7E31)
+
+#endif  /* __HDMI_TX_REG_H_ */
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_set.c b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_set.c
new file mode 100644
index 0000000..7bf6c2f
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_set.c
@@ -0,0 +1,2501 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_set.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/register.h>
+#include <amlogic/hdmi.h>
+#include "hdmitx_reg.h"
+#include "hdmitx_tvenc.h"
+#include "mach_reg.h"
+#include "hw_enc_clk_config.h"
+
+struct hdmitx_dev hdmitx_device;
+
+static void hdmi_tvenc_set(enum hdmi_vic vic);
+extern void _udelay(unsigned int us);
+static void hdmitx_set_phy(struct hdmitx_dev *hdev);
+static void set_tmds_clk_div40(unsigned int div40);
+
+#define HSYNC_POLARITY      1                       // HSYNC polarity: active high
+#define VSYNC_POLARITY      1                       // VSYNC polarity: active high
+
+#define TX_INPUT_COLOR_FORMAT   HDMI_COLOR_FORMAT_444   // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+#define TX_INPUT_COLOR_RANGE    HDMI_COLOR_RANGE_LIM    // Pixel range: 0=limited; 1=full.
+#define TX_OUTPUT_COLOR_RANGE   HDMI_COLOR_RANGE_LIM    // Pixel range: 0=limited; 1=full.
+
+// TODO  Delete later
+#define CLK_UTIL_VID_PLL_DIV_1      0
+#define CLK_UTIL_VID_PLL_DIV_2      1
+#define CLK_UTIL_VID_PLL_DIV_3      2
+#define CLK_UTIL_VID_PLL_DIV_3p5    3
+#define CLK_UTIL_VID_PLL_DIV_3p75   4
+#define CLK_UTIL_VID_PLL_DIV_4      5
+#define CLK_UTIL_VID_PLL_DIV_5      6
+#define CLK_UTIL_VID_PLL_DIV_6      7
+#define CLK_UTIL_VID_PLL_DIV_6p25   8
+#define CLK_UTIL_VID_PLL_DIV_7      9
+#define CLK_UTIL_VID_PLL_DIV_7p5    10
+#define CLK_UTIL_VID_PLL_DIV_12     11
+#define CLK_UTIL_VID_PLL_DIV_14     12
+#define CLK_UTIL_VID_PLL_DIV_15     13
+
+static int hdmitx_get_hpd_state(void)
+{
+	int st = 0;
+
+	st = !!(hd_read_reg(P_PREG_PAD_GPIO1_I) & (1 << 20));
+	return st;
+}
+
+static void ddc_pinmux_init(void)
+{
+	hd_set_reg_bits(P_PAD_PULL_UP_EN_REG1, 0, 21, 2);    // Disable GPIOH_1/2 pull-up/down
+	hd_set_reg_bits(P_PAD_PULL_UP_REG1, 0, 21, 2);
+	hd_set_reg_bits(P_PREG_PAD_GPIO1_EN_N, 3, 21, 2);     // GPIOH_1/2 input
+	hd_set_reg_bits(P_PERIPHS_PIN_MUX_6, 3, 29, 2);      // Mux DDC SDA/SCL
+}
+
+static void hdelay(int us)
+{
+	int i;
+	while (us--) {
+		i = 10000;
+		while (i--) ;
+	}
+}
+
+#define mdelay(i)   hdelay(i)
+#define msleep(i)   hdelay(i)
+
+static void hdmitx_set_hw(struct hdmitx_dev *hdev);
+
+// Internal functions:
+static void hdmitx_csc_config (unsigned char input_color_format,
+                        unsigned char output_color_format,
+                        unsigned char color_depth);
+
+static void dump_regs(void)
+{
+	unsigned int reg_adr;
+	unsigned int reg_val;
+	unsigned int ladr;
+	for (reg_adr = 0x0000; reg_adr < 0x0100; reg_adr ++) {
+                ladr = 0xc883c000 + (reg_adr << 2);
+		reg_val = hd_read_reg(ladr);
+		printk("[0x%08x] = 0x%X\n", ladr, reg_val);
+	}
+#define VPU_REG_ADDR(reg) (0xd0100000 + (reg << 2))
+	for (reg_adr = 0x1b00; reg_adr < 0x1c00; reg_adr ++) {
+		ladr = VPU_REG_ADDR(reg_adr);
+		reg_val = hd_read_reg(ladr);
+		printk("[0x%08x] = 0x%X\n", ladr, reg_val);
+	}
+	for (reg_adr = 0x1c01; reg_adr < 0x1d00; reg_adr ++) {
+		ladr = VPU_REG_ADDR(reg_adr);
+		reg_val = hd_read_reg(ladr);
+		printk("[0x%08x] = 0x%X\n", ladr, reg_val);
+	}
+	for (reg_adr = 0x2700; reg_adr < 0x2780; reg_adr ++) {
+		ladr = VPU_REG_ADDR(reg_adr);
+		reg_val = hd_read_reg(ladr);
+		printk("[0x%08x] = 0x%X\n", ladr, reg_val);
+	}
+	for (reg_adr = HDMITX_TOP_SW_RESET; reg_adr < HDMITX_TOP_STAT0 + 1; reg_adr ++) {
+		reg_val = hdmitx_rd_reg(reg_adr);
+		printk("TOP[0x%x]: 0x%x\n", reg_adr, reg_val);
+	}
+	for (reg_adr = HDMITX_DWC_DESIGN_ID; reg_adr < HDMITX_DWC_I2CM_SCDC_UPDATE1 + 1; reg_adr ++) {
+		if ((reg_adr > HDMITX_DWC_HDCP_BSTATUS_0 -1) && (reg_adr < HDMITX_DWC_HDCPREG_BKSV0)) {
+            //hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x1);
+//            hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1<<1), 2 * HZ);
+			reg_val = 0;//hdmitx_rd_reg(reg_adr);
+		} else {
+			reg_val = hdmitx_rd_reg(reg_adr);
+		}
+		if (reg_val) {
+			// excluse HDCP regisiters
+			if ((reg_adr < HDMITX_DWC_A_HDCPCFG0) || (reg_adr > HDMITX_DWC_CEC_CTRL))
+				printk("DWC[0x%x]: 0x%x\n", reg_adr, reg_val);
+		}
+	}
+}
+
+static void hdmitx_hw_init(void)
+{
+	static int hw_init_flag;
+
+	if (hw_init_flag)
+		return;
+	else
+		hw_init_flag = 1;
+
+	/* Enable clocks and bring out of reset */
+
+	/* Enable hdmitx_sys_clk */
+	/* .clk0 ( cts_oscin_clk ), */
+	/* .clk1 ( fclk_div4 ), */
+	/* .clk2 ( fclk_div3 ), */
+	/* .clk3 ( fclk_div5 ), */
+	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 0x0100, 0, 16);
+
+	/* Enable clk81_hdmitx_pclk */
+	hd_set_reg_bits(P_HHI_GCLK_MPEG2, 1, 4, 1);
+
+	/* wire	wr_enable = control[3]; */
+	/* wire	fifo_enable = control[2]; */
+	/* assign phy_clk_en = control[1]; */
+	/* Enable tmds_clk */
+	/* Bring HDMITX MEM output of power down */
+	hd_set_reg_bits(P_HHI_MEM_PD_REG0, 0, 8, 8);
+	/* reset HDMITX APB & TX & PHY */
+	hd_set_reg_bits(P_RESET0_REGISTER, 1, 19, 1);
+	hd_set_reg_bits(P_RESET2_REGISTER, 1, 15, 1);
+	hd_set_reg_bits(P_RESET2_REGISTER, 1,  2, 1);
+	// Enable APB3 fail on error
+	hd_set_reg_bits(P_HDMITX_CTRL_PORT, 1, 15, 1);
+	hd_set_reg_bits((P_HDMITX_CTRL_PORT + 0x10), 1, 15, 1);
+	/* Bring out of reset */
+	hdmitx_wr_reg(HDMITX_TOP_SW_RESET,  0);
+	_udelay(200);
+	/* Enable internal pixclk, tmds_clk, spdif_clk, i2s_clk, cecclk */
+	hdmitx_wr_reg(HDMITX_TOP_CLK_CNTL,  0x000000ff);
+	hdmitx_wr_reg(HDMITX_DWC_MC_LOCKONCLOCK, 0xff);
+
+	hdmitx_wr_reg(HDMITX_DWC_MC_CLKDIS, 0x00);
+}
+
+/*
+ * Note: read 8 Bytes of EDID data every time
+ */
+static int read_edid_8bytes(unsigned char *rx_edid, unsigned char addr)
+{
+	unsigned int timeout = 0;
+	unsigned int i = 0;
+	// Program SLAVE/SEGMENT/ADDR
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE, 0x50);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGADDR, 0x30);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGPTR, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, addr & 0xff);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1 << 3);
+	timeout = 0;
+	while ((!(hdmitx_rd_reg(HDMITX_DWC_IH_I2CM_STAT0) & (1 << 1))) && (timeout < 3)) {
+		mdelay(2);
+		timeout ++;
+	}
+	if (timeout == 3) {
+		printk("ddc timeout\n");
+		return 0;
+	}
+	hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0, 1 << 1);        // clear INT
+	// Read back 8 bytes
+	for (i = 0; i < 8; i ++) {
+		rx_edid[i] = hdmitx_rd_reg(HDMITX_DWC_I2CM_READ_BUFF0 + i);
+	}
+	return 1;
+}
+
+static void ddc_init(void)
+{
+	static int ddc_init_flag;
+	unsigned int data32 = 0;
+
+
+	if (ddc_init_flag)
+		return;
+	else
+		ddc_init_flag = 1;
+
+	ddc_pinmux_init();
+
+	data32  = 0;
+	data32 |= (0    << 6);  // [  6] read_req_mask
+	data32 |= (0    << 2);  // [  2] done_mask
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_INT,      data32);
+
+	data32  = 0;
+	data32 |= (0    << 6);  // [  6] nack_mask
+	data32 |= (0    << 2);  // [  2] arbitration_error_mask
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_CTLINT,   data32);
+
+	data32  = 0;
+	data32 |= (0    << 3);  // [  3] i2c_fast_mode: 0=standard mode; 1=fast mode.
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_DIV,      data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_HCNT_1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_HCNT_0, 0x67);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_LCNT_1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_LCNT_0, 0x78);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_HCNT_1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_HCNT_0, 0x0f);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_LCNT_1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_LCNT_0, 0x20);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SDA_HOLD,	0x08);
+
+	data32  = 0;
+	data32 |= (0    << 5);  // [  5] updt_rd_vsyncpoll_en
+	data32 |= (0    << 4);  // [  4] read_request_en  // scdc
+	data32 |= (0    << 0);  // [  0] read_update
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SCDC_UPDATE,  data32);
+}
+
+static int hdmitx_read_edid(unsigned char *buf, unsigned char addr, unsigned char size)
+{
+	ddc_init();
+	if ((addr + size) > 256)
+		return 0;
+	return read_edid_8bytes(buf, addr);
+}
+
+static void scdc_rd_sink(unsigned char adr, unsigned char *val)
+{
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE, 0x54);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, adr);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1);
+	_udelay(2000);
+	*val = (unsigned char)hdmitx_rd_reg(HDMITX_DWC_I2CM_DATAI);
+}
+
+static void scdc_wr_sink(unsigned char adr, unsigned char val)
+{
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE, 0x54);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS, adr);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_DATAO, val);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 0x10);
+	_udelay(2000);
+}
+
+static void scdc_prepare(unsigned int div)
+{
+	unsigned char rx_ver = 0;
+
+	scdc_rd_sink(SINK_VER, &rx_ver);
+	if (rx_ver != 1)
+		scdc_rd_sink(SINK_VER, &rx_ver);	/* Recheck */
+	printf("rx version is %s  div=%d\n",
+		(rx_ver == 1) ? "2.0" : "1.4 or below",
+		div ? 40 : 10);
+
+	scdc_wr_sink(SOURCE_VER, 0x1);
+	scdc_wr_sink(SOURCE_VER, 0x1);
+	scdc_wr_sink(TMDS_CFG, div ? 0x3 : 0); /* TMDS 1/40 & Scramble */
+	scdc_wr_sink(TMDS_CFG, div ? 0x3 : 0); /* TMDS 1/40 & Scramble */
+}
+
+static void hdmitx_turnoff(void)
+{
+        /* Close HDMITX PHY */
+        hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0);
+        hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0);
+        /* Disable HPLL */
+        hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0);
+}
+
+static struct hdmi_support_mode gxbb_modes[] = {
+	{HDMI_3840x2160p60_16x9, "2160p60hz", 0},
+	{HDMI_3840x2160p50_16x9, "2160p50hz", 0},
+	{HDMI_3840x2160p30_16x9, "2160p30hz", 0},
+	{HDMI_3840x2160p25_16x9, "2160p25hz", 0},
+	{HDMI_3840x2160p24_16x9, "2160p24hz", 0},
+	{HDMI_4096x2160p60_256x135, "smpte60hz", 0},
+	{HDMI_4096x2160p50_256x135, "smpte50hz", 0},
+	{HDMI_4096x2160p30_256x135, "smpte30hz", 0},
+	{HDMI_4096x2160p25_256x135, "smpte25hz", 0},
+	{HDMI_4096x2160p24_256x135, "smpte24hz", 0},
+	{HDMI_3840x2160p60_16x9, "2160p60hz420", 1},
+	{HDMI_3840x2160p50_16x9, "2160p50hz420", 1},
+	{HDMI_4096x2160p50_256x135, "smpte50hz420", 1},
+	{HDMI_4096x2160p60_256x135, "smpte60hz420", 1},
+	{HDMI_1920x1080p60_16x9, "1080p60hz", 0},
+	{HDMI_1920x1080p50_16x9, "1080p50hz", 0},
+	{HDMI_1920x1080p30_16x9, "1080p30hz", 0},
+	{HDMI_1920x1080p25_16x9, "1080p25hz", 0},
+	{HDMI_1920x1080p24_16x9, "1080p24hz", 0},
+	{HDMI_1920x1080i60_16x9, "1080i60hz", 0},
+	{HDMI_1920x1080i50_16x9, "1080i50hz", 0},
+	{HDMI_1280x720p60_16x9, "720p60hz", 0},
+	{HDMI_1280x720p50_16x9, "720p50hz", 0},
+	{HDMI_720x576p50_16x9, "576p50hz", 0},
+	{HDMI_720x480p60_16x9, "480p60hz", 0},
+	{HDMI_720x576i50_16x9, "576i50hz", 0},
+	{HDMI_720x480i60_16x9, "480i60hz", 0},
+};
+
+static void hdmitx_list_support_modes(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(gxbb_modes); i++)
+		printf("%s\n", gxbb_modes[i].sname);
+}
+
+static void hdmitx_test_bist(unsigned int mode)
+{
+	switch (mode) {
+	case 1:
+	case 2:
+	case 3:
+		hd_set_reg_bits(P_ENCP_VIDEO_MODE_ADV, 0, 3, 1);
+		hd_write_reg(P_VENC_VIDEO_TST_EN, 1);
+		hd_write_reg(P_VENC_VIDEO_TST_MDSEL, mode);
+		break;
+	case 0:
+	default:
+		hd_set_reg_bits(P_ENCP_VIDEO_MODE_ADV, 1, 3, 1);
+		hd_write_reg(P_VENC_VIDEO_TST_EN, 0);
+		break;
+	}
+}
+
+static void hdmitx_output_blank(unsigned int blank)
+{
+	if (blank == 1)
+		hd_write_reg(P_VPU_HDMI_DATA_OVR,
+			((1 << 31) | (1 << 29) | (1 << 9)));
+	if (blank == 0)
+		hd_write_reg(P_VPU_HDMI_DATA_OVR, 0);
+}
+
+void hdmi_tx_init(void)
+{
+	hdmitx_device.HWOp.get_hpd_state = hdmitx_get_hpd_state;
+	hdmitx_device.HWOp.read_edid = hdmitx_read_edid;
+	hdmitx_device.HWOp.turn_off = hdmitx_turnoff;
+	hdmitx_device.HWOp.list_support_modes = hdmitx_list_support_modes;
+	hdmitx_device.HWOp.dump_regs = dump_regs;
+	hdmitx_device.HWOp.test_bist = hdmitx_test_bist;
+	hdmitx_device.HWOp.output_blank = hdmitx_output_blank;
+}
+
+void hdmi_tx_set(struct hdmitx_dev *hdev)
+{
+	hdmitx_hw_init();
+	hdmitx_debug();
+	ddc_init();
+	hdmitx_set_hw(hdev);
+	hdmitx_debug();
+	return;
+
+#if 0
+	hdmi_tx_gate(vic);
+	hdmi_tx_clk(vic);
+	hdmi_tx_misc(vic);
+	hdmi_tx_enc(vic);
+	hdmi_tx_set_vend_spec_infofram(vic);
+	hdmi_tx_phy(vic);
+#endif
+}
+
+#define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
+static void hdcp14_init(void)
+{
+	register long x0 asm("x0") = 0x82000012;
+	asm volatile(
+		__asmeq("%0", "x0")
+		"smc #0\n"
+		: : "r"(x0)
+	);
+}
+
+#define NUM_INT_VSYNC   INT_VEC_VIU1_VSYNC
+
+static unsigned long modulo(unsigned long a, unsigned long b);
+static signed int to_signed(unsigned int a);
+
+static void config_hdmi20_tx ( enum hdmi_vic vic, struct hdmi_format_para *para,
+                        unsigned char   color_depth,            // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+                        unsigned char   input_color_format,     // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                        unsigned char   input_color_range,      // Pixel range: 0=limited; 1=full.
+                        unsigned char   output_color_format,    // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                        unsigned char   output_color_range     // Pixel range: 0=limited; 1=full.
+                    )          // 0:TMDS_CLK_rate=TMDS_Character_rate; 1:TMDS_CLK_rate=TMDS_Character_rate/4, for TMDS_Character_rate>340Mcsc.
+{
+	struct hdmi_cea_timing *t = &para->timing;
+	unsigned long   data32;
+	unsigned char   vid_map;
+	unsigned char   csc_en;
+	unsigned char   default_phase = 0;
+	unsigned char   tmp = 0;
+
+#define GET_TIMING(name)      (t->name)
+
+	hdmitx_hw_init();
+
+	data32  = 0;
+	data32 |= (1 << 12);
+	data32 |= (0 << 8);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_TOP_BIST_CNTL, data32);
+
+	/* Configure video */
+
+	// Configure video sampler
+    vid_map = ( input_color_format == HDMI_COLOR_FORMAT_RGB )?  ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x01    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x03    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_36B)? 0x05    :
+                                                                                                        0x07)   :
+              ((input_color_format == HDMI_COLOR_FORMAT_444) ||
+               (input_color_format == HDMI_COLOR_FORMAT_420))?  ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x09    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x0b    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_36B)? 0x0d    :
+                                                                                                        0x0f)   :
+                                                                ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x16    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x14    :
+                                                                                                        0x12);
+
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (vid_map << 0);
+	hdmitx_wr_reg(HDMITX_DWC_TX_INVID0, data32);
+
+	data32  = 0;
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_TX_INSTUFFING, data32);
+	hdmitx_wr_reg(HDMITX_DWC_TX_GYDATA0, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_GYDATA1, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_RCRDATA0, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_RCRDATA1, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_BCBDATA0, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_TX_BCBDATA1, 0x00);
+
+	/* Configure Color Space Converter */
+
+	csc_en  = (input_color_format != output_color_format) ? 1 : 0;
+
+	data32  = 0;
+	data32 |= (csc_en   << 0);
+	hdmitx_wr_reg(HDMITX_DWC_MC_FLOWCTRL, data32);
+
+    data32  = 0;
+    data32 |= ((((input_color_format ==HDMI_COLOR_FORMAT_422) &&
+                 (output_color_format!=HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 4);  // [5:4] intmode
+    data32 |= ((((input_color_format !=HDMI_COLOR_FORMAT_422) &&
+                 (output_color_format==HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 0);  // [1:0] decmode
+	hdmitx_wr_reg(HDMITX_DWC_CSC_CFG, data32);
+
+	hdmitx_csc_config(input_color_format, output_color_format, color_depth);
+
+	/* Configure video packetizer */
+
+	/* Video Packet color depth and pixel repetition */
+	data32  = 0;
+	data32 |= (((output_color_format==HDMI_COLOR_FORMAT_422)? HDMI_COLOR_DEPTH_24B : color_depth)   << 4);  // [7:4] color_depth
+	data32 |= (0 << 0);
+	if ((data32 & 0xf0) == 0x40 )
+		data32 &= ~(0xf << 4);
+	hdmitx_wr_reg(HDMITX_DWC_VP_PR_CD, data32);
+	if (output_color_format == HDMI_COLOR_FORMAT_422) {
+		switch (color_depth) {
+		case HDMI_COLOR_DEPTH_24B:
+			tmp = 4;
+			break;
+		default:
+			tmp = 0;
+			break;
+		}
+		hdmitx_set_reg_bits(HDMITX_DWC_VP_PR_CD, tmp, 4, 4);
+	}
+
+	/* Video Packet Stuffing */
+	data32  = 0;
+	data32 |= (default_phase << 5);
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_VP_STUFF,  data32);
+
+	/* Video Packet YCC color remapping */
+	data32  = 0;
+	hdmitx_wr_reg(HDMITX_DWC_VP_REMAP, data32);
+	if (output_color_format == HDMI_COLOR_FORMAT_422) {
+		switch (color_depth) {
+		case HDMI_COLOR_DEPTH_36B:
+			tmp = 2;
+			break;
+		case HDMI_COLOR_DEPTH_30B:
+			tmp = 1;
+			break;
+		case HDMI_COLOR_DEPTH_24B:
+			tmp = 0;
+			break;
+		}
+	}
+	hdmitx_set_reg_bits(HDMITX_DWC_VP_REMAP, tmp, 0, 2);  // [1:0] ycc422_size
+
+	/* Video Packet configuration */
+	data32  = 0;
+	data32 |= ((((output_color_format != HDMI_COLOR_FORMAT_422) &&
+		(color_depth == HDMI_COLOR_DEPTH_24B))? 1 : 0) << 6);  // [  6] bypass_en
+	data32 |= ((((output_color_format == HDMI_COLOR_FORMAT_422) ||
+		(color_depth == HDMI_COLOR_DEPTH_24B))? 0 : 1) << 5);  // [  5] pp_en
+	data32 |= (0 << 4);  // [  4] pr_en
+	data32 |= (((output_color_format == HDMI_COLOR_FORMAT_422)?  1 : 0) << 3);  // [  3] ycc422_en
+	data32 |= (1 << 2);  // [  2] pr_bypass_select
+	data32 |= (((output_color_format == HDMI_COLOR_FORMAT_422)? 1 :
+		(color_depth == HDMI_COLOR_DEPTH_24B)?  2 : 0)  << 0);  // [1:0] output_selector: 0=pixel packing; 1=YCC422 remap; 2/3=8-bit bypass
+	hdmitx_wr_reg(HDMITX_DWC_VP_CONF, data32);
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_VP_MASK, data32);
+
+	/* Configure audio */
+	/* I2S Sampler config */
+
+	data32  = 0;
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT, data32);
+
+	data32  = 0;
+	data32 |= (1 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_INT1,  data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_MULTISTREAM_CTRL, 0);
+
+/* if enable it now, fifo_overrun will happen, because packet don't get
+ * sent out until initial DE detected.
+ */
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (1 << 5);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF0, data32);
+
+	data32  = 0;
+	data32 |= (0 << 5);
+	data32 |= (24   << 0);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF1, data32);
+
+	data32  = 0;
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_CONF2, data32);
+
+	/* spdif sampler config */
+
+	data32  = 0;
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT,  data32);
+
+	data32  = 0;
+	data32 |= (0 << 4);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT1, data32);
+
+	data32  = 0;
+	data32 |= (0 << 7);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF0,	data32);
+
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (0 << 6);
+	data32 |= (24 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF1,	data32);
+
+	/* Frame Composer configuration */
+
+	/* Video definitions, as per output video(for packet gen/schedulling) */
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (GET_TIMING(vsync_polarity) << 6);
+	data32 |= (GET_TIMING(hsync_polarity) << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (!(para->progress_mode) << 1);
+	data32 |= (!(para->progress_mode) << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVIDCONF,  data32);
+
+	data32  = GET_TIMING(h_active)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV0,   data32);
+	data32  = (GET_TIMING(h_active)>>8) & 0x3f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV1,   data32);
+
+	data32  = GET_TIMING(h_blank) & 0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK0,  data32);
+	data32  = (GET_TIMING(h_blank)>>8)&0x1f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK1,  data32);
+
+	data32  = GET_TIMING(v_active)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV0,   data32);
+	data32  = (GET_TIMING(v_active)>>8)&0x1f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV1,   data32);
+
+	data32  = GET_TIMING(v_blank)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVBLANK,   data32);
+
+	data32  = GET_TIMING(h_front)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY0,  data32);
+	data32  = (GET_TIMING(h_front)>>8)&0x1f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY1,  data32);
+
+	data32  = GET_TIMING(h_sync)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH0,  data32);
+	data32  = (GET_TIMING(h_sync)>>8)&0x3;
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH1,  data32);
+
+	data32  = GET_TIMING(v_front)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSYNCINDELAY,   data32);
+
+	data32  = GET_TIMING(v_sync)&0x3f;
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSYNCINWIDTH,   data32);
+
+	/* control period duration (typ 12 tmds periods) */
+	hdmitx_wr_reg(HDMITX_DWC_FC_CTRLDUR,	12);
+	/* extended control period duration (typ 32 tmds periods) */
+	hdmitx_wr_reg(HDMITX_DWC_FC_EXCTRLDUR,  32);
+	/* max interval betwen extended control period duration (typ 50) */
+	hdmitx_wr_reg(HDMITX_DWC_FC_EXCTRLSPAC, 1);
+	/* preamble filler */
+	hdmitx_wr_reg(HDMITX_DWC_FC_CH0PREAM, 0x0b);
+	hdmitx_wr_reg(HDMITX_DWC_FC_CH1PREAM, 0x16);
+	hdmitx_wr_reg(HDMITX_DWC_FC_CH2PREAM, 0x21);
+
+	/* write GCP packet configuration */
+	data32  = 0;
+	data32 |= (default_phase << 2);
+	data32 |= (0 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_GCP, data32);
+
+	/* write AVI Infoframe packet configuration */
+
+	data32  = 0;
+	data32 |= (((output_color_format>>2)&0x1) << 7);
+	data32 |= (1 << 6);
+	data32 |= (0 << 4);
+	data32 |= (0 << 2);
+	data32 |= (0x2 << 0);    /* FIXED YCBCR 444 */
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF0, data32);
+	switch (output_color_format) {
+	case HDMI_COLOR_FORMAT_RGB:
+		tmp = 0;
+		break;
+	case HDMI_COLOR_FORMAT_422:
+		tmp = 1;
+		break;
+	case HDMI_COLOR_FORMAT_420:
+		tmp = 3;
+		break;
+	case HDMI_COLOR_FORMAT_444:
+	default:
+		tmp = 2;
+		break;
+	}
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF0, tmp, 0, 2);
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF1, 0x8);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF2, 0);
+
+	/* set Aspect Ratio in AVIInfo */
+	switch (para->vic) {
+	case HDMI_640x480p60_4x3:
+	case HDMI_720x480p60_4x3:
+	case HDMI_720x480i60_4x3:
+	case HDMI_720x240p60_4x3:
+	case HDMI_2880x480i60_4x3:
+	case HDMI_2880x240p60_4x3:
+	case HDMI_1440x480p60_4x3:
+	case HDMI_720x576p50_4x3:
+	case HDMI_720x576i50_4x3:
+	case HDMI_720x288p_4x3:
+	case HDMI_2880x576i50_4x3:
+	case HDMI_2880x288p50_4x3:
+	case HDMI_1440x576p_4x3:
+	case HDMI_2880x480p60_4x3:
+	case HDMI_2880x576p50_4x3:
+	case HDMI_720x576p100_4x3:
+	case HDMI_720x576i100_4x3:
+	case HDMI_720x480p120_4x3:
+	case HDMI_720x480i120_4x3:
+	case HDMI_720x576p200_4x3:
+	case HDMI_720x576i200_4x3:
+	case HDMI_720x480p240_4x3:
+	case HDMI_720x480i240_4x3:
+		/* Picture Aspect Ratio M1/M0 4:3 */
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 0x1, 4, 2);
+		break;
+	default:
+		/* Picture Aspect Ratio M1/M0 16:9 */
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 0x2, 4, 2);
+		break;
+	}
+	/* Active Format Aspect Ratio R3~R0 Same as picture aspect ratio */
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 0x8, 0, 4);
+
+	/* set Colorimetry in AVIInfo */
+	switch (para->vic) {
+	case HDMI_640x480p60_4x3:
+	case HDMI_720x480p60_4x3:
+	case HDMI_720x480p60_16x9:
+	case HDMI_720x480i60_4x3:
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x240p60_4x3:
+	case HDMI_720x240p60_16x9:
+	case HDMI_2880x480i60_4x3:
+	case HDMI_2880x480i60_16x9:
+	case HDMI_2880x240p60_4x3:
+	case HDMI_2880x240p60_16x9:
+	case HDMI_1440x480p60_4x3:
+	case HDMI_1440x480p60_16x9:
+	case HDMI_720x576p50_4x3:
+	case HDMI_720x576p50_16x9:
+	case HDMI_720x576i50_4x3:
+	case HDMI_720x576i50_16x9:
+	case HDMI_720x288p_4x3:
+	case HDMI_720x288p_16x9:
+	case HDMI_2880x576i50_4x3:
+	case HDMI_2880x576i50_16x9:
+	case HDMI_2880x288p50_4x3:
+	case HDMI_2880x288p50_16x9:
+	case HDMI_1440x576p_4x3:
+	case HDMI_1440x576p_16x9:
+	case HDMI_2880x480p60_4x3:
+	case HDMI_2880x480p60_16x9:
+	case HDMI_2880x576p50_4x3:
+	case HDMI_2880x576p50_16x9:
+	case HDMI_720x576p100_4x3:
+	case HDMI_720x576p100_16x9:
+	case HDMI_720x576i100_4x3:
+	case HDMI_720x576i100_16x9:
+	case HDMI_720x480p120_4x3:
+	case HDMI_720x480p120_16x9:
+	case HDMI_720x480i120_4x3:
+	case HDMI_720x480i120_16x9:
+	case HDMI_720x576p200_4x3:
+	case HDMI_720x576p200_16x9:
+	case HDMI_720x576i200_4x3:
+	case HDMI_720x576i200_16x9:
+	case HDMI_720x480p240_4x3:
+	case HDMI_720x480p240_16x9:
+	case HDMI_720x480i240_4x3:
+	case HDMI_720x480i240_16x9:
+		/* C1C0 601 */
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 1, 6, 2);
+		break;
+	default:
+		/* C1C0 709 */
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 2, 6, 2);
+		break;
+	}
+	switch (para->vic) {
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p30_256x135:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+	case HDMI_3840x2160p24_64x27:
+	case HDMI_3840x2160p25_64x27:
+	case HDMI_3840x2160p30_64x27:
+	case HDMI_3840x2160p50_64x27:
+	case HDMI_3840x2160p60_64x27:
+		if (para->cd != HDMI_COLOR_DEPTH_24B) {
+			/* C1C0 Extended Colorimetry 3 */
+			hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 3, 6, 2);
+			/* Extended Colorimetry EC2/1/0 0 */
+			hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF2, 6, 4, 3);
+		}
+		break;
+	default:
+		break;
+	}
+
+	data32  = 0;
+	data32 |= (((output_color_range == HDMI_COLOR_RANGE_FUL)?1:0)   << 2);  // [3:2] YQ
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF3,   data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, para->vic);
+
+/* the audio setting bellow are only used for I2S audio IEC60958-3 frame
+ * insertion
+ */
+
+
+	/* packet queue priority (auto mode) */
+	hdmitx_wr_reg(HDMITX_DWC_FC_CTRLQHIGH,  15);
+	hdmitx_wr_reg(HDMITX_DWC_FC_CTRLQLOW, 3);
+
+	/* packet scheduller configuration for SPD, VSD, ISRC1/2, ACP. */
+	data32  = 0;
+	data32 |= (0 << 4);
+	data32 |= (0 << 3);
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO0, data32);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO2, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATMAN, 0);
+
+	/* packet scheduller configuration for AVI, GCP, AUDI, ACR. */
+	data32  = 0;
+	data32 |= (0 << 5);
+	data32 |= (0 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO3, data32);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB0,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB1,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB2,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB3,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB4,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB5,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB6,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB7,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB8,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB9,  0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB10, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_RDRB11, 0);
+
+	/* Packet transmission enable */
+	data32  = 0;
+	data32 |= (0 << 6);
+	data32 |= (0 << 5);
+	data32 |= (0 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_PACKET_TX_EN, data32);
+
+	/* For 3D video */
+	data32  = 0;
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_ACTSPC_HDLR_CFG, data32);
+
+	data32  = GET_TIMING(v_active)&0xff;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVACT_2D_0,	data32);
+	data32  = (GET_TIMING(v_active)>>8)&0xf;
+	hdmitx_wr_reg(HDMITX_DWC_FC_INVACT_2D_1,	data32);
+
+	/* Do not enable these interrupt below, we can check them at RX side. */
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_MASK0,  data32);
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_MASK1,  data32);
+
+	data32  = 0;
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_MASK2,  data32);
+
+	/* Pixel repetition ratio the input and output video */
+	data32  = 0;
+	data32 |= ((para->pixel_repetition_factor+1) << 4);
+	data32 |= (para->pixel_repetition_factor << 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_PRCONF, data32);
+
+	/* Configure HDCP */
+	data32  = 0;
+	data32 |= (0 << 7);
+	data32 |= (0 << 6);
+	data32 |= (0 << 4);
+	data32 |= (0 << 3);
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_A_APIINTMSK, data32);
+
+	data32  = 0;
+	data32 |= (0 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 1);
+	hdmitx_wr_reg(HDMITX_DWC_A_VIDPOLCFG,   data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_A_OESSWCFG,    0x40);
+
+	hdcp14_init();
+
+	/* Interrupts */
+	/* Clear interrupts */
+	hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT0,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT1,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT2,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_AS_STAT0,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_PHY_STAT0, 0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0,	0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_CEC_STAT0, 0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_VP_STAT0,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_IH_I2CMPHY_STAT0, 0xff);
+	hdmitx_wr_reg(HDMITX_DWC_A_APIINTCLR,  0xff);
+	hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_STAT, 0xff);
+
+	hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR,	0x0000001f);
+
+	/* Selectively enable/mute interrupt sources */
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT0,  data32);
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 5);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT1,  data32);
+
+	data32  = 0;
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT2,  data32);
+
+	data32  = 0;
+	data32 |= (0 << 4);
+	data32 |= (0 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_AS_STAT0,  data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_PHY_STAT0, 0x3f);
+
+	data32  = 0;
+	data32 |= (0 << 2);
+	data32 |= (1 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_I2CM_STAT0, data32);
+
+	data32  = 0;
+	data32 |= (0 << 6);
+	data32 |= (0 << 5);
+	data32 |= (0 << 4);
+	data32 |= (0 << 3);
+	data32 |= (0 << 2);
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_CEC_STAT0, data32);
+
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_VP_STAT0,  0xff);
+
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0, 0x03);
+
+	data32  = 0;
+	data32 |= (0 << 1);
+	data32 |= (0 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_IH_MUTE, data32);
+
+	data32  = 0;
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (1 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_TOP_INTR_MASKN, data32);
+
+	/* Reset pulse */
+	hdmitx_rd_check_reg(HDMITX_DWC_MC_LOCKONCLOCK, 0xff, 0x9f);
+	hdmitx_wr_reg(HDMITX_DWC_MC_SWRSTZREQ, 0);
+	mdelay(10);
+
+	data32  = 0;
+	data32 |= (1 << 7);
+	data32 |= (1 << 6);
+	data32 |= (1 << 4);
+	data32 |= (1 << 3);
+	data32 |= (1 << 2);
+	data32 |= (0 << 1);
+	data32 |= (1 << 0);
+	hdmitx_wr_reg(HDMITX_DWC_MC_SWRSTZREQ, data32);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSYNCINWIDTH,
+		hdmitx_rd_reg(HDMITX_DWC_FC_VSYNCINWIDTH));
+
+} /* config_hdmi20_tx */
+
+/* Set TV encoder for HDMI */
+static void hdmitx_enc(enum hdmi_vic vic)
+{
+	set_vmode_enc_hw(vic);
+	hdmi_tvenc_set(vic);
+	return;
+}
+
+static void hdmitx_set_pll(struct hdmitx_dev *hdev)
+{
+	if (hdev->para->cs != HDMI_COLOR_FORMAT_422) {
+		switch (hdev->para->cd) {
+		case HDMI_COLOR_DEPTH_30B:
+			hdmitx_set_clk_30b(hdev->vic);
+			break;
+		case HDMI_COLOR_DEPTH_24B:
+		default:
+			set_hdmitx_clk(hdev->vic);
+			break;
+		}
+	} else {
+		set_hdmitx_clk(hdev->vic);
+	}
+        if (hdev->para->cs == HDMI_COLOR_FORMAT_420) {
+		hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 1, 16, 4);
+		if ((hdev->para->cd) == HDMI_COLOR_DEPTH_24B) {
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 1, 21, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 19, 2);
+		} else {
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 21, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 19, 2);
+		}
+	}
+}
+
+static void set_phy_by_mode(unsigned int mode)
+{
+	switch (mode) {
+	case 1: /* 5.94Gbps, 3.7125Gbsp */
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x333d3282);
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2136315b);
+		break;
+	case 2: /* 2.97Gbps */
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33303382);
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2036315b);
+		break;
+	case 3: /* 1.485Gbps, and below */
+	default:
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33303362);
+		hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2016315b);
+		break;
+	}
+}
+
+static void hdmitx_set_phy(struct hdmitx_dev *hdev)
+{
+	if (!hdev)
+		return;
+
+	switch (hdev->vic) {
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+		if ((hdev->para->cs == HDMI_COLOR_FORMAT_420)
+			&& (hdev->para->cd == HDMI_COLOR_DEPTH_24B))
+			set_phy_by_mode(1);
+		else
+			set_phy_by_mode(2);
+		break;
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_3840x2160p24_64x27:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p25_64x27:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p30_64x27:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p30_256x135:
+		if ((hdev->para->cs == HDMI_COLOR_FORMAT_422)
+			|| (hdev->para->cd == HDMI_COLOR_DEPTH_24B))
+			set_phy_by_mode(2);
+		else
+			set_phy_by_mode(1);
+		break;
+	case HDMI_1920x1080p60_16x9:
+	default:
+		set_phy_by_mode(3);
+		break;
+	}
+/* P_HHI_HDMI_PHY_CNTL1	bit[1]: enable clock	bit[0]: soft reset */
+#define RESET_HDMI_PHY() \
+do { \
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0xf, 0, 4); \
+	mdelay(2); \
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0xe, 0, 4); \
+	mdelay(2); \
+} while (0)
+
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0390, 16, 16);
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0, 0, 4);
+	RESET_HDMI_PHY();
+	RESET_HDMI_PHY();
+	RESET_HDMI_PHY();
+#undef RESET_HDMI_PHY
+
+	printk("hdmitx phy setting done\n");
+}
+
+/*
+ * mode: 1 means Progressive;  0 means interlaced
+ */
+static void enc_vpu_bridge_reset(int mode)
+{
+    unsigned int wr_clk = 0;
+
+    printk("%s[%d]\n", __func__, __LINE__);
+    wr_clk = (hd_read_reg(P_VPU_HDMI_SETTING) & 0xf00) >> 8;
+    if (mode) {
+        hd_write_reg(P_ENCP_VIDEO_EN, 0);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 0, 2);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 8, 4);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        mdelay(1);
+        hd_write_reg(P_ENCP_VIDEO_EN, 1);
+        mdelay(1);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, wr_clk, 8, 4);
+        mdelay(1);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 2, 0, 2);  // [    0] src_sel_enci: Enable ENCP output to HDMI
+    } else {
+        hd_write_reg(P_ENCI_VIDEO_EN, 0);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 0, 2);  // [    0] src_sel_enci: Disable ENCI output to HDMI
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 8, 4);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        mdelay(1);
+        hd_write_reg(P_ENCI_VIDEO_EN, 1);
+        mdelay(1);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, wr_clk, 8, 4);
+        mdelay(1);
+        hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 0, 2);  // [    0] src_sel_enci: Enable ENCI output to HDMI
+    }
+}
+
+static void hdmi_tvenc1080i_set(enum hdmi_vic vic)
+{
+	unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2;
+	unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0,
+		PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+	unsigned FRONT_PORCH = 88, HSYNC_PIXELS = 0, ACTIVE_LINES = 0,
+		INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0,
+		VSYNC_LINES = 0;
+	unsigned LINES_F0 = 0, LINES_F1 = 563, BACK_PORCH = 0;
+
+	unsigned long total_pixels_venc = 0;
+	unsigned long active_pixels_venc = 0;
+	unsigned long front_porch_venc = 0;
+	unsigned long hsync_pixels_venc = 0;
+
+	unsigned long de_h_begin = 0, de_h_end = 0;
+	unsigned long de_v_begin_even = 0, de_v_end_even = 0,
+		de_v_begin_odd = 0, de_v_end_odd = 0;
+	unsigned long hs_begin = 0, hs_end = 0;
+	unsigned long vs_adjust = 0;
+	unsigned long vs_bline_evn = 0, vs_eline_evn = 0,
+		vs_bline_odd = 0, vs_eline_odd = 0;
+	unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+	if (vic == HDMI_1920x1080i60_16x9) {
+		INTERLACE_MODE = 1;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 562;
+		LINES_F1 = 563;
+		FRONT_PORCH = 88;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 15;
+	} else if (vic == HDMI_1920x1080i50_16x9) {
+		INTERLACE_MODE = 1;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 562;
+		LINES_F1 = 563;
+		FRONT_PORCH = 528;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 15;
+	}
+	TOTAL_PIXELS = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS);
+	TOTAL_LINES = (LINES_F0+(LINES_F1*INTERLACE_MODE));
+
+	total_pixels_venc = (TOTAL_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	active_pixels_venc = (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	front_porch_venc = (FRONT_PORCH / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	hsync_pixels_venc =
+		(HSYNC_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
+
+	hd_write_reg(P_ENCP_VIDEO_MODE, hd_read_reg(P_ENCP_VIDEO_MODE)|(1<<14));
+
+	/* Program DE timing */
+	de_h_begin = modulo(hd_read_reg(P_ENCP_VIDEO_HAVON_BEGIN) +
+		VFIFO2VD_TO_HDMI_LATENCY, total_pixels_venc);
+	de_h_end  = modulo(de_h_begin + active_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DE_H_BEGIN, de_h_begin);
+	hd_write_reg(P_ENCP_DE_H_END, de_h_end);
+	/* Program DE timing for even field */
+	de_v_begin_even = hd_read_reg(P_ENCP_VIDEO_VAVON_BLINE);
+	de_v_end_even  = de_v_begin_even + ACTIVE_LINES;
+	hd_write_reg(P_ENCP_DE_V_BEGIN_EVEN, de_v_begin_even);
+	hd_write_reg(P_ENCP_DE_V_END_EVEN,  de_v_end_even);
+	/* Program DE timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		de_v_begin_odd = to_signed((
+			hd_read_reg(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4)
+			+ de_v_begin_even + (TOTAL_LINES-1)/2;
+		de_v_end_odd = de_v_begin_odd + ACTIVE_LINES;
+		hd_write_reg(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);/* 583 */
+		hd_write_reg(P_ENCP_DE_V_END_ODD, de_v_end_odd);  /* 1123 */
+	}
+
+	/* Program Hsync timing */
+	if (de_h_end + front_porch_venc >= total_pixels_venc) {
+		hs_begin = de_h_end + front_porch_venc - total_pixels_venc;
+		vs_adjust  = 1;
+	} else {
+		hs_begin = de_h_end + front_porch_venc;
+		vs_adjust  = 0;
+	}
+	hs_end = modulo(hs_begin + hsync_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DVI_HSO_BEGIN,  hs_begin);
+	hd_write_reg(P_ENCP_DVI_HSO_END, hs_end);
+
+	/* Program Vsync timing for even field */
+	if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust))
+		vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES
+			- (1-vs_adjust);
+	else
+		vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES
+			- VSYNC_LINES - (1-vs_adjust);
+
+	vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES);
+	hd_write_reg(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);   /* 0 */
+	hd_write_reg(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);   /* 5 */
+	vso_begin_evn = hs_begin; /* 2 */
+	hd_write_reg(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);  /* 2 */
+	hd_write_reg(P_ENCP_DVI_VSO_END_EVN, vso_begin_evn);  /* 2 */
+	/* Program Vsync timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+		vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+		vso_begin_odd  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_END_ODD, vso_begin_odd);
+	}
+
+	hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+		(0 << 1) |
+		(HSYNC_POLARITY << 2) |
+		(VSYNC_POLARITY << 3) |
+		(0 << 4) |
+		(4 << 5) |
+		(0 << 8) |
+		(0 << 12)
+	);
+	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+
+}
+
+static void hdmi_tvenc4k2k_set(enum hdmi_vic vic)
+{
+	unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2;
+	unsigned long TOTAL_PIXELS = 4400, PIXEL_REPEAT_HDMI = 0,
+		PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 3840;
+	unsigned FRONT_PORCH = 1020, HSYNC_PIXELS = 0, ACTIVE_LINES = 2160,
+		INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0,
+		VSYNC_LINES = 0;
+	unsigned LINES_F0 = 2250, LINES_F1 = 2250, BACK_PORCH = 0;
+
+	unsigned long total_pixels_venc = 0;
+	unsigned long active_pixels_venc = 0;
+	unsigned long front_porch_venc = 0;
+	unsigned long hsync_pixels_venc = 0;
+
+	unsigned long de_h_begin = 0, de_h_end = 0;
+	unsigned long de_v_begin_even = 0, de_v_end_even = 0,
+		de_v_begin_odd = 0, de_v_end_odd = 0;
+	unsigned long hs_begin = 0, hs_end = 0;
+	unsigned long vs_adjust = 0;
+	unsigned long vs_bline_evn = 0, vs_eline_evn = 0, vs_bline_odd = 0,
+		vs_eline_odd = 0;
+	unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+	switch (vic) {
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p60_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (3840*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 176;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 296;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72 + 1;
+		break;
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p50_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (3840*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 1056;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 296;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72 + 1;
+		break;
+	case HDMI_3840x2160p24_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (3840*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 1276;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 296;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72 + 1;
+		break;
+	case HDMI_4096x2160p24_256x135:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (4096*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 1020;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 296;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72 + 1;
+		break;
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p50_256x135:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (4096*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 968;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 128;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72;
+		break;
+	case HDMI_4096x2160p30_256x135:
+	case HDMI_4096x2160p60_256x135:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 0;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS = (4096*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (2160/(1+INTERLACE_MODE));
+		LINES_F0 = 2250;
+		LINES_F1 = 2250;
+		FRONT_PORCH = 88;
+		HSYNC_PIXELS = 88;
+		BACK_PORCH = 128;
+		VSYNC_LINES = 10;
+		SOF_LINES = 72;
+		break;
+	default:
+		printk("hdmitx20: no setting for VIC = %d\n", vic);
+		break;
+	}
+
+	TOTAL_PIXELS = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS);
+	TOTAL_LINES = (LINES_F0+(LINES_F1*INTERLACE_MODE));
+
+	total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	active_pixels_venc = (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	front_porch_venc = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+
+	de_h_begin = modulo(hd_read_reg(P_ENCP_VIDEO_HAVON_BEGIN) +
+		VFIFO2VD_TO_HDMI_LATENCY, total_pixels_venc);
+	de_h_end  = modulo(de_h_begin + active_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DE_H_BEGIN, de_h_begin);
+	hd_write_reg(P_ENCP_DE_H_END, de_h_end);
+	/* Program DE timing for even field */
+	de_v_begin_even = hd_read_reg(P_ENCP_VIDEO_VAVON_BLINE);
+	de_v_end_even  = modulo(de_v_begin_even + ACTIVE_LINES, TOTAL_LINES);
+	hd_write_reg(P_ENCP_DE_V_BEGIN_EVEN, de_v_begin_even);
+	hd_write_reg(P_ENCP_DE_V_END_EVEN,  de_v_end_even);
+	/* Program DE timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		de_v_begin_odd = to_signed(
+			(hd_read_reg(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4)
+			+ de_v_begin_even + (TOTAL_LINES-1)/2;
+		de_v_end_odd = modulo(de_v_begin_odd + ACTIVE_LINES,
+			TOTAL_LINES);
+		hd_write_reg(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
+		hd_write_reg(P_ENCP_DE_V_END_ODD, de_v_end_odd);
+	}
+
+	/* Program Hsync timing */
+	if (de_h_end + front_porch_venc >= total_pixels_venc) {
+		hs_begin = de_h_end + front_porch_venc - total_pixels_venc;
+		vs_adjust  = 1;
+	} else {
+		hs_begin = de_h_end + front_porch_venc;
+		vs_adjust  = 1;
+	}
+	hs_end = modulo(hs_begin + hsync_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DVI_HSO_BEGIN,  hs_begin);
+	hd_write_reg(P_ENCP_DVI_HSO_END, hs_end);
+
+	/* Program Vsync timing for even field */
+	if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust))
+		vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES
+			- (1-vs_adjust);
+	else
+		vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES
+			- VSYNC_LINES - (1-vs_adjust);
+	vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES);
+	hd_write_reg(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);
+	hd_write_reg(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);
+	vso_begin_evn = hs_begin;
+	hd_write_reg(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);
+	hd_write_reg(P_ENCP_DVI_VSO_END_EVN, vso_begin_evn);
+	/* Program Vsync timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+		vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+		vso_begin_odd  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_END_ODD, vso_begin_odd);
+	}
+	hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+			(0 << 1) |
+			(HSYNC_POLARITY << 2) |
+			(VSYNC_POLARITY << 3) |
+			(0 << 4) |
+			(4 << 5) |
+			(0 << 8) |
+			(0 << 12)
+	);
+	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+	hd_write_reg(P_ENCP_VIDEO_EN, 1);
+}
+
+static void hdmi_tvenc480i_set(enum hdmi_vic vic)
+{
+	unsigned long VFIFO2VD_TO_HDMI_LATENCY = 1;
+	unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0,
+		PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+	unsigned FRONT_PORCH = 38, HSYNC_PIXELS = 124, ACTIVE_LINES = 0,
+		INTERLACE_MODE = 0, VSYNC_LINES = 0;
+	unsigned LINES_F0 = 262, LINES_F1 = 263, BACK_PORCH = 114,
+		EOF_LINES = 2;
+
+	unsigned long total_pixels_venc = 0;
+	unsigned long active_pixels_venc = 0;
+	unsigned long front_porch_venc = 0;
+	unsigned long hsync_pixels_venc = 0;
+
+	unsigned long de_h_begin = 0, de_h_end = 0;
+	unsigned long de_v_begin_even = 0, de_v_end_even = 0,
+		de_v_begin_odd = 0, de_v_end_odd = 0;
+	unsigned long hs_begin = 0, hs_end = 0;
+	unsigned long vs_adjust = 0;
+	unsigned long vs_bline_evn = 0, vs_eline_evn = 0,
+		vs_bline_odd = 0, vs_eline_odd = 0;
+	unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+	hd_set_reg_bits(P_HHI_GCLK_OTHER, 1, 8, 1);
+	switch (vic) {
+	case HDMI_720x480i60_16x9:
+		INTERLACE_MODE = 1;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 1;
+		ACTIVE_PIXELS	= (720*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (480/(1+INTERLACE_MODE));
+		LINES_F0 = 262;
+		LINES_F1 = 263;
+		FRONT_PORCH = 38;
+		HSYNC_PIXELS = 124;
+		BACK_PORCH = 114;
+		EOF_LINES = 4;
+		VSYNC_LINES = 3;
+                break;
+	case HDMI_720x576i50_16x9:
+		INTERLACE_MODE = 1;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 1;
+		ACTIVE_PIXELS	= (720*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (576/(1+INTERLACE_MODE));
+		LINES_F0 = 312;
+		LINES_F1 = 313;
+		FRONT_PORCH = 24;
+		HSYNC_PIXELS = 126;
+		BACK_PORCH = 138;
+		EOF_LINES = 2;
+		VSYNC_LINES = 3;
+		break;
+	default:
+		break;
+	}
+
+	TOTAL_PIXELS = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS);
+
+	total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC); /* 1716 / 2 * 2 = 1716 */
+	active_pixels_venc = (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	front_porch_venc = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC); /* 38   / 2 * 2 = 38 */
+	hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC); /* 124  / 2 * 2 = 124 */
+
+	de_h_begin = modulo(hd_read_reg(P_ENCI_VFIFO2VD_PIXEL_START) +
+		VFIFO2VD_TO_HDMI_LATENCY, total_pixels_venc);
+	de_h_end  = modulo(de_h_begin + active_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCI_DE_H_BEGIN, de_h_begin);	/* 235 */
+	hd_write_reg(P_ENCI_DE_H_END, de_h_end);	 /* 1675 */
+
+	de_v_begin_even = hd_read_reg(P_ENCI_VFIFO2VD_LINE_TOP_START);
+	de_v_end_even  = de_v_begin_even + ACTIVE_LINES;
+	de_v_begin_odd = hd_read_reg(P_ENCI_VFIFO2VD_LINE_BOT_START);
+	de_v_end_odd = de_v_begin_odd + ACTIVE_LINES;
+	hd_write_reg(P_ENCI_DE_V_BEGIN_EVEN, de_v_begin_even);
+	hd_write_reg(P_ENCI_DE_V_END_EVEN,  de_v_end_even);
+	hd_write_reg(P_ENCI_DE_V_BEGIN_ODD, de_v_begin_odd);
+	hd_write_reg(P_ENCI_DE_V_END_ODD, de_v_end_odd);
+
+	/* Program Hsync timing */
+	if (de_h_end + front_porch_venc >= total_pixels_venc) {
+		hs_begin = de_h_end + front_porch_venc - total_pixels_venc;
+		vs_adjust  = 1;
+	} else {
+		hs_begin = de_h_end + front_porch_venc;
+		vs_adjust  = 0;
+	}
+	hs_end = modulo(hs_begin + hsync_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCI_DVI_HSO_BEGIN,  hs_begin);  /* 1713 */
+	hd_write_reg(P_ENCI_DVI_HSO_END, hs_end);	/* 121 */
+
+	/* Program Vsync timing for even field */
+	if (de_v_end_odd-1 + EOF_LINES + vs_adjust >= LINES_F1) {
+		vs_bline_evn = de_v_end_odd-1 + EOF_LINES + vs_adjust
+			- LINES_F1;
+		vs_eline_evn = vs_bline_evn + VSYNC_LINES;
+		hd_write_reg(P_ENCI_DVI_VSO_BLINE_EVN, vs_bline_evn);
+		/* vso_bline_evn_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+		/* vso_eline_evn_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_BEGIN_EVN, hs_begin);
+		hd_write_reg(P_ENCI_DVI_VSO_END_EVN, hs_begin);
+	} else {
+		vs_bline_odd = de_v_end_odd-1 + EOF_LINES + vs_adjust;
+		hd_write_reg(P_ENCI_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		/* vso_bline_odd_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_BEGIN_ODD, hs_begin);
+	if (vs_bline_odd + VSYNC_LINES >= LINES_F1) {
+		vs_eline_evn = vs_bline_odd + VSYNC_LINES - LINES_F1;
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+		/* vso_eline_evn_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_END_EVN, hs_begin);
+	} else {
+		vs_eline_odd = vs_bline_odd + VSYNC_LINES;
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		/* vso_eline_odd_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_END_ODD, hs_begin);
+	}
+	}
+	/* Program Vsync timing for odd field */
+	if (de_v_end_even-1 + EOF_LINES + 1 >= LINES_F0) {
+		vs_bline_odd = de_v_end_even-1 + EOF_LINES + 1 - LINES_F0;
+		vs_eline_odd = vs_bline_odd + VSYNC_LINES;
+		hd_write_reg(P_ENCI_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		/* vso_bline_odd_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		/* vso_eline_odd_reg_wr_cnt ++; */
+		vso_begin_odd  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCI_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+		hd_write_reg(P_ENCI_DVI_VSO_END_ODD, vso_begin_odd);
+	} else {
+		vs_bline_evn = de_v_end_even-1 + EOF_LINES + 1;
+		hd_write_reg(P_ENCI_DVI_VSO_BLINE_EVN, vs_bline_evn); /* 261 */
+		/* vso_bline_evn_reg_wr_cnt ++; */
+		vso_begin_evn  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCI_DVI_VSO_BEGIN_EVN, vso_begin_evn);
+	if (vs_bline_evn + VSYNC_LINES >= LINES_F0) {
+		vs_eline_odd = vs_bline_evn + VSYNC_LINES - LINES_F0;
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		/* vso_eline_odd_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_END_ODD, vso_begin_evn);
+	} else {
+		vs_eline_evn = vs_bline_evn + VSYNC_LINES;
+		hd_write_reg(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+		/* vso_eline_evn_reg_wr_cnt ++; */
+		hd_write_reg(P_ENCI_DVI_VSO_END_EVN, vso_begin_evn);
+	}
+	}
+
+	hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+			(0 << 1) |
+			(0 << 2) |
+			(0 << 3) |
+			(0 << 4) |
+			(4 << 5) |
+			(1 << 8) |
+			(1 << 12)
+	);
+	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 0, 1);
+}
+
+static void hdmi_tvenc_set_def(enum hdmi_vic vic)
+{
+        unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2;
+	unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0,
+		PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+	unsigned FRONT_PORCH = 0, HSYNC_PIXELS = 0, ACTIVE_LINES = 0,
+		INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0,
+		VSYNC_LINES = 0;
+	unsigned LINES_F0 = 0, LINES_F1 = 0, BACK_PORCH = 0;
+
+	unsigned long total_pixels_venc = 0;
+	unsigned long active_pixels_venc = 0;
+	unsigned long front_porch_venc = 0;
+	unsigned long hsync_pixels_venc = 0;
+
+	unsigned long de_h_begin = 0, de_h_end = 0;
+	unsigned long de_v_begin_even = 0, de_v_end_even = 0,
+		de_v_begin_odd = 0, de_v_end_odd = 0;
+	unsigned long hs_begin = 0, hs_end = 0;
+	unsigned long vs_adjust = 0;
+	unsigned long vs_bline_evn = 0, vs_eline_evn = 0,
+		vs_bline_odd = 0, vs_eline_odd = 0;
+	unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+        hdmitx_debug();
+	switch (vic) {
+	case HDMI_720x480p60_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS	= (720*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (480/(1+INTERLACE_MODE));
+		LINES_F0 = 525;
+		LINES_F1 = 525;
+		FRONT_PORCH = 16;
+		HSYNC_PIXELS = 62;
+		BACK_PORCH = 60;
+		VSYNC_LINES = 6;
+		SOF_LINES = 30;
+		break;
+	case HDMI_720x576p50_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS	= (720*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (576/(1+INTERLACE_MODE));
+		LINES_F0 = 625;
+		LINES_F1 = 625;
+		FRONT_PORCH = 12;
+		HSYNC_PIXELS = 64;
+		BACK_PORCH = 68;
+		VSYNC_LINES = 5;
+		SOF_LINES = 39;
+		break;
+	case HDMI_1280x720p60_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS	= (1280*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (720/(1+INTERLACE_MODE));
+		LINES_F0 = 750;
+		LINES_F1 = 750;
+		FRONT_PORCH = 110;
+		HSYNC_PIXELS = 40;
+		BACK_PORCH = 220;
+		VSYNC_LINES = 5;
+		SOF_LINES = 20;
+		break;
+	case HDMI_1280x720p50_16x9:
+		INTERLACE_MODE = 0;
+		PIXEL_REPEAT_VENC = 1;
+		PIXEL_REPEAT_HDMI = 0;
+		ACTIVE_PIXELS	= (1280*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (720/(1+INTERLACE_MODE));
+		LINES_F0 = 750;
+		LINES_F1 = 750;
+		FRONT_PORCH = 440;
+		HSYNC_PIXELS = 40;
+		BACK_PORCH = 220;
+		VSYNC_LINES = 5;
+		SOF_LINES = 20;
+		break;
+	case HDMI_1920x1080p50_16x9:
+	case HDMI_1920x1080p25_16x9:
+		INTERLACE_MODE	= 0;
+		PIXEL_REPEAT_VENC  = 0;
+		PIXEL_REPEAT_HDMI  = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 1125;
+		LINES_F1 = 1125;
+		FRONT_PORCH = 528;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 36;
+		break;
+	case HDMI_1920x1080p24_16x9:
+		INTERLACE_MODE	= 0;
+		PIXEL_REPEAT_VENC  = 0;
+		PIXEL_REPEAT_HDMI  = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 1125;
+		LINES_F1 = 1125;
+		FRONT_PORCH = 638;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 36;
+		break;
+	case HDMI_1920x1080p60_16x9:
+	case HDMI_1920x1080p30_16x9:
+		INTERLACE_MODE	= 0;
+		PIXEL_REPEAT_VENC  = 0;
+		PIXEL_REPEAT_HDMI  = 0;
+		ACTIVE_PIXELS = (1920*(1+PIXEL_REPEAT_HDMI));
+		ACTIVE_LINES = (1080/(1+INTERLACE_MODE));
+		LINES_F0 = 1125;
+		LINES_F1 = 1125;
+		FRONT_PORCH = 88;
+		HSYNC_PIXELS = 44;
+		BACK_PORCH = 148;
+		VSYNC_LINES = 5;
+		SOF_LINES = 36;
+		break;
+	default:
+		break;
+	}
+
+	TOTAL_PIXELS = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS);
+	TOTAL_LINES = (LINES_F0+(LINES_F1*INTERLACE_MODE));
+
+	total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	active_pixels_venc = (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	front_porch_venc = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+	hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) *
+		(1+PIXEL_REPEAT_VENC);
+
+	hd_write_reg(P_ENCP_VIDEO_MODE, hd_read_reg(P_ENCP_VIDEO_MODE)|(1<<14));
+	/* Program DE timing */
+	de_h_begin = modulo(hd_read_reg(P_ENCP_VIDEO_HAVON_BEGIN) +
+		VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc);
+	de_h_end  = modulo(de_h_begin + active_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DE_H_BEGIN, de_h_begin);	/* 220 */
+	hd_write_reg(P_ENCP_DE_H_END, de_h_end);	 /* 1660 */
+	/* Program DE timing for even field */
+	de_v_begin_even = hd_read_reg(P_ENCP_VIDEO_VAVON_BLINE);
+	de_v_end_even  = de_v_begin_even + ACTIVE_LINES;
+	hd_write_reg(P_ENCP_DE_V_BEGIN_EVEN, de_v_begin_even);
+	hd_write_reg(P_ENCP_DE_V_END_EVEN,  de_v_end_even);	/* 522 */
+	/* Program DE timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		de_v_begin_odd = to_signed(
+			(hd_read_reg(P_ENCP_VIDEO_OFLD_VOAV_OFST)
+			& 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2;
+		de_v_end_odd = de_v_begin_odd + ACTIVE_LINES;
+		hd_write_reg(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
+		hd_write_reg(P_ENCP_DE_V_END_ODD, de_v_end_odd);
+	}
+
+	/* Program Hsync timing */
+	if (de_h_end + front_porch_venc >= total_pixels_venc) {
+		hs_begin = de_h_end + front_porch_venc - total_pixels_venc;
+		vs_adjust  = 1;
+	} else {
+		hs_begin = de_h_end + front_porch_venc;
+		vs_adjust  = 0;
+	}
+	hs_end = modulo(hs_begin + hsync_pixels_venc, total_pixels_venc);
+	hd_write_reg(P_ENCP_DVI_HSO_BEGIN,  hs_begin);
+	hd_write_reg(P_ENCP_DVI_HSO_END, hs_end);
+
+	/* Program Vsync timing for even field */
+	if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust))
+		vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES -
+			(1-vs_adjust);
+	else
+		vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES -
+			VSYNC_LINES - (1-vs_adjust);
+	vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES);
+	hd_write_reg(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);   /* 5 */
+	hd_write_reg(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);   /* 11 */
+	vso_begin_evn = hs_begin; /* 1692 */
+	hd_write_reg(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);  /* 1692 */
+	hd_write_reg(P_ENCP_DVI_VSO_END_EVN, vso_begin_evn);  /* 1692 */
+	/* Program Vsync timing for odd field if needed */
+	if (INTERLACE_MODE) {
+		vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+		vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+		vso_begin_odd  = modulo(hs_begin + (total_pixels_venc>>1),
+			total_pixels_venc);
+		hd_write_reg(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+		hd_write_reg(P_ENCP_DVI_VSO_END_ODD, vso_begin_odd);
+	}
+	switch (vic) {
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x576i50_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(0 << 2) |
+				(0 << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(1 << 8) |
+				(1 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 0, 1);
+		break;
+	case HDMI_1920x1080i60_16x9:
+	case HDMI_1920x1080i50_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(HSYNC_POLARITY << 2) |
+				(VSYNC_POLARITY << 3) |
+				(0 << 4) |
+				(((TX_INPUT_COLOR_FORMAT == 0) ? 1 : 0) << 5) |
+				(1 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		break;
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p30_256x135:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+			(0 << 1) |
+			(HSYNC_POLARITY << 2) |
+			(VSYNC_POLARITY << 3) |
+			(0 << 4) |
+			(4 << 5) |
+			(0 << 8) |
+			(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		hd_write_reg(P_ENCP_VIDEO_EN, 1); /* Enable VENC */
+		break;
+	case HDMI_720x480p60_16x9:
+	case HDMI_720x576p50_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(0 << 2) |
+				(0 << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(1 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		break;
+	case HDMI_1280x720p60_16x9:
+	case HDMI_1280x720p50_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(HSYNC_POLARITY << 2) |
+				(VSYNC_POLARITY << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(1 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		break;
+	default:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) | /* [	1] src_sel_encp */
+				(HSYNC_POLARITY << 2) |
+				(VSYNC_POLARITY << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(0 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+	}
+	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+}
+
+static void hdmi_tvenc_set(enum hdmi_vic vic)
+{
+	switch (vic) {
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x576i50_16x9:
+		hdmi_tvenc480i_set(vic);
+		break;
+	case HDMI_1920x1080i60_16x9:
+	case HDMI_1920x1080i50_16x9:
+		hdmi_tvenc1080i_set(vic);
+		break;
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p30_256x135:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+		hdmi_tvenc4k2k_set(vic);
+		break;
+	default:
+		hdmi_tvenc_set_def(vic);
+                break;
+	}
+
+	switch (vic) {
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x576i50_16x9:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (0                                 << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (0                                 << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (1                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 0, 1);  // [    0] src_sel_enci: Enable ENCI output to HDMI
+		break;
+	case HDMI_1920x1080i60_16x9:
+	case HDMI_1920x1080i50_16x9:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+		break;
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_4096x2160p24_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p30_256x135:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                  << 0) | // [    0] src_sel_enci
+                     (0                                 << 1) | // [    1] src_sel_encp
+                     (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                     (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                     (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                     (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                //                          0=output CrYCb(BRG);
+                                                                //                          1=output YCbCr(RGB);
+                                                                //                          2=output YCrCb(RBG);
+                                                                //                          3=output CbCrY(GBR);
+                                                                //                          4=output CbYCr(GRB);
+                                                                //                          5=output CrCbY(BGR);
+                                                                //                          6,7=Rsrv.
+                     (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                     (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+		hd_write_reg(P_ENCP_VIDEO_EN, 1); // Enable VENC
+		break;
+	case HDMI_720x480p60_16x9:
+	case HDMI_720x576p50_16x9:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (0                                 << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (0                                 << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+		break;
+	case HDMI_1280x720p60_16x9:
+	case HDMI_1280x720p50_16x9:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+		break;
+	default:
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_write_reg(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                             (0                                 << 1) | // [    1] src_sel_encp
+                             (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                             (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                             (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                             (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                        //                          0=output CrYCb(BRG);
+                                                                        //                          1=output YCbCr(RGB);
+                                                                        //                          2=output YCrCb(RBG);
+                                                                        //                          3=output CbCrY(GBR);
+                                                                        //                          4=output CbYCr(GRB);
+                                                                        //                          5=output CrCbY(BGR);
+                                                                        //                          6,7=Rsrv.
+                             (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                             (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+		);
+		// Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+	}
+}
+
+static void mode420_half_horizontal_para(void)
+{
+	unsigned int hactive = 0;
+	unsigned int hblank = 0;
+	unsigned int hfront = 0;
+	unsigned int hsync = 0;
+
+	printk("%s[%d]\n", __func__, __LINE__);
+	hactive  =  hdmitx_rd_reg(HDMITX_DWC_FC_INHACTV0);
+	hactive += (hdmitx_rd_reg(HDMITX_DWC_FC_INHACTV1) & 0x3f) << 8;
+	hblank  =  hdmitx_rd_reg(HDMITX_DWC_FC_INHBLANK0);
+	hblank += (hdmitx_rd_reg(HDMITX_DWC_FC_INHBLANK1) & 0x1f) << 8;
+	hfront  =  hdmitx_rd_reg(HDMITX_DWC_FC_HSYNCINDELAY0);
+	hfront += (hdmitx_rd_reg(HDMITX_DWC_FC_HSYNCINDELAY1) & 0x1f) << 8;
+	hsync  =  hdmitx_rd_reg(HDMITX_DWC_FC_HSYNCINWIDTH0);
+	hsync += (hdmitx_rd_reg(HDMITX_DWC_FC_HSYNCINWIDTH1) & 0x3) << 8;
+
+	hactive = hactive / 2;
+	hblank = hblank / 2;
+	hfront = hfront / 2;
+	hsync = hsync / 2;
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV0, (hactive & 0xff));
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV1, ((hactive >> 8) & 0x3f));
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK0, (hblank  & 0xff));
+	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK1, ((hblank >> 8) & 0x1f));
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY0, (hfront & 0xff));
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY1, ((hfront >> 8) & 0x1f));
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH0, (hsync & 0xff));
+	hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH1, ((hsync >> 8) & 0x3));
+}
+
+static void set_tmds_clk_div40(unsigned int div40)
+{
+	if (div40 == 1) {
+		hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_01, 0);		  // [25:16] tmds_clk_pttn[19:10]  [ 9: 0] tmds_clk_pttn[ 9: 0]
+		hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_23, 0x03ff03ff); // [25:16] tmds_clk_pttn[39:30]  [ 9: 0] tmds_clk_pttn[29:20]
+	} else {
+		hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_01, 0x001f001f);
+		hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_23, 0x001f001f);
+	}
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_SCRAMBLER_CTRL, (div40 == 1) ? 1 : 0, 0, 1);
+
+	hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x1);			// 0xc
+	msleep(2);
+	hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x2);            // 0xc
+	scdc_prepare((div40 == 1) ? 1:0);
+}
+
+static void hdmitx_set_vsi_pkt(enum hdmi_vic vic)
+{
+	/* convert to HDMI_VIC */
+	if (vic == HDMI_3840x2160p30_16x9)
+		vic = 1;
+	else if (vic == HDMI_3840x2160p25_16x9)
+		vic = 2;
+	else if (vic == HDMI_3840x2160p24_16x9)
+		vic = 3;
+	else
+		vic = 4;
+
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID0, 0x03);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID1, 0x0c);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID2, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD0, 0x20);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD1, vic);
+	hdmitx_wr_reg(HDMITX_DWC_FC_VSDSIZE, 5);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO0, 1, 3, 1);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO1, 0);
+	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO2, 0x10);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 4, 1);
+}
+
+/* record HDMITX current format */
+/* ISA_DEBUG_REG0 0x2600
+ * bit[11]: Y420
+ * bit[10:8]: HDMI VIC
+ * bit[7:0]: CEA VIC
+ */
+static void save_hdmitx_format(enum hdmi_vic vic, int y420)
+{
+	unsigned int data32;
+
+	data32 = vic & 0xff;
+	data32 |= (hdmitx_rd_reg(HDMITX_DWC_FC_VSDPAYLOAD1) & 0x7) << 8;
+	data32 |= (!!y420) << 11;
+	hd_write_reg(P_ISA_DEBUG_REG0, data32);
+}
+
+static void hdmitx_set_vdac(unsigned int enable)
+{
+	if (0 == enable)
+	{
+		hd_write_reg(P_HHI_VDAC_CNTL0, 0);
+		hd_write_reg(P_HHI_VDAC_CNTL1, 8);
+	}
+	else if (1 == enable)
+	{
+		hd_write_reg(P_HHI_VDAC_CNTL0, 1);
+		hd_write_reg(P_HHI_VDAC_CNTL1, 0);
+	}
+
+	return ;
+}
+
+static void hdmitx_set_hw(struct hdmitx_dev* hdev)
+{
+	struct hdmi_format_para *para = NULL;
+
+	para = hdmi_get_fmt_paras(hdev->vic);
+	if (para == NULL) {
+		printk("error at %s[%d]\n", __func__, __LINE__);
+		return;
+	}
+
+	hdmitx_set_pll(hdev);
+	hdmitx_set_phy(hdev);
+	hdmitx_enc(hdev->vic);
+	hdmitx_set_vdac(0);
+
+	// --------------------------------------------------------
+	// Set up HDMI
+	// --------------------------------------------------------
+	config_hdmi20_tx(hdev->vic, para,                     // pixel_repeat,
+		hdev->para->cd,                        // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+		TX_INPUT_COLOR_FORMAT,                 // input_color_format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+		TX_INPUT_COLOR_RANGE,                  // input_color_range: 0=limited; 1=full.
+		hdev->para->cs,                // output_color_format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+		TX_OUTPUT_COLOR_RANGE                 // output_color_range: 0=limited; 1=full.
+		);
+
+	/* switch HDMI_VIC for 2160p30/25/24hz */
+	switch (hdev->vic) {
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_4096x2160p24_256x135:
+		hdmitx_set_vsi_pkt(hdev->vic);
+		break;
+	default:
+		break;
+	}
+
+	/* Using ISA_DEBUG_REG0 to record HDMITX current format */
+	save_hdmitx_format(hdev->vic, (hdev->para->cs == HDMI_COLOR_FORMAT_420));
+
+	hd_write_reg(P_VPU_HDMI_FMT_CTRL,(((TX_INPUT_COLOR_FORMAT==HDMI_COLOR_FORMAT_420)?2:0)  << 0) | // [ 1: 0] hdmi_vid_fmt. 0=444; 1=convert to 422; 2=convert to 420.
+						 (2													 << 2) | // [ 3: 2] chroma_dnsmp. 0=use pixel 0; 1=use pixel 1; 2=use average.
+						 (0													 << 4) | // [	4] dith_en. 1=enable dithering before HDMI TX input.
+						 (0													 << 5) | // [	5] hdmi_dith_md: random noise selector.
+						 (0													 << 6)); // [ 9: 6] hdmi_dith10_cntl.
+	if (hdev->para->cs == HDMI_COLOR_FORMAT_420) {
+		hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 2, 0, 2);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 4, 4);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 8, 1);
+	}
+	switch (hdev->vic) {
+	case HDMI_720x480i60_16x9:
+	case HDMI_720x576i50_16x9:
+		enc_vpu_bridge_reset(0);
+		break;
+	default:
+		enc_vpu_bridge_reset(1);
+		break;
+	}
+
+	//hdmi_hw_reset(hdev, param);
+	// move hdmitx_set_pll() to the end of this function.
+	// hdmitx_set_pll(param);
+
+	if (hdev->para->cs == HDMI_COLOR_FORMAT_420)
+		mode420_half_horizontal_para();
+
+	switch (hdev->vic) {
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+		if ((hdev->para->cs == HDMI_COLOR_FORMAT_420)
+		   && (hdev->para->cd == HDMI_COLOR_DEPTH_24B))
+			set_tmds_clk_div40(0);
+		else
+			set_tmds_clk_div40(1);
+		break;
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_3840x2160p24_64x27:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p25_64x27:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p30_64x27:
+		if ((hdev->para->cs == HDMI_COLOR_FORMAT_422)
+			|| (hdev->para->cd == HDMI_COLOR_DEPTH_24B))
+			set_tmds_clk_div40(0);
+		else
+			set_tmds_clk_div40(1);
+		break;
+	default:
+		set_tmds_clk_div40(0);
+		break;
+	}
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 0, 3, 1);
+	msleep(1);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 1, 3, 1);
+}
+
+// Use this self-made function rather than %, because % appears to produce wrong
+// value for divisor which are not 2's exponential.
+static unsigned long modulo(unsigned long a, unsigned long b)
+{
+	if (a >= b) {
+		return(a-b);
+	} else {
+		return(a);
+	}
+}
+
+static signed int to_signed(unsigned int a)
+{
+	if (a <= 7) {
+		return(a);
+	} else {
+		return(a-16);
+	}
+}
+
+// TODO
+static void hdmitx_csc_config (unsigned char input_color_format,
+                        unsigned char output_color_format,
+                        unsigned char color_depth)
+{
+	unsigned char   conv_en;
+	unsigned long   csc_coeff_a1, csc_coeff_a2, csc_coeff_a3, csc_coeff_a4;
+	unsigned long   csc_coeff_b1, csc_coeff_b2, csc_coeff_b3, csc_coeff_b4;
+	unsigned long   csc_coeff_c1, csc_coeff_c2, csc_coeff_c3, csc_coeff_c4;
+	unsigned char   csc_scale;
+	unsigned long   data32;
+
+	conv_en = (((input_color_format  == HDMI_COLOR_FORMAT_RGB) ||
+                (output_color_format == HDMI_COLOR_FORMAT_RGB)) &&
+               ( input_color_format  != output_color_format))? 1 : 0;
+
+	if (conv_en) {
+		if (output_color_format == HDMI_COLOR_FORMAT_RGB) {
+			csc_coeff_a1    = 0x2000;
+			csc_coeff_a2    = 0x6926;
+			csc_coeff_a3    = 0x74fd;
+			csc_coeff_a4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x010e :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x043b :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x10ee :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x10ee : 0x010e;
+			csc_coeff_b1    = 0x2000;
+			csc_coeff_b2    = 0x2cdd;
+			csc_coeff_b3    = 0x0000;
+			csc_coeff_b4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x7e9a :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x7a65 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x6992 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x6992 : 0x7e9a;
+			csc_coeff_c1    = 0x2000;
+			csc_coeff_c2    = 0x0000;
+			csc_coeff_c3    = 0x38b4;
+			csc_coeff_c4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x7e3b :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x78ea :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x63a6 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x63a6 : 0x7e3b;
+			csc_scale       = 1;
+		} else {    // input_color_format == HDMI_COLOR_FORMAT_RGB
+			csc_coeff_a1    = 0x2591;
+			csc_coeff_a2    = 0x1322;
+			csc_coeff_a3    = 0x074b;
+			csc_coeff_a4    = 0x0000;
+			csc_coeff_b1    = 0x6535;
+			csc_coeff_b2    = 0x2000;
+			csc_coeff_b3    = 0x7acc;
+			csc_coeff_b4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x0200 :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x0800 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x2000 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x2000 : 0x0200;
+			csc_coeff_c1    = 0x6acd;
+			csc_coeff_c2    = 0x7534;
+			csc_coeff_c3    = 0x2000;
+			csc_coeff_c4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x0200 :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x0800 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x2000 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x2000 : 0x0200;
+			csc_scale       = 0;
+		}
+	} else {
+		csc_coeff_a1    = 0x2000;
+		csc_coeff_a2    = 0x0000;
+		csc_coeff_a3    = 0x0000;
+		csc_coeff_a4    = 0x0000;
+		csc_coeff_b1    = 0x0000;
+		csc_coeff_b2    = 0x2000;
+		csc_coeff_b3    = 0x0000;
+		csc_coeff_b4    = 0x0000;
+		csc_coeff_c1    = 0x0000;
+		csc_coeff_c2    = 0x0000;
+		csc_coeff_c3    = 0x2000;
+		csc_coeff_c4    = 0x0000;
+		csc_scale       = 1;
+	}
+
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A1_MSB,   (csc_coeff_a1>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A1_LSB,	csc_coeff_a1&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A2_MSB,   (csc_coeff_a2>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A2_LSB,	csc_coeff_a2&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A3_MSB,   (csc_coeff_a3>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A3_LSB,	csc_coeff_a3&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A4_MSB,   (csc_coeff_a4>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A4_LSB,	csc_coeff_a4&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B1_MSB,   (csc_coeff_b1>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B1_LSB,	csc_coeff_b1&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B2_MSB,   (csc_coeff_b2>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B2_LSB,	csc_coeff_b2&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B3_MSB,   (csc_coeff_b3>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B3_LSB,	csc_coeff_b3&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B4_MSB,   (csc_coeff_b4>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B4_LSB,	csc_coeff_b4&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C1_MSB,   (csc_coeff_c1>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C1_LSB,	csc_coeff_c1&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C2_MSB,   (csc_coeff_c2>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C2_LSB,	csc_coeff_c2&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C3_MSB,   (csc_coeff_c3>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C3_LSB,	csc_coeff_c3&0xff	  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C4_MSB,   (csc_coeff_c4>>8)&0xff  );
+	hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C4_LSB,	csc_coeff_c4&0xff	  );
+
+	data32  = 0;
+	data32 |= (color_depth  << 4);  // [7:4] csc_color_depth
+	data32 |= (csc_scale	<< 0);  // [1:0] cscscale
+	hdmitx_wr_reg(HDMITX_DWC_CSC_SCALE,         data32);
+}   /* hdmitx_csc_config */
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_tvenc.c b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_tvenc.c
new file mode 100644
index 0000000..1de1ea1
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_tvenc.c
@@ -0,0 +1,670 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_tvenc.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "mach_reg.h"
+#include "hdmitx_tvenc.h"
+
+#define MREG_END_MARKER 0xFFFF
+
+static const struct reg_t tvregs_720p[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+
+	{P_VENC_DVI_SETTING, 0x2029},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0019},
+	{P_ENCP_VIDEO_YFP1_HTIME, 648},
+	{P_ENCP_VIDEO_YFP2_HTIME, 3207},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3299},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 80},
+	{P_ENCP_VIDEO_HSPULS_END, 240},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 80},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 688},
+	{P_ENCP_VIDEO_VSPULS_END, 3248},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 4},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 8},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 648},
+	{P_ENCP_VIDEO_HAVON_END, 3207},
+	{P_ENCP_VIDEO_VAVON_BLINE, 29},
+	{P_ENCP_VIDEO_VAVON_ELINE, 748},
+	{P_ENCP_VIDEO_HSO_BEGIN, 256},
+	{P_ENCP_VIDEO_HSO_END, 168},
+	{P_ENCP_VIDEO_VSO_BEGIN, 168},
+	{P_ENCP_VIDEO_VSO_END, 256},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_MAX_LNCNT, 749},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_720p_50hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0x202d},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3959},
+	{P_ENCP_VIDEO_MAX_LNCNT, 749},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 80},
+	{P_ENCP_VIDEO_HSPULS_END, 240},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 80},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 648},
+	{P_ENCP_VIDEO_HAVON_END, 3207},
+	{P_ENCP_VIDEO_HSO_BEGIN, 128},
+	{P_ENCP_VIDEO_HSO_END, 208},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 688},
+	{P_ENCP_VIDEO_VSPULS_END, 3248},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 4},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 8},
+	{P_ENCP_VIDEO_VAVON_BLINE, 29},
+	{P_ENCP_VIDEO_VAVON_ELINE, 748},
+	{P_ENCP_VIDEO_VSO_BEGIN, 128},
+	{P_ENCP_VIDEO_VSO_END, 128},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 648},
+	{P_ENCP_VIDEO_YFP2_HTIME, 3207},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0019},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x407},
+	{P_ENCP_VIDEO_YC_DLY, 0},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_480i[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCI_CFILT_CTRL, 0x12},
+	{P_ENCI_CFILT_CTRL2, 0x12},
+	{P_VENC_DVI_SETTING, 0},
+	{P_ENCI_VIDEO_MODE, 0},
+	{P_ENCI_VIDEO_MODE_ADV, 0},
+	{P_ENCI_SYNC_HSO_BEGIN, 5},
+	{P_ENCI_SYNC_HSO_END, 129},
+	{P_ENCI_SYNC_VSO_EVNLN, 0x0003},
+	{P_ENCI_SYNC_VSO_ODDLN, 0x0104},
+	{P_ENCI_MACV_MAX_AMP, 0x810b},
+	{P_VENC_VIDEO_PROG_MODE, 0xf0},
+	{P_ENCI_VIDEO_MODE, 0x08},
+	{P_ENCI_VIDEO_MODE_ADV, 0x26},
+	{P_ENCI_VIDEO_SCH, 0x20},
+	{P_ENCI_SYNC_MODE, 0x07},
+	{P_ENCI_DBG_PX_RST, 0},
+	{P_ENCI_VFIFO2VD_CTL, 0x4e01},
+	{P_ENCI_VFIFO2VD_PIXEL_START, 0xf3,},
+	{P_ENCI_VFIFO2VD_PIXEL_END, 0x0693,},
+	{P_ENCI_VFIFO2VD_LINE_TOP_START, 0x12,},
+	{P_ENCI_VFIFO2VD_LINE_TOP_END, 0x102,},
+	{P_ENCI_VFIFO2VD_LINE_BOT_START, 0x13,},
+	{P_ENCI_VFIFO2VD_LINE_BOT_END, 0x103,},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x5},
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_480p[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x2052},
+	{P_VENC_DVI_SETTING, 0x21},
+	{P_ENCP_VIDEO_MODE, 0x4000},
+	{P_ENCP_VIDEO_MODE_ADV, 9},
+	{P_ENCP_VIDEO_YFP1_HTIME, 244},
+	{P_ENCP_VIDEO_YFP2_HTIME, 1630},
+	{P_ENCP_VIDEO_MAX_PXCNT, 1715},
+	{P_ENCP_VIDEO_MAX_LNCNT, 524},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 0x22},
+	{P_ENCP_VIDEO_HSPULS_END, 0xa0},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 88},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 0},
+	{P_ENCP_VIDEO_VSPULS_END, 1589},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 5},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 249},
+	{P_ENCP_VIDEO_HAVON_END, 1689},
+	{P_ENCP_VIDEO_VAVON_BLINE, 42},
+	{P_ENCP_VIDEO_VAVON_ELINE, 521},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x07},
+	{P_VENC_VIDEO_PROG_MODE, 0x0},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x3},
+	{P_ENCP_VIDEO_HSO_END, 0x5},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x3},
+	{P_ENCP_VIDEO_VSO_END, 0x5},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_SY_VAL, 8},
+	{P_ENCP_VIDEO_SY2_VAL, 0x1d8},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_576i[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0},
+	{P_ENCI_VIDEO_MODE, 0},
+	{P_ENCI_VIDEO_MODE_ADV, 0},
+	{P_ENCI_SYNC_HSO_BEGIN, 3},
+	{P_ENCI_SYNC_HSO_END, 129},
+	{P_ENCI_SYNC_VSO_EVNLN, 0x0003},
+	{P_ENCI_SYNC_VSO_ODDLN, 0x0104},
+	{P_ENCI_MACV_MAX_AMP, 0x8107},
+	{P_VENC_VIDEO_PROG_MODE, 0xff},
+	{P_ENCI_VIDEO_MODE, 0x13},
+	{P_ENCI_VIDEO_MODE_ADV, 0x26},
+	{P_ENCI_VIDEO_SCH, 0x28},
+	{P_ENCI_SYNC_MODE, 0x07},
+	{P_ENCI_YC_DELAY, 0x333},
+	{P_ENCI_VFIFO2VD_PIXEL_START, 0x010b},
+	{P_ENCI_VFIFO2VD_PIXEL_END, 0x06ab},
+	{P_ENCI_VFIFO2VD_LINE_TOP_START, 0x0016},
+	{P_ENCI_VFIFO2VD_LINE_TOP_END, 0x0136},
+	{P_ENCI_VFIFO2VD_LINE_BOT_START, 0x0017},
+	{P_ENCI_VFIFO2VD_LINE_BOT_END, 0x0137},
+	{P_ENCI_DBG_PX_RST, 0},
+	{P_ENCI_VFIFO2VD_CTL, 0x4e01},
+	{P_ENCI_VFIFO2VD_PIXEL_START, 0x010b},
+	{P_ENCI_VFIFO2VD_PIXEL_END, 0x06ab},
+	{P_ENCI_VFIFO2VD_LINE_TOP_START, 0x0016},
+	{P_ENCI_VFIFO2VD_LINE_TOP_END, 0x0136},
+	{P_ENCI_VFIFO2VD_LINE_BOT_START, 0x0017},
+	{P_ENCI_VFIFO2VD_LINE_BOT_END, 0x0137},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0x5},
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_576p[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x52},
+	{P_VENC_DVI_SETTING, 0x21},
+	{P_ENCP_VIDEO_MODE, 0x4000},
+	{P_ENCP_VIDEO_MODE_ADV, 9},
+	{P_ENCP_VIDEO_YFP1_HTIME, 235},
+	{P_ENCP_VIDEO_YFP2_HTIME, 1674},
+	{P_ENCP_VIDEO_MAX_PXCNT, 1727},
+	{P_ENCP_VIDEO_MAX_LNCNT, 624},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 0},
+	{P_ENCP_VIDEO_HSPULS_END, 0x80},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 88},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 0},
+	{P_ENCP_VIDEO_VSPULS_END, 1599},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 235},
+	{P_ENCP_VIDEO_HAVON_END, 1674},
+	{P_ENCP_VIDEO_VAVON_BLINE, 44},
+	{P_ENCP_VIDEO_VAVON_ELINE, 619},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x07},
+	{P_VENC_VIDEO_PROG_MODE, 0x0},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x80},
+	{P_ENCP_VIDEO_HSO_END, 0x0},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x0},
+	{P_ENCP_VIDEO_VSO_END, 0x5},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_SY_VAL, 8},
+	{P_ENCP_VIDEO_SY2_VAL, 0x1d8},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080i[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0x2029},
+	{P_ENCP_VIDEO_MAX_PXCNT, 4399},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 88},
+	{P_ENCP_VIDEO_HSPULS_END, 264},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 88},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 516},
+	{P_ENCP_VIDEO_HAVON_END, 4355},
+	{P_ENCP_VIDEO_HSO_BEGIN, 264},
+	{P_ENCP_VIDEO_HSO_END, 176},
+	{P_ENCP_VIDEO_EQPULS_BEGIN, 2288},
+	{P_ENCP_VIDEO_EQPULS_END, 2464},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 440},
+	{P_ENCP_VIDEO_VSPULS_END, 2200},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_EQPULS_BLINE, 0},
+	{P_ENCP_VIDEO_EQPULS_ELINE, 4},
+	{P_ENCP_VIDEO_VAVON_BLINE, 20},
+	{P_ENCP_VIDEO_VAVON_ELINE, 559},
+	{P_ENCP_VIDEO_VSO_BEGIN, 88},
+	{P_ENCP_VIDEO_VSO_END, 88},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 516},
+	{P_ENCP_VIDEO_YFP2_HTIME, 4355},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_OFLD_VOAV_OFST, 0x11},
+	{P_ENCP_VIDEO_MODE, 0x5ffc},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0019},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x207},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080i_50hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0x202d},
+	{P_ENCP_VIDEO_MAX_PXCNT, 5279},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 88},
+	{P_ENCP_VIDEO_HSPULS_END, 264},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 88},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 526},
+	{P_ENCP_VIDEO_HAVON_END, 4365},
+	{P_ENCP_VIDEO_HSO_BEGIN, 142},
+	{P_ENCP_VIDEO_HSO_END, 230},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 440},
+	{P_ENCP_VIDEO_VSPULS_END, 2200},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_VAVON_BLINE, 20},
+	{P_ENCP_VIDEO_VAVON_ELINE, 559},
+	{P_ENCP_VIDEO_VSO_BEGIN, 142},
+	{P_ENCP_VIDEO_VSO_END, 142},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 526},
+	{P_ENCP_VIDEO_YFP2_HTIME, 4365},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_OFLD_VOAV_OFST, 0x11},
+	{P_ENCP_VIDEO_MODE, 0x5ffc},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0019},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x7},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080p[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1052},
+	{P_VENC_DVI_SETTING, 0x0001},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0018},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 2060},
+	{P_ENCP_VIDEO_MAX_PXCNT, 2199},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 2067},
+	{P_ENCP_VIDEO_VAVON_BLINE, 41},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1120},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100},
+	{P_ENCP_VIDEO_VSO_END, 2164},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080p_50hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_DVI_SETTING, 0x000d},
+	{P_ENCP_VIDEO_MAX_PXCNT, 2639},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 44},
+	{P_ENCP_VIDEO_HSPULS_END, 132},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 271},
+	{P_ENCP_VIDEO_HAVON_END, 2190},
+	{P_ENCP_VIDEO_HSO_BEGIN, 79},
+	{P_ENCP_VIDEO_HSO_END, 123},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 220},
+	{P_ENCP_VIDEO_VSPULS_END, 2140},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_EQPULS_BLINE, 0},
+	{P_ENCP_VIDEO_EQPULS_ELINE, 4},
+	{P_ENCP_VIDEO_VAVON_BLINE, 41},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1120},
+	{P_ENCP_VIDEO_VSO_BEGIN, 79},
+	{P_ENCP_VIDEO_VSO_END, 79},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 271},
+	{P_ENCP_VIDEO_YFP2_HTIME, 2190},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0018},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x7},
+	{P_ENCP_VIDEO_YC_DLY, 0},
+	{P_ENCP_VIDEO_RGB_CTRL, 2},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_1080p_24hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1052},
+	{P_VENC_DVI_SETTING, 0x000d},
+	{P_ENCP_VIDEO_MAX_PXCNT, 2749},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1124},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 44},
+	{P_ENCP_VIDEO_HSPULS_END, 132},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 271},
+	{P_ENCP_VIDEO_HAVON_END, 2190},
+	{P_ENCP_VIDEO_HSO_BEGIN, 79},
+	{P_ENCP_VIDEO_HSO_END, 123},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 220},
+	{P_ENCP_VIDEO_VSPULS_END, 2140},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_EQPULS_BLINE, 0},
+	{P_ENCP_VIDEO_EQPULS_ELINE, 4},
+	{P_ENCP_VIDEO_VAVON_BLINE, 41},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1120},
+	{P_ENCP_VIDEO_VSO_BEGIN, 79},
+	{P_ENCP_VIDEO_VSO_END, 79},
+	{P_ENCP_VIDEO_VSO_BLINE, 0},
+	{P_ENCP_VIDEO_VSO_ELINE, 5},
+	{P_ENCP_VIDEO_YFP1_HTIME, 271},
+	{P_ENCP_VIDEO_YFP2_HTIME, 2190},
+	{P_VENC_VIDEO_PROG_MODE, 0x100},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0018},
+	{P_ENCP_VIDEO_SYNC_MODE, 0x7},
+	{P_ENCP_VIDEO_YC_DLY, 0},
+	{P_ENCP_VIDEO_RGB_CTRL, 2},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_30hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0008},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 140+3840},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3840+560-1},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156+1920},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059+1920},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 3987},
+	{P_ENCP_VIDEO_VAVON_BLINE, 89},
+	{P_ENCP_VIDEO_VAVON_ELINE, 2248},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156+1920},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100+1920},
+	{P_ENCP_VIDEO_VSO_END, 2164+1920},
+	{P_ENCP_VIDEO_VSO_BLINE, 51},
+	{P_ENCP_VIDEO_VSO_ELINE, 53},
+	{P_ENCP_VIDEO_MAX_LNCNT, 2249},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1000},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_25hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0008},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 140+3840},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3840+1440-1},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156+1920},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059+1920},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 3987},
+	{P_ENCP_VIDEO_VAVON_BLINE, 89},
+	{P_ENCP_VIDEO_VAVON_ELINE, 2248},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156+1920},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100+1920},
+	{P_ENCP_VIDEO_VSO_END, 2164+1920},
+	{P_ENCP_VIDEO_VSO_BLINE, 51},
+	{P_ENCP_VIDEO_VSO_ELINE, 53},
+	{P_ENCP_VIDEO_MAX_LNCNT, 2249},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1000},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_24hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0008},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 140+3840},
+	{P_ENCP_VIDEO_MAX_PXCNT, 3840+1660-1},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156+1920},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059+1920},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 3987},
+	{P_ENCP_VIDEO_VAVON_BLINE, 89},
+	{P_ENCP_VIDEO_VAVON_ELINE, 2248},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156+1920},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100+1920},
+	{P_ENCP_VIDEO_VSO_END, 2164+1920},
+	{P_ENCP_VIDEO_VSO_BLINE, 51},
+	{P_ENCP_VIDEO_VSO_ELINE, 53},
+	{P_ENCP_VIDEO_MAX_LNCNT, 2249},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1000},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_smpte[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x0008},
+	{P_ENCP_VIDEO_YFP1_HTIME, 140},
+	{P_ENCP_VIDEO_YFP2_HTIME, 140+3840+256},
+	{P_ENCP_VIDEO_MAX_PXCNT, 4096+1404-1},
+	{P_ENCP_VIDEO_HSPULS_BEGIN, 2156+1920},
+	{P_ENCP_VIDEO_HSPULS_END, 44},
+	{P_ENCP_VIDEO_HSPULS_SWITCH, 44},
+	{P_ENCP_VIDEO_VSPULS_BEGIN, 140},
+	{P_ENCP_VIDEO_VSPULS_END, 2059+1920},
+	{P_ENCP_VIDEO_VSPULS_BLINE, 0},
+	{P_ENCP_VIDEO_VSPULS_ELINE, 4},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 148},
+	{P_ENCP_VIDEO_HAVON_END, 3987+256},
+	{P_ENCP_VIDEO_VAVON_BLINE, 89},
+	{P_ENCP_VIDEO_VAVON_ELINE, 2248},
+	{P_ENCP_VIDEO_HSO_BEGIN, 44},
+	{P_ENCP_VIDEO_HSO_END, 2156+1920+256},
+	{P_ENCP_VIDEO_VSO_BEGIN, 2100+1920+256},
+	{P_ENCP_VIDEO_VSO_END, 2164+1920+256},
+	{P_ENCP_VIDEO_VSO_BLINE, 51},
+	{P_ENCP_VIDEO_VSO_ELINE, 53},
+	{P_ENCP_VIDEO_MAX_LNCNT, 2249},
+	{P_ENCP_VIDEO_FILT_CTRL, 0x1000},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_smpte_25hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x149F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x8C9,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0xD8,},
+	{P_ENCP_VIDEO_HAVON_END, 0x10D7,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x52,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x8C1,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x58,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0xA,},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_t tvregs_4k2k_smpte_30hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x112F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x8C9,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0xD8,},
+	{P_ENCP_VIDEO_HAVON_END, 0x10D7,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x52,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x8C1,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x58,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0xA,},
+	{P_VPU_VIU_VENC_MUX_CTRL, 0xA},
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+struct vic_tvregs_set {
+	enum hdmi_vic vic;
+	const struct reg_t *reg_setting;
+};
+
+/* Using HDMI vic as index */
+static struct vic_tvregs_set tvregsTab[] = {
+	{HDMI_720x480i60_16x9, tvregs_480i},
+	{HDMI_2880x480i60_16x9, tvregs_480i},
+	{HDMI_720x480p60_16x9, tvregs_480p},
+	{HDMI_2880x240p60_16x9, tvregs_480p},
+	{HDMI_720x576i50_16x9, tvregs_576i},
+	{HDMI_2880x576i50_16x9, tvregs_576i},
+	{HDMI_720x576p50_16x9, tvregs_576p},
+	{HDMI_2880x576p50_16x9, tvregs_576p},
+	{HDMI_1280x720p60_16x9, tvregs_720p},
+	{HDMI_1920x1080i60_16x9, tvregs_1080i},
+	{HDMI_1920x1080p60_16x9, tvregs_1080p},
+	{HDMI_1920x1080p30_16x9, tvregs_1080p},
+	{HDMI_1280x720p50_16x9, tvregs_720p_50hz},
+	{HDMI_1920x1080i50_16x9, tvregs_1080i_50hz},
+	{HDMI_1920x1080p50_16x9, tvregs_1080p_50hz},
+	{HDMI_1920x1080p25_16x9, tvregs_1080p_50hz},
+	{HDMI_1920x1080p24_16x9, tvregs_1080p_24hz},
+	{HDMI_3840x2160p30_16x9, tvregs_4k2k_30hz},
+	{HDMI_3840x2160p25_16x9, tvregs_4k2k_25hz},
+	{HDMI_3840x2160p24_16x9, tvregs_4k2k_24hz},
+	{HDMI_4096x2160p24_256x135, tvregs_4k2k_smpte},
+	{HDMI_4096x2160p25_256x135, tvregs_4k2k_smpte_25hz},
+	{HDMI_4096x2160p30_256x135, tvregs_4k2k_smpte_30hz},
+	{HDMI_4096x2160p50_256x135, tvregs_4k2k_smpte_25hz},
+	{HDMI_4096x2160p60_256x135, tvregs_4k2k_smpte_30hz},
+	{HDMI_3840x2160p60_16x9, tvregs_4k2k_30hz},
+	{HDMI_3840x2160p50_16x9, tvregs_4k2k_25hz},
+};
+
+static inline void setreg(const struct reg_t *r)
+{
+	hd_write_reg(r->reg, r->val);
+	/* printk("[0x%x] = 0x%x\n", r->reg, r->val); */
+}
+
+static const struct reg_t *tvregs_setting_mode(enum hdmi_vic vic)
+{
+	int i = 0;
+	for (i = 0; i < ARRAY_SIZE(tvregsTab); i++) {
+		if (vic == tvregsTab[i].vic)
+			return tvregsTab[i].reg_setting;
+	}
+	return NULL;
+}
+
+void set_vmode_enc_hw(enum hdmi_vic vic)
+{
+	const struct reg_t *s = tvregs_setting_mode(vic);
+
+	if (s) {
+		pr_info("hdmitx: set enc for VIC: %d\n", vic);
+		while (MREG_END_MARKER != s->reg)
+			setreg(s++);
+	} else
+		pr_info("hdmitx: not find VIC: %d\n", vic);
+}
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_tvenc.h b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_tvenc.h
new file mode 100644
index 0000000..e1952da
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_tvenc.h
@@ -0,0 +1,45 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/hdmitx_tvenc.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __HDMI_TX_TVENC_H__
+#define __HDMI_TX_TVENC_H__
+
+#include <common.h>
+#include <amlogic/hdmi.h>
+
+struct reg_t {
+	unsigned int reg;
+	unsigned int val;
+};
+
+struct enc_reg_set {
+	unsigned int addr;
+	unsigned int val;
+};
+
+struct enc_reg_map {
+	enum hdmi_vic vic;
+	struct enc_reg_set *set;
+};
+
+void set_vmode_enc_hw(enum hdmi_vic vic);
+
+#endif
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/hw_enc_clk_config.h b/arch/arm/cpu/armv8/txl/hdmitx20/hw_enc_clk_config.h
new file mode 100644
index 0000000..3990e0d
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/hw_enc_clk_config.h
@@ -0,0 +1,87 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/hw_enc_clk_config.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __HW_ENC_CLK_CONFIG_H__
+#define __HW_ENC_CLK_CONFIG_H__
+#include <amlogic/hdmi.h>
+
+//#include <linux/amlogic/vout/enc_clk_config.h>
+
+#define CLK_UTIL_VID_PLL_DIV_1      0
+#define CLK_UTIL_VID_PLL_DIV_2      1
+#define CLK_UTIL_VID_PLL_DIV_3      2
+#define CLK_UTIL_VID_PLL_DIV_3p5    3
+#define CLK_UTIL_VID_PLL_DIV_3p75   4
+#define CLK_UTIL_VID_PLL_DIV_4      5
+#define CLK_UTIL_VID_PLL_DIV_5      6
+#define CLK_UTIL_VID_PLL_DIV_6      7
+#define CLK_UTIL_VID_PLL_DIV_6p25   8
+#define CLK_UTIL_VID_PLL_DIV_7      9
+#define CLK_UTIL_VID_PLL_DIV_7p5    10
+#define CLK_UTIL_VID_PLL_DIV_12     11
+#define CLK_UTIL_VID_PLL_DIV_14     12
+#define CLK_UTIL_VID_PLL_DIV_15     13
+#define CLK_UTIL_VID_PLL_DIV_2p5    14
+
+enum viu_type {
+    VIU_ENCL = 0,
+    VIU_ENCI,
+    VIU_ENCP,
+    VIU_ENCT,
+};
+
+typedef struct{
+    enum hdmi_vic vic;
+    unsigned viu_path;
+    enum viu_type viu_type;
+    unsigned hpll_clk_out;
+    unsigned od1;
+    unsigned od2;
+    unsigned od3;
+    unsigned vid_pll_div;
+    unsigned vid_clk_div;
+    unsigned hdmi_tx_pixel_div;
+    unsigned encp_div;
+    unsigned enci_div;
+}hw_enc_clk_val_t;
+
+#define GROUP_MAX	8
+#define GROUP_END	-1
+struct hw_enc_clk_val_group {
+    enum hdmi_vic group[GROUP_MAX];
+    unsigned viu_path;
+    enum viu_type viu_type;
+    unsigned hpll_clk_out;
+    unsigned od1;
+    unsigned od2;
+    unsigned od3;
+    unsigned vid_pll_div;
+    unsigned vid_clk_div;
+    unsigned hdmi_tx_pixel_div;
+    unsigned encp_div;
+    unsigned enci_div;
+};
+
+void set_hdmitx_clk(enum hdmi_vic vic);
+void hdmitx_set_clk_30b(enum hdmi_vic vic);
+void set_hdmitx_clk_420(void);
+
+#endif
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/mach_reg.h b/arch/arm/cpu/armv8/txl/hdmitx20/mach_reg.h
new file mode 100644
index 0000000..a27c523
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/mach_reg.h
@@ -0,0 +1,810 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/mach_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __MACH_REG_H__
+#define __MACH_REG_H__
+
+#include <common.h>
+
+#define OFFSET	24
+#define nCBUS_REG_ADDR(reg) (0xc8834400 + (reg << 2))
+#define VCBUS_REG_ADDR(reg) (0xd0100000 + (reg << 2))
+
+unsigned long hd_read_reg(unsigned long addr);
+void hd_write_reg(unsigned long addr, unsigned long val);
+void hd_set_reg_bits(unsigned long addr, unsigned long value, unsigned long offset,
+	unsigned long len);
+void sec_reg_write(unsigned *addr, unsigned value);
+unsigned sec_reg_read(unsigned *addr);
+
+#define P_PREG_PAD_GPIO6_EN_N nCBUS_REG_ADDR(0x08)
+#define P_PREG_PAD_GPIO6_O    nCBUS_REG_ADDR(0x09)
+#define P_PREG_PAD_GPIO6_I    nCBUS_REG_ADDR(0x0a)
+#define P_PREG_JTAG_GPIO_ADDR nCBUS_REG_ADDR(0x0b)
+#define P_PREG_PAD_GPIO0_EN_N nCBUS_REG_ADDR(0x0c)
+#define P_PREG_PAD_GPIO0_O    nCBUS_REG_ADDR(0x0d)
+#define P_PREG_PAD_GPIO0_I    nCBUS_REG_ADDR(0x0e)
+#define P_PREG_PAD_GPIO1_EN_N nCBUS_REG_ADDR(0x0f)
+#define P_PREG_PAD_GPIO1_O    nCBUS_REG_ADDR(0x10)
+#define P_PREG_PAD_GPIO1_I    nCBUS_REG_ADDR(0x11)
+#define P_PREG_PAD_GPIO2_EN_N nCBUS_REG_ADDR(0x12)
+#define P_PREG_PAD_GPIO2_O    nCBUS_REG_ADDR(0x13)
+#define P_PREG_PAD_GPIO2_I    nCBUS_REG_ADDR(0x14)
+#define P_PREG_PAD_GPIO3_EN_N nCBUS_REG_ADDR(0x15)
+#define P_PREG_PAD_GPIO3_O    nCBUS_REG_ADDR(0x16)
+#define P_PREG_PAD_GPIO3_I    nCBUS_REG_ADDR(0x17)
+#define P_PREG_PAD_GPIO4_EN_N nCBUS_REG_ADDR(0x18)
+#define P_PREG_PAD_GPIO4_O    nCBUS_REG_ADDR(0x19)
+#define P_PREG_PAD_GPIO4_I    nCBUS_REG_ADDR(0x1a)
+#define P_PREG_PAD_GPIO5_EN_N nCBUS_REG_ADDR(0x1b)
+#define P_PREG_PAD_GPIO5_O    nCBUS_REG_ADDR(0x1c)
+#define P_PREG_PAD_GPIO5_I    nCBUS_REG_ADDR(0x1d)
+#define PERIPHS_PIN_MUX_0 0x2c	/* register.h:419 */
+#define P_PERIPHS_PIN_MUX_0 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_0)
+#define PERIPHS_PIN_MUX_1 0x2d	/* register.h:420 */
+#define P_PERIPHS_PIN_MUX_1 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_1)
+#define PERIPHS_PIN_MUX_2 0x2e	/* register.h:421 */
+#define P_PERIPHS_PIN_MUX_2 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_2)
+#define PERIPHS_PIN_MUX_3 0x2f	/* register.h:422 */
+#define P_PERIPHS_PIN_MUX_3 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_3)
+#define PERIPHS_PIN_MUX_4 0x30	/* register.h:423 */
+#define P_PERIPHS_PIN_MUX_4 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_4)
+#define PERIPHS_PIN_MUX_5 0x31	/* register.h:424 */
+#define P_PERIPHS_PIN_MUX_5 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define PERIPHS_PIN_MUX_6 0x32	/* register.h:425 */
+#define P_PERIPHS_PIN_MUX_6 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_6)
+#define PERIPHS_PIN_MUX_7 0x33	/* register.h:426 */
+#define P_PERIPHS_PIN_MUX_7 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_7)
+#define PERIPHS_PIN_MUX_8 0x34	/* register.h:427 */
+#define P_PERIPHS_PIN_MUX_8 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_8)
+#define PERIPHS_PIN_MUX_9 0x35	/* register.h:428 */
+#define P_PERIPHS_PIN_MUX_9 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_9)
+#define PERIPHS_PIN_MUX_10 0x36	/* register.h:429 */
+#define P_PERIPHS_PIN_MUX_10 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_10)
+#define PERIPHS_PIN_MUX_11 0x37	/* register.h:430 */
+#define P_PERIPHS_PIN_MUX_11 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_11)
+#define PERIPHS_PIN_MUX_12 0x38	/* register.h:431 */
+#define P_PERIPHS_PIN_MUX_12 nCBUS_REG_ADDR(PERIPHS_PIN_MUX_12)
+
+#define PAD_PULL_UP_REG0 0x3a
+#define P_PAD_PULL_UP_REG0 nCBUS_REG_ADDR(PAD_PULL_UP_REG0)
+#define PAD_PULL_UP_REG1 0x3d
+#define P_PAD_PULL_UP_REG1 nCBUS_REG_ADDR(PAD_PULL_UP_REG1)
+#define PAD_PULL_UP_REG2 0x3c
+#define P_PAD_PULL_UP_REG2 nCBUS_REG_ADDR(PAD_PULL_UP_REG2)
+#define PAD_PULL_UP_REG3 0x3d
+#define P_PAD_PULL_UP_REG3 nCBUS_REG_ADDR(PAD_PULL_UP_REG3)
+#define PAD_PULL_UP_REG4 0x3d
+#define P_PAD_PULL_UP_REG4 nCBUS_REG_ADDR(PAD_PULL_UP_REG4)
+#define PAD_PULL_UP_EN_REG0 0x48
+#define P_PAD_PULL_UP_EN_REG0 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG0)
+#define PAD_PULL_UP_EN_REG1 0x49
+#define P_PAD_PULL_UP_EN_REG1 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG1)
+#define PAD_PULL_UP_EN_REG2 0x4a
+#define P_PAD_PULL_UP_EN_REG2 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG2)
+#define PAD_PULL_UP_EN_REG3 0x4b
+#define P_PAD_PULL_UP_EN_REG3 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG3)
+#define PAD_PULL_UP_EN_REG4 0x4c
+#define P_PAD_PULL_UP_EN_REG4 nCBUS_REG_ADDR(PAD_PULL_UP_EN_REG4)
+
+#define P_HHI_MEM_PD_REG0 (0xc883c000 + (0x40 << 2))
+#define P_HHI_VPU_MEM_PD_REG0 (0xc883c000 + (0x41 << 2))
+#define P_HHI_VPU_MEM_PD_REG1 (0xc883c000 + (0x42 << 2))
+#define P_HHI_AUD_DAC_CTRL (0xc883c000 + (0x44 << 2))
+#define P_HHI_VIID_CLK_DIV (0xc883c000 + (0x4a << 2))
+/* [19] -enable clk_div0 */
+/* [18:16] - cntl_clk_in_sel */
+#define P_HHI_VIID_CLK_CNTL (0xc883c000 + (0x4b << 2))
+#define P_HHI_VIID_DIVIDER_CNTL (0xc883c000 + (0x4c << 2))
+
+/*
+//========================================================================
+//  Global Control Registers			    (12'h000 - 12'h0ff)
+//
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  RESET_CBUS_BASE = 0x11
+// -----------------------------------------------
+*/
+#define P_VERSION_CTRL ((0x00  << 2) + 0xc1104400)
+#define P_RESET0_REGISTER ((0x01  << 2) + 0xc1104400)
+#define P_RESET1_REGISTER ((0x02  << 2) + 0xc1104400)
+#define P_RESET2_REGISTER ((0x03  << 2) + 0xc1104400)
+#define P_RESET3_REGISTER ((0x04  << 2) + 0xc1104400)
+#define P_RESET4_REGISTER ((0x05  << 2) + 0xc1104400)
+#define P_RESET5_REGISTER ((0x06  << 2) + 0xc1104400)
+#define P_RESET6_REGISTER ((0x07  << 2) + 0xc1104400)
+#define P_RESET7_REGISTER ((0x08  << 2) + 0xc1104400)
+#define P_RESET0_MASK ((0x10  << 2) + 0xc1104400)
+#define P_RESET1_MASK ((0x11  << 2) + 0xc1104400)
+#define P_RESET2_MASK ((0x12  << 2) + 0xc1104400)
+#define P_RESET3_MASK ((0x13  << 2) + 0xc1104400)
+#define P_RESET4_MASK ((0x14  << 2) + 0xc1104400)
+#define P_RESET5_MASK ((0x15  << 2) + 0xc1104400)
+#define P_RESET6_MASK ((0x16  << 2) + 0xc1104400)
+
+/* Gated clock enables.
+ * There are 64 enables for the MPEG clocks and 32 enables for other
+ * clock domains.
+ */
+#define P_HHI_GCLK_MPEG0 (0xc883c000 + (0x50 << 2))
+#define P_HHI_GCLK_MPEG1 (0xc883c000 + (0x51 << 2))
+#define P_HHI_GCLK_MPEG2 (0xc883c000 + (0x52 << 2))
+#define P_HHI_GCLK_OTHER (0xc883c000 + (0x54 << 2))
+#define P_HHI_GCLK_AO (0xc883c000 + (0x55 << 2))
+#define P_HHI_SYS_OSCIN_CNTL (0xc883c000 + (0x56 << 2))
+#define P_HHI_SYS_CPU_CLK_CNTL1 (0xc883c000 + (0x57 << 2))
+#define P_HHI_SYS_CPU_RESET_CNTL (0xc883c000 + (0x58 << 2))
+/* [7:0]   - cntl_xd0 */
+#define P_HHI_VID_CLK_DIV (0xc883c000 + (0x59 << 2))
+#define P_HHI_MPEG_CLK_CNTL (0xc883c000 + (0x5d << 2))
+#define P_HHI_AUD_CLK_CNTL (0xc883c000 + (0x5e << 2))
+/* [18:16] - cntl_clk_in_sel */
+#define P_HHI_VID_CLK_CNTL (0xc883c000 + (0x5f << 2))
+#define P_HHI_WIFI_CLK_CNTL (0xc883c000 + (0x60 << 2))
+#define P_HHI_WIFI_PLL_CNTL (0xc883c000 + (0x61 << 2))
+#define P_HHI_WIFI_PLL_CNTL2 (0xc883c000 + (0x62 << 2))
+#define P_HHI_WIFI_PLL_CNTL3 (0xc883c000 + (0x63 << 2))
+#define P_HHI_AUD_CLK_CNTL2 (0xc883c000 + (0x64 << 2))
+#define P_HHI_VID_CLK_CNTL2 (0xc883c000 + (0x65 << 2))
+#define P_HHI_VID_DIVIDER_CNTL (0xc883c000 + (0x66 << 2))
+#define P_HHI_SYS_CPU_CLK_CNTL (0xc883c000 + (0x67 << 2))
+#define P_HHI_VID_PLL_CLK_DIV (0xc883c000 + (0x68 << 2))
+#define P_HHI_AUD_CLK_CNTL3 (0xc883c000 + (0x69 << 2))
+#define P_HHI_MALI_CLK_CNTL (0xc883c000 + (0x6c << 2))
+#define P_HHI_MIPI_PHY_CLK_CNTL (0xc883c000 + (0x6e << 2))
+#define P_HHI_VPU_CLK_CNTL (0xc883c000 + (0x6f << 2))
+#define P_HHI_OTHER_PLL_CNTL (0xc883c000 + (0x70 << 2))
+#define P_HHI_OTHER_PLL_CNTL2 (0xc883c000 + (0x71 << 2))
+#define P_HHI_OTHER_PLL_CNTL3 (0xc883c000 + (0x72 << 2))
+#define P_HHI_HDMI_CLK_CNTL (0xc883c000 + (0x73 << 2))
+#define P_HHI_DEMOD_CLK_CNTL (0xc883c000 + (0x74 << 2))
+#define P_HHI_SATA_CLK_CNTL (0xc883c000 + (0x75 << 2))
+#define P_HHI_ETH_CLK_CNTL (0xc883c000 + (0x76 << 2))
+#define P_HHI_CLK_DOUBLE_CNTL (0xc883c000 + (0x77 << 2))
+#define P_HHI_VDEC_CLK_CNTL (0xc883c000 + (0x78 << 2))
+#define P_HHI_VDEC2_CLK_CNTL (0xc883c000 + (0x79 << 2))
+#define P_HHI_VDEC3_CLK_CNTL (0xc883c000 + (0x7a << 2))
+#define P_HHI_VDEC4_CLK_CNTL (0xc883c000 + (0x7b << 2))
+#define P_HHI_HDCP22_CLK_CNTL (0xc883c000 + (0x7c << 2))
+#define P_HHI_VAPBCLK_CNTL (0xc883c000 + (0x7d << 2))
+#define P_HHI_VP9DEC_CLK_CNTL (0xc883c000 + (0x7e << 2))
+#define P_HHI_HDMI_AFC_CNTL (0xc883c000 + (0x7f << 2))
+#define P_HHI_HDMIRX_CLK_CNTL (0xc883c000 + (0x80 << 2))
+#define P_HHI_HDMIRX_AUD_CLK_CNTL (0xc883c000 + (0x81 << 2))
+#define P_HHI_EDP_APB_CLK_CNTL (0xc883c000 + (0x82 << 2))
+#define P_HHI_VPU_CLKB_CNTL (0xc883c000 + (0x83 << 2))
+#define P_HHI_VID_PLL_MOD_CNTL0 (0xc883c000 + (0x84 << 2))
+#define P_HHI_VID_PLL_MOD_LOW_TCNT (0xc883c000 + (0x85 << 2))
+#define P_HHI_VID_PLL_MOD_HIGH_TCNT (0xc883c000 + (0x86 << 2))
+#define P_HHI_VID_PLL_MOD_NOM_TCNT (0xc883c000 + (0x87 << 2))
+#define P_HHI_USB_CLK_CNTL (0xc883c000 + (0x88 << 2))
+#define P_HHI_32K_CLK_CNTL (0xc883c000 + (0x89 << 2))
+#define P_HHI_GEN_CLK_CNTL (0xc883c000 + (0x8a << 2))
+#define P_HHI_GEN_CLK_CNTL2 (0xc883c000 + (0x8b << 2))
+#define P_HHI_JTAG_CONFIG (0xc883c000 + (0x8e << 2))
+#define P_HHI_VAFE_CLKXTALIN_CNTL (0xc883c000 + (0x8f << 2))
+#define P_HHI_VAFE_CLKOSCIN_CNTL (0xc883c000 + (0x90 << 2))
+#define P_HHI_VAFE_CLKIN_CNTL (0xc883c000 + (0x91 << 2))
+#define P_HHI_TVFE_AUTOMODE_CLK_CNTL (0xc883c000 + (0x92 << 2))
+#define P_HHI_VAFE_CLKPI_CNTL (0xc883c000 + (0x93 << 2))
+#define P_HHI_VDIN_MEAS_CLK_CNTL (0xc883c000 + (0x94 << 2))
+#define P_HHI_PCM_CLK_CNTL (0xc883c000 + (0x96 << 2))
+#define P_HHI_NAND_CLK_CNTL (0xc883c000 + (0x97 << 2))
+#define P_HHI_ISP_LED_CLK_CNTL (0xc883c000 + (0x98 << 2))
+#define P_HHI_SD_EMMC_CLK_CNTL (0xc883c000 + (0x99 << 2))
+#define P_HHI_EDP_TX_PHY_CNTL0 (0xc883c000 + (0x9c << 2))
+#define P_HHI_EDP_TX_PHY_CNTL1 (0xc883c000 + (0x9d << 2))
+#define P_HHI_MPLL_CNTL (0xc883c000 + (0xa0 << 2))
+#define P_HHI_MPLL_CNTL2 (0xc883c000 + (0xa1 << 2))
+#define P_HHI_MPLL_CNTL3 (0xc883c000 + (0xa2 << 2))
+#define P_HHI_MPLL_CNTL4 (0xc883c000 + (0xa3 << 2))
+#define P_HHI_MPLL_CNTL5 (0xc883c000 + (0xa4 << 2))
+#define P_HHI_MPLL_CNTL6 (0xc883c000 + (0xa5 << 2))
+#define P_HHI_MPLL_CNTL7 (0xc883c000 + (0xa6 << 2))
+#define P_HHI_MPLL_CNTL8 (0xc883c000 + (0xa7 << 2))
+#define P_HHI_MPLL_CNTL9 (0xc883c000 + (0xa8 << 2))
+#define P_HHI_MPLL_CNTL10 (0xc883c000 + (0xa9 << 2))
+#define P_HHI_ADC_PLL_CNTL (0xc883c000 + (0xaa << 2))
+#define P_HHI_ADC_PLL_CNTL2 (0xc883c000 + (0xab << 2))
+#define P_HHI_ADC_PLL_CNTL3 (0xc883c000 + (0xac << 2))
+#define P_HHI_ADC_PLL_CNTL4 (0xc883c000 + (0xad << 2))
+#define P_HHI_ADC_PLL_CNTL_I (0xc883c000 + (0xae << 2))
+#define P_HHI_AUDCLK_PLL_CNTL (0xc883c000 + (0xb0 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL2 (0xc883c000 + (0xb1 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL3 (0xc883c000 + (0xb2 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL4 (0xc883c000 + (0xb3 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL5 (0xc883c000 + (0xb4 << 2))
+#define P_HHI_AUDCLK_PLL_CNTL6 (0xc883c000 + (0xb5 << 2))
+#define P_HHI_L2_DDR_CLK_CNTL (0xc883c000 + (0xb6 << 2))
+#define P_HHI_MPLL3_CNTL0 (0xc883c000 + (0xb8 << 2))
+#define P_HHI_MPLL3_CNTL1 (0xc883c000 + (0xb9 << 2))
+#define P_HHI_VDAC_CNTL0 (0xc883c000 + (0xbd << 2))
+#define P_HHI_VDAC_CNTL1 (0xc883c000 + (0xbe << 2))
+#define P_HHI_SYS_PLL_CNTL (0xc883c000 + (0xc0 << 2))
+#define P_HHI_SYS_PLL_CNTL2 (0xc883c000 + (0xc1 << 2))
+#define P_HHI_SYS_PLL_CNTL3 (0xc883c000 + (0xc2 << 2))
+#define P_HHI_SYS_PLL_CNTL4 (0xc883c000 + (0xc3 << 2))
+#define P_HHI_SYS_PLL_CNTL5 (0xc883c000 + (0xc4 << 2))
+#define P_HHI_DPLL_TOP_I (0xc883c000 + (0xc6 << 2))
+#define P_HHI_DPLL_TOP2_I (0xc883c000 + (0xc7 << 2))
+#define P_HHI_HDMI_PLL_CNTL (0xc883c000 + (0xc8 << 2))
+#define P_HHI_HDMI_PLL_CNTL2 (0xc883c000 + (0xc9 << 2))
+#define P_HHI_HDMI_PLL_CNTL3 (0xc883c000 + (0xca << 2))
+#define P_HHI_HDMI_PLL_CNTL4 (0xc883c000 + (0xcb << 2))
+#define P_HHI_HDMI_PLL_CNTL5 (0xc883c000 + (0xcc << 2))
+#define P_HHI_HDMI_PLL_CNTL6 (0xc883c000 + (0xcd << 2))
+#define P_HHI_HDMI_PLL_CNTL_I (0xc883c000 + (0xce << 2))
+#define P_HHI_HDMI_PLL_CNTL7 (0xc883c000 + (0xcf << 2))
+#define P_HHI_DSI_LVDS_EDP_CNTL0 (0xc883c000 + (0xd1 << 2))
+#define P_HHI_DSI_LVDS_EDP_CNTL1 (0xc883c000 + (0xd2 << 2))
+#define P_HHI_CSI_PHY_CNTL0 (0xc883c000 + (0xd3 << 2))
+#define P_HHI_CSI_PHY_CNTL1 (0xc883c000 + (0xd4 << 2))
+#define P_HHI_CSI_PHY_CNTL2 (0xc883c000 + (0xd5 << 2))
+#define P_HHI_CSI_PHY_CNTL3 (0xc883c000 + (0xd6 << 2))
+#define P_HHI_CSI_PHY_CNTL4 (0xc883c000 + (0xd7 << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL0 (0xc883c000 + (0xd8 << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL1 (0xc883c000 + (0xd9 << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL2 (0xc883c000 + (0xda << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL3 (0xc883c000 + (0xdb << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL4 (0xc883c000 + (0xdc << 2))
+#define P_HHI_DIF_CSI_PHY_CNTL5 (0xc883c000 + (0xdd << 2))
+#define P_HHI_LVDS_TX_PHY_CNTL0 (0xc883c000 + (0xde << 2))
+#define P_HHI_LVDS_TX_PHY_CNTL1 (0xc883c000 + (0xdf << 2))
+#define P_HHI_VID2_PLL_CNTL (0xc883c000 + (0xe0 << 2))
+#define P_HHI_VID2_PLL_CNTL2 (0xc883c000 + (0xe1 << 2))
+#define P_HHI_VID2_PLL_CNTL3 (0xc883c000 + (0xe2 << 2))
+#define P_HHI_VID2_PLL_CNTL4 (0xc883c000 + (0xe3 << 2))
+#define P_HHI_VID2_PLL_CNTL5 (0xc883c000 + (0xe4 << 2))
+#define P_HHI_VID2_PLL_CNTL_I (0xc883c000 + (0xe5 << 2))
+#define P_HHI_HDMI_PHY_CNTL0 (0xc883c000 + (0xe8 << 2))
+#define P_HHI_HDMI_PHY_CNTL1 (0xc883c000 + (0xe9 << 2))
+#define P_HHI_HDMI_PHY_CNTL2 (0xc883c000 + (0xea << 2))
+#define P_HHI_HDMI_PHY_CNTL3 (0xc883c000 + (0xeb << 2))
+#define P_HHI_VID_LOCK_CLK_CNTL (0xc883c000 + (0xf2 << 2))
+#define P_HHI_ATV_DMD_SYS_CLK_CNTL (0xc883c000 + (0xf3 << 2))
+#define P_HHI_BT656_CLK_CNTL (0xc883c000 + (0xf5 << 2))
+#define P_HHI_SAR_CLK_CNTL (0xc883c000 + (0xf6 << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL (0xc883c000 + (0xf8 << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL2 (0xc883c000 + (0xf9 << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL3 (0xc883c000 + (0xfa << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL4 (0xc883c000 + (0xfb << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL5 (0xc883c000 + (0xfc << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL6 (0xc883c000 + (0xfd << 2))
+#define P_HHI_HDMIRX_AUD_PLL_CNTL_I (0xc883c000 + (0xfe << 2))
+
+#define AIU_HDMI_CLK_DATA_CTRL 0x152a	/* register.h:2466 */
+#define P_AIU_HDMI_CLK_DATA_CTRL CBUS_REG_ADDR(AIU_HDMI_CLK_DATA_CTRL)
+
+#define ISA_DEBUG_REG0 0x2600
+#define P_ISA_DEBUG_REG0 CBUS_REG_ADDR(ISA_DEBUG_REG0)
+
+#define VENC_DVI_SETTING 0x1b62	/* register.h:8014 */
+#define P_VENC_DVI_SETTING VCBUS_REG_ADDR(VENC_DVI_SETTING)
+
+#define VENC_VIDEO_TST_EN 0x1b70
+#define P_VENC_VIDEO_TST_EN VCBUS_REG_ADDR(VENC_VIDEO_TST_EN)
+#define VENC_VIDEO_TST_MDSEL 0x1b71
+#define P_VENC_VIDEO_TST_MDSEL VCBUS_REG_ADDR(VENC_VIDEO_TST_MDSEL)
+#define VENC_VIDEO_TST_Y 0x1b72
+#define P_VENC_VIDEO_TST_Y VCBUS_REG_ADDR(VENC_VIDEO_TST_Y)
+#define VENC_VIDEO_TST_CB 0x1b73
+#define P_VENC_VIDEO_TST_CB VCBUS_REG_ADDR(VENC_VIDEO_TST_CB)
+#define VENC_VIDEO_TST_CR 0x1b74
+#define P_VENC_VIDEO_TST_CR VCBUS_REG_ADDR(VENC_VIDEO_TST_CR)
+#define VENC_VIDEO_TST_CLRBAR_STRT 0x1b75
+#define P_VENC_VIDEO_TST_CLRBAR_STRT VCBUS_REG_ADDR(VENC_VIDEO_TST_CLRBAR_STRT)
+#define VENC_VIDEO_TST_CLRBAR_WIDTH 0x1b76
+#define P_VENC_VIDEO_TST_CLRBAR_WIDTH VCBUS_REG_ADDR(VENC_VIDEO_TST_CLRBAR_WIDTH)
+#define VENC_VIDEO_TST_VDCNT_STSET 0x1b77
+#define P_VENC_VIDEO_TST_VDCNT_STSET VCBUS_REG_ADDR(VENC_VIDEO_TST_VDCNT_STSET)
+#define ENCP_VIDEO_EN 0x1b80	/* register.h:8078 */
+#define P_ENCP_VIDEO_EN VCBUS_REG_ADDR(ENCP_VIDEO_EN)
+#define ENCP_VIDEO_SYNC_MODE 0x1b81	/* register.h:8079 */
+#define P_ENCP_VIDEO_SYNC_MODE VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_MODE)
+#define ENCP_MACV_EN 0x1b82	/* register.h:8080 */
+#define P_ENCP_MACV_EN VCBUS_REG_ADDR(ENCP_MACV_EN)
+#define ENCP_VIDEO_Y_SCL 0x1b83	/* register.h:8081 */
+#define P_ENCP_VIDEO_Y_SCL VCBUS_REG_ADDR(ENCP_VIDEO_Y_SCL)
+#define ENCP_VIDEO_PB_SCL 0x1b84	/* register.h:8082 */
+#define P_ENCP_VIDEO_PB_SCL VCBUS_REG_ADDR(ENCP_VIDEO_PB_SCL)
+#define ENCP_VIDEO_PR_SCL 0x1b85	/* register.h:8083 */
+#define P_ENCP_VIDEO_PR_SCL VCBUS_REG_ADDR(ENCP_VIDEO_PR_SCL)
+#define ENCP_VIDEO_SYNC_SCL 0x1b86	/* register.h:8084 */
+#define P_ENCP_VIDEO_SYNC_SCL VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_SCL)
+#define ENCP_VIDEO_MACV_SCL 0x1b87	/* register.h:8085 */
+#define P_ENCP_VIDEO_MACV_SCL VCBUS_REG_ADDR(ENCP_VIDEO_MACV_SCL)
+#define ENCP_VIDEO_Y_OFFST 0x1b88	/* register.h:8086 */
+#define P_ENCP_VIDEO_Y_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_Y_OFFST)
+#define ENCP_VIDEO_PB_OFFST 0x1b89	/* register.h:8087 */
+#define P_ENCP_VIDEO_PB_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_PB_OFFST)
+#define ENCP_VIDEO_PR_OFFST 0x1b8a	/* register.h:8088 */
+#define P_ENCP_VIDEO_PR_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_PR_OFFST)
+#define ENCP_VIDEO_SYNC_OFFST 0x1b8b	/* register.h:8089 */
+#define P_ENCP_VIDEO_SYNC_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_OFFST)
+#define ENCP_VIDEO_MACV_OFFST 0x1b8c	/* register.h:8090 */
+#define P_ENCP_VIDEO_MACV_OFFST VCBUS_REG_ADDR(ENCP_VIDEO_MACV_OFFST)
+#define ENCP_VIDEO_MODE 0x1b8d	/* register.h:8092 */
+#define P_ENCP_VIDEO_MODE VCBUS_REG_ADDR(ENCP_VIDEO_MODE)
+#define ENCP_VIDEO_MODE_ADV 0x1b8e	/* register.h:8093 */
+#define P_ENCP_VIDEO_MODE_ADV VCBUS_REG_ADDR(ENCP_VIDEO_MODE_ADV)
+#define ENCP_DBG_PX_RST 0x1b90	/* register.h:8095 */
+#define P_ENCP_DBG_PX_RST VCBUS_REG_ADDR(ENCP_DBG_PX_RST)
+#define ENCP_DBG_LN_RST 0x1b91	/* register.h:8096 */
+#define P_ENCP_DBG_LN_RST VCBUS_REG_ADDR(ENCP_DBG_LN_RST)
+#define ENCP_DBG_PX_INT 0x1b92	/* register.h:8097 */
+#define P_ENCP_DBG_PX_INT VCBUS_REG_ADDR(ENCP_DBG_PX_INT)
+#define ENCP_DBG_LN_INT 0x1b93	/* register.h:8098 */
+#define P_ENCP_DBG_LN_INT VCBUS_REG_ADDR(ENCP_DBG_LN_INT)
+#define ENCP_VIDEO_YFP1_HTIME 0x1b94	/* register.h:8100 */
+#define P_ENCP_VIDEO_YFP1_HTIME VCBUS_REG_ADDR(ENCP_VIDEO_YFP1_HTIME)
+#define ENCP_VIDEO_YFP2_HTIME 0x1b95	/* register.h:8101 */
+#define P_ENCP_VIDEO_YFP2_HTIME VCBUS_REG_ADDR(ENCP_VIDEO_YFP2_HTIME)
+#define ENCP_VIDEO_YC_DLY 0x1b96	/* register.h:8102 */
+#define P_ENCP_VIDEO_YC_DLY VCBUS_REG_ADDR(ENCP_VIDEO_YC_DLY)
+#define ENCP_VIDEO_MAX_PXCNT 0x1b97	/* register.h:8103 */
+#define P_ENCP_VIDEO_MAX_PXCNT VCBUS_REG_ADDR(ENCP_VIDEO_MAX_PXCNT)
+#define ENCP_VIDEO_HSPULS_BEGIN 0x1b98	/* register.h:8104 */
+#define P_ENCP_VIDEO_HSPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_BEGIN)
+#define ENCP_VIDEO_HSPULS_END 0x1b99	/* register.h:8105 */
+#define P_ENCP_VIDEO_HSPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_END)
+#define ENCP_VIDEO_HSPULS_SWITCH 0x1b9a	/* register.h:8106 */
+#define P_ENCP_VIDEO_HSPULS_SWITCH VCBUS_REG_ADDR(ENCP_VIDEO_HSPULS_SWITCH)
+#define ENCP_VIDEO_VSPULS_BEGIN 0x1b9b	/* register.h:8107 */
+#define P_ENCP_VIDEO_VSPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_BEGIN)
+#define ENCP_VIDEO_VSPULS_END 0x1b9c	/* register.h:8108 */
+#define P_ENCP_VIDEO_VSPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_END)
+#define ENCP_VIDEO_VSPULS_BLINE 0x1b9d	/* register.h:8109 */
+#define P_ENCP_VIDEO_VSPULS_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_BLINE)
+#define ENCP_VIDEO_VSPULS_ELINE 0x1b9e	/* register.h:8110 */
+#define P_ENCP_VIDEO_VSPULS_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VSPULS_ELINE)
+#define ENCP_VIDEO_EQPULS_BEGIN 0x1b9f	/* register.h:8111 */
+#define P_ENCP_VIDEO_EQPULS_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_BEGIN)
+#define ENCP_VIDEO_EQPULS_END 0x1ba0	/* register.h:8112 */
+#define P_ENCP_VIDEO_EQPULS_END VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_END)
+#define ENCP_VIDEO_EQPULS_BLINE 0x1ba1	/* register.h:8113 */
+#define P_ENCP_VIDEO_EQPULS_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_BLINE)
+#define ENCP_VIDEO_EQPULS_ELINE 0x1ba2	/* register.h:8114 */
+#define P_ENCP_VIDEO_EQPULS_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_EQPULS_ELINE)
+#define ENCP_VIDEO_HAVON_END 0x1ba3	/* register.h:8115 */
+#define P_ENCP_VIDEO_HAVON_END VCBUS_REG_ADDR(ENCP_VIDEO_HAVON_END)
+#define ENCP_VIDEO_HAVON_BEGIN 0x1ba4	/* register.h:8116 */
+#define P_ENCP_VIDEO_HAVON_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HAVON_BEGIN)
+#define ENCP_VIDEO_VAVON_ELINE 0x1baf	/* register.h:8117 */
+#define P_ENCP_VIDEO_VAVON_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VAVON_ELINE)
+#define ENCP_VIDEO_VAVON_BLINE 0x1ba6	/* register.h:8118 */
+#define P_ENCP_VIDEO_VAVON_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VAVON_BLINE)
+#define ENCP_VIDEO_HSO_BEGIN 0x1ba7	/* register.h:8119 */
+#define P_ENCP_VIDEO_HSO_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_HSO_BEGIN)
+#define ENCP_VIDEO_HSO_END 0x1ba8	/* register.h:8120 */
+#define P_ENCP_VIDEO_HSO_END VCBUS_REG_ADDR(ENCP_VIDEO_HSO_END)
+#define ENCP_VIDEO_VSO_BEGIN 0x1ba9	/* register.h:8121 */
+#define P_ENCP_VIDEO_VSO_BEGIN VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BEGIN)
+#define ENCP_VIDEO_VSO_END 0x1baa	/* register.h:8122 */
+#define P_ENCP_VIDEO_VSO_END VCBUS_REG_ADDR(ENCP_VIDEO_VSO_END)
+#define ENCP_VIDEO_VSO_BLINE 0x1bab	/* register.h:8123 */
+#define P_ENCP_VIDEO_VSO_BLINE VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BLINE)
+#define ENCP_VIDEO_VSO_ELINE 0x1bac	/* register.h:8124 */
+#define P_ENCP_VIDEO_VSO_ELINE VCBUS_REG_ADDR(ENCP_VIDEO_VSO_ELINE)
+#define ENCP_VIDEO_SYNC_WAVE_CURVE 0x1bad	/* register.h:8125 */
+#define P_ENCP_VIDEO_SYNC_WAVE_CURVE VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_WAVE_CURVE)
+#define ENCP_VIDEO_MAX_LNCNT 0x1bae	/* register.h:8126 */
+#define P_ENCP_VIDEO_MAX_LNCNT VCBUS_REG_ADDR(ENCP_VIDEO_MAX_LNCNT)
+#define ENCP_VIDEO_SY_VAL 0x1bb0	/* register.h:8127 */
+#define P_ENCP_VIDEO_SY_VAL VCBUS_REG_ADDR(ENCP_VIDEO_SY_VAL)
+#define ENCP_VIDEO_SY2_VAL 0x1bb1	/* register.h:8128 */
+#define P_ENCP_VIDEO_SY2_VAL VCBUS_REG_ADDR(ENCP_VIDEO_SY2_VAL)
+#define ENCP_VIDEO_BLANKY_VAL 0x1bb2	/* register.h:8129 */
+#define P_ENCP_VIDEO_BLANKY_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKY_VAL)
+#define ENCP_VIDEO_BLANKPB_VAL 0x1bb3	/* register.h:8130 */
+#define P_ENCP_VIDEO_BLANKPB_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKPB_VAL)
+#define ENCP_VIDEO_BLANKPR_VAL 0x1bb4	/* register.h:8131 */
+#define P_ENCP_VIDEO_BLANKPR_VAL VCBUS_REG_ADDR(ENCP_VIDEO_BLANKPR_VAL)
+#define ENCP_VIDEO_HOFFST 0x1bb5	/* register.h:8132 */
+#define P_ENCP_VIDEO_HOFFST VCBUS_REG_ADDR(ENCP_VIDEO_HOFFST)
+#define ENCP_VIDEO_VOFFST 0x1bb6	/* register.h:8133 */
+#define P_ENCP_VIDEO_VOFFST VCBUS_REG_ADDR(ENCP_VIDEO_VOFFST)
+#define ENCP_VIDEO_RGB_CTRL 0x1bb7	/* register.h:8134 */
+#define P_ENCP_VIDEO_RGB_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_RGB_CTRL)
+#define ENCP_VIDEO_FILT_CTRL 0x1bb8	/* register.h:8135 */
+#define P_ENCP_VIDEO_FILT_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_FILT_CTRL)
+#define ENCP_VIDEO_OFLD_VPEQ_OFST 0x1bb9	/* register.h:8136 */
+#define P_ENCP_VIDEO_OFLD_VPEQ_OFST VCBUS_REG_ADDR(ENCP_VIDEO_OFLD_VPEQ_OFST)
+#define ENCP_VIDEO_OFLD_VOAV_OFST 0x1bba	/* register.h:8137 */
+#define P_ENCP_VIDEO_OFLD_VOAV_OFST VCBUS_REG_ADDR(ENCP_VIDEO_OFLD_VOAV_OFST)
+#define ENCP_VIDEO_MATRIX_CB 0x1bbb	/* register.h:8138 */
+#define P_ENCP_VIDEO_MATRIX_CB VCBUS_REG_ADDR(ENCP_VIDEO_MATRIX_CB)
+#define ENCP_VIDEO_MATRIX_CR 0x1bbc	/* register.h:8139 */
+#define P_ENCP_VIDEO_MATRIX_CR VCBUS_REG_ADDR(ENCP_VIDEO_MATRIX_CR)
+#define ENCP_VIDEO_RGBIN_CTRL 0x1bbd	/* register.h:8140 */
+#define P_ENCP_VIDEO_RGBIN_CTRL VCBUS_REG_ADDR(ENCP_VIDEO_RGBIN_CTRL)
+#define ENCP_MACV_BLANKY_VAL 0x1bc0	/* register.h:8142 */
+#define P_ENCP_MACV_BLANKY_VAL VCBUS_REG_ADDR(ENCP_MACV_BLANKY_VAL)
+#define ENCP_MACV_MAXY_VAL 0x1bc1	/* register.h:8143 */
+#define P_ENCP_MACV_MAXY_VAL VCBUS_REG_ADDR(ENCP_MACV_MAXY_VAL)
+#define ENCP_MACV_1ST_PSSYNC_STRT 0x1bc2	/* register.h:8144 */
+#define P_ENCP_MACV_1ST_PSSYNC_STRT VCBUS_REG_ADDR(ENCP_MACV_1ST_PSSYNC_STRT)
+#define ENCP_MACV_PSSYNC_STRT 0x1bc3	/* register.h:8145 */
+#define P_ENCP_MACV_PSSYNC_STRT VCBUS_REG_ADDR(ENCP_MACV_PSSYNC_STRT)
+#define ENCP_MACV_AGC_STRT 0x1bc4	/* register.h:8146 */
+#define P_ENCP_MACV_AGC_STRT VCBUS_REG_ADDR(ENCP_MACV_AGC_STRT)
+#define ENCP_MACV_AGC_END 0x1bc5	/* register.h:8147 */
+#define P_ENCP_MACV_AGC_END VCBUS_REG_ADDR(ENCP_MACV_AGC_END)
+#define ENCP_MACV_WAVE_END 0x1bc6	/* register.h:8148 */
+#define P_ENCP_MACV_WAVE_END VCBUS_REG_ADDR(ENCP_MACV_WAVE_END)
+#define ENCP_MACV_STRTLINE 0x1bc7	/* register.h:8149 */
+#define P_ENCP_MACV_STRTLINE VCBUS_REG_ADDR(ENCP_MACV_STRTLINE)
+#define ENCP_MACV_ENDLINE 0x1bc8	/* register.h:8150 */
+#define P_ENCP_MACV_ENDLINE VCBUS_REG_ADDR(ENCP_MACV_ENDLINE)
+#define ENCP_MACV_TS_CNT_MAX_L 0x1bc9	/* register.h:8151 */
+#define P_ENCP_MACV_TS_CNT_MAX_L VCBUS_REG_ADDR(ENCP_MACV_TS_CNT_MAX_L)
+#define ENCP_MACV_TS_CNT_MAX_H 0x1bca	/* register.h:8152 */
+#define P_ENCP_MACV_TS_CNT_MAX_H VCBUS_REG_ADDR(ENCP_MACV_TS_CNT_MAX_H)
+#define ENCP_MACV_TIME_DOWN 0x1bcb	/* register.h:8153 */
+#define P_ENCP_MACV_TIME_DOWN VCBUS_REG_ADDR(ENCP_MACV_TIME_DOWN)
+#define ENCP_MACV_TIME_LO 0x1bcc	/* register.h:8154 */
+#define P_ENCP_MACV_TIME_LO VCBUS_REG_ADDR(ENCP_MACV_TIME_LO)
+#define ENCP_MACV_TIME_UP 0x1bcd	/* register.h:8155 */
+#define P_ENCP_MACV_TIME_UP VCBUS_REG_ADDR(ENCP_MACV_TIME_UP)
+#define ENCP_MACV_TIME_RST 0x1bce	/* register.h:8156 */
+#define P_ENCP_MACV_TIME_RST VCBUS_REG_ADDR(ENCP_MACV_TIME_RST)
+#define ENCP_VBI_CTRL 0x1bd0	/* register.h:8158 */
+#define P_ENCP_VBI_CTRL VCBUS_REG_ADDR(ENCP_VBI_CTRL)
+#define ENCP_VBI_SETTING 0x1bd1	/* register.h:8159 */
+#define P_ENCP_VBI_SETTING VCBUS_REG_ADDR(ENCP_VBI_SETTING)
+#define ENCP_VBI_BEGIN 0x1bd2	/* register.h:8160 */
+#define P_ENCP_VBI_BEGIN VCBUS_REG_ADDR(ENCP_VBI_BEGIN)
+#define ENCP_VBI_WIDTH 0x1bd3	/* register.h:8161 */
+#define P_ENCP_VBI_WIDTH VCBUS_REG_ADDR(ENCP_VBI_WIDTH)
+#define ENCP_VBI_HVAL 0x1bd4	/* register.h:8162 */
+#define P_ENCP_VBI_HVAL VCBUS_REG_ADDR(ENCP_VBI_HVAL)
+#define ENCP_VBI_DATA0 0x1bd5	/* register.h:8163 */
+#define P_ENCP_VBI_DATA0 VCBUS_REG_ADDR(ENCP_VBI_DATA0)
+#define ENCP_VBI_DATA1 0x1bd6	/* register.h:8164 */
+#define P_ENCP_VBI_DATA1 VCBUS_REG_ADDR(ENCP_VBI_DATA1)
+
+#define ENCI_VIDEO_MODE 0x1b00	/* register.h:8185 */
+#define P_ENCI_VIDEO_MODE VCBUS_REG_ADDR(ENCI_VIDEO_MODE)
+#define ENCI_VIDEO_MODE_ADV 0x1b01	/* register.h:8186 */
+#define P_ENCI_VIDEO_MODE_ADV VCBUS_REG_ADDR(ENCI_VIDEO_MODE_ADV)
+#define ENCI_VIDEO_FSC_ADJ 0x1b02	/* register.h:8187 */
+#define P_ENCI_VIDEO_FSC_ADJ VCBUS_REG_ADDR(ENCI_VIDEO_FSC_ADJ)
+#define ENCI_VIDEO_BRIGHT 0x1b03	/* register.h:8188 */
+#define P_ENCI_VIDEO_BRIGHT VCBUS_REG_ADDR(ENCI_VIDEO_BRIGHT)
+#define ENCI_VIDEO_CONT 0x1b04	/* register.h:8189 */
+#define P_ENCI_VIDEO_CONT VCBUS_REG_ADDR(ENCI_VIDEO_CONT)
+#define ENCI_VIDEO_SAT 0x1b05	/* register.h:8190 */
+#define P_ENCI_VIDEO_SAT VCBUS_REG_ADDR(ENCI_VIDEO_SAT)
+#define ENCI_VIDEO_HUE 0x1b06	/* register.h:8191 */
+#define P_ENCI_VIDEO_HUE VCBUS_REG_ADDR(ENCI_VIDEO_HUE)
+#define ENCI_VIDEO_SCH 0x1b07	/* register.h:8192 */
+#define P_ENCI_VIDEO_SCH VCBUS_REG_ADDR(ENCI_VIDEO_SCH)
+#define ENCI_SYNC_MODE 0x1b08	/* register.h:8193 */
+#define P_ENCI_SYNC_MODE VCBUS_REG_ADDR(ENCI_SYNC_MODE)
+#define ENCI_SYNC_CTRL 0x1b09	/* register.h:8194 */
+#define P_ENCI_SYNC_CTRL VCBUS_REG_ADDR(ENCI_SYNC_CTRL)
+#define ENCI_SYNC_HSO_BEGIN 0x1b0a	/* register.h:8195 */
+#define P_ENCI_SYNC_HSO_BEGIN VCBUS_REG_ADDR(ENCI_SYNC_HSO_BEGIN)
+#define ENCI_SYNC_HSO_END 0x1b0b	/* register.h:8196 */
+#define P_ENCI_SYNC_HSO_END VCBUS_REG_ADDR(ENCI_SYNC_HSO_END)
+#define ENCI_SYNC_VSO_EVN 0x1b0c	/* register.h:8197 */
+#define P_ENCI_SYNC_VSO_EVN VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVN)
+#define ENCI_SYNC_VSO_ODD 0x1b0d	/* register.h:8198 */
+#define P_ENCI_SYNC_VSO_ODD VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODD)
+#define ENCI_SYNC_VSO_EVNLN 0x1b0e	/* register.h:8199 */
+#define P_ENCI_SYNC_VSO_EVNLN VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVNLN)
+#define ENCI_SYNC_VSO_ODDLN 0x1b0f	/* register.h:8200 */
+#define P_ENCI_SYNC_VSO_ODDLN VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODDLN)
+#define ENCI_SYNC_HOFFST 0x1b10	/* register.h:8201 */
+#define P_ENCI_SYNC_HOFFST VCBUS_REG_ADDR(ENCI_SYNC_HOFFST)
+#define ENCI_SYNC_VOFFST 0x1b11	/* register.h:8202 */
+#define P_ENCI_SYNC_VOFFST VCBUS_REG_ADDR(ENCI_SYNC_VOFFST)
+#define ENCI_SYNC_ADJ 0x1b12	/* register.h:8203 */
+#define P_ENCI_SYNC_ADJ VCBUS_REG_ADDR(ENCI_SYNC_ADJ)
+#define ENCI_RGB_SETTING 0x1b13	/* register.h:8204 */
+#define P_ENCI_RGB_SETTING VCBUS_REG_ADDR(ENCI_RGB_SETTING)
+#define ENCI_DE_H_BEGIN 0x1b16	/* register.h:8207 */
+#define P_ENCI_DE_H_BEGIN VCBUS_REG_ADDR(ENCI_DE_H_BEGIN)
+#define ENCI_DE_H_END 0x1b17	/* register.h:8208 */
+#define P_ENCI_DE_H_END VCBUS_REG_ADDR(ENCI_DE_H_END)
+#define ENCI_DE_V_BEGIN_EVEN 0x1b18	/* register.h:8209 */
+#define P_ENCI_DE_V_BEGIN_EVEN VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_EVEN)
+#define ENCI_DE_V_END_EVEN 0x1b19	/* register.h:8210 */
+#define P_ENCI_DE_V_END_EVEN VCBUS_REG_ADDR(ENCI_DE_V_END_EVEN)
+#define ENCI_DE_V_BEGIN_ODD 0x1b1a	/* register.h:8211 */
+#define P_ENCI_DE_V_BEGIN_ODD VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_ODD)
+#define ENCI_DE_V_END_ODD 0x1b1b	/* register.h:8212 */
+#define P_ENCI_DE_V_END_ODD VCBUS_REG_ADDR(ENCI_DE_V_END_ODD)
+#define ENCI_VBI_SETTING 0x1b20	/* register.h:8213 */
+#define P_ENCI_VBI_SETTING VCBUS_REG_ADDR(ENCI_VBI_SETTING)
+#define ENCI_VBI_CCDT_EVN 0x1b21	/* register.h:8214 */
+#define P_ENCI_VBI_CCDT_EVN VCBUS_REG_ADDR(ENCI_VBI_CCDT_EVN)
+#define ENCI_VBI_CCDT_ODD 0x1b22	/* register.h:8215 */
+#define P_ENCI_VBI_CCDT_ODD VCBUS_REG_ADDR(ENCI_VBI_CCDT_ODD)
+#define ENCI_VBI_CC525_LN 0x1b23	/* register.h:8216 */
+#define P_ENCI_VBI_CC525_LN VCBUS_REG_ADDR(ENCI_VBI_CC525_LN)
+#define ENCI_VBI_CC625_LN 0x1b24	/* register.h:8217 */
+#define P_ENCI_VBI_CC625_LN VCBUS_REG_ADDR(ENCI_VBI_CC625_LN)
+#define ENCI_VBI_WSSDT 0x1b25	/* register.h:8218 */
+#define P_ENCI_VBI_WSSDT VCBUS_REG_ADDR(ENCI_VBI_WSSDT)
+#define ENCI_VBI_WSS_LN 0x1b26	/* register.h:8219 */
+#define P_ENCI_VBI_WSS_LN VCBUS_REG_ADDR(ENCI_VBI_WSS_LN)
+#define ENCI_VBI_CGMSDT_L 0x1b27	/* register.h:8220 */
+#define P_ENCI_VBI_CGMSDT_L VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_L)
+#define ENCI_VBI_CGMSDT_H 0x1b28	/* register.h:8221 */
+#define P_ENCI_VBI_CGMSDT_H VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_H)
+#define ENCI_VBI_CGMS_LN 0x1b29	/* register.h:8222 */
+#define P_ENCI_VBI_CGMS_LN VCBUS_REG_ADDR(ENCI_VBI_CGMS_LN)
+#define ENCI_VBI_TTX_HTIME 0x1b2a	/* register.h:8223 */
+#define P_ENCI_VBI_TTX_HTIME VCBUS_REG_ADDR(ENCI_VBI_TTX_HTIME)
+#define ENCI_VBI_TTX_LN 0x1b2b	/* register.h:8224 */
+#define P_ENCI_VBI_TTX_LN VCBUS_REG_ADDR(ENCI_VBI_TTX_LN)
+#define ENCI_VBI_TTXDT0 0x1b2c	/* register.h:8225 */
+#define P_ENCI_VBI_TTXDT0 VCBUS_REG_ADDR(ENCI_VBI_TTXDT0)
+#define ENCI_VBI_TTXDT1 0x1b2d	/* register.h:8226 */
+#define P_ENCI_VBI_TTXDT1 VCBUS_REG_ADDR(ENCI_VBI_TTXDT1)
+#define ENCI_VBI_TTXDT2 0x1b2e	/* register.h:8227 */
+#define P_ENCI_VBI_TTXDT2 VCBUS_REG_ADDR(ENCI_VBI_TTXDT2)
+#define ENCI_VBI_TTXDT3 0x1b2f	/* register.h:8228 */
+#define P_ENCI_VBI_TTXDT3 VCBUS_REG_ADDR(ENCI_VBI_TTXDT3)
+#define ENCI_MACV_N0 0x1b30	/* register.h:8229 */
+#define P_ENCI_MACV_N0 VCBUS_REG_ADDR(ENCI_MACV_N0)
+#define ENCI_MACV_N1 0x1b31	/* register.h:8230 */
+#define P_ENCI_MACV_N1 VCBUS_REG_ADDR(ENCI_MACV_N1)
+#define ENCI_MACV_N2 0x1b32	/* register.h:8231 */
+#define P_ENCI_MACV_N2 VCBUS_REG_ADDR(ENCI_MACV_N2)
+#define ENCI_MACV_N3 0x1b33	/* register.h:8232 */
+#define P_ENCI_MACV_N3 VCBUS_REG_ADDR(ENCI_MACV_N3)
+#define ENCI_MACV_N4 0x1b34	/* register.h:8233 */
+#define P_ENCI_MACV_N4 VCBUS_REG_ADDR(ENCI_MACV_N4)
+#define ENCI_MACV_N5 0x1b35	/* register.h:8234 */
+#define P_ENCI_MACV_N5 VCBUS_REG_ADDR(ENCI_MACV_N5)
+#define ENCI_MACV_N6 0x1b36	/* register.h:8235 */
+#define P_ENCI_MACV_N6 VCBUS_REG_ADDR(ENCI_MACV_N6)
+#define ENCI_MACV_N7 0x1b37	/* register.h:8236 */
+#define P_ENCI_MACV_N7 VCBUS_REG_ADDR(ENCI_MACV_N7)
+#define ENCI_MACV_N8 0x1b38	/* register.h:8237 */
+#define P_ENCI_MACV_N8 VCBUS_REG_ADDR(ENCI_MACV_N8)
+#define ENCI_MACV_N9 0x1b39	/* register.h:8238 */
+#define P_ENCI_MACV_N9 VCBUS_REG_ADDR(ENCI_MACV_N9)
+#define ENCI_MACV_N10 0x1b3a	/* register.h:8239 */
+#define P_ENCI_MACV_N10 VCBUS_REG_ADDR(ENCI_MACV_N10)
+#define ENCI_MACV_N11 0x1b3b	/* register.h:8240 */
+#define P_ENCI_MACV_N11 VCBUS_REG_ADDR(ENCI_MACV_N11)
+#define ENCI_MACV_N12 0x1b3c	/* register.h:8241 */
+#define P_ENCI_MACV_N12 VCBUS_REG_ADDR(ENCI_MACV_N12)
+#define ENCI_MACV_N13 0x1b3d	/* register.h:8242 */
+#define P_ENCI_MACV_N13 VCBUS_REG_ADDR(ENCI_MACV_N13)
+#define ENCI_MACV_N14 0x1b3e	/* register.h:8243 */
+#define P_ENCI_MACV_N14 VCBUS_REG_ADDR(ENCI_MACV_N14)
+#define ENCI_MACV_N15 0x1b3f	/* register.h:8244 */
+#define P_ENCI_MACV_N15 VCBUS_REG_ADDR(ENCI_MACV_N15)
+#define ENCI_MACV_N16 0x1b40	/* register.h:8245 */
+#define P_ENCI_MACV_N16 VCBUS_REG_ADDR(ENCI_MACV_N16)
+#define ENCI_MACV_N17 0x1b41	/* register.h:8246 */
+#define P_ENCI_MACV_N17 VCBUS_REG_ADDR(ENCI_MACV_N17)
+#define ENCI_MACV_N18 0x1b42	/* register.h:8247 */
+#define P_ENCI_MACV_N18 VCBUS_REG_ADDR(ENCI_MACV_N18)
+#define ENCI_MACV_N19 0x1b43	/* register.h:8248 */
+#define P_ENCI_MACV_N19 VCBUS_REG_ADDR(ENCI_MACV_N19)
+#define ENCI_MACV_N20 0x1b44	/* register.h:8249 */
+#define P_ENCI_MACV_N20 VCBUS_REG_ADDR(ENCI_MACV_N20)
+#define ENCI_MACV_N21 0x1b45	/* register.h:8250 */
+#define P_ENCI_MACV_N21 VCBUS_REG_ADDR(ENCI_MACV_N21)
+#define ENCI_MACV_N22 0x1b46	/* register.h:8251 */
+#define P_ENCI_MACV_N22 VCBUS_REG_ADDR(ENCI_MACV_N22)
+#define ENCI_DBG_PX_RST 0x1b48	/* register.h:8253 */
+#define P_ENCI_DBG_PX_RST VCBUS_REG_ADDR(ENCI_DBG_PX_RST)
+#define ENCI_DBG_FLDLN_RST 0x1b49	/* register.h:8254 */
+#define P_ENCI_DBG_FLDLN_RST VCBUS_REG_ADDR(ENCI_DBG_FLDLN_RST)
+#define ENCI_DBG_PX_INT 0x1b4a	/* register.h:8255 */
+#define P_ENCI_DBG_PX_INT VCBUS_REG_ADDR(ENCI_DBG_PX_INT)
+#define ENCI_DBG_FLDLN_INT 0x1b4b	/* register.h:8256 */
+#define P_ENCI_DBG_FLDLN_INT VCBUS_REG_ADDR(ENCI_DBG_FLDLN_INT)
+#define ENCI_DBG_MAXPX 0x1b4c	/* register.h:8257 */
+#define P_ENCI_DBG_MAXPX VCBUS_REG_ADDR(ENCI_DBG_MAXPX)
+#define ENCI_DBG_MAXLN 0x1b4d	/* register.h:8258 */
+#define P_ENCI_DBG_MAXLN VCBUS_REG_ADDR(ENCI_DBG_MAXLN)
+#define ENCI_MACV_MAX_AMP 0x1b50	/* register.h:8259 */
+#define P_ENCI_MACV_MAX_AMP VCBUS_REG_ADDR(ENCI_MACV_MAX_AMP)
+#define ENCI_MACV_PULSE_LO 0x1b51	/* register.h:8260 */
+#define P_ENCI_MACV_PULSE_LO VCBUS_REG_ADDR(ENCI_MACV_PULSE_LO)
+#define ENCI_MACV_PULSE_HI 0x1b52	/* register.h:8261 */
+#define P_ENCI_MACV_PULSE_HI VCBUS_REG_ADDR(ENCI_MACV_PULSE_HI)
+#define ENCI_MACV_BKP_MAX 0x1b53	/* register.h:8262 */
+#define P_ENCI_MACV_BKP_MAX VCBUS_REG_ADDR(ENCI_MACV_BKP_MAX)
+#define ENCI_CFILT_CTRL 0x1b54	/* register.h:8263 */
+#define P_ENCI_CFILT_CTRL VCBUS_REG_ADDR(ENCI_CFILT_CTRL)
+#define ENCI_CFILT7 0x1b55	/* register.h:8264 */
+#define P_ENCI_CFILT7 VCBUS_REG_ADDR(ENCI_CFILT7)
+#define ENCI_YC_DELAY 0x1b56	/* register.h:8265 */
+#define P_ENCI_YC_DELAY VCBUS_REG_ADDR(ENCI_YC_DELAY)
+#define ENCI_VIDEO_EN 0x1b57	/* register.h:8266 */
+#define P_ENCI_VIDEO_EN VCBUS_REG_ADDR(ENCI_VIDEO_EN)
+#define VENC_VIDEO_PROG_MODE 0x1b68	/* /../ucode/register.h:8023 */
+#define P_VENC_VIDEO_PROG_MODE		VCBUS_REG_ADDR(VENC_VIDEO_PROG_MODE)
+
+#define ENCI_DVI_HSO_BEGIN 0x1c00	/* register.h:8280 */
+#define P_ENCI_DVI_HSO_BEGIN VCBUS_REG_ADDR(ENCI_DVI_HSO_BEGIN)
+#define ENCI_DVI_HSO_END 0x1c01	/* register.h:8281 */
+#define P_ENCI_DVI_HSO_END VCBUS_REG_ADDR(ENCI_DVI_HSO_END)
+#define ENCI_DVI_VSO_BLINE_EVN 0x1c02	/* register.h:8282 */
+#define P_ENCI_DVI_VSO_BLINE_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_BLINE_EVN)
+#define ENCI_DVI_VSO_BLINE_ODD 0x1c03	/* register.h:8283 */
+#define P_ENCI_DVI_VSO_BLINE_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_BLINE_ODD)
+#define ENCI_DVI_VSO_ELINE_EVN 0x1c04	/* register.h:8284 */
+#define P_ENCI_DVI_VSO_ELINE_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_ELINE_EVN)
+#define ENCI_DVI_VSO_ELINE_ODD 0x1c05	/* register.h:8285 */
+#define P_ENCI_DVI_VSO_ELINE_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_ELINE_ODD)
+#define ENCI_DVI_VSO_BEGIN_EVN 0x1c06	/* register.h:8286 */
+#define P_ENCI_DVI_VSO_BEGIN_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_BEGIN_EVN)
+#define ENCI_DVI_VSO_BEGIN_ODD 0x1c07	/* register.h:8287 */
+#define P_ENCI_DVI_VSO_BEGIN_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_BEGIN_ODD)
+#define ENCI_DVI_VSO_END_EVN 0x1c08	/* register.h:8288 */
+#define P_ENCI_DVI_VSO_END_EVN VCBUS_REG_ADDR(ENCI_DVI_VSO_END_EVN)
+#define ENCI_DVI_VSO_END_ODD 0x1c09	/* register.h:8289 */
+#define P_ENCI_DVI_VSO_END_ODD VCBUS_REG_ADDR(ENCI_DVI_VSO_END_ODD)
+#define ENCI_CFILT_CTRL2 0x1c0a	/* register.h:8295 */
+#define P_ENCI_CFILT_CTRL2 VCBUS_REG_ADDR(ENCI_CFILT_CTRL2)
+#define ENCI_DACSEL_0 0x1c0b	/* register.h:8296 */
+#define P_ENCI_DACSEL_0 VCBUS_REG_ADDR(ENCI_DACSEL_0)
+#define ENCI_DACSEL_1 0x1c0c	/* register.h:8297 */
+#define P_ENCI_DACSEL_1 VCBUS_REG_ADDR(ENCI_DACSEL_1)
+#define ENCP_DACSEL_0 0x1c0d	/* register.h:8298 */
+#define P_ENCP_DACSEL_0 VCBUS_REG_ADDR(ENCP_DACSEL_0)
+#define ENCP_DACSEL_1 0x1c0e	/* register.h:8299 */
+#define P_ENCP_DACSEL_1 VCBUS_REG_ADDR(ENCP_DACSEL_1)
+#define ENCP_MAX_LINE_SWITCH_POINT 0x1c0f	/* register.h:8300 */
+#define P_ENCP_MAX_LINE_SWITCH_POINT VCBUS_REG_ADDR(ENCP_MAX_LINE_SWITCH_POINT)
+#define ENCI_TST_EN 0x1c10	/* register.h:8301 */
+#define P_ENCI_TST_EN VCBUS_REG_ADDR(ENCI_TST_EN)
+#define ENCI_TST_MDSEL 0x1c11	/* register.h:8302 */
+#define P_ENCI_TST_MDSEL VCBUS_REG_ADDR(ENCI_TST_MDSEL)
+#define ENCI_TST_Y 0x1c12	/* register.h:8303 */
+#define P_ENCI_TST_Y VCBUS_REG_ADDR(ENCI_TST_Y)
+#define ENCI_TST_CB 0x1c13	/* register.h:8304 */
+#define P_ENCI_TST_CB VCBUS_REG_ADDR(ENCI_TST_CB)
+#define ENCI_TST_CR 0x1c14	/* register.h:8305 */
+#define P_ENCI_TST_CR VCBUS_REG_ADDR(ENCI_TST_CR)
+#define ENCI_TST_CLRBAR_STRT 0x1c15	/* register.h:8306 */
+#define P_ENCI_TST_CLRBAR_STRT VCBUS_REG_ADDR(ENCI_TST_CLRBAR_STRT)
+#define ENCI_TST_CLRBAR_WIDTH 0x1c16	/* register.h:8307 */
+#define P_ENCI_TST_CLRBAR_WIDTH VCBUS_REG_ADDR(ENCI_TST_CLRBAR_WIDTH)
+#define ENCI_TST_VDCNT_STSET 0x1c17	/* register.h:8308 */
+#define P_ENCI_TST_VDCNT_STSET VCBUS_REG_ADDR(ENCI_TST_VDCNT_STSET)
+#define ENCI_VFIFO2VD_CTL 0x1c18	/* register.h:8313 */
+#define P_ENCI_VFIFO2VD_CTL VCBUS_REG_ADDR(ENCI_VFIFO2VD_CTL)
+#define ENCI_VFIFO2VD_PIXEL_START 0x1c19	/* register.h:8315 */
+#define P_ENCI_VFIFO2VD_PIXEL_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_PIXEL_START)
+#define ENCI_VFIFO2VD_PIXEL_END 0x1c1a	/* register.h:8317 */
+#define P_ENCI_VFIFO2VD_PIXEL_END VCBUS_REG_ADDR(ENCI_VFIFO2VD_PIXEL_END)
+#define ENCI_VFIFO2VD_LINE_TOP_START 0x1c1b	/* register.h:8319 */
+#define P_ENCI_VFIFO2VD_LINE_TOP_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_TOP_START)
+#define ENCI_VFIFO2VD_LINE_TOP_END 0x1c1c	/* register.h:8321 */
+#define P_ENCI_VFIFO2VD_LINE_TOP_END \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_TOP_END)
+#define ENCI_VFIFO2VD_LINE_BOT_START 0x1c1d	/* register.h:8323 */
+#define P_ENCI_VFIFO2VD_LINE_BOT_START \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_BOT_START)
+#define ENCI_VFIFO2VD_LINE_BOT_END 0x1c1e	/* register.h:8325 */
+#define P_ENCI_VFIFO2VD_LINE_BOT_END \
+	VCBUS_REG_ADDR(ENCI_VFIFO2VD_LINE_BOT_END)
+#define ENCI_VFIFO2VD_CTL2 0x1c1f	/* register.h:8326 */
+#define P_ENCI_VFIFO2VD_CTL2 VCBUS_REG_ADDR(ENCI_VFIFO2VD_CTL2)
+
+#define ENCP_DVI_HSO_BEGIN 0x1c30	/* register.h:8354 */
+#define P_ENCP_DVI_HSO_BEGIN VCBUS_REG_ADDR(ENCP_DVI_HSO_BEGIN)
+#define ENCP_DVI_HSO_END 0x1c31	/* register.h:8355 */
+#define P_ENCP_DVI_HSO_END VCBUS_REG_ADDR(ENCP_DVI_HSO_END)
+#define ENCP_DVI_VSO_BLINE_EVN 0x1c32	/* register.h:8356 */
+#define P_ENCP_DVI_VSO_BLINE_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_BLINE_EVN)
+#define ENCP_DVI_VSO_BLINE_ODD 0x1c33	/* register.h:8357 */
+#define P_ENCP_DVI_VSO_BLINE_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_BLINE_ODD)
+#define ENCP_DVI_VSO_ELINE_EVN 0x1c34	/* register.h:8358 */
+#define P_ENCP_DVI_VSO_ELINE_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_ELINE_EVN)
+#define ENCP_DVI_VSO_ELINE_ODD 0x1c35	/* register.h:8359 */
+#define P_ENCP_DVI_VSO_ELINE_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_ELINE_ODD)
+#define ENCP_DVI_VSO_BEGIN_EVN 0x1c36	/* register.h:8360 */
+#define P_ENCP_DVI_VSO_BEGIN_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_BEGIN_EVN)
+#define ENCP_DVI_VSO_BEGIN_ODD 0x1c37	/* register.h:8361 */
+#define P_ENCP_DVI_VSO_BEGIN_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_BEGIN_ODD)
+#define ENCP_DVI_VSO_END_EVN 0x1c38	/* register.h:8362 */
+#define P_ENCP_DVI_VSO_END_EVN VCBUS_REG_ADDR(ENCP_DVI_VSO_END_EVN)
+#define ENCP_DVI_VSO_END_ODD 0x1c39	/* register.h:8363 */
+#define P_ENCP_DVI_VSO_END_ODD VCBUS_REG_ADDR(ENCP_DVI_VSO_END_ODD)
+#define ENCP_DE_H_BEGIN 0x1c3a	/* register.h:8364 */
+#define P_ENCP_DE_H_BEGIN VCBUS_REG_ADDR(ENCP_DE_H_BEGIN)
+#define ENCP_DE_H_END 0x1c3b	/* register.h:8365 */
+#define P_ENCP_DE_H_END VCBUS_REG_ADDR(ENCP_DE_H_END)
+#define ENCP_DE_V_BEGIN_EVEN 0x1c3c	/* register.h:8366 */
+#define P_ENCP_DE_V_BEGIN_EVEN VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_EVEN)
+#define ENCP_DE_V_END_EVEN 0x1c3d	/* register.h:8367 */
+#define P_ENCP_DE_V_END_EVEN VCBUS_REG_ADDR(ENCP_DE_V_END_EVEN)
+#define ENCP_DE_V_BEGIN_ODD 0x1c3e	/* register.h:8368 */
+#define P_ENCP_DE_V_BEGIN_ODD VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_ODD)
+#define ENCP_DE_V_END_ODD 0x1c3f	/* register.h:8369 */
+#define P_ENCP_DE_V_END_ODD VCBUS_REG_ADDR(ENCP_DE_V_END_ODD)
+#define ENCI_SYNC_LINE_LENGTH 0x1c40	/* register.h:8372 */
+#define P_ENCI_SYNC_LINE_LENGTH VCBUS_REG_ADDR(ENCI_SYNC_LINE_LENGTH)
+#define ENCI_SYNC_PIXEL_EN 0x1c41	/* register.h:8375 */
+#define P_ENCI_SYNC_PIXEL_EN VCBUS_REG_ADDR(ENCI_SYNC_PIXEL_EN)
+#define ENCI_SYNC_TO_LINE_EN 0x1c42	/* register.h:8382 */
+#define P_ENCI_SYNC_TO_LINE_EN VCBUS_REG_ADDR(ENCI_SYNC_TO_LINE_EN)
+#define ENCI_SYNC_TO_PIXEL 0x1c43	/* register.h:8384 */
+#define P_ENCI_SYNC_TO_PIXEL VCBUS_REG_ADDR(ENCI_SYNC_TO_PIXEL)
+#define ENCP_SYNC_LINE_LENGTH 0x1c44	/* register.h:8387 */
+#define P_ENCP_SYNC_LINE_LENGTH VCBUS_REG_ADDR(ENCP_SYNC_LINE_LENGTH)
+#define ENCP_SYNC_PIXEL_EN 0x1c45	/* register.h:8390 */
+#define P_ENCP_SYNC_PIXEL_EN VCBUS_REG_ADDR(ENCP_SYNC_PIXEL_EN)
+#define ENCP_SYNC_TO_LINE_EN 0x1c46	/* register.h:8397 */
+#define P_ENCP_SYNC_TO_LINE_EN VCBUS_REG_ADDR(ENCP_SYNC_TO_LINE_EN)
+#define ENCP_SYNC_TO_PIXEL 0x1c47	/* register.h:8399 */
+#define P_ENCP_SYNC_TO_PIXEL VCBUS_REG_ADDR(ENCP_SYNC_TO_PIXEL)
+
+/* [3:2] cntl_viu2_sel_venc: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT. */
+/* [1:0] cntl_viu1_sel_venc: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT. */
+#define VPU_VIU_VENC_MUX_CTRL 0x271a	/* register.h:9214 */
+#define P_VPU_VIU_VENC_MUX_CTRL VCBUS_REG_ADDR(VPU_VIU_VENC_MUX_CTRL)
+#define VPU_HDMI_SETTING 0x271b	/* register.h:9229 */
+#define P_VPU_HDMI_SETTING VCBUS_REG_ADDR(VPU_HDMI_SETTING)
+
+#define VPU_HDMI_DATA_OVR 0x2727	/* register.h:9270 */
+#define P_VPU_HDMI_DATA_OVR VCBUS_REG_ADDR(VPU_HDMI_DATA_OVR)
+#define VPU_HDMI_FMT_CTRL 0x2743
+#define P_VPU_HDMI_FMT_CTRL VCBUS_REG_ADDR(VPU_HDMI_FMT_CTRL)
+
+/* c_always_on_pointer.h:71 */
+#define AO_RTI_PULL_UP_REG ((0x00 << 10) | (0x0B << 2))
+#define P_AO_RTI_PULL_UP_REG		AOBUS_REG_ADDR(AO_RTI_PULL_UP_REG)
+#define AO_RTI_PIN_MUX_REG ((0x00 << 10) | (0x05 << 2))
+#define P_AO_RTI_PIN_MUX_REG		AOBUS_REG_ADDR(AO_RTI_PIN_MUX_REG)
+#define AO_DEBUG_REG0 ((0x00 << 10) | (0x28 << 2))
+#define P_AO_DEBUG_REG0		AOBUS_REG_ADDR(AO_DEBUG_REG0)
+#define AO_DEBUG_REG1 ((0x00 << 10) | (0x29 << 2))
+#define P_AO_DEBUG_REG1		AOBUS_REG_ADDR(AO_DEBUG_REG1)
+#define AO_DEBUG_REG2 ((0x00 << 10) | (0x2a << 2))
+#define P_AO_DEBUG_REG2		AOBUS_REG_ADDR(AO_DEBUG_REG2)
+#define AO_DEBUG_REG3 ((0x00 << 10) | (0x2b << 2))
+#define P_AO_DEBUG_REG3		AOBUS_REG_ADDR(AO_DEBUG_REG3)
+#define AO_CEC_GEN_CNTL ((0x00 << 10) | (0x40 << 2))
+#define P_AO_CEC_GEN_CNTL		AOBUS_REG_ADDR(AO_CEC_GEN_CNTL)
+#define AO_CEC_RW_REG ((0x00 << 10) | (0x41 << 2))
+#define P_AO_CEC_RW_REG		AOBUS_REG_ADDR(AO_CEC_RW_REG)
+#define AO_CEC_INTR_MASKN ((0x00 << 10) | (0x42 << 2))
+#define P_AO_CEC_INTR_MASKN		AOBUS_REG_ADDR(AO_CEC_INTR_MASKN)
+#define AO_CEC_INTR_CLR ((0x00 << 10) | (0x43 << 2))
+#define P_AO_CEC_INTR_CLR		AOBUS_REG_ADDR(AO_CEC_INTR_CLR)
+#define AO_CEC_INTR_STAT ((0x00 << 10) | (0x44 << 2))
+#define P_AO_CEC_INTR_STAT		AOBUS_REG_ADDR(AO_CEC_INTR_STAT)
+
+#define P_AO_RTI_GEN_PWR_SLEEP0 (0xc8100000 + (0x3a << 2))
+
+#define P_HDMITX_ADDR_PORT_SEC        0xda83a000
+#define P_HDMITX_DATA_PORT_SEC        0xda83a004
+#define P_HDMITX_CTRL_PORT_SEC        0xda83a008
+/* secure address P_HDMITX_ADDR_PORT 0xda83a000 */
+#define P_HDMITX_ADDR_PORT        0xc883a000
+#define P_HDMITX_DATA_PORT        0xc883a004
+#define P_HDMITX_CTRL_PORT        0xc883a008
+
+#endif
diff --git a/arch/arm/cpu/armv8/txl/hdmitx20/reg_ops.c b/arch/arm/cpu/armv8/txl/hdmitx20/reg_ops.c
new file mode 100644
index 0000000..85206cb
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/hdmitx20/reg_ops.c
@@ -0,0 +1,125 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/hdmitx20/reg_ops.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <asm/arch/io.h>
+#include <asm/io.h>
+#include "mach_reg.h"
+#include "hdmitx_reg.h"
+#include <amlogic/hdmi.h>
+
+static int dbg_en;
+
+void hd_write_reg(unsigned long addr, unsigned long val)
+{
+	writel(val, addr);
+	if (dbg_en)
+		printk("W: 0x%08lx  0x%08lx %s 0x%08lx\n", addr, val, (val == hd_read_reg(addr)) ? "==" : "!=", hd_read_reg(addr));
+}
+
+unsigned long hd_read_reg(unsigned long addr)
+{
+	unsigned long val = 0;
+	val = readl(addr);
+	if (dbg_en)
+		printk("R: 0x%08lx   0x%08lx\n", addr, val);
+	return val;
+}
+
+void hd_set_reg_bits(unsigned long addr, unsigned long value,
+	unsigned long offset, unsigned long len)
+{
+	unsigned long data = 0;
+
+	data = hd_read_reg(addr);
+	data &= ~(((1L << len) - 1) << offset);
+	data |= (value & ((1L << len) - 1)) << offset;
+	hd_write_reg(addr, data);
+}
+
+unsigned int hdmitx_rd_reg(unsigned int addr)
+{
+	unsigned int data = 0;
+	unsigned long offset = (addr & DWC_OFFSET_MASK) >> 24;
+
+	if (addr & SEC_OFFSET) {
+		/* TODO */
+		/* LATER */
+	} else {
+		addr = addr & 0xffff;
+
+		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
+		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
+		data = hd_read_reg(P_HDMITX_DATA_PORT + offset);
+	}
+	if (dbg_en)
+		pr_info("%s rd[0x%x] 0x%x\n", offset ? "DWC" : "TOP",
+			addr, data);
+	return data;
+}
+
+void hdmitx_wr_reg(unsigned int addr, unsigned int data)
+{
+	unsigned long offset = (addr & DWC_OFFSET_MASK) >> 24;
+
+	if (addr & SEC_OFFSET) {
+		/* TODO */
+		/* LATER */
+	} else {
+		addr = addr & 0xffff;
+
+		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
+		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
+		hd_write_reg(P_HDMITX_DATA_PORT + offset, data);
+	}
+	if (dbg_en)
+		pr_info("%s wr[0x%x] 0x%x\n", offset ? "DWC" : "TOP",
+			addr, data);
+}
+
+void hdmitx_set_reg_bits(unsigned int addr, unsigned int value,
+	unsigned int offset, unsigned int len)
+{
+	unsigned int data32 = 0;
+
+	data32 = hdmitx_rd_reg(addr);
+	data32 &= ~(((1 << len) - 1) << offset);
+	data32 |= (value & ((1 << len) - 1)) << offset;
+	hdmitx_wr_reg(addr, data32);
+}
+
+void hdmitx_poll_reg(unsigned int addr, unsigned int val, unsigned long timeout)
+{
+	udelay(2000);
+	if (!(hdmitx_rd_reg(addr) & val))
+		pr_info("hdmitx poll:0x%x  val:0x%x t=%dms timeout\n",
+			addr, val, 2000);
+}
+
+void hdmitx_rd_check_reg (unsigned long addr, unsigned long exp_data, unsigned long mask)
+{
+    unsigned long rd_data;
+    rd_data = hdmitx_rd_reg(addr);
+    if ((rd_data | mask) != (exp_data | mask)) {
+        pr_info("HDMITX-DWC addr=0x%04x rd_data=0x%02x\n", (unsigned int)addr, (unsigned int)rd_data);
+        pr_info("Error: HDMITX-DWC exp_data=0x%02x mask=0x%02x\n", (unsigned int)exp_data, (unsigned int)mask);
+    }
+}
diff --git a/arch/arm/cpu/armv8/txl/mailbox.c b/arch/arm/cpu/armv8/txl/mailbox.c
new file mode 100644
index 0000000..f94663e
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/mailbox.c
@@ -0,0 +1,197 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/mailbox.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include <common.h>
+#include <asm/arch/io.h>
+#include <command.h>
+#include <malloc.h>
+#include <asm/arch/mailbox.h>
+#include <asm/arch/secure_apb.h>
+
+/* Bit position for size value in MHU header */
+#define SIZE_SHIFT	20
+/* Mask to extract size value in MHU header*/
+#define SIZE_MASK	0x1ff
+
+static unsigned int *ap_mb_stat[] = {
+	(unsigned int *)HIU_MAILBOX_STAT_4,
+	(unsigned int *)HIU_MAILBOX_STAT_5,
+};
+static unsigned int *ap_mb_set[] = {
+	(unsigned int *)HIU_MAILBOX_SET_4,
+	(unsigned int *)HIU_MAILBOX_SET_5,
+};
+static unsigned int *ap_mb_clear[] = {
+	(unsigned int *)HIU_MAILBOX_CLR_4,
+	(unsigned int *)HIU_MAILBOX_CLR_5,
+};
+static unsigned int *ap_mb_payload[] = {
+	(unsigned int *)(P_SHARE_SRAM_BASE + MHU_LOW_AP_TO_SCP_PAYLOAD),
+	(unsigned int *)(P_SHARE_SRAM_BASE + MHU_HIGH_AP_TO_SCP_PAYLOAD),
+};
+static unsigned int *scp_mb_stat[] = {
+	(unsigned int *)HIU_MAILBOX_STAT_1,
+	(unsigned int *)HIU_MAILBOX_STAT_2,
+};
+/*
+static unsigned int *scp_mb_set[] = {
+	(unsigned int *)HIU_MAILBOX_SET_1,
+	(unsigned int *)HIU_MAILBOX_SET_2,
+};
+*/
+static unsigned int *scp_mb_clear[] = {
+	(unsigned int *)HIU_MAILBOX_CLR_1,
+	(unsigned int *)HIU_MAILBOX_CLR_2,
+};
+static unsigned int *scp_mb_payload[] = {
+	(unsigned int *)(P_SHARE_SRAM_BASE + MHU_LOW_SCP_TO_AP_PAYLOAD),
+	(unsigned int *)(P_SHARE_SRAM_BASE + MHU_HIGH_SCP_TO_AP_PAYLOAD),
+};
+
+static void mb_message_start(unsigned int priority)
+{
+	while (readl(ap_mb_stat[priority]) != 0)
+		;
+}
+static void mb_message_send(unsigned int command, unsigned int priority)
+{
+	writel(command, ap_mb_set[priority]);
+	while (readl(ap_mb_stat[priority]) != 0)
+		;
+}
+static unsigned int mb_message_wait(unsigned int priority)
+{
+	unsigned int response;
+	while (!(response = readl(scp_mb_stat[priority])))
+		;
+	return response;
+}
+static void mb_message_end(unsigned int priority)
+{
+	writel(0xffffffff, scp_mb_clear[priority]);
+}
+static unsigned int mb_message_receive(
+					void **message_out,
+					unsigned int *size_out,
+					unsigned int priority)
+{
+	unsigned int response = mb_message_wait(priority);
+	unsigned int size = (response >> SIZE_SHIFT) & SIZE_MASK;
+
+	response &= ~(SIZE_MASK << SIZE_SHIFT);
+
+	if (size_out)
+		*size_out = size;
+	if (message_out)
+		*message_out = (void *)(scp_mb_payload[priority]);
+
+	return response;
+}
+static void mb_init(unsigned int priority)
+{
+	writel(0xffffffff, ap_mb_clear[priority]);
+}
+
+static void scpi_send32(unsigned int command,
+			unsigned int message, unsigned int priority)
+{
+	mb_init(priority);
+	mb_message_start(priority);
+	writel(message, ap_mb_payload[priority]);
+	mb_message_send(command, priority);
+	mb_message_wait(priority);
+	mb_message_end(priority);
+}
+
+static void scpi_send_block(unsigned int command,
+			unsigned int *message, unsigned int message_size, unsigned int priority)
+{
+	mb_init(priority);
+	mb_message_start(priority);
+	memcpy(ap_mb_payload[priority], message, message_size);
+	mb_message_send(command, priority);
+	mb_message_wait(priority);
+	mb_message_end(priority);
+}
+
+void open_scp_log(unsigned int channel)
+{
+	scpi_send32(SCPI_CMD_OPEN_SCP_LOG, channel, LOW_PRIORITY);
+}
+
+int send_usr_data(unsigned int clinet_id, unsigned int *val, unsigned int size)
+{
+	unsigned long command;
+
+	if (size > 0x1fd)
+		return -1;
+
+	command = ((unsigned int)SCPI_CMD_SET_USR_DATA & 0xff) | ((clinet_id & 0xff) << 8) | ((size & 0x1ff) << 20);
+	scpi_send_block(command,val,size,0);
+
+	return 0;
+}
+
+/*
+*  type:
+*		0: data; 1: version
+*/
+int thermal_calibration(unsigned int type, unsigned int data)
+{
+	unsigned int *appayload = ap_mb_payload[LOW_PRIORITY];
+	unsigned int *response;
+	unsigned int size;
+
+	mb_message_start(LOW_PRIORITY);
+	writel(type, appayload);
+	writel(data, appayload+1);
+	mb_message_send(
+				((0x8 << SIZE_SHIFT) | SCPI_CMD_THERMAL_CALIB),
+				LOW_PRIORITY);
+	mb_message_receive((void *)&response, &size, LOW_PRIORITY);
+	mb_message_end(LOW_PRIORITY);
+
+	if (*response != SCPI_SUCCESS)
+		return -1;
+	else
+		return 0;
+}
+
+int thermal_get_value(unsigned int sensor_id, unsigned int *value)
+{
+	unsigned int *response;
+	unsigned int size;
+
+	mb_message_start(LOW_PRIORITY);
+	writel(sensor_id, ap_mb_payload[LOW_PRIORITY]);
+	mb_message_send(
+				((0x4 << SIZE_SHIFT) | SCPI_CMD_SENSOR_VALUE),
+				LOW_PRIORITY);
+	mb_message_receive((void *)&response, &size, LOW_PRIORITY);
+	mb_message_end(LOW_PRIORITY);
+
+	*value = *(response+1);
+	if (*response != SCPI_SUCCESS)
+		return -1;
+	else
+		return 0;
+}
diff --git a/arch/arm/cpu/armv8/txl/power_gate.h b/arch/arm/cpu/armv8/txl/power_gate.h
new file mode 100644
index 0000000..18adb03
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/power_gate.h
@@ -0,0 +1,1164 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/power_gate.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __POWER_MGR_HEADER_
+#define __POWER_MGR_HEADER_
+
+#include <asm/arch/io.h>
+#include <common.h>
+#include <asm/arch-gxb/io.h>
+/* #include <asm/arch-gxb/register.h> */
+#include <asm/arch/secure_apb.h>
+/* clock gate control */
+
+#define DEBUG_MASK 0
+
+#define SET_CLK_GATE_MASK(reg, mask) __raw_writel((__raw_readl(reg)|mask), reg)
+#define CLEAR_CLK_GATE_MASK(reg, mask) \
+	__raw_writel((__raw_readl(reg)&(~mask)), reg)
+#define CLK_GATE_ON(_MOD) do { \
+	if (DEBUG_MASK) \
+		printf("on reg %24s before read :0x%x : 0x%x\n",\
+				GCLK_NAME_##_MOD, \
+				(unsigned int)GCLK_REG_##_MOD, \
+				__raw_readl(GCLK_REG_##_MOD)); \
+		SET_CLK_GATE_MASK(GCLK_REG_##_MOD, \
+				(unsigned int)GCLK_MASK_##_MOD); \
+	if (DEBUG_MASK) \
+		printf("on reg %24s after  read :0x%x : 0x%x\n",\
+				GCLK_NAME_##_MOD, \
+				(unsigned int)GCLK_REG_##_MOD, \
+				__raw_readl(GCLK_REG_##_MOD)); \
+	} while (0)
+
+#define CLK_GATE_OFF(_MOD) do { \
+	if (DEBUG_MASK) \
+		printf("off reg[ %24s ][0x%08x]before read:0x%08x:0x%08x\n",\
+				GCLK_NAME_##_MOD, (int)GCLK_MASK_##_MOD, \
+				(unsigned int)GCLK_REG_##_MOD, \
+				__raw_readl(GCLK_REG_##_MOD)); \
+	CLEAR_CLK_GATE_MASK(GCLK_REG_##_MOD, (unsigned int)GCLK_MASK_##_MOD);\
+	if (DEBUG_MASK)\
+		printf("off reg[ %24s ][0x%08x] read after:0x%08x:0x%08x\n",\
+				GCLK_NAME_##_MOD, \
+				(int)GCLK_MASK_##_MOD, \
+				(unsigned int)GCLK_REG_##_MOD, \
+				__raw_readl(GCLK_REG_##_MOD)); \
+	} while (0)
+
+#define IS_CLK_GATE_ON(_MOD) (__raw_readl(GCLK_REG_##_MOD) & (GCLK_MASK_##_MOD))
+#define GATE_INIT(_MOD) GCLK_ref[GCLK_IDX_##_MOD] = IS_CLK_GATE_ON(_MOD) ? 1 : 0
+
+#define GCLK_IDX_DDR         0
+#define GCLK_NAME_DDR      "DDR"
+#define GCLK_DEV_DDR      "CLKGATE_DDR"
+#define GCLK_REG_DDR      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_DDR      (1<<0)
+
+#define GCLK_IDX_DOS         1
+#define GCLK_NAME_DOS      "DOS"
+#define GCLK_DEV_DOS      "CLKGATE_DOS"
+#define GCLK_REG_DOS      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_DOS      (1<<1)
+
+#define GCLK_IDX_RESERVED0_0         2
+#define GCLK_NAME_RESERVED0_0      "RESERVED0_0"
+#define GCLK_DEV_RESERVED0_0      "CLKGATE_RESERVED0_0"
+#define GCLK_REG_RESERVED0_0      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_0      (1<<2)
+
+#define GCLK_IDX_RESERVED0_1         3
+#define GCLK_NAME_RESERVED0_1      "RESERVED0_1"
+#define GCLK_DEV_RESERVED0_1      "CLKGATE_RESERVED0_1"
+#define GCLK_REG_RESERVED0_1      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_1      (1<<3)
+
+/* #define GCLK_IDX_AHB_BRIDGE         4 */
+/* #define GCLK_NAME_AHB_BRIDGE      "AHB_BRIDGE" */
+/* #define GCLK_DEV_AHB_BRIDGE      "CLKGATE_AHB_BRIDGE" */
+/* #define GCLK_REG_AHB_BRIDGE      (HHI_GCLK_MPEG0) */
+/* #define GCLK_MASK_AHB_BRIDGE      (1<<4) */
+
+#define GCLK_IDX_ISA         5
+#define GCLK_NAME_ISA      "ISA"
+#define GCLK_DEV_ISA      "CLKGATE_ISA"
+#define GCLK_REG_ISA      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_ISA      (1<<5)
+
+/* NEW ADD */
+#define GCLK_IDX_PL310_CBUS         6
+#define GCLK_NAME_PL310_CBUS      "PL310_CBUS"
+#define GCLK_DEV_PL310_CBUS      "CLKGATE_PL310_CBUS"
+#define GCLK_REG_PL310_CBUS      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_PL310_CBUS      (1<<6)
+
+#define GCLK_IDX_PERIPHS_TOP     7
+#define GCLK_NAME_PERIPHS_TOP      "PERIPHS_TOP"
+#define GCLK_DEV_PERIPHS_TOP      "CLKGATE_PERIPHS_TOP"
+#define GCLK_REG_PERIPHS_TOP      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_PERIPHS_TOP      (1<<7)
+
+#define GCLK_IDX_SPICC         8
+#define GCLK_NAME_SPICC      "SPICC"
+#define GCLK_DEV_SPICC      "CLKGATE_SPICC"
+#define GCLK_REG_SPICC      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_SPICC      (1<<8)
+
+#define GCLK_IDX_I2C         9
+#define GCLK_NAME_I2C      "I2C"
+#define GCLK_DEV_I2C      "CLKGATE_I2C"
+#define GCLK_REG_I2C      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_I2C      (1<<9)
+
+#define GCLK_IDX_SAR_ADC         10
+#define GCLK_NAME_SAR_ADC      "SAR_ADC"
+#define GCLK_DEV_SAR_ADC      "CLKGATE_SAR_ADC"
+//#define GCLK_REG_SAR_ADC      (HHI_SAR_CLK_CNTL) //no HHI_SAR_CLK_CNTL on TXL
+#define GCLK_REG_SAR_ADC      (AO_SAR_CLK)
+#define GCLK_MASK_SAR_ADC      (1<<8)
+
+#define GCLK_IDX_SMART_CARD_MPEG_DOMAIN         11
+#define GCLK_NAME_SMART_CARD_MPEG_DOMAIN      "SMART_CARD_MPEG_DOMAIN"
+#define GCLK_DEV_SMART_CARD_MPEG_DOMAIN      "CLKGATE_SMART_CARD_MPEG_DOMAIN"
+#define GCLK_REG_SMART_CARD_MPEG_DOMAIN      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_SMART_CARD_MPEG_DOMAIN      (1<<11)
+
+#define GCLK_IDX_RANDOM_NUM_GEN         12
+#define GCLK_NAME_RANDOM_NUM_GEN      "RANDOM_NUM_GEN"
+#define GCLK_DEV_RANDOM_NUM_GEN      "CLKGATE_RANDOM_NUM_GEN"
+#define GCLK_REG_RANDOM_NUM_GEN      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RANDOM_NUM_GEN      (1<<12)
+
+#define GCLK_IDX_UART0         13
+#define GCLK_NAME_UART0      "UART0"
+#define GCLK_DEV_UART0      "CLKGATE_UART0"
+#define GCLK_REG_UART0      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_UART0      (1<<13)
+
+/* gxb no this clock gate */
+/* #define GCLK_IDX_SDHC         14 */
+/* #define GCLK_NAME_SDHC      "SDHC" */
+/* #define GCLK_DEV_SDHC      "CLKGATE_SDHC" */
+/* #define GCLK_REG_SDHC      (HHI_GCLK_MPEG0) */
+/* #define GCLK_MASK_SDHC      (1<<14) */
+
+#define GCLK_IDX_STREAM         15
+#define GCLK_NAME_STREAM      "STREAM"
+#define GCLK_DEV_STREAM      "CLKGATE_STREAM"
+#define GCLK_REG_STREAM      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_STREAM      (1<<15)
+
+#define GCLK_IDX_ASYNC_FIFO         16
+#define GCLK_NAME_ASYNC_FIFO      "ASYNC_FIFO"
+#define GCLK_DEV_ASYNC_FIFO      "CLKGATE_ASYNC_FIFO"
+#define GCLK_REG_ASYNC_FIFO      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_ASYNC_FIFO      (1<<16)
+
+/* gxb no this clock gate */
+/* #define GCLK_IDX_SDIO         17 */
+/* #define GCLK_NAME_SDIO      "SDIO" */
+/* #define GCLK_DEV_SDIO      "CLKGATE_SDIO" */
+/* #define GCLK_REG_SDIO      (HHI_GCLK_MPEG0) */
+/* #define GCLK_MASK_SDIO      (1<<17) */
+
+/* gxb no this clock gate */
+/* #define GCLK_IDX_AUD_BUF         18 */
+/* #define GCLK_NAME_AUD_BUF      "AUD_BUF" */
+/* #define GCLK_DEV_AUD_BUF      "CLKGATE_AUD_BUF" */
+/* #define GCLK_REG_AUD_BUF      (HHI_GCLK_MPEG0) */
+/* #define GCLK_MASK_AUD_BUF      (1<<18) */
+
+#define GCLK_IDX_HIU_PARSER         19
+#define GCLK_NAME_HIU_PARSER      "HIU_PARSER"
+#define GCLK_DEV_HIU_PARSER      "CLKGATE_HIU_PARSER"
+#define GCLK_REG_HIU_PARSER      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_HIU_PARSER      (1<<19)
+
+#define GCLK_IDX_RESERVED0_2         20
+#define GCLK_NAME_RESERVED0_2      "RESERVED0_2"
+#define GCLK_DEV_RESERVED0_2      "CLKGATE_RESERVED0_2"
+#define GCLK_REG_RESERVED0_2      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_2      (1<<20)
+
+/* NEW ADD */
+#define GCLK_IDX_RESERVED0_3         21
+#define GCLK_NAME_RESERVED0_3      "RESERVED0_3 "
+#define GCLK_DEV_RESERVED0_3      "CLKGATE_RESERVED0_3 "
+#define GCLK_REG_RESERVED0_3      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_3      (1<<21)
+
+#define GCLK_IDX_RESERVED0_4         22
+#define GCLK_NAME_RESERVED0_4      "RESERVED0_4"
+#define GCLK_DEV_RESERVED0_4      "CLKGATE_RESERVED0_4"
+#define GCLK_REG_RESERVED0_4      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_4      (1<<22)
+
+#define GCLK_IDX_ASSIST_MISC         23
+#define GCLK_NAME_ASSIST_MISC      "ASSIST_MISC"
+#define GCLK_DEV_ASSIST_MISC      "CLKGATE_ASSIST_MISC"
+#define GCLK_REG_ASSIST_MISC      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_ASSIST_MISC      (1<<23)
+
+
+#define  GCLK_IDX_EMMC_A         24
+#define GCLK_NAME_EMMC_A      "EMMC_A"
+#define  GCLK_DEV_EMMC_A     "CLKGATE_EMMC_A"
+#define  GCLK_REG_EMMC_A      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_EMMC_A      (1<<24)
+
+#define  GCLK_IDX_EMMC_B         25
+#define GCLK_NAME_EMMC_B      "EMMC_B"
+#define  GCLK_DEV_EMMC_B      "CLKGATE_EMMC_B"
+#define  GCLK_REG_EMMC_B      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_EMMC_B      (1<<25)
+
+#define  GCLK_IDX_EMMC_C         26
+#define GCLK_NAME_EMMC_C      "EMMC_C"
+#define  GCLK_DEV_EMMC_C      "CLKGATE_EMMC_C"
+#define  GCLK_REG_EMMC_C      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_EMMC_C      (1<<26)
+
+#define GCLK_IDX_RESERVED0_8         27
+#define GCLK_NAME_RESERVED0_8      "RESERVED0_8"
+#define GCLK_DEV_RESERVED0_8      "CLKGATE_RESERVED0_8"
+#define GCLK_REG_RESERVED0_8      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_8      (1<<27)
+
+#define GCLK_IDX_RESERVED0_9         28
+#define GCLK_NAME_RESERVED0_9      "RESERVED0_9"
+#define GCLK_DEV_RESERVED0_9      "CLKGATE_RESERVED0_9"
+#define GCLK_REG_RESERVED0_9      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_9      (1<<28)
+
+#define GCLK_IDX_RESERVED0_A         29
+#define GCLK_NAME_RESERVED0_A      "RESERVED0_A"
+#define GCLK_DEV_RESERVED0_A      "CLKGATE_RESERVED0_A"
+#define GCLK_REG_RESERVED0_A      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_A      (1<<29)
+
+#define GCLK_IDX_SPI         30
+#define GCLK_NAME_SPI      "SPI"
+#define GCLK_DEV_SPI      "CLKGATE_SPI"
+#define GCLK_REG_SPI      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_SPI      (1<<30)
+
+#define GCLK_IDX_RESERVED0_B         31
+#define GCLK_NAME_RESERVED0_B      "RESERVED0_B"
+#define GCLK_DEV_RESERVED0_B      "CLKGATE_RESERVED0_B"
+#define GCLK_REG_RESERVED0_B      (HHI_GCLK_MPEG0)
+#define GCLK_MASK_RESERVED0_B      (1<<31)
+
+/**************************************************************/
+
+#define GCLK_IDX_RESERVED1_1         32
+#define GCLK_NAME_RESERVED1_1      "RESERVED1_1"
+#define GCLK_DEV_RESERVED1_1      "CLKGATE_RESERVED1_1"
+#define GCLK_REG_RESERVED1_1      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_1      (1<<0)
+
+
+#define GCLK_IDX_RESERVED1_2         33
+#define GCLK_NAME_RESERVED1_2      "RESERVED1_2"
+#define GCLK_DEV_RESERVED1_2      "CLKGATE_RESERVED1_2"
+#define GCLK_REG_RESERVED1_2      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_2      (1<<1)
+
+
+#define GCLK_IDX_AUD_IN         34
+#define GCLK_NAME_AUD_IN      "AUD_IN"
+#define GCLK_DEV_AUD_IN      "CLKGATE_AUD_IN"
+#define GCLK_REG_AUD_IN      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AUD_IN      (1<<2)
+
+#define GCLK_IDX_ETHERNET         35
+#define GCLK_NAME_ETHERNET      "ETHERNET"
+#define GCLK_DEV_ETHERNET      "CLKGATE_ETHERNET"
+#define GCLK_REG_ETHERNET      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_ETHERNET      (1<<3)
+
+#define GCLK_IDX_ETH_CLK     145
+#define GCLK_NAME_ETH_CLK    "ETH_CLK"
+#define GCLK_REG_ETH_CLK     (HHI_MPLL_CNTL10)
+#define GCLK_MASK_ETH_CLK      (1<<3)
+
+#define GCLK_IDX_DEMUX         36
+#define GCLK_NAME_DEMUX      "DEMUX"
+#define GCLK_DEV_DEMUX      "CLKGATE_DEMUX"
+#define GCLK_REG_DEMUX      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_DEMUX      (1<<4)
+
+#define GCLK_IDX_RESERVED1_3         37
+#define GCLK_NAME_RESERVED1_3      "RESERVED1_3"
+#define GCLK_DEV_RESERVED1_3      "CLKGATE_RESERVED1_3"
+#define GCLK_REG_RESERVED1_3      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_3      (1<<5)
+
+#define GCLK_IDX_AIU_AI_TOP_GLUE         38
+#define GCLK_NAME_AIU_AI_TOP_GLUE      "AIU_AI_TOP_GLUE"
+#define GCLK_DEV_AIU_AI_TOP_GLUE      "CLKGATE_AIU_AI_TOP_GLUE"
+#define GCLK_REG_AIU_AI_TOP_GLUE      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_AI_TOP_GLUE      (1<<6)
+
+#define GCLK_IDX_AIU_IEC958         39
+#define GCLK_NAME_AIU_IEC958      "AIU_IEC958"
+#define GCLK_DEV_AIU_IEC958      "CLKGATE_AIU_IEC958"
+#define GCLK_REG_AIU_IEC958      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_IEC958      (1<<7)
+
+#define GCLK_IDX_AIU_I2S_OUT         40
+#define GCLK_NAME_AIU_I2S_OUT      "AIU_I2S_OUT"
+#define GCLK_DEV_AIU_I2S_OUT      "CLKGATE_AIU_I2S_OUT"
+#define GCLK_REG_AIU_I2S_OUT      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_I2S_OUT      (1<<8)
+
+#define GCLK_IDX_AIU_AMCLK_MEASURE         41
+#define GCLK_NAME_AIU_AMCLK_MEASURE      "AIU_AMCLK_MEASURE"
+#define GCLK_DEV_AIU_AMCLK_MEASURE      "CLKGATE_AIU_AMCLK_MEASURE"
+#define GCLK_REG_AIU_AMCLK_MEASURE      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_AMCLK_MEASURE      (1<<9)
+
+#define GCLK_IDX_AIU_AIFIFO2         42
+#define GCLK_NAME_AIU_AIFIFO2      "AIU_AIFIFO2"
+#define GCLK_DEV_AIU_AIFIFO2      "CLKGATE_AIU_AIFIFO2"
+#define GCLK_REG_AIU_AIFIFO2      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_AIFIFO2      (1<<10)
+
+#define GCLK_IDX_AIU_AUD_MIXER         43
+#define GCLK_NAME_AIU_AUD_MIXER      "AIU_AUD_MIXER"
+#define GCLK_DEV_AIU_AUD_MIXER      "CLKGATE_AIU_AUD_MIXER"
+#define GCLK_REG_AIU_AUD_MIXER      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_AUD_MIXER      (1<<11)
+
+#define GCLK_IDX_AIU_MIXER_REG         44
+#define GCLK_NAME_AIU_MIXER_REG      "AIU_MIXER_REG"
+#define GCLK_DEV_AIU_MIXER_REG      "CLKGATE_AIU_MIXER_REG"
+#define GCLK_REG_AIU_MIXER_REG      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_MIXER_REG      (1<<12)
+
+#define GCLK_IDX_AIU_ADC         45
+#define GCLK_NAME_AIU_ADC      "AIU_ADC"
+#define GCLK_DEV_AIU_ADC      "CLKGATE_AIU_ADC"
+#define GCLK_REG_AIU_ADC      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_ADC      (1<<13)
+
+#define GCLK_IDX_BLK_MOV         46
+#define GCLK_NAME_BLK_MOV      "BLK_MOV"
+#define GCLK_DEV_BLK_MOV      "CLKGATE_BLK_MOV"
+#define GCLK_REG_BLK_MOV      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_BLK_MOV      (1<<14)
+
+/* NEW ADD */
+#define GCLK_IDX_AIU_TOP_LEVEL         47
+#define GCLK_NAME_AIU_TOP_LEVEL      "AIU_TOP_LEVEL"
+#define GCLK_DEV_AIU_TOP_LEVEL      "CLKGATE_AIU_TOP_LEVEL"
+#define GCLK_REG_AIU_TOP_LEVEL      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AIU_TOP_LEVEL      (1<<15)
+
+#define GCLK_NAME_PCM_MCLK       "PCM_MCLK"
+#define GCLK_REG_PCM_MCLK        (HHI_PCM_CLK_CNTL)
+#define GCLK_MASK_PCM_MCLK       (1<<9)
+
+#define GCLK_NAME_PCM_SCLK       "PCM_SCLK"
+#define GCLK_REG_PCM_SCLK        (HHI_PCM_CLK_CNTL)
+#define GCLK_MASK_PCM_SCLK       (1<<22)
+
+#define GCLK_IDX_UART1         48
+#define GCLK_NAME_UART1      "UART1"
+#define GCLK_DEV_UART1      "CLKGATE_UART1"
+#define GCLK_REG_UART1      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_UART1      (1<<16)
+
+#define GCLK_IDX_RESERVED1_4         49
+#define GCLK_NAME_RESERVED1_4      "RESERVED1_4"
+#define GCLK_DEV_RESERVED1_4      "CLKGATE_RESERVED1_4"
+#define GCLK_REG_RESERVED1_4      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_4      (1<<17)
+
+/* NEW ADD */
+#define GCLK_IDX_RESERVED1_5         50
+#define GCLK_NAME_RESERVED1_5      "RESERVED1_5"
+#define GCLK_DEV_RESERVED1_5      "CLKGATE_RESERVED1_5"
+#define GCLK_REG_RESERVED1_5      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_5      (1<<18)
+
+#define GCLK_IDX_RESERVED1_6         51
+#define GCLK_NAME_RESERVED1_6      "RESERVED1_6"
+#define GCLK_DEV_RESERVED1_6      "CLKGATE_RESERVED1_6"
+#define GCLK_REG_RESERVED1_6      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_6      (1<<19)
+
+#define GCLK_IDX_GE2D         52
+#define GCLK_NAME_GE2D      "GE2D"
+#define GCLK_DEV_GE2D      "CLKGATE_GE2D"
+#define GCLK_REG_GE2D      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_GE2D      (1<<20)
+
+#define GCLK_IDX_USB0         53
+#define GCLK_NAME_USB0      "USB0"
+#define GCLK_DEV_USB0      "CLKGATE_USB0"
+#define GCLK_REG_USB0      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_USB0      (1<<21)
+
+#define GCLK_IDX_USB1         54
+#define GCLK_NAME_USB1      "USB1"
+#define GCLK_DEV_USB1      "CLKGATE_USB1"
+#define GCLK_REG_USB1      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_USB1      (1<<22)
+
+#define GCLK_IDX_RESET         55
+#define GCLK_NAME_RESET      "RESET"
+#define GCLK_DEV_RESET      "CLKGATE_RESET"
+#define GCLK_REG_RESET      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESET      (1<<23)
+
+#define GCLK_IDX_NAND_CLK         56
+#define GCLK_NAME_NAND_CLK      "NAND CLK"
+#define GCLK_DEV_NAND_CLK      "HHI_NAND_CLK"
+#define GCLK_REG_NAND_CLK      (HHI_NAND_CLK_CNTL)
+#define GCLK_MASK_NAND_CLK      (1<<7)
+
+#define GCLK_IDX_HIU_PARSER_TOP         57
+#define GCLK_NAME_HIU_PARSER_TOP      "HIU_PARSER_TOP"
+#define GCLK_DEV_HIU_PARSER_TOP      "CLKGATE_HIU_PARSER_TOP"
+#define GCLK_REG_HIU_PARSER_TOP      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_HIU_PARSER_TOP      (1<<25)
+
+/* NEW ADD */
+#define GCLK_NAME_USB_CLK       "USB_CLK"
+#define GCLK_REG_USB_CLK        (HHI_USB_CLK_CNTL)
+#define GCLK_MASK_USB_CLK       (1<<9)
+
+#define GCLK_IDX_USB_GENERAL         58
+#define GCLK_NAME_USB_GENERAL      "USB_GENERAL"
+#define GCLK_DEV_USB_GENERAL      "CLKGATE_USB_GENERAL"
+#define GCLK_REG_USB_GENERAL      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_USB_GENERAL      (1<<26)
+
+#define GCLK_IDX_RESERVED1_7         59
+#define GCLK_NAME_RESERVED1_7      "RESERVED1_7"
+#define GCLK_DEV_RESERVED1_7      "CLKGATE_RESERVED1_7"
+#define GCLK_REG_RESERVED1_7      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_RESERVED1_7      (1<<27)
+
+/* #define GCLK_IDX_VDIN1         60 */
+/* #define GCLK_NAME_VDIN1      "VDIN1" */
+/* #define GCLK_DEV_VDIN1      "CLKGATE_VDIN1" */
+/* #define GCLK_REG_VDIN1      (HHI_GCLK_MPEG1) */
+/* #define GCLK_MASK_VDIN1      (1<<28) */
+
+#define GCLK_IDX_AHB_ARB0         61
+#define GCLK_NAME_AHB_ARB0      "AHB_ARB0"
+#define GCLK_DEV_AHB_ARB0      "CLKGATE_AHB_ARB0"
+#define GCLK_REG_AHB_ARB0      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_AHB_ARB0      (1<<29)
+
+#define GCLK_IDX_EFUSE         62
+#define GCLK_NAME_EFUSE      "EFUSE"
+#define GCLK_DEV_EFUSE      "CLKGATE_EFUSE"
+#define GCLK_REG_EFUSE      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_EFUSE      (1<<30)
+
+#define GCLK_IDX_ROM_CLK         63
+#define GCLK_NAME_ROM_CLK      "ROM_CLK"
+#define GCLK_DEV_ROM_CLK      "CLKGATE_ROM_CLK"
+#define GCLK_REG_ROM_CLK      (HHI_GCLK_MPEG1)
+#define GCLK_MASK_ROM_CLK      (1<<31)
+
+/**************************************************************/
+
+#define GCLK_IDX_RESERVED2_0         64
+#define GCLK_NAME_RESERVED2_0      "RESERVED2_0"
+#define GCLK_DEV_RESERVED2_0      "CLKGATE_RESERVED2_0"
+#define GCLK_REG_RESERVED2_0      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_0      (1<<0)
+
+#define GCLK_IDX_AHB_DATA_BUS         65
+#define GCLK_NAME_AHB_DATA_BUS      "AHB_DATA_BUS"
+#define GCLK_DEV_AHB_DATA_BUS      "CLKGATE_AHB_DATA_BUS"
+#define GCLK_REG_AHB_DATA_BUS      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_AHB_DATA_BUS      (1<<1)
+
+#define GCLK_IDX_AHB_CONTROL_BUS         66
+#define GCLK_NAME_AHB_CONTROL_BUS      "AHB_CONTROL_BUS"
+#define GCLK_DEV_AHB_CONTROL_BUS      "CLKGATE_AHB_CONTROL_BUS"
+#define GCLK_REG_AHB_CONTROL_BUS      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_AHB_CONTROL_BUS      (1<<2)
+
+#define GCLK_IDX_HDMI_INTR_SYNC         67
+#define GCLK_NAME_HDMI_INTR_SYNC      "HDMI_INTR_SYNC"
+#define GCLK_DEV_HDMI_INTR_SYNC      "CLKGATE_HDMI_INTR_SYNC"
+#define GCLK_REG_HDMI_INTR_SYNC      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_HDMI_INTR_SYNC      (1<<3)
+
+#define GCLK_IDX_HDMI_PCLK         68
+#define GCLK_NAME_HDMI_PCLK      "HDMI_PCLK"
+#define GCLK_DEV_HDMI_PCLK      "CLKGATE_HDMI_PCLK"
+#define GCLK_REG_HDMI_PCLK      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_HDMI_PCLK      (1<<4)
+
+#define  GCLK_IDX_PDM         69
+#define GCLK_NAME_PDM      "PDM"
+#define  GCLK_DEV_PDM      "CLKGATE_PDM"
+#define  GCLK_REG_PDM      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_PDM      (1<<5)
+
+#define  GCLK_IDX_BT656        70
+#define GCLK_NAME_BT656     "BT656"
+#define  GCLK_DEV_BT656     "CLKGATE_BT656"
+#define  GCLK_REG_BT656     (HHI_GCLK_MPEG2)
+#define GCLK_MASK_BT656     (1<<6)
+
+#define  GCLK_IDX_BT656_2         71
+#define GCLK_NAME_BT656_2      "BT656_2"
+#define  GCLK_DEV_BT656_2      "CLKGATE_BT656_2"
+#define  GCLK_REG_BT656_2      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_BT656_2      (1<<7)
+
+#define GCLK_IDX_MISC_USB1_TO_DDR         72
+#define GCLK_NAME_MISC_USB1_TO_DDR      "MISC_USB1_TO_DDR"
+#define GCLK_DEV_MISC_USB1_TO_DDR      "CLKGATE_MISC_USB1_TO_DDR"
+#define GCLK_REG_MISC_USB1_TO_DDR      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_MISC_USB1_TO_DDR      (1<<8)
+
+#define GCLK_IDX_MISC_USB0_TO_DDR         73
+#define GCLK_NAME_MISC_USB0_TO_DDR      "MISC_USB0_TO_DDR"
+#define GCLK_DEV_MISC_USB0_TO_DDR      "CLKGATE_MISC_USB0_TO_DDR"
+#define GCLK_REG_MISC_USB0_TO_DDR      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_MISC_USB0_TO_DDR      (1<<9)
+
+#define GCLK_IDX_RESERVED2_4        74
+#define GCLK_NAME_RESERVED2_4      "RESERVED2_4"
+#define GCLK_DEV_RESERVED2_4      "CLKGATE_RESERVED2_4"
+#define GCLK_REG_RESERVED2_4      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_4      (1<<10)
+
+#define GCLK_IDX_MMC_PCLK         75
+#define GCLK_NAME_MMC_PCLK      "MMC_PCLK"
+#define GCLK_DEV_MMC_PCLK      "CLKGATE_MMC_PCLK"
+#define GCLK_REG_MMC_PCLK      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_MMC_PCLK      (1<<11)
+
+#define GCLK_NAME_MMC_A_PCLK     "MMC_A_PCLK"
+#define GCLK_REG_MMC_A_PCLK      (HHI_MPLL_CNTL10)
+#define GCLK_MASK_MMC_A_PCLK      (1<<2)
+
+#define GCLK_NAME_MMC_B_PCLK     "MMC_B_PCLK"
+#define GCLK_REG_MMC_B_PCLK      (HHI_MPLL_CNTL10)
+#define GCLK_MASK_MMC_B_PCLK      (1<<1)
+
+#define GCLK_NAME_MMC_C_PCLK     "MMC_C_PCLK"
+#define GCLK_REG_MMC_C_PCLK      (HHI_MPLL_CNTL10)
+#define GCLK_MASK_MMC_C_PCLK      (1<<0)
+
+#define GCLK_NAME_EMMC_A_CLK      "EMMC_A_CLK"
+#define GCLK_REG_EMMC_A_CLK      (HHI_SD_EMMC_CLK_CNTL)
+#define GCLK_MASK_EMMC_A_CLK    (1<<7)
+
+#define GCLK_NAME_EMMC_B_CLK      "EMMC_B_CLK"
+#define GCLK_REG_EMMC_B_CLK      (HHI_SD_EMMC_CLK_CNTL)
+#define GCLK_MASK_EMMC_B_CLK    (1<<23)
+
+#define GCLK_IDX_MISC_DVIN         76
+#define GCLK_NAME_MISC_DVIN      "MISC_DVIN"
+#define GCLK_DEV_MISC_DVIN      "CLKGATE_MISC_DVIN"
+#define GCLK_REG_MISC_DVIN      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_MISC_DVIN      (1<<12)
+
+#define GCLK_IDX_RESERVED2_5         77
+#define GCLK_NAME_RESERVED2_5      "RESERVED2_5"
+#define GCLK_DEV_RESERVED2_5      "CLKGATE_RESERVED2_5"
+#define GCLK_REG_RESERVED2_5      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_5      (1<<13)
+
+#define GCLK_IDX_RESERVED2_6         78
+#define GCLK_NAME_RESERVED2_6      "RESERVED2_6"
+#define GCLK_DEV_RESERVED2_6      "CLKGATE_RESERVED2_6"
+#define GCLK_REG_RESERVED2_6      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_6      (1<<14)
+
+#define GCLK_IDX_UART2         79
+#define GCLK_NAME_UART2      "UART2"
+#define GCLK_DEV_UART2      "CLKGATE_UART2"
+#define GCLK_REG_UART2      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_UART2      (1<<15)
+
+#define GCLK_IDX_RESERVED2_7         80
+#define GCLK_NAME_RESERVED2_7      "RESERVED2_7"
+#define GCLK_DEV_RESERVED2_7      "CLKGATE_RESERVED2_7"
+#define GCLK_REG_RESERVED2_7      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_7      (1<<16)
+
+#define GCLK_IDX_RESERVED2_8         81
+#define GCLK_NAME_RESERVED2_8      "RESERVED2_8"
+#define GCLK_DEV_RESERVED2_8      "CLKGATE_RESERVED2_8"
+#define GCLK_REG_RESERVED2_8      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_8      (1<<17)
+
+#define GCLK_IDX_RESERVED2_9         82
+#define GCLK_NAME_RESERVED2_9      "RESERVED2_9"
+#define GCLK_DEV_RESERVED2_9      "CLKGATE_RESERVED2_9"
+#define GCLK_REG_RESERVED2_9      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_9      (1<<18)
+
+#define GCLK_IDX_RESERVED2_A         83
+#define GCLK_NAME_RESERVED2_A      "RESERVED2_A"
+#define GCLK_DEV_RESERVED2_A      "CLKGATE_RESERVED2_A"
+#define GCLK_REG_RESERVED2_A      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_A      (1<<19)
+
+#define GCLK_IDX_RESERVED2_B         84
+#define GCLK_NAME_RESERVED2_B      "RESERVED2_B"
+#define GCLK_DEV_RESERVED2_B      "CLKGATE_RESERVED2_B"
+#define GCLK_REG_RESERVED2_B      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_B      (1<<20)
+
+#define  GCLK_IDX_UART3         85
+#define GCLK_NAME_UART3      "UART3"
+#define  GCLK_DEV_UART3      "CLKGATE_UART3"
+#define  GCLK_REG_UART3      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_UART3      (1<<21)
+
+#define GCLK_IDX_SANA        86
+#define GCLK_NAME_SANA      "SANA"
+#define GCLK_DEV_SANA      "CLKGATE_SANA"
+#define GCLK_REG_SANA      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_SANA      (1<<22)
+
+#define GCLK_IDX_RESERVED2_D        87
+#define GCLK_NAME_RESERVED2_D      "RESERVED2_D"
+#define GCLK_DEV_RESERVED2_D      "CLKGATE_RESERVED2_D"
+#define GCLK_REG_RESERVED2_D      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_D      (1<<23)
+
+#define GCLK_IDX_RESERVED2_E        88
+#define GCLK_NAME_RESERVED2_E      "RESERVED2_E"
+#define GCLK_DEV_RESERVED2_E      "CLKGATE_RESERVED2_E"
+#define GCLK_REG_RESERVED2_E      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_E      (1<<24)
+
+#define GCLK_IDX_VPU_INTR        89
+#define GCLK_NAME_VPU_INTR      "VPU_INTR"
+#define GCLK_DEV_VPU_INTR      "CLKGATE_VPU_INTR"
+#define GCLK_REG_VPU_INTR      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_VPU_INTR      (1<<25)
+
+#define GCLK_IDX_SECURE_AHP_APB3        90
+#define GCLK_NAME_SECURE_AHP_APB3      "SECURE_AHP_APB3"
+#define GCLK_DEV_SECURE_AHP_APB3      "CLKGATE_SECURE_AHP_APB3"
+#define GCLK_REG_SECURE_AHP_APB3      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_SECURE_AHP_APB3      (1<<26)
+
+#define GCLK_IDX_RESERVED2_F        91
+#define GCLK_NAME_RESERVED2_F      "RESERVED2_F"
+#define GCLK_DEV_RESERVED2_F      "CLKGATE_RESERVED2_F"
+#define GCLK_REG_RESERVED2_F      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_F      (1<<27)
+
+#define GCLK_IDX_RESERVED2_10        92
+#define GCLK_NAME_RESERVED2_10      "RESERVED2_10"
+#define GCLK_DEV_RESERVED2_10      "CLKGATE_RESERVED2_10"
+#define GCLK_REG_RESERVED2_10      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_10      (1<<28)
+
+#define GCLK_IDX_CLK81_TO_A9        93
+#define GCLK_NAME_CLK81_TO_A9      "CLK81_TO_A9"
+#define GCLK_DEV_CLK81_TO_A9      "CLKGATE_CLK81_TO_A9"
+#define GCLK_REG_CLK81_TO_A9      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_CLK81_TO_A9      (1<<29)
+
+#define  GCLK_IDX_GIC        94
+#define GCLK_NAME_GIC      "GIC"
+#define  GCLK_DEV_GIC      "CLKGATE_GIC"
+#define  GCLK_REG_GIC      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_GIC      (1<<30)
+
+#define GCLK_IDX_RESERVED2_12        95
+#define GCLK_NAME_RESERVED2_12      "RESERVED2_12"
+#define GCLK_DEV_RESERVED2_12      "CLKGATE_RESERVED2_12"
+#define GCLK_REG_RESERVED2_12      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED2_12      (1<<31)
+
+/**************************************************************/
+
+#define GCLK_IDX_RESERVED3_0        96
+#define GCLK_NAME_RESERVED3_0      "RESERVED3_0"
+#define GCLK_DEV_RESERVED3_0      "CLKGATE_RESERVED3_0"
+#define GCLK_REG_RESERVED3_0      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED3_0      (1<<0)
+
+#define GCLK_IDX_VCLK2_VENCI         97
+#define GCLK_NAME_VCLK2_VENCI      "VCLK2_VENCI"
+#define GCLK_DEV_VCLK2_VENCI      "CLKGATE_VCLK2_VENCI"
+#define GCLK_REG_VCLK2_VENCI      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCI      (1<<1)
+
+#define GCLK_IDX_VCLK2_VENCI1         98
+#define GCLK_NAME_VCLK2_VENCI1      "VCLK2_VENCI1"
+#define GCLK_DEV_VCLK2_VENCI1      "CLKGATE_VCLK2_VENCI1"
+#define GCLK_REG_VCLK2_VENCI1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCI1      (1<<2)
+
+#define GCLK_IDX_VCLK2_VENCP         99
+#define GCLK_NAME_VCLK2_VENCP      "VCLK2_VENCP"
+#define GCLK_DEV_VCLK2_VENCP      "CLKGATE_VCLK2_VENCP"
+#define GCLK_REG_VCLK2_VENCP      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCP      (1<<3)
+
+#define GCLK_IDX_VCLK2_VENCP1         100
+#define GCLK_NAME_VCLK2_VENCP1      "VCLK2_VENCP1"
+#define GCLK_DEV_VCLK2_VENCP1      "CLKGATE_VCLK2_VENCP1"
+#define GCLK_REG_VCLK2_VENCP1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCP1      (1<<4)
+
+#define GCLK_IDX_VCLK2_VENCT         101
+#define GCLK_NAME_VCLK2_VENCT      "VCLK2_VENCT"
+#define GCLK_DEV_VCLK2_VENCT      "CLKGATE_VCLK2_VENCT"
+#define GCLK_REG_VCLK2_VENCT      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCT      (1<<5)
+
+#define GCLK_IDX_VCLK2_VENCT1         102
+#define GCLK_NAME_VCLK2_VENCT1      "VCLK2_VENCT1"
+#define GCLK_DEV_VCLK2_VENCT1      "CLKGATE_VCLK2_VENCT1"
+#define GCLK_REG_VCLK2_VENCT1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCT1      (1<<6)
+
+#define GCLK_IDX_VCLK2_OTHER         103
+#define GCLK_NAME_VCLK2_OTHER      "VCLK2_OTHER"
+#define GCLK_DEV_VCLK2_OTHER      "CLKGATE_VCLK2_OTHER"
+#define GCLK_REG_VCLK2_OTHER      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_OTHER      (1<<7)
+
+#define GCLK_IDX_VCLK2_ENCI         104
+#define GCLK_NAME_VCLK2_ENCI      "VCLK2_ENCI"
+#define GCLK_DEV_VCLK2_ENCI      "CLKGATE_VCLK2_ENCI"
+#define GCLK_REG_VCLK2_ENCI      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_ENCI      (1<<8)
+
+#define GCLK_IDX_VCLK2_ENCP         105
+#define GCLK_NAME_VCLK2_ENCP      "VCLK2_ENCP"
+#define GCLK_DEV_VCLK2_ENCP      "CLKGATE_VCLK2_ENCP"
+#define GCLK_REG_VCLK2_ENCP      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_ENCP      (1<<9)
+
+#define GCLK_IDX_DAC_CLK         106
+#define GCLK_NAME_DAC_CLK      "DAC_CLK"
+#define GCLK_DEV_DAC_CLK      "CLKGATE_DAC_CLK"
+#define GCLK_REG_DAC_CLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_DAC_CLK      (1<<10)
+
+#define GCLK_IDX_RESERVED3_1        107
+#define GCLK_NAME_RESERVED3_1      "RESERVED3_1"
+#define GCLK_DEV_RESERVED3_1      "CLKGATE_RESERVED3_1"
+#define GCLK_REG_RESERVED3_1      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED3_1      (1<<11)
+
+#define GCLK_IDX_RESERVED3_2        108
+#define GCLK_NAME_RESERVED3_2      "RESERVED3_2"
+#define GCLK_DEV_RESERVED3_2      "CLKGATE_RESERVED3_2"
+#define GCLK_REG_RESERVED3_2      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED3_2      (1<<12)
+
+#define GCLK_IDX_RESERVED3_3        109
+#define GCLK_NAME_RESERVED3_3      "RESERVED3_3"
+#define GCLK_DEV_RESERVED3_3      "CLKGATE_RESERVED3_3"
+#define GCLK_REG_RESERVED3_3      (HHI_GCLK_MPEG2)
+#define GCLK_MASK_RESERVED3_3      (1<<13)
+
+#define GCLK_IDX_AIU_AOCLK         110
+#define GCLK_NAME_AIU_AOCLK      "AIU_AOCLK"
+#define GCLK_DEV_AIU_AOCLK      "CLKGATE_AIU_AOCLK"
+#define GCLK_REG_AIU_AOCLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_AIU_AOCLK      (1<<14)
+
+#define GCLK_IDX_RESERVED3_4         111
+#define GCLK_NAME_RESERVED3_4      "RESERVED3_4"
+#define GCLK_DEV_RESERVED3_4      "CLKGATE_RESERVED3_4"
+#define GCLK_REG_RESERVED3_4      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_4      (1<<15)
+
+#define GCLK_IDX_AIU_ICE958_AMCLK         112
+#define GCLK_NAME_AIU_ICE958_AMCLK      "AIU_ICE958_AMCLK"
+#define GCLK_DEV_AIU_ICE958_AMCLK      "CLKGATE_AIU_ICE958_AMCLK"
+#define GCLK_REG_AIU_ICE958_AMCLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_AIU_ICE958_AMCLK      (1<<16)
+
+#define GCLK_IDX_RESERVED3_5         113
+#define GCLK_NAME_RESERVED3_5      "RESERVED3_5"
+#define GCLK_DEV_RESERVED3_5      "CLKGATE_RESERVED3_5"
+#define GCLK_REG_RESERVED3_5      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_5      (1<<17)
+
+#define GCLK_IDX_RESERVED3_6         114
+#define GCLK_NAME_RESERVED3_6      "RESERVED3_6"
+#define GCLK_DEV_RESERVED3_6      "CLKGATE_RESERVED3_6"
+#define GCLK_REG_RESERVED3_6      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_6      (1<<18)
+
+#define GCLK_IDX_RESERVED3_7         115
+#define GCLK_NAME_RESERVED3_7      "RESERVED3_7"
+#define GCLK_DEV_RESERVED3_7      "CLKGATE_RESERVED3_7"
+#define GCLK_REG_RESERVED3_7      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_7      (1<<19)
+
+#define GCLK_IDX_ENC480P         116
+#define GCLK_NAME_ENC480P      "ENC480P"
+#define GCLK_DEV_ENC480P      "CLKGATE_ENC480P"
+#define GCLK_REG_ENC480P      (HHI_GCLK_OTHER)
+#define GCLK_MASK_ENC480P      (1<<20)
+
+#define GCLK_IDX_RANDOM_NUM_GEN1         117
+#define GCLK_NAME_RANDOM_NUM_GEN1      "RANDOM_NUM_GEN1"
+#define GCLK_DEV_RANDOM_NUM_GEN1      "CLKGATE_RANDOM_NUM_GEN1"
+#define GCLK_REG_RANDOM_NUM_GEN1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RANDOM_NUM_GEN1      (1<<21)
+
+#define GCLK_IDX_VCLK2_ENCT         118
+#define GCLK_NAME_VCLK2_ENCT      "GCLK_VENCL_INT"
+#define GCLK_DEV_VCLK2_ENCT      "CLKGATE_GCLK_VENCL_INT"
+#define GCLK_REG_VCLK2_ENCT      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_ENCT      (1<<22)
+
+#define  GCLK_IDX_VCLK2_ENCL         119
+#define GCLK_NAME_VCLK2_ENCL      "VLKC2_ENCL"
+#define  GCLK_DEV_VCLK2_ENCL      "CLKGATE_VCLK2_ENCL"
+#define  GCLK_REG_VCLK2_ENCL      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_ENCL      (1<<23)
+
+#define GCLK_IDX_MMC_CLK         120
+#define GCLK_NAME_MMC_CLK      "MMC_CLK"
+#define GCLK_DEV_MMC_CLK      "CLKGATE_MMC_CLK"
+#define GCLK_REG_MMC_CLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_MMC_CLK      (1<<24)
+
+#define GCLK_IDX_VCLK2_VENCL         121
+#define GCLK_NAME_VCLK2_VENCL      "VCLK2_VENCL"
+#define GCLK_DEV_VCLK2_VENCL      "CLKGATE_VCLK2_VENCL"
+#define GCLK_REG_VCLK2_VENCL      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_VENCL      (1<<25)
+
+#define GCLK_IDX_VCLK2_OTHER1         122
+#define GCLK_NAME_VCLK2_OTHER1      "VCLK2_OTHER1"
+#define GCLK_DEV_VCLK2_OTHER1      "CLKGATE_VCLK2_OTHER1"
+#define GCLK_REG_VCLK2_OTHER1      (HHI_GCLK_OTHER)
+#define GCLK_MASK_VCLK2_OTHER1      (1<<26)
+
+#define GCLK_IDX_RESERVED3_9         123
+#define GCLK_NAME_RESERVED3_9      "RESERVED3_9"
+#define GCLK_DEV_RESERVED3_9      "CLKGATE_RESERVED3_9"
+#define GCLK_REG_RESERVED3_9      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_9      (1<<27)
+
+#define GCLK_IDX_RESERVED3_A         124
+#define GCLK_NAME_RESERVED3_A      "RESERVED3_A"
+#define GCLK_DEV_RESERVED3_A      "CLKGATE_RESERVED3_A"
+#define GCLK_REG_RESERVED3_A      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_A      (1<<28)
+
+#define GCLK_IDX_RESERVED3_B         125
+#define GCLK_NAME_RESERVED3_B      "RESERVED3_B"
+#define GCLK_DEV_RESERVED3_B      "CLKGATE_RESERVED3_B"
+#define GCLK_REG_RESERVED3_B      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_B      (1<<29)
+
+#define GCLK_IDX_RESERVED3_C         126
+#define GCLK_NAME_RESERVED3_C      "RESERVED3_C"
+#define GCLK_DEV_RESERVED3_C      "CLKGATE_RESERVED3_C"
+#define GCLK_REG_RESERVED3_C      (HHI_GCLK_OTHER)
+#define GCLK_MASK_RESERVED3_C      (1<<30)
+
+#define GCLK_IDX_EDP_CLK         127
+#define GCLK_NAME_EDP_CLK      "EDP_CLK"
+#define GCLK_DEV_EDP_CLK      "CLKGATE_EDP_CLK"
+#define GCLK_REG_EDP_CLK      (HHI_GCLK_OTHER)
+#define GCLK_MASK_EDP_CLK      (1<<31)
+
+/**************************************************************/
+
+#define GCLK_IDX_MEDIA_CPU         128
+#define GCLK_NAME_MEDIA_CPU      "MEDIA_CPU"
+#define GCLK_DEV_MEDIA_CPU      "CLKGATE_MEDIA_CPU"
+#define GCLK_REG_MEDIA_CPU      (HHI_GCLK_AO)
+#define GCLK_MASK_MEDIA_CPU      (1<<0)
+
+#define GCLK_IDX_AHB_SRAM         129
+#define GCLK_NAME_AHB_SRAM      "AHB_SRAM"
+#define GCLK_DEV_AHB_SRAM      "CLKGATE_AHB_SRAM"
+#define GCLK_REG_AHB_SRAM      (HHI_GCLK_AO)
+#define GCLK_MASK_AHB_SRAM      (1<<1)
+
+#define GCLK_IDX_AHB_BUS         130
+#define GCLK_NAME_AHB_BUS      "AHB_BUS"
+#define GCLK_DEV_AHB_BUS      "CLKGATE_AHB_BUS"
+#define GCLK_REG_AHB_BUS      (HHI_GCLK_AO)
+#define GCLK_MASK_AHB_BUS      (1<<2)
+
+#define GCLK_IDX_AO_REGS         131
+#define GCLK_NAME_AO_REGS      "AO_REGS"
+#define GCLK_DEV_AO_REGS      "CLKGATE_AO_REGS"
+#define GCLK_REG_AO_REGS      (HHI_GCLK_AO)
+#define GCLK_MASK_AO_REGS      (1<<3)
+
+#define GCLK_NAME_I2C_AO    "I2C_AO"
+#define  GCLK_REG_I2C_AO    (HHI_GCLK_AO)
+#define GCLK_MASK_I2C_AO    (1<<4)
+
+
+#define GCLK_IDX_CTS_ENCI         132
+#define GCLK_NAME_CTS_ENCI      "CTS_ENCI"
+#define GCLK_DEV_CTS_ENCI      "CLKGATE_CTS_ENCI"
+#define GCLK_REG_CTS_ENCI      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_ENCI      (1<<0)
+
+#define GCLK_IDX_CTS_ENCT         133
+#define GCLK_NAME_CTS_ENCT      "CTS_ENCT"
+#define GCLK_DEV_CTS_ENCT      "CLKGATE_CTS_ENCT"
+#define GCLK_REG_CTS_ENCT      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_ENCT      (1<<1)
+
+#define GCLK_IDX_CTS_ENCP         134
+#define GCLK_NAME_CTS_ENCP      "CTS_ENCP"
+#define GCLK_DEV_CTS_ENCP      "CLKGATE_CTS_ENCP"
+#define GCLK_REG_CTS_ENCP      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_ENCP      (1<<2)
+
+#define GCLK_IDX_CTS_ENCL         135
+#define GCLK_NAME_CTS_ENCL      "CTS_ENCL"
+#define GCLK_DEV_CTS_ENCL      "CLKGATE_CTS_ENCL"
+#define GCLK_REG_CTS_ENCL      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_ENCL      (1<<3)
+
+#define GCLK_IDX_CTS_VDAC         136
+#define GCLK_NAME_CTS_VDAC      "CTS_VDAC"
+#define GCLK_DEV_CTS_VDAC      "CLKGATE_CTS_VDAC"
+#define GCLK_REG_CTS_VDAC      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_VDAC      (1<<4)
+
+#define GCLK_IDX_CTS_HDMI_TX_PIXEL         137
+#define GCLK_NAME_CTS_HDMI_TX_PIXEL      "CTS_HDMI_TX_PIXEL"
+#define GCLK_DEV_CTS_HDMI_TX_PIXEL      "CLKGATE_CTS_HDMI_TX_PIXEL"
+#define GCLK_REG_CTS_HDMI_TX_PIXEL      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_CTS_HDMI_TX_PIXEL      (1<<5)
+
+#define GCLK_IDX_AUD         138
+#define GCLK_NAME_AUD      "AUD"
+#define GCLK_DEV_AUD      "CLKGATE_AUD"
+#define GCLK_REG_AUD      (HHI_AUD_CLK_CNTL)
+#define GCLK_MASK_AUD      (1<<23)
+
+
+#define GCLK_IDX_AUD2         138
+#define GCLK_NAME_AUD2      "AUD2"
+#define GCLK_DEV_AUD2      "CLKGATE_AUD2"
+#define GCLK_REG_AUD2      (HHI_AUD_CLK_CNTL)
+#define GCLK_MASK_AUD2      (1<<8)
+
+
+#define GCLK_NAME_AUD_CLK_2      "AUD_CLK_2"
+#define GCLK_REG_AUD_CLK_2      (HHI_AUD_CLK_CNTL2)
+#define GCLK_MASK_AUD_CLK_2      (1<<8)
+
+#define GCLK_IDX_AUD_CLK_3         138
+#define GCLK_NAME_AUD_CLK_3      "AUD_CLK"
+#define GCLK_DEV_AUD_CLK_3      "CLKGATE_AUD_CLK"
+#define GCLK_REG_AUD_CLK_3      (HHI_AUD_CLK_CNTL3)
+#define GCLK_MASK_AUD_CLK_3      (1<<16)
+
+#define GCLK_IDX_LCD_AN_PHY2         139
+#define GCLK_NAME_LCD_AN_PHY2      "LCD_AN_PHY2"
+#define GCLK_DEV_LCD_AN_PHY2      "CLKGATE_LCD_AN_PHY2"
+#define GCLK_REG_LCD_AN_PHY2      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_LCD_AN_PHY2      (1<<7)
+
+#define GCLK_IDX_LCD_AN_PHY3         140
+#define GCLK_NAME_LCD_AN_PHY3      "LCD_AN_PHY3"
+#define GCLK_DEV_LCD_AN_PHY3      "CLKGATE_LCD_AN_PHY3"
+#define GCLK_REG_LCD_AN_PHY3      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_LCD_AN_PHY3      (1<<6)
+
+#define GCLK_NAME_ATV_DEMO_VDAC     "ATV_DEMO_VDAC"
+#define GCLK_REG_ATV_DEMO_VDAC      (HHI_VID_CLK_CNTL2)
+#define GCLK_MASK_ATV_DEMO_VDAC      (1<<8)
+
+#define GCLK_IDX_HDMI_PLL_CNTL         142
+#define GCLK_NAME_HDMI_PLL_CNTL      "HDMI_PLL_CNTL"
+#define GCLK_DEV_HDMI_PLL_CNTL       "GATE_HDMI_PLL_CNTL"
+#define GCLK_REG_HDMI_PLL_CNTL       (HHI_HDMI_PLL_CNTL)
+#define GCLK_MASK_HDMI_PLL_CNTL       (1<<30)
+
+#define GCLK_NAME_HDMITX_CLK    "HDMITX_CLK"
+#define GCLK_REG_HDMITX_CLK    (HHI_HDMI_CLK_CNTL)
+#define GCLK_MASK_HDMITX_CLK    (1<<8)
+
+
+#define GCLK_NAME_HDMITX_CLK    "HDMITX_CLK"
+#define GCLK_REG_HDMITX_CLK    (HHI_HDMI_CLK_CNTL)
+#define GCLK_MASK_HDMITX_CLK    (1<<8)
+
+#define GCLK_IDX_VDEC_CLK_1        144
+#define GCLK_NAME_VDEC_CLK_1      "VDEC_CLK_1"
+#define GCLK_DEV_VDEC_CLK_1       "CLKGATE_VDEC_CLK_1"
+#define GCLK_REG_VDEC_CLK_1       (HHI_VDEC_CLK_CNTL)
+#define GCLK_MASK_VDEC_CLK_1       (1<<8)
+
+#define GCLK_NAME_VDEC_CLK_2      "VDEC_CLK_2"
+#define GCLK_REG_VDEC_CLK_2       (HHI_VDEC3_CLK_CNTL)
+#define GCLK_MASK_VDEC_CLK_2       (1<<8)
+
+#define GCLK_NAME_VDEC2_CLK_1     "VDEC2_CLK_1"
+#define GCLK_REG_VDEC2_CLK_1       (HHI_VDEC2_CLK_CNTL)
+#define GCLK_MASK_VDEC2_CLK_1       (1<<8)
+
+#define GCLK_NAME_VDEC2_CLK_2     "VDEC2_CLK_2"
+#define GCLK_REG_VDEC2_CLK_2      (HHI_VDEC4_CLK_CNTL)
+#define GCLK_MASK_VDEC2_CLK_2       (1<<8)
+
+#define GCLK_IDX_HCODEC_CLK_1        145
+#define GCLK_NAME_HCODEC_CLK_1      "HCODEC_CLK"
+#define GCLK_DEV_HCODEC_CLK_1       "CLKGATE_HCODEC_CLK"
+#define GCLK_REG_HCODEC_CLK_1       (HHI_VDEC_CLK_CNTL)
+#define GCLK_MASK_HCODEC_CLK_1       (1<<24)
+
+#define GCLK_NAME_HCODEC_CLK_2      "HCODEC_CLK_2"
+#define GCLK_REG_HCODEC_CLK_2       (HHI_VDEC3_CLK_CNTL)
+#define GCLK_MASK_HCODEC_CLK_2       (1<<24)
+
+#define GCLK_NAME_HEVC_CLK_1      "HCODEC_CLK_1"
+#define GCLK_REG_HEVC_CLK_1       (HHI_VDEC2_CLK_CNTL)
+#define GCLK_MASK_HEVC_CLK_1       (1<<24)
+
+#define GCLK_NAME_HEVC_CLK_2      "HEVC_CLK_2"
+#define GCLK_REG_HEVC_CLK_2       (HHI_VDEC4_CLK_CNTL)
+#define GCLK_MASK_HEVC_CLK_2       (1<<24)
+
+#define GCLK_IDX_GEN_CLK        146
+#define GCLK_NAME_GEN_CLK      "GEN_CLK"
+#define GCLK_DEV_GEN_CLK       "CLKGATE_HCODEC_CLK"
+#define GCLK_REG_GEN_CLK       (HHI_GEN_CLK_CNTL)
+#define GCLK_MASK_GEN_CLK       (1<<11)
+
+#define GCLK_NAME_VPU_CLK_1      "VPU_CLK_1"
+#define GCLK_REG_VPU_CLK_1       (HHI_VPU_CLK_CNTL)
+#define GCLK_MASK_VPU_CLK_1       (1<<8)
+
+#define GCLK_NAME_VPU_CLK_2      "VPU_CLK_2"
+#define GCLK_REG_VPU_CLK_2       (HHI_VPU_CLK_CNTL)
+#define GCLK_MASK_VPU_CLK_2       (1<<24)
+
+
+#define GCLK_NAME_VPU_CLKB      "VPU_CLKB"
+#define GCLK_REG_VPU_CLKB       (HHI_VPU_CLKB_CNTL)
+#define GCLK_MASK_VPU_CLKB       (1<<8)
+
+#define GCLK_NAME_VAPB_CLK_1    "VAPB_CLK_1"
+#define  GCLK_REG_VAPB_CLK_1    (HHI_VAPBCLK_CNTL)
+#define GCLK_MASK_VAPB_CLK_1    (1<<8)
+
+#define GCLK_NAME_VAPB_CLK_2    "VAPB_CLK_2"
+#define  GCLK_REG_VAPB_CLK_2    (HHI_VAPBCLK_CNTL)
+#define GCLK_MASK_VAPB_CLK_2    (1<<24)
+
+#define GCLK_NAME_MALI_CLK_1     "MALI_CLK_1"
+#define GCLK_REG_MALI_CLK_1    (HHI_MALI_CLK_CNTL)
+#define GCLK_MASK_MALI_CLK_1   (1<<8)
+
+#define GCLK_NAME_MALI_CLK_2     "MALI_CLK_2"
+#define GCLK_REG_MALI_CLK_2    (HHI_MALI_CLK_CNTL)
+#define GCLK_MASK_MALI_CLK_2   (1<<24)
+
+#define GCLK_NAME_PWM_A_CLK    "PWM_A_CLK"
+#define GCLK_REG_PWM_A_CLK    (CBUS_REG_ADDR(0x2156))
+#define GCLK_MASK_PWM_A_CLK    (1<<15)
+
+#define GCLK_NAME_PWM_B_CLK    "PWM_B_CLK"
+#define GCLK_REG_PWM_B_CLK    (CBUS_REG_ADDR(0x2156))
+#define GCLK_MASK_PWM_B_CLK    (1<<23)
+
+#define GCLK_NAME_PWM_C_CLK    "PWM_C_CLK"
+#define GCLK_REG_PWM_C_CLK    (CBUS_REG_ADDR(0x2196))
+#define GCLK_MASK_PWM_C_CLK    (1<<15)
+
+#define GCLK_NAME_PWM_D_CLK    "PWM_D_CLK"
+#define GCLK_REG_PWM_D_CLK    (CBUS_REG_ADDR(0x2196))
+#define GCLK_MASK_PWM_D_CLK    (1<<23)
+
+#define GCLK_NAME_PWM_E_CLK    "PWM_E_CLK"
+#define GCLK_REG_PWM_E_CLK    (CBUS_REG_ADDR(0x21b2))
+#define GCLK_MASK_PWM_E_CLK    (1<<15)
+
+#define GCLK_NAME_PWM_F_CLK    "PWM_D_CLK"
+#define GCLK_REG_PWM_F_CLK    (CBUS_REG_ADDR(0x21b2))
+#define GCLK_MASK_PWM_F_CLK    (1<<23)
+
+#define GCLK_NAME_VDIN_MEAS_CLK    "VDIN_MEAS_CLK"
+#define  GCLK_REG_VDIN_MEAS_CLK   (HHI_VDIN_MEAS_CLK_CNTL)
+#define GCLK_MASK_VDIN_MEAS_CLK   (1<<8)
+
+#define GCLK_NAME_MSR_CLK    "MSR_CLK"
+#define  GCLK_REG_MSR_CLK    (CBUS_REG_ADDR(0x21d7))
+#define GCLK_MASK_MSR_CLK    (1<<19)
+
+#define GCLK_NAME_MSR_HS_CLK    "MSR_HS_CLK"
+#define  GCLK_REG_MSR_HS_CLK    (CBUS_REG_ADDR(0x21d9))
+#define GCLK_MASK_MSR_HS_CLK    (1<<28)
+
+#define GCLK_NAME_32K_CLK     "32K_CLK"
+#define GCLK_REG_32K_CLK     (HHI_32K_CLK_CNTL)
+#define GCLK_MASK_32K_CLK    (1<<15)
+
+
+
+#define GCLK_IDX_MAX 200
+
+extern short GCLK_ref[GCLK_IDX_MAX];
+
+#define REGISTER_CLK(_MOD) \
+static struct clk CLK_##_MOD = {            \
+	.name       = GCLK_NAME_##_MOD,             \
+	.clock_index = GCLK_IDX_##_MOD,          \
+	.clock_gate_reg_adr = GCLK_REG_##_MOD,  \
+	.clock_gate_reg_mask = GCLK_MASK_##_MOD,    \
+}
+
+#define CLK_LOOKUP_ITEM(_MOD) \
+	{           \
+		.dev_id = GCLK_DEV_##_MOD, \
+		.con_id = GCLK_NAME_##_MOD, \
+		.clk    = &CLK_##_MOD,   \
+	}
+
+
+
+/**********************/
+/* internal audio dac control */
+#define ADAC_RESET                      (0x5000+0x00*4)
+#define ADAC_LATCH                      (0x5000+0x01*4)
+#define ADAC_POWER_CTRL_REG1            (0x5000+0x10*4)
+#define ADAC_POWER_CTRL_REG2            (0x5000+0x11*4)
+
+int audio_internal_dac_disable(void);
+
+/* video dac control */
+int  video_dac_enable(unsigned char enable_mask);
+
+int  video_dac_disable(void);
+
+
+#endif
diff --git a/arch/arm/cpu/armv8/txl/sdio.c b/arch/arm/cpu/armv8/txl/sdio.c
new file mode 100644
index 0000000..6166108
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/sdio.c
@@ -0,0 +1,79 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/sdio.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include <asm/arch/io.h>
+#include <asm/arch/cpu_sdio.h>
+#include <asm/arch/secure_apb.h>
+
+void  cpu_sd_emmc_pwr_prepare(unsigned port)
+{
+//    switch(port)
+//    {
+//        case SDIO_PORT_A:
+//            clrbits_le32(P_PREG_PAD_GPIO4_EN_N,0x30f);
+//            clrbits_le32(P_PREG_PAD_GPIO4_O   ,0x30f);
+//            clrbits_le32(P_PERIPHS_PIN_MUX_8,0x3f);
+//            break;
+//        case SDIO_PORT_B:
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,0x3f<<23);
+//            clrbits_le32(P_PREG_PAD_GPIO5_O   ,0x3f<<23);
+//            clrbits_le32(P_PERIPHS_PIN_MUX_2,0x3f<<10);
+//            break;
+//        case SDIO_PORT_C:
+//            //clrbits_le32(P_PREG_PAD_GPIO3_EN_N,0xc0f);
+//            //clrbits_le32(P_PREG_PAD_GPIO3_O   ,0xc0f);
+//            //clrbits_le32(P_PERIPHS_PIN_MUX_6,(0x3f<<24));break;
+//            break;
+//    }
+
+    /**
+        do nothing here
+    */
+}
+unsigned sd_debug_board_1bit_flag = 0;
+int cpu_sd_emmc_init(unsigned port)
+{
+
+	//printf("inand sdio  port:%d\n",port);
+	switch (port)
+	{
+	case SDIO_PORT_A:
+        setbits_le32(P_PERIPHS_PIN_MUX_5, (0x3f << 26) | (0x1 << 24));
+		break;
+	case SDIO_PORT_B:
+		if (sd_debug_board_1bit_flag == 1)
+			setbits_le32(P_PERIPHS_PIN_MUX_6, 0x7 << 2);
+        else {
+            clrbits_le32(P_PERIPHS_PIN_MUX_6, 0x3f << 6);
+			setbits_le32(P_PERIPHS_PIN_MUX_6, 0x3f << 0);
+        }
+		break;
+	case SDIO_PORT_C://SDIOC GPIOB_2~GPIOB_7
+		clrbits_le32(P_PERIPHS_PIN_MUX_7, (0x7 << 5) | (0xff << 16));
+		setbits_le32(P_PERIPHS_PIN_MUX_7, 0x7 << 29);
+        //printf("inand sdio  port:%d\n",port);
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/txl/timer.c b/arch/arm/cpu/armv8/txl/timer.c
new file mode 100644
index 0000000..8c26edd
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/timer.c
@@ -0,0 +1,40 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/timer.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/timer.h>
+#include <asm/types.h>
+
+#define P_EE_TIMER_E		P_ISA_TIMERE
+
+uint32_t get_time(void)
+{
+	return readl(P_EE_TIMER_E);
+}
+
+void _udelay(unsigned int us)
+{
+#ifndef CONFIG_PXP_EMULATOR
+	unsigned int t0 = get_time();
+
+	while (get_time() - t0 <= us)
+		;
+#endif
+}
diff --git a/arch/arm/cpu/armv8/txl/usb.c b/arch/arm/cpu/armv8/txl/usb.c
new file mode 100644
index 0000000..7b80931
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/usb.c
@@ -0,0 +1,68 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/usb.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+//#include <common.h>
+//#include <asm/cache.h>
+#include <asm/arch/usb-new.h>
+#include <asm/arch/romboot.h>
+
+
+static struct amlogic_usb_config * g_usb_cfg[BOARD_USB_MODE_MAX][USB_PHY_PORT_MAX];
+
+struct amlogic_usb_config * board_usb_start(int mode,int index)
+{
+	printf("USB3.0 XHCI init start\n");
+
+	if (mode < 0 || mode >= BOARD_USB_MODE_MAX||!g_usb_cfg[mode][index])
+		return 0;
+
+	writel((1 << 2),P_RESET1_REGISTER);
+
+	return g_usb_cfg[mode][index];
+}
+
+int board_usb_stop(int mode,int index)
+{
+	printf("board_usb_stop cfg: %d\n",mode);
+
+	return 0;
+}
+
+int usb_index = 0;
+void board_usb_init(struct amlogic_usb_config * usb_cfg,int mode)
+{
+	if (mode < 0 || mode >= BOARD_USB_MODE_MAX || !usb_cfg)
+		return ;
+
+	if (mode == BOARD_USB_MODE_HOST) {
+		if (usb_index >= USB_PHY_PORT_MAX)
+			return;
+		g_usb_cfg[mode][usb_index] = usb_cfg;
+		usb_index++;
+	} else
+		g_usb_cfg[mode][0] = usb_cfg;
+	printf("register usb cfg[%d][%d] = %p\n",mode,(mode==BOARD_USB_MODE_HOST)?usb_index:0,usb_cfg);
+}
+
+int get_usb_count(void)
+{
+    return  usb_index;
+}
diff --git a/arch/arm/cpu/armv8/txl/watchdog.c b/arch/arm/cpu/armv8/txl/watchdog.c
new file mode 100644
index 0000000..9430207
--- /dev/null
+++ b/arch/arm/cpu/armv8/txl/watchdog.c
@@ -0,0 +1,77 @@
+
+/*
+ * arch/arm/cpu/armv8/txl/watchdog.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <asm/types.h>
+#include <asm/arch/romboot.h>
+#include <asm/arch/watchdog.h>
+#include <asm/arch/io.h>
+#include <asm/arch/timer.h>
+
+void watchdog_init(uint32_t msec)
+{
+	// src: 24MHz
+	// div: 24000 for 1ms
+	// reset ao-22 and ee-21
+	*P_WATCHDOG_CNTL = (1<<24)|(1<<25)|(1<<22)|(1<<21)|(24000-1);
+
+	// set timeout
+	*P_WATCHDOG_TCNT = msec;
+	*P_WATCHDOG_RESET = 0;
+
+	// enable
+	*P_WATCHDOG_CNTL |= (1<<18);
+}
+
+void watchdog_reset(void)
+{
+	*P_WATCHDOG_RESET = 0;
+}
+
+void watchdog_disable(void)
+{
+	// turn off internal counter and disable
+	*P_WATCHDOG_CNTL &= ~((1<<18)|(1<<25));
+}
+void reset_system(void)
+{
+	int i;
+	_udelay(10000); //wait print
+	while (1) {
+		writel( 0x3 | (1 << 21) // sys reset en
+					| (1 << 23) // interrupt en
+					| (1 << 24) // clk en
+					| (1 << 25) // clk div en
+					| (1 << 26) // sys reset now
+			, P_WATCHDOG_CNTL);
+		writel(0, P_WATCHDOG_RESET);
+
+		writel(readl(P_WATCHDOG_CNTL) | (1<<18), // watchdog en
+			P_WATCHDOG_CNTL);
+		for (i=0; i<100; i++)
+			readl(P_WATCHDOG_CNTL);/*Deceive gcc for waiting some cycles */
+	}
+}
+
+/* uboot reset interface */
+void reset_cpu(unsigned long flag){
+	reset_system();
+}
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-gxb/bl31_apis.h b/arch/arm/include/asm/arch-gxb/bl31_apis.h
index d9a9b50..c6d3275 100644
--- a/arch/arm/include/asm/arch-gxb/bl31_apis.h
+++ b/arch/arm/include/asm/arch-gxb/bl31_apis.h
@@ -75,6 +75,7 @@
 #define SECURITY_KEY_NOTIFY	0x82000066
 #define SECURITY_KEY_LIST		0x82000067
 #define SECURITY_KEY_REMOVE	0x82000068
+#define SECURITY_KEY_NOTIFY_EX	0x82000069
 
 /* Secure HAL APIs */
 #define TRUSTZONE_HAL_API_SRAM                  0x400
@@ -103,6 +104,7 @@ struct sram_hal_api_arg {
 	#define AML_D_P_W_EFUSE_SECURE_BOOT  (0x10)
 	#define AML_D_P_W_EFUSE_PASSWORD     (0x11)
 	#define AML_D_P_W_EFUSE_CUSTOMER_ID  (0x12)
+	#define AML_D_P_W_EFUSE_AMLOGIC      (0x20)
 	#define AML_D_P_IMG_DECRYPT          (0x40)
 	#define AML_D_P_UPGRADE_CHECK        (0x80)
 
diff --git a/arch/arm/include/asm/arch-gxb/cpu.h b/arch/arm/include/asm/arch-gxb/cpu.h
index 0dcc298..b5f8ef6 100644
--- a/arch/arm/include/asm/arch-gxb/cpu.h
+++ b/arch/arm/include/asm/arch-gxb/cpu.h
@@ -27,6 +27,7 @@
 
 #define CONFIG_AML_MESON 1
 #define CONFIG_AML_MESON_GX 1
+#define CONFIG_CHIP_AML_GXB 1
 
 /* Size of malloc() pool */
 #define CONFIG_SYS_MALLOC_LEN		(64*1024*1024)
@@ -61,4 +62,4 @@
 #define CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC
 #define CONFIG_SILENT_U_BOOT_ONLY
 
-#endif /* _CPU_H */
\ No newline at end of file
+#endif /* _CPU_H */
diff --git a/arch/arm/include/asm/arch-gxl/bl31_apis.h b/arch/arm/include/asm/arch-gxl/bl31_apis.h
index 11d890f..d4dbc11 100644
--- a/arch/arm/include/asm/arch-gxl/bl31_apis.h
+++ b/arch/arm/include/asm/arch-gxl/bl31_apis.h
@@ -75,6 +75,7 @@
 #define SECURITY_KEY_NOTIFY	0x82000066
 #define SECURITY_KEY_LIST		0x82000067
 #define SECURITY_KEY_REMOVE	0x82000068
+#define SECURITY_KEY_NOTIFY_EX	0x82000069
 
 /* Secure HAL APIs */
 #define TRUSTZONE_HAL_API_SRAM                  0x400
@@ -104,6 +105,7 @@ struct sram_hal_api_arg {
 	#define AML_D_P_W_EFUSE_SECURE_BOOT  (0x10)
 	#define AML_D_P_W_EFUSE_PASSWORD     (0x11)
 	#define AML_D_P_W_EFUSE_CUSTOMER_ID  (0x12)
+	#define AML_D_P_W_EFUSE_AMLOGIC      (0x20)
 	#define AML_D_P_IMG_DECRYPT          (0x40)
 	#define AML_D_P_UPGRADE_CHECK        (0x80)
 
diff --git a/arch/arm/include/asm/arch-gxl/ddr_define.h b/arch/arm/include/asm/arch-gxl/ddr_define.h
index 1df1f5c..d2af9d3 100644
--- a/arch/arm/include/asm/arch-gxl/ddr_define.h
+++ b/arch/arm/include/asm/arch-gxl/ddr_define.h
@@ -10,6 +10,7 @@
 #define CONFIG_DDR0_16BIT					1
 #define CONFIG_DDR0_RANK0					2
 #define CONFIG_DDR0_RANK01					3
+#define CONFIG_DDR0_16BIT_2					4
 /* CONFIG_DDR_CHL_AUTO mode support RANK0 and RANK0+1 mode auto detect */
 #define CONFIG_DDR_CHL_AUTO					0xF
 
@@ -102,12 +103,26 @@
 #ifndef CONFIG_DDR4_TIMING_TEST
 #define CONFIG_DDR4_TIMING_TEST				0
 #endif
-#define DDR_FUNC_DDR4_TIMING_TEST			(CONFIG_DDR4_TIMING_TEST<<3)
+#define DDR_FUNC_DDR4_TIMING_TEST			(CONFIG_DDR4_TIMING_TEST<<4)
+
+/* ddr pll bypass */
+#ifndef CONFIG_DDR_PLL_BYPASS
+#define CONFIG_DDR_PLL_BYPASS				0
+#endif
+#define DDR_FUNC_DDR_PLL_BYPASS				(CONFIG_DDR_PLL_BYPASS<<5)
+
+/* ddr rdbi function */
+#ifndef CONFIG_DDR_FUNC_RDBI
+#define CONFIG_DDR_FUNC_RDBI				0
+#endif
+#define DDR_FUNC_RDBI						(CONFIG_DDR_FUNC_RDBI<<6)
 
 #define DDR_FUNC							(DDR_FUNC_D2PLL					| \
 											DDR_FUNC_LP						| \
 											DDR_FUNC_ZQ_PD					| \
 											DDR_FUNC_EXT_VREF				| \
 											DDR_FUNC_DDR4_TIMING_TEST		| \
+											DDR_FUNC_DDR_PLL_BYPASS			| \
+											DDR_FUNC_RDBI					| \
 											(1 << 31) 						\
 											)
diff --git a/arch/arm/include/asm/arch-gxl/thermal.h b/arch/arm/include/asm/arch-gxl/thermal.h
index 32fb3e7..1760324 100644
--- a/arch/arm/include/asm/arch-gxl/thermal.h
+++ b/arch/arm/include/asm/arch-gxl/thermal.h
@@ -32,6 +32,8 @@
 #define SAR_ADC_DETECT_IDLE_SW	SAR_ADC_BASE +(0x9*4)//0xc11086a4
 #define SAR_ADC_DELTA_10		SAR_ADC_BASE +(0xa*4)//0xc11086a8
 #define SAR_ADC_REG11			SAR_ADC_BASE +(0xb*4)//0xc11086ac
+#define SAR_ADC_REG12			(SAR_ADC_BASE + (0xc<<2))
+#define SAR_ADC_REG13			(SAR_ADC_BASE + (0xd<<2))
 
 #define SAR_CLK_CNTL			HHI_SAR_CLK_CNTL
 #define SAR_BUS_CLK_EN			HHI_GCLK_MPEG2
diff --git a/arch/arm/include/asm/arch-gxl/timing.h b/arch/arm/include/asm/arch-gxl/timing.h
index 43820c0..9cac694 100644
--- a/arch/arm/include/asm/arch-gxl/timing.h
+++ b/arch/arm/include/asm/arch-gxl/timing.h
@@ -116,7 +116,10 @@ struct ddr_set{
 	/* 2016.05.24 update */
 	unsigned int  t_pub_acbdlr3;
 
-	unsigned long  t_rsv_int64_1;
+	/* 2016.07.07 update */
+	unsigned short  t_pub_soc_vref_dram_vref;
+	unsigned short  t_rsv_short_1;
+	unsigned int   t_rsv_int_1;
 	unsigned long  t_rsv_int64_2;
 }__attribute__ ((packed));
 
diff --git a/arch/arm/include/asm/arch-gxtvbb/bl31_apis.h b/arch/arm/include/asm/arch-gxtvbb/bl31_apis.h
index 23eeeb8..fe86317 100644
--- a/arch/arm/include/asm/arch-gxtvbb/bl31_apis.h
+++ b/arch/arm/include/asm/arch-gxtvbb/bl31_apis.h
@@ -85,6 +85,7 @@
 #define SECURITY_KEY_NOTIFY	0x82000066
 #define SECURITY_KEY_LIST		0x82000067
 #define SECURITY_KEY_REMOVE	0x82000068
+#define SECURITY_KEY_NOTIFY_EX	0x82000069
 
 /* Secure HAL APIs */
 #define TRUSTZONE_HAL_API_SRAM                  0x400
@@ -113,6 +114,7 @@ struct sram_hal_api_arg {
 	#define AML_D_P_W_EFUSE_SECURE_BOOT  (0x10)
 	#define AML_D_P_W_EFUSE_PASSWORD     (0x11)
 	#define AML_D_P_W_EFUSE_CUSTOMER_ID  (0x12)
+	#define AML_D_P_W_EFUSE_AMLOGIC 	 (0x20)
 	#define AML_D_P_IMG_DECRYPT          (0x40)
 	#define AML_D_P_UPGRADE_CHECK        (0x80)
 
diff --git a/arch/arm/include/asm/arch-gxtvbb/thermal.h b/arch/arm/include/asm/arch-gxtvbb/thermal.h
index 9339a6c..fbc1ec1 100644
--- a/arch/arm/include/asm/arch-gxtvbb/thermal.h
+++ b/arch/arm/include/asm/arch-gxtvbb/thermal.h
@@ -32,6 +32,8 @@
 #define SAR_ADC_DETECT_IDLE_SW	SAR_ADC_BASE +(0x9*4)//0xc8100624
 #define SAR_ADC_DELTA_10		SAR_ADC_BASE +(0xa*4)//0xc8100628
 #define SAR_ADC_REG11			SAR_ADC_BASE +(0xb*4)//0xc810062c
+#define SAR_ADC_REG12           SAR_ADC_BASE +(0xc*4)//0xc8100630
+#define SAR_ADC_REG13           SAR_ADC_BASE +(0xd*4)//0xc8100634
 #define SAR_CLK_CNTL			AO_SAR_CLK
 #define SAR_BUS_CLK_EN			AO_RTI_GEN_CNTL_REG0
 
diff --git a/arch/arm/include/asm/arch-txl/acs.h b/arch/arm/include/asm/arch-txl/acs.h
new file mode 100644
index 0000000..ee058d8
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/acs.h
@@ -0,0 +1,51 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/acs.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ACS_H
+#define __ACS_H
+
+#ifndef __ASSEMBLY__
+struct acs_setting{
+		char				acs_magic[5];	//acs setting magic word, make sure this piece of data was right.
+		unsigned char		chip_type;		//chip type
+		unsigned short		version;		//version of acs_setting struct, for PC tool use.
+		unsigned long		acs_set_length;	//length of current struct.
+
+		//ddr setting part, 16 bytes
+		char				ddr_magic[5];		//magic word to indicate that following 12 bytes was ddr setting.
+		unsigned char		ddr_set_version;	//struct version, for PC tool use.
+		unsigned short		ddr_set_length;		//length of ddr struct.
+		unsigned long		ddr_set_addr;		//address of ddr setting.
+
+		//ddr timing part, 16 bytes
+		char				ddrt_magic[5];
+		unsigned char		ddrt_set_version;
+		unsigned short		ddrt_set_length;
+		unsigned long		ddrt_set_addr;
+
+		char				pll_magic[5];
+		unsigned char		pll_set_version;
+		unsigned short		pll_set_length;
+		unsigned long		pll_set_addr;
+}__attribute__ ((packed));
+
+#endif
+#endif
diff --git a/arch/arm/include/asm/arch-txl/bl31_apis.h b/arch/arm/include/asm/arch-txl/bl31_apis.h
new file mode 100644
index 0000000..bcb5809
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/bl31_apis.h
@@ -0,0 +1,140 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/bl31_apis.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+/*
+ * Trustzone API
+ *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *
+ */
+
+#ifndef __GXBB_BL31_APIS_H
+#define __GXBB_BL31_APIS_H
+
+#include <asm/arch/io.h>
+
+/*#define SRAM_READ				0x82000010
+#define CORE_RD_REV1			0x82000011
+#define SRAM_ACS_READ		0x82000012
+#define SRAM_ACS_INDIRECT_READ		0x82000013*/
+
+#define GET_SHARE_MEM_INPUT_BASE		0x82000020
+#define GET_SHARE_MEM_OUTPUT_BASE		0x82000021
+#define GET_REBOOT_REASON		0x82000022
+#define GET_SHARE_STORAGE_IN_BASE		0x82000023
+#define GET_SHARE_STORAGE_OUT_BASE		0x82000024
+#define GET_SHARE_STORAGE_BLOCK_BASE	0x82000025
+#define GET_SHARE_STORAGE_MESSAGE_BASE	0x82000026
+#define GET_SHARE_STORAGE_BLOCK_SIZE		0x82000027
+#define SET_STORAGE_INFO		0x82000028
+
+/* Set Reboot Reason then Reboot*/
+#define PSCI_SYS_REBOOT		0x84000009
+
+/* SECUREOS DEFINITION*/
+/* SMC Identifiers for non-secure world functions */
+#define CALL_TRUSTZONE_HAL_API                  0x5
+
+/* EFUSE */
+#define EFUSE_READ					0x82000030
+#define EFUSE_WRITE				0x82000031
+#define EFUSE_WRITE_PATTERN		0x82000032
+#define EFUSE_USER_MAX    0x82000033
+
+#define DEBUG_EFUSE_WRITE_PATTERN	0x820000F0
+#define DEBUG_EFUSE_READ_PATTERN	0x820000F1
+
+/* JTAG*/
+#define JTAG_ON                                0x82000040
+#define JTAG_OFF                               0x82000041
+
+#define SET_USB_BOOT_FUNC	0x82000043
+	/* USB BOOT FUNC sub command list*/
+	#define CLEAR_USB_BOOT			1
+	#define FORCE_USB_BOOT			2
+	#define RUN_COMD_USB_BOOT		3
+	#define PANIC_DUMP_USB_BOOT	4
+
+/* Security Key*/
+#define SECURITY_KEY_QUERY	0x82000060
+#define SECURITY_KEY_READ	0x82000061
+#define SECURITY_KEY_WRITE	0x82000062
+#define SECURITY_KEY_TELL		0x82000063
+#define SECURITY_KEY_VERIFY	0x82000064
+#define SECURITY_KEY_STATUS	0x82000065
+#define SECURITY_KEY_NOTIFY	0x82000066
+#define SECURITY_KEY_LIST		0x82000067
+#define SECURITY_KEY_REMOVE	0x82000068
+#define SECURITY_KEY_NOTIFY_EX	0x82000069
+
+/* Secure HAL APIs */
+#define TRUSTZONE_HAL_API_SRAM                  0x400
+
+
+#define SRAM_HAL_API_CHECK_EFUSE 0x403
+struct sram_hal_api_arg {
+	unsigned int cmd;
+	unsigned int req_len;
+	unsigned int res_len;
+	unsigned long req_phy_addr;
+	unsigned long res_phy_addr;
+	unsigned long ret_phy_addr;
+};
+
+#define JTAG_STATE_ON  0
+#define JTAG_STATE_OFF 1
+#define JTAG_M3_AO     0
+#define JTAG_M3_EE     1
+#define JTAG_A53_AO    2
+#define JTAG_A53_EE 3
+#define CLUSTER_BIT 2
+
+
+/////////////////////////////////////////////////////////////////////////////////
+#define AML_DATA_PROCESS                 (0x820000FF)
+	#define AML_D_P_W_EFUSE_SECURE_BOOT  (0x10)
+	#define AML_D_P_W_EFUSE_PASSWORD     (0x11)
+	#define AML_D_P_W_EFUSE_CUSTOMER_ID  (0x12)
+	#define AML_D_P_W_EFUSE_AMLOGIC 	 (0x20)
+	#define AML_D_P_IMG_DECRYPT          (0x40)
+	#define AML_D_P_UPGRADE_CHECK        (0x80)
+
+#define GXB_EFUSE_PATTERN_SIZE      (0x500)
+#define GXB_IMG_SIZE                (24<<20)
+#define GXB_IMG_LOAD_ADDR           (0x1080000)
+	#define GXB_IMG_DEC_KNL   (1<<0)
+	#define GXB_IMG_DEC_RMD   (1<<1)
+	#define GXB_IMG_DEC_DTB   (1<<2)
+	#define GXB_IMG_DEC_ALL   (GXB_IMG_DEC_KNL|GXB_IMG_DEC_RMD|GXB_IMG_DEC_DTB)
+
+#define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
+
+void aml_set_jtag_state(unsigned state, unsigned select);
+unsigned aml_get_reboot_reason(void);
+unsigned aml_reboot(uint64_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2);
+unsigned long aml_sec_boot_check(unsigned long ,unsigned long ,unsigned long,unsigned long );
+long get_sharemem_info(unsigned long);
+void set_usb_boot_function(unsigned long command);
+void aml_system_off(void);
+
+#endif
diff --git a/arch/arm/include/asm/arch-txl/clock.h b/arch/arm/include/asm/arch-txl/clock.h
new file mode 100644
index 0000000..0ded8b1
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/clock.h
@@ -0,0 +1,82 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/clock.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ARCH_ARM_MESON_CLOCK_H_U_BOOT_
+#define __ARCH_ARM_MESON_CLOCK_H_U_BOOT_
+
+/* below clk is M8, it is placed here for compiling pass */
+#define CTS_PWM_A_CLK                  (45)
+#define CTS_PWM_B_CLK                  (44)
+#define CTS_PWM_C_CLK                  (43)
+#define CTS_PWM_D_CLK                  (42)
+#define CTS_ETH_RX_TX                  (41)
+#define CTS_PCM_MCLK                   (40)
+#define CTS_PCM_SCLK                   (39)
+#define CTS_VDIN_MEAS_CLK              (38)
+#define CTS_VDAC_CLK1                  (37)
+#define CTS_HDMI_TX_PIXEL_CLK          (36)
+#define CTS_MALI_CLK                   (35)
+#define CTS_SDHC_CLK1                  (34)
+#define CTS_SDHC_CLK0                  (33)
+#define CTS_AUDAC_CLKPI                (32)
+#define CTS_A9_CLK                     (31)
+#define CTS_DDR_CLK                    (30)
+#define CTS_VDAC_CLK0                  (29)
+#define CTS_SAR_ADC_CLK                (28)
+#define CTS_ENCI_CLK                   (27)
+#define SC_CLK_INT                     (26)
+#define USB_CLK_12MHZ                  (25)
+#define LVDS_FIFO_CLK                  (24)
+#define HDMI_CH3_TMDSCLK               (23)
+#define MOD_ETH_CLK50_I                (22)
+#define MOD_AUDIN_AMCLK_I              (21)
+#define CTS_BTCLK27                    (20)
+#define CTS_HDMI_SYS_CLK               (19)
+#define CTS_LED_PLL_CLK                (18)
+#define CTS_VGHL_PLL_CLK               (17)
+#define CTS_FEC_CLK_2                  (16)
+#define CTS_FEC_CLK_1                  (15)
+#define CTS_FEC_CLK_0                  (14)
+#define CTS_AMCLK                      (13)
+#define VID2_PLL_CLK                   (12)
+#define CTS_ETH_RMII                   (11)
+#define CTS_ENCT_CLK                   (10)
+#define CTS_ENCL_CLK                   (9)
+#define CTS_ENCP_CLK                   (8)
+#define CLK81                          (7)
+#define VID_PLL_CLK                    (6)
+#define AUD_PLL_CLK                    (5)
+#define MISC_PLL_CLK                   (4)
+#define DDR_PLL_CLK                    (3)
+#define SYS_PLL_CLK                    (2)
+#define AM_RING_OSC_CLK_OUT1           (1)
+#define AM_RING_OSC_CLK_OUT0           (0)
+
+int clk_get_rate(unsigned clksrc);
+unsigned long clk_util_clk_msr( unsigned long   clk_mux );
+__u32 get_cpu_clk(void);
+__u32 get_clk_ddr(void);
+__u32 get_clk81(void);
+__u32 get_misc_pll_clk(void);
+
+
+#endif /* __ARCH_ARM_MESON_CLOCK_H_U_BOOT_ */
+
diff --git a/arch/arm/include/asm/arch-txl/cpu.h b/arch/arm/include/asm/arch-txl/cpu.h
new file mode 100644
index 0000000..847a91e
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/cpu.h
@@ -0,0 +1,65 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/cpu.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _CPU_H
+#define _CPU_H
+//#include <config.h>
+//#include <asm/plat-cpu.h>
+//#include <asm/arch/ddr.h>
+
+#define CONFIG_AML_MESON 1
+#define CONFIG_AML_MESON_GX 1
+#define CONFIG_AML_MESON_GXL 1
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(64*1024*1024)
+
+/* dram */
+#define PHYS_SDRAM_1_BASE					0x00000000UL
+#define PHYS_SDRAM_1_SIZE					(CONFIG_DDR_SIZE << 20)
+#define CONFIG_SYS_SDRAM_BASE				PHYS_SDRAM_1_BASE
+#define CONFIG_SYS_INIT_SP_ADDR				(0x20000000)
+
+#define CONFIG_SYS_TEXT_BASE		0x01000000 /*16MB rsv*/
+#define CONFIG_SYS_LOAD_ADDR		(PHYS_SDRAM_1_BASE + CONFIG_SYS_TEXT_BASE)
+
+/* ? */
+#define CONFIG_SYS_CBSIZE		512
+#define CONFIG_SYS_PROMPT		SYS_PROMPT
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+/* support board late init */
+#define CONFIG_BOARD_LATE_INIT
+/* use "hush" command parser */
+#define CONFIG_SYS_HUSH_PARSER
+
+#define CONFIG_DTB_MEM_ADDR 0x1000000
+
+#define CONFIG_AML_CUSTOMER_ID  (0)
+
+#define CONFIG_SILENT_CONSOLE
+#define CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC
+#define CONFIG_SILENT_U_BOOT_ONLY
+
+#endif /* _CPU_H */
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-txl/cpu_config.h b/arch/arm/include/asm/arch-txl/cpu_config.h
new file mode 100644
index 0000000..6ea788a
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/cpu_config.h
@@ -0,0 +1,101 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/cpu_config.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _BOOT_ROM_CONFIG_H_
+#define _BOOT_ROM_CONFIG_H_
+
+/***********************************************************
+ * The following constants are GXBB definition
+ **********************************************************/
+#define ROMBOOT_START   0xD9040000
+#define ROM_SIZE        (64*1024)
+#define ROMBOOT_END     (ROMBOOT_START+ROM_SIZE)
+
+/***********************************************************
+ * AHB-SRAM Total Size 80KB, layout shown as below
+ *
+ * ROMCODE use the top 32KB
+ *
+ * [	128]	0xD901_3F80 - 0xD901_3FFF	Reserved
+ * [	128]	0xD901_3F00 - 0xD901_3F7F	CPUs Boot Entry
+ * [	256]	0xD901_3E00 - 0xD901_3EFF	Debug Info
+ * [	512]	0xD901_3C00 - 0xD901_3DFF	eFuse mirror
+ * [	 1K]	0xD901_3800 - 0xD901_3BFF	Secure Mailbox (3)
+ * [	 1K]	0xD901_3400 - 0xD901_37FF	High Mailbox (2) *
+ * [	 1K]	0xD901_3000 - 0xD901_33FF	High Mailbox (1) *
+ * [	26K]	0xD900_C800 - 0xD901_2FFF	BL1 Stack, BSS
+ * [	 1K]	0xD900_C400 - 0xD900_C7FF	NAND, USB Buffer
+ * [	 1K]	0xD900_C000 - 0xD900_C3FF	Reserved
+ *
+ **********************************************************/
+#define RAM_START			0xD9000000
+#define RAM_SIZE			(80 * 1024)
+#define BL1_RAM_START			(RAM_START + 0xC000)
+#define BL1_RAM_SIZE			(32 * 1024)
+#define BL1_RAM_END			(BL1_RAM_START + BL1_RAM_SIZE)
+#define BSS_START			(BL1_RAM_START + (2 * 1024))
+#define BSS_SIZE			(18 * 1024)
+#define _STACK_END			(BSS_START + BSS_SIZE + 8*1024)
+#define BL1_EFUSE_MIRROR		(BL1_RAM_END - 1024)
+#define P_SHARED_EFUSE_MIRROR		(volatile uint32_t *)(BL1_EFUSE_MIRROR)
+#define BL1_DEBUG_BUFFER		(BL1_RAM_END - 512)
+#define CPU_BOOT_ENTRY		(BL1_DEBUG_BUFFER + 256)
+#define P_SHARED_DEBUG_BUFF		(volatile uint32_t *)(BL1_DEBUG_BUFFER)
+#define BL1_SEC_MBX			(BL1_RAM_END - 2*1024)
+#define BL1_NAND_BUFF			(BL1_RAM_START + 1024)
+#define BL1_USB_BUFF			(BL1_NAND_BUFF)
+
+#define MEMORY_LOC			RAM_START
+
+#define SRAM_DEBUG_BUFF_SIZE		256
+
+/* BL2 SPL size */
+#define BL2_SIZE			(48 * 1024)
+
+//for signature test
+//#define CONFIG_AML_SIG_TEST_BUILD
+
+/* Software SHA2 */
+#define CONFIG_SHA2_SW
+
+/* Hardware SHA2 */
+#define CONFIG_SHA2_HW
+#define SHA2_HW_UPDATE_API
+
+/* Keep timer config in conf.h */
+#define CONFIG_TIMER
+
+/* Bootrom debug info */
+#define CONFIG_DEBUG_INFO
+
+/* Mincrypt RSA library */
+//#define CONFIG_MINCRYPT
+
+/* PolarSSL RSA library */
+#define CONFIG_POLARSSL_RSA
+
+#ifdef CONFIG_POLARSSL_RSA
+#ifndef CONFIG_MALLOC
+#define CONFIG_MALLOC
+#endif /* ! CONFIG_MALLOC */
+#endif /* CONFIG_POLARSSL_RSA */
+
+#endif /* _BOOT_ROM_CONFIG_H_ */
diff --git a/arch/arm/include/asm/arch-txl/cpu_sdio.h b/arch/arm/include/asm/arch-txl/cpu_sdio.h
new file mode 100644
index 0000000..6cdf017
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/cpu_sdio.h
@@ -0,0 +1,267 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/cpu_sdio.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __CPU_SDIO_H__
+#define __CPU_SDIO_H__
+
+#define SD_EMMC_BASE_A 0xd0070000
+#define SD_EMMC_BASE_B 0xd0072000
+#define SD_EMMC_BASE_C 0xd0074000
+
+#define SDIO_PORT_A 0
+#define SDIO_PORT_B 1
+#define SDIO_PORT_C 2
+
+#define	Cfg_div 	0
+#define Cfg_src		6
+#define Cfg_co_phase	8
+#define	Cfg_tx_phase	10
+#define	Cfg_rx_phase	12
+#define	Cfg_sram_pd		14
+#define	Cfg_tx_delay	16
+#define	Cfg_rx_delay	20
+#define	Cfg_always_on	24
+#define	Cfg_irq_sdio_sleep   25
+#define Cfg_irq_sdio_sleep_ds		26
+
+#define	SD_EMMC_RXD_ERROR				1
+#define	SD_EMMC_TXD_ERROR				1<<1
+#define	SD_EMMC_DESC_ERROR				1<<2
+#define	SD_EMMC_RESP_CRC_ERROR			1<<3
+#define	SD_EMMC_RESP_TIMEOUT_ERROR		1<<4
+#define	SD_EMMC_DESC_TIMEOUT_ERROR		1<<5
+
+struct sd_emmc_global_regs {
+    volatile uint32_t gclock;     // 0x00
+    volatile uint32_t gdelay;     // 0x04
+    volatile uint32_t gadjust;    // 0x08
+    volatile uint32_t reserved_0c;       // 0x0c
+    volatile uint32_t gcalout;    // 0x10
+    volatile uint32_t reserved_14[11];   // 0x14~0x3c
+    volatile uint32_t gstart;     // 0x40
+    volatile uint32_t gcfg;       // 0x44
+    volatile uint32_t gstatus;    // 0x48
+    volatile uint32_t girq_en;    // 0x4c
+    volatile uint32_t gcmd_cfg;   // 0x50
+    volatile uint32_t gcmd_arg;   // 0x54
+    volatile uint32_t gcmd_dat;   // 0x58
+    volatile uint32_t gcmd_rsp0;   // 0x5c
+    volatile uint32_t gcmd_rsp1;  // 0x60
+    volatile uint32_t gcmd_rsp2;  // 0x64
+    volatile uint32_t gcmd_rsp3;  // 0x68
+    volatile uint32_t reserved_6c;       // 0x6c
+    volatile uint32_t gcurr_cfg;  // 0x70
+    volatile uint32_t gcurr_arg;  // 0x74
+    volatile uint32_t gcurr_dat;  // 0x78
+    volatile uint32_t gcurr_rsp;  // 0x7c
+    volatile uint32_t gnext_cfg;  // 0x80
+    volatile uint32_t gnext_arg;  // 0x84
+    volatile uint32_t gnext_dat;  // 0x88
+    volatile uint32_t gnext_rsp;  // 0x8c
+    volatile uint32_t grxd;       // 0x90
+    volatile uint32_t gtxd;       // 0x94
+    volatile uint32_t reserved_98[90];   // 0x98~0x1fc
+    volatile uint32_t gdesc[128]; // 0x200
+    volatile uint32_t gping[128]; // 0x400
+    volatile uint32_t gpong[128]; // 0x800
+};
+
+union sd_emmc_setup {
+    uint32_t d32;
+    struct {
+        unsigned bw:3;
+        unsigned fast:1;
+        unsigned par:3;
+        unsigned hcs:1;
+        unsigned sd:1;
+        unsigned sdhc:1;
+        unsigned type:6;
+        unsigned rca:16;
+    } b;
+};
+
+struct sd_emmc_desc_info{
+    uint32_t cmd_info;
+    uint32_t cmd_arg;
+    uint32_t data_addr;
+    uint32_t resp_addr;
+};
+
+struct cmd_cfg{
+    uint32_t length:9;
+    uint32_t block_mode:1;
+    uint32_t r1b:1;
+    uint32_t end_of_chain:1;
+    uint32_t timeout:4;
+    uint32_t no_resp:1;
+    uint32_t no_cmd:1;
+    uint32_t data_io:1;
+    uint32_t data_wr:1;
+    uint32_t resp_nocrc:1;
+    uint32_t resp_128:1;
+    uint32_t resp_num:1;
+    uint32_t data_num:1;
+    uint32_t cmd_index:6;
+    uint32_t error:1;
+    uint32_t owner:1;
+};
+
+struct sd_emmc_status{
+	uint32_t rxd_err:8;      /*[7:0]     RX data CRC error per wire, for multiple block read, the CRC errors are ORed together.*/
+	uint32_t txd_err:1;      /*[8]       TX data CRC error, for multiple block write, any one of blocks CRC error. */
+	uint32_t desc_err:1;     /*[9]       SD/eMMC controller doesnot own descriptor. The owner bit is p0q, set cfg_ignore_owner to ignore this error.*/
+	uint32_t resp_err:1;     /*[10]      Response CRC error.*/
+	uint32_t resp_timeout:1; /*[11]      No response received before time limit. The timeout limit is set by cfg_resp_timeout.*/
+	uint32_t desc_timeout:1; /*[12]      Descriptor execution time over time limit. The timeout limit is set by descriptor itself.*/
+                            /*      Consider the multiple block read/write, set the proper timeout limits.*/
+	uint32_t end_of_chain:1; /*[13]      End of Chain IRQ, Normal IRQ. */
+	uint32_t desc_irq:1;     /*[14]      This descriptor requests an IRQ, Normal IRQ, the descriptor chain execution keeps going on.*/
+	uint32_t irq_sdio:1;     /*[15]      SDIO device uses DAT[1] to request IRQ. */
+	uint32_t dat_i:8;        /*[23:16]   Input data signals. */
+	uint32_t cmd_i:1;        /*[24]      nput response signal. */
+	uint32_t ds:1;           /*[25]      Input data strobe. */
+	uint32_t bus_fsm:4;      /*[29:26]   BUS fsm */
+    uint32_t desc_wr_rdy:1;  /*[30]      Descriptor write back process is done and it is ready for CPU to read.*/
+	uint32_t core_rdy:1;	 /*[31]       desc_busy or sd_emmc_irq or bus_fsm is not idle.*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_clock{
+    uint32_t div:6;          /*[5:0]     Clock divider. Frequency = clock source/cfg_div, Maximum divider 63. */
+                            /*Clock off: cfg_div==0, the clock is disabled */
+                            /*Divider bypass: cfg_div==1, clock source is used as core clock without divider. */
+    uint32_t src:2;          /*[7:6]     Clock source, 0: Crystal 24MHz, 1: Fix PLL, 850MHz*/
+                            /* 2: MPLL, <637MHz, used for 400MHz exactly. 3: different PLL */
+    uint32_t core_phase:2;   /*[9:8]     Core clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t tx_phase:2;     /*[11:10]   TX clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t rx_phase:2;     /*[13:12]   RX clock phase. 0: 0 phase, 1: 90 phase, 2: 180 phase, 3: 270 phase.*/
+    uint32_t reserved14:2;
+    uint32_t tx_delay:4;     /*[19:16]   TX clock delay line. 0: no delay, n: delay n*200ps. Maximum delay 3ns.*/
+    uint32_t rx_delay:4;     /*[23:20]   RX clock delay line. 0: no delay, n: delay n*200ps. Maximum delay 3ns.*/
+    uint32_t always_on:1;    /*[24]      1: Keep clock always on. 0: Clock on/off controlled by activities. */
+                            /*Any APB3 access or descriptor execution will keep clock on.*/
+    uint32_t irq_sdio_sleep:1; /*[25]    1: enable IRQ sdio when in sleep mode. */
+    uint32_t reserved26:6;
+};
+
+struct sd_emmc_delay{
+    uint32_t dat0:4;         /*[3:0]       Data 0 delay line. */
+    uint32_t dat1:4;         /*[7:4]       Data 1 delay line. */
+    uint32_t dat2:4;         /*[11:8]      Data 2 delay line. */
+    uint32_t dat3:4;         /*[15:12]     Data 3 delay line. */
+    uint32_t dat4:4;         /*[19:16]     Data 4 delay line. */
+    uint32_t dat5:4;         /*[23:20]     Data 5 delay line. */
+    uint32_t dat6:4;         /*[27:24]     Data 6 delay line. */
+    uint32_t dat7:4;         /*[31:28]     Data 7 delay line. */
+};
+
+
+struct sd_emmc_adjust{
+    uint32_t cmd_delay:4;           /*[3:0]       Command delay line. */
+    uint32_t ds_delay:4;            /*[7:4]       DS delay line. */
+    uint32_t cali_sel:4;            /*[11:8]      Select one signal to be tested.*/
+                                        /*Signals are labeled from 0 to 9 the same as delay lines. */
+    uint32_t cali_enable:1;         /*[12]        Enable calibration. */
+    uint32_t adj_enable:1;          /*[13]       Adjust interface timing by resampling the input signals. */
+    uint32_t cali_rise:1;           /*[14]       1: test the rising edge. 0: test the falling edge. */
+    uint32_t ds_enable:1;			/*[15]		Sampling the DAT based on DS in HS400 mode*/
+    uint32_t adj_delay:6;           /*[21:16]       Resample the input signals when clock index==adj_delay. */
+    uint32_t adj_auto:1;			/*[22]			Use cali_dut first falling edge to adjust the timing */
+										/*set cali_enable to 1 to use this function*/
+	uint32_t reserved23:9;
+};
+
+
+struct sd_emmc_calout{
+    uint32_t cali_idx:6;         /*[5:0]       Calibration reading. The event happens at this index. */
+    uint32_t reserved6:1;
+    uint32_t cali_vld:1;         /*[7]         The reading is valid. */
+    uint32_t cali_setup:8;       /*[15:8]      Copied from BASE+0x8 [15:8] include cali_sel, cali_enable, adj_enable, cali_rise. */
+    uint32_t reserved16:16;
+};
+
+
+struct sd_emmc_start{
+	uint32_t init:1;         /*[0]   1: Read descriptor from internal SRAM, limited to 32 descriptors. */
+                            /*  0: Read descriptor from external DDR */
+	uint32_t busy:1;         /*[1]   1: Start command chain execution process. 0: Stop */
+	uint32_t addr:30;        /*[31:2] Descriptor address, the last 2 bits are 0, 4 bytes aligned. */
+                            /*  When internal SRAM is used, the valid address range is from 0x200~0x3ff */
+                            /*  When external DDR is used, the valid address is anywhere in DDR, the length of chain is unlimited.*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_config{
+	uint32_t bus_width:2;    /*[1:0]     0: 1 bit, 1: 4 bits, 2: 8 bits, 3: 2 bits (not supported)*/
+	uint32_t ddr:1;          /*[2]       1: DDR mode, 0: SDR mode */
+	uint32_t dc_ugt:1;       /*[3]       1: DDR access urgent, 0: DDR access normal. */
+	uint32_t bl_len:4;       /*[7:4]     Block length 2^cfg_bl_len, because internal buffer size is limited to 512 bytes, the cfg_bl_len <=9. */
+	uint32_t resp_timeout:4; /*[11:8]    Wait response till 2^cfg_resp_timeout core clock cycles. Maximum 32768 core cycles. */
+	uint32_t rc_cc:4;        /*[15:12]   Wait response-command, command-command gap before next command, 2^cfg_rc_cc core clock cycles. */
+	uint32_t out_fall:1;     /*[16]      DDR mode only. The command and TXD start from rising edge. Set 1 to start from falling edge. */
+	uint32_t blk_gap_ip:1;   /*[17]      1: Enable SDIO data block gap interrupt period. 0: Disabled.*/
+	uint32_t spare:1;        /*[18]      Spare,  ??? need check*/
+	uint32_t ignore_owner:1; /*[19]      Use this descriptor even if its owner bit is p0q.*/
+	uint32_t chk_ds:1;       /*[20]      Check data strobe in HS400.*/
+	uint32_t cmd_low:1;      /*[21]      Hold CMD as output Low, eMMC boot mode.*/
+	uint32_t stop_clk:1;     /*[22]      1: stop clock. 0: normal clock.*/
+	                        /*In normal mode, the clock is automatically on/off during reading mode to back off reading in case of*/
+	                        /*DDR slow response, stop clock is used in voltage switch.*/
+	uint32_t auto_clk:1;     /*[23]      1: when BUS is idle and no descriptor is available, turn off clock, to save power.*/
+                            /*      0: core clock is always on.*/
+    uint32_t txd_add_err:1;	/*[24]   	TXD add error test*/
+							/*Test feature, should not be used in normal condition.*/
+							/*It will inverted the first CRC bits of the 3rd block.*/
+							/*Block index starts from 0, 1, 2, m*/
+    uint32_t txd_retry:1;	/*[25]   	When TXD CRC error, host sends the block again.*/
+							/*The total number of retries of one descriptor is limited to 15, */
+							/*after 15 retries, the TXD_err is set to high.*/
+    uint32_t revd:8;	        /*[31:26]   reved*/
+};//__attribute__((__may_alias__));
+
+
+struct sd_emmc_irq_en{
+	uint32_t rxd_err:8;      /*[7:0]     RX data CRC error per wire.*/
+	uint32_t txd_err:1;      /*[8]       TX data CRC error. */
+	uint32_t desc_err:1;     /*[9]       SD/eMMC controller doesnot own descriptor. */
+	uint32_t resp_err:1;     /*[10]      Response CRC error.*/
+	uint32_t resp_timeout:1; /*[11]      No response received before time limit. */
+	uint32_t desc_timeout:1; /*[12]      Descriptor execution time over time limit. */
+	uint32_t end_of_chain:1; /*[13]      End of Chain IRQ. */
+	uint32_t desc_irq:1;     /*[14]      This descriptor requests an IRQ. */
+	uint32_t irq_sdio:1;     /*[15]      Enable sdio interrupt. */
+    uint32_t revd:16;	    /*[31:16]   reved*/
+};
+
+struct sd_emmc_data_info{
+	uint32_t cnt:10;         /*[9:0]     Rxd words received from BUS. Txd words received from DDR.*/
+	uint32_t blk:9;          /*[24:16]   Rxd Blocks received from BUS. Txd blocks received from DDR.*/
+	uint32_t revd:30;        /*[31:17]   Reved. */
+};
+
+
+struct sd_emmc_card_info{
+	uint32_t txd_cnt:10;     /*[9:0]     Txd BUS cycle counter. */
+	uint32_t txd_blk:9;      /*[24:16]   Txd BUS block counter.*/
+	uint32_t revd:30;        /*[31:17]   Reved. */
+};
+
+#endif
diff --git a/arch/arm/include/asm/arch-txl/ddr.h b/arch/arm/include/asm/arch-txl/ddr.h
new file mode 100644
index 0000000..f5ea6c7
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/ddr.h
@@ -0,0 +1,116 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/ddr.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <config.h>
+#include <io.h>
+#include <stdint.h>
+#include <asm/arch/ddr_define.h>
+
+/* io defines */
+//#define wr_reg(addr, data)	(*((volatile uint32_t *)addr))=(uint32_t)(uint64_t)(data)
+//#define rd_reg(addr)		(*((volatile uint32_t *)(addr)))
+#define wr_reg(addr, data)	writel(data, addr)
+#define rd_reg(addr)	readl(addr)
+/*clear [mask] 0 bits in [addr], set these 0 bits with [value] corresponding bits*/
+#define modify_reg(addr, value, mask) wr_reg(addr, ((rd_reg(addr) & (mask)) | (value)))
+#define wait_set(addr, loc) do{}while(0 == (rd_reg(addr) & (1<<loc)));
+#define wait_clr(addr, loc) do{}while(1 == (rd_reg(addr) & (1<<loc)));
+#define wait_equal(addr, data) do{}while(data != (rd_reg(addr)));
+
+/* function defines */
+unsigned int ddr_init(void);
+unsigned int ddr_init_pll(void);
+unsigned int ddr_init_dmc(void);
+unsigned int ddr_init_pctl(void);
+unsigned int hot_boot(void);
+void ddr_print_info(void);
+void ddr_test(void);
+void ddr_pre_init(void);
+void ddr_debug(void);
+
+/* pctl status */
+#define  UPCTL_STAT_MASK        (7)
+#define  UPCTL_STAT_INIT        (0)
+#define  UPCTL_STAT_CONFIG      (1)
+#define  UPCTL_STAT_ACCESS      (3)
+#define  UPCTL_STAT_LOW_POWER   (5)
+
+/* pctl cmds */
+#define UPCTL_CMD_INIT         (0)
+#define UPCTL_CMD_CONFIG       (1)
+#define UPCTL_CMD_GO           (2)
+#define UPCTL_CMD_SLEEP        (3)
+#define UPCTL_CMD_WAKEUP       (4)
+
+/* PUB PIR setting */
+#define PUB_PIR_INIT						(1<<0)
+#define PUB_PIR_ZCAL						(1<<1)
+#define PUB_PIR_CA							(1<<2)
+#define PUB_PIR_PLLINIT						(1<<4)
+#define PUB_PIR_DCAL						(1<<5)
+#define PUB_PIR_PHYRST						(1<<6)
+#define PUB_PIR_DRAMRST						(1<<7)
+#define PUB_PIR_DRAMINIT					(1<<8)
+#define PUB_PIR_WL							(1<<9)
+#define PUB_PIR_QSGATE						(1<<10)
+#define PUB_PIR_WLADJ						(1<<11)
+#define PUB_PIR_RDDSKW						(1<<12)
+#define PUB_PIR_WRDSKW						(1<<13)
+#define PUB_PIR_RDEYE						(1<<14)
+#define PUB_PIR_WREYE						(1<<15)
+#define PUB_PIR_ICPC						(1<<16)
+#define PUB_PIR_PLLBYP						(1<<17)
+#define PUB_PIR_CTLDINIT					(1<<18)
+#define PUB_PIR_RDIMMINIT					(1<<19)
+#define PUB_PIR_CLRSR						(1<<27)
+#define PUB_PIR_LOCKBYP						(1<<28)
+#define PUB_PIR_DCALBYP						(1<<29)
+#define PUB_PIR_ZCALBYP						(1<<30)
+#define PUB_PIR_INITBYP						(1<<31)
+
+/* PHY initialize register (PIR) */
+#define DDR_PIR ((PUB_PIR_ZCAL) 		|\
+				(PUB_PIR_PLLINIT) 		|\
+				(PUB_PIR_DCAL) 			|\
+				(PUB_PIR_PHYRST)		|\
+				(PUB_PIR_DRAMRST)		|\
+				(PUB_PIR_DRAMINIT)		|\
+				(PUB_PIR_WL)			|\
+				(PUB_PIR_QSGATE)		|\
+				(PUB_PIR_WLADJ)			|\
+				(PUB_PIR_RDDSKW)		|\
+				(PUB_PIR_WRDSKW)		|\
+				(PUB_PIR_RDEYE)			|\
+				(PUB_PIR_WREYE)			 \
+				)
+
+/* PHY general status register (PGSR0) */
+#if (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR3)
+#define DDR_PGSR0_CHECK() ((rd_reg(DDR0_PUB_PGSR0) != 0xC0000fff) && \
+							(rd_reg(DDR0_PUB_PGSR0) != 0x80000fff))
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR2)
+#define DDR_PGSR0_CHECK()
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR3)
+#define DDR_PGSR0_CHECK()
+#endif
+
+/* other regs */
+#define SCRATCH0				0xC1107D3C
diff --git a/arch/arm/include/asm/arch-txl/ddr_define.h b/arch/arm/include/asm/arch-txl/ddr_define.h
new file mode 100644
index 0000000..c961e38
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/ddr_define.h
@@ -0,0 +1,147 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/ddr_define.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#define CONFIG_DDR_TYPE_DDR3				0
+#define CONFIG_DDR_TYPE_DDR4				1
+#define CONFIG_DDR_TYPE_LPDDR3				2
+#define CONFIG_DDR_TYPE_LPDDR2				3
+#define CONFIG_DDR_TYPE_AUTO				0xf /* support ddr3/ddr4 */
+
+/* ddr channel defines */
+#define CONFIG_DDR0_16BIT					1
+#define CONFIG_DDR0_RANK0					2
+#define CONFIG_DDR0_RANK01					3
+#define CONFIG_DDR0_16BIT_2					4
+/* CONFIG_DDR_CHL_AUTO mode support RANK0 and RANK0+1 mode auto detect */
+#define CONFIG_DDR_CHL_AUTO					0xF
+
+#define CFG_DDR_BASE_ADDR					0X0
+#define CFG_DDR_START_OFFSET				0X01000000 //SKIP 16MB
+
+/* ddr type identifier */
+#define CONFIG_DDR_TIMMING_LPDDR2			0x02
+#define CONFIG_DDR_TIMMING_LPDDR3			0x03
+#define CONFIG_DDR_TIMMING_DDR3_7			0x07
+#define CONFIG_DDR_TIMMING_DDR3_9			0x09
+#define CONFIG_DDR_TIMMING_DDR3_11			0x0B
+#define CONFIG_DDR_TIMMING_DDR3_12			0x0C
+#define CONFIG_DDR_TIMMING_DDR3_13			0x0D
+#define CONFIG_DDR_TIMMING_DDR3_14			0x0E
+
+#define CONFIG_DDR_TIMMING_DDR4_1600		0x0F
+#define CONFIG_DDR_TIMMING_DDR4_1866		0x10
+#define CONFIG_DDR_TIMMING_DDR4_2133		0x11
+#define CONFIG_DDR_TIMMING_DDR4_2400		0x12
+#define CONFIG_DDR_TIMMING_DDR4_2666		0x13
+#define CONFIG_DDR_TIMMING_DDR4_3200		0x14
+
+#define CONFIG_DDR_FUNC_TEST				(1<<0)
+
+#define CONFIG_DDR_INIT_RETRY_TOTAL			(10)
+#define CONFIG_DDR_PCTL_RETRY_TOTAL			(100)
+
+#define DDR_USE_1_RANK(chl_set)	((chl_set == CONFIG_DDR0_RANK0) || \
+				(chl_set == CONFIG_DDR0_16BIT))
+#define DDR_USE_2_RANK(chl_set)	((chl_set == CONFIG_DDR0_RANK01))
+
+/* DMC_DDR_CTRL defines */
+#define DDR_DDR4_ENABLE						(1<<22)
+#define DDR_RANK1_ENABLE					(1<<21)
+#define DDR_DDR4_BG_ENABLE					(1<<20)
+#define DDR_16BIT_ENABLE					(1<<16)
+
+#define DDR_RANK1_SIZE_CTRL					(3)
+#define DDR_RANK0_SIZE_CTRL					(0)
+
+
+/* how to add a new ddr function?
+   1. add CONFIG_DDR_FUNC_XXX in (config).h file
+   2. add define in this file.
+      2.1 add
+        #ifndef CONFIG_DDR_FUNC_XXX
+        #define CONFIG_DDR_FUNC_XXX 0
+        #endif
+      2.2 add
+        #define DDR_FUNC_XXX (CONFIG_FUNC_XXX<<X)
+      2.3 add DDR_FUNC_XXX |\ in DDR_FUNC
+   3. add same define and parser in bl2 code
+   */
+/* 2.1, 2,2, 2,3 example */
+/*
+#ifndef CONFIG_CMD_DDR_D2PLL
+#define CONFIG_CMD_DDR_D2PLL				0
+#endif
+#define DDR_FUNC_D2PLL						(CONFIG_CMD_DDR_D2PLL<<0)
+#define DDR_FUNC							(EXISTING_FUNCTIONS) |\
+											(DDR_FUNC_D2PLL)
+*/
+
+/* d2pll support */
+#ifndef CONFIG_CMD_DDR_D2PLL
+#define CONFIG_CMD_DDR_D2PLL				0
+#endif
+#define DDR_FUNC_D2PLL						(CONFIG_CMD_DDR_D2PLL<<0)
+
+/* ddr low power function support */
+#ifndef CONFIG_DDR_LOW_POWER
+#define CONFIG_DDR_LOW_POWER				0
+#endif
+#define DDR_FUNC_LP							(CONFIG_DDR_LOW_POWER<<1)
+
+/* ddr zq power down support */
+#ifndef CONFIG_DDR_ZQ_PD
+#define CONFIG_DDR_ZQ_PD					0
+#endif
+#define DDR_FUNC_ZQ_PD						(CONFIG_DDR_ZQ_PD<<2)
+
+/* ddr vref function */
+#ifndef CONFIG_DDR_USE_EXT_VREF
+#define CONFIG_DDR_USE_EXT_VREF				0
+#endif
+#define DDR_FUNC_EXT_VREF					(CONFIG_DDR_USE_EXT_VREF<<3)
+
+/* ddr4 timing test function */
+#ifndef CONFIG_DDR4_TIMING_TEST
+#define CONFIG_DDR4_TIMING_TEST				0
+#endif
+#define DDR_FUNC_DDR4_TIMING_TEST			(CONFIG_DDR4_TIMING_TEST<<4)
+
+/* ddr pll bypass */
+#ifndef CONFIG_DDR_PLL_BYPASS
+#define CONFIG_DDR_PLL_BYPASS				0
+#endif
+#define DDR_FUNC_DDR_PLL_BYPASS				(CONFIG_DDR_PLL_BYPASS<<5)
+
+/* ddr rdbi function */
+#ifndef CONFIG_DDR_FUNC_RDBI
+#define CONFIG_DDR_FUNC_RDBI				0
+#endif
+#define DDR_FUNC_RDBI						(CONFIG_DDR_FUNC_RDBI<<6)
+
+#define DDR_FUNC							(DDR_FUNC_D2PLL					| \
+											DDR_FUNC_LP						| \
+											DDR_FUNC_ZQ_PD					| \
+											DDR_FUNC_EXT_VREF				| \
+											DDR_FUNC_DDR4_TIMING_TEST		| \
+											DDR_FUNC_DDR_PLL_BYPASS			| \
+											DDR_FUNC_RDBI					| \
+											(1 << 31) 						\
+											)
diff --git a/arch/arm/include/asm/arch-txl/efuse.h b/arch/arm/include/asm/arch-txl/efuse.h
new file mode 100644
index 0000000..e7b7ca3
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/efuse.h
@@ -0,0 +1,62 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/efuse.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __EFUSE_H
+#define __EFUSE_H
+
+#include <config.h>
+#include <common.h>
+
+/* efuse HAL_API arg */
+struct efuse_hal_api_arg {
+	unsigned int cmd;		/* R/W */
+	unsigned int offset;
+	unsigned int size;
+	unsigned long buffer_phy;
+	unsigned long retcnt_phy;
+};
+
+
+#define EFUSE_BYTES				512   /* (EFUSE_BITS/8) */
+
+#define EFUSE_HAL_API_READ	0
+#define EFUSE_HAL_API_WRITE 1
+#define EFUSE_HAL_API_WRITE_PATTERN 2
+#define EFUSE_HAL_API_USER_MAX 3
+
+#define EFUSE_USER_MASK            (0x1 << 16)
+#define EFUSE_THERMAL_MASK         (0x1 << 17)
+#define EFUSE_THERMAL_VERFLAG_MASK (0x1 << 18)
+#define EFUSE_ENCRYPT_MASK         (0x1 << 19)
+
+#define ASSIST_HW_REV                              0x1f53
+
+int efuse_read_usr(char *buf, size_t count, loff_t *ppos);
+int efuse_write_usr(char *buf, size_t count, loff_t *ppos);
+uint32_t efuse_get_max(void);
+ssize_t efuse_read(char *buf, size_t count, loff_t *ppos);
+ssize_t efuse_write(const char *buf, size_t count, loff_t *ppos);
+
+int32_t meson_trustzone_efuse(struct efuse_hal_api_arg *arg);
+int32_t meson_trustzone_efuse_get_max(struct efuse_hal_api_arg *arg);
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-txl/eth_setup.h b/arch/arm/include/asm/arch-txl/eth_setup.h
new file mode 100644
index 0000000..190b9e0
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/eth_setup.h
@@ -0,0 +1,116 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/eth_setup.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/io.h>
+
+/*
+ *board configuration interface.
+ * */
+struct eth_clock_conf{
+	int enable;
+	int clock_50MHZ_phase;
+	//add ... as you need.
+};
+
+struct eth_board_socket{
+char *name ;
+int (*eth_clock_configure)(struct eth_clock_conf);
+int (*eth_pinmux_setup)(void);
+int (*eth_hw_reset)(void);
+
+};
+
+
+
+/*
+ *clock define part
+ */
+
+#define ETH_BASE                                (0xC9410000)
+#define ETH_PLL_CNTL                            CBUS_REG_ADDR(0x2050)
+ /* Ethernet ctrl */
+#define ETH_PLL_CNTL_DIVEN                      (1<<0)
+#define ETH_PLL_CNTL_MACSPD                     (1<<1)
+#define ETH_PLL_CNTL_DATEND                     (1<<2)
+#define ETH_PLL_CNTL_DESEND                     (1<<3)
+
+
+/*
+	please refer following doc for detail
+	@AppNote-M3-ClockTrees.docx
+
+	select clk: -> CBUS_REG(0x1076)
+
+	7-sys_pll_div2
+	6-vid2_pll_clk
+	5-vid_pll_clk
+	4-aud_pll_clk
+	3-ddr_pll_clk
+	2-misc_pll_clk
+	1-sys_pll_clk
+	0-XTAL
+
+	clk_freq:800MHz
+	output_clk:50MHz
+	aways,maybe changed for others?
+*/
+
+#define ETH_CLKSRC_XTAL             (0)
+#define ETH_CLKSRC_SYS_PLL_CLK      (1)
+#define ETH_CLKSRC_MISC_PLL_CLK     (2)
+#define ETH_CLKSRC_DDR_PLL_CLK      (3)
+#define ETH_CLKSRC_AUD_PLL_CLK      (
+#define ETH_CLKSRC_VID_PLL_CLK      (5)
+#define ETH_CLKSRC_VID2_PLL_CLK     (6)
+#define ETH_CLKSRC_SYS_PLL_DIV2_CLK (7)
+#define CLK_1M						(1000000)
+
+typedef union eth_aml_reg0 {
+    /** raw register data */
+    unsigned int d32;
+    /** register bits */
+	struct {
+        unsigned phy_intf_sel:1;
+        unsigned data_endian:1;
+        unsigned desc_endian:1;
+        unsigned rx_clk_rmii_invert:1;
+        unsigned rgmii_tx_clk_src:1;
+        unsigned rgmii_tx_clk_phase:2;
+        unsigned rgmii_tx_clk_ratio:3;
+        unsigned phy_ref_clk_enable:1;
+        unsigned clk_rmii_i_invert:1;
+        unsigned clk_en:1;
+        unsigned adj_enable:1;
+        unsigned adj_setup:1;
+        unsigned adj_delay:5;
+        unsigned adj_skew:5;
+        unsigned cali_start:1;
+        unsigned cali_rise:1;
+        unsigned cali_sel:3;
+        unsigned rgmii_rx_reuse:1;
+        unsigned eth_urgent:1;
+		} b;
+} eth_aml_reg0_t;
+
+#define ETH_VALIDE_CLKSRC(clk,out_clk) ((clk%out_clk)==0)
+
+int  eth_clk_set(int selectclk,unsigned long clk_freq,unsigned long out_clk);
+
diff --git a/arch/arm/include/asm/arch-txl/gpio.h b/arch/arm/include/asm/arch-txl/gpio.h
new file mode 100644
index 0000000..03be88e
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/gpio.h
@@ -0,0 +1,252 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/gpio.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ARCH_GPIO_H_
+#define __ARCH_GPIO_H_
+/*AO Bank*/
+#define	GPIOAO_0    0
+#define	GPIOAO_1    1
+#define	GPIOAO_2    2
+#define	GPIOAO_3    3
+#define	GPIOAO_4    4
+#define	GPIOAO_5    5
+#define	GPIOAO_6    6
+#define	GPIOAO_7    7
+#define	GPIOAO_8    8
+#define	GPIOAO_9    9
+
+/*EE Bank*/
+#define	GPIOZ_0    0
+#define	GPIOZ_1    1
+#define	GPIOZ_2    2
+#define	GPIOZ_3    3
+#define	GPIOZ_4    4
+#define	GPIOZ_5    5
+#define	GPIOZ_6    6
+#define	GPIOZ_7    7
+#define	GPIOZ_8    8
+#define	GPIOZ_9    9
+#define	GPIOZ_10    10
+#define	GPIOZ_11    11
+#define	GPIOZ_12    12
+#define	GPIOZ_13    13
+#define	GPIOZ_14    14
+#define	GPIOZ_15    15
+
+#define	GPIOH_0    16
+#define	GPIOH_1    17
+#define	GPIOH_2    18
+#define	GPIOH_3    19
+#define	GPIOH_4    20
+#define	GPIOH_5    21
+#define	GPIOH_6    22
+#define	GPIOH_7    23
+#define	GPIOH_8    24
+#define	GPIOH_9    25
+
+#define	BOOT_0    26
+#define	BOOT_1    27
+#define	BOOT_2    28
+#define	BOOT_3    29
+#define	BOOT_4    30
+#define	BOOT_5    31
+#define	BOOT_6    32
+#define	BOOT_7    33
+#define	BOOT_8    34
+#define	BOOT_9    35
+#define	BOOT_10    36
+#define	BOOT_11    37
+#define	BOOT_12    38
+#define	BOOT_13    39
+#define	BOOT_14    40
+#define	BOOT_15    41
+
+#define	CARD_0    42
+#define	CARD_1    43
+#define	CARD_2    44
+#define	CARD_3    45
+#define	CARD_4    46
+#define	CARD_5    47
+#define	CARD_6    48
+
+#define	GPIODV_0    49
+#define	GPIODV_1    50
+#define	GPIODV_2    51
+#define	GPIODV_3    52
+#define	GPIODV_4    53
+#define	GPIODV_5    54
+#define	GPIODV_6    55
+#define	GPIODV_7    56
+#define	GPIODV_8    57
+#define	GPIODV_9    58
+#define	GPIODV_10    59
+#define	GPIODV_11    60
+#define	GPIODV_12    61
+#define	GPIODV_13    62
+#define	GPIODV_14    63
+#define	GPIODV_15    64
+#define	GPIODV_16    65
+#define	GPIODV_17    66
+#define	GPIODV_18    67
+#define	GPIODV_19    68
+#define	GPIODV_20    69
+#define	GPIODV_21    70
+#define	GPIODV_22    71
+#define	GPIODV_23    72
+#define	GPIODV_24    73
+#define	GPIODV_25    74
+#define	GPIODV_26    75
+#define	GPIODV_27    76
+#define	GPIODV_28    77
+#define	GPIODV_29    78
+
+#define	GPIOX_0    79
+#define	GPIOX_1    80
+#define	GPIOX_2    81
+#define	GPIOX_3    82
+#define	GPIOX_4    83
+#define	GPIOX_5    84
+#define	GPIOX_6    85
+#define	GPIOX_7    86
+#define	GPIOX_8    87
+#define	GPIOX_9    88
+#define	GPIOX_10    89
+#define	GPIOX_11    90
+#define	GPIOX_12    91
+#define	GPIOX_13    92
+#define	GPIOX_14    93
+#define	GPIOX_15    94
+#define	GPIOX_16    95
+#define	GPIOX_17    96
+#define	GPIOX_18    97
+
+#define	GPIOCLK_0    98
+#define	GPIOCLK_1    99
+
+#define	GPIO_TEST_N    100
+
+
+
+#define EE_OFFSET 10
+
+#define	PIN_GPIOZ_0    (EE_OFFSET + GPIOZ_0)
+#define	PIN_GPIOZ_1    (EE_OFFSET + GPIOZ_1)
+#define	PIN_GPIOZ_2    (EE_OFFSET + GPIOZ_2)
+#define	PIN_GPIOZ_3    (EE_OFFSET + GPIOZ_3)
+#define	PIN_GPIOZ_4    (EE_OFFSET + GPIOZ_4)
+#define	PIN_GPIOZ_5    (EE_OFFSET + GPIOZ_5)
+#define	PIN_GPIOZ_6    (EE_OFFSET + GPIOZ_6)
+#define	PIN_GPIOZ_7    (EE_OFFSET + GPIOZ_7)
+#define	PIN_GPIOZ_8    (EE_OFFSET + GPIOZ_8)
+#define	PIN_GPIOZ_9    (EE_OFFSET + GPIOZ_9)
+#define	PIN_GPIOZ_10    (EE_OFFSET + GPIOZ_10)
+#define	PIN_GPIOZ_11    (EE_OFFSET + GPIOZ_11)
+#define	PIN_GPIOZ_12    (EE_OFFSET + GPIOZ_12)
+#define	PIN_GPIOZ_13    (EE_OFFSET + GPIOZ_13)
+#define	PIN_GPIOZ_14    (EE_OFFSET + GPIOZ_14)
+#define	PIN_GPIOZ_15    (EE_OFFSET + GPIOZ_15)
+#define	PIN_GPIOH_0    (EE_OFFSET + GPIOH_0)
+#define	PIN_GPIOH_1    (EE_OFFSET + GPIOH_1)
+#define	PIN_GPIOH_2    (EE_OFFSET + GPIOH_2)
+#define	PIN_GPIOH_3    (EE_OFFSET + GPIOH_3)
+#define	PIN_GPIOH_4    (EE_OFFSET + GPIOH_4)
+#define	PIN_GPIOH_5    (EE_OFFSET + GPIOH_5)
+#define	PIN_GPIOH_6    (EE_OFFSET + GPIOH_6)
+#define	PIN_GPIOH_7    (EE_OFFSET + GPIOH_7)
+#define	PIN_GPIOH_8    (EE_OFFSET + GPIOH_8)
+#define	PIN_GPIOH_9    (EE_OFFSET + GPIOH_9)
+#define	PIN_BOOT_0    (EE_OFFSET + BOOT_0)
+#define	PIN_BOOT_1    (EE_OFFSET + BOOT_1)
+#define	PIN_BOOT_2    (EE_OFFSET + BOOT_2)
+#define	PIN_BOOT_3    (EE_OFFSET + BOOT_3)
+#define	PIN_BOOT_4    (EE_OFFSET + BOOT_4)
+#define	PIN_BOOT_5    (EE_OFFSET + BOOT_5)
+#define	PIN_BOOT_6    (EE_OFFSET + BOOT_6)
+#define	PIN_BOOT_7    (EE_OFFSET + BOOT_7)
+#define	PIN_BOOT_8    (EE_OFFSET + BOOT_8)
+#define	PIN_BOOT_9    (EE_OFFSET + BOOT_9)
+#define	PIN_BOOT_10    (EE_OFFSET + BOOT_10)
+#define	PIN_BOOT_11    (EE_OFFSET + BOOT_11)
+#define	PIN_BOOT_12    (EE_OFFSET + BOOT_12)
+#define	PIN_BOOT_13    (EE_OFFSET + BOOT_13)
+#define	PIN_BOOT_14    (EE_OFFSET + BOOT_14)
+#define	PIN_BOOT_15    (EE_OFFSET + BOOT_15)
+#define	PIN_CARD_0    (EE_OFFSET + CARD_0)
+#define	PIN_CARD_1    (EE_OFFSET + CARD_1)
+#define	PIN_CARD_2    (EE_OFFSET + CARD_2)
+#define	PIN_CARD_3    (EE_OFFSET + CARD_3)
+#define	PIN_CARD_4    (EE_OFFSET + CARD_4)
+#define	PIN_CARD_5    (EE_OFFSET + CARD_5)
+#define	PIN_CARD_6    (EE_OFFSET + CARD_6)
+#define	PIN_GPIODV_0    (EE_OFFSET + GPIODV_0)
+#define	PIN_GPIODV_1    (EE_OFFSET + GPIODV_1)
+#define	PIN_GPIODV_2    (EE_OFFSET + GPIODV_2)
+#define	PIN_GPIODV_3    (EE_OFFSET + GPIODV_3)
+#define	PIN_GPIODV_4    (EE_OFFSET + GPIODV_4)
+#define	PIN_GPIODV_5    (EE_OFFSET + GPIODV_5)
+#define	PIN_GPIODV_6    (EE_OFFSET + GPIODV_6)
+#define	PIN_GPIODV_7    (EE_OFFSET + GPIODV_7)
+#define	PIN_GPIODV_8    (EE_OFFSET + GPIODV_8)
+#define	PIN_GPIODV_9    (EE_OFFSET + GPIODV_9)
+#define	PIN_GPIODV_10    (EE_OFFSET + GPIODV_10)
+#define	PIN_GPIODV_11    (EE_OFFSET + GPIODV_11)
+#define	PIN_GPIODV_12    (EE_OFFSET + GPIODV_12)
+#define	PIN_GPIODV_13    (EE_OFFSET + GPIODV_13)
+#define	PIN_GPIODV_14    (EE_OFFSET + GPIODV_14)
+#define	PIN_GPIODV_15    (EE_OFFSET + GPIODV_15)
+#define	PIN_GPIODV_16    (EE_OFFSET + GPIODV_16)
+#define	PIN_GPIODV_17    (EE_OFFSET + GPIODV_17)
+#define	PIN_GPIODV_18    (EE_OFFSET + GPIODV_18)
+#define	PIN_GPIODV_19    (EE_OFFSET + GPIODV_19)
+#define	PIN_GPIODV_20    (EE_OFFSET + GPIODV_20)
+#define	PIN_GPIODV_21    (EE_OFFSET + GPIODV_21)
+#define	PIN_GPIODV_22    (EE_OFFSET + GPIODV_22)
+#define	PIN_GPIODV_23    (EE_OFFSET + GPIODV_23)
+#define	PIN_GPIODV_24    (EE_OFFSET + GPIODV_24)
+#define	PIN_GPIODV_25    (EE_OFFSET + GPIODV_25)
+#define	PIN_GPIODV_26    (EE_OFFSET + GPIODV_26)
+#define	PIN_GPIODV_27    (EE_OFFSET + GPIODV_27)
+#define	PIN_GPIODV_28    (EE_OFFSET + GPIODV_28)
+#define	PIN_GPIODV_29    (EE_OFFSET + GPIODV_29)
+#define	PIN_GPIOX_0    (EE_OFFSET + GPIOX_0)
+#define	PIN_GPIOX_1    (EE_OFFSET + GPIOX_1)
+#define	PIN_GPIOX_2    (EE_OFFSET + GPIOX_2)
+#define	PIN_GPIOX_3    (EE_OFFSET + GPIOX_3)
+#define	PIN_GPIOX_4    (EE_OFFSET + GPIOX_4)
+#define	PIN_GPIOX_5    (EE_OFFSET + GPIOX_5)
+#define	PIN_GPIOX_6    (EE_OFFSET + GPIOX_6)
+#define	PIN_GPIOX_7    (EE_OFFSET + GPIOX_7)
+#define	PIN_GPIOX_8    (EE_OFFSET + GPIOX_8)
+#define	PIN_GPIOX_9    (EE_OFFSET + GPIOX_9)
+#define	PIN_GPIOX_10    (EE_OFFSET + GPIOX_10)
+#define	PIN_GPIOX_11    (EE_OFFSET + GPIOX_11)
+#define	PIN_GPIOX_12    (EE_OFFSET + GPIOX_12)
+#define	PIN_GPIOX_13    (EE_OFFSET + GPIOX_13)
+#define	PIN_GPIOX_14    (EE_OFFSET + GPIOX_14)
+#define	PIN_GPIOX_15    (EE_OFFSET + GPIOX_15)
+#define	PIN_GPIOX_16    (EE_OFFSET + GPIOX_16)
+#define	PIN_GPIOX_17    (EE_OFFSET + GPIOX_17)
+#define	PIN_GPIOX_18    (EE_OFFSET + GPIOX_18)
+#define	PIN_GPIOCLK_0    (EE_OFFSET + GPIOCLK_0)
+#define	PIN_GPIOCLK_1    (EE_OFFSET + GPIOCLK_1)
+
+#define	PIN_GPIO_TEST_N    (EE_OFFSET + GPIO_TEST_N)
+#endif
diff --git a/arch/arm/include/asm/arch-txl/i2c.h b/arch/arm/include/asm/arch-txl/i2c.h
new file mode 100644
index 0000000..b45e305
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/i2c.h
@@ -0,0 +1,310 @@
+
+/*
+ * arch/arm/include/asm/arch-gxtvbb/i2c.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __AML_MACH_I2C__
+#define __AML_MACH_I2C__
+
+#include <asm/io.h>
+
+/**
+ * struct i2c_msg - an I2C transaction segment beginning with START
+ * @addr: Slave address, either seven or ten bits.  When this is a ten
+ *	bit address, I2C_M_TEN must be set in @flags and the adapter
+ *	must support I2C_FUNC_10BIT_ADDR.
+ * @flags: I2C_M_RD is handled by all adapters.  No other flags may be
+ *	provided unless the adapter exported the relevant I2C_FUNC_*
+ *	flags through i2c_check_functionality().
+ * @len: Number of data bytes in @buf being read from or written to the
+ *	I2C slave address.  For read transactions where I2C_M_RECV_LEN
+ *	is set, the caller guarantees that this buffer can hold up to
+ *	32 bytes in addition to the initial length byte sent by the
+ *	slave (plus, if used, the SMBus PEC); and this value will be
+ *	incremented by the number of block data bytes received.
+ * @buf: The buffer into which data is read, or from which it's written.
+ *
+ * An i2c_msg is the low level representation of one segment of an I2C
+ * transaction.  It is visible to drivers in the @i2c_transfer() procedure,
+ * to userspace from i2c-dev, and to I2C adapter drivers through the
+ * @i2c_adapter.@master_xfer() method.
+ *
+ * Except when I2C "protocol mangling" is used, all I2C adapters implement
+ * the standard rules for I2C transactions.  Each transaction begins with a
+ * START.  That is followed by the slave address, and a bit encoding read
+ * versus write.  Then follow all the data bytes, possibly including a byte
+ * with SMBus PEC.  The transfer terminates with a NAK, or when all those
+ * bytes have been transferred and ACKed.  If this is the last message in a
+ * group, it is followed by a STOP.  Otherwise it is followed by the next
+ * @i2c_msg transaction segment, beginning with a (repeated) START.
+ *
+ * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then
+ * passing certain @flags may have changed those standard protocol behaviors.
+ * Those flags are only for use with broken/nonconforming slaves, and with
+ * adapters which are known to support the specific mangling options they
+ * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).
+ */
+struct i2c_msg {
+	__u16 addr;	/* slave address			*/
+	__u16 flags;
+#define I2C_M_TEN		0x0010	/* this is a ten bit chip address */
+#define I2C_M_RD		0x0001	/* read data, from slave to master */
+#define I2C_M_NOSTART		0x4000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_REV_DIR_ADDR	0x2000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
+	__u16 len;		/* msg length				*/
+	__u8 *buf;		/* pointer to msg data			*/
+};
+
+#define I2C_M_0_CONTROL_REG                        0x2140
+
+/*#define I2C_M_0_SLAVE_ADDR                         0x2141
+#define I2C_M_0_TOKEN_LIST0                        0x2142
+#define I2C_M_0_TOKEN_LIST1                        0x2143
+#define I2C_M_0_WDATA_REG0                         0x2144
+#define I2C_M_0_WDATA_REG1                         0x2145
+#define I2C_M_0_RDATA_REG0                         0x2146
+#define I2C_M_0_RDATA_REG1                         0x2147
+*/
+#define I2C_S_CONTROL_REG                          0x2150
+#define I2C_M_1_CONTROL_REG                        0x21f0
+#define I2C_M_2_CONTROL_REG 					   0x21f8
+#define I2C_M_3_CONTROL_REG                        0x2348
+
+#define MESON_I2C_MASTER_AO_START	(0xc8100500)
+#define MESON_I2C_MASTER_AO_END		(0xc810051c+5)
+
+#define MESON_I2C_MASTER_A_START	CBUS_REG_ADDR(I2C_M_0_CONTROL_REG)
+#define MESON_I2C_MASTER_A_END		(CBUS_REG_ADDR(I2C_M_0_RDATA_REG1+1)-1)
+
+#define MESON_I2C_MASTER_B_START	CBUS_REG_ADDR(I2C_M_1_CONTROL_REG)
+#define MESON_I2C_MASTER_B_END		(CBUS_REG_ADDR(I2C_M_1_RDATA_REG1+1)-1)
+
+#define MESON_I2C_MASTER_C_START	CBUS_REG_ADDR(I2C_M_2_CONTROL_REG)
+#define MESON_I2C_MASTER_C_END		(CBUS_REG_ADDR(I2C_M_2_RDATA_REG1+1)-1)
+
+#define MESON_I2C_MASTER_D_START	CBUS_REG_ADDR(I2C_M_3_CONTROL_REG)
+#define MESON_I2C_MASTER_D_END		(CBUS_REG_ADDR(I2C_M_3_RDATA_REG1+1)-1)
+
+#define MESON_I2C_SLAVE_START		CBUS_REG_ADDR(I2C_S_CONTROL_REG)
+#define MESON_I2C_SLAVE_END			(CBUS_REG_ADDR(I2C_S_CNTL1_REG+1)-1)
+
+
+#define AML_I2C_MASTER_AO			0
+#define AML_I2C_MASTER_A			1
+#define AML_I2C_MASTER_B 			2
+#define AML_I2C_MASTER_C 			3
+#define AML_I2C_MASTER_D 			4
+
+
+#define AML_I2C_SLAVE_ADDR			0x6c
+
+/*M1 i2c pinmux
+ *       I/O			I2C_MASTER_A		I2C_MASTER_B		I2C_SLAVE
+ * GPIO_JTAG_TMS	SCK_A REG1[12]							SCK_A REG1[13]
+ * GPIO_JTAG_TDI		SDA_A REG1[12]							SDA_A REG1[13]
+ * GPIO_JTAG_TCK						SCK_B REG1[16]		SCK_A REG1[17]
+ * GPIO_JTAG_TDO						SDA_B REG1[20]		SDA_A REG1[21]
+ * GPIOB_0								SCK_B REG2[5]		SCK_A REG2[6]
+ * GPIOB_1								SDA_B REG2[2]		SDA_A REG2[3]
+ * GPIOB_2			SCK_A REGS[13]							SCK_A REG2[14]
+ * GPIOB_3			SDA_A REG2[9]							SDA_A REG2[10]
+ * GPIOC_13								SCK_B REG3[28]		SCK_A REG3[29]
+ * GPIOC_14								SDA_B REG3[25]		SDA_A REG3[26]
+ * GPIOC_21			SCK_A REG7[9]							SCK_A REG7[10]
+ * GPIOC_22			SDA_A REG7[6]							SDA_A REG7[7]
+ * GPIOE_16								SCK_B REG5[27]		SCK_A REG5[28]
+ * GPIOE_17								SDA_B REG5[25]		SDA_A REG5[26]
+*/
+
+/*i2c master a*/
+
+
+#define MESON_I2C_MASTER_A_GPIOZ_17_REG		(PERIPHS_PIN_MUX_9)
+#define MESON_I2C_MASTER_A_GPIOZ_17_BIT		(1<<7)
+#define MESON_I2C_MASTER_A_GPIOZ_18_REG		(PERIPHS_PIN_MUX_9)
+#define MESON_I2C_MASTER_A_GPIOZ_18_BIT		(1<<8)
+
+#define MESON_I2C_MASTER_A_GPIOW_0_REG		(PERIPHS_PIN_MUX_5)
+#define MESON_I2C_MASTER_A_GPIOW_0_BIT		(1<<22)
+#define MESON_I2C_MASTER_A_GPIOW_1_REG		(PERIPHS_PIN_MUX_5)
+#define MESON_I2C_MASTER_A_GPIOW_1_BIT		(1<<23)
+
+/*i2c master b*/
+
+
+#define MESON_I2C_MASTER_B_GPIOH_3_REG		(PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_B_GPIOH_3_BIT		(1<<6)
+#define MESON_I2C_MASTER_B_GPIOH_4_REG		(PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_B_GPIOH_4_BIT		(1<<7)
+
+#define MESON_I2C_MASTER_B_GPIOY_12_REG		(PERIPHS_PIN_MUX_10)
+#define MESON_I2C_MASTER_B_GPIOY_12_BIT		(1<<14)
+#define MESON_I2C_MASTER_B_GPIOY_13_REG		(PERIPHS_PIN_MUX_10)
+#define MESON_I2C_MASTER_B_GPIOY_13_BIT		(1<<15)
+
+/*i2c master c*/
+#define MESON_I2C_MASTER_C_GPIOY_7_REG		(PERIPHS_PIN_MUX_4)
+#define MESON_I2C_MASTER_C_GPIOY_7_BIT		(1<<28)
+#define MESON_I2C_MASTER_C_GPIOY_8_REG		(PERIPHS_PIN_MUX_4)
+#define MESON_I2C_MASTER_C_GPIOY_8_BIT		(1<<29)
+
+#define MESON_I2C_MASTER_C_GPIOX_0_REG		(PERIPHS_PIN_MUX_1)
+#define MESON_I2C_MASTER_C_GPIOX_0_BIT		(1<<22)
+#define MESON_I2C_MASTER_C_GPIOX_1_REG		(PERIPHS_PIN_MUX_1)
+#define MESON_I2C_MASTER_C_GPIOX_1_BIT		(1<<23)
+
+/*i2c master d*/
+
+
+#define MESON_I2C_MASTER_D_GPIOY_10_REG		(PERIPHS_PIN_MUX_10)
+#define MESON_I2C_MASTER_D_GPIOY_10_BIT		(1<<10)
+#define MESON_I2C_MASTER_D_GPIOY_11_REG		(PERIPHS_PIN_MUX_10)
+#define MESON_I2C_MASTER_D_GPIOY_11_BIT		(1<<11)
+
+#define MESON_I2C_MASTER_D_GPIOH_5_REG		(PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_D_GPIOH_5_BIT		(1<<23)
+#define MESON_I2C_MASTER_D_GPIOH_6_REG		(PERIPHS_PIN_MUX_7)
+#define MESON_I2C_MASTER_D_GPIOH_6_BIT		(1<<24)
+
+/*i2c master AO*/
+
+
+#define MESON_I2C_MASTER_AO_GPIOAO_4_REG	(P_AO_RTI_PIN_MUX_REG)
+#define MESON_I2C_MASTER_AO_GPIOAO_4_BIT	(1<<8)
+#define MESON_I2C_MASTER_AO_GPIOAO_5_REG	(P_AO_RTI_PIN_MUX_REG)
+#define MESON_I2C_MASTER_AO_GPIOAO_5_BIT	(1<<9)
+
+/*i2c slave*/
+#define MESON_I2C_SLAVE_JTAG_TMS_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_1)
+#define MESON_I2C_SLAVE_JTAG_TMS_BIT			(1<<13)
+#define MESON_I2C_SLAVE_JTAG_TDI_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_1)
+#define MESON_I2C_SLAVE_JTAG_TDI_BIT			(1<<13)
+
+#define MESON_I2C_SLAVE_GPIOB_2_REG  			CBUS_REG_ADDR(PERIPHS_PIN_MUX_2)
+#define MESON_I2C_SLAVE_GPIOB_2_BIT  			(1<<14)
+#define MESON_I2C_SLAVE_GPIOB_3_REG  			CBUS_REG_ADDR(PERIPHS_PIN_MUX_2)
+#define MESON_I2C_SLAVE_GPIOB_3_BIT  			(1<<10)
+
+#define MESON_I2C_SLAVE_GPIOC_21_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_7)
+#define MESON_I2C_SLAVE_GPIOC_21_BIT			(1<<10)
+#define MESON_I2C_SLAVE_GPIOC_22_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_7)
+#define MESON_I2C_SLAVE_GPIOC_22_BIT			(1<<7)
+
+#define MESON_I2C_SLAVE_JTAG_TCK_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_1)
+#define MESON_I2C_SLAVE_JTAG_TCK_BIT			(1<<17)
+#define MESON_I2C_SLAVE_JTAG_TDO_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_1)
+#define MESON_I2C_SLAVE_JTAG_TDO_BIT			(1<<21)
+
+#define MESON_I2C_SLAVE_GPIOB_0_REG  			CBUS_REG_ADDR(PERIPHS_PIN_MUX_2)
+#define MESON_I2C_SLAVE_GPIOB_0_BIT  			(1<<6)
+#define MESON_I2C_SLAVE_GPIOB_1_REG  			CBUS_REG_ADDR(PERIPHS_PIN_MUX_2)
+#define MESON_I2C_SLAVE_GPIOB_1_BIT  			(1<<3)
+
+#define MESON_I2C_SLAVE_GPIOC_13_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_3)
+#define MESON_I2C_SLAVE_GPIOC_13_BIT			(1<<29)
+#define MESON_I2C_SLAVE_GPIOC_14_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_3)
+#define MESON_I2C_SLAVE_GPIOC_14_BIT			(1<<26)
+
+#define MESON_I2C_SLAVE_GPIOC_16_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define MESON_I2C_SLAVE_GPIOC_16_BIT			(1<<28)
+#define MESON_I2C_SLAVE_GPIOC_17_REG			CBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define MESON_I2C_SLAVE_GPIOC_17_BIT			(1<<26)
+
+
+#define AML_I2C_SPPED_50K			50000
+#define AML_I2C_SPPED_100K			100000
+#define AML_I2C_SPPED_200K			200000
+#define AML_I2C_SPPED_300K			300000
+#define AML_I2C_SPPED_400K			400000
+
+struct aml_pinmux_reg_bit {
+	unsigned long	scl_reg;
+	unsigned long	sda_reg;
+	unsigned int  scl_bit;
+	unsigned int  sda_bit;
+};
+
+struct aml_i2c_platform{
+	unsigned int		slave_addr;/*7bit addr*/
+	unsigned int 		wait_count;/*i2c wait ack timeout =
+											wait_count * wait_ack_interval */
+	unsigned int 		wait_ack_interval;
+	unsigned int 		wait_read_interval;
+	unsigned int 		wait_xfer_interval;
+	unsigned int 		master_no;
+	unsigned int		use_pio;/*0: hardware i2c, 1: manual pio i2c*/
+	unsigned int		master_i2c_speed;
+
+	/* only need 1 i2c master to comunicate with several devices,
+	  * should I prepare 2 master interface to use simultaneously?*/
+	struct resource	* resource;
+	struct aml_pinmux_reg_bit master_ao_pinmux;
+	struct aml_pinmux_reg_bit master_a_pinmux;
+	struct aml_pinmux_reg_bit master_b_pinmux;
+	struct aml_pinmux_reg_bit master_c_pinmux;
+	struct aml_pinmux_reg_bit master_d_pinmux;
+
+	struct aml_pinmux_reg_bit slave_reg_bit;
+};
+
+/**************i2c software gpio***************/
+
+#define MESON_I2C_PREG_GPIOC_OE			CBUS_REG_ADDR(PREG_FGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOC_OUTLVL		CBUS_REG_ADDR(PREG_FGPIO_O)
+#define MESON_I2C_PREG_GPIOC_INLVL		CBUS_REG_ADDR(PREG_FGPIO_I)
+
+#define MESON_I2C_PREG_GPIOE_OE			CBUS_REG_ADDR(PREG_HGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOE_OUTLVL		CBUS_REG_ADDR(PREG_HGPIO_O)
+#define MESON_I2C_PREG_GPIOE_INLVL		CBUS_REG_ADDR(PREG_HGPIO_I)
+
+#define MESON_I2C_PREG_GPIOA_OE			CBUS_REG_ADDR(PREG_EGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOA_OUTLVL		CBUS_REG_ADDR(PREG_EGPIO_O)
+#define MESON_I2C_PREG_GPIOA_INLVL		CBUS_REG_ADDR(PREG_EGPIO_I)
+
+struct aml_sw_i2c_pins
+{
+	unsigned int scl_reg_out;
+	unsigned int scl_reg_in;
+	unsigned int scl_bit;
+	unsigned int scl_oe;
+	unsigned int sda_reg_out;
+	unsigned int sda_reg_in;
+	unsigned int sda_bit;
+	unsigned int sda_oe;
+};
+
+
+struct aml_sw_i2c_platform {
+	struct aml_sw_i2c_pins sw_pins;
+
+	/* local settings */
+	int udelay;		/* half clock cycle time in us,
+				   minimum 2 us for fast-mode I2C,
+				   minimum 5 us for standard-mode I2C and SMBus,
+				   maximum 50 us for SMBus */
+	int timeout;		/* in jiffies */
+};
+
+
+#endif //__AML_MACH_I2C__
+
+
diff --git a/arch/arm/include/asm/arch-txl/io.h b/arch/arm/include/asm/arch-txl/io.h
new file mode 100644
index 0000000..4ff9a11
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/io.h
@@ -0,0 +1,124 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/io.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __MACH_MESSON_REGS_IO_H
+#define __MACH_MESSON_REGS_IO_H
+
+#ifndef __ASSEMBLY__
+
+#include <asm/io.h>
+#define IO_CBUS_BASE			0xc1100000L
+#define IO_AXI_BUS_BASE			0xc1300000L
+#define IO_AHB_BUS_BASE			0xc9000000L
+#define IO_APB_BUS_BASE			0xc8000000L
+#define IO_APB_HDMI_BUS_BASE    0xd0040000L
+#define IO_VPU_BUS_BASE			0xd0100000L
+
+#define MESON_PERIPHS1_VIRT_BASE	0xc1108400L
+#define MESON_PERIPHS1_PHYS_BASE	0xc1108400L
+
+#define MESON_PERIPHS1_VIRT_BASE	0xc1108400L
+#define MESON_PERIPHS1_PHYS_BASE	0xc1108400L
+
+#define CBUS_REG_OFFSET(reg) ((reg) << 2)
+#define CBUS_REG_ADDR(reg)	 (IO_CBUS_BASE + CBUS_REG_OFFSET(reg))
+
+#define AXI_REG_OFFSET(reg)  ((reg) << 2)
+#define AXI_REG_ADDR(reg)	 (IO_AXI_BUS_BASE + AXI_REG_OFFSET(reg))
+
+#define AHB_REG_OFFSET(reg)  ((reg) << 2)
+#define AHB_REG_ADDR(reg)	 (IO_AHB_BUS_BASE + AHB_REG_OFFSET(reg))
+
+#define VPU_REG_OFFSET(reg)  ((reg) << 2)
+#define VPU_REG_ADDR(reg)	 (IO_VPU_BUS_BASE + VPU_REG_OFFSET(reg))
+
+
+#define APB_REG_OFFSET(reg)  (reg)
+#define APB_REG_ADDR(reg)	 (IO_APB_BUS_BASE + APB_REG_OFFSET(reg))
+#define APB_REG_ADDR_VALID(reg) (((unsigned long)(reg) & 3) == 0)
+
+#define APB_HDMI_REG_OFFSET(reg)  (reg)
+#define APB_HDMI_REG_ADDR(reg)	 (IO_APB_HDMI_BUS_BASE + APB_HDMI_REG_OFFSET(reg))
+#define APB_HDMI_REG_ADDR_VALID(reg) (((unsigned long)(reg) & 3) == 0)
+
+
+#define WRITE_CBUS_REG(reg, val) __raw_writel(val, CBUS_REG_ADDR(reg))
+#define READ_CBUS_REG(reg) (__raw_readl(CBUS_REG_ADDR(reg)))
+#define WRITE_CBUS_REG_BITS(reg, val, start, len) \
+    WRITE_CBUS_REG(reg,	(READ_CBUS_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_CBUS_REG_BITS(reg, start, len) \
+    ((READ_CBUS_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_CBUS_REG_MASK(reg, mask) WRITE_CBUS_REG(reg, (READ_CBUS_REG(reg)&(~(mask))))
+#define SET_CBUS_REG_MASK(reg, mask)   WRITE_CBUS_REG(reg, (READ_CBUS_REG(reg)|(mask)))
+
+#define WRITE_AXI_REG(reg, val) __raw_writel(val, AXI_REG_ADDR(reg))
+#define READ_AXI_REG(reg) (__raw_readl(AXI_REG_ADDR(reg)))
+#define WRITE_AXI_REG_BITS(reg, val, start, len) \
+    WRITE_AXI_REG(reg,	(READ_AXI_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_AXI_REG_BITS(reg, start, len) \
+    ((READ_AXI_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_AXI_REG_MASK(reg, mask) WRITE_AXI_REG(reg, (READ_AXI_REG(reg)&(~(mask))))
+#define SET_AXI_REG_MASK(reg, mask)   WRITE_AXI_REG(reg, (READ_AXI_REG(reg)|(mask)))
+
+#define WRITE_AHB_REG(reg, val) __raw_writel(val, AHB_REG_ADDR(reg))
+#define READ_AHB_REG(reg) (__raw_readl(AHB_REG_ADDR(reg)))
+#define WRITE_AHB_REG_BITS(reg, val, start, len) \
+    WRITE_AHB_REG(reg,	(READ_AHB_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_AHB_REG_BITS(reg, start, len) \
+    ((READ_AHB_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_AHB_REG_MASK(reg, mask) WRITE_AHB_REG(reg, (READ_AHB_REG(reg)&(~(mask))))
+#define SET_AHB_REG_MASK(reg, mask)   WRITE_AHB_REG(reg, (READ_AHB_REG(reg)|(mask)))
+
+#define WRITE_APB_REG(reg, val) __raw_writel(val, APB_REG_ADDR(reg))
+#define READ_APB_REG(reg) (__raw_readl(APB_REG_ADDR(reg)))
+#define WRITE_APB_REG_BITS(reg, val, start, len) \
+    WRITE_APB_REG(reg,	(READ_APB_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_APB_REG_BITS(reg, start, len) \
+    ((READ_APB_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_APB_REG_MASK(reg, mask) WRITE_APB_REG(reg, (READ_APB_REG(reg)&(~(mask))))
+#define SET_APB_REG_MASK(reg, mask)   WRITE_APB_REG(reg, (READ_APB_REG(reg)|(mask)))
+
+#define WRITE_APB_HDMI_REG(reg, val) __raw_writel(val, APB_HDMI_REG_ADDR(reg))
+#define READ_APB_HDMI_REG(reg) (__raw_readl(APB_HDMI_REG_ADDR(reg)))
+#define WRITE_APB_HDMI_REG_BITS(reg, val, start, len) \
+    WRITE_APB_HDMI_REG(reg,	(READ_APB_HDMI_REG(reg) & ~(((1L<<(len))-1)<<(start)) )| ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define READ_APB_HDMI_REG_BITS(reg, start, len) \
+    ((READ_APB_HDMI_REG(reg) >> (start)) & ((1L<<(len))-1))
+#define CLEAR_APB_HDMI_REG_MASK(reg, mask) WRITE_APB_HDMI_REG(reg, (READ_APB_HDMI_REG(reg)&(~(mask))))
+#define SET_APB_HDMI_REG_MASK(reg, mask)   WRITE_APB_HDMI_REG(reg, (READ_APB_HDMI_REG(reg)|(mask)))
+
+/* for back compatible alias */
+#define WRITE_MPEG_REG(reg, val) \
+	WRITE_CBUS_REG(reg, val)
+#define READ_MPEG_REG(reg) \
+	READ_CBUS_REG(reg)
+#define WRITE_MPEG_REG_BITS(reg, val, start, len) \
+	WRITE_CBUS_REG_BITS(reg, val, start, len)
+#define READ_MPEG_REG_BITS(reg, start, len) \
+	READ_CBUS_REG_BITS(reg, start, len)
+#define CLEAR_MPEG_REG_MASK(reg, mask) \
+	CLEAR_CBUS_REG_MASK(reg, mask)
+#define SET_MPEG_REG_MASK(reg, mask) \
+	SET_CBUS_REG_MASK(reg, mask)
+#endif
+
+
+#endif
diff --git a/arch/arm/include/asm/arch-txl/mailbox.h b/arch/arm/include/asm/arch-txl/mailbox.h
new file mode 100644
index 0000000..165cde3
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/mailbox.h
@@ -0,0 +1,79 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/mailbox.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+ /*
+  *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *
+ */
+
+#ifndef __GXBB_MAILBOX_H_
+#define __GXBB_MAILBOX_H_
+
+#define SCPI_CMD_SENSOR_VALUE 0x1C
+#define SCPI_CMD_SET_USR_DATA 0x20
+#define SCPI_CMD_OPEN_SCP_LOG 0xC4
+#define SCPI_CMD_THERMAL_CALIB 0xC5
+
+#define LOW_PRIORITY	0
+#define HIGH_PRIORITY 1
+
+#define P_SHARE_SRAM_BASE    0xc8000000
+#define MHU_HIGH_SCP_TO_AP_PAYLOAD		0x13400
+#define MHU_HIGH_AP_TO_SCP_PAYLOAD		0x13600
+#define MHU_LOW_SCP_TO_AP_PAYLOAD		0x13000
+#define MHU_LOW_AP_TO_SCP_PAYLOAD		0x13200
+
+enum scpi_client_id {
+	SCPI_CL_NONE,
+	SCPI_CL_CLOCKS,
+	SCPI_CL_DVFS,
+	SCPI_CL_POWER,
+	SCPI_CL_THERMAL,
+	SCPI_CL_REMOTE,
+	SCPI_CL_LED_TIMER,
+	SCPI_MAX = 0xff,
+};
+
+enum scpi_error_codes {
+	SCPI_SUCCESS = 0, /* Success */
+	SCPI_ERR_PARAM = 1, /* Invalid parameter(s) */
+	SCPI_ERR_ALIGN = 2, /* Invalid alignment */
+	SCPI_ERR_SIZE = 3, /* Invalid size */
+	SCPI_ERR_HANDLER = 4, /* Invalid handler/callback */
+	SCPI_ERR_ACCESS = 5, /* Invalid access/permission denied */
+	SCPI_ERR_RANGE = 6, /* Value out of range */
+	SCPI_ERR_TIMEOUT = 7, /* Timeout has occurred */
+	SCPI_ERR_NOMEM = 8, /* Invalid memory area or pointer */
+	SCPI_ERR_PWRSTATE = 9, /* Invalid power state */
+	SCPI_ERR_SUPPORT = 10, /* Not supported or disabled */
+	SCPI_ERR_DEVICE = 11, /* Device error */
+	SCPI_ERR_MAX
+};
+
+void open_scp_log(unsigned int channel);
+int thermal_calibration(unsigned int type, unsigned int data);
+int thermal_get_value(unsigned int sensor_id, unsigned int *value);
+int send_usr_data(unsigned int clinet_id, unsigned int *val, unsigned int size);
+
+ #endif
diff --git a/arch/arm/include/asm/arch-txl/nand.h b/arch/arm/include/asm/arch-txl/nand.h
new file mode 100644
index 0000000..8ab9f42
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/nand.h
@@ -0,0 +1,151 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/nand.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __NAND_H__
+#define __NAND_H__
+#include <asm/arch/cpu_config.h>
+
+#ifndef SD_EMMC_BASE_C
+#define SD_EMMC_BASE_C 0xd0074000
+#endif
+
+#define P_NAND_BASE (SD_EMMC_BASE_C | (1<<11))
+#define P_CLK_CNTL	(volatile uint32_t *)(SD_EMMC_BASE_C)
+#define P_NAND_CMD  (volatile uint32_t *)(P_NAND_BASE + 0x00)
+#define P_NAND_CFG  (volatile uint32_t *)(P_NAND_BASE + 0x04)
+#define P_NAND_DADR (volatile uint32_t *)(P_NAND_BASE + 0x08)
+#define P_NAND_IADR (volatile uint32_t *)(P_NAND_BASE + 0x0c)
+#define P_NAND_BUF  (volatile uint32_t *)(P_NAND_BASE + 0x10)
+#define P_NAND_INFO (volatile uint32_t *)(P_NAND_BASE + 0x14)
+#define P_NAND_DC   (volatile uint32_t *)(P_NAND_BASE + 0x18)
+#define P_NAND_ADR  (volatile uint32_t *)(P_NAND_BASE + 0x1c)
+#define P_NAND_DL   (volatile uint32_t *)(P_NAND_BASE + 0x20)
+#define P_NAND_DH   (volatile uint32_t *)(P_NAND_BASE + 0x24)
+#define P_NAND_CADR (volatile uint32_t *)(P_NAND_BASE + 0x28)
+#define P_NAND_SADR (volatile uint32_t *)(P_NAND_BASE + 0x2c)
+
+#define CEF (0xf<<10)
+#define CE0 (0xe<<10)
+#define CE1 (0xd<<10)
+#define CE2 (0xb<<10)
+#define CE3 (0x7<<10)
+
+#define IO4 ((0xe<<10)|(1<<18))
+#define IO5 ((0xd<<10)|(1<<18))
+#define IO6 ((0xb<<10)|(1<<18))
+
+#define CLE  (0x5<<14)
+#define ALE  (0x6<<14)
+#define DWR  (0x4<<14)
+#define DRD  (0x8<<14)
+#define IDLE (0xc<<14)
+#define RB   (1<<20)
+
+#define M2N  ((0<<17) | (2<<20) | (1<<19))
+#define N2M  ((1<<17) | (2<<20) | (1<<19))
+#define STS  ((3<<17) | (2<<20))
+#define ADL  ((0<<16) | (3<<20))
+#define ADH  ((1<<16) | (3<<20))
+#define AIL  ((2<<16) | (3<<20))
+#define AIH  ((3<<16) | (3<<20))
+#define ASL  ((4<<16) | (3<<20))
+#define ASH  ((5<<16) | (3<<20))
+#define SEED ((8<<16) | (3<<20))
+
+// NAND Flash Manufacturer ID Codes
+#define NAND_MFR_TOSHIBA	0x98
+#define NAND_MFR_SAMSUNG	0xec
+#define NAND_MFR_FUJITSU	0x04
+#define NAND_MFR_NATIONAL	0x8f
+#define NAND_MFR_RENESAS	0x07
+#define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX		0xad
+#define NAND_MFR_MICRON		0x2c
+#define NAND_MFR_AMD		0x01
+#define NAND_MFR_INTEL		0x89
+#define NAND_MFR_SANDISK    	0x45
+#define NAND_MFR_USER          0x100
+#define NAND_MFR_EFUSE         0x101
+
+typedef struct nand_setup {
+    union {
+        uint32_t d32;
+        struct {
+            unsigned cmd:22;
+            unsigned large_page:1; // 22
+            unsigned no_rb:1;      // 23 from efuse
+            unsigned a2:1;         // 24
+            unsigned reserved25:1; // 25
+            unsigned page_list:1;  // 26
+            unsigned sync_mode:2;  // 27 from efuse
+            unsigned size:2;       // 29 from efuse
+            unsigned active:1;     // 31
+        } b;
+    } cfg;
+    uint16_t id;
+    uint16_t max; // id:0x100 user, max:0 disable.
+} nand_setup_t;
+
+typedef struct _nand_cmd{
+    unsigned char type;
+    unsigned char val;
+} nand_cmd_t;
+
+typedef struct _ext_info{
+	uint32_t read_info;		//nand_read_info;
+	uint32_t new_type;		//new_nand_type;
+	uint32_t page_per_blk;	//pages_in_block;
+	uint32_t xlc;			//slc=1, mlc=2, tlc=3.
+	uint32_t rsv1[5];
+} ext_info_t;
+
+typedef struct _nand_page0 {
+	nand_setup_t nand_setup;		//8
+	unsigned char page_list[16]; 	//16
+	nand_cmd_t retry_usr[32];		//64 (32 cmd max I/F)
+	ext_info_t ext_info;			//64
+} nand_page0_t;	//384 bytes max.
+
+//#define NAND_PAGE0_BUF	  BL1_NAND_BUFF
+#define NAND_PAGE0_BUF  (0x1800000)
+#define NAND_PAGE_LIST	  (NAND_PAGE0_BUF + sizeof(nand_setup_t))
+#define NAND_RETRY_USER	  (NAND_PAGE_LIST + 16)
+#define NAND_INFO_BUF     (NAND_PAGE0_BUF + 512)
+#define DEFAULT_ECC_MODE  ((1<<23) |(1<<22) | (2<<20) |(1<<19) |(1<<17)|(7<<14)|(1<<13)|(48<<6)|1)
+//#define DEFAULT_ECC_MODE  ((1<<23) |(1<<22) | (2<<20) |(1<<19) |(1<<17)|(7<<14)|(1<<13)|(48<<6)|1)
+
+#define ERROR_MOD(mod,num) ((uint32_t)(((mod<<6)|num)))
+#define ERROR_NAND_TIMEOUT          ERROR_MOD(2,1)      //
+#define ERROR_NAND_ECC              ERROR_MOD(2,2)      //
+#define ERROR_NAND_MAGIC_WORD       ERROR_MOD(2,3)      //
+#define ERROR_NAND_INIT_READ        ERROR_MOD(2,4)      //
+#define ERROR_NAND_BLANK_PAGE       ERROR_MOD(2,5)      //
+#define ERROR_NAND_UNALIGN_SRC      ERROR_MOD(2,6)      //
+
+#define NAND_SECTOR_SIZE		(512)
+#define NAND_MAX_PAGESIZE		(0x4000)	//16K
+#define SRC_ALIGN_SIZE			(NAND_MAX_PAGESIZE)
+
+#define INFO_BYTE_PER_ECCPAGE	(8)
+uint32_t nfio_init(void);
+uint32_t nf_read(uint32_t boot_device, uint32_t src, uint32_t des, uint32_t size);
+#endif /* __NAND_H__ */
+
diff --git a/arch/arm/include/asm/arch-txl/reboot.h b/arch/arm/include/asm/arch-txl/reboot.h
new file mode 100644
index 0000000..83a98b8
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/reboot.h
@@ -0,0 +1,59 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/reboot.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __REBOOT_H
+#define __REBOOT_H
+
+/*
+Reboot reason AND corresponding env setting:
+0:  Cold boot                 cold_boot
+1:  Normal boot               normal
+2:  Factory reset             factory_reset
+3:  Upgrade system            update
+4:  USB Burning               usb_burning
+5:  Suspend                   suspend_off
+6:  Hibernate                 hibernate
+7~10: reserved
+11:  Crash dump               crash_dump
+12~15: reserved
+*/
+#define AMLOGIC_COLD_BOOT				0
+#define	AMLOGIC_NORMAL_BOOT				1
+#define	AMLOGIC_FACTORY_RESET_REBOOT	2
+#define	AMLOGIC_UPDATE_REBOOT			3
+#define AMLOGIC_USB_BURNING_REBOOT		4
+#define AMLOGIC_SUSPEND_REBOOT			5
+#define AMLOGIC_HIBERNATE_REBOOT		6
+#define	AMLOGIC_CRASH_REBOOT			11
+#define AMLOGIC_KERNEL_PANIC			12
+#define AMLOGIC_WATCHDOG_REBOOT			13
+
+/*
+old version env
+0x01010101, normal
+0x02020202, factory_reset
+0x03030303, update
+0x09090909, usb_burning
+0x0b0b0b0b, suspend_off
+*/
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-txl/register.h b/arch/arm/include/asm/arch-txl/register.h
new file mode 100644
index 0000000..6958b86
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/register.h
@@ -0,0 +1,99 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/register.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __REGISTER_H__
+#define __REGISTER_H__
+
+#define IO_CBUS_BASE			  0xc1100000
+#define IO_AXI_BUS_BASE			0xc1300000
+#define IO_AHB_BUS_BASE			0xc9000000
+#define IO_APB_BUS_BASE			0xc8000000
+#define IO_APB_HDMI_BUS_BASE    0xd0040000
+#define IO_VPU_BUS_BASE			0xd0100000
+
+#define CBUS_REG_OFFSET(reg) ((reg) << 2)
+#define CBUS_REG_ADDR(reg)	 (IO_CBUS_BASE + CBUS_REG_OFFSET(reg))
+
+/* below UART0,UART1,AO_UART is m8 addr,it is placed is for compiling pass */
+/* -------------------------------
+// UART0
+// ---------------------------- */
+#define UART0_WFIFO                                0x2130
+#define UART0_RFIFO                                0x2131
+#define UART0_CONTROL                              0x2132
+#define UART0_STATUS                               0x2133
+#define UART0_MISC                                 0x2134
+#define UART0_REG5                                 0x2135
+/* ----------------------------
+// UART1
+----------------------------*/
+#define UART1_WFIFO                                0x2137
+#define UART1_RFIFO                                0x2138
+#define UART1_CONTROL                              0x2139
+#define UART1_STATUS                               0x213a
+#define UART1_MISC                                 0x213b
+#define UART1_REG5                                 0x213c
+
+
+/* ------------------------------------------------------
+ The following are handled by $periphs/rtl/periphs_reg.v
+  ----------------------------------------              */
+#define PREG_CTLREG0_ADDR                          0x2000
+#define P_PREG_CTLREG0_ADDR CBUS_REG_ADDR(PREG_CTLREG0_ADDR)
+
+
+/* ----------------------------
+ clock measure (4)
+ ---------------------------- */
+#define MSR_CLK_DUTY                               0x21d6
+#define MSR_CLK_REG0                               0x21d7
+#define MSR_CLK_REG1                               0x21d8
+#define MSR_CLK_REG2                               0x21d9
+#define P_MSR_CLK_DUTY CBUS_REG_ADDR(MSR_CLK_DUTY)
+#define P_MSR_CLK_REG0 CBUS_REG_ADDR(MSR_CLK_REG0)
+#define P_MSR_CLK_REG1 CBUS_REG_ADDR(MSR_CLK_REG1)
+#define P_MSR_CLK_REG2 CBUS_REG_ADDR(MSR_CLK_REG2)
+
+
+
+/* --------------------------------
+ *  AO uart
+ * -------------------------------*/
+#define IO_AOBUS_BASE       0xc8100000  ///1M
+
+#define AOBUS_REG_OFFSET(reg)   ((reg) )
+#define AOBUS_REG_ADDR(reg)	    (IO_AOBUS_BASE + AOBUS_REG_OFFSET(reg))
+
+#define AO_UART_WFIFO ((0x01 << 10) | (0x30 << 2)) 	///../ucode/c_always_on_pointer.h:89
+#define P_AO_UART_WFIFO 		AOBUS_REG_ADDR(AO_UART_WFIFO)
+#define AO_UART_RFIFO ((0x01 << 10) | (0x31 << 2)) 	///../ucode/c_always_on_pointer.h:90
+#define P_AO_UART_RFIFO 		AOBUS_REG_ADDR(AO_UART_RFIFO)
+#define AO_UART_CONTROL ((0x01 << 10) | (0x32 << 2)) 	///../ucode/c_always_on_pointer.h:91
+#define P_AO_UART_CONTROL 		AOBUS_REG_ADDR(AO_UART_CONTROL)
+#define AO_UART_STATUS ((0x01 << 10) | (0x33 << 2)) 	///../ucode/c_always_on_pointer.h:92
+#define P_AO_UART_STATUS 		AOBUS_REG_ADDR(AO_UART_STATUS)
+#define AO_UART_MISC ((0x01 << 10) | (0x34 << 2)) 	///../ucode/c_always_on_pointer.h:93
+#define P_AO_UART_MISC 		AOBUS_REG_ADDR(AO_UART_MISC)
+#define AO_UART_REG5 ((0x01 << 10) | (0x35 << 2)) 	///../ucode/c_always_on_pointer.h:94
+#define P_AO_UART_REG5 		AOBUS_REG_ADDR(AO_UART_REG5)
+
+
+#endif //__REGISTER_H__
diff --git a/arch/arm/include/asm/arch-txl/romboot.h b/arch/arm/include/asm/arch-txl/romboot.h
new file mode 100644
index 0000000..ad28a94
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/romboot.h
@@ -0,0 +1,67 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/romboot.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __BOOT_ROM_H_
+#define __BOOT_ROM_H_
+#ifndef __ASSEMBLY__
+//#include <stdint.h>
+//uint8_t simple_i2c(uint8_t adr);
+//void spi_pin_mux(void);
+//void spi_init(void);
+//uint32_t spi_read(uint32_t src, uint32_t mem, uint32_t size);
+//void udelay(uint32_t usec);
+//void boot_des_decrypt(uint8_t *ct, uint8_t *pt, uint32_t size);
+
+#endif /* ! __ASSEMBLY__ */
+#include "config.h"
+
+/* Magic number to "boot" up A53 */
+#define AO_SEC_SD_CFG10_CB			0x80000000
+
+/*BOOT device and ddr size*/
+/*31-28: boot device id, 27-24: boot device para, 23-20: reserved*/
+/*19-8: ddr size, 7-0: board revision*/
+//#define P_AO_SEC_GP_CFG0                                     0xDA100240 //defined in secure_apb.h
+#define AO_SEC_GP_CFG7_W0_BIT			8
+#define AO_SEC_GP_CFG7_W0			0x100
+
+#define P_ISA_TIMERE                 (volatile uint32_t *)0xc1109988
+#define P_ASSIST_POR_CONFIG          (volatile uint32_t *)0xc1107d54
+
+#define P_RESET1_REGISTER	     (volatile uint32_t *)0xc1104408
+
+#define P_WATCHDOG_CNTL              (volatile uint32_t *)0xc11098d0
+#define P_WATCHDOG_CNTL1             (volatile uint32_t *)0xc11098d4
+#define P_WATCHDOG_TCNT              (volatile uint32_t *)0xc11098d8
+#define P_WATCHDOG_RESET             (volatile uint32_t *)0xc11098dc
+
+#define P_SPI_FLASH_CTRL             (volatile uint32_t *)0xc1108c88
+#define P_SPI_USER_REG               (volatile uint32_t *)0xc1108c9c
+#define P_SPI_START_ADDR             (volatile uint32_t *)0xCC000000
+
+#define BOOT_ID_RESERVED	0
+#define BOOT_ID_EMMC		1
+#define BOOT_ID_NAND		2
+#define BOOT_ID_SPI		3
+#define BOOT_ID_SDCARD		4
+#define BOOT_ID_USB		5
+
+#endif /* __BOOT_ROM_H_ */
diff --git a/arch/arm/include/asm/arch-txl/sd_emmc.h b/arch/arm/include/asm/arch-txl/sd_emmc.h
new file mode 100644
index 0000000..07f7874
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/sd_emmc.h
@@ -0,0 +1,175 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/sd_emmc.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __SD_EMMC_H__
+#define __SD_EMMC_H__
+
+#include "cpu_sdio.h"
+
+#define SD_EMMC_BASE_A 0xd0070000
+#define SD_EMMC_BASE_B 0xd0072000
+#define SD_EMMC_BASE_C 0xd0074000
+
+#define NEWSD_IRQ_ALL				    0x3fff
+
+#define SD_EMMC_CLKSRC_24M 	24000000
+#define SD_EMMC_CLKSRC_DIV2	1000000000
+
+#define NEWSD_IRQ_EN_ALL_INIT
+#define NEWSD_MAX_DESC_MUN					512
+#define NEWSD_BOUNCE_REQ_SIZE		(512*1024)
+#define MAX_BLOCK_COUNTS	256
+#define SD_EMMC_CLKSRC 24000000
+
+#define MMC_RSP_136_NUM					4
+#define MAX_RESPONSE_BYTES     4
+
+#define RESPONSE_R1_R3_R6_R7_LENGTH     6
+#define RESPONSE_R2_CID_CSD_LENGTH      17
+#define RESPONSE_R4_R5_NONE_LENGTH      0
+
+#define SDIO_PORT_A    0
+#define SDIO_PORT_B    1
+#define SDIO_PORT_C    2
+
+#define CARD_SD_SDIO_INIT          (1<<0)
+#define CARD_SD_SDIO_DETECT        (1<<1)
+#define CARD_SD_SDIO_PWR_PREPARE   (1<<2)
+#define CARD_SD_SDIO_PWR_ON        (1<<3)
+#define CARD_SD_SDIO_PWR_OFF       (1<<4)
+
+typedef enum _SD_Error_Status_t {
+	SD_NO_ERROR                 = 0,
+	SD_ERROR_OUT_OF_RANGE,                  //Bit 31
+	SD_ERROR_ADDRESS,                       //Bit 30
+	SD_ERROR_BLOCK_LEN,                     //Bit 29
+	SD_ERROR_ERASE_SEQ,                     //Bit 28
+	SD_ERROR_ERASE_PARAM,                   //Bit 27
+	SD_ERROR_WP_VIOLATION,                  //Bit 26
+	SD_ERROR_CARD_IS_LOCKED,                    //Bit 25
+	SD_ERROR_LOCK_UNLOCK_FAILED,                //Bit 24
+	SD_ERROR_COM_CRC,                       //Bit 23
+	SD_ERROR_ILLEGAL_COMMAND,               //Bit 22
+	SD_ERROR_CARD_ECC_FAILED,                   //Bit 21
+	SD_ERROR_CC,                                //Bit 20
+	SD_ERROR_GENERAL,                       //Bit 19
+	SD_ERROR_Reserved1,                         //Bit 18
+	SD_ERROR_Reserved2,                         //Bit 17
+	SD_ERROR_CID_CSD_OVERWRITE,             //Bit 16
+	SD_ERROR_AKE_SEQ,                           //Bit 03
+	SD_ERROR_STATE_MISMATCH,
+	SD_ERROR_HEADER_MISMATCH,
+	SD_ERROR_DATA_CRC,
+	SD_ERROR_TIMEOUT,
+	SD_ERROR_DRIVER_FAILURE,
+	SD_ERROR_WRITE_PROTECTED,
+	SD_ERROR_NO_MEMORY,
+	SD_ERROR_SWITCH_FUNCTION_COMUNICATION,
+	SD_ERROR_NO_FUNCTION_SWITCH,
+	SD_ERROR_NO_CARD_INS
+} SD_Error_Status_t;
+
+
+typedef enum _SD_Bus_Width
+{
+	SD_BUS_SINGLE                   = 1,        //only DAT0
+	SD_BUS_WIDE                     = 4         //use DAT0-4
+} SD_Bus_Width_t;
+
+//LSB -> MSB, structrue for SD Card Status
+typedef struct _SD_Card_Status
+{
+	unsigned Reserved3: 2;
+	unsigned Reserved4: 1;
+	unsigned AKE_SEQ_ERROR: 1;                  //Error in the sequence of authentication process.
+	unsigned Reserved5: 1;
+	unsigned APP_CMD: 1;                        //The card will expect ACMD, or indication that the command has been interpreted as ACMD.
+	unsigned NotUsed: 2;
+
+	unsigned READY_FOR_DATA: 1;                 //Corresponds to buffer empty signalling on the bus.
+	unsigned CURRENT_STATE: 4;                  //The state of the card when receiving the command.
+	unsigned ERASE_RESET: 1;                    //An erase sequence was cleared beforem executing because an out of erase sequence command was received.
+	unsigned CARD_ECC_DISABLED: 1;              //The command has been executed without using the internal ECC.
+	unsigned WP_ERASE_SKIP: 1;                  //Only partial address space was erased due to existing write protected blocks.
+
+	unsigned CID_CSD_OVERWRITE: 1;              //Can be either one of the following errors:
+	unsigned Reserved1: 1;
+	unsigned Reserved2: 1;
+	unsigned ERROR: 1;                          //A general or an unknown error occurred during the operation.
+	unsigned CC_ERROR: 1;                       //Internal card controller error
+	unsigned CARD_ECC_FAILED: 1;                //Card internal ECC was applied but failed to correct the data.
+	unsigned ILLEGAL_COMMAND: 1;                //Command not legal for the card state
+	unsigned COM_CRC_ERROR: 1;                  //The CRC check of the previous command failed.
+
+	unsigned LOCK_UNLOCK_FAILED: 1;             //Set when a sequence or password error has been detected in lock/ unlock card command or if there was an attempt to access a locked card
+
+	unsigned CARD_IS_LOCKED: 1;                 //When set, signals that the card is locked by the host
+	unsigned WP_VIOLATION: 1;                   //Attempt to program a write-protected block.
+	unsigned ERASE_PARAM: 1;                    //An invalid selection of write-blocks for erase occurred.
+	unsigned ERASE_SEQ_ERROR: 1;                //An error in the sequence of erase commands occurred.
+	unsigned BLOCK_LEN_ERROR: 1;                //The transferred block length is not allowed for this card, or the number of transferred bytes does not match the block length.
+	unsigned ADDRESS_ERROR: 1;                  //A misaligned address that did not match the block length was used in the command.
+	unsigned OUT_OF_RANGE: 1;                   //The command??s argument was out of the allowed range for this card.
+
+} SD_Card_Status_t;
+
+//structure for response
+typedef struct _SD_Response_R1
+{
+	SD_Card_Status_t card_status;               //card status
+} SD_Response_R1_t;
+
+
+struct aml_card_sd_info
+{
+	unsigned sd_emmc_port;				 //0: sdioa, 1:sdiob, 2:sdioc
+	unsigned sd_emmc_reg_base;
+	char * name;
+	int inited_flag;
+	int removed_flag;
+	int init_retry;
+	int single_blk_failed;
+	char* desc_buf;
+	struct mmc_config cfg;
+	struct sd_emmc_global_regs *sd_emmc_reg;
+	dma_addr_t		desc_dma_addr;
+#ifdef AML_CARD_SD_INFO_DETAILED
+	int  (* sd_emmc_init)(unsigned port,struct aml_card_sd_info *sdio);
+	int  (* sd_emmc_detect)(unsigned port,struct aml_card_sd_info *sdio);
+	void (* sd_emmc_pwr_prepare)(unsigned port,struct aml_card_sd_info *sdio);
+	void (* sd_emmc_pwr_on)(unsigned port,struct aml_card_sd_info *sdio);
+	void (* sd_emmc_pwr_off)(unsigned port,struct aml_card_sd_info *sdio);
+	unsigned int sdio_pwr_flag;
+#else
+	int  (* sd_emmc_init)(unsigned port);
+	int  (* sd_emmc_detect)(unsigned port);
+	void (* sd_emmc_pwr_prepare)(unsigned port);
+	void (* sd_emmc_pwr_on)(unsigned port);
+	void (* sd_emmc_pwr_off)(unsigned port);
+#endif
+};
+
+extern struct aml_card_sd_info * cpu_sd_emmc_get(unsigned port);
+extern int                cpu_sd_emmc_init(unsigned port);
+extern void               cpu_sd_emmc_pwr_prepare(unsigned port);
+struct mmc;//mmc is struct mmc , to avoid include mmc.h , declare it
+extern void               sd_emmc_register(struct aml_card_sd_info *);
+#endif
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-txl/secure_apb.h b/arch/arm/include/asm/arch-txl/secure_apb.h
new file mode 100644
index 0000000..909c0f3
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/secure_apb.h
@@ -0,0 +1,1945 @@
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+//
+// ./create_headers_from_secure_apb4_h.pl
+//
+// and was applied to the file
+//
+// ./secure_apb4_ee.h ./ao_rti_reg.h
+//
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+//
+#ifdef SECURE_APB_H
+#else
+#define SECURE_APB_H
+
+//
+// Reading file:  ./secure_apb4_ee.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//========================================================================
+//  RNG
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8834000
+//  APB4_DECODER_SECURE_BASE         32'hDA834000
+//  Non Secure Register
+#define     RNG_DATA                                           (0xc8834000 + (0x00 << 2))
+#define SEC_RNG_DATA                                           (0xda834000 + (0x00 << 2))
+#define   P_RNG_DATA                                           (volatile uint32_t *)(0xc8834000 + (0x00 << 2))
+//  Secure Register
+#define     RNG_SEC_CONFIG_REG1                                (0xc8834000 + (0x01 << 2))
+#define SEC_RNG_SEC_CONFIG_REG1                                (0xda834000 + (0x01 << 2))
+#define   P_RNG_SEC_CONFIG_REG1                                (volatile uint32_t *)(0xc8834000 + (0x01 << 2))
+#define     RNG_SEC_CONFIG_REG2                                (0xc8834000 + (0x02 << 2))
+#define SEC_RNG_SEC_CONFIG_REG2                                (0xda834000 + (0x02 << 2))
+#define   P_RNG_SEC_CONFIG_REG2                                (volatile uint32_t *)(0xc8834000 + (0x02 << 2))
+#define     RNG_SEC_SCRATCH_REG                                (0xc8834000 + (0x03 << 2))
+#define SEC_RNG_SEC_SCRATCH_REG                                (0xda834000 + (0x03 << 2))
+#define   P_RNG_SEC_SCRATCH_REG                                (volatile uint32_t *)(0xc8834000 + (0x03 << 2))
+//========================================================================
+//  ACODEC
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8832000
+//  APB4_DECODER_SECURE_BASE         32'hDA832000
+#define     ACODEC_0                                           (0xc8832000 + (0x00 << 2))
+#define SEC_ACODEC_0                                           (0xda832000 + (0x00 << 2))
+#define   P_ACODEC_0                                           (volatile uint32_t *)(0xc8832000 + (0x00 << 2))
+#define     ACODEC_1                                           (0xc8832000 + (0x01 << 2))
+#define SEC_ACODEC_1                                           (0xda832000 + (0x01 << 2))
+#define   P_ACODEC_1                                           (volatile uint32_t *)(0xc8832000 + (0x01 << 2))
+#define     ACODEC_2                                           (0xc8832000 + (0x02 << 2))
+#define SEC_ACODEC_2                                           (0xda832000 + (0x02 << 2))
+#define   P_ACODEC_2                                           (volatile uint32_t *)(0xc8832000 + (0x02 << 2))
+#define     ACODEC_3                                           (0xc8832000 + (0x03 << 2))
+#define SEC_ACODEC_3                                           (0xda832000 + (0x03 << 2))
+#define   P_ACODEC_3                                           (volatile uint32_t *)(0xc8832000 + (0x03 << 2))
+#define     ACODEC_4                                           (0xc8832000 + (0x04 << 2))
+#define SEC_ACODEC_4                                           (0xda832000 + (0x04 << 2))
+#define   P_ACODEC_4                                           (volatile uint32_t *)(0xc8832000 + (0x04 << 2))
+//========================================================================
+//  PERIPHS
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8834400
+//  APB4_DECODER_SECURE_BASE         32'hDA834400
+// The following are handled by $periphs/rtl/periphs_reg.v
+#define     PREG_CTLREG0_ADDR                                  (0xc8834400 + (0x00 << 2))
+#define SEC_PREG_CTLREG0_ADDR                                  (0xda834400 + (0x00 << 2))
+#define   P_PREG_CTLREG0_ADDR                                  (volatile uint32_t *)(0xc8834400 + (0x00 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO6_EN_N                                (0xc8834400 + (0x08 << 2))
+#define SEC_PREG_PAD_GPIO6_EN_N                                (0xda834400 + (0x08 << 2))
+#define   P_PREG_PAD_GPIO6_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x08 << 2))
+#define     PREG_PAD_GPIO6_O                                   (0xc8834400 + (0x09 << 2))
+#define SEC_PREG_PAD_GPIO6_O                                   (0xda834400 + (0x09 << 2))
+#define   P_PREG_PAD_GPIO6_O                                   (volatile uint32_t *)(0xc8834400 + (0x09 << 2))
+#define     PREG_PAD_GPIO6_I                                   (0xc8834400 + (0x0a << 2))
+#define SEC_PREG_PAD_GPIO6_I                                   (0xda834400 + (0x0a << 2))
+#define   P_PREG_PAD_GPIO6_I                                   (volatile uint32_t *)(0xc8834400 + (0x0a << 2))
+// ----------------------------
+// ----------------------------
+#define     PREG_JTAG_GPIO_ADDR                                (0xc8834400 + (0x0b << 2))
+#define SEC_PREG_JTAG_GPIO_ADDR                                (0xda834400 + (0x0b << 2))
+#define   P_PREG_JTAG_GPIO_ADDR                                (volatile uint32_t *)(0xc8834400 + (0x0b << 2))
+// ----------------------------
+// Pre-defined GPIO addresses
+// ----------------------------
+#define     PREG_PAD_GPIO0_EN_N                                (0xc8834400 + (0x0c << 2))
+#define SEC_PREG_PAD_GPIO0_EN_N                                (0xda834400 + (0x0c << 2))
+#define   P_PREG_PAD_GPIO0_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x0c << 2))
+#define     PREG_PAD_GPIO0_O                                   (0xc8834400 + (0x0d << 2))
+#define SEC_PREG_PAD_GPIO0_O                                   (0xda834400 + (0x0d << 2))
+#define   P_PREG_PAD_GPIO0_O                                   (volatile uint32_t *)(0xc8834400 + (0x0d << 2))
+#define     PREG_PAD_GPIO0_I                                   (0xc8834400 + (0x0e << 2))
+#define SEC_PREG_PAD_GPIO0_I                                   (0xda834400 + (0x0e << 2))
+#define   P_PREG_PAD_GPIO0_I                                   (volatile uint32_t *)(0xc8834400 + (0x0e << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO1_EN_N                                (0xc8834400 + (0x0f << 2))
+#define SEC_PREG_PAD_GPIO1_EN_N                                (0xda834400 + (0x0f << 2))
+#define   P_PREG_PAD_GPIO1_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x0f << 2))
+#define     PREG_PAD_GPIO1_O                                   (0xc8834400 + (0x10 << 2))
+#define SEC_PREG_PAD_GPIO1_O                                   (0xda834400 + (0x10 << 2))
+#define   P_PREG_PAD_GPIO1_O                                   (volatile uint32_t *)(0xc8834400 + (0x10 << 2))
+#define     PREG_PAD_GPIO1_I                                   (0xc8834400 + (0x11 << 2))
+#define SEC_PREG_PAD_GPIO1_I                                   (0xda834400 + (0x11 << 2))
+#define   P_PREG_PAD_GPIO1_I                                   (volatile uint32_t *)(0xc8834400 + (0x11 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO2_EN_N                                (0xc8834400 + (0x12 << 2))
+#define SEC_PREG_PAD_GPIO2_EN_N                                (0xda834400 + (0x12 << 2))
+#define   P_PREG_PAD_GPIO2_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x12 << 2))
+#define     PREG_PAD_GPIO2_O                                   (0xc8834400 + (0x13 << 2))
+#define SEC_PREG_PAD_GPIO2_O                                   (0xda834400 + (0x13 << 2))
+#define   P_PREG_PAD_GPIO2_O                                   (volatile uint32_t *)(0xc8834400 + (0x13 << 2))
+#define     PREG_PAD_GPIO2_I                                   (0xc8834400 + (0x14 << 2))
+#define SEC_PREG_PAD_GPIO2_I                                   (0xda834400 + (0x14 << 2))
+#define   P_PREG_PAD_GPIO2_I                                   (volatile uint32_t *)(0xc8834400 + (0x14 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO3_EN_N                                (0xc8834400 + (0x15 << 2))
+#define SEC_PREG_PAD_GPIO3_EN_N                                (0xda834400 + (0x15 << 2))
+#define   P_PREG_PAD_GPIO3_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x15 << 2))
+#define     PREG_PAD_GPIO3_O                                   (0xc8834400 + (0x16 << 2))
+#define SEC_PREG_PAD_GPIO3_O                                   (0xda834400 + (0x16 << 2))
+#define   P_PREG_PAD_GPIO3_O                                   (volatile uint32_t *)(0xc8834400 + (0x16 << 2))
+#define     PREG_PAD_GPIO3_I                                   (0xc8834400 + (0x17 << 2))
+#define SEC_PREG_PAD_GPIO3_I                                   (0xda834400 + (0x17 << 2))
+#define   P_PREG_PAD_GPIO3_I                                   (volatile uint32_t *)(0xc8834400 + (0x17 << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO4_EN_N                                (0xc8834400 + (0x18 << 2))
+#define SEC_PREG_PAD_GPIO4_EN_N                                (0xda834400 + (0x18 << 2))
+#define   P_PREG_PAD_GPIO4_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x18 << 2))
+#define     PREG_PAD_GPIO4_O                                   (0xc8834400 + (0x19 << 2))
+#define SEC_PREG_PAD_GPIO4_O                                   (0xda834400 + (0x19 << 2))
+#define   P_PREG_PAD_GPIO4_O                                   (volatile uint32_t *)(0xc8834400 + (0x19 << 2))
+#define     PREG_PAD_GPIO4_I                                   (0xc8834400 + (0x1a << 2))
+#define SEC_PREG_PAD_GPIO4_I                                   (0xda834400 + (0x1a << 2))
+#define   P_PREG_PAD_GPIO4_I                                   (volatile uint32_t *)(0xc8834400 + (0x1a << 2))
+// ----------------------------
+#define     PREG_PAD_GPIO5_EN_N                                (0xc8834400 + (0x1b << 2))
+#define SEC_PREG_PAD_GPIO5_EN_N                                (0xda834400 + (0x1b << 2))
+#define   P_PREG_PAD_GPIO5_EN_N                                (volatile uint32_t *)(0xc8834400 + (0x1b << 2))
+#define     PREG_PAD_GPIO5_O                                   (0xc8834400 + (0x1c << 2))
+#define SEC_PREG_PAD_GPIO5_O                                   (0xda834400 + (0x1c << 2))
+#define   P_PREG_PAD_GPIO5_O                                   (volatile uint32_t *)(0xc8834400 + (0x1c << 2))
+#define     PREG_PAD_GPIO5_I                                   (0xc8834400 + (0x1d << 2))
+#define SEC_PREG_PAD_GPIO5_I                                   (0xda834400 + (0x1d << 2))
+#define   P_PREG_PAD_GPIO5_I                                   (volatile uint32_t *)(0xc8834400 + (0x1d << 2))
+// ----------------------------
+// ----------------------------
+// Pin Mux  (9)
+// ----------------------------
+#define     PERIPHS_PIN_MUX_0                                  (0xc8834400 + (0x2c << 2))
+#define SEC_PERIPHS_PIN_MUX_0                                  (0xda834400 + (0x2c << 2))
+#define   P_PERIPHS_PIN_MUX_0                                  (volatile uint32_t *)(0xc8834400 + (0x2c << 2))
+#define     PERIPHS_PIN_MUX_1                                  (0xc8834400 + (0x2d << 2))
+#define SEC_PERIPHS_PIN_MUX_1                                  (0xda834400 + (0x2d << 2))
+#define   P_PERIPHS_PIN_MUX_1                                  (volatile uint32_t *)(0xc8834400 + (0x2d << 2))
+#define     PERIPHS_PIN_MUX_2                                  (0xc8834400 + (0x2e << 2))
+#define SEC_PERIPHS_PIN_MUX_2                                  (0xda834400 + (0x2e << 2))
+#define   P_PERIPHS_PIN_MUX_2                                  (volatile uint32_t *)(0xc8834400 + (0x2e << 2))
+#define     PERIPHS_PIN_MUX_3                                  (0xc8834400 + (0x2f << 2))
+#define SEC_PERIPHS_PIN_MUX_3                                  (0xda834400 + (0x2f << 2))
+#define   P_PERIPHS_PIN_MUX_3                                  (volatile uint32_t *)(0xc8834400 + (0x2f << 2))
+#define     PERIPHS_PIN_MUX_4                                  (0xc8834400 + (0x30 << 2))
+#define SEC_PERIPHS_PIN_MUX_4                                  (0xda834400 + (0x30 << 2))
+#define   P_PERIPHS_PIN_MUX_4                                  (volatile uint32_t *)(0xc8834400 + (0x30 << 2))
+#define     PERIPHS_PIN_MUX_5                                  (0xc8834400 + (0x31 << 2))
+#define SEC_PERIPHS_PIN_MUX_5                                  (0xda834400 + (0x31 << 2))
+#define   P_PERIPHS_PIN_MUX_5                                  (volatile uint32_t *)(0xc8834400 + (0x31 << 2))
+#define     PERIPHS_PIN_MUX_6                                  (0xc8834400 + (0x32 << 2))
+#define SEC_PERIPHS_PIN_MUX_6                                  (0xda834400 + (0x32 << 2))
+#define   P_PERIPHS_PIN_MUX_6                                  (volatile uint32_t *)(0xc8834400 + (0x32 << 2))
+#define     PERIPHS_PIN_MUX_7                                  (0xc8834400 + (0x33 << 2))
+#define SEC_PERIPHS_PIN_MUX_7                                  (0xda834400 + (0x33 << 2))
+#define   P_PERIPHS_PIN_MUX_7                                  (volatile uint32_t *)(0xc8834400 + (0x33 << 2))
+#define     PERIPHS_PIN_MUX_8                                  (0xc8834400 + (0x34 << 2))
+#define SEC_PERIPHS_PIN_MUX_8                                  (0xda834400 + (0x34 << 2))
+#define   P_PERIPHS_PIN_MUX_8                                  (volatile uint32_t *)(0xc8834400 + (0x34 << 2))
+#define     PERIPHS_PIN_MUX_9                                  (0xc8834400 + (0x35 << 2))
+#define SEC_PERIPHS_PIN_MUX_9                                  (0xda834400 + (0x35 << 2))
+#define   P_PERIPHS_PIN_MUX_9                                  (volatile uint32_t *)(0xc8834400 + (0x35 << 2))
+#define     PERIPHS_PIN_MUX_10                                 (0xc8834400 + (0x36 << 2))
+#define SEC_PERIPHS_PIN_MUX_10                                 (0xda834400 + (0x36 << 2))
+#define   P_PERIPHS_PIN_MUX_10                                 (volatile uint32_t *)(0xc8834400 + (0x36 << 2))
+#define     PERIPHS_PIN_MUX_11                                 (0xc8834400 + (0x37 << 2))
+#define SEC_PERIPHS_PIN_MUX_11                                 (0xda834400 + (0x37 << 2))
+#define   P_PERIPHS_PIN_MUX_11                                 (volatile uint32_t *)(0xc8834400 + (0x37 << 2))
+#define     PERIPHS_PIN_MUX_12                                 (0xc8834400 + (0x38 << 2))
+#define SEC_PERIPHS_PIN_MUX_12                                 (0xda834400 + (0x38 << 2))
+#define   P_PERIPHS_PIN_MUX_12                                 (volatile uint32_t *)(0xc8834400 + (0x38 << 2))
+// ----------------------------
+// Pad conntrols
+// ----------------------------
+#define     PAD_PULL_UP_REG6                                   (0xc8834400 + (0x39 << 2))
+#define SEC_PAD_PULL_UP_REG6                                   (0xda834400 + (0x39 << 2))
+#define   P_PAD_PULL_UP_REG6                                   (volatile uint32_t *)(0xc8834400 + (0x39 << 2))
+#define     PAD_PULL_UP_REG0                                   (0xc8834400 + (0x3a << 2))
+#define SEC_PAD_PULL_UP_REG0                                   (0xda834400 + (0x3a << 2))
+#define   P_PAD_PULL_UP_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x3a << 2))
+#define     PAD_PULL_UP_REG1                                   (0xc8834400 + (0x3b << 2))
+#define SEC_PAD_PULL_UP_REG1                                   (0xda834400 + (0x3b << 2))
+#define   P_PAD_PULL_UP_REG1                                   (volatile uint32_t *)(0xc8834400 + (0x3b << 2))
+#define     PAD_PULL_UP_REG2                                   (0xc8834400 + (0x3c << 2))
+#define SEC_PAD_PULL_UP_REG2                                   (0xda834400 + (0x3c << 2))
+#define   P_PAD_PULL_UP_REG2                                   (volatile uint32_t *)(0xc8834400 + (0x3c << 2))
+#define     PAD_PULL_UP_REG3                                   (0xc8834400 + (0x3d << 2))
+#define SEC_PAD_PULL_UP_REG3                                   (0xda834400 + (0x3d << 2))
+#define   P_PAD_PULL_UP_REG3                                   (volatile uint32_t *)(0xc8834400 + (0x3d << 2))
+#define     PAD_PULL_UP_REG4                                   (0xc8834400 + (0x3e << 2))
+#define SEC_PAD_PULL_UP_REG4                                   (0xda834400 + (0x3e << 2))
+#define   P_PAD_PULL_UP_REG4                                   (volatile uint32_t *)(0xc8834400 + (0x3e << 2))
+#define     PAD_PULL_UP_REG5                                   (0xc8834400 + (0x3f << 2))
+#define SEC_PAD_PULL_UP_REG5                                   (0xda834400 + (0x3f << 2))
+#define   P_PAD_PULL_UP_REG5                                   (volatile uint32_t *)(0xc8834400 + (0x3f << 2))
+// ----------------------------
+// Random (2)
+// ----------------------------
+#define     RAND64_ADDR0                                       (0xc8834400 + (0x40 << 2))
+#define SEC_RAND64_ADDR0                                       (0xda834400 + (0x40 << 2))
+#define   P_RAND64_ADDR0                                       (volatile uint32_t *)(0xc8834400 + (0x40 << 2))
+#define     RAND64_ADDR1                                       (0xc8834400 + (0x41 << 2))
+#define SEC_RAND64_ADDR1                                       (0xda834400 + (0x41 << 2))
+#define   P_RAND64_ADDR1                                       (volatile uint32_t *)(0xc8834400 + (0x41 << 2))
+// ---------------------------
+// Ethernet (1)
+// ----------------------------
+#define     PREG_ETHERNET_ADDR0                                (0xc8834400 + (0x42 << 2))
+#define SEC_PREG_ETHERNET_ADDR0                                (0xda834400 + (0x42 << 2))
+#define   P_PREG_ETHERNET_ADDR0                                (volatile uint32_t *)(0xc8834400 + (0x42 << 2))
+// ---------------------------
+// AM_ANALOG_TOP
+// ----------------------------
+#define     PREG_AM_ANALOG_ADDR                                (0xc8834400 + (0x43 << 2))
+#define SEC_PREG_AM_ANALOG_ADDR                                (0xda834400 + (0x43 << 2))
+#define   P_PREG_AM_ANALOG_ADDR                                (volatile uint32_t *)(0xc8834400 + (0x43 << 2))
+// ---------------------------
+// Mali55 (1)
+// ----------------------------
+#define     PREG_MALI_BYTE_CNTL                                (0xc8834400 + (0x44 << 2))
+#define SEC_PREG_MALI_BYTE_CNTL                                (0xda834400 + (0x44 << 2))
+#define   P_PREG_MALI_BYTE_CNTL                                (volatile uint32_t *)(0xc8834400 + (0x44 << 2))
+// ---------------------------
+// WIFI (1)
+// ----------------------------
+#define     PREG_WIFI_CNTL                                     (0xc8834400 + (0x45 << 2))
+#define SEC_PREG_WIFI_CNTL                                     (0xda834400 + (0x45 << 2))
+#define   P_PREG_WIFI_CNTL                                     (volatile uint32_t *)(0xc8834400 + (0x45 << 2))
+#define     PAD_PULL_UP_EN_REG0                                (0xc8834400 + (0x48 << 2))
+#define SEC_PAD_PULL_UP_EN_REG0                                (0xda834400 + (0x48 << 2))
+#define   P_PAD_PULL_UP_EN_REG0                                (volatile uint32_t *)(0xc8834400 + (0x48 << 2))
+#define     PAD_PULL_UP_EN_REG1                                (0xc8834400 + (0x49 << 2))
+#define SEC_PAD_PULL_UP_EN_REG1                                (0xda834400 + (0x49 << 2))
+#define   P_PAD_PULL_UP_EN_REG1                                (volatile uint32_t *)(0xc8834400 + (0x49 << 2))
+#define     PAD_PULL_UP_EN_REG2                                (0xc8834400 + (0x4a << 2))
+#define SEC_PAD_PULL_UP_EN_REG2                                (0xda834400 + (0x4a << 2))
+#define   P_PAD_PULL_UP_EN_REG2                                (volatile uint32_t *)(0xc8834400 + (0x4a << 2))
+#define     PAD_PULL_UP_EN_REG3                                (0xc8834400 + (0x4b << 2))
+#define SEC_PAD_PULL_UP_EN_REG3                                (0xda834400 + (0x4b << 2))
+#define   P_PAD_PULL_UP_EN_REG3                                (volatile uint32_t *)(0xc8834400 + (0x4b << 2))
+#define     PAD_PULL_UP_EN_REG4                                (0xc8834400 + (0x4c << 2))
+#define SEC_PAD_PULL_UP_EN_REG4                                (0xda834400 + (0x4c << 2))
+#define   P_PAD_PULL_UP_EN_REG4                                (volatile uint32_t *)(0xc8834400 + (0x4c << 2))
+#define     PAD_PULL_UP_EN_REG5                                (0xc8834400 + (0x4d << 2))
+#define SEC_PAD_PULL_UP_EN_REG5                                (0xda834400 + (0x4d << 2))
+#define   P_PAD_PULL_UP_EN_REG5                                (volatile uint32_t *)(0xc8834400 + (0x4d << 2))
+#define     PAD_PULL_UP_EN_REG6                                (0xc8834400 + (0x4e << 2))
+#define SEC_PAD_PULL_UP_EN_REG6                                (0xda834400 + (0x4e << 2))
+#define   P_PAD_PULL_UP_EN_REG6                                (volatile uint32_t *)(0xc8834400 + (0x4e << 2))
+// ---------------------------
+#define     PREG_ETH_REG0                                      (0xc8834400 + (0x50 << 2))
+#define SEC_PREG_ETH_REG0                                      (0xda834400 + (0x50 << 2))
+#define   P_PREG_ETH_REG0                                      (volatile uint32_t *)(0xc8834400 + (0x50 << 2))
+#define     PREG_ETH_REG1                                      (0xc8834400 + (0x51 << 2))
+#define SEC_PREG_ETH_REG1                                      (0xda834400 + (0x51 << 2))
+#define   P_PREG_ETH_REG1                                      (volatile uint32_t *)(0xc8834400 + (0x51 << 2))
+#define     PREG_NAND_CFG_KEY0                                 (0xc8834400 + (0x52 << 2))
+#define SEC_PREG_NAND_CFG_KEY0                                 (0xda834400 + (0x52 << 2))
+#define   P_PREG_NAND_CFG_KEY0                                 (volatile uint32_t *)(0xc8834400 + (0x52 << 2))
+#define     PREG_NAND_CFG_KEY1                                 (0xc8834400 + (0x53 << 2))
+#define SEC_PREG_NAND_CFG_KEY1                                 (0xda834400 + (0x53 << 2))
+#define   P_PREG_NAND_CFG_KEY1                                 (volatile uint32_t *)(0xc8834400 + (0x53 << 2))
+#define     PREG_VPU_SECURE0                                   (0xc8834400 + (0x54 << 2))
+#define SEC_PREG_VPU_SECURE0                                   (0xda834400 + (0x54 << 2))
+#define   P_PREG_VPU_SECURE0                                   (volatile uint32_t *)(0xc8834400 + (0x54 << 2))
+#define     PREG_VPU_SECURE1                                   (0xc8834400 + (0x55 << 2))
+#define SEC_PREG_VPU_SECURE1                                   (0xda834400 + (0x55 << 2))
+#define   P_PREG_VPU_SECURE1                                   (volatile uint32_t *)(0xc8834400 + (0x55 << 2))
+#define     PREG_ETH_REG2                                      (0xc8834400 + (0x56 << 2))
+#define SEC_PREG_ETH_REG2                                      (0xda834400 + (0x56 << 2))
+#define   P_PREG_ETH_REG2                                      (volatile uint32_t *)(0xc8834400 + (0x56 << 2))
+#define     PREG_ETH_REG3                                      (0xc8834400 + (0x57 << 2))
+#define SEC_PREG_ETH_REG3                                      (0xda834400 + (0x57 << 2))
+#define   P_PREG_ETH_REG3                                      (volatile uint32_t *)(0xc8834400 + (0x57 << 2))
+#define     PREG_ETH_REG4                                      (0xc8834400 + (0x58 << 2))
+#define SEC_PREG_ETH_REG4                                      (0xda834400 + (0x58 << 2))
+#define   P_PREG_ETH_REG4                                      (volatile uint32_t *)(0xc8834400 + (0x58 << 2))
+// ---------------------------
+// Generic production test
+// ----------------------------
+#define     PROD_TEST_REG0                                     (0xc8834400 + (0x60 << 2))
+#define SEC_PROD_TEST_REG0                                     (0xda834400 + (0x60 << 2))
+#define   P_PROD_TEST_REG0                                     (volatile uint32_t *)(0xc8834400 + (0x60 << 2))
+#define     PROD_TEST_REG1                                     (0xc8834400 + (0x61 << 2))
+#define SEC_PROD_TEST_REG1                                     (0xda834400 + (0x61 << 2))
+#define   P_PROD_TEST_REG1                                     (volatile uint32_t *)(0xc8834400 + (0x61 << 2))
+#define     PROD_TEST_REG2                                     (0xc8834400 + (0x62 << 2))
+#define SEC_PROD_TEST_REG2                                     (0xda834400 + (0x62 << 2))
+#define   P_PROD_TEST_REG2                                     (volatile uint32_t *)(0xc8834400 + (0x62 << 2))
+#define     PROD_TEST_REG3                                     (0xc8834400 + (0x63 << 2))
+#define SEC_PROD_TEST_REG3                                     (0xda834400 + (0x63 << 2))
+#define   P_PROD_TEST_REG3                                     (volatile uint32_t *)(0xc8834400 + (0x63 << 2))
+// ---------------------------
+// am_analog_top
+// ----------------------------
+//`define METAL_REVISION                      8'h6a
+#define     ADC_TOP_MISC                                       (0xc8834400 + (0x6b << 2))
+#define SEC_ADC_TOP_MISC                                       (0xda834400 + (0x6b << 2))
+#define   P_ADC_TOP_MISC                                       (volatile uint32_t *)(0xc8834400 + (0x6b << 2))
+#define     DPLL_TOP_MISC                                      (0xc8834400 + (0x6c << 2))
+#define SEC_DPLL_TOP_MISC                                      (0xda834400 + (0x6c << 2))
+#define   P_DPLL_TOP_MISC                                      (volatile uint32_t *)(0xc8834400 + (0x6c << 2))
+#define     ANALOG_TOP_MISC                                    (0xc8834400 + (0x6d << 2))
+#define SEC_ANALOG_TOP_MISC                                    (0xda834400 + (0x6d << 2))
+#define   P_ANALOG_TOP_MISC                                    (volatile uint32_t *)(0xc8834400 + (0x6d << 2))
+#define     AM_ANALOG_TOP_REG0                                 (0xc8834400 + (0x6e << 2))
+#define SEC_AM_ANALOG_TOP_REG0                                 (0xda834400 + (0x6e << 2))
+#define   P_AM_ANALOG_TOP_REG0                                 (volatile uint32_t *)(0xc8834400 + (0x6e << 2))
+#define     AM_ANALOG_TOP_REG1                                 (0xc8834400 + (0x6f << 2))
+#define SEC_AM_ANALOG_TOP_REG1                                 (0xda834400 + (0x6f << 2))
+#define   P_AM_ANALOG_TOP_REG1                                 (volatile uint32_t *)(0xc8834400 + (0x6f << 2))
+// ---------------------------
+// Sticky regs
+// ----------------------------
+#define     PREG_STICKY_REG0                                   (0xc8834400 + (0x70 << 2))
+#define SEC_PREG_STICKY_REG0                                   (0xda834400 + (0x70 << 2))
+#define   P_PREG_STICKY_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x70 << 2))
+#define     PREG_STICKY_REG1                                   (0xc8834400 + (0x71 << 2))
+#define SEC_PREG_STICKY_REG1                                   (0xda834400 + (0x71 << 2))
+#define   P_PREG_STICKY_REG1                                   (volatile uint32_t *)(0xc8834400 + (0x71 << 2))
+#define     PREG_STICKY_REG2                                   (0xc8834400 + (0x72 << 2))
+#define SEC_PREG_STICKY_REG2                                   (0xda834400 + (0x72 << 2))
+#define   P_PREG_STICKY_REG2                                   (volatile uint32_t *)(0xc8834400 + (0x72 << 2))
+#define     PREG_STICKY_REG3                                   (0xc8834400 + (0x73 << 2))
+#define SEC_PREG_STICKY_REG3                                   (0xda834400 + (0x73 << 2))
+#define   P_PREG_STICKY_REG3                                   (volatile uint32_t *)(0xc8834400 + (0x73 << 2))
+#define     PREG_STICKY_REG4                                   (0xc8834400 + (0x74 << 2))
+#define SEC_PREG_STICKY_REG4                                   (0xda834400 + (0x74 << 2))
+#define   P_PREG_STICKY_REG4                                   (volatile uint32_t *)(0xc8834400 + (0x74 << 2))
+#define     PREG_STICKY_REG5                                   (0xc8834400 + (0x75 << 2))
+#define SEC_PREG_STICKY_REG5                                   (0xda834400 + (0x75 << 2))
+#define   P_PREG_STICKY_REG5                                   (volatile uint32_t *)(0xc8834400 + (0x75 << 2))
+#define     PREG_STICKY_REG6                                   (0xc8834400 + (0x76 << 2))
+#define SEC_PREG_STICKY_REG6                                   (0xda834400 + (0x76 << 2))
+#define   P_PREG_STICKY_REG6                                   (volatile uint32_t *)(0xc8834400 + (0x76 << 2))
+#define     PREG_STICKY_REG7                                   (0xc8834400 + (0x77 << 2))
+#define SEC_PREG_STICKY_REG7                                   (0xda834400 + (0x77 << 2))
+#define   P_PREG_STICKY_REG7                                   (volatile uint32_t *)(0xc8834400 + (0x77 << 2))
+#define     PREG_STICKY_REG8                                   (0xc8834400 + (0x78 << 2))
+#define SEC_PREG_STICKY_REG8                                   (0xda834400 + (0x78 << 2))
+#define   P_PREG_STICKY_REG8                                   (volatile uint32_t *)(0xc8834400 + (0x78 << 2))
+#define     PREG_STICKY_REG9                                   (0xc8834400 + (0x79 << 2))
+#define SEC_PREG_STICKY_REG9                                   (0xda834400 + (0x79 << 2))
+#define   P_PREG_STICKY_REG9                                   (volatile uint32_t *)(0xc8834400 + (0x79 << 2))
+#define     PREG_WRITE_ONCE_REG                                (0xc8834400 + (0x7e << 2))
+#define SEC_PREG_WRITE_ONCE_REG                                (0xda834400 + (0x7e << 2))
+#define   P_PREG_WRITE_ONCE_REG                                (volatile uint32_t *)(0xc8834400 + (0x7e << 2))
+// ---------------------------
+// AM Ring Oscillator
+// ----------------------------
+#define     AM_RING_OSC_REG0                                   (0xc8834400 + (0x7f << 2))
+#define SEC_AM_RING_OSC_REG0                                   (0xda834400 + (0x7f << 2))
+#define   P_AM_RING_OSC_REG0                                   (volatile uint32_t *)(0xc8834400 + (0x7f << 2))
+// Control whether to provide random number to HDMITX20
+#define     HDMITX20_RNDNUM                                    (0xc8834400 + (0x80 << 2))
+#define SEC_HDMITX20_RNDNUM                                    (0xda834400 + (0x80 << 2))
+#define   P_HDMITX20_RNDNUM                                    (volatile uint32_t *)(0xc8834400 + (0x80 << 2))
+// ---------------------------
+// Bus Monitoring
+// ----------------------------
+#define     BUS_MONITOR_CNTL                                   (0xc8834400 + (0x81 << 2))
+#define SEC_BUS_MONITOR_CNTL                                   (0xda834400 + (0x81 << 2))
+#define   P_BUS_MONITOR_CNTL                                   (volatile uint32_t *)(0xc8834400 + (0x81 << 2))
+#define     BUS_MON0_ADDR                                      (0xc8834400 + (0x82 << 2))
+#define SEC_BUS_MON0_ADDR                                      (0xda834400 + (0x82 << 2))
+#define   P_BUS_MON0_ADDR                                      (volatile uint32_t *)(0xc8834400 + (0x82 << 2))
+#define     BUS_MON0_DATA                                      (0xc8834400 + (0x83 << 2))
+#define SEC_BUS_MON0_DATA                                      (0xda834400 + (0x83 << 2))
+#define   P_BUS_MON0_DATA                                      (volatile uint32_t *)(0xc8834400 + (0x83 << 2))
+#define     BUS_MON0_DATA_MSK                                  (0xc8834400 + (0x84 << 2))
+#define SEC_BUS_MON0_DATA_MSK                                  (0xda834400 + (0x84 << 2))
+#define   P_BUS_MON0_DATA_MSK                                  (volatile uint32_t *)(0xc8834400 + (0x84 << 2))
+#define     BUS_MON1_ADDR                                      (0xc8834400 + (0x85 << 2))
+#define SEC_BUS_MON1_ADDR                                      (0xda834400 + (0x85 << 2))
+#define   P_BUS_MON1_ADDR                                      (volatile uint32_t *)(0xc8834400 + (0x85 << 2))
+#define     BUS_MON1_DATA                                      (0xc8834400 + (0x86 << 2))
+#define SEC_BUS_MON1_DATA                                      (0xda834400 + (0x86 << 2))
+#define   P_BUS_MON1_DATA                                      (volatile uint32_t *)(0xc8834400 + (0x86 << 2))
+#define     BUS_MON1_DATA_MSK                                  (0xc8834400 + (0x87 << 2))
+#define SEC_BUS_MON1_DATA_MSK                                  (0xda834400 + (0x87 << 2))
+#define   P_BUS_MON1_DATA_MSK                                  (volatile uint32_t *)(0xc8834400 + (0x87 << 2))
+#define     ASYNC_FIFO_LOCK_ADR                                (0xc8834400 + (0x88 << 2))
+#define SEC_ASYNC_FIFO_LOCK_ADR                                (0xda834400 + (0x88 << 2))
+#define   P_ASYNC_FIFO_LOCK_ADR                                (volatile uint32_t *)(0xc8834400 + (0x88 << 2))
+#define     SECE_TIMER_CTRL                                    (0xc8834400 + (0x89 << 2))
+#define SEC_SECE_TIMER_CTRL                                    (0xda834400 + (0x89 << 2))
+#define   P_SECE_TIMER_CTRL                                    (volatile uint32_t *)(0xc8834400 + (0x89 << 2))
+#define     SECE_TIMER_LOW                                     (0xc8834400 + (0x8a << 2))
+#define SEC_SECE_TIMER_LOW                                     (0xda834400 + (0x8a << 2))
+#define   P_SECE_TIMER_LOW                                     (volatile uint32_t *)(0xc8834400 + (0x8a << 2))
+#define     SECE_TIMER_HIG                                     (0xc8834400 + (0x8b << 2))
+#define SEC_SECE_TIMER_HIG                                     (0xda834400 + (0x8b << 2))
+#define   P_SECE_TIMER_HIG                                     (volatile uint32_t *)(0xc8834400 + (0x8b << 2))
+// ---------------------------
+// System CPU control registers
+// ----------------------------
+#define     SYS_CPU_POR_CFG0                                   (0xc8834400 + (0x90 << 2))
+#define SEC_SYS_CPU_POR_CFG0                                   (0xda834400 + (0x90 << 2))
+#define   P_SYS_CPU_POR_CFG0                                   (volatile uint32_t *)(0xc8834400 + (0x90 << 2))
+#define     SYS_CPU_POR_CFG1                                   (0xc8834400 + (0x91 << 2))
+#define SEC_SYS_CPU_POR_CFG1                                   (0xda834400 + (0x91 << 2))
+#define   P_SYS_CPU_POR_CFG1                                   (volatile uint32_t *)(0xc8834400 + (0x91 << 2))
+#define     SYS_CPU_CFG0                                       (0xc8834400 + (0x92 << 2))
+#define SEC_SYS_CPU_CFG0                                       (0xda834400 + (0x92 << 2))
+#define   P_SYS_CPU_CFG0                                       (volatile uint32_t *)(0xc8834400 + (0x92 << 2))
+#define     SYS_CPU_CFG1                                       (0xc8834400 + (0x93 << 2))
+#define SEC_SYS_CPU_CFG1                                       (0xda834400 + (0x93 << 2))
+#define   P_SYS_CPU_CFG1                                       (volatile uint32_t *)(0xc8834400 + (0x93 << 2))
+#define     SYS_CPU_CFG2                                       (0xc8834400 + (0x94 << 2))
+#define SEC_SYS_CPU_CFG2                                       (0xda834400 + (0x94 << 2))
+#define   P_SYS_CPU_CFG2                                       (volatile uint32_t *)(0xc8834400 + (0x94 << 2))
+#define     SYS_CPU_CFG3                                       (0xc8834400 + (0x95 << 2))
+#define SEC_SYS_CPU_CFG3                                       (0xda834400 + (0x95 << 2))
+#define   P_SYS_CPU_CFG3                                       (volatile uint32_t *)(0xc8834400 + (0x95 << 2))
+#define     SYS_CPU_CFG4                                       (0xc8834400 + (0x96 << 2))
+#define SEC_SYS_CPU_CFG4                                       (0xda834400 + (0x96 << 2))
+#define   P_SYS_CPU_CFG4                                       (volatile uint32_t *)(0xc8834400 + (0x96 << 2))
+#define     SYS_CPU_CFG5                                       (0xc8834400 + (0x97 << 2))
+#define SEC_SYS_CPU_CFG5                                       (0xda834400 + (0x97 << 2))
+#define   P_SYS_CPU_CFG5                                       (volatile uint32_t *)(0xc8834400 + (0x97 << 2))
+#define     SYS_CPU_CFG6                                       (0xc8834400 + (0x98 << 2))
+#define SEC_SYS_CPU_CFG6                                       (0xda834400 + (0x98 << 2))
+#define   P_SYS_CPU_CFG6                                       (volatile uint32_t *)(0xc8834400 + (0x98 << 2))
+#define     SYS_CPU_CFG7                                       (0xc8834400 + (0x99 << 2))
+#define SEC_SYS_CPU_CFG7                                       (0xda834400 + (0x99 << 2))
+#define   P_SYS_CPU_CFG7                                       (volatile uint32_t *)(0xc8834400 + (0x99 << 2))
+#define     SYS_CPU_CFG8                                       (0xc8834400 + (0x9a << 2))
+#define SEC_SYS_CPU_CFG8                                       (0xda834400 + (0x9a << 2))
+#define   P_SYS_CPU_CFG8                                       (volatile uint32_t *)(0xc8834400 + (0x9a << 2))
+#define     SYS_CPU_CFG9                                       (0xc8834400 + (0x9b << 2))
+#define SEC_SYS_CPU_CFG9                                       (0xda834400 + (0x9b << 2))
+#define   P_SYS_CPU_CFG9                                       (volatile uint32_t *)(0xc8834400 + (0x9b << 2))
+#define     SYS_CPU_CFG10                                      (0xc8834400 + (0x9c << 2))
+#define SEC_SYS_CPU_CFG10                                      (0xda834400 + (0x9c << 2))
+#define   P_SYS_CPU_CFG10                                      (volatile uint32_t *)(0xc8834400 + (0x9c << 2))
+#define     SYS_CPU_CFG11                                      (0xc8834400 + (0x9d << 2))
+#define SEC_SYS_CPU_CFG11                                      (0xda834400 + (0x9d << 2))
+#define   P_SYS_CPU_CFG11                                      (volatile uint32_t *)(0xc8834400 + (0x9d << 2))
+#define     SYS_CPU_CFG12                                      (0xc8834400 + (0x9e << 2))
+#define SEC_SYS_CPU_CFG12                                      (0xda834400 + (0x9e << 2))
+#define   P_SYS_CPU_CFG12                                      (volatile uint32_t *)(0xc8834400 + (0x9e << 2))
+#define     SYS_CPU_CFG13                                      (0xc8834400 + (0x9f << 2))
+#define SEC_SYS_CPU_CFG13                                      (0xda834400 + (0x9f << 2))
+#define   P_SYS_CPU_CFG13                                      (volatile uint32_t *)(0xc8834400 + (0x9f << 2))
+#define     SYS_CPU_STATUS0                                    (0xc8834400 + (0xa0 << 2))
+#define SEC_SYS_CPU_STATUS0                                    (0xda834400 + (0xa0 << 2))
+#define   P_SYS_CPU_STATUS0                                    (volatile uint32_t *)(0xc8834400 + (0xa0 << 2))
+#define     SYS_CPU_STATUS1                                    (0xc8834400 + (0xa1 << 2))
+#define SEC_SYS_CPU_STATUS1                                    (0xda834400 + (0xa1 << 2))
+#define   P_SYS_CPU_STATUS1                                    (volatile uint32_t *)(0xc8834400 + (0xa1 << 2))
+#define     SYS_CPU_STATUS2                                    (0xc8834400 + (0xa2 << 2))
+#define SEC_SYS_CPU_STATUS2                                    (0xda834400 + (0xa2 << 2))
+#define   P_SYS_CPU_STATUS2                                    (volatile uint32_t *)(0xc8834400 + (0xa2 << 2))
+#define     SYS_CPU_STATUS3                                    (0xc8834400 + (0xa3 << 2))
+#define SEC_SYS_CPU_STATUS3                                    (0xda834400 + (0xa3 << 2))
+#define   P_SYS_CPU_STATUS3                                    (volatile uint32_t *)(0xc8834400 + (0xa3 << 2))
+#define     SYS_CPU_STATUS4                                    (0xc8834400 + (0xa4 << 2))
+#define SEC_SYS_CPU_STATUS4                                    (0xda834400 + (0xa4 << 2))
+#define   P_SYS_CPU_STATUS4                                    (volatile uint32_t *)(0xc8834400 + (0xa4 << 2))
+#define     SYS_CPU_STATUS5                                    (0xc8834400 + (0xa5 << 2))
+#define SEC_SYS_CPU_STATUS5                                    (0xda834400 + (0xa5 << 2))
+#define   P_SYS_CPU_STATUS5                                    (volatile uint32_t *)(0xc8834400 + (0xa5 << 2))
+#define     SYS_CPU_MISC                                       (0xc8834400 + (0xa8 << 2))
+#define SEC_SYS_CPU_MISC                                       (0xda834400 + (0xa8 << 2))
+#define   P_SYS_CPU_MISC                                       (volatile uint32_t *)(0xc8834400 + (0xa8 << 2))
+//========================================================================
+//  HIU - Registers
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hC883C000
+// APB4_DECODER_SECURE_BASE         32'hDA83C000
+#define     SCR_HIU                                            (0xc883c000 + (0x0b << 2))
+#define SEC_SCR_HIU                                            (0xda83c000 + (0x0b << 2))
+#define   P_SCR_HIU                                            (volatile uint32_t *)(0xc883c000 + (0x0b << 2))
+#define     HPG_TIMER                                          (0xc883c000 + (0x0f << 2))
+#define SEC_HPG_TIMER                                          (0xda83c000 + (0x0f << 2))
+#define   P_HPG_TIMER                                          (volatile uint32_t *)(0xc883c000 + (0x0f << 2))
+#define     HHI_GP0_PLL_CNTL                                   (0xc883c000 + (0x10 << 2))
+#define SEC_HHI_GP0_PLL_CNTL                                   (0xda83c000 + (0x10 << 2))
+#define   P_HHI_GP0_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x10 << 2))
+#define     HHI_GP0_PLL_CNTL2                                  (0xc883c000 + (0x11 << 2))
+#define SEC_HHI_GP0_PLL_CNTL2                                  (0xda83c000 + (0x11 << 2))
+#define   P_HHI_GP0_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x11 << 2))
+#define     HHI_GP0_PLL_CNTL3                                  (0xc883c000 + (0x12 << 2))
+#define SEC_HHI_GP0_PLL_CNTL3                                  (0xda83c000 + (0x12 << 2))
+#define   P_HHI_GP0_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x12 << 2))
+#define     HHI_GP0_PLL_CNTL4                                  (0xc883c000 + (0x13 << 2))
+#define SEC_HHI_GP0_PLL_CNTL4                                  (0xda83c000 + (0x13 << 2))
+#define   P_HHI_GP0_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0x13 << 2))
+#define     HHI_GP0_PLL_CNTL5                                  (0xc883c000 + (0x14 << 2))
+#define SEC_HHI_GP0_PLL_CNTL5                                  (0xda83c000 + (0x14 << 2))
+#define   P_HHI_GP0_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x14 << 2))
+#define     HHI_GP0_PLL_STS                                    (0xc883c000 + (0x15 << 2))
+#define SEC_HHI_GP0_PLL_STS                                    (0xda83c000 + (0x15 << 2))
+#define   P_HHI_GP0_PLL_STS                                    (volatile uint32_t *)(0xc883c000 + (0x15 << 2))
+#define     HHI_GP0_PLL_CNTL1                                  (0xc883c000 + (0x16 << 2))
+#define SEC_HHI_GP0_PLL_CNTL1                                  (0xda83c000 + (0x16 << 2))
+#define   P_HHI_GP0_PLL_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0x16 << 2))
+#define     HHI_GP1_PLL_CNTL                                   (0xc883c000 + (0x18 << 2))
+#define SEC_HHI_GP1_PLL_CNTL                                   (0xda83c000 + (0x18 << 2))
+#define   P_HHI_GP1_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x18 << 2))
+#define     HHI_GP1_PLL_CNTL2                                  (0xc883c000 + (0x19 << 2))
+#define SEC_HHI_GP1_PLL_CNTL2                                  (0xda83c000 + (0x19 << 2))
+#define   P_HHI_GP1_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x19 << 2))
+#define     HHI_GP1_PLL_CNTL3                                  (0xc883c000 + (0x1a << 2))
+#define SEC_HHI_GP1_PLL_CNTL3                                  (0xda83c000 + (0x1a << 2))
+#define   P_HHI_GP1_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x1a << 2))
+#define     HHI_GP1_PLL_CNTL4                                  (0xc883c000 + (0x1b << 2))
+#define SEC_HHI_GP1_PLL_CNTL4                                  (0xda83c000 + (0x1b << 2))
+#define   P_HHI_GP1_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0x1b << 2))
+#define     HHI_GP1_PLL_CNTL5                                  (0xc883c000 + (0x1c << 2))
+#define SEC_HHI_GP1_PLL_CNTL5                                  (0xda83c000 + (0x1c << 2))
+#define   P_HHI_GP1_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x1c << 2))
+#define     HHI_GP1_PLL_STS                                    (0xc883c000 + (0x1d << 2))
+#define SEC_HHI_GP1_PLL_STS                                    (0xda83c000 + (0x1d << 2))
+#define   P_HHI_GP1_PLL_STS                                    (volatile uint32_t *)(0xc883c000 + (0x1d << 2))
+#define     HHI_GP1_PLL_CNTL1                                  (0xc883c000 + (0x1e << 2))
+#define SEC_HHI_GP1_PLL_CNTL1                                  (0xda83c000 + (0x1e << 2))
+#define   P_HHI_GP1_PLL_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0x1e << 2))
+#define     HHI_CADC_CNTL                                      (0xc883c000 + (0x20 << 2))
+#define SEC_HHI_CADC_CNTL                                      (0xda83c000 + (0x20 << 2))
+#define   P_HHI_CADC_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0x20 << 2))
+#define     HHI_CADC_CNTL2                                     (0xc883c000 + (0x21 << 2))
+#define SEC_HHI_CADC_CNTL2                                     (0xda83c000 + (0x21 << 2))
+#define   P_HHI_CADC_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0x21 << 2))
+#define     HHI_CADC_CNTL3                                     (0xc883c000 + (0x22 << 2))
+#define SEC_HHI_CADC_CNTL3                                     (0xda83c000 + (0x22 << 2))
+#define   P_HHI_CADC_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0x22 << 2))
+#define     HHI_CADC_CNTL4                                     (0xc883c000 + (0x23 << 2))
+#define SEC_HHI_CADC_CNTL4                                     (0xda83c000 + (0x23 << 2))
+#define   P_HHI_CADC_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0x23 << 2))
+#define     HHI_CADC_CNTL5                                     (0xc883c000 + (0x24 << 2))
+#define SEC_HHI_CADC_CNTL5                                     (0xda83c000 + (0x24 << 2))
+#define   P_HHI_CADC_CNTL5                                     (volatile uint32_t *)(0xc883c000 + (0x24 << 2))
+#define     HHI_CADC_CNTL6                                     (0xc883c000 + (0x25 << 2))
+#define SEC_HHI_CADC_CNTL6                                     (0xda83c000 + (0x25 << 2))
+#define   P_HHI_CADC_CNTL6                                     (volatile uint32_t *)(0xc883c000 + (0x25 << 2))
+#define     HHI_DADC_CNTL                                      (0xc883c000 + (0x27 << 2))
+#define SEC_HHI_DADC_CNTL                                      (0xda83c000 + (0x27 << 2))
+#define   P_HHI_DADC_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0x27 << 2))
+#define     HHI_DADC_CNTL2                                     (0xc883c000 + (0x28 << 2))
+#define SEC_HHI_DADC_CNTL2                                     (0xda83c000 + (0x28 << 2))
+#define   P_HHI_DADC_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0x28 << 2))
+#define     HHI_DADC_RDBK0_I                                   (0xc883c000 + (0x29 << 2))
+#define SEC_HHI_DADC_RDBK0_I                                   (0xda83c000 + (0x29 << 2))
+#define   P_HHI_DADC_RDBK0_I                                   (volatile uint32_t *)(0xc883c000 + (0x29 << 2))
+#define     HHI_DADC_CNTL3                                     (0xc883c000 + (0x2a << 2))
+#define SEC_HHI_DADC_CNTL3                                     (0xda83c000 + (0x2a << 2))
+#define   P_HHI_DADC_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0x2a << 2))
+#define     HHI_DADC_CNTL4                                     (0xc883c000 + (0x2b << 2))
+#define SEC_HHI_DADC_CNTL4                                     (0xda83c000 + (0x2b << 2))
+#define   P_HHI_DADC_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0x2b << 2))
+#define     HHI_AFE_TUNNING_CNTL                               (0xc883c000 + (0x2c << 2))
+#define SEC_HHI_AFE_TUNNING_CNTL                               (0xda83c000 + (0x2c << 2))
+#define   P_HHI_AFE_TUNNING_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x2c << 2))
+#define     HHI_AFE_TUNNING_CNTL_I                             (0xc883c000 + (0x2d << 2))
+#define SEC_HHI_AFE_TUNNING_CNTL_I                             (0xda83c000 + (0x2d << 2))
+#define   P_HHI_AFE_TUNNING_CNTL_I                             (volatile uint32_t *)(0xc883c000 + (0x2d << 2))
+#define     HHI_XTAL_DIVN_CNTL                                 (0xc883c000 + (0x2f << 2))
+#define SEC_HHI_XTAL_DIVN_CNTL                                 (0xda83c000 + (0x2f << 2))
+#define   P_HHI_XTAL_DIVN_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x2f << 2))
+#define     HHI_GCLK2_MPEG0                                    (0xc883c000 + (0x30 << 2))
+#define SEC_HHI_GCLK2_MPEG0                                    (0xda83c000 + (0x30 << 2))
+#define   P_HHI_GCLK2_MPEG0                                    (volatile uint32_t *)(0xc883c000 + (0x30 << 2))
+#define     HHI_GCLK2_MPEG1                                    (0xc883c000 + (0x31 << 2))
+#define SEC_HHI_GCLK2_MPEG1                                    (0xda83c000 + (0x31 << 2))
+#define   P_HHI_GCLK2_MPEG1                                    (volatile uint32_t *)(0xc883c000 + (0x31 << 2))
+#define     HHI_GCLK2_MPEG2                                    (0xc883c000 + (0x32 << 2))
+#define SEC_HHI_GCLK2_MPEG2                                    (0xda83c000 + (0x32 << 2))
+#define   P_HHI_GCLK2_MPEG2                                    (volatile uint32_t *)(0xc883c000 + (0x32 << 2))
+#define     HHI_GCLK2_OTHER                                    (0xc883c000 + (0x34 << 2))
+#define SEC_HHI_GCLK2_OTHER                                    (0xda83c000 + (0x34 << 2))
+#define   P_HHI_GCLK2_OTHER                                    (volatile uint32_t *)(0xc883c000 + (0x34 << 2))
+#define     HHI_GCLK2_AO                                       (0xc883c000 + (0x35 << 2))
+#define SEC_HHI_GCLK2_AO                                       (0xda83c000 + (0x35 << 2))
+#define   P_HHI_GCLK2_AO                                       (volatile uint32_t *)(0xc883c000 + (0x35 << 2))
+#define     HHI_TIMER90K                                       (0xc883c000 + (0x3b << 2))
+#define SEC_HHI_TIMER90K                                       (0xda83c000 + (0x3b << 2))
+#define   P_HHI_TIMER90K                                       (volatile uint32_t *)(0xc883c000 + (0x3b << 2))
+#define     HHI_MEM_PD_REG0                                    (0xc883c000 + (0x40 << 2))
+#define SEC_HHI_MEM_PD_REG0                                    (0xda83c000 + (0x40 << 2))
+#define   P_HHI_MEM_PD_REG0                                    (volatile uint32_t *)(0xc883c000 + (0x40 << 2))
+//VIU1
+//bit 29:28 mem_pd_vi_sharp,  2'b00: Sharpness line buffer memory power on, 2'b11: power down
+//bit 29:28 mem_pd_vi_dipost, 2'b00: Deinterlace - di_post memory power on, 2'b11: power down
+//bit 27:26 mem_pd_vi_dipre,  2'b00: Deinterlace - di_pre memory power on, 2'b11: power down
+//bit 25:24 mem_pd_vi_prot3,  2'b00: picture rotation3 memory power on, 2'b11: power down
+//bit 23:22 mem_pd_vi_prot2,  2'b00: picture rotation2 memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vi_prot1,  2'b00: picture rotation1 memory power on, 2'b11: power down
+//bit 19:18 mem_pd_vi_vdin1,  2'b00: vdin1 memory power on, 2'b11: power down
+//bit 17:16 mem_pd_vi_vdin0,  2'b00: vdin0 memory power on, 2'b11: power down
+//bit 15:14 mem_pd_vi_osd_sc, 2'b00: osd_scaler memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi_scale,  2'b00: scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi_ofifo,  2'b00: vpp output fifo memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi_chroma, 2'b00: color management module memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi_vd2,    2'b00: vd2 memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi_vd1,    2'b00: vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi_osd2,   2'b00: osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi_osd1,   2'b00: osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG0                                (0xc883c000 + (0x41 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG0                                (0xda83c000 + (0x41 << 2))
+#define   P_HHI_VPU_MEM_PD_REG0                                (volatile uint32_t *)(0xc883c000 + (0x41 << 2))
+//bit 29:28 mem_pd_atv_dmd,   2'b00: ATV DMD memory power on, 2'b11: power down
+//bit 29:28 mem_pd_cvd2,      2'b00: CVD2 memory power on, 2'b11: power down
+//bit 27:26 mem_pd_isp,       2'b00: ISP memory power on, 2'b11: power down
+//bit 25:24 mem_pd_venci_int, 2'b00: cvbs- enci interface memory power on, 2'b11: power down
+//bit 23:22 mem_pd_venc_l_top,2'b00: panel - encl top memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vencp_int, 2'b00: hdmi - encp interface memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi2_osd_sc,2'b00: viu2 OSD scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi2_scale, 2'b00: viu2 scaler memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi2_ofifo, 2'b00: viu2 vpp output fifo memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi2_chroma,2'b00: viu2 color management module memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi2_vd1,   2'b00: viu2 vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi2_osd2,  2'b00: viu2 osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi2_osd1,  2'b00: viu2 osd1 memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG1                                (0xc883c000 + (0x42 << 2))
+#define SEC_HHI_VPU_MEM_PD_REG1                                (0xda83c000 + (0x42 << 2))
+#define   P_HHI_VPU_MEM_PD_REG1                                (volatile uint32_t *)(0xc883c000 + (0x42 << 2))
+#define     HHI_DEMOD_MEM_PD_REG                               (0xc883c000 + (0x43 << 2))
+#define SEC_HHI_DEMOD_MEM_PD_REG                               (0xda83c000 + (0x43 << 2))
+#define   P_HHI_DEMOD_MEM_PD_REG                               (volatile uint32_t *)(0xc883c000 + (0x43 << 2))
+#define     HHI_AUD_DAC_CTRL                                   (0xc883c000 + (0x44 << 2))
+#define SEC_HHI_AUD_DAC_CTRL                                   (0xda83c000 + (0x44 << 2))
+#define   P_HHI_AUD_DAC_CTRL                                   (volatile uint32_t *)(0xc883c000 + (0x44 << 2))
+// `define HHI_VIID_PLL_CNTL4      8'h46 // video PLL read back
+// `define HHI_VIID_PLL_CNTL       8'h47 // Video PLL control, word 1
+// `define HHI_VIID_PLL_CNTL2      8'h48 // Video PLL control, word 2
+// `define HHI_VIID_PLL_CNTL3      8'h49 // Video PLL control, word 3
+#define     HHI_VIID_CLK_DIV                                   (0xc883c000 + (0x4a << 2))
+#define SEC_HHI_VIID_CLK_DIV                                   (0xda83c000 + (0x4a << 2))
+#define   P_HHI_VIID_CLK_DIV                                   (volatile uint32_t *)(0xc883c000 + (0x4a << 2))
+#define     HHI_VIID_CLK_CNTL                                  (0xc883c000 + (0x4b << 2))
+#define SEC_HHI_VIID_CLK_CNTL                                  (0xda83c000 + (0x4b << 2))
+#define   P_HHI_VIID_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x4b << 2))
+#define     HHI_VIID_DIVIDER_CNTL                              (0xc883c000 + (0x4c << 2))
+#define SEC_HHI_VIID_DIVIDER_CNTL                              (0xda83c000 + (0x4c << 2))
+#define   P_HHI_VIID_DIVIDER_CNTL                              (volatile uint32_t *)(0xc883c000 + (0x4c << 2))
+//bit 1:0   mem_pd_vi_wm,  2'b00: viu1 wm memory power on, 2'b11: power down
+#define     HHI_VPU_MEM_PD_REG2                                (0xc883c000 + (0x4d << 2))
+#define SEC_HHI_VPU_MEM_PD_REG2                                (0xda83c000 + (0x4d << 2))
+#define   P_HHI_VPU_MEM_PD_REG2                                (volatile uint32_t *)(0xc883c000 + (0x4d << 2))
+// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
+#define     HHI_GCLK_MPEG0                                     (0xc883c000 + (0x50 << 2))
+#define SEC_HHI_GCLK_MPEG0                                     (0xda83c000 + (0x50 << 2))
+#define   P_HHI_GCLK_MPEG0                                     (volatile uint32_t *)(0xc883c000 + (0x50 << 2))
+#define     HHI_GCLK_MPEG1                                     (0xc883c000 + (0x51 << 2))
+#define SEC_HHI_GCLK_MPEG1                                     (0xda83c000 + (0x51 << 2))
+#define   P_HHI_GCLK_MPEG1                                     (volatile uint32_t *)(0xc883c000 + (0x51 << 2))
+#define     HHI_GCLK_MPEG2                                     (0xc883c000 + (0x52 << 2))
+#define SEC_HHI_GCLK_MPEG2                                     (0xda83c000 + (0x52 << 2))
+#define   P_HHI_GCLK_MPEG2                                     (volatile uint32_t *)(0xc883c000 + (0x52 << 2))
+#define     HHI_GCLK_OTHER                                     (0xc883c000 + (0x54 << 2))
+#define SEC_HHI_GCLK_OTHER                                     (0xda83c000 + (0x54 << 2))
+#define   P_HHI_GCLK_OTHER                                     (volatile uint32_t *)(0xc883c000 + (0x54 << 2))
+#define     HHI_GCLK_AO                                        (0xc883c000 + (0x55 << 2))
+#define SEC_HHI_GCLK_AO                                        (0xda83c000 + (0x55 << 2))
+#define   P_HHI_GCLK_AO                                        (volatile uint32_t *)(0xc883c000 + (0x55 << 2))
+//`define HHI_SYS_OSCIN_CNTL      8'h56
+#define     HHI_SYS_CPU_CLK_CNTL1                              (0xc883c000 + (0x57 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL1                              (0xda83c000 + (0x57 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0x57 << 2))
+#define     HHI_SYS_CPU_RESET_CNTL                             (0xc883c000 + (0x58 << 2))
+#define SEC_HHI_SYS_CPU_RESET_CNTL                             (0xda83c000 + (0x58 << 2))
+#define   P_HHI_SYS_CPU_RESET_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x58 << 2))
+// PLL Controls
+#define     HHI_VID_CLK_DIV                                    (0xc883c000 + (0x59 << 2))
+#define SEC_HHI_VID_CLK_DIV                                    (0xda83c000 + (0x59 << 2))
+#define   P_HHI_VID_CLK_DIV                                    (volatile uint32_t *)(0xc883c000 + (0x59 << 2))
+#define     HHI_MPEG_CLK_CNTL                                  (0xc883c000 + (0x5d << 2))
+#define SEC_HHI_MPEG_CLK_CNTL                                  (0xda83c000 + (0x5d << 2))
+#define   P_HHI_MPEG_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x5d << 2))
+#define     HHI_AUD_CLK_CNTL                                   (0xc883c000 + (0x5e << 2))
+#define SEC_HHI_AUD_CLK_CNTL                                   (0xda83c000 + (0x5e << 2))
+#define   P_HHI_AUD_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x5e << 2))
+#define     HHI_VID_CLK_CNTL                                   (0xc883c000 + (0x5f << 2))
+#define SEC_HHI_VID_CLK_CNTL                                   (0xda83c000 + (0x5f << 2))
+#define   P_HHI_VID_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x5f << 2))
+#define     HHI_WIFI_CLK_CNTL                                  (0xc883c000 + (0x60 << 2))
+#define SEC_HHI_WIFI_CLK_CNTL                                  (0xda83c000 + (0x60 << 2))
+#define   P_HHI_WIFI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x60 << 2))
+#define     HHI_WIFI_PLL_CNTL                                  (0xc883c000 + (0x61 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL                                  (0xda83c000 + (0x61 << 2))
+#define   P_HHI_WIFI_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x61 << 2))
+#define     HHI_WIFI_PLL_CNTL2                                 (0xc883c000 + (0x62 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL2                                 (0xda83c000 + (0x62 << 2))
+#define   P_HHI_WIFI_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0x62 << 2))
+#define     HHI_WIFI_PLL_CNTL3                                 (0xc883c000 + (0x63 << 2))
+#define SEC_HHI_WIFI_PLL_CNTL3                                 (0xda83c000 + (0x63 << 2))
+#define   P_HHI_WIFI_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0x63 << 2))
+#define     HHI_AUD_CLK_CNTL2                                  (0xc883c000 + (0x64 << 2))
+#define SEC_HHI_AUD_CLK_CNTL2                                  (0xda83c000 + (0x64 << 2))
+#define   P_HHI_AUD_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x64 << 2))
+#define     HHI_VID_CLK_CNTL2                                  (0xc883c000 + (0x65 << 2))
+#define SEC_HHI_VID_CLK_CNTL2                                  (0xda83c000 + (0x65 << 2))
+#define   P_HHI_VID_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x65 << 2))
+#define     HHI_VID_DIVIDER_CNTL                               (0xc883c000 + (0x66 << 2))
+#define SEC_HHI_VID_DIVIDER_CNTL                               (0xda83c000 + (0x66 << 2))
+#define   P_HHI_VID_DIVIDER_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x66 << 2))
+#define     HHI_SYS_CPU_CLK_CNTL                               (0xc883c000 + (0x67 << 2))
+#define SEC_HHI_SYS_CPU_CLK_CNTL                               (0xda83c000 + (0x67 << 2))
+#define   P_HHI_SYS_CPU_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x67 << 2))
+#define     HHI_VID_PLL_CLK_DIV                                (0xc883c000 + (0x68 << 2))
+#define SEC_HHI_VID_PLL_CLK_DIV                                (0xda83c000 + (0x68 << 2))
+#define   P_HHI_VID_PLL_CLK_DIV                                (volatile uint32_t *)(0xc883c000 + (0x68 << 2))
+#define     HHI_AUD_CLK_CNTL3                                  (0xc883c000 + (0x69 << 2))
+#define SEC_HHI_AUD_CLK_CNTL3                                  (0xda83c000 + (0x69 << 2))
+#define   P_HHI_AUD_CLK_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0x69 << 2))
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL        8'h68 // DDR PLL control, word 1
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL2       8'h69 // DDR PLL control, word 2
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL3       8'h6a // DDR PLL control, word 3
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL4       8'h6b // DDR PLL control, word 3
+#define     HHI_MALI_CLK_CNTL                                  (0xc883c000 + (0x6c << 2))
+#define SEC_HHI_MALI_CLK_CNTL                                  (0xda83c000 + (0x6c << 2))
+#define   P_HHI_MALI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x6c << 2))
+#define     HHI_MIPI_PHY_CLK_CNTL                              (0xc883c000 + (0x6e << 2))
+#define SEC_HHI_MIPI_PHY_CLK_CNTL                              (0xda83c000 + (0x6e << 2))
+#define   P_HHI_MIPI_PHY_CLK_CNTL                              (volatile uint32_t *)(0xc883c000 + (0x6e << 2))
+#define     HHI_VPU_CLK_CNTL                                   (0xc883c000 + (0x6f << 2))
+#define SEC_HHI_VPU_CLK_CNTL                                   (0xda83c000 + (0x6f << 2))
+#define   P_HHI_VPU_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x6f << 2))
+#define     HHI_OTHER_PLL_CNTL                                 (0xc883c000 + (0x70 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL                                 (0xda83c000 + (0x70 << 2))
+#define   P_HHI_OTHER_PLL_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x70 << 2))
+#define     HHI_OTHER_PLL_CNTL2                                (0xc883c000 + (0x71 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL2                                (0xda83c000 + (0x71 << 2))
+#define   P_HHI_OTHER_PLL_CNTL2                                (volatile uint32_t *)(0xc883c000 + (0x71 << 2))
+#define     HHI_OTHER_PLL_CNTL3                                (0xc883c000 + (0x72 << 2))
+#define SEC_HHI_OTHER_PLL_CNTL3                                (0xda83c000 + (0x72 << 2))
+#define   P_HHI_OTHER_PLL_CNTL3                                (volatile uint32_t *)(0xc883c000 + (0x72 << 2))
+#define     HHI_HDMI_CLK_CNTL                                  (0xc883c000 + (0x73 << 2))
+#define SEC_HHI_HDMI_CLK_CNTL                                  (0xda83c000 + (0x73 << 2))
+#define   P_HHI_HDMI_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x73 << 2))
+#define     HHI_DEMOD_CLK_CNTL                                 (0xc883c000 + (0x74 << 2))
+#define SEC_HHI_DEMOD_CLK_CNTL                                 (0xda83c000 + (0x74 << 2))
+#define   P_HHI_DEMOD_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x74 << 2))
+#define     HHI_SATA_CLK_CNTL                                  (0xc883c000 + (0x75 << 2))
+#define SEC_HHI_SATA_CLK_CNTL                                  (0xda83c000 + (0x75 << 2))
+#define   P_HHI_SATA_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x75 << 2))
+#define     HHI_ETH_CLK_CNTL                                   (0xc883c000 + (0x76 << 2))
+#define SEC_HHI_ETH_CLK_CNTL                                   (0xda83c000 + (0x76 << 2))
+#define   P_HHI_ETH_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x76 << 2))
+#define     HHI_CLK_DOUBLE_CNTL                                (0xc883c000 + (0x77 << 2))
+#define SEC_HHI_CLK_DOUBLE_CNTL                                (0xda83c000 + (0x77 << 2))
+#define   P_HHI_CLK_DOUBLE_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x77 << 2))
+#define     HHI_VDEC_CLK_CNTL                                  (0xc883c000 + (0x78 << 2))
+#define SEC_HHI_VDEC_CLK_CNTL                                  (0xda83c000 + (0x78 << 2))
+#define   P_HHI_VDEC_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x78 << 2))
+#define     HHI_VDEC2_CLK_CNTL                                 (0xc883c000 + (0x79 << 2))
+#define SEC_HHI_VDEC2_CLK_CNTL                                 (0xda83c000 + (0x79 << 2))
+#define   P_HHI_VDEC2_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x79 << 2))
+#define     HHI_VDEC3_CLK_CNTL                                 (0xc883c000 + (0x7a << 2))
+#define SEC_HHI_VDEC3_CLK_CNTL                                 (0xda83c000 + (0x7a << 2))
+#define   P_HHI_VDEC3_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x7a << 2))
+#define     HHI_VDEC4_CLK_CNTL                                 (0xc883c000 + (0x7b << 2))
+#define SEC_HHI_VDEC4_CLK_CNTL                                 (0xda83c000 + (0x7b << 2))
+#define   P_HHI_VDEC4_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0x7b << 2))
+#define     HHI_HDCP22_CLK_CNTL                                (0xc883c000 + (0x7c << 2))
+#define SEC_HHI_HDCP22_CLK_CNTL                                (0xda83c000 + (0x7c << 2))
+#define   P_HHI_HDCP22_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x7c << 2))
+#define     HHI_VAPBCLK_CNTL                                   (0xc883c000 + (0x7d << 2))
+#define SEC_HHI_VAPBCLK_CNTL                                   (0xda83c000 + (0x7d << 2))
+#define   P_HHI_VAPBCLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x7d << 2))
+#define     HHI_VP9DEC_CLK_CNTL                                (0xc883c000 + (0x7e << 2))
+#define SEC_HHI_VP9DEC_CLK_CNTL                                (0xda83c000 + (0x7e << 2))
+#define   P_HHI_VP9DEC_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x7e << 2))
+// `define HHI_SYS_CPU_AUTO_CLK0        8'h78   never used
+// `define HHI_SYS_CPU_AUTO_CLK1        8'h79   never used
+// `define HHI_MEDIA_CPU_AUTO_CLK0    8'h7a     never used
+// `define HHI_MEDIA_CPU_AUTO_CLK1    8'h7b     never used
+#define     HHI_HDMI_AFC_CNTL                                  (0xc883c000 + (0x7f << 2))
+#define SEC_HHI_HDMI_AFC_CNTL                                  (0xda83c000 + (0x7f << 2))
+#define   P_HHI_HDMI_AFC_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x7f << 2))
+#define     HHI_HDMIRX_CLK_CNTL                                (0xc883c000 + (0x80 << 2))
+#define SEC_HHI_HDMIRX_CLK_CNTL                                (0xda83c000 + (0x80 << 2))
+#define   P_HHI_HDMIRX_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x80 << 2))
+#define     HHI_HDMIRX_AUD_CLK_CNTL                            (0xc883c000 + (0x81 << 2))
+#define SEC_HHI_HDMIRX_AUD_CLK_CNTL                            (0xda83c000 + (0x81 << 2))
+#define   P_HHI_HDMIRX_AUD_CLK_CNTL                            (volatile uint32_t *)(0xc883c000 + (0x81 << 2))
+#define     HHI_EDP_APB_CLK_CNTL                               (0xc883c000 + (0x82 << 2))
+#define SEC_HHI_EDP_APB_CLK_CNTL                               (0xda83c000 + (0x82 << 2))
+#define   P_HHI_EDP_APB_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x82 << 2))
+#define     HHI_VPU_CLKB_CNTL                                  (0xc883c000 + (0x83 << 2))
+#define SEC_HHI_VPU_CLKB_CNTL                                  (0xda83c000 + (0x83 << 2))
+#define   P_HHI_VPU_CLKB_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x83 << 2))
+#define     HHI_VID_PLL_MOD_CNTL0                              (0xc883c000 + (0x84 << 2))
+#define SEC_HHI_VID_PLL_MOD_CNTL0                              (0xda83c000 + (0x84 << 2))
+#define   P_HHI_VID_PLL_MOD_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0x84 << 2))
+#define     HHI_VID_PLL_MOD_LOW_TCNT                           (0xc883c000 + (0x85 << 2))
+#define SEC_HHI_VID_PLL_MOD_LOW_TCNT                           (0xda83c000 + (0x85 << 2))
+#define   P_HHI_VID_PLL_MOD_LOW_TCNT                           (volatile uint32_t *)(0xc883c000 + (0x85 << 2))
+#define     HHI_VID_PLL_MOD_HIGH_TCNT                          (0xc883c000 + (0x86 << 2))
+#define SEC_HHI_VID_PLL_MOD_HIGH_TCNT                          (0xda83c000 + (0x86 << 2))
+#define   P_HHI_VID_PLL_MOD_HIGH_TCNT                          (volatile uint32_t *)(0xc883c000 + (0x86 << 2))
+#define     HHI_VID_PLL_MOD_NOM_TCNT                           (0xc883c000 + (0x87 << 2))
+#define SEC_HHI_VID_PLL_MOD_NOM_TCNT                           (0xda83c000 + (0x87 << 2))
+#define   P_HHI_VID_PLL_MOD_NOM_TCNT                           (volatile uint32_t *)(0xc883c000 + (0x87 << 2))
+#define     HHI_USB_CLK_CNTL                                   (0xc883c000 + (0x88 << 2))
+#define SEC_HHI_USB_CLK_CNTL                                   (0xda83c000 + (0x88 << 2))
+#define   P_HHI_USB_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x88 << 2))
+// Removed `define HHI_DDR_CLK_CNTL            8'h88
+#define     HHI_32K_CLK_CNTL                                   (0xc883c000 + (0x89 << 2))
+#define SEC_HHI_32K_CLK_CNTL                                   (0xda83c000 + (0x89 << 2))
+#define   P_HHI_32K_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x89 << 2))
+#define     HHI_GEN_CLK_CNTL                                   (0xc883c000 + (0x8a << 2))
+#define SEC_HHI_GEN_CLK_CNTL                                   (0xda83c000 + (0x8a << 2))
+#define   P_HHI_GEN_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x8a << 2))
+#define     HHI_GEN_CLK_CNTL2                                  (0xc883c000 + (0x8b << 2))
+#define SEC_HHI_GEN_CLK_CNTL2                                  (0xda83c000 + (0x8b << 2))
+#define   P_HHI_GEN_CLK_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0x8b << 2))
+#define     HHI_JTAG_CONFIG                                    (0xc883c000 + (0x8e << 2))
+#define SEC_HHI_JTAG_CONFIG                                    (0xda83c000 + (0x8e << 2))
+#define   P_HHI_JTAG_CONFIG                                    (volatile uint32_t *)(0xc883c000 + (0x8e << 2))
+#define     HHI_VAFE_CLKXTALIN_CNTL                            (0xc883c000 + (0x8f << 2))
+#define SEC_HHI_VAFE_CLKXTALIN_CNTL                            (0xda83c000 + (0x8f << 2))
+#define   P_HHI_VAFE_CLKXTALIN_CNTL                            (volatile uint32_t *)(0xc883c000 + (0x8f << 2))
+#define     HHI_VAFE_CLKOSCIN_CNTL                             (0xc883c000 + (0x90 << 2))
+#define SEC_HHI_VAFE_CLKOSCIN_CNTL                             (0xda83c000 + (0x90 << 2))
+#define   P_HHI_VAFE_CLKOSCIN_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x90 << 2))
+#define     HHI_VAFE_CLKIN_CNTL                                (0xc883c000 + (0x91 << 2))
+#define SEC_HHI_VAFE_CLKIN_CNTL                                (0xda83c000 + (0x91 << 2))
+#define   P_HHI_VAFE_CLKIN_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x91 << 2))
+#define     HHI_TVFE_AUTOMODE_CLK_CNTL                         (0xc883c000 + (0x92 << 2))
+#define SEC_HHI_TVFE_AUTOMODE_CLK_CNTL                         (0xda83c000 + (0x92 << 2))
+#define   P_HHI_TVFE_AUTOMODE_CLK_CNTL                         (volatile uint32_t *)(0xc883c000 + (0x92 << 2))
+#define     HHI_VAFE_CLKPI_CNTL                                (0xc883c000 + (0x93 << 2))
+#define SEC_HHI_VAFE_CLKPI_CNTL                                (0xda83c000 + (0x93 << 2))
+#define   P_HHI_VAFE_CLKPI_CNTL                                (volatile uint32_t *)(0xc883c000 + (0x93 << 2))
+#define     HHI_VDIN_MEAS_CLK_CNTL                             (0xc883c000 + (0x94 << 2))
+#define SEC_HHI_VDIN_MEAS_CLK_CNTL                             (0xda83c000 + (0x94 << 2))
+#define   P_HHI_VDIN_MEAS_CLK_CNTL                             (volatile uint32_t *)(0xc883c000 + (0x94 << 2))
+// `define HHI_PCM2_CLK_CNTL           8'h95
+#define     HHI_PCM_CLK_CNTL                                   (0xc883c000 + (0x96 << 2))
+#define SEC_HHI_PCM_CLK_CNTL                                   (0xda83c000 + (0x96 << 2))
+#define   P_HHI_PCM_CLK_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0x96 << 2))
+#define     HHI_NAND_CLK_CNTL                                  (0xc883c000 + (0x97 << 2))
+#define SEC_HHI_NAND_CLK_CNTL                                  (0xda83c000 + (0x97 << 2))
+#define   P_HHI_NAND_CLK_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0x97 << 2))
+#define     HHI_ISP_LED_CLK_CNTL                               (0xc883c000 + (0x98 << 2))
+#define SEC_HHI_ISP_LED_CLK_CNTL                               (0xda83c000 + (0x98 << 2))
+#define   P_HHI_ISP_LED_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x98 << 2))
+#define     HHI_SD_EMMC_CLK_CNTL                               (0xc883c000 + (0x99 << 2))
+#define SEC_HHI_SD_EMMC_CLK_CNTL                               (0xda83c000 + (0x99 << 2))
+#define   P_HHI_SD_EMMC_CLK_CNTL                               (volatile uint32_t *)(0xc883c000 + (0x99 << 2))
+#define     HHI_EDP_TX_PHY_CNTL0                               (0xc883c000 + (0x9c << 2))
+#define SEC_HHI_EDP_TX_PHY_CNTL0                               (0xda83c000 + (0x9c << 2))
+#define   P_HHI_EDP_TX_PHY_CNTL0                               (volatile uint32_t *)(0xc883c000 + (0x9c << 2))
+#define     HHI_EDP_TX_PHY_CNTL1                               (0xc883c000 + (0x9d << 2))
+#define SEC_HHI_EDP_TX_PHY_CNTL1                               (0xda83c000 + (0x9d << 2))
+#define   P_HHI_EDP_TX_PHY_CNTL1                               (volatile uint32_t *)(0xc883c000 + (0x9d << 2))
+#define     HHI_ADC_PLL_CNTL5                                  (0xc883c000 + (0x9e << 2))
+#define SEC_HHI_ADC_PLL_CNTL5                                  (0xda83c000 + (0x9e << 2))
+#define   P_HHI_ADC_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0x9e << 2))
+#define     HHI_ADC_PLL_CNTL6                                  (0xc883c000 + (0x9f << 2))
+#define SEC_HHI_ADC_PLL_CNTL6                                  (0xda83c000 + (0x9f << 2))
+#define   P_HHI_ADC_PLL_CNTL6                                  (volatile uint32_t *)(0xc883c000 + (0x9f << 2))
+#define     HHI_MPLL_CNTL                                      (0xc883c000 + (0xa0 << 2))
+#define SEC_HHI_MPLL_CNTL                                      (0xda83c000 + (0xa0 << 2))
+#define   P_HHI_MPLL_CNTL                                      (volatile uint32_t *)(0xc883c000 + (0xa0 << 2))
+#define     HHI_MPLL_CNTL2                                     (0xc883c000 + (0xa1 << 2))
+#define SEC_HHI_MPLL_CNTL2                                     (0xda83c000 + (0xa1 << 2))
+#define   P_HHI_MPLL_CNTL2                                     (volatile uint32_t *)(0xc883c000 + (0xa1 << 2))
+#define     HHI_MPLL_CNTL3                                     (0xc883c000 + (0xa2 << 2))
+#define SEC_HHI_MPLL_CNTL3                                     (0xda83c000 + (0xa2 << 2))
+#define   P_HHI_MPLL_CNTL3                                     (volatile uint32_t *)(0xc883c000 + (0xa2 << 2))
+#define     HHI_MPLL_CNTL4                                     (0xc883c000 + (0xa3 << 2))
+#define SEC_HHI_MPLL_CNTL4                                     (0xda83c000 + (0xa3 << 2))
+#define   P_HHI_MPLL_CNTL4                                     (volatile uint32_t *)(0xc883c000 + (0xa3 << 2))
+#define     HHI_MPLL_CNTL5                                     (0xc883c000 + (0xa4 << 2))
+#define SEC_HHI_MPLL_CNTL5                                     (0xda83c000 + (0xa4 << 2))
+#define   P_HHI_MPLL_CNTL5                                     (volatile uint32_t *)(0xc883c000 + (0xa4 << 2))
+#define     HHI_MPLL_CNTL6                                     (0xc883c000 + (0xa5 << 2))
+#define SEC_HHI_MPLL_CNTL6                                     (0xda83c000 + (0xa5 << 2))
+#define   P_HHI_MPLL_CNTL6                                     (volatile uint32_t *)(0xc883c000 + (0xa5 << 2))
+#define     HHI_MPLL_CNTL7                                     (0xc883c000 + (0xa6 << 2))
+#define SEC_HHI_MPLL_CNTL7                                     (0xda83c000 + (0xa6 << 2))
+#define   P_HHI_MPLL_CNTL7                                     (volatile uint32_t *)(0xc883c000 + (0xa6 << 2))
+#define     HHI_MPLL_CNTL8                                     (0xc883c000 + (0xa7 << 2))
+#define SEC_HHI_MPLL_CNTL8                                     (0xda83c000 + (0xa7 << 2))
+#define   P_HHI_MPLL_CNTL8                                     (volatile uint32_t *)(0xc883c000 + (0xa7 << 2))
+#define     HHI_MPLL_CNTL9                                     (0xc883c000 + (0xa8 << 2))
+#define SEC_HHI_MPLL_CNTL9                                     (0xda83c000 + (0xa8 << 2))
+#define   P_HHI_MPLL_CNTL9                                     (volatile uint32_t *)(0xc883c000 + (0xa8 << 2))
+#define     HHI_MPLL_CNTL10                                    (0xc883c000 + (0xa9 << 2))
+#define SEC_HHI_MPLL_CNTL10                                    (0xda83c000 + (0xa9 << 2))
+#define   P_HHI_MPLL_CNTL10                                    (volatile uint32_t *)(0xc883c000 + (0xa9 << 2))
+#define     HHI_ADC_PLL_CNTL                                   (0xc883c000 + (0xaa << 2))
+#define SEC_HHI_ADC_PLL_CNTL                                   (0xda83c000 + (0xaa << 2))
+#define   P_HHI_ADC_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xaa << 2))
+#define     HHI_ADC_PLL_CNTL2                                  (0xc883c000 + (0xab << 2))
+#define SEC_HHI_ADC_PLL_CNTL2                                  (0xda83c000 + (0xab << 2))
+#define   P_HHI_ADC_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xab << 2))
+#define     HHI_ADC_PLL_CNTL3                                  (0xc883c000 + (0xac << 2))
+#define SEC_HHI_ADC_PLL_CNTL3                                  (0xda83c000 + (0xac << 2))
+#define   P_HHI_ADC_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xac << 2))
+#define     HHI_ADC_PLL_CNTL4                                  (0xc883c000 + (0xad << 2))
+#define SEC_HHI_ADC_PLL_CNTL4                                  (0xda83c000 + (0xad << 2))
+#define   P_HHI_ADC_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xad << 2))
+#define     HHI_ADC_PLL_STS                                    (0xc883c000 + (0xae << 2))
+#define SEC_HHI_ADC_PLL_STS                                    (0xda83c000 + (0xae << 2))
+#define   P_HHI_ADC_PLL_STS                                    (volatile uint32_t *)(0xc883c000 + (0xae << 2))
+#define     HHI_ADC_PLL_CNTL1                                  (0xc883c000 + (0xaf << 2))
+#define SEC_HHI_ADC_PLL_CNTL1                                  (0xda83c000 + (0xaf << 2))
+#define   P_HHI_ADC_PLL_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0xaf << 2))
+#define     HHI_AUDCLK_PLL_CNTL                                (0xc883c000 + (0xb0 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL                                (0xda83c000 + (0xb0 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL                                (volatile uint32_t *)(0xc883c000 + (0xb0 << 2))
+#define     HHI_AUDCLK_PLL_CNTL2                               (0xc883c000 + (0xb1 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL2                               (0xda83c000 + (0xb1 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL2                               (volatile uint32_t *)(0xc883c000 + (0xb1 << 2))
+#define     HHI_AUDCLK_PLL_CNTL3                               (0xc883c000 + (0xb2 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL3                               (0xda83c000 + (0xb2 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL3                               (volatile uint32_t *)(0xc883c000 + (0xb2 << 2))
+#define     HHI_AUDCLK_PLL_CNTL4                               (0xc883c000 + (0xb3 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL4                               (0xda83c000 + (0xb3 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL4                               (volatile uint32_t *)(0xc883c000 + (0xb3 << 2))
+#define     HHI_AUDCLK_PLL_CNTL5                               (0xc883c000 + (0xb4 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL5                               (0xda83c000 + (0xb4 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL5                               (volatile uint32_t *)(0xc883c000 + (0xb4 << 2))
+#define     HHI_AUDCLK_PLL_CNTL6                               (0xc883c000 + (0xb5 << 2))
+#define SEC_HHI_AUDCLK_PLL_CNTL6                               (0xda83c000 + (0xb5 << 2))
+#define   P_HHI_AUDCLK_PLL_CNTL6                               (volatile uint32_t *)(0xc883c000 + (0xb5 << 2))
+#define     HHI_L2_DDR_CLK_CNTL                                (0xc883c000 + (0xb6 << 2))
+#define SEC_HHI_L2_DDR_CLK_CNTL                                (0xda83c000 + (0xb6 << 2))
+#define   P_HHI_L2_DDR_CLK_CNTL                                (volatile uint32_t *)(0xc883c000 + (0xb6 << 2))
+#define     HHI_MPLL3_CNTL0                                    (0xc883c000 + (0xb8 << 2))
+#define SEC_HHI_MPLL3_CNTL0                                    (0xda83c000 + (0xb8 << 2))
+#define   P_HHI_MPLL3_CNTL0                                    (volatile uint32_t *)(0xc883c000 + (0xb8 << 2))
+#define     HHI_MPLL3_CNTL1                                    (0xc883c000 + (0xb9 << 2))
+#define SEC_HHI_MPLL3_CNTL1                                    (0xda83c000 + (0xb9 << 2))
+#define   P_HHI_MPLL3_CNTL1                                    (volatile uint32_t *)(0xc883c000 + (0xb9 << 2))
+#define     HHI_PLL_TOP_MISC                                   (0xc883c000 + (0xba << 2))
+#define SEC_HHI_PLL_TOP_MISC                                   (0xda83c000 + (0xba << 2))
+#define   P_HHI_PLL_TOP_MISC                                   (volatile uint32_t *)(0xc883c000 + (0xba << 2))
+#define     HHI_VDAC_CNTL0                                     (0xc883c000 + (0xbd << 2))
+#define SEC_HHI_VDAC_CNTL0                                     (0xda83c000 + (0xbd << 2))
+#define   P_HHI_VDAC_CNTL0                                     (volatile uint32_t *)(0xc883c000 + (0xbd << 2))
+#define     HHI_VDAC_CNTL1                                     (0xc883c000 + (0xbe << 2))
+#define SEC_HHI_VDAC_CNTL1                                     (0xda83c000 + (0xbe << 2))
+#define   P_HHI_VDAC_CNTL1                                     (volatile uint32_t *)(0xc883c000 + (0xbe << 2))
+#define     HHI_SYS_PLL_CNTL1                                  (0xc883c000 + (0xbf << 2))
+#define SEC_HHI_SYS_PLL_CNTL1                                  (0xda83c000 + (0xbf << 2))
+#define   P_HHI_SYS_PLL_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0xbf << 2))
+#define     HHI_SYS_PLL_CNTL                                   (0xc883c000 + (0xc0 << 2))
+#define SEC_HHI_SYS_PLL_CNTL                                   (0xda83c000 + (0xc0 << 2))
+#define   P_HHI_SYS_PLL_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xc0 << 2))
+#define     HHI_SYS_PLL_CNTL2                                  (0xc883c000 + (0xc1 << 2))
+#define SEC_HHI_SYS_PLL_CNTL2                                  (0xda83c000 + (0xc1 << 2))
+#define   P_HHI_SYS_PLL_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xc1 << 2))
+#define     HHI_SYS_PLL_CNTL3                                  (0xc883c000 + (0xc2 << 2))
+#define SEC_HHI_SYS_PLL_CNTL3                                  (0xda83c000 + (0xc2 << 2))
+#define   P_HHI_SYS_PLL_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xc2 << 2))
+#define     HHI_SYS_PLL_CNTL4                                  (0xc883c000 + (0xc3 << 2))
+#define SEC_HHI_SYS_PLL_CNTL4                                  (0xda83c000 + (0xc3 << 2))
+#define   P_HHI_SYS_PLL_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xc3 << 2))
+#define     HHI_SYS_PLL_CNTL5                                  (0xc883c000 + (0xc4 << 2))
+#define SEC_HHI_SYS_PLL_CNTL5                                  (0xda83c000 + (0xc4 << 2))
+#define   P_HHI_SYS_PLL_CNTL5                                  (volatile uint32_t *)(0xc883c000 + (0xc4 << 2))
+#define     HHI_SYS_PLL_STS                                    (0xc883c000 + (0xc5 << 2))
+#define SEC_HHI_SYS_PLL_STS                                    (0xda83c000 + (0xc5 << 2))
+#define   P_HHI_SYS_PLL_STS                                    (volatile uint32_t *)(0xc883c000 + (0xc5 << 2))
+#define     HHI_DPLL_TOP_I                                     (0xc883c000 + (0xc6 << 2))
+#define SEC_HHI_DPLL_TOP_I                                     (0xda83c000 + (0xc6 << 2))
+#define   P_HHI_DPLL_TOP_I                                     (volatile uint32_t *)(0xc883c000 + (0xc6 << 2))
+#define     HHI_DPLL_TOP2_I                                    (0xc883c000 + (0xc7 << 2))
+#define SEC_HHI_DPLL_TOP2_I                                    (0xda83c000 + (0xc7 << 2))
+#define   P_HHI_DPLL_TOP2_I                                    (volatile uint32_t *)(0xc883c000 + (0xc7 << 2))
+#define     HHI_HDMI_PLL_CNTL                                  (0xc883c000 + (0xc8 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL                                  (0xda83c000 + (0xc8 << 2))
+#define   P_HHI_HDMI_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0xc8 << 2))
+#define     HHI_HDMI_PLL_CNTL1                                 (0xc883c000 + (0xc9 << 2))
+#define SEC_HHI_HDMI_PLL_CNTL1                                 (0xda83c000 + (0xc9 << 2))
+#define   P_HHI_HDMI_PLL_CNTL1                                 (volatile uint32_t *)(0xc883c000 + (0xc9 << 2))
+#define     HHI_HDMI_PLL_CNTL2                                 (0xc883c000 + (0xca << 2))
+#define SEC_HHI_HDMI_PLL_CNTL2                                 (0xda83c000 + (0xca << 2))
+#define   P_HHI_HDMI_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xca << 2))
+#define     HHI_HDMI_PLL_CNTL3                                 (0xc883c000 + (0xcb << 2))
+#define SEC_HHI_HDMI_PLL_CNTL3                                 (0xda83c000 + (0xcb << 2))
+#define   P_HHI_HDMI_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xcb << 2))
+#define     HHI_HDMI_PLL_CNTL4                                 (0xc883c000 + (0xcc << 2))
+#define SEC_HHI_HDMI_PLL_CNTL4                                 (0xda83c000 + (0xcc << 2))
+#define   P_HHI_HDMI_PLL_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xcc << 2))
+#define     HHI_HDMI_PLL_CNTL5                                 (0xc883c000 + (0xcd << 2))
+#define SEC_HHI_HDMI_PLL_CNTL5                                 (0xda83c000 + (0xcd << 2))
+#define   P_HHI_HDMI_PLL_CNTL5                                 (volatile uint32_t *)(0xc883c000 + (0xcd << 2))
+#define     HHI_HDMI_PLL_STS                                   (0xc883c000 + (0xce << 2))
+#define SEC_HHI_HDMI_PLL_STS                                   (0xda83c000 + (0xce << 2))
+#define   P_HHI_HDMI_PLL_STS                                   (volatile uint32_t *)(0xc883c000 + (0xce << 2))
+#define     HHI_DSI_LVDS_EDP_CNTL0                             (0xc883c000 + (0xd1 << 2))
+#define SEC_HHI_DSI_LVDS_EDP_CNTL0                             (0xda83c000 + (0xd1 << 2))
+#define   P_HHI_DSI_LVDS_EDP_CNTL0                             (volatile uint32_t *)(0xc883c000 + (0xd1 << 2))
+#define     HHI_DSI_LVDS_EDP_CNTL1                             (0xc883c000 + (0xd2 << 2))
+#define SEC_HHI_DSI_LVDS_EDP_CNTL1                             (0xda83c000 + (0xd2 << 2))
+#define   P_HHI_DSI_LVDS_EDP_CNTL1                             (volatile uint32_t *)(0xc883c000 + (0xd2 << 2))
+#define     HHI_CSI_PHY_CNTL0                                  (0xc883c000 + (0xd3 << 2))
+#define SEC_HHI_CSI_PHY_CNTL0                                  (0xda83c000 + (0xd3 << 2))
+#define   P_HHI_CSI_PHY_CNTL0                                  (volatile uint32_t *)(0xc883c000 + (0xd3 << 2))
+#define     HHI_CSI_PHY_CNTL1                                  (0xc883c000 + (0xd4 << 2))
+#define SEC_HHI_CSI_PHY_CNTL1                                  (0xda83c000 + (0xd4 << 2))
+#define   P_HHI_CSI_PHY_CNTL1                                  (volatile uint32_t *)(0xc883c000 + (0xd4 << 2))
+#define     HHI_CSI_PHY_CNTL2                                  (0xc883c000 + (0xd5 << 2))
+#define SEC_HHI_CSI_PHY_CNTL2                                  (0xda83c000 + (0xd5 << 2))
+#define   P_HHI_CSI_PHY_CNTL2                                  (volatile uint32_t *)(0xc883c000 + (0xd5 << 2))
+#define     HHI_CSI_PHY_CNTL3                                  (0xc883c000 + (0xd6 << 2))
+#define SEC_HHI_CSI_PHY_CNTL3                                  (0xda83c000 + (0xd6 << 2))
+#define   P_HHI_CSI_PHY_CNTL3                                  (volatile uint32_t *)(0xc883c000 + (0xd6 << 2))
+#define     HHI_CSI_PHY_CNTL4                                  (0xc883c000 + (0xd7 << 2))
+#define SEC_HHI_CSI_PHY_CNTL4                                  (0xda83c000 + (0xd7 << 2))
+#define   P_HHI_CSI_PHY_CNTL4                                  (volatile uint32_t *)(0xc883c000 + (0xd7 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL0                              (0xc883c000 + (0xd8 << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL0                              (0xda83c000 + (0xd8 << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0xd8 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL1                              (0xc883c000 + (0xd9 << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL1                              (0xda83c000 + (0xd9 << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0xd9 << 2))
+#define     HHI_DIF_CSI_PHY_CNTL2                              (0xc883c000 + (0xda << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL2                              (0xda83c000 + (0xda << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL2                              (volatile uint32_t *)(0xc883c000 + (0xda << 2))
+#define     HHI_DIF_CSI_PHY_CNTL3                              (0xc883c000 + (0xdb << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL3                              (0xda83c000 + (0xdb << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL3                              (volatile uint32_t *)(0xc883c000 + (0xdb << 2))
+#define     HHI_DIF_CSI_PHY_CNTL4                              (0xc883c000 + (0xdc << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL4                              (0xda83c000 + (0xdc << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL4                              (volatile uint32_t *)(0xc883c000 + (0xdc << 2))
+#define     HHI_DIF_CSI_PHY_CNTL5                              (0xc883c000 + (0xdd << 2))
+#define SEC_HHI_DIF_CSI_PHY_CNTL5                              (0xda83c000 + (0xdd << 2))
+#define   P_HHI_DIF_CSI_PHY_CNTL5                              (volatile uint32_t *)(0xc883c000 + (0xdd << 2))
+#define     HHI_LVDS_TX_PHY_CNTL0                              (0xc883c000 + (0xde << 2))
+#define SEC_HHI_LVDS_TX_PHY_CNTL0                              (0xda83c000 + (0xde << 2))
+#define   P_HHI_LVDS_TX_PHY_CNTL0                              (volatile uint32_t *)(0xc883c000 + (0xde << 2))
+#define     HHI_LVDS_TX_PHY_CNTL1                              (0xc883c000 + (0xdf << 2))
+#define SEC_HHI_LVDS_TX_PHY_CNTL1                              (0xda83c000 + (0xdf << 2))
+#define   P_HHI_LVDS_TX_PHY_CNTL1                              (volatile uint32_t *)(0xc883c000 + (0xdf << 2))
+#define     HHI_VID2_PLL_CNTL                                  (0xc883c000 + (0xe0 << 2))
+#define SEC_HHI_VID2_PLL_CNTL                                  (0xda83c000 + (0xe0 << 2))
+#define   P_HHI_VID2_PLL_CNTL                                  (volatile uint32_t *)(0xc883c000 + (0xe0 << 2))
+#define     HHI_VID2_PLL_CNTL2                                 (0xc883c000 + (0xe1 << 2))
+#define SEC_HHI_VID2_PLL_CNTL2                                 (0xda83c000 + (0xe1 << 2))
+#define   P_HHI_VID2_PLL_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xe1 << 2))
+#define     HHI_VID2_PLL_CNTL3                                 (0xc883c000 + (0xe2 << 2))
+#define SEC_HHI_VID2_PLL_CNTL3                                 (0xda83c000 + (0xe2 << 2))
+#define   P_HHI_VID2_PLL_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xe2 << 2))
+#define     HHI_VID2_PLL_CNTL4                                 (0xc883c000 + (0xe3 << 2))
+#define SEC_HHI_VID2_PLL_CNTL4                                 (0xda83c000 + (0xe3 << 2))
+#define   P_HHI_VID2_PLL_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xe3 << 2))
+#define     HHI_VID2_PLL_CNTL5                                 (0xc883c000 + (0xe4 << 2))
+#define SEC_HHI_VID2_PLL_CNTL5                                 (0xda83c000 + (0xe4 << 2))
+#define   P_HHI_VID2_PLL_CNTL5                                 (volatile uint32_t *)(0xc883c000 + (0xe4 << 2))
+#define     HHI_VID2_PLL_CNTL_I                                (0xc883c000 + (0xe5 << 2))
+#define SEC_HHI_VID2_PLL_CNTL_I                                (0xda83c000 + (0xe5 << 2))
+#define   P_HHI_VID2_PLL_CNTL_I                                (volatile uint32_t *)(0xc883c000 + (0xe5 << 2))
+#define     HHI_HDMI_PHY_CNTL0                                 (0xc883c000 + (0xe8 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL0                                 (0xda83c000 + (0xe8 << 2))
+#define   P_HHI_HDMI_PHY_CNTL0                                 (volatile uint32_t *)(0xc883c000 + (0xe8 << 2))
+#define     HHI_HDMI_PHY_CNTL1                                 (0xc883c000 + (0xe9 << 2))
+#define SEC_HHI_HDMI_PHY_CNTL1                                 (0xda83c000 + (0xe9 << 2))
+#define   P_HHI_HDMI_PHY_CNTL1                                 (volatile uint32_t *)(0xc883c000 + (0xe9 << 2))
+#define     HHI_HDMI_PHY_CNTL2                                 (0xc883c000 + (0xea << 2))
+#define SEC_HHI_HDMI_PHY_CNTL2                                 (0xda83c000 + (0xea << 2))
+#define   P_HHI_HDMI_PHY_CNTL2                                 (volatile uint32_t *)(0xc883c000 + (0xea << 2))
+#define     HHI_HDMI_PHY_CNTL3                                 (0xc883c000 + (0xeb << 2))
+#define SEC_HHI_HDMI_PHY_CNTL3                                 (0xda83c000 + (0xeb << 2))
+#define   P_HHI_HDMI_PHY_CNTL3                                 (volatile uint32_t *)(0xc883c000 + (0xeb << 2))
+#define     HHI_HDMI_PHY_CNTL4                                 (0xc883c000 + (0xec << 2))
+#define SEC_HHI_HDMI_PHY_CNTL4                                 (0xda83c000 + (0xec << 2))
+#define   P_HHI_HDMI_PHY_CNTL4                                 (volatile uint32_t *)(0xc883c000 + (0xec << 2))
+#define     HHI_HDMI_PHY_STATUS                                (0xc883c000 + (0xed << 2))
+#define SEC_HHI_HDMI_PHY_STATUS                                (0xda83c000 + (0xed << 2))
+#define   P_HHI_HDMI_PHY_STATUS                                (volatile uint32_t *)(0xc883c000 + (0xed << 2))
+#define     HHI_VID_LOCK_CLK_CNTL                              (0xc883c000 + (0xf2 << 2))
+#define SEC_HHI_VID_LOCK_CLK_CNTL                              (0xda83c000 + (0xf2 << 2))
+#define   P_HHI_VID_LOCK_CLK_CNTL                              (volatile uint32_t *)(0xc883c000 + (0xf2 << 2))
+#define     HHI_ATV_DMD_SYS_CLK_CNTL                           (0xc883c000 + (0xf3 << 2))
+#define SEC_HHI_ATV_DMD_SYS_CLK_CNTL                           (0xda83c000 + (0xf3 << 2))
+#define   P_HHI_ATV_DMD_SYS_CLK_CNTL                           (volatile uint32_t *)(0xc883c000 + (0xf3 << 2))
+#define     HHI_EE_MISC_CNTL                                   (0xc883c000 + (0xf4 << 2))
+#define SEC_HHI_EE_MISC_CNTL                                   (0xda83c000 + (0xf4 << 2))
+#define   P_HHI_EE_MISC_CNTL                                   (volatile uint32_t *)(0xc883c000 + (0xf4 << 2))
+#define     HHI_BT656_CLK_CNTL                                 (0xc883c000 + (0xf5 << 2))
+#define SEC_HHI_BT656_CLK_CNTL                                 (0xda83c000 + (0xf5 << 2))
+#define   P_HHI_BT656_CLK_CNTL                                 (volatile uint32_t *)(0xc883c000 + (0xf5 << 2))
+//`define HHI_SAR_CLK_CNTL            8'hf6
+#define     HHI_HDMIRX_AUD_PLL_CNTL                            (0xc883c000 + (0xf8 << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL                            (0xda83c000 + (0xf8 << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL                            (volatile uint32_t *)(0xc883c000 + (0xf8 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL2                           (0xc883c000 + (0xf9 << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL2                           (0xda83c000 + (0xf9 << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL2                           (volatile uint32_t *)(0xc883c000 + (0xf9 << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL3                           (0xc883c000 + (0xfa << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL3                           (0xda83c000 + (0xfa << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL3                           (volatile uint32_t *)(0xc883c000 + (0xfa << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL4                           (0xc883c000 + (0xfb << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL4                           (0xda83c000 + (0xfb << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL4                           (volatile uint32_t *)(0xc883c000 + (0xfb << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL5                           (0xc883c000 + (0xfc << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL5                           (0xda83c000 + (0xfc << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL5                           (volatile uint32_t *)(0xc883c000 + (0xfc << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL6                           (0xc883c000 + (0xfd << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL6                           (0xda83c000 + (0xfd << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL6                           (volatile uint32_t *)(0xc883c000 + (0xfd << 2))
+#define     HHI_HDMIRX_AUD_PLL_CNTL_I                          (0xc883c000 + (0xfe << 2))
+#define SEC_HHI_HDMIRX_AUD_PLL_CNTL_I                          (0xda83c000 + (0xfe << 2))
+#define   P_HHI_HDMIRX_AUD_PLL_CNTL_I                          (volatile uint32_t *)(0xc883c000 + (0xfe << 2))
+//========================================================================
+//  HIU - Mailbox
+//========================================================================
+// APB4_DECODER_NON_SECURE_BASE     32'hC883C400
+// APB4_DECODER_SECURE_BASE         32'hDA83C400
+#define     HIU_MAILBOX_SET_0                                  (0xc883c400 + (0x01 << 2))
+#define SEC_HIU_MAILBOX_SET_0                                  (0xda83c400 + (0x01 << 2))
+#define   P_HIU_MAILBOX_SET_0                                  (volatile uint32_t *)(0xc883c400 + (0x01 << 2))
+#define     HIU_MAILBOX_STAT_0                                 (0xc883c400 + (0x02 << 2))
+#define SEC_HIU_MAILBOX_STAT_0                                 (0xda83c400 + (0x02 << 2))
+#define   P_HIU_MAILBOX_STAT_0                                 (volatile uint32_t *)(0xc883c400 + (0x02 << 2))
+#define     HIU_MAILBOX_CLR_0                                  (0xc883c400 + (0x03 << 2))
+#define SEC_HIU_MAILBOX_CLR_0                                  (0xda83c400 + (0x03 << 2))
+#define   P_HIU_MAILBOX_CLR_0                                  (volatile uint32_t *)(0xc883c400 + (0x03 << 2))
+#define     HIU_MAILBOX_SET_1                                  (0xc883c400 + (0x04 << 2))
+#define SEC_HIU_MAILBOX_SET_1                                  (0xda83c400 + (0x04 << 2))
+#define   P_HIU_MAILBOX_SET_1                                  (volatile uint32_t *)(0xc883c400 + (0x04 << 2))
+#define     HIU_MAILBOX_STAT_1                                 (0xc883c400 + (0x05 << 2))
+#define SEC_HIU_MAILBOX_STAT_1                                 (0xda83c400 + (0x05 << 2))
+#define   P_HIU_MAILBOX_STAT_1                                 (volatile uint32_t *)(0xc883c400 + (0x05 << 2))
+#define     HIU_MAILBOX_CLR_1                                  (0xc883c400 + (0x06 << 2))
+#define SEC_HIU_MAILBOX_CLR_1                                  (0xda83c400 + (0x06 << 2))
+#define   P_HIU_MAILBOX_CLR_1                                  (volatile uint32_t *)(0xc883c400 + (0x06 << 2))
+#define     HIU_MAILBOX_SET_2                                  (0xc883c400 + (0x07 << 2))
+#define SEC_HIU_MAILBOX_SET_2                                  (0xda83c400 + (0x07 << 2))
+#define   P_HIU_MAILBOX_SET_2                                  (volatile uint32_t *)(0xc883c400 + (0x07 << 2))
+#define     HIU_MAILBOX_STAT_2                                 (0xc883c400 + (0x08 << 2))
+#define SEC_HIU_MAILBOX_STAT_2                                 (0xda83c400 + (0x08 << 2))
+#define   P_HIU_MAILBOX_STAT_2                                 (volatile uint32_t *)(0xc883c400 + (0x08 << 2))
+#define     HIU_MAILBOX_CLR_2                                  (0xc883c400 + (0x09 << 2))
+#define SEC_HIU_MAILBOX_CLR_2                                  (0xda83c400 + (0x09 << 2))
+#define   P_HIU_MAILBOX_CLR_2                                  (volatile uint32_t *)(0xc883c400 + (0x09 << 2))
+#define     HIU_MAILBOX_SET_3                                  (0xc883c400 + (0x0a << 2))
+#define SEC_HIU_MAILBOX_SET_3                                  (0xda83c400 + (0x0a << 2))
+#define   P_HIU_MAILBOX_SET_3                                  (volatile uint32_t *)(0xc883c400 + (0x0a << 2))
+#define     HIU_MAILBOX_STAT_3                                 (0xc883c400 + (0x0b << 2))
+#define SEC_HIU_MAILBOX_STAT_3                                 (0xda83c400 + (0x0b << 2))
+#define   P_HIU_MAILBOX_STAT_3                                 (volatile uint32_t *)(0xc883c400 + (0x0b << 2))
+#define     HIU_MAILBOX_CLR_3                                  (0xc883c400 + (0x0c << 2))
+#define SEC_HIU_MAILBOX_CLR_3                                  (0xda83c400 + (0x0c << 2))
+#define   P_HIU_MAILBOX_CLR_3                                  (volatile uint32_t *)(0xc883c400 + (0x0c << 2))
+#define     HIU_MAILBOX_SET_4                                  (0xc883c400 + (0x0d << 2))
+#define SEC_HIU_MAILBOX_SET_4                                  (0xda83c400 + (0x0d << 2))
+#define   P_HIU_MAILBOX_SET_4                                  (volatile uint32_t *)(0xc883c400 + (0x0d << 2))
+#define     HIU_MAILBOX_STAT_4                                 (0xc883c400 + (0x0e << 2))
+#define SEC_HIU_MAILBOX_STAT_4                                 (0xda83c400 + (0x0e << 2))
+#define   P_HIU_MAILBOX_STAT_4                                 (volatile uint32_t *)(0xc883c400 + (0x0e << 2))
+#define     HIU_MAILBOX_CLR_4                                  (0xc883c400 + (0x0f << 2))
+#define SEC_HIU_MAILBOX_CLR_4                                  (0xda83c400 + (0x0f << 2))
+#define   P_HIU_MAILBOX_CLR_4                                  (volatile uint32_t *)(0xc883c400 + (0x0f << 2))
+#define     HIU_MAILBOX_SET_5                                  (0xc883c400 + (0x10 << 2))
+#define SEC_HIU_MAILBOX_SET_5                                  (0xda83c400 + (0x10 << 2))
+#define   P_HIU_MAILBOX_SET_5                                  (volatile uint32_t *)(0xc883c400 + (0x10 << 2))
+#define     HIU_MAILBOX_STAT_5                                 (0xc883c400 + (0x11 << 2))
+#define SEC_HIU_MAILBOX_STAT_5                                 (0xda83c400 + (0x11 << 2))
+#define   P_HIU_MAILBOX_STAT_5                                 (volatile uint32_t *)(0xc883c400 + (0x11 << 2))
+#define     HIU_MAILBOX_CLR_5                                  (0xc883c400 + (0x12 << 2))
+#define SEC_HIU_MAILBOX_CLR_5                                  (0xda83c400 + (0x12 << 2))
+#define   P_HIU_MAILBOX_CLR_5                                  (volatile uint32_t *)(0xc883c400 + (0x12 << 2))
+//========================================================================
+//  EFUSE
+//========================================================================
+//  APB4_DECODER_NON_SECURE_BASE     32'hC8830000
+//  APB4_DECODER_SECURE_BASE         32'hDA830000
+#define     EFUSE_CNTL0                                        (0xc8830000 + (0x00 << 2))
+#define SEC_EFUSE_CNTL0                                        (0xda830000 + (0x00 << 2))
+#define   P_EFUSE_CNTL0                                        (volatile uint32_t *)(0xc8830000 + (0x00 << 2))
+#define     EFUSE_CNTL1                                        (0xc8830000 + (0x01 << 2))
+#define SEC_EFUSE_CNTL1                                        (0xda830000 + (0x01 << 2))
+#define   P_EFUSE_CNTL1                                        (volatile uint32_t *)(0xc8830000 + (0x01 << 2))
+#define     EFUSE_CNTL2                                        (0xc8830000 + (0x02 << 2))
+#define SEC_EFUSE_CNTL2                                        (0xda830000 + (0x02 << 2))
+#define   P_EFUSE_CNTL2                                        (volatile uint32_t *)(0xc8830000 + (0x02 << 2))
+#define     EFUSE_CNTL3                                        (0xc8830000 + (0x03 << 2))
+#define SEC_EFUSE_CNTL3                                        (0xda830000 + (0x03 << 2))
+#define   P_EFUSE_CNTL3                                        (volatile uint32_t *)(0xc8830000 + (0x03 << 2))
+#define     EFUSE_CNTL4                                        (0xc8830000 + (0x04 << 2))
+#define SEC_EFUSE_CNTL4                                        (0xda830000 + (0x04 << 2))
+#define   P_EFUSE_CNTL4                                        (volatile uint32_t *)(0xc8830000 + (0x04 << 2))
+#define     EFUSE_WDATA0                                       (0xc8830000 + (0x05 << 2))
+#define SEC_EFUSE_WDATA0                                       (0xda830000 + (0x05 << 2))
+#define   P_EFUSE_WDATA0                                       (volatile uint32_t *)(0xc8830000 + (0x05 << 2))
+#define     EFUSE_WDATA1                                       (0xc8830000 + (0x06 << 2))
+#define SEC_EFUSE_WDATA1                                       (0xda830000 + (0x06 << 2))
+#define   P_EFUSE_WDATA1                                       (volatile uint32_t *)(0xc8830000 + (0x06 << 2))
+#define     EFUSE_WDATA2                                       (0xc8830000 + (0x07 << 2))
+#define SEC_EFUSE_WDATA2                                       (0xda830000 + (0x07 << 2))
+#define   P_EFUSE_WDATA2                                       (volatile uint32_t *)(0xc8830000 + (0x07 << 2))
+#define     EFUSE_WDATA3                                       (0xc8830000 + (0x08 << 2))
+#define SEC_EFUSE_WDATA3                                       (0xda830000 + (0x08 << 2))
+#define   P_EFUSE_WDATA3                                       (volatile uint32_t *)(0xc8830000 + (0x08 << 2))
+#define     EFUSE_RDATA0                                       (0xc8830000 + (0x09 << 2))
+#define SEC_EFUSE_RDATA0                                       (0xda830000 + (0x09 << 2))
+#define   P_EFUSE_RDATA0                                       (volatile uint32_t *)(0xc8830000 + (0x09 << 2))
+#define     EFUSE_RDATA1                                       (0xc8830000 + (0x0a << 2))
+#define SEC_EFUSE_RDATA1                                       (0xda830000 + (0x0a << 2))
+#define   P_EFUSE_RDATA1                                       (volatile uint32_t *)(0xc8830000 + (0x0a << 2))
+#define     EFUSE_RDATA2                                       (0xc8830000 + (0x0b << 2))
+#define SEC_EFUSE_RDATA2                                       (0xda830000 + (0x0b << 2))
+#define   P_EFUSE_RDATA2                                       (volatile uint32_t *)(0xc8830000 + (0x0b << 2))
+#define     EFUSE_RDATA3                                       (0xc8830000 + (0x0c << 2))
+#define SEC_EFUSE_RDATA3                                       (0xda830000 + (0x0c << 2))
+#define   P_EFUSE_RDATA3                                       (volatile uint32_t *)(0xc8830000 + (0x0c << 2))
+#define     EFUSE_RD_DISABLE                                   (0xc8830000 + (0x10 << 2))
+#define SEC_EFUSE_RD_DISABLE                                   (0xda830000 + (0x10 << 2))
+#define   P_EFUSE_RD_DISABLE                                   (volatile uint32_t *)(0xc8830000 + (0x10 << 2))
+#define     EFUSE_WR_DISABLE                                   (0xc8830000 + (0x11 << 2))
+#define SEC_EFUSE_WR_DISABLE                                   (0xda830000 + (0x11 << 2))
+#define   P_EFUSE_WR_DISABLE                                   (volatile uint32_t *)(0xc8830000 + (0x11 << 2))
+#define     EFUSE_OBFUSCATE                                    (0xc8830000 + (0x12 << 2))
+#define SEC_EFUSE_OBFUSCATE                                    (0xda830000 + (0x12 << 2))
+#define   P_EFUSE_OBFUSCATE                                    (volatile uint32_t *)(0xc8830000 + (0x12 << 2))
+#define     EFUSE_AES_KEY32                                    (0xc8830000 + (0x13 << 2))
+#define SEC_EFUSE_AES_KEY32                                    (0xda830000 + (0x13 << 2))
+#define   P_EFUSE_AES_KEY32                                    (volatile uint32_t *)(0xc8830000 + (0x13 << 2))
+#define     KEY_LDR_USR_CNTL                                   (0xc8830000 + (0x20 << 2))
+#define SEC_KEY_LDR_USR_CNTL                                   (0xda830000 + (0x20 << 2))
+#define   P_KEY_LDR_USR_CNTL                                   (volatile uint32_t *)(0xc8830000 + (0x20 << 2))
+#define     KEY_LDR_USR_RAM_W                                  (0xc8830000 + (0x21 << 2))
+#define SEC_KEY_LDR_USR_RAM_W                                  (0xda830000 + (0x21 << 2))
+#define   P_KEY_LDR_USR_RAM_W                                  (volatile uint32_t *)(0xc8830000 + (0x21 << 2))
+#define     KEY_LDR_VENDOR_ID                                  (0xc8830000 + (0x22 << 2))
+#define SEC_KEY_LDR_VENDOR_ID                                  (0xda830000 + (0x22 << 2))
+#define   P_KEY_LDR_VENDOR_ID                                  (volatile uint32_t *)(0xc8830000 + (0x22 << 2))
+#define     KEY_LDR_SEC_REG0                                   (0xc8830000 + (0x23 << 2))
+#define SEC_KEY_LDR_SEC_REG0                                   (0xda830000 + (0x23 << 2))
+#define   P_KEY_LDR_SEC_REG0                                   (volatile uint32_t *)(0xc8830000 + (0x23 << 2))
+#define     KEY_LDR_SEC_CFG                                    (0xc8830000 + (0x24 << 2))
+#define SEC_KEY_LDR_SEC_CFG                                    (0xda830000 + (0x24 << 2))
+#define   P_KEY_LDR_SEC_CFG                                    (volatile uint32_t *)(0xc8830000 + (0x24 << 2))
+#define     KEY_LDR_SEC_BLK_NUM                                (0xc8830000 + (0x25 << 2))
+#define SEC_KEY_LDR_SEC_BLK_NUM                                (0xda830000 + (0x25 << 2))
+#define   P_KEY_LDR_SEC_BLK_NUM                                (volatile uint32_t *)(0xc8830000 + (0x25 << 2))
+#define     KEY_LDR_NONCE_0                                    (0xc8830000 + (0x26 << 2))
+#define SEC_KEY_LDR_NONCE_0                                    (0xda830000 + (0x26 << 2))
+#define   P_KEY_LDR_NONCE_0                                    (volatile uint32_t *)(0xc8830000 + (0x26 << 2))
+#define     KEY_LDR_NONCE_1                                    (0xc8830000 + (0x27 << 2))
+#define SEC_KEY_LDR_NONCE_1                                    (0xda830000 + (0x27 << 2))
+#define   P_KEY_LDR_NONCE_1                                    (volatile uint32_t *)(0xc8830000 + (0x27 << 2))
+#define     KEY_LDR_NONCE_2                                    (0xc8830000 + (0x28 << 2))
+#define SEC_KEY_LDR_NONCE_2                                    (0xda830000 + (0x28 << 2))
+#define   P_KEY_LDR_NONCE_2                                    (volatile uint32_t *)(0xc8830000 + (0x28 << 2))
+#define     KEY_LDR_NONCE_3                                    (0xc8830000 + (0x29 << 2))
+#define SEC_KEY_LDR_NONCE_3                                    (0xda830000 + (0x29 << 2))
+#define   P_KEY_LDR_NONCE_3                                    (volatile uint32_t *)(0xc8830000 + (0x29 << 2))
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./secure_apb4_ee.h
+//
+//
+// Reading file:  ./ao_rti_reg.h
+//
+// -------------------------------------------------------------------
+// PSEL #0
+// -------------------------------------------------------------------
+// APB4_DECODER_NON_SECURE_BASE     32'hC8100000
+// APB4_DECODER_SECURE_BASE         32'hDA100000
+// Registers not affected by the Watchdog timer
+#define     AO_RTI_STATUS_REG0                                 (0xc8100000 + (0x00 << 2))
+#define SEC_AO_RTI_STATUS_REG0                                 (0xda100000 + (0x00 << 2))
+#define   P_AO_RTI_STATUS_REG0                                 (volatile uint32_t *)(0xc8100000 + (0x00 << 2))
+#define     AO_RTI_STATUS_REG1                                 (0xc8100000 + (0x01 << 2))
+#define SEC_AO_RTI_STATUS_REG1                                 (0xda100000 + (0x01 << 2))
+#define   P_AO_RTI_STATUS_REG1                                 (volatile uint32_t *)(0xc8100000 + (0x01 << 2))
+#define     AO_RTI_STATUS_REG2                                 (0xc8100000 + (0x02 << 2))
+#define SEC_AO_RTI_STATUS_REG2                                 (0xda100000 + (0x02 << 2))
+#define   P_AO_RTI_STATUS_REG2                                 (volatile uint32_t *)(0xc8100000 + (0x02 << 2))
+#define     AO_RTI_PWR_CNTL_REG1                               (0xc8100000 + (0x03 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG1                               (0xda100000 + (0x03 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG1                               (volatile uint32_t *)(0xc8100000 + (0x03 << 2))
+#define     AO_RTI_PWR_CNTL_REG0                               (0xc8100000 + (0x04 << 2))
+#define SEC_AO_RTI_PWR_CNTL_REG0                               (0xda100000 + (0x04 << 2))
+#define   P_AO_RTI_PWR_CNTL_REG0                               (volatile uint32_t *)(0xc8100000 + (0x04 << 2))
+#define     AO_RTI_PIN_MUX_REG                                 (0xc8100000 + (0x05 << 2))
+#define SEC_AO_RTI_PIN_MUX_REG                                 (0xda100000 + (0x05 << 2))
+#define   P_AO_RTI_PIN_MUX_REG                                 (volatile uint32_t *)(0xc8100000 + (0x05 << 2))
+#define     AO_RTI_PIN_MUX_REG2                                (0xc8100000 + (0x06 << 2))
+#define SEC_AO_RTI_PIN_MUX_REG2                                (0xda100000 + (0x06 << 2))
+#define   P_AO_RTI_PIN_MUX_REG2                                (volatile uint32_t *)(0xc8100000 + (0x06 << 2))
+#define     AO_RTI_STATUS_REG3                                 (0xc8100000 + (0x07 << 2))
+#define SEC_AO_RTI_STATUS_REG3                                 (0xda100000 + (0x07 << 2))
+#define   P_AO_RTI_STATUS_REG3                                 (volatile uint32_t *)(0xc8100000 + (0x07 << 2))
+//`define AO_REMAP_REG0               8'h07 //TODO: DELETE. NOT USED
+#define     AO_REMAP_REG1                                      (0xc8100000 + (0x08 << 2))
+#define SEC_AO_REMAP_REG1                                      (0xda100000 + (0x08 << 2))
+#define   P_AO_REMAP_REG1                                      (volatile uint32_t *)(0xc8100000 + (0x08 << 2))
+#define     AO_GPIO_O_EN_N                                     (0xc8100000 + (0x09 << 2))
+#define SEC_AO_GPIO_O_EN_N                                     (0xda100000 + (0x09 << 2))
+#define   P_AO_GPIO_O_EN_N                                     (volatile uint32_t *)(0xc8100000 + (0x09 << 2))
+#define     AO_GPIO_I                                          (0xc8100000 + (0x0a << 2))
+#define SEC_AO_GPIO_I                                          (0xda100000 + (0x0a << 2))
+#define   P_AO_GPIO_I                                          (volatile uint32_t *)(0xc8100000 + (0x0a << 2))
+#define     AO_RTI_PULL_UP_REG                                 (0xc8100000 + (0x0b << 2))
+#define SEC_AO_RTI_PULL_UP_REG                                 (0xda100000 + (0x0b << 2))
+#define   P_AO_RTI_PULL_UP_REG                                 (volatile uint32_t *)(0xc8100000 + (0x0b << 2))
+#define     AO_RTI_JTAG_CONFIG_REG                             (0xc8100000 + (0x0c << 2))
+#define SEC_AO_RTI_JTAG_CONFIG_REG                             (0xda100000 + (0x0c << 2))
+#define   P_AO_RTI_JTAG_CONFIG_REG                             (volatile uint32_t *)(0xc8100000 + (0x0c << 2))
+#define     AO_RTI_WD_MARK                                     (0xc8100000 + (0x0d << 2))
+#define SEC_AO_RTI_WD_MARK                                     (0xda100000 + (0x0d << 2))
+#define   P_AO_RTI_WD_MARK                                     (volatile uint32_t *)(0xc8100000 + (0x0d << 2))
+// sando add for AO CPU
+#define     AO_CPU_CNTL                                        (0xc8100000 + (0x0e << 2))
+#define SEC_AO_CPU_CNTL                                        (0xda100000 + (0x0e << 2))
+#define   P_AO_CPU_CNTL                                        (volatile uint32_t *)(0xc8100000 + (0x0e << 2))
+#define     AO_CPU_CNTL2                                       (0xc8100000 + (0x0f << 2))
+#define SEC_AO_CPU_CNTL2                                       (0xda100000 + (0x0f << 2))
+#define   P_AO_CPU_CNTL2                                       (volatile uint32_t *)(0xc8100000 + (0x0f << 2))
+#define     AO_RTI_GEN_CNTL_REG0                               (0xc8100000 + (0x10 << 2))
+#define SEC_AO_RTI_GEN_CNTL_REG0                               (0xda100000 + (0x10 << 2))
+#define   P_AO_RTI_GEN_CNTL_REG0                               (volatile uint32_t *)(0xc8100000 + (0x10 << 2))
+#define     AO_CPU_CNTL_NS                                     (0xc8100000 + (0x11 << 2))
+#define SEC_AO_CPU_CNTL_NS                                     (0xda100000 + (0x11 << 2))
+#define   P_AO_CPU_CNTL_NS                                     (volatile uint32_t *)(0xc8100000 + (0x11 << 2))
+#define     AO_TIMER_REG                                       (0xc8100000 + (0x13 << 2))
+#define SEC_AO_TIMER_REG                                       (0xda100000 + (0x13 << 2))
+#define   P_AO_TIMER_REG                                       (volatile uint32_t *)(0xc8100000 + (0x13 << 2))
+#define     AO_TIMERA_REG                                      (0xc8100000 + (0x14 << 2))
+#define SEC_AO_TIMERA_REG                                      (0xda100000 + (0x14 << 2))
+#define   P_AO_TIMERA_REG                                      (volatile uint32_t *)(0xc8100000 + (0x14 << 2))
+#define     AO_TIMERE_REG                                      (0xc8100000 + (0x15 << 2))
+#define SEC_AO_TIMERE_REG                                      (0xda100000 + (0x15 << 2))
+#define   P_AO_TIMERE_REG                                      (volatile uint32_t *)(0xc8100000 + (0x15 << 2))
+#define     AO_OSCIN_CNTL                                      (0xc8100000 + (0x16 << 2))
+#define SEC_AO_OSCIN_CNTL                                      (0xda100000 + (0x16 << 2))
+#define   P_AO_OSCIN_CNTL                                      (volatile uint32_t *)(0xc8100000 + (0x16 << 2))
+#define     AO_AHB2DDR_CNTL                                    (0xc8100000 + (0x18 << 2))
+#define SEC_AO_AHB2DDR_CNTL                                    (0xda100000 + (0x18 << 2))
+#define   P_AO_AHB2DDR_CNTL                                    (volatile uint32_t *)(0xc8100000 + (0x18 << 2))
+#define     AO_TIMEBASE_CNTL                                   (0xc8100000 + (0x19 << 2))
+#define SEC_AO_TIMEBASE_CNTL                                   (0xda100000 + (0x19 << 2))
+#define   P_AO_TIMEBASE_CNTL                                   (volatile uint32_t *)(0xc8100000 + (0x19 << 2))
+#define     AO_CRT_CLK_CNTL1                                   (0xc8100000 + (0x1a << 2))
+#define SEC_AO_CRT_CLK_CNTL1                                   (0xda100000 + (0x1a << 2))
+#define   P_AO_CRT_CLK_CNTL1                                   (volatile uint32_t *)(0xc8100000 + (0x1a << 2))
+#define     AO_RTI_INTER_OSC_CTL0                              (0xc8100000 + (0x1b << 2))
+#define SEC_AO_RTI_INTER_OSC_CTL0                              (0xda100000 + (0x1b << 2))
+#define   P_AO_RTI_INTER_OSC_CTL0                              (volatile uint32_t *)(0xc8100000 + (0x1b << 2))
+#define     AO_RTI_INTER_OSC_CTL1                              (0xc8100000 + (0x1c << 2))
+#define SEC_AO_RTI_INTER_OSC_CTL1                              (0xda100000 + (0x1c << 2))
+#define   P_AO_RTI_INTER_OSC_CTL1                              (volatile uint32_t *)(0xc8100000 + (0x1c << 2))
+#define     AO_METAL_REVISION                                  (0xc8100000 + (0x1f << 2))
+#define SEC_AO_METAL_REVISION                                  (0xda100000 + (0x1f << 2))
+#define   P_AO_METAL_REVISION                                  (volatile uint32_t *)(0xc8100000 + (0x1f << 2))
+#define     AO_IRQ_MASK_FIQ_SEL                                (0xc8100000 + (0x20 << 2))
+#define SEC_AO_IRQ_MASK_FIQ_SEL                                (0xda100000 + (0x20 << 2))
+#define   P_AO_IRQ_MASK_FIQ_SEL                                (volatile uint32_t *)(0xc8100000 + (0x20 << 2))
+#define     AO_IRQ_GPIO_REG                                    (0xc8100000 + (0x21 << 2))
+#define SEC_AO_IRQ_GPIO_REG                                    (0xda100000 + (0x21 << 2))
+#define   P_AO_IRQ_GPIO_REG                                    (volatile uint32_t *)(0xc8100000 + (0x21 << 2))
+#define     AO_IRQ_STAT                                        (0xc8100000 + (0x22 << 2))
+#define SEC_AO_IRQ_STAT                                        (0xda100000 + (0x22 << 2))
+#define   P_AO_IRQ_STAT                                        (volatile uint32_t *)(0xc8100000 + (0x22 << 2))
+#define     AO_IRQ_STAT_CLR                                    (0xc8100000 + (0x23 << 2))
+#define SEC_AO_IRQ_STAT_CLR                                    (0xda100000 + (0x23 << 2))
+#define   P_AO_IRQ_STAT_CLR                                    (volatile uint32_t *)(0xc8100000 + (0x23 << 2))
+#define     AO_SAR_CLK                                         (0xc8100000 + (0x24 << 2))
+#define SEC_AO_SAR_CLK                                         (0xda100000 + (0x24 << 2))
+#define   P_AO_SAR_CLK                                         (volatile uint32_t *)(0xc8100000 + (0x24 << 2))
+#define     AO_RTC_ALT_CLK_CNTL0                               (0xc8100000 + (0x25 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL0                               (0xda100000 + (0x25 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL0                               (volatile uint32_t *)(0xc8100000 + (0x25 << 2))
+#define     AO_RTC_ALT_CLK_CNTL1                               (0xc8100000 + (0x26 << 2))
+#define SEC_AO_RTC_ALT_CLK_CNTL1                               (0xda100000 + (0x26 << 2))
+#define   P_AO_RTC_ALT_CLK_CNTL1                               (volatile uint32_t *)(0xc8100000 + (0x26 << 2))
+#define     AO_DEBUG_REG0                                      (0xc8100000 + (0x28 << 2))
+#define SEC_AO_DEBUG_REG0                                      (0xda100000 + (0x28 << 2))
+#define   P_AO_DEBUG_REG0                                      (volatile uint32_t *)(0xc8100000 + (0x28 << 2))
+#define     AO_DEBUG_REG1                                      (0xc8100000 + (0x29 << 2))
+#define SEC_AO_DEBUG_REG1                                      (0xda100000 + (0x29 << 2))
+#define   P_AO_DEBUG_REG1                                      (volatile uint32_t *)(0xc8100000 + (0x29 << 2))
+#define     AO_DEBUG_REG2                                      (0xc8100000 + (0x2a << 2))
+#define SEC_AO_DEBUG_REG2                                      (0xda100000 + (0x2a << 2))
+#define   P_AO_DEBUG_REG2                                      (volatile uint32_t *)(0xc8100000 + (0x2a << 2))
+#define     AO_DEBUG_REG3                                      (0xc8100000 + (0x2b << 2))
+#define SEC_AO_DEBUG_REG3                                      (0xda100000 + (0x2b << 2))
+#define   P_AO_DEBUG_REG3                                      (volatile uint32_t *)(0xc8100000 + (0x2b << 2))
+#define     AO_TIMESTAMP_CNTL                                  (0xc8100000 + (0x2d << 2))
+#define SEC_AO_TIMESTAMP_CNTL                                  (0xda100000 + (0x2d << 2))
+#define   P_AO_TIMESTAMP_CNTL                                  (volatile uint32_t *)(0xc8100000 + (0x2d << 2))
+#define     AO_TIMESTAMP_RD0                                   (0xc8100000 + (0x2e << 2))
+#define SEC_AO_TIMESTAMP_RD0                                   (0xda100000 + (0x2e << 2))
+#define   P_AO_TIMESTAMP_RD0                                   (volatile uint32_t *)(0xc8100000 + (0x2e << 2))
+#define     AO_TIMESTAMP_RD1                                   (0xc8100000 + (0x2f << 2))
+#define SEC_AO_TIMESTAMP_RD1                                   (0xda100000 + (0x2f << 2))
+#define   P_AO_TIMESTAMP_RD1                                   (volatile uint32_t *)(0xc8100000 + (0x2f << 2))
+#define     AO_IR_BLASTER_ADDR0                                (0xc8100000 + (0x30 << 2))
+#define SEC_AO_IR_BLASTER_ADDR0                                (0xda100000 + (0x30 << 2))
+#define   P_AO_IR_BLASTER_ADDR0                                (volatile uint32_t *)(0xc8100000 + (0x30 << 2))
+#define     AO_IR_BLASTER_ADDR1                                (0xc8100000 + (0x31 << 2))
+#define SEC_AO_IR_BLASTER_ADDR1                                (0xda100000 + (0x31 << 2))
+#define   P_AO_IR_BLASTER_ADDR1                                (volatile uint32_t *)(0xc8100000 + (0x31 << 2))
+#define     AO_IR_BLASTER_ADDR2                                (0xc8100000 + (0x32 << 2))
+#define SEC_AO_IR_BLASTER_ADDR2                                (0xda100000 + (0x32 << 2))
+#define   P_AO_IR_BLASTER_ADDR2                                (volatile uint32_t *)(0xc8100000 + (0x32 << 2))
+#define     AO_CPU_STAT1                                       (0xc8100000 + (0x33 << 2))
+#define SEC_AO_CPU_STAT1                                       (0xda100000 + (0x33 << 2))
+#define   P_AO_CPU_STAT1                                       (volatile uint32_t *)(0xc8100000 + (0x33 << 2))
+#define     AO_CPU_STAT2                                       (0xc8100000 + (0x34 << 2))
+#define SEC_AO_CPU_STAT2                                       (0xda100000 + (0x34 << 2))
+#define   P_AO_CPU_STAT2                                       (volatile uint32_t *)(0xc8100000 + (0x34 << 2))
+#define     AO_CPU_TIMESTAMP                                   (0xc8100000 + (0x35 << 2))
+#define SEC_AO_CPU_TIMESTAMP                                   (0xda100000 + (0x35 << 2))
+#define   P_AO_CPU_TIMESTAMP                                   (volatile uint32_t *)(0xc8100000 + (0x35 << 2))
+#define     AO_CPU_TIMESTAMP2                                  (0xc8100000 + (0x36 << 2))
+#define SEC_AO_CPU_TIMESTAMP2                                  (0xda100000 + (0x36 << 2))
+#define   P_AO_CPU_TIMESTAMP2                                  (volatile uint32_t *)(0xc8100000 + (0x36 << 2))
+#define     AO_CPU_CNTL3                                       (0xc8100000 + (0x37 << 2))
+#define SEC_AO_CPU_CNTL3                                       (0xda100000 + (0x37 << 2))
+#define   P_AO_CPU_CNTL3                                       (volatile uint32_t *)(0xc8100000 + (0x37 << 2))
+// general Power control
+#define     AO_RTI_PWR_SYS_CPU_CNTL0                           (0xc8100000 + (0x38 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL0                           (0xda100000 + (0x38 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL0                           (volatile uint32_t *)(0xc8100000 + (0x38 << 2))
+#define     AO_RTI_PWR_SYS_CPU_CNTL1                           (0xc8100000 + (0x39 << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_CNTL1                           (0xda100000 + (0x39 << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_CNTL1                           (volatile uint32_t *)(0xc8100000 + (0x39 << 2))
+#define     AO_RTI_GEN_PWR_SLEEP0                              (0xc8100000 + (0x3a << 2))
+#define SEC_AO_RTI_GEN_PWR_SLEEP0                              (0xda100000 + (0x3a << 2))
+#define   P_AO_RTI_GEN_PWR_SLEEP0                              (volatile uint32_t *)(0xc8100000 + (0x3a << 2))
+#define     AO_RTI_GEN_PWR_ISO0                                (0xc8100000 + (0x3b << 2))
+#define SEC_AO_RTI_GEN_PWR_ISO0                                (0xda100000 + (0x3b << 2))
+#define   P_AO_RTI_GEN_PWR_ISO0                                (volatile uint32_t *)(0xc8100000 + (0x3b << 2))
+#define     AO_RTI_GEN_PWR_ACK0                                (0xc8100000 + (0x3c << 2))
+#define SEC_AO_RTI_GEN_PWR_ACK0                                (0xda100000 + (0x3c << 2))
+#define   P_AO_RTI_GEN_PWR_ACK0                                (volatile uint32_t *)(0xc8100000 + (0x3c << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xc8100000 + (0x3d << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (0xda100000 + (0x3d << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD0                         (volatile uint32_t *)(0xc8100000 + (0x3d << 2))
+#define     AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xc8100000 + (0x3e << 2))
+#define SEC_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (0xda100000 + (0x3e << 2))
+#define   P_AO_RTI_PWR_SYS_CPU_MEM_PD1                         (volatile uint32_t *)(0xc8100000 + (0x3e << 2))
+#define     AO_CPU_CNTL4                                       (0xc8100000 + (0x3f << 2))
+#define SEC_AO_CPU_CNTL4                                       (0xda100000 + (0x3f << 2))
+#define   P_AO_CPU_CNTL4                                       (volatile uint32_t *)(0xc8100000 + (0x3f << 2))
+#define     AO_CEC_GEN_CNTL                                    (0xc8100000 + (0x40 << 2))
+#define SEC_AO_CEC_GEN_CNTL                                    (0xda100000 + (0x40 << 2))
+#define   P_AO_CEC_GEN_CNTL                                    (volatile uint32_t *)(0xc8100000 + (0x40 << 2))
+#define     AO_CEC_RW_REG                                      (0xc8100000 + (0x41 << 2))
+#define SEC_AO_CEC_RW_REG                                      (0xda100000 + (0x41 << 2))
+#define   P_AO_CEC_RW_REG                                      (volatile uint32_t *)(0xc8100000 + (0x41 << 2))
+#define     AO_CEC_INTR_MASKN                                  (0xc8100000 + (0x42 << 2))
+#define SEC_AO_CEC_INTR_MASKN                                  (0xda100000 + (0x42 << 2))
+#define   P_AO_CEC_INTR_MASKN                                  (volatile uint32_t *)(0xc8100000 + (0x42 << 2))
+#define     AO_CEC_INTR_CLR                                    (0xc8100000 + (0x43 << 2))
+#define SEC_AO_CEC_INTR_CLR                                    (0xda100000 + (0x43 << 2))
+#define   P_AO_CEC_INTR_CLR                                    (volatile uint32_t *)(0xc8100000 + (0x43 << 2))
+#define     AO_CEC_INTR_STAT                                   (0xc8100000 + (0x44 << 2))
+#define SEC_AO_CEC_INTR_STAT                                   (0xda100000 + (0x44 << 2))
+#define   P_AO_CEC_INTR_STAT                                   (volatile uint32_t *)(0xc8100000 + (0x44 << 2))
+#define     AO_CPU_CNTL5                                       (0xc8100000 + (0x45 << 2))
+#define SEC_AO_CPU_CNTL5                                       (0xda100000 + (0x45 << 2))
+#define   P_AO_CPU_CNTL5                                       (volatile uint32_t *)(0xc8100000 + (0x45 << 2))
+#define     AO_WATCHDOG_CNTL                                   (0xc8100000 + (0x48 << 2))
+#define SEC_AO_WATCHDOG_CNTL                                   (0xda100000 + (0x48 << 2))
+#define   P_AO_WATCHDOG_CNTL                                   (volatile uint32_t *)(0xc8100000 + (0x48 << 2))
+#define     AO_WATCHDOG_CNTL1                                  (0xc8100000 + (0x49 << 2))
+#define SEC_AO_WATCHDOG_CNTL1                                  (0xda100000 + (0x49 << 2))
+#define   P_AO_WATCHDOG_CNTL1                                  (volatile uint32_t *)(0xc8100000 + (0x49 << 2))
+#define     AO_WATCHDOG_TCNT                                   (0xc8100000 + (0x4a << 2))
+#define SEC_AO_WATCHDOG_TCNT                                   (0xda100000 + (0x4a << 2))
+#define   P_AO_WATCHDOG_TCNT                                   (volatile uint32_t *)(0xc8100000 + (0x4a << 2))
+#define     AO_WATCHDOG_RESET                                  (0xc8100000 + (0x4b << 2))
+#define SEC_AO_WATCHDOG_RESET                                  (0xda100000 + (0x4b << 2))
+#define   P_AO_WATCHDOG_RESET                                  (volatile uint32_t *)(0xc8100000 + (0x4b << 2))
+#define     AO_RTI_STICKY_REG0                                 (0xc8100000 + (0x4c << 2))
+#define SEC_AO_RTI_STICKY_REG0                                 (0xda100000 + (0x4c << 2))
+#define   P_AO_RTI_STICKY_REG0                                 (volatile uint32_t *)(0xc8100000 + (0x4c << 2))
+#define     AO_RTI_STICKY_REG1                                 (0xc8100000 + (0x4d << 2))
+#define SEC_AO_RTI_STICKY_REG1                                 (0xda100000 + (0x4d << 2))
+#define   P_AO_RTI_STICKY_REG1                                 (volatile uint32_t *)(0xc8100000 + (0x4d << 2))
+#define     AO_RTI_STICKY_REG2                                 (0xc8100000 + (0x4e << 2))
+#define SEC_AO_RTI_STICKY_REG2                                 (0xda100000 + (0x4e << 2))
+#define   P_AO_RTI_STICKY_REG2                                 (volatile uint32_t *)(0xc8100000 + (0x4e << 2))
+#define     AO_RTI_STICKY_REG3                                 (0xc8100000 + (0x4f << 2))
+#define SEC_AO_RTI_STICKY_REG3                                 (0xda100000 + (0x4f << 2))
+#define   P_AO_RTI_STICKY_REG3                                 (volatile uint32_t *)(0xc8100000 + (0x4f << 2))
+//
+// Secure APB3 Slot 2 registers
+//
+#define     AO_SEC_REG0                                        (0xc8100000 + (0x50 << 2))
+#define SEC_AO_SEC_REG0                                        (0xda100000 + (0x50 << 2))
+#define   P_AO_SEC_REG0                                        (volatile uint32_t *)(0xc8100000 + (0x50 << 2))
+#define     AO_SEC_REG1                                        (0xc8100000 + (0x51 << 2))
+#define SEC_AO_SEC_REG1                                        (0xda100000 + (0x51 << 2))
+#define   P_AO_SEC_REG1                                        (volatile uint32_t *)(0xc8100000 + (0x51 << 2))
+#define     AO_SEC_REG2                                        (0xc8100000 + (0x52 << 2))
+#define SEC_AO_SEC_REG2                                        (0xda100000 + (0x52 << 2))
+#define   P_AO_SEC_REG2                                        (volatile uint32_t *)(0xc8100000 + (0x52 << 2))
+#define     AO_SEC_TMODE_PWD0                                  (0xc8100000 + (0x58 << 2))
+#define SEC_AO_SEC_TMODE_PWD0                                  (0xda100000 + (0x58 << 2))
+#define   P_AO_SEC_TMODE_PWD0                                  (volatile uint32_t *)(0xc8100000 + (0x58 << 2))
+#define     AO_SEC_TMODE_PWD1                                  (0xc8100000 + (0x59 << 2))
+#define SEC_AO_SEC_TMODE_PWD1                                  (0xda100000 + (0x59 << 2))
+#define   P_AO_SEC_TMODE_PWD1                                  (volatile uint32_t *)(0xc8100000 + (0x59 << 2))
+#define     AO_SEC_TMODE_PWD2                                  (0xc8100000 + (0x5a << 2))
+#define SEC_AO_SEC_TMODE_PWD2                                  (0xda100000 + (0x5a << 2))
+#define   P_AO_SEC_TMODE_PWD2                                  (volatile uint32_t *)(0xc8100000 + (0x5a << 2))
+#define     AO_SEC_TMODE_PWD3                                  (0xc8100000 + (0x5b << 2))
+#define SEC_AO_SEC_TMODE_PWD3                                  (0xda100000 + (0x5b << 2))
+#define   P_AO_SEC_TMODE_PWD3                                  (volatile uint32_t *)(0xc8100000 + (0x5b << 2))
+#define     AO_SEC_SCRATCH                                     (0xc8100000 + (0x5f << 2))
+#define SEC_AO_SEC_SCRATCH                                     (0xda100000 + (0x5f << 2))
+#define   P_AO_SEC_SCRATCH                                     (volatile uint32_t *)(0xc8100000 + (0x5f << 2))
+#define     AO_SEC_JTAG_PWD0                                   (0xc8100000 + (0x60 << 2))
+#define SEC_AO_SEC_JTAG_PWD0                                   (0xda100000 + (0x60 << 2))
+#define   P_AO_SEC_JTAG_PWD0                                   (volatile uint32_t *)(0xc8100000 + (0x60 << 2))
+#define     AO_SEC_JTAG_PWD1                                   (0xc8100000 + (0x61 << 2))
+#define SEC_AO_SEC_JTAG_PWD1                                   (0xda100000 + (0x61 << 2))
+#define   P_AO_SEC_JTAG_PWD1                                   (volatile uint32_t *)(0xc8100000 + (0x61 << 2))
+#define     AO_SEC_JTAG_PWD2                                   (0xc8100000 + (0x62 << 2))
+#define SEC_AO_SEC_JTAG_PWD2                                   (0xda100000 + (0x62 << 2))
+#define   P_AO_SEC_JTAG_PWD2                                   (volatile uint32_t *)(0xc8100000 + (0x62 << 2))
+#define     AO_SEC_JTAG_PWD3                                   (0xc8100000 + (0x63 << 2))
+#define SEC_AO_SEC_JTAG_PWD3                                   (0xda100000 + (0x63 << 2))
+#define   P_AO_SEC_JTAG_PWD3                                   (volatile uint32_t *)(0xc8100000 + (0x63 << 2))
+#define     AO_SEC_JTAG_SEC_CNTL                               (0xc8100000 + (0x64 << 2))
+#define SEC_AO_SEC_JTAG_SEC_CNTL                               (0xda100000 + (0x64 << 2))
+#define   P_AO_SEC_JTAG_SEC_CNTL                               (volatile uint32_t *)(0xc8100000 + (0x64 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR0                              (0xc8100000 + (0x65 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR0                              (0xda100000 + (0x65 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR0                              (volatile uint32_t *)(0xc8100000 + (0x65 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR1                              (0xc8100000 + (0x66 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR1                              (0xda100000 + (0x66 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR1                              (volatile uint32_t *)(0xc8100000 + (0x66 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR2                              (0xc8100000 + (0x67 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR2                              (0xda100000 + (0x67 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR2                              (volatile uint32_t *)(0xc8100000 + (0x67 << 2))
+#define     AO_SEC_JTAG_PWD_ADDR3                              (0xc8100000 + (0x68 << 2))
+#define SEC_AO_SEC_JTAG_PWD_ADDR3                              (0xda100000 + (0x68 << 2))
+#define   P_AO_SEC_JTAG_PWD_ADDR3                              (volatile uint32_t *)(0xc8100000 + (0x68 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xc8100000 + (0x70 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (0xda100000 + (0x70 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_0                      (volatile uint32_t *)(0xc8100000 + (0x70 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xc8100000 + (0x71 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (0xda100000 + (0x71 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_1                      (volatile uint32_t *)(0xc8100000 + (0x71 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xc8100000 + (0x72 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (0xda100000 + (0x72 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG0_2                      (volatile uint32_t *)(0xc8100000 + (0x72 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xc8100000 + (0x73 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (0xda100000 + (0x73 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_0                      (volatile uint32_t *)(0xc8100000 + (0x73 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xc8100000 + (0x74 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (0xda100000 + (0x74 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_1                      (volatile uint32_t *)(0xc8100000 + (0x74 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xc8100000 + (0x75 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (0xda100000 + (0x75 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG1_2                      (volatile uint32_t *)(0xc8100000 + (0x75 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xc8100000 + (0x76 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (0xda100000 + (0x76 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_0                      (volatile uint32_t *)(0xc8100000 + (0x76 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xc8100000 + (0x77 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (0xda100000 + (0x77 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_1                      (volatile uint32_t *)(0xc8100000 + (0x77 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xc8100000 + (0x78 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (0xda100000 + (0x78 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG2_2                      (volatile uint32_t *)(0xc8100000 + (0x78 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xc8100000 + (0x79 << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (0xda100000 + (0x79 << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_0                      (volatile uint32_t *)(0xc8100000 + (0x79 << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xc8100000 + (0x7a << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (0xda100000 + (0x7a << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_1                      (volatile uint32_t *)(0xc8100000 + (0x7a << 2))
+#define     AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xc8100000 + (0x7b << 2))
+#define SEC_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (0xda100000 + (0x7b << 2))
+#define   P_AO_SEC_SHARED_AHB_SRAM_REG3_2                      (volatile uint32_t *)(0xc8100000 + (0x7b << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG0_0                          (0xc8100000 + (0x7c << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG0_0                          (0xda100000 + (0x7c << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG0_0                          (volatile uint32_t *)(0xc8100000 + (0x7c << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG0_1                          (0xc8100000 + (0x7d << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG0_1                          (0xda100000 + (0x7d << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG0_1                          (volatile uint32_t *)(0xc8100000 + (0x7d << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG1_0                          (0xc8100000 + (0x7e << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG1_0                          (0xda100000 + (0x7e << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG1_0                          (volatile uint32_t *)(0xc8100000 + (0x7e << 2))
+#define     AO_SEC_AO_AHB_SRAM_REG1_1                          (0xc8100000 + (0x7f << 2))
+#define SEC_AO_SEC_AO_AHB_SRAM_REG1_1                          (0xda100000 + (0x7f << 2))
+#define   P_AO_SEC_AO_AHB_SRAM_REG1_1                          (volatile uint32_t *)(0xc8100000 + (0x7f << 2))
+#define     AO_SEC_SD_CFG8                                     (0xc8100000 + (0x88 << 2))
+#define SEC_AO_SEC_SD_CFG8                                     (0xda100000 + (0x88 << 2))
+#define   P_AO_SEC_SD_CFG8                                     (volatile uint32_t *)(0xc8100000 + (0x88 << 2))
+#define     AO_SEC_SD_CFG9                                     (0xc8100000 + (0x89 << 2))
+#define SEC_AO_SEC_SD_CFG9                                     (0xda100000 + (0x89 << 2))
+#define   P_AO_SEC_SD_CFG9                                     (volatile uint32_t *)(0xc8100000 + (0x89 << 2))
+#define     AO_SEC_SD_CFG10                                    (0xc8100000 + (0x8a << 2))
+#define SEC_AO_SEC_SD_CFG10                                    (0xda100000 + (0x8a << 2))
+#define   P_AO_SEC_SD_CFG10                                    (volatile uint32_t *)(0xc8100000 + (0x8a << 2))
+#define     AO_SEC_SD_CFG11                                    (0xc8100000 + (0x8b << 2))
+#define SEC_AO_SEC_SD_CFG11                                    (0xda100000 + (0x8b << 2))
+#define   P_AO_SEC_SD_CFG11                                    (volatile uint32_t *)(0xc8100000 + (0x8b << 2))
+#define     AO_SEC_SD_CFG12                                    (0xc8100000 + (0x8c << 2))
+#define SEC_AO_SEC_SD_CFG12                                    (0xda100000 + (0x8c << 2))
+#define   P_AO_SEC_SD_CFG12                                    (volatile uint32_t *)(0xc8100000 + (0x8c << 2))
+#define     AO_SEC_SD_CFG13                                    (0xc8100000 + (0x8d << 2))
+#define SEC_AO_SEC_SD_CFG13                                    (0xda100000 + (0x8d << 2))
+#define   P_AO_SEC_SD_CFG13                                    (volatile uint32_t *)(0xc8100000 + (0x8d << 2))
+#define     AO_SEC_SD_CFG14                                    (0xc8100000 + (0x8e << 2))
+#define SEC_AO_SEC_SD_CFG14                                    (0xda100000 + (0x8e << 2))
+#define   P_AO_SEC_SD_CFG14                                    (volatile uint32_t *)(0xc8100000 + (0x8e << 2))
+#define     AO_SEC_SD_CFG15                                    (0xc8100000 + (0x8f << 2))
+#define SEC_AO_SEC_SD_CFG15                                    (0xda100000 + (0x8f << 2))
+#define   P_AO_SEC_SD_CFG15                                    (volatile uint32_t *)(0xc8100000 + (0x8f << 2))
+#define     AO_SEC_GP_CFG0                                     (0xc8100000 + (0x90 << 2))
+#define SEC_AO_SEC_GP_CFG0                                     (0xda100000 + (0x90 << 2))
+#define   P_AO_SEC_GP_CFG0                                     (volatile uint32_t *)(0xc8100000 + (0x90 << 2))
+#define     AO_SEC_GP_CFG1                                     (0xc8100000 + (0x91 << 2))
+#define SEC_AO_SEC_GP_CFG1                                     (0xda100000 + (0x91 << 2))
+#define   P_AO_SEC_GP_CFG1                                     (volatile uint32_t *)(0xc8100000 + (0x91 << 2))
+#define     AO_SEC_GP_CFG2                                     (0xc8100000 + (0x92 << 2))
+#define SEC_AO_SEC_GP_CFG2                                     (0xda100000 + (0x92 << 2))
+#define   P_AO_SEC_GP_CFG2                                     (volatile uint32_t *)(0xc8100000 + (0x92 << 2))
+#define     AO_SEC_GP_CFG3                                     (0xc8100000 + (0x93 << 2))
+#define SEC_AO_SEC_GP_CFG3                                     (0xda100000 + (0x93 << 2))
+#define   P_AO_SEC_GP_CFG3                                     (volatile uint32_t *)(0xc8100000 + (0x93 << 2))
+#define     AO_SEC_GP_CFG4                                     (0xc8100000 + (0x94 << 2))
+#define SEC_AO_SEC_GP_CFG4                                     (0xda100000 + (0x94 << 2))
+#define   P_AO_SEC_GP_CFG4                                     (volatile uint32_t *)(0xc8100000 + (0x94 << 2))
+#define     AO_SEC_GP_CFG5                                     (0xc8100000 + (0x95 << 2))
+#define SEC_AO_SEC_GP_CFG5                                     (0xda100000 + (0x95 << 2))
+#define   P_AO_SEC_GP_CFG5                                     (volatile uint32_t *)(0xc8100000 + (0x95 << 2))
+#define     AO_SEC_GP_CFG6                                     (0xc8100000 + (0x96 << 2))
+#define SEC_AO_SEC_GP_CFG6                                     (0xda100000 + (0x96 << 2))
+#define   P_AO_SEC_GP_CFG6                                     (volatile uint32_t *)(0xc8100000 + (0x96 << 2))
+#define     AO_SEC_GP_CFG7                                     (0xc8100000 + (0x97 << 2))
+#define SEC_AO_SEC_GP_CFG7                                     (0xda100000 + (0x97 << 2))
+#define   P_AO_SEC_GP_CFG7                                     (volatile uint32_t *)(0xc8100000 + (0x97 << 2))
+#define     AO_SEC_GP_CFG8                                     (0xc8100000 + (0x98 << 2))
+#define SEC_AO_SEC_GP_CFG8                                     (0xda100000 + (0x98 << 2))
+#define   P_AO_SEC_GP_CFG8                                     (volatile uint32_t *)(0xc8100000 + (0x98 << 2))
+#define     AO_SEC_GP_CFG9                                     (0xc8100000 + (0x99 << 2))
+#define SEC_AO_SEC_GP_CFG9                                     (0xda100000 + (0x99 << 2))
+#define   P_AO_SEC_GP_CFG9                                     (volatile uint32_t *)(0xc8100000 + (0x99 << 2))
+#define     AO_SEC_GP_CFG10                                    (0xc8100000 + (0x9a << 2))
+#define SEC_AO_SEC_GP_CFG10                                    (0xda100000 + (0x9a << 2))
+#define   P_AO_SEC_GP_CFG10                                    (volatile uint32_t *)(0xc8100000 + (0x9a << 2))
+#define     AO_SEC_GP_CFG11                                    (0xc8100000 + (0x9b << 2))
+#define SEC_AO_SEC_GP_CFG11                                    (0xda100000 + (0x9b << 2))
+#define   P_AO_SEC_GP_CFG11                                    (volatile uint32_t *)(0xc8100000 + (0x9b << 2))
+#define     AO_SEC_GP_CFG12                                    (0xc8100000 + (0x9c << 2))
+#define SEC_AO_SEC_GP_CFG12                                    (0xda100000 + (0x9c << 2))
+#define   P_AO_SEC_GP_CFG12                                    (volatile uint32_t *)(0xc8100000 + (0x9c << 2))
+#define     AO_SEC_GP_CFG13                                    (0xc8100000 + (0x9d << 2))
+#define SEC_AO_SEC_GP_CFG13                                    (0xda100000 + (0x9d << 2))
+#define   P_AO_SEC_GP_CFG13                                    (volatile uint32_t *)(0xc8100000 + (0x9d << 2))
+#define     AO_SEC_GP_CFG14                                    (0xc8100000 + (0x9e << 2))
+#define SEC_AO_SEC_GP_CFG14                                    (0xda100000 + (0x9e << 2))
+#define   P_AO_SEC_GP_CFG14                                    (volatile uint32_t *)(0xc8100000 + (0x9e << 2))
+#define     AO_SEC_GP_CFG15                                    (0xc8100000 + (0x9f << 2))
+#define SEC_AO_SEC_GP_CFG15                                    (0xda100000 + (0x9f << 2))
+#define   P_AO_SEC_GP_CFG15                                    (volatile uint32_t *)(0xc8100000 + (0x9f << 2))
+//`define AO_RTC_ADDR0                    8'h70 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR1                    8'h71 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR2                    8'h72 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR3                    8'h73 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+//`define AO_RTC_ADDR4                    8'h74 //TODO: DEFINE IF WE'RE IMPLEMENTING AO_RTC
+// -------------------------------------------------------------------
+// PSEL #1
+// -------------------------------------------------------------------
+// APB4_DECODER_NON_SECURE_BASE     32'hC8100400
+// APB4_DECODER_SECURE_BASE         32'hDA100400
+// ----------------------------
+// IR Remote (8)
+// ----------------------------
+#define     AO_IR_DEC_LDR_ACTIVE                               (0xc8100400 + (0x20 << 2))
+#define SEC_AO_IR_DEC_LDR_ACTIVE                               (0xda100400 + (0x20 << 2))
+#define   P_AO_IR_DEC_LDR_ACTIVE                               (volatile uint32_t *)(0xc8100400 + (0x20 << 2))
+#define     AO_IR_DEC_LDR_IDLE                                 (0xc8100400 + (0x21 << 2))
+#define SEC_AO_IR_DEC_LDR_IDLE                                 (0xda100400 + (0x21 << 2))
+#define   P_AO_IR_DEC_LDR_IDLE                                 (volatile uint32_t *)(0xc8100400 + (0x21 << 2))
+#define     AO_IR_DEC_LDR_REPEAT                               (0xc8100400 + (0x22 << 2))
+#define SEC_AO_IR_DEC_LDR_REPEAT                               (0xda100400 + (0x22 << 2))
+#define   P_AO_IR_DEC_LDR_REPEAT                               (volatile uint32_t *)(0xc8100400 + (0x22 << 2))
+#define     AO_IR_DEC_BIT_0                                    (0xc8100400 + (0x23 << 2))
+#define SEC_AO_IR_DEC_BIT_0                                    (0xda100400 + (0x23 << 2))
+#define   P_AO_IR_DEC_BIT_0                                    (volatile uint32_t *)(0xc8100400 + (0x23 << 2))
+#define     AO_IR_DEC_REG0                                     (0xc8100400 + (0x24 << 2))
+#define SEC_AO_IR_DEC_REG0                                     (0xda100400 + (0x24 << 2))
+#define   P_AO_IR_DEC_REG0                                     (volatile uint32_t *)(0xc8100400 + (0x24 << 2))
+#define     AO_IR_DEC_FRAME                                    (0xc8100400 + (0x25 << 2))
+#define SEC_AO_IR_DEC_FRAME                                    (0xda100400 + (0x25 << 2))
+#define   P_AO_IR_DEC_FRAME                                    (volatile uint32_t *)(0xc8100400 + (0x25 << 2))
+#define     AO_IR_DEC_STATUS                                   (0xc8100400 + (0x26 << 2))
+#define SEC_AO_IR_DEC_STATUS                                   (0xda100400 + (0x26 << 2))
+#define   P_AO_IR_DEC_STATUS                                   (volatile uint32_t *)(0xc8100400 + (0x26 << 2))
+#define     AO_IR_DEC_REG1                                     (0xc8100400 + (0x27 << 2))
+#define SEC_AO_IR_DEC_REG1                                     (0xda100400 + (0x27 << 2))
+#define   P_AO_IR_DEC_REG1                                     (volatile uint32_t *)(0xc8100400 + (0x27 << 2))
+// ----------------------------
+// UART
+// ----------------------------
+#define     AO_UART_WFIFO                                      (0xc8100400 + (0x30 << 2))
+#define SEC_AO_UART_WFIFO                                      (0xda100400 + (0x30 << 2))
+#define   P_AO_UART_WFIFO                                      (volatile uint32_t *)(0xc8100400 + (0x30 << 2))
+#define     AO_UART_RFIFO                                      (0xc8100400 + (0x31 << 2))
+#define SEC_AO_UART_RFIFO                                      (0xda100400 + (0x31 << 2))
+#define   P_AO_UART_RFIFO                                      (volatile uint32_t *)(0xc8100400 + (0x31 << 2))
+#define     AO_UART_CONTROL                                    (0xc8100400 + (0x32 << 2))
+#define SEC_AO_UART_CONTROL                                    (0xda100400 + (0x32 << 2))
+#define   P_AO_UART_CONTROL                                    (volatile uint32_t *)(0xc8100400 + (0x32 << 2))
+#define     AO_UART_STATUS                                     (0xc8100400 + (0x33 << 2))
+#define SEC_AO_UART_STATUS                                     (0xda100400 + (0x33 << 2))
+#define   P_AO_UART_STATUS                                     (volatile uint32_t *)(0xc8100400 + (0x33 << 2))
+#define     AO_UART_MISC                                       (0xc8100400 + (0x34 << 2))
+#define SEC_AO_UART_MISC                                       (0xda100400 + (0x34 << 2))
+#define   P_AO_UART_MISC                                       (volatile uint32_t *)(0xc8100400 + (0x34 << 2))
+#define     AO_UART_REG5                                       (0xc8100400 + (0x35 << 2))
+#define SEC_AO_UART_REG5                                       (0xda100400 + (0x35 << 2))
+#define   P_AO_UART_REG5                                       (volatile uint32_t *)(0xc8100400 + (0x35 << 2))
+// ----------------------------
+// UART2
+// ----------------------------
+#define     AO_UART2_WFIFO                                     (0xc8100400 + (0x38 << 2))
+#define SEC_AO_UART2_WFIFO                                     (0xda100400 + (0x38 << 2))
+#define   P_AO_UART2_WFIFO                                     (volatile uint32_t *)(0xc8100400 + (0x38 << 2))
+#define     AO_UART2_RFIFO                                     (0xc8100400 + (0x39 << 2))
+#define SEC_AO_UART2_RFIFO                                     (0xda100400 + (0x39 << 2))
+#define   P_AO_UART2_RFIFO                                     (volatile uint32_t *)(0xc8100400 + (0x39 << 2))
+#define     AO_UART2_CONTROL                                   (0xc8100400 + (0x3a << 2))
+#define SEC_AO_UART2_CONTROL                                   (0xda100400 + (0x3a << 2))
+#define   P_AO_UART2_CONTROL                                   (volatile uint32_t *)(0xc8100400 + (0x3a << 2))
+#define     AO_UART2_STATUS                                    (0xc8100400 + (0x3b << 2))
+#define SEC_AO_UART2_STATUS                                    (0xda100400 + (0x3b << 2))
+#define   P_AO_UART2_STATUS                                    (volatile uint32_t *)(0xc8100400 + (0x3b << 2))
+#define     AO_UART2_MISC                                      (0xc8100400 + (0x3c << 2))
+#define SEC_AO_UART2_MISC                                      (0xda100400 + (0x3c << 2))
+#define   P_AO_UART2_MISC                                      (volatile uint32_t *)(0xc8100400 + (0x3c << 2))
+#define     AO_UART2_REG5                                      (0xc8100400 + (0x3d << 2))
+#define SEC_AO_UART2_REG5                                      (0xda100400 + (0x3d << 2))
+#define   P_AO_UART2_REG5                                      (volatile uint32_t *)(0xc8100400 + (0x3d << 2))
+// ----------------------------
+// I2C Master (8)
+// ----------------------------
+#define     AO_I2C_M_0_CONTROL_REG                             (0xc8100400 + (0x40 << 2))
+#define SEC_AO_I2C_M_0_CONTROL_REG                             (0xda100400 + (0x40 << 2))
+#define   P_AO_I2C_M_0_CONTROL_REG                             (volatile uint32_t *)(0xc8100400 + (0x40 << 2))
+#define     AO_I2C_M_0_SLAVE_ADDR                              (0xc8100400 + (0x41 << 2))
+#define SEC_AO_I2C_M_0_SLAVE_ADDR                              (0xda100400 + (0x41 << 2))
+#define   P_AO_I2C_M_0_SLAVE_ADDR                              (volatile uint32_t *)(0xc8100400 + (0x41 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST0                             (0xc8100400 + (0x42 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST0                             (0xda100400 + (0x42 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST0                             (volatile uint32_t *)(0xc8100400 + (0x42 << 2))
+#define     AO_I2C_M_0_TOKEN_LIST1                             (0xc8100400 + (0x43 << 2))
+#define SEC_AO_I2C_M_0_TOKEN_LIST1                             (0xda100400 + (0x43 << 2))
+#define   P_AO_I2C_M_0_TOKEN_LIST1                             (volatile uint32_t *)(0xc8100400 + (0x43 << 2))
+#define     AO_I2C_M_0_WDATA_REG0                              (0xc8100400 + (0x44 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG0                              (0xda100400 + (0x44 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG0                              (volatile uint32_t *)(0xc8100400 + (0x44 << 2))
+#define     AO_I2C_M_0_WDATA_REG1                              (0xc8100400 + (0x45 << 2))
+#define SEC_AO_I2C_M_0_WDATA_REG1                              (0xda100400 + (0x45 << 2))
+#define   P_AO_I2C_M_0_WDATA_REG1                              (volatile uint32_t *)(0xc8100400 + (0x45 << 2))
+#define     AO_I2C_M_0_RDATA_REG0                              (0xc8100400 + (0x46 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG0                              (0xda100400 + (0x46 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG0                              (volatile uint32_t *)(0xc8100400 + (0x46 << 2))
+#define     AO_I2C_M_0_RDATA_REG1                              (0xc8100400 + (0x47 << 2))
+#define SEC_AO_I2C_M_0_RDATA_REG1                              (0xda100400 + (0x47 << 2))
+#define   P_AO_I2C_M_0_RDATA_REG1                              (volatile uint32_t *)(0xc8100400 + (0x47 << 2))
+// ----------------------------
+// I2C Slave (3)
+// ----------------------------
+#define     AO_I2C_S_CONTROL_REG                               (0xc8100400 + (0x50 << 2))
+#define SEC_AO_I2C_S_CONTROL_REG                               (0xda100400 + (0x50 << 2))
+#define   P_AO_I2C_S_CONTROL_REG                               (volatile uint32_t *)(0xc8100400 + (0x50 << 2))
+#define     AO_I2C_S_SEND_REG                                  (0xc8100400 + (0x51 << 2))
+#define SEC_AO_I2C_S_SEND_REG                                  (0xda100400 + (0x51 << 2))
+#define   P_AO_I2C_S_SEND_REG                                  (volatile uint32_t *)(0xc8100400 + (0x51 << 2))
+#define     AO_I2C_S_RECV_REG                                  (0xc8100400 + (0x52 << 2))
+#define SEC_AO_I2C_S_RECV_REG                                  (0xda100400 + (0x52 << 2))
+#define   P_AO_I2C_S_RECV_REG                                  (volatile uint32_t *)(0xc8100400 + (0x52 << 2))
+#define     AO_I2C_S_CNTL1_REG                                 (0xc8100400 + (0x53 << 2))
+#define SEC_AO_I2C_S_CNTL1_REG                                 (0xda100400 + (0x53 << 2))
+#define   P_AO_I2C_S_CNTL1_REG                                 (volatile uint32_t *)(0xc8100400 + (0x53 << 2))
+// ----------------------------
+// PWM A-B
+// ----------------------------
+#define     AO_PWM_PWM_A                                       (0xc8100400 + (0x54 << 2))
+#define SEC_AO_PWM_PWM_A                                       (0xda100400 + (0x54 << 2))
+#define   P_AO_PWM_PWM_A                                       (volatile uint32_t *)(0xc8100400 + (0x54 << 2))
+#define     AO_PWM_PWM_B                                       (0xc8100400 + (0x55 << 2))
+#define SEC_AO_PWM_PWM_B                                       (0xda100400 + (0x55 << 2))
+#define   P_AO_PWM_PWM_B                                       (volatile uint32_t *)(0xc8100400 + (0x55 << 2))
+#define     AO_PWM_MISC_REG_AB                                 (0xc8100400 + (0x56 << 2))
+#define SEC_AO_PWM_MISC_REG_AB                                 (0xda100400 + (0x56 << 2))
+#define   P_AO_PWM_MISC_REG_AB                                 (volatile uint32_t *)(0xc8100400 + (0x56 << 2))
+#define     AO_PWM_DELTA_SIGMA_AB                              (0xc8100400 + (0x57 << 2))
+#define SEC_AO_PWM_DELTA_SIGMA_AB                              (0xda100400 + (0x57 << 2))
+#define   P_AO_PWM_DELTA_SIGMA_AB                              (volatile uint32_t *)(0xc8100400 + (0x57 << 2))
+#define     AO_PWM_TIME_AB                                     (0xc8100400 + (0x58 << 2))
+#define SEC_AO_PWM_TIME_AB                                     (0xda100400 + (0x58 << 2))
+#define   P_AO_PWM_TIME_AB                                     (volatile uint32_t *)(0xc8100400 + (0x58 << 2))
+#define     AO_PWM_A2                                          (0xc8100400 + (0x59 << 2))
+#define SEC_AO_PWM_A2                                          (0xda100400 + (0x59 << 2))
+#define   P_AO_PWM_A2                                          (volatile uint32_t *)(0xc8100400 + (0x59 << 2))
+#define     AO_PWM_B2                                          (0xc8100400 + (0x5a << 2))
+#define SEC_AO_PWM_B2                                          (0xda100400 + (0x5a << 2))
+#define   P_AO_PWM_B2                                          (volatile uint32_t *)(0xc8100400 + (0x5a << 2))
+// ----------------------------
+// Multiformat IR Remote
+// ----------------------------
+#define     AO_MF_IR_DEC_LDR_ACTIVE                            (0xc8100400 + (0x60 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_ACTIVE                            (0xda100400 + (0x60 << 2))
+#define   P_AO_MF_IR_DEC_LDR_ACTIVE                            (volatile uint32_t *)(0xc8100400 + (0x60 << 2))
+#define     AO_MF_IR_DEC_LDR_IDLE                              (0xc8100400 + (0x61 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_IDLE                              (0xda100400 + (0x61 << 2))
+#define   P_AO_MF_IR_DEC_LDR_IDLE                              (volatile uint32_t *)(0xc8100400 + (0x61 << 2))
+#define     AO_MF_IR_DEC_LDR_REPEAT                            (0xc8100400 + (0x62 << 2))
+#define SEC_AO_MF_IR_DEC_LDR_REPEAT                            (0xda100400 + (0x62 << 2))
+#define   P_AO_MF_IR_DEC_LDR_REPEAT                            (volatile uint32_t *)(0xc8100400 + (0x62 << 2))
+#define     AO_MF_IR_DEC_BIT_0                                 (0xc8100400 + (0x63 << 2))
+#define SEC_AO_MF_IR_DEC_BIT_0                                 (0xda100400 + (0x63 << 2))
+#define   P_AO_MF_IR_DEC_BIT_0                                 (volatile uint32_t *)(0xc8100400 + (0x63 << 2))
+#define     AO_MF_IR_DEC_REG0                                  (0xc8100400 + (0x64 << 2))
+#define SEC_AO_MF_IR_DEC_REG0                                  (0xda100400 + (0x64 << 2))
+#define   P_AO_MF_IR_DEC_REG0                                  (volatile uint32_t *)(0xc8100400 + (0x64 << 2))
+#define     AO_MF_IR_DEC_FRAME                                 (0xc8100400 + (0x65 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME                                 (0xda100400 + (0x65 << 2))
+#define   P_AO_MF_IR_DEC_FRAME                                 (volatile uint32_t *)(0xc8100400 + (0x65 << 2))
+#define     AO_MF_IR_DEC_STATUS                                (0xc8100400 + (0x66 << 2))
+#define SEC_AO_MF_IR_DEC_STATUS                                (0xda100400 + (0x66 << 2))
+#define   P_AO_MF_IR_DEC_STATUS                                (volatile uint32_t *)(0xc8100400 + (0x66 << 2))
+#define     AO_MF_IR_DEC_REG1                                  (0xc8100400 + (0x67 << 2))
+#define SEC_AO_MF_IR_DEC_REG1                                  (0xda100400 + (0x67 << 2))
+#define   P_AO_MF_IR_DEC_REG1                                  (volatile uint32_t *)(0xc8100400 + (0x67 << 2))
+#define     AO_MF_IR_DEC_REG2                                  (0xc8100400 + (0x68 << 2))
+#define SEC_AO_MF_IR_DEC_REG2                                  (0xda100400 + (0x68 << 2))
+#define   P_AO_MF_IR_DEC_REG2                                  (volatile uint32_t *)(0xc8100400 + (0x68 << 2))
+#define     AO_MF_IR_DEC_DURATN2                               (0xc8100400 + (0x69 << 2))
+#define SEC_AO_MF_IR_DEC_DURATN2                               (0xda100400 + (0x69 << 2))
+#define   P_AO_MF_IR_DEC_DURATN2                               (volatile uint32_t *)(0xc8100400 + (0x69 << 2))
+#define     AO_MF_IR_DEC_DURATN3                               (0xc8100400 + (0x6a << 2))
+#define SEC_AO_MF_IR_DEC_DURATN3                               (0xda100400 + (0x6a << 2))
+#define   P_AO_MF_IR_DEC_DURATN3                               (volatile uint32_t *)(0xc8100400 + (0x6a << 2))
+#define     AO_MF_IR_DEC_FRAME1                                (0xc8100400 + (0x6b << 2))
+#define SEC_AO_MF_IR_DEC_FRAME1                                (0xda100400 + (0x6b << 2))
+#define   P_AO_MF_IR_DEC_FRAME1                                (volatile uint32_t *)(0xc8100400 + (0x6b << 2))
+#define     AO_MF_IR_DEC_STATUS1                               (0xc8100400 + (0x6c << 2))
+#define SEC_AO_MF_IR_DEC_STATUS1                               (0xda100400 + (0x6c << 2))
+#define   P_AO_MF_IR_DEC_STATUS1                               (volatile uint32_t *)(0xc8100400 + (0x6c << 2))
+#define     AO_MF_IR_DEC_STATUS2                               (0xc8100400 + (0x6d << 2))
+#define SEC_AO_MF_IR_DEC_STATUS2                               (0xda100400 + (0x6d << 2))
+#define   P_AO_MF_IR_DEC_STATUS2                               (volatile uint32_t *)(0xc8100400 + (0x6d << 2))
+#define     AO_MF_IR_DEC_REG3                                  (0xc8100400 + (0x6e << 2))
+#define SEC_AO_MF_IR_DEC_REG3                                  (0xda100400 + (0x6e << 2))
+#define   P_AO_MF_IR_DEC_REG3                                  (volatile uint32_t *)(0xc8100400 + (0x6e << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV0                            (0xc8100400 + (0x6f << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV0                            (0xda100400 + (0x6f << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV0                            (volatile uint32_t *)(0xc8100400 + (0x6f << 2))
+#define     AO_MF_IR_DEC_FRAME_RSV1                            (0xc8100400 + (0x70 << 2))
+#define SEC_AO_MF_IR_DEC_FRAME_RSV1                            (0xda100400 + (0x70 << 2))
+#define   P_AO_MF_IR_DEC_FRAME_RSV1                            (volatile uint32_t *)(0xc8100400 + (0x70 << 2))
+#define     AO_MF_IR_DEC_FILTE                                 (0xc8100400 + (0x71 << 2))
+#define SEC_AO_MF_IR_DEC_FILTE                                 (0xda100400 + (0x71 << 2))
+#define   P_AO_MF_IR_DEC_FILTE                                 (volatile uint32_t *)(0xc8100400 + (0x71 << 2))
+#define     AO_MF_IR_DEC_IRQ_CTL                               (0xc8100400 + (0x72 << 2))
+#define SEC_AO_MF_IR_DEC_IRQ_CTL                               (0xda100400 + (0x72 << 2))
+#define   P_AO_MF_IR_DEC_IRQ_CTL                               (volatile uint32_t *)(0xc8100400 + (0x72 << 2))
+#define     AO_MF_IR_DEC_FIFO_CTL                              (0xc8100400 + (0x73 << 2))
+#define SEC_AO_MF_IR_DEC_FIFO_CTL                              (0xda100400 + (0x73 << 2))
+#define   P_AO_MF_IR_DEC_FIFO_CTL                              (volatile uint32_t *)(0xc8100400 + (0x73 << 2))
+#define     AO_MF_IR_DEC_WIDTH_NEW                             (0xc8100400 + (0x74 << 2))
+#define SEC_AO_MF_IR_DEC_WIDTH_NEW                             (0xda100400 + (0x74 << 2))
+#define   P_AO_MF_IR_DEC_WIDTH_NEW                             (volatile uint32_t *)(0xc8100400 + (0x74 << 2))
+#define     AO_MF_IR_DEC_REPEAT_DET                            (0xc8100400 + (0x75 << 2))
+#define SEC_AO_MF_IR_DEC_REPEAT_DET                            (0xda100400 + (0x75 << 2))
+#define   P_AO_MF_IR_DEC_REPEAT_DET                            (volatile uint32_t *)(0xc8100400 + (0x75 << 2))
+// ---------------------------
+// SAR ADC
+// ---------------------------
+#define     AO_SAR_ADC_REG0                                    (0xc8100400 + (0x80 << 2))
+#define SEC_AO_SAR_ADC_REG0                                    (0xda100400 + (0x80 << 2))
+#define   P_AO_SAR_ADC_REG0                                    (volatile uint32_t *)(0xc8100400 + (0x80 << 2))
+#define     AO_SAR_ADC_CHAN_LIST                               (0xc8100400 + (0x81 << 2))
+#define SEC_AO_SAR_ADC_CHAN_LIST                               (0xda100400 + (0x81 << 2))
+#define   P_AO_SAR_ADC_CHAN_LIST                               (volatile uint32_t *)(0xc8100400 + (0x81 << 2))
+#define     AO_SAR_ADC_AVG_CNTL                                (0xc8100400 + (0x82 << 2))
+#define SEC_AO_SAR_ADC_AVG_CNTL                                (0xda100400 + (0x82 << 2))
+#define   P_AO_SAR_ADC_AVG_CNTL                                (volatile uint32_t *)(0xc8100400 + (0x82 << 2))
+#define     AO_SAR_ADC_REG3                                    (0xc8100400 + (0x83 << 2))
+#define SEC_AO_SAR_ADC_REG3                                    (0xda100400 + (0x83 << 2))
+#define   P_AO_SAR_ADC_REG3                                    (volatile uint32_t *)(0xc8100400 + (0x83 << 2))
+#define     AO_SAR_ADC_DELAY                                   (0xc8100400 + (0x84 << 2))
+#define SEC_AO_SAR_ADC_DELAY                                   (0xda100400 + (0x84 << 2))
+#define   P_AO_SAR_ADC_DELAY                                   (volatile uint32_t *)(0xc8100400 + (0x84 << 2))
+#define     AO_SAR_ADC_LAST_RD                                 (0xc8100400 + (0x85 << 2))
+#define SEC_AO_SAR_ADC_LAST_RD                                 (0xda100400 + (0x85 << 2))
+#define   P_AO_SAR_ADC_LAST_RD                                 (volatile uint32_t *)(0xc8100400 + (0x85 << 2))
+#define     AO_SAR_ADC_FIFO_RD                                 (0xc8100400 + (0x86 << 2))
+#define SEC_AO_SAR_ADC_FIFO_RD                                 (0xda100400 + (0x86 << 2))
+#define   P_AO_SAR_ADC_FIFO_RD                                 (volatile uint32_t *)(0xc8100400 + (0x86 << 2))
+#define     AO_SAR_ADC_AUX_SW                                  (0xc8100400 + (0x87 << 2))
+#define SEC_AO_SAR_ADC_AUX_SW                                  (0xda100400 + (0x87 << 2))
+#define   P_AO_SAR_ADC_AUX_SW                                  (volatile uint32_t *)(0xc8100400 + (0x87 << 2))
+#define     AO_SAR_ADC_CHAN_10_SW                              (0xc8100400 + (0x88 << 2))
+#define SEC_AO_SAR_ADC_CHAN_10_SW                              (0xda100400 + (0x88 << 2))
+#define   P_AO_SAR_ADC_CHAN_10_SW                              (volatile uint32_t *)(0xc8100400 + (0x88 << 2))
+#define     AO_SAR_ADC_DETECT_IDLE_SW                          (0xc8100400 + (0x89 << 2))
+#define SEC_AO_SAR_ADC_DETECT_IDLE_SW                          (0xda100400 + (0x89 << 2))
+#define   P_AO_SAR_ADC_DETECT_IDLE_SW                          (volatile uint32_t *)(0xc8100400 + (0x89 << 2))
+#define     AO_SAR_ADC_DELTA_10                                (0xc8100400 + (0x8a << 2))
+#define SEC_AO_SAR_ADC_DELTA_10                                (0xda100400 + (0x8a << 2))
+#define   P_AO_SAR_ADC_DELTA_10                                (volatile uint32_t *)(0xc8100400 + (0x8a << 2))
+#define     AO_SAR_ADC_REG11                                   (0xc8100400 + (0x8b << 2))
+#define SEC_AO_SAR_ADC_REG11                                   (0xda100400 + (0x8b << 2))
+#define   P_AO_SAR_ADC_REG11                                   (volatile uint32_t *)(0xc8100400 + (0x8b << 2))
+#define     AO_SAR_ADC_REG12                                   (0xc8100400 + (0x8c << 2))
+#define SEC_AO_SAR_ADC_REG12                                   (0xda100400 + (0x8c << 2))
+#define   P_AO_SAR_ADC_REG12                                   (volatile uint32_t *)(0xc8100400 + (0x8c << 2))
+#define     AO_SAR_ADC_REG13                                   (0xc8100400 + (0x8d << 2))
+#define SEC_AO_SAR_ADC_REG13                                   (0xda100400 + (0x8d << 2))
+#define   P_AO_SAR_ADC_REG13                                   (volatile uint32_t *)(0xc8100400 + (0x8d << 2))
+// ---------------------------
+// RTC (4)
+// ---------------------------
+// Moved to the secure APB3 bus
+// `define AO_RTC_ADDR0                8'hd0
+// `define AO_RTC_ADDR1                8'hd1
+// `define AO_RTC_ADDR2                8'hd2
+// `define AO_RTC_ADDR3                8'hd3
+// `define AO_RTC_ADDR4                8'hd4
+//
+// Closing file:  ./ao_rti_reg.h
+//
+
+#endif // SECURE_APB_H
+
diff --git a/arch/arm/include/asm/arch-txl/thermal.h b/arch/arm/include/asm/arch-txl/thermal.h
new file mode 100644
index 0000000..4282b58
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/thermal.h
@@ -0,0 +1,45 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/thermal.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#define SAR_ADC_BASE			0xc8100400+0x80*4
+
+#define SAR_ADC_REG0 			SAR_ADC_BASE +(0x0*4)//0xc8100600
+#define SAR_ADC_CHAN_LIST		SAR_ADC_BASE +(0x1*4)//0xc8100604
+#define SAR_ADC_AVG_CNTL		SAR_ADC_BASE +(0x2*4)//0xc8100608
+#define SAR_ADC_REG3			SAR_ADC_BASE +(0x3*4)//0xc810060c
+#define SAR_ADC_DELAY			SAR_ADC_BASE +(0x4*4)//0xc8100610
+#define SAR_ADC_LAST_RD			SAR_ADC_BASE +(0x5*4)//0xc8100614
+#define SAR_ADC_FIFO_RD			SAR_ADC_BASE +(0x6*4)//0xc8100618
+#define SAR_ADC_AUX_SW			SAR_ADC_BASE +(0x7*4)//0xc810061c
+#define SAR_ADC_CHAN_10_SW		SAR_ADC_BASE +(0x8*4)//0xc8100620
+#define SAR_ADC_DETECT_IDLE_SW	SAR_ADC_BASE +(0x9*4)//0xc8100624
+#define SAR_ADC_DELTA_10		SAR_ADC_BASE +(0xa*4)//0xc8100628
+#define SAR_ADC_REG11			SAR_ADC_BASE +(0xb*4)//0xc810062c
+#define SAR_ADC_REG12			SAR_ADC_BASE +(0xc*4)//0xc8100630
+#define SAR_ADC_REG13			SAR_ADC_BASE +(0xd*4)//0xc8100634
+#define SAR_CLK_CNTL			AO_SAR_CLK
+#define SAR_BUS_CLK_EN			AO_RTI_GEN_CNTL_REG0
+
+#define EN_BIT					7
+#define FLAG_BUSY_KERNEL		(1<<14)
+#define FLAG_BUSY_BL30			(1<<15)
+
+#define SAMPLE_BIT_MASK			0xfff  /*12bit*/
diff --git a/arch/arm/include/asm/arch-txl/timer.h b/arch/arm/include/asm/arch-txl/timer.h
new file mode 100644
index 0000000..6710403
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/timer.h
@@ -0,0 +1,41 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/timer.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __TIMER_H
+#define __TIMER_H
+
+#include <asm/arch/romboot.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/io.h>
+
+/**
+ * Get the current timestamp from the system timer.
+ */
+uint32_t get_time(void);
+
+/**
+ * Busy-wait.
+ *
+ * @param us            Number of microseconds to delay.
+ */
+void _udelay(unsigned int us);
+
+#endif /* __TIMER_H */
diff --git a/arch/arm/include/asm/arch-txl/timing.h b/arch/arm/include/asm/arch-txl/timing.h
new file mode 100644
index 0000000..98c197c
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/timing.h
@@ -0,0 +1,209 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/timing.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __AML_TIMING_H_
+#define __AML_TIMING_H_
+
+struct ddr_set{
+	/* common and function defines */
+	unsigned char  ddr_channel_set;
+	unsigned char  ddr_type;
+	unsigned char  ddr_2t_mode;
+	unsigned char  ddr_full_test;
+	unsigned char  ddr_size_detect;
+	unsigned char  ddr_drv;
+	unsigned char  ddr_odt;
+	unsigned char  ddr_timing_ind;
+	unsigned short ddr_size; //define in header file
+	unsigned short ddr_clk;
+	unsigned int   ddr_base_addr;
+	unsigned int   ddr_start_offset;
+	unsigned int   ddr_pll_ctrl;
+	unsigned int   ddr_dmc_ctrl;
+	unsigned int   ddr0_addrmap[5];
+	unsigned int   ddr1_addrmap[5];
+
+	/* pub defines */
+	unsigned int   t_pub_ptr[5];  //PUB PTR0-3
+	unsigned short t_pub_mr[8];   //PUB MR0-3
+	unsigned int   t_pub_odtcr;
+	unsigned int   t_pub_dtpr[8]; //PUB DTPR0-3
+	unsigned int   t_pub_pgcr0;   //PUB PGCR0
+	unsigned int   t_pub_pgcr1;   //PUB PGCR1
+	unsigned int   t_pub_pgcr2;   //PUB PGCR2
+	unsigned int   t_pub_pgcr3;   //PUB PGCR3
+	unsigned int   t_pub_dxccr;   //PUB DXCCR
+	unsigned int   t_pub_dtcr0;    //PUB DTCR
+	unsigned int   t_pub_dtcr1;    //PUB DTCR
+	unsigned int   t_pub_aciocr[5];  //PUB ACIOCRx
+	unsigned int   t_pub_dx0gcr[3];  //PUB DX0GCRx
+	unsigned int   t_pub_dx1gcr[3];  //PUB DX1GCRx
+	unsigned int   t_pub_dx2gcr[3];  //PUB DX2GCRx
+	unsigned int   t_pub_dx3gcr[3];  //PUB DX3GCRx
+	unsigned int   t_pub_dcr;     //PUB DCR
+	unsigned int   t_pub_dtar;
+	unsigned int   t_pub_dsgcr;   //PUB DSGCR
+	unsigned int   t_pub_zq0pr;   //PUB ZQ0PR
+	unsigned int   t_pub_zq1pr;   //PUB ZQ1PR
+	unsigned int   t_pub_zq2pr;   //PUB ZQ2PR
+	unsigned int   t_pub_zq3pr;   //PUB ZQ3PR
+	unsigned int   t_pub_vtcr1;
+
+	/* pctl0 defines */
+	unsigned short t_pctl0_1us_pck;   //PCTL TOGCNT1U
+	unsigned short t_pctl0_100ns_pck; //PCTL TOGCNT100N
+	unsigned short t_pctl0_init_us;   //PCTL TINIT
+	unsigned short t_pctl0_rsth_us;   //PCTL TRSTH
+	unsigned int   t_pctl0_mcfg;   //PCTL MCFG
+	unsigned int   t_pctl0_mcfg1;  //PCTL MCFG1
+	unsigned short t_pctl0_scfg;   //PCTL SCFG
+	unsigned short t_pctl0_sctl;   //PCTL SCTL
+	unsigned int   t_pctl0_ppcfg;
+	unsigned short t_pctl0_dfistcfg0;
+	unsigned short t_pctl0_dfistcfg1;
+	unsigned short t_pctl0_dfitctrldelay;
+	unsigned short t_pctl0_dfitphywrdata;
+	unsigned short t_pctl0_dfitphywrlta;
+	unsigned short t_pctl0_dfitrddataen;
+	unsigned short t_pctl0_dfitphyrdlat;
+	unsigned short t_pctl0_dfitdramclkdis;
+	unsigned short t_pctl0_dfitdramclken;
+	unsigned short t_pctl0_dfitphyupdtype0;
+	unsigned short t_pctl0_dfitphyupdtype1;
+	unsigned short t_pctl0_dfitctrlupdmin;
+	unsigned short t_pctl0_dfitctrlupdmax; //TODO - check 16/32
+	unsigned short t_pctl0_dfiupdcfg; //TODO - check 16/32
+	unsigned short t_pctl0_cmdtstaten;
+	unsigned short t_ddr_align;
+	unsigned int   t_pctl0_dfiodtcfg;
+	unsigned int   t_pctl0_dfiodtcfg1;
+	unsigned int   t_pctl0_dfilpcfg0;
+
+	//PUB CLK fine tune
+	unsigned int   t_pub_acbdlr0; //2015.09.21 CK0 delay for different board PCB design
+	unsigned int   t_pub_aclcdlr;
+
+	/* ddr functions */
+	unsigned int   ddr_func;
+	/* dqs correction */
+	unsigned char  wr_adj_per[6];
+	unsigned char  rd_adj_per[6];
+
+	/* aligned */
+	/* 2016.04.12 update */
+	unsigned short ddr4_clk; //2016.05.13 add
+	unsigned char  ddr4_drv; //2016.05.13 add
+	unsigned char  ddr4_odt; //2016.05.13 add
+
+	/* 2016.05.24 update */
+	unsigned int  t_pub_acbdlr3;
+
+	/* 2016.07.07 update */
+	unsigned short  t_pub_soc_vref_dram_vref;
+	unsigned short  t_rsv_short_1;
+	unsigned int   t_rsv_int_1;
+	unsigned long  t_rsv_int64_2;
+}__attribute__ ((packed));
+
+struct ddr_timing{
+	//Identifier
+	unsigned char  identifier; //refer ddr.h
+
+	//DTPR0
+	unsigned char  cfg_ddr_rtp;
+	unsigned char  cfg_ddr_wtr;
+	unsigned char  cfg_ddr_rp;
+	unsigned char  cfg_ddr_rcd;
+	unsigned char  cfg_ddr_ras;
+	unsigned char  cfg_ddr_rrd;
+	unsigned char  cfg_ddr_rc;
+
+	//DTPR1
+	unsigned char  cfg_ddr_mrd;
+	unsigned char  cfg_ddr_mod;
+	unsigned char  cfg_ddr_faw;
+	unsigned char  cfg_ddr_wlmrd;
+	unsigned char  cfg_ddr_wlo;
+
+	//DTPR2
+	unsigned char  cfg_ddr_xp;
+
+	//DTPR1
+	unsigned short cfg_ddr_rfc;
+
+	//DTPR2
+	unsigned short cfg_ddr_xs;
+	unsigned short cfg_ddr_dllk;
+	unsigned char  cfg_ddr_cke;
+	unsigned char  cfg_ddr_rtodt;
+	unsigned char  cfg_ddr_rtw;
+
+	unsigned char  cfg_ddr_refi;
+	unsigned char  cfg_ddr_refi_mddr3;
+	unsigned char  cfg_ddr_cl;
+	unsigned char  cfg_ddr_wr;
+	unsigned char  cfg_ddr_cwl;
+	unsigned char  cfg_ddr_al;
+	unsigned char  cfg_ddr_dqs;
+	unsigned char  cfg_ddr_cksre;
+	unsigned char  cfg_ddr_cksrx;
+	unsigned char  cfg_ddr_zqcs;
+	unsigned char  cfg_ddr_xpdll;
+	unsigned short cfg_ddr_exsr;
+	unsigned short cfg_ddr_zqcl;
+	unsigned short cfg_ddr_zqcsi;
+
+	/* aligned */
+	/* 2016.04.12 update */
+	unsigned char  cfg_ddr_tccdl;
+	unsigned char  cfg_ddr_tdqsck;
+	unsigned char  cfg_ddr_tdqsckmax;
+	unsigned char  rsv_char;
+
+	/* reserved */
+	unsigned int   rsv_int;
+}__attribute__ ((packed));
+
+typedef struct ddr_set ddr_set_t;
+typedef struct ddr_timing ddr_timing_t;
+
+struct pll_set{
+	unsigned short cpu_clk;
+	unsigned short pxp;
+	unsigned int spi_ctrl;
+	unsigned short vddee;
+	unsigned short vcck;
+	unsigned char szPad[4];
+	unsigned long  lCustomerID;
+	unsigned short	debug_mode;
+	unsigned short	ddr_clk_debug;
+	unsigned short	cpu_clk_debug;
+	unsigned short	rsv_s1;
+	/* align */
+	unsigned long	rsv_l2;
+	unsigned long	rsv_l3;
+	unsigned long	rsv_l4;
+	unsigned long	rsv_l5;
+}__attribute__ ((packed));
+
+typedef struct pll_set pll_set_t;
+
+#endif //__AML_TIMING_H_
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-txl/uart.h b/arch/arm/include/asm/arch-txl/uart.h
new file mode 100644
index 0000000..3fbc14e
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/uart.h
@@ -0,0 +1,168 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/uart.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __MESON_FIRM_UART_H_
+#define __MESON_FIRM_UART_H_
+#include <config.h>
+#include <common.h>
+#include "register.h"
+//#include "io.h"
+
+
+#ifndef CONFIG_CONS_INDEX
+#error Please define CONFIG_CONS_INDEX==[0|1]
+#endif
+
+#if CONFIG_CONS_INDEX==0
+#define UART_PORT_CONS UART_PORT_0
+#elif CONFIG_CONS_INDEX==1
+#define UART_PORT_CONS UART_PORT_1
+#elif CONFIG_CONS_INDEX==2
+#define UART_PORT_CONS UART_PORT_AO
+#define USE_AO_UART   1
+#else
+#error Please define CONFIG_CONS_INDEX==[0|1]
+#endif
+/*
+#define UART_PORT_0     CBUS_REG_ADDR(UART0_WFIFO)
+#define UART_PORT_1     CBUS_REG_ADDR(UART1_WFIFO)
+#define UART_PORT_2     CBUS_REG_ADDR(UART2_WFIFO)
+#define UART_PORT_AO    P_AO_UART_WFIFO
+
+#define UART_WFIFO      (0<<2)
+#define UART_RFIFO      (1<<2)
+#define UART_CONTROL    (2<<2)
+#define UART_STATUS     (3<<2)
+#define UART_MISC       (4<<2)
+*/
+
+#include "clock.h"
+
+#define UART_CLK_SRC    CLK81
+#define UART_PORT_0     UART0_WFIFO
+#define UART_PORT_1     UART1_WFIFO
+#define UART_PORT_AO    P_AO_UART_WFIFO
+#define UART_WFIFO      0
+#define UART_RFIFO      1
+#define UART_CONTROL    2
+#define UART_STATUS     3
+#define UART_MISC       4
+
+#if USE_AO_UART == 1
+#define P_UART(uart_base,reg)    	  (uart_base + (reg<<2))
+#else
+#define P_UART(uart_base,reg)    	CBUS_REG_ADDR(uart_base+reg)
+#endif
+#define P_UART_WFIFO(uart_base)   	P_UART(uart_base,UART_WFIFO)
+#define P_UART_RFIFO(uart_base)   	P_UART(uart_base,UART_RFIFO)
+
+#define P_UART_CONTROL(uart_base)    P_UART(uart_base,UART_CONTROL)
+    #define UART_CNTL_MASK_BAUD_RATE                (0xfff)
+    #define UART_CNTL_MASK_TX_EN                    (1<<12)
+    #define UART_CNTL_MASK_RX_EN                    (1<<13)
+    #define UART_CNTL_MASK_2WIRE                    (1<<15)
+    #define UART_CNTL_MASK_STP_BITS                 (3<<16)
+    #define UART_CNTL_MASK_STP_1BIT                 (0<<16)
+    #define UART_CNTL_MASK_STP_2BIT                 (1<<16)
+    #define UART_CNTL_MASK_PRTY_EVEN                (0<<18)
+    #define UART_CNTL_MASK_PRTY_ODD                 (1<<18)
+    #define UART_CNTL_MASK_PRTY_TYPE                (1<<18)
+    #define UART_CNTL_MASK_PRTY_EN                  (1<<19)
+    #define UART_CNTL_MASK_CHAR_LEN                 (3<<20)
+    #define UART_CNTL_MASK_CHAR_8BIT                (0<<20)
+    #define UART_CNTL_MASK_CHAR_7BIT                (1<<20)
+    #define UART_CNTL_MASK_CHAR_6BIT                (2<<20)
+    #define UART_CNTL_MASK_CHAR_5BIT                (3<<20)
+    #define UART_CNTL_MASK_RST_TX                   (1<<22)
+    #define UART_CNTL_MASK_RST_RX                   (1<<23)
+    #define UART_CNTL_MASK_CLR_ERR                  (1<<24)
+    #define UART_CNTL_MASK_INV_RX                   (1<<25)
+    #define UART_CNTL_MASK_INV_TX                   (1<<26)
+    #define UART_CNTL_MASK_RINT_EN                  (1<<27)
+    #define UART_CNTL_MASK_TINT_EN                  (1<<28)
+    #define UART_CNTL_MASK_INV_CTS                  (1<<29)
+    #define UART_CNTL_MASK_MASK_ERR                 (1<<30)
+    #define UART_CNTL_MASK_INV_RTS                  (1<<31)
+#define P_UART_STATUS(uart_base)  P_UART(uart_base,UART_STATUS )
+    #define UART_STAT_MASK_RFIFO_CNT                (0x7f<<0)
+    #define UART_STAT_MASK_TFIFO_CNT                (0x7f<<8)
+    #define UART_STAT_MASK_PRTY_ERR                 (1<<16)
+    #define UART_STAT_MASK_FRAM_ERR                 (1<<17)
+    #define UART_STAT_MASK_WFULL_ERR                (1<<18)
+    #define UART_STAT_MASK_RFIFO_FULL               (1<<19)
+    #define UART_STAT_MASK_RFIFO_EMPTY              (1<<20)
+    #define UART_STAT_MASK_TFIFO_FULL               (1<<21)
+    #define UART_STAT_MASK_TFIFO_EMPTY              (1<<22)
+    #define UART_STAT_MASK_XMIT_BUSY					(1<<25)
+    #define UART_STAT_MASK_RECV_BUSY					(1<<26)
+#define P_UART_MISC(uart_base)    P_UART(uart_base,UART_MISC   )
+
+
+#ifndef CONFIG_SERIAL_STP_BITS
+#define CONFIG_SERIAL_STP_BITS 1 // 1 , 2
+#endif
+#if CONFIG_SERIAL_STP_BITS==1
+#define UART_STP_BIT UART_CNTL_MASK_STP_1BIT
+#elif CONFIG_SERIAL_STP_BITS==2
+#define UART_STP_BIT UART_CNTL_MASK_STP_2BIT
+#else
+#error CONFIG_SERIAL_STP_BITS wrong
+#endif
+
+
+#ifndef CONFIG_SERIAL_PRTY_TYPE
+#define CONFIG_SERIAL_PRTY_TYPE 0 //0 ,2 ,3
+#endif
+#if CONFIG_SERIAL_PRTY_TYPE==0
+#define UART_PRTY_BIT 0
+#elif CONFIG_SERIAL_PRTY_TYPE==2
+#define UART_PRTY_BIT    (UART_CNTL_MASK_PRTY_EN|UART_CNTL_MASK_PRTY_EVEN)
+#elif CONFIG_SERIAL_PRTY_TYPE==3
+#define UART_PRTY_BIT    (UART_CNTL_MASK_PRTY_EN|UART_CNTL_MASK_PRTY_ODD)
+#else
+#error CONFIG_SERIAL_PRTY_TYPE wrong
+#endif
+
+#ifndef CONFIG_SERIAL_CHAR_LEN
+#define CONFIG_SERIAL_CHAR_LEN 8 //5,6,7,8
+#endif
+#if CONFIG_SERIAL_CHAR_LEN==5
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_5BIT
+#elif CONFIG_SERIAL_CHAR_LEN==6
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_6BIT
+#elif CONFIG_SERIAL_CHAR_LEN==7
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_7BIT
+#elif CONFIG_SERIAL_CHAR_LEN==8
+#define UART_CHAR_LEN   UART_CNTL_MASK_CHAR_8BIT
+#else
+#error CONFIG_SERIAL_CHAR_LEN wrong
+#endif
+#define UART_CONTROL_SET(baud,clk81)                        \
+                        (((clk81)/(baud*4) -1)              \
+                        | UART_STP_BIT                      \
+                        | UART_PRTY_BIT                     \
+                        | UART_CHAR_LEN                     \
+                        | UART_CNTL_MASK_TX_EN              \
+                        | UART_CNTL_MASK_RX_EN              \
+                        | UART_CNTL_MASK_RST_TX             \
+                        | UART_CNTL_MASK_RST_RX             \
+                        | UART_CNTL_MASK_CLR_ERR    )
+#endif
diff --git a/arch/arm/include/asm/arch-txl/usb-new.h b/arch/arm/include/asm/arch-txl/usb-new.h
new file mode 100644
index 0000000..86f7f74
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/usb-new.h
@@ -0,0 +1,342 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/usb-new.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ARCH_ARM_MESON_USB_H_U_BOOT__
+#define __ARCH_ARM_MESON_USB_H_U_BOOT__
+
+#include <common.h>
+#include <asm/types.h>
+#include <asm/arch/io.h>
+
+#define USB_PHY_PORT_MAX	1
+/* Phy register MACRO definitions */
+
+#define LINKSYSTEM_FLADJ_MASK			(0x3f << 1)
+#define LINKSYSTEM_FLADJ(_x)			((_x) << 1)
+#define LINKSYSTEM_XHCI_VERSION_CONTROL		(0x1 << 27)
+
+#define PHYUTMI_OTGDISABLE			(1 << 6)
+#define PHYUTMI_FORCESUSPEND			(1 << 1)
+#define PHYUTMI_FORCESLEEP			(1 << 0)
+
+#define PHYCLKRST_SSC_REFCLKSEL_MASK		(0xff << 23)
+#define PHYCLKRST_SSC_REFCLKSEL(_x)		((_x) << 23)
+
+#define PHYCLKRST_SSC_RANGE_MASK		(0x03 << 21)
+#define PHYCLKRST_SSC_RANGE(_x)			((_x) << 21)
+
+#define PHYCLKRST_SSC_EN			(0x1 << 20)
+#define PHYCLKRST_REF_SSP_EN			(0x1 << 19)
+#define PHYCLKRST_REF_CLKDIV2			(0x1 << 18)
+
+#define PHYCLKRST_MPLL_MULTIPLIER_MASK		(0x7f << 11)
+#define PHYCLKRST_MPLL_MULTIPLIER_100MHZ_REF	(0x19 << 11)
+#define PHYCLKRST_MPLL_MULTIPLIER_50M_REF	(0x02 << 11)
+#define PHYCLKRST_MPLL_MULTIPLIER_24MHZ_REF	(0x68 << 11)
+#define PHYCLKRST_MPLL_MULTIPLIER_20MHZ_REF	(0x7d << 11)
+#define PHYCLKRST_MPLL_MULTIPLIER_19200KHZ_REF	(0x02 << 11)
+
+#define PHYCLKRST_FSEL_MASK			(0x3f << 5)
+#define PHYCLKRST_FSEL(_x)			((_x) << 5)
+#define PHYCLKRST_FSEL_PAD_100MHZ		(0x27 << 5)
+#define PHYCLKRST_FSEL_PAD_24MHZ		(0x2a << 5)
+#define PHYCLKRST_FSEL_PAD_20MHZ		(0x31 << 5)
+#define PHYCLKRST_FSEL_PAD_19_2MHZ		(0x38 << 5)
+
+#define PHYCLKRST_RETENABLEN			(0x1 << 4)
+
+#define PHYCLKRST_REFCLKSEL_MASK		(0x03 << 2)
+#define PHYCLKRST_REFCLKSEL_PAD_REFCLK		(0x2 << 2)
+#define PHYCLKRST_REFCLKSEL_EXT_REFCLK		(0x3 << 2)
+
+#define PHYCLKRST_PORTRESET			(0x1 << 1)
+#define PHYCLKRST_COMMONONN			(0x1 << 0)
+
+#define PHYPARAM0_REF_USE_PAD			(0x1 << 31)
+#define PHYPARAM0_REF_LOSLEVEL_MASK		(0x1f << 26)
+#define PHYPARAM0_REF_LOSLEVEL			(0x9 << 26)
+
+#define PHYPARAM1_PCS_TXDEEMPH_MASK		(0x1f << 0)
+#define PHYPARAM1_PCS_TXDEEMPH			(0x1c)
+
+#define PHYTEST_POWERDOWN_SSP			(0x1 << 3)
+#define PHYTEST_POWERDOWN_HSP			(0x1 << 2)
+
+#define PHYBATCHG_UTMI_CLKSEL			(0x1 << 2)
+
+#define FSEL_CLKSEL_24M				(0x5)
+
+/* XHCI PHY register structure */
+#define PHY_REGISTER_SIZE	0x20
+/* Register definitions */
+struct u2p_aml_regs {
+	volatile uint32_t u2p_r0;
+	volatile uint32_t u2p_r1;
+	volatile uint32_t u2p_r2;
+};
+
+//struct u2p_aml_regs amlogic_usb2_phy;
+
+union u2p_r0_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned bypass_sel:1;
+		unsigned bypass_dm_en:1;
+		unsigned bypass_dp_en:1;
+		unsigned txbitstuffenh:1;
+		unsigned txbitstuffen:1;
+		unsigned dmpulldown:1;
+		unsigned dppulldown:1;
+		unsigned vbusvldextsel:1;
+		unsigned vbusvldext:1;
+		unsigned adp_prb_en:1;
+		unsigned adp_dischrg:1;
+		unsigned adp_chrg:1;
+		unsigned drvvbus:1;
+		unsigned idpullup:1;
+		unsigned loopbackenb:1;
+		unsigned otgdisable:1;
+		unsigned commononn:1;
+		unsigned fsel:3;
+		unsigned refclksel:2;
+		unsigned por:1;
+		unsigned vatestenb:2;
+		unsigned set_iddq:1;
+		unsigned ate_reset:1;
+		unsigned fsv_minus:1;
+		unsigned fsv_plus:1;
+		unsigned bypass_dm_data:1;
+		unsigned bypass_dp_data:1;
+		unsigned not_used:1;
+	} b;
+};
+
+union u2p_r1_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned burn_in_test:1;
+		unsigned aca_enable:1;
+		unsigned dcd_enable:1;
+		unsigned vdatsrcenb:1;
+		unsigned vdatdetenb:1;
+		unsigned chrgsel:1;
+		unsigned tx_preemp_pulse_tune:1;
+		unsigned tx_preemp_amp_tune:2;
+		unsigned tx_res_tune:2;
+		unsigned tx_rise_tune:2;
+		unsigned tx_vref_tune:4;
+		unsigned tx_fsls_tune:4;
+		unsigned tx_hsxv_tune:2;
+		unsigned otg_tune:3;
+		unsigned sqrx_tune:3;
+		unsigned comp_dis_tune:3;
+	} b;
+};
+
+union u2p_r2_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned data_in:4;
+		unsigned data_in_en:4;
+		unsigned addr:4;
+		unsigned data_out_sel:1;
+		unsigned clk:1;
+		unsigned data_out:4;
+		unsigned aca_pin_range_c:1;
+		unsigned aca_pin_range_b:1;
+		unsigned aca_pin_range_a:1;
+		unsigned aca_pin_gnd:1;
+		unsigned aca_pin_float:1;
+		unsigned chg_det:1;
+		unsigned device_sess_vld:1;
+		unsigned adp_probe:1;
+		unsigned adp_sense:1;
+		unsigned sessend:1;
+		unsigned vbusvalid:1;
+		unsigned bvalid:1;
+		unsigned avalid:1;
+		unsigned iddig:1;
+	} b;
+};
+
+struct usb_aml_regs {
+	volatile uint32_t usb_r0;
+	volatile uint32_t usb_r1;
+	volatile uint32_t usb_r2;
+	volatile uint32_t usb_r3;
+	volatile uint32_t usb_r4;
+	volatile uint32_t usb_r5;
+	volatile uint32_t usb_r6;
+};
+
+//struct usb_aml_regs amlogic_usb3_phy;
+
+union usb_r0_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned p30_fsel:6;
+		unsigned p30_phy_reset:1;
+		unsigned p30_test_powerdown_hsp:1;
+		unsigned p30_test_powerdown_ssp:1;
+		unsigned p30_acjt_level:5;
+		unsigned p30_tx_vboost_lvl:3;
+		unsigned p30_lane0_tx2rx_loopbk:1;
+		unsigned p30_lane0_ext_pclk_req:1;
+		unsigned p30_pcs_rx_los_mask_val:10;
+		unsigned u2d_ss_scaledown_mode:2;
+		unsigned u2d_act:1;
+	} b;
+};
+
+union usb_r1_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned u3h_bigendian_gs:1;
+		unsigned u3h_pme_en:1;
+		unsigned u3h_hub_port_overcurrent:5;
+		unsigned u3h_hub_port_perm_attach:5;
+		unsigned u3h_host_u2_port_disable:4;
+		unsigned u3h_host_u3_port_disable:1;
+		unsigned u3h_host_port_power_control_present:1;
+		unsigned u3h_host_msi_enable:1;
+		unsigned u3h_fladj_30mhz_reg:6;
+		unsigned p30_pcs_tx_swing_full:7;
+	} b;
+};
+
+union usb_r2_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned p30_cr_data_in:16;
+		unsigned p30_cr_read:1;
+		unsigned p30_cr_write:1;
+		unsigned p30_cr_cap_addr:1;
+		unsigned p30_cr_cap_data:1;
+		unsigned p30_pcs_tx_deemph_3p5db:6;
+		unsigned p30_pcs_tx_deemph_6db:6;
+	} b;
+};
+
+union usb_r3_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned p30_ssc_en:1;
+		unsigned p30_ssc_range:3;
+		unsigned p30_ssc_ref_clk_sel:9;
+		unsigned p30_ref_ssp_en:1;
+		unsigned reserved14:2;
+		unsigned p30_los_bias:3;
+		unsigned p30_los_level:5;
+		unsigned p30_mpll_multiplier:7;
+		unsigned reserved31:1;
+	} b;
+};
+
+union usb_r4_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned p21_PORTRESET0:1;
+		unsigned p21_SLEEPM0:1;
+		unsigned mem_pd:2;
+		unsigned p21_only:1;
+		unsigned reserved4:27;
+	} b;
+};
+
+union usb_r5_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned iddig_sync:1;
+		unsigned iddig_reg:1;
+		unsigned iddig_cfg:2;
+		unsigned iddig_en0:1;
+		unsigned iddig_en1:1;
+		unsigned iddig_curr:1;
+		unsigned iddig_irq:1;
+		unsigned iddig_th:8;
+		unsigned iddig_cnt:8;
+		unsigned reserved5:8;
+	} b;
+};
+
+union usb_r6_t {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned p30_cr_data_out:16;
+		unsigned p30_cr_ack:1;
+		unsigned not_used:15;
+	} b;
+};
+
+/* usb id mode, only after M2
+	 mode = 0 : HARDWARE
+	 mode = 1 : SW_HOST
+	 mode = 2 : SW_DEVICE
+ */
+#define USB_ID_MODE_HARDWARE    (1)
+#define USB_ID_MODE_SW_HOST     (2)
+#define USB_ID_MODE_SW_DEVICE   (3)
+
+struct amlogic_usb_config {
+	/* controller */
+	unsigned int base_addr;
+	/* role */
+	int id_mode;
+	/* vbus call back */
+	void (* set_vbus_power)(char is_power_on);
+	unsigned int usb_phy2_base_addr;
+	unsigned int usb_phy3_base_addr;
+	unsigned int u2_port_num;
+	unsigned int u3_port_num;
+};
+
+//struct amlogic_usb_config amlogic_usb_config_gxl;
+
+#define BOARD_USB_MODE_HOST	0
+#define BOARD_USB_MODE_SLAVE	1
+#define BOARD_USB_MODE_CHARGER	2
+#define BOARD_USB_MODE_MAX	3
+struct amlogic_usb_config * board_usb_start(int mode,int index);
+int board_usb_stop(int mode,int index);
+void board_usb_init(struct amlogic_usb_config * usb_cfg,int mode);
+int get_usb_count(void);
+#endif
+
diff --git a/arch/arm/include/asm/arch-txl/usb.h b/arch/arm/include/asm/arch-txl/usb.h
new file mode 100644
index 0000000..4fd8555
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/usb.h
@@ -0,0 +1,282 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/usb.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __ARCH_ARM_MESON_USB_H_U_BOOT__
+#define __ARCH_ARM_MESON_USB_H_U_BOOT__
+
+#include <common.h>
+#include <asm/types.h>
+#include <asm/arch/io.h>
+/*
+#define USB_PHY_PORT_A	    (0x40000)
+#define USB_PHY_PORT_B	    (0xc0000)
+#define USB_PHY_PORT_C	    (0x100000)
+#define USB_PHY_PORT_D	    (0x140000)
+#define USB_PHY_PORT_MSK	(0x1f0000) */
+
+#define USB_PHY_PORT_A		0x000000
+#define USB_PHY_PORT_B		0x100000
+#define USB_PHY_PORT_C		0x200000
+#define USB_PHY_PORT_D		0x300000
+#define USB_PHY_PORT_MSK	0x300000
+#define USB_PHY_PORT_MAX	2
+
+#define PREI_USB_PHY_REG_A     0xc0000000
+#define PREI_USB_PHY_REG_B     0xc0000020
+//#define PREI_USB_PHY_REG_C     0x2210
+//#define PREI_USB_PHY_REG_D     0x2218
+typedef struct usb_peri_reg {
+	volatile uint32_t config;
+	volatile uint32_t ctrl;
+	volatile uint32_t endp_intr;
+	volatile uint32_t adp_bc;
+	volatile uint32_t dbg_uart;
+	volatile uint32_t test;
+	volatile uint32_t tune;
+	volatile uint32_t reserved;
+} usb_peri_reg_t;
+
+typedef union usb_config_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned clk_en:1;
+        unsigned clk_sel:3;
+        unsigned clk_div:7;
+        unsigned reserved0:4;
+        unsigned clk_32k_alt_sel:1;
+        unsigned reserved1:15;
+        unsigned test_trig:1;
+    } b;
+} usb_config_data_t;
+
+typedef union usb_ctrl_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned soft_prst:1;
+        unsigned soft_hreset:1;
+        unsigned ss_scaledown_mode:2;
+        unsigned clk_det_rst:1;
+        unsigned intr_sel:1;
+        unsigned reserved:2;
+        unsigned clk_detected:1;
+        unsigned sof_sent_rcvd_tgl:1;
+        unsigned sof_toggle_out:1;
+        unsigned not_used:4;
+        unsigned por:1;
+        unsigned sleepm:1;
+        unsigned txbitstuffennh:1;
+        unsigned txbitstuffenn:1;
+        unsigned commononn:1;
+        unsigned refclksel:2;
+        unsigned fsel:3;
+        unsigned portreset:1;
+        unsigned thread_id:6;
+    } b;
+} usb_ctrl_data_t;
+
+typedef union usb_endp_intr_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned int0:1;
+        unsigned int1:1;
+        unsigned int2:1;
+        unsigned int3:1;
+        unsigned int4:1;
+        unsigned int5:1;
+        unsigned int6:1;
+        unsigned int7:1;
+        unsigned int8:1;
+        unsigned int9:1;
+        unsigned int10:1;
+        unsigned int11:1;
+        unsigned int12:1;
+        unsigned int13:1;
+        unsigned int14:1;
+        unsigned int15:1;
+        unsigned int16:1;
+        unsigned int17:1;
+        unsigned int18:1;
+        unsigned int19:1;
+        unsigned int20:1;
+        unsigned int21:1;
+        unsigned int22:1;
+        unsigned int23:1;
+        unsigned int24:1;
+        unsigned int25:1;
+        unsigned int26:1;
+        unsigned int27:1;
+        unsigned int28:1;
+        unsigned int29:1;
+        unsigned int30:1;
+        unsigned int31:1;
+    } b;
+} usb_endp_intr_data_t;
+
+typedef union usb_adp_bc_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+	unsigned vbusvldextsel:1;
+	unsigned vbusvldext:1;
+	unsigned otgdisable:1;
+	unsigned idpullup:1;
+	unsigned drvvbus:1;
+	unsigned adp_prb_en:1;
+	unsigned adp_dischrg:1;
+	unsigned adp_chrg:1;
+	unsigned sessend:1;
+	unsigned device_sess_vld:1;
+	unsigned bvalid:1;
+	unsigned avalid:1;
+	unsigned iddig:1;
+	unsigned vbusvalid:1;
+	unsigned adp_probe:1;
+	unsigned adp_sense:1;
+	unsigned aca_enable:1;
+	unsigned dcd_enable:1;
+	unsigned vdatdetenb:1;
+	unsigned vdatsrcenb:1;
+	unsigned chrgsel:1;
+	unsigned chg_det:1;
+	unsigned aca_pin_range_c:1;
+	unsigned aca_pin_range_b:1;
+	unsigned aca_pin_range_a:1;
+	unsigned aca_pin_gnd:1;
+	unsigned aca_pin_float:1;
+	unsigned not_used:5;
+    } b;
+} usb_adp_bc_data_t;
+
+typedef union usb_dbg_uart_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+	unsigned bypass_sel:1;
+	unsigned bypass_dm_en:1;
+	unsigned bypass_dp_en:1;
+	unsigned bypass_dm_data:1;
+	unsigned bypass_dp_data:1;
+	unsigned fsv_minus:1;
+	unsigned fsv_plus:1;
+	unsigned burn_in_test:1;
+	unsigned loopbackenb:1;
+	unsigned set_iddq:1;
+	unsigned ate_reset:1;
+	unsigned reserved:4;
+	unsigned not_used:17;
+    } b;
+} usb_dbg_uart_data_t;
+
+typedef union phy_test_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+	unsigned data_in:4;
+	unsigned data_in_en:4;
+	unsigned addr:4;
+	unsigned data_out_sel:1;
+	unsigned clk:1;
+	unsigned vatestenb:2;
+	unsigned data_out:4;
+	unsigned not_used:12;
+    } b;
+} phy_test_data_t;
+
+typedef union phy_tune_data {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+	unsigned tx_res_tune:2;
+	unsigned tx_hsxv_tune:2;
+	unsigned tx_vref_tune:4;
+	unsigned tx_rise_tune:2;
+	unsigned tx_preemp_pulse_tune:1;
+	unsigned tx_preemp_amp_tune:2;
+	unsigned tx_fsls_tune:4;
+	unsigned sqrx_tune:3;
+	unsigned otg_tune:3;
+	unsigned comp_dis_tune:3;
+	unsigned not_used:6;
+    } b;
+} phy_tune_data_t;
+
+
+/*
+ * Clock source index must sync with chip's spec
+ * M1/M2/M3/M6/M8 are different!
+ * This is only for M8
+ */
+#define USB_PHY_CLK_SEL_XTAL	0
+
+#define USB_PHY_A_INTR_BIT	(1 << 30)
+#define USB_PHY_B_INTR_BIT	(1 << 31)
+
+/* usb id mode, only after M2
+	 mode = 0 : HARDWARE
+	 mode = 1 : SW_HOST
+	 mode = 2 : SW_DEVICE
+ */
+#define USB_ID_MODE_HARDWARE    (1)
+#define USB_ID_MODE_SW_HOST     (2)
+#define USB_ID_MODE_SW_DEVICE   (3)
+
+typedef struct amlogic_usb_config{
+	/* clock info */
+	int clk_selecter; // usb USB_PHY_CLOCK_SEL_xxx
+	int pll_divider;  // when other/ddr/demod pll used, fill this
+
+	/* controller */
+	unsigned int base_addr;
+
+	/* role */
+	int id_mode; // only used after M2
+
+	/* vbus call back */
+	void (* set_vbus_power)(char is_power_on);
+
+	/* battery charging detect call back */
+	int(* battery_charging_det_cb)(char bc_mode);
+#define BC_MODE_UNKNOWN	0
+#define BC_MODE_SDP		1	/* Standard Downstream Port */
+#define BC_MODE_DCP		2	/* Dedicated Charging Port */
+#define BC_MODE_CDP		3	/* Charging Downstream Port */
+
+}amlogic_usb_config_t;
+
+#define BOARD_USB_MODE_HOST	0
+#define BOARD_USB_MODE_SLAVE	1
+#define BOARD_USB_MODE_CHARGER	2
+#define BOARD_USB_MODE_MAX	3
+amlogic_usb_config_t * board_usb_start(int mode,int index);
+int board_usb_stop(int mode,int index);
+void board_usb_init(amlogic_usb_config_t * usb_cfg,int mode);
+int get_usb_count(void);
+#endif //__ARCH_ARM_MESON_USB_H_U_BOOT__
diff --git a/arch/arm/include/asm/arch-txl/watchdog.h b/arch/arm/include/asm/arch-txl/watchdog.h
new file mode 100644
index 0000000..c4823cb
--- /dev/null
+++ b/arch/arm/include/asm/arch-txl/watchdog.h
@@ -0,0 +1,35 @@
+
+/*
+ * arch/arm/include/asm/arch-txl/watchdog.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _BOOT_ROM_WATCHDOG_H
+#define _BOOT_ROM_WATCHDOG_H
+
+//#include "common.h"
+
+void watchdog_init(uint32_t msec);
+void watchdog_reset(void);
+void reset_system(void);
+void watchdog_disable(void);
+
+/* uboot reset interface */
+void reset_cpu(unsigned long flag);
+
+#endif /* _BOOT_ROM_WATCHDOG_H */
diff --git a/arch/arm/include/asm/cpu_id.h b/arch/arm/include/asm/cpu_id.h
index 74cac18..bfc5dad 100644
--- a/arch/arm/include/asm/cpu_id.h
+++ b/arch/arm/include/asm/cpu_id.h
@@ -31,6 +31,7 @@
 #define MESON_CPU_MAJOR_ID_GXTVBB	0x20
 #define MESON_CPU_MAJOR_ID_GXL		0x21
 #define MESON_CPU_MAJOR_ID_GXM		0x22
+#define MESON_CPU_MAJOR_ID_TXL		0x23
 
 #define MESON_CPU_PACKAGE_ID_905D	0X00
 #define MESON_CPU_PACKAGE_ID_905M	0x20
diff --git a/board/amlogic/Kconfig b/board/amlogic/Kconfig
index 385f9e0..72d2a75 100644
--- a/board/amlogic/Kconfig
+++ b/board/amlogic/Kconfig
@@ -67,6 +67,18 @@ config GXM_Q200_V1
 	bool "Support amlogic gxm/gxl q200 board"
 	default n
 
+config TXL_SKT_V1
+	bool "Support amlogic txl socket v1 board"
+	default n
+
+config TXL_P320_V1
+	bool "Support amlogic txl p320 board"
+	default n
+
+config TXL_P321_V1
+	bool "Support amlogic txl p321 board"
+	default n
+
 config PXP_EMULATOR
 	bool "Support pxp environment"
 	default n
@@ -146,6 +158,18 @@ if GXM_Q200_V1
 source "board/amlogic/gxm_q200_v1/Kconfig"
 endif
 
+if TXL_SKT_V1
+source "board/amlogic/txl_skt_v1/Kconfig"
+endif
+
+if TXL_P320_V1
+source "board/amlogic/txl_p320_v1/Kconfig"
+endif
+
+if TXL_P321_V1
+source "board/amlogic/txl_p321_v1/Kconfig"
+endif
+
 if ODROID_C2
 source "board/hardkernel/odroidc2/Kconfig"
 endif
diff --git a/board/amlogic/configs/gxb_p200_v1.h b/board/amlogic/configs/gxb_p200_v1.h
index 4c5f51d..44d70b1 100644
--- a/board/amlogic/configs/gxb_p200_v1.h
+++ b/board/amlogic/configs/gxb_p200_v1.h
@@ -74,7 +74,7 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-        "firstboot=1\0"\
+        "firstboot=0\0"\
         "upgrade_step=0\0"\
         "jtag=apao\0"\
         "loadaddr=1080000\0"\
diff --git a/board/amlogic/configs/gxb_p201_v1.h b/board/amlogic/configs/gxb_p201_v1.h
index 7b0c7ac..8c7a56c 100644
--- a/board/amlogic/configs/gxb_p201_v1.h
+++ b/board/amlogic/configs/gxb_p201_v1.h
@@ -71,7 +71,7 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-        "firstboot=1\0"\
+        "firstboot=0\0"\
         "upgrade_step=0\0"\
         "jtag=apee\0"\
         "loadaddr=1080000\0"\
diff --git a/board/amlogic/configs/gxb_skt_v1.h b/board/amlogic/configs/gxb_skt_v1.h
index 04a4e2c..9651243 100644
--- a/board/amlogic/configs/gxb_skt_v1.h
+++ b/board/amlogic/configs/gxb_skt_v1.h
@@ -29,6 +29,9 @@
 #warning "include warning"
 #endif
 
+#define CONFIG_VCCK_INIT_VOLTAGE	1100
+#define CONFIG_VDDEE_INIT_VOLTAGE	1000		// voltage for power up
+#define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
 /* configs for CEC */
 #define CONFIG_CEC_OSD_NAME		"Mbox"
 #define CONFIG_CEC_WAKEUP
diff --git a/board/amlogic/configs/gxl_p212_v1.h b/board/amlogic/configs/gxl_p212_v1.h
index 38abf11..004f2f9 100644
--- a/board/amlogic/configs/gxl_p212_v1.h
+++ b/board/amlogic/configs/gxl_p212_v1.h
@@ -42,12 +42,7 @@
 #define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
 
 /* configs for CEC */
-#ifdef UBOOT_Megafon
-#define CONFIG_CEC_OSD_NAME		"Wifire TV"
-#else
 #define CONFIG_CEC_OSD_NAME		"Mbox"
-
-#endif
 #define CONFIG_CEC_WAKEUP
 
 #define CONFIG_INSTABOOT
@@ -62,31 +57,25 @@
 #define CONFIG_SERIAL_MULTI		1
 
 //Enable ir remote wake up for bl30
-#define CONFIG_IR_REMOTE
+//#define CONFIG_IR_REMOTE
 //#define CONFIG_AML_IRDETECT_EARLY
-#define CONFIG_IR_REMOTE_POWER_UP_KEY_CNT 9
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_CNT 4
 #define CONFIG_IR_REMOTE_USE_PROTOCOL 0         // 0:nec  1:duokan  2:Toshiba 3:rca 4:rcmm
 #define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL1 0XE51AFB04 //amlogic tv ir --- power
 #define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL2 0XBB44FB04 //amlogic tv ir --- ch+
 #define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL3 0xF20DFE01 //amlogic tv ir --- ch-
 #define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL4 0xBA45BD02
-#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL5 0x3ac5bd02
-#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL6 0xbf40ff00 //zte ir power
-#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL7 0xf50a7748 //7748 ir power
-#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL8 0xff00fe02 //bt-remote's ir power butter
-#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL9 0x23dc1608 //bt-remote's ir power butter2
-
 
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL5 0x3ac5bd02
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-        "firstboot=1\0"\
+        "firstboot=0\0"\
         "upgrade_step=0\0"\
-        "jtag=apee\0"\
-        "cecconfig=cec0xff\0"\
+        "jtag=apao\0"\
         "loadaddr=1080000\0"\
-        "outputmode=1080p50hz\0" \
-        "hdmimode=1080p50hz\0" \
+        "outputmode=1080p60hz\0" \
+        "hdmimode=1080p60hz\0" \
         "cvbsmode=576cvbs\0" \
         "display_width=1920\0" \
         "display_height=1080\0" \
@@ -162,11 +151,8 @@
             "fi; \0" \
          "update="\
             /*first usb burning, second sdc_burn, third ext-sd autoscr/recovery, last udisk autoscr/recovery*/\
-            "setenv EnableSelinux disabled; "\
-            "run storeargs; "\
             "run usb_burning; "\
             "run sdc_burning; "\
-			"setenv upgrade_step 3; save;"\
             "if mmcinfo; then "\
                 "run recovery_from_sdcard;"\
             "fi;"\
@@ -212,21 +198,11 @@
             "fi;"\
             "\0"\
         "upgrade_key="\
-            "if gpio input GPIOH_6; then "\
+            "if gpio input GPIOAO_2; then "\
                 "echo detect upgrade key; sleep 3;"\
-                "if gpio input GPIOH_6; then run update; fi;"\
+                "if gpio input GPIOAO_2; then run update; fi;"\
             "fi;"\
             "\0"\
-	    "irremote_update="\
-		    "echo in irremote_update;"\
-		    "if irkey 0xf8077748 0x7d824cb3 1000000; then "\
-			    "echo read irkey ok!; " \
-		    "if itest ${irkey_value} == 0xf8077748; then " \
-			    "run update;" \
-		    "else if itest ${irkey_value} == 0x7d824cb3; then " \
-			    "run update;" \
-			    "fi;fi;" \
-		    "fi;\0" \
 
 #define CONFIG_PREBOOT  \
             "run factory_reset_poweroff_protect;"\
@@ -234,7 +210,6 @@
             "run init_display;"\
             "run storeargs;"\
             "run upgrade_key;" \
-			"run irremote_update;"\
             "run switch_bootmode;"
 #define CONFIG_BOOTCOMMAND "run storeboot"
 
@@ -252,7 +227,7 @@
 /* ddr */
 #define CONFIG_DDR_SIZE					0 //MB //0 means ddr size auto-detect
 #define CONFIG_DDR_CLK					912  //MHz, Range: 384-1200, should be multiple of 24
-#define CONFIG_DDR4_CLK					1100  //MHz, for boards which use different ddr chip
+#define CONFIG_DDR4_CLK					1008  //MHz, for boards which use different ddr chip
 /* DDR type setting
  *    CONFIG_DDR_TYPE_LPDDR3   : LPDDR3
  *    CONFIG_DDR_TYPE_DDR3     : DDR3
diff --git a/board/amlogic/configs/gxl_skt_v1.h b/board/amlogic/configs/gxl_skt_v1.h
index 8e8ff74..e78ce1d 100644
--- a/board/amlogic/configs/gxl_skt_v1.h
+++ b/board/amlogic/configs/gxl_skt_v1.h
@@ -65,7 +65,7 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-        "firstboot=1\0"\
+        "firstboot=0\0"\
         "upgrade_step=0\0"\
         "jtag=apao\0"\
         "loadaddr=1080000\0"\
@@ -231,7 +231,7 @@
 /* ddr */
 #define CONFIG_DDR_SIZE					0 //MB //0 means ddr size auto-detect
 #define CONFIG_DDR_CLK					792  //MHz, Range: 384-1200, should be multiple of 24
-#define CONFIG_DDR4_CLK					1100  //MHz, for boards which use different ddr chip
+#define CONFIG_DDR4_CLK					1008  //MHz, for boards which use different ddr chip
 /* DDR type setting
  *    CONFIG_DDR_TYPE_LPDDR3   : LPDDR3
  *    CONFIG_DDR_TYPE_DDR3     : DDR3
diff --git a/board/amlogic/configs/gxm_q200_v1.h b/board/amlogic/configs/gxm_q200_v1.h
index 72127fe..ef40315 100644
--- a/board/amlogic/configs/gxm_q200_v1.h
+++ b/board/amlogic/configs/gxm_q200_v1.h
@@ -73,9 +73,9 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-        "firstboot=1\0"\
+        "firstboot=0\0"\
         "upgrade_step=0\0"\
-        "jtag=apee\0"\
+        "jtag=apao\0"\
         "loadaddr=1080000\0"\
         "outputmode=1080p60hz\0" \
         "hdmimode=1080p60hz\0" \
@@ -231,7 +231,8 @@
 /* ddr */
 #define CONFIG_DDR_SIZE					0 //MB //0 means ddr size auto-detect
 #define CONFIG_DDR_CLK					912  //MHz, Range: 384-1200, should be multiple of 24
-#define CONFIG_DDR4_CLK					1100  //MHz, for boards which use different ddr chip
+#define CONFIG_DDR4_CLK					1008  //MHz, for boards which use different ddr chip
+#define CONFIG_NR_DRAM_BANKS			1
 /* DDR type setting
  *    CONFIG_DDR_TYPE_LPDDR3   : LPDDR3
  *    CONFIG_DDR_TYPE_DDR3     : DDR3
@@ -242,17 +243,18 @@
  *    CONFIG_DDR0_RANK0        : DDR0 rank0
  *    CONFIG_DDR0_RANK01       : DDR0 rank0+1
  *    CONFIG_DDR0_16BIT        : DDR0 16bit mode
+ *    CONFIG_DDR0_16BIT_2      : DDR0 16bit mode, 2ranks
  *    CONFIG_DDR_CHL_AUTO      : auto detect RANK0 / RANK0+1 */
 #define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR0_RANK01
-#define CONFIG_DDR_FULL_TEST			0 //1 for ddr full test
-#define CONFIG_NR_DRAM_BANKS			1
 /* ddr functions */
+#define CONFIG_DDR_FULL_TEST			0 //0:disable, 1:enable. ddr full test
 #define CONFIG_CMD_DDR_D2PLL			0 //0:disable, 1:enable. d2pll cmd
 #define CONFIG_CMD_DDR_TEST				0 //0:disable, 1:enable. ddrtest cmd
 #define CONFIG_DDR_LOW_POWER			0 //0:disable, 1:enable. ddr clk gate for lp
 #define CONFIG_DDR_ZQ_PD				0 //0:disable, 1:enable. ddr zq power down
 #define CONFIG_DDR_USE_EXT_VREF			0 //0:disable, 1:enable. ddr use external vref
 #define CONFIG_DDR4_TIMING_TEST			0 //0:disable, 1:enable. ddr4 timing test function
+#define CONFIG_DDR_PLL_BYPASS			0 //0:disable, 1:enable. ddr pll bypass function
 
 /* storage: emmc/nand/sd */
 #define	CONFIG_STORE_COMPATIBLE 1
diff --git a/board/amlogic/configs/gxm_q201_v1.h b/board/amlogic/configs/gxm_q201_v1.h
index 5cab871..7fd117f 100644
--- a/board/amlogic/configs/gxm_q201_v1.h
+++ b/board/amlogic/configs/gxm_q201_v1.h
@@ -73,9 +73,9 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-        "firstboot=1\0"\
+        "firstboot=0\0"\
         "upgrade_step=0\0"\
-        "jtag=apee\0"\
+        "jtag=apao\0"\
         "loadaddr=1080000\0"\
         "outputmode=1080p60hz\0" \
         "hdmimode=1080p60hz\0" \
@@ -231,7 +231,8 @@
 /* ddr */
 #define CONFIG_DDR_SIZE					0 //MB //0 means ddr size auto-detect
 #define CONFIG_DDR_CLK					912  //MHz, Range: 384-1200, should be multiple of 24
-#define CONFIG_DDR4_CLK					1100  //MHz, for boards which use different ddr chip
+#define CONFIG_DDR4_CLK					1008  //MHz, for boards which use different ddr chip
+#define CONFIG_NR_DRAM_BANKS			1
 /* DDR type setting
  *    CONFIG_DDR_TYPE_LPDDR3   : LPDDR3
  *    CONFIG_DDR_TYPE_DDR3     : DDR3
@@ -242,17 +243,18 @@
  *    CONFIG_DDR0_RANK0        : DDR0 rank0
  *    CONFIG_DDR0_RANK01       : DDR0 rank0+1
  *    CONFIG_DDR0_16BIT        : DDR0 16bit mode
+ *    CONFIG_DDR0_16BIT_2      : DDR0 16bit mode, 2ranks
  *    CONFIG_DDR_CHL_AUTO      : auto detect RANK0 / RANK0+1 */
-#define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR0_RANK0
-#define CONFIG_DDR_FULL_TEST			0 //1 for ddr full test
-#define CONFIG_NR_DRAM_BANKS			1
+#define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR_CHL_AUTO
 /* ddr functions */
+#define CONFIG_DDR_FULL_TEST			0 //0:disable, 1:enable. ddr full test
 #define CONFIG_CMD_DDR_D2PLL			0 //0:disable, 1:enable. d2pll cmd
 #define CONFIG_CMD_DDR_TEST				0 //0:disable, 1:enable. ddrtest cmd
 #define CONFIG_DDR_LOW_POWER			0 //0:disable, 1:enable. ddr clk gate for lp
 #define CONFIG_DDR_ZQ_PD				0 //0:disable, 1:enable. ddr zq power down
 #define CONFIG_DDR_USE_EXT_VREF			0 //0:disable, 1:enable. ddr use external vref
 #define CONFIG_DDR4_TIMING_TEST			0 //0:disable, 1:enable. ddr4 timing test function
+#define CONFIG_DDR_PLL_BYPASS			0 //0:disable, 1:enable. ddr pll bypass function
 
 /* storage: emmc/nand/sd */
 #define	CONFIG_STORE_COMPATIBLE 1
diff --git a/board/amlogic/configs/gxm_skt_v1.h b/board/amlogic/configs/gxm_skt_v1.h
index bde4a17..9222e0e 100644
--- a/board/amlogic/configs/gxm_skt_v1.h
+++ b/board/amlogic/configs/gxm_skt_v1.h
@@ -71,7 +71,7 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-        "firstboot=1\0"\
+        "firstboot=0\0"\
         "upgrade_step=0\0"\
         "jtag=apee\0"\
         "loadaddr=1080000\0"\
@@ -227,7 +227,7 @@
 /* ddr */
 #define CONFIG_DDR_SIZE					0 //MB //0 means ddr size auto-detect
 #define CONFIG_DDR_CLK					792  //MHz, Range: 384-1200, should be multiple of 24
-#define CONFIG_DDR4_CLK					1100  //MHz, for boards which use different ddr chip
+#define CONFIG_DDR4_CLK					1008  //MHz, for boards which use different ddr chip
 /* DDR type setting
  *    CONFIG_DDR_TYPE_LPDDR3   : LPDDR3
  *    CONFIG_DDR_TYPE_DDR3     : DDR3
diff --git a/board/amlogic/configs/gxtvbb_9023_skt_v1.h b/board/amlogic/configs/gxtvbb_9023_skt_v1.h
index ee2dc62..514adc2 100644
--- a/board/amlogic/configs/gxtvbb_9023_skt_v1.h
+++ b/board/amlogic/configs/gxtvbb_9023_skt_v1.h
@@ -83,7 +83,7 @@
         "fb_width=1920\0" \
         "fb_height=1080\0" \
         "storeargs="\
-            "setenv bootargs rootfstype=ramfs init=/init console=ttyS0,115200 no_console_suspend earlyprintk=aml-uart,0xc81004c0 androidboot.selinux=disabled logo=osd1,loaded,0x3b000000 vout=1080p60hz,enable hdmitx= osd_reverse=${osd_reverse} video_reverse=${video_reverse} androidboot.firstboot=1"\
+            "setenv bootargs rootfstype=ramfs init=/init console=ttyS0,115200 no_console_suspend earlyprintk=aml-uart,0xc81004c0 androidboot.selinux=disabled logo=osd1,loaded,0x3b000000 vout=1080p60hz,enable hdmitx= osd_reverse=${osd_reverse} video_reverse=${video_reverse} androidboot.firstboot=0"\
             "\0"\
 	"storeboot="\
 	"if imgread kernel boot ${loadaddr}; then bootm ${loadaddr}; fi;"\
diff --git a/board/amlogic/configs/gxtvbb_p300_v1.h b/board/amlogic/configs/gxtvbb_p300_v1.h
index 05f3f0c..42d0915 100644
--- a/board/amlogic/configs/gxtvbb_p300_v1.h
+++ b/board/amlogic/configs/gxtvbb_p300_v1.h
@@ -37,6 +37,12 @@
 #define CONFIG_VDDEE_INIT_VOLTAGE	1100		// voltage for power up
 #define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
 
+#define CONFIG_AML_SPICC
+/*#define CONFIG_AML_LOCAL_DIMMING*/
+/*#define CONFIG_AML_LOCAL_DIMMING_IW7019*/
+/*#define CONFIG_AML_LOCAL_DIMMING_OB3350*/
+
+
 /* configs for CEC */
 #define CONFIG_CEC_OSD_NAME		"AML_TV"
 #define CONFIG_CEC_WAKEUP
@@ -68,7 +74,7 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-	"firstboot=1\0"\
+	"firstboot=0\0"\
 	"upgrade_step=0\0"\
 	"loadaddr=1080000\0"\
 	"panel_type=lvds_2\0" \
@@ -416,6 +422,9 @@
 
 /* other functions */
 #define CONFIG_NEED_BL301	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+#define CONFIG_FIP_IMG_SUPPORT	1
 #define CONFIG_BOOTDELAY	1 //delay 1s
 #define CONFIG_SYS_LONGHELP 1
 #define CONFIG_CMD_MISC     1
diff --git a/board/amlogic/configs/gxtvbb_p301_v1.h b/board/amlogic/configs/gxtvbb_p301_v1.h
index f339c07..625cf6e 100644
--- a/board/amlogic/configs/gxtvbb_p301_v1.h
+++ b/board/amlogic/configs/gxtvbb_p301_v1.h
@@ -37,6 +37,10 @@
 #define CONFIG_VDDEE_INIT_VOLTAGE	1100		// voltage for power up
 #define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
 
+/*#define CONFIG_AML_LOCAL_DIMMING*/
+/*#define CONFIG_AML_LOCAL_DIMMING_IW7019*/
+/*#define CONFIG_AML_LOCAL_DIMMING_OB3350*/
+
 /* configs for CEC */
 #define CONFIG_CEC_OSD_NAME		"AML_TV"
 #define CONFIG_CEC_WAKEUP
@@ -77,11 +81,12 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-	"firstboot=1\0"\
+	"firstboot=0\0"\
 	"upgrade_step=0\0"\
 	"loadaddr=1080000\0"\
 	"panel_type=lvds_2\0" \
 	"outputmode=1080p60hz\0" \
+	"hdmiuart_mode=open\0"\
 	"panel_reverse=0\0" \
 	"osd_reverse=n\0" \
 	"video_reverse=n\0" \
@@ -430,6 +435,9 @@
 
 /* other functions */
 #define CONFIG_NEED_BL301	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+#define CONFIG_FIP_IMG_SUPPORT	1
 #define CONFIG_BOOTDELAY	1 //delay 1s
 #define CONFIG_SYS_LONGHELP 1
 #define CONFIG_CMD_MISC     1
diff --git a/board/amlogic/configs/gxtvbb_p310_v1.h b/board/amlogic/configs/gxtvbb_p310_v1.h
index d28db3a..4cb6b23 100644
--- a/board/amlogic/configs/gxtvbb_p310_v1.h
+++ b/board/amlogic/configs/gxtvbb_p310_v1.h
@@ -68,7 +68,7 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-	"firstboot=1\0"\
+	"firstboot=0\0"\
 	"upgrade_step=0\0"\
 	"loadaddr=1080000\0"\
 	"dtb_mem_addr=0x1000000\0" \
@@ -400,7 +400,10 @@
 
 /* other functions */
 #define CONFIG_NEED_BL301	1
-#define CONFIG_BOOTDELAY	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+#define CONFIG_FIP_IMG_SUPPORT	1
+#define CONFIG_BOOTDELAY	1 //delay 1s
 #define CONFIG_SYS_LONGHELP 1
 #define CONFIG_CMD_MISC         1
 #define CONFIG_CMD_ITEST    1
diff --git a/board/amlogic/configs/gxtvbb_p311_v1.h b/board/amlogic/configs/gxtvbb_p311_v1.h
index 30a51b8..2525196 100644
--- a/board/amlogic/configs/gxtvbb_p311_v1.h
+++ b/board/amlogic/configs/gxtvbb_p311_v1.h
@@ -68,7 +68,7 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-	"firstboot=1\0"\
+	"firstboot=0\0"\
 	"upgrade_step=0\0"\
 	"loadaddr=1080000\0"\
 	"dtb_mem_addr=0x1000000\0" \
@@ -401,6 +401,10 @@
 /* other functions */
 #define CONFIG_NEED_BL301	1
 #define CONFIG_BOOTDELAY	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+#define CONFIG_FIP_IMG_SUPPORT	1
+#define CONFIG_BOOTDELAY	1 //delay 1s
 #define CONFIG_SYS_LONGHELP 1
 #define CONFIG_CMD_MISC         1
 #define CONFIG_CMD_ITEST    1
diff --git a/board/amlogic/configs/gxtvbb_skt_v1.h b/board/amlogic/configs/gxtvbb_skt_v1.h
index beef78f..55eb535 100644
--- a/board/amlogic/configs/gxtvbb_skt_v1.h
+++ b/board/amlogic/configs/gxtvbb_skt_v1.h
@@ -275,7 +275,10 @@
 
 /* other functions */
 #define CONFIG_NEED_BL301	1
-#define CONFIG_BOOTDELAY	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+#define CONFIG_FIP_IMG_SUPPORT	1
+#define CONFIG_BOOTDELAY	1 //delay 1s
 #define CONFIG_SYS_LONGHELP 1
 #define CONFIG_CMD_MISC         1
 #define CONFIG_CMD_CPU_TEMP 1
diff --git a/board/amlogic/configs/gxtvbb_t966_skt_v1.h b/board/amlogic/configs/gxtvbb_t966_skt_v1.h
index 8d168e8..ec80e0b 100644
--- a/board/amlogic/configs/gxtvbb_t966_skt_v1.h
+++ b/board/amlogic/configs/gxtvbb_t966_skt_v1.h
@@ -69,7 +69,7 @@
 /* args/envs */
 #define CONFIG_SYS_MAXARGS  64
 #define CONFIG_EXTRA_ENV_SETTINGS \
-	"firstboot=1\0"\
+	"firstboot=0\0"\
 	"upgrade_step=0\0"\
 	"loadaddr=1080000\0"\
 	"dtb_mem_addr=0x1000000\0" \
@@ -396,7 +396,10 @@
 
 /* other functions */
 #define CONFIG_NEED_BL301	1
-#define CONFIG_BOOTDELAY	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+#define CONFIG_FIP_IMG_SUPPORT	1
+#define CONFIG_BOOTDELAY	1 //delay 1s
 #define CONFIG_SYS_LONGHELP 1
 #define CONFIG_CMD_MISC         1
 #define CONFIG_CMD_ITEST    1
diff --git a/board/amlogic/configs/txl_p320_v1.h b/board/amlogic/configs/txl_p320_v1.h
new file mode 100644
index 0000000..be2337b
--- /dev/null
+++ b/board/amlogic/configs/txl_p320_v1.h
@@ -0,0 +1,454 @@
+
+/*
+ * board/amlogic/configs/txl_p320_v1.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __TXL_P320_V1_H__
+#define __TXL_P320_V1_H__
+
+#include <asm/arch/cpu.h>
+
+#define CONFIG_SYS_GENERIC_BOARD  1
+#ifndef CONFIG_AML_MESON
+#warning "include warning"
+#endif
+
+/*
+ * platform power init config
+ */
+#define CONFIG_PLATFORM_POWER_INIT
+#define CONFIG_VCCK_INIT_VOLTAGE	1100
+#define CONFIG_VDDEE_INIT_VOLTAGE	1000		// voltage for power up
+#define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
+
+/* configs for CEC */
+#define CONFIG_CEC_OSD_NAME		"AML_TV"
+#define CONFIG_CEC_WAKEUP
+
+/* SMP Definitinos */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+/* config saradc*/
+#define CONFIG_CMD_SARADC 1
+
+/* Serial config */
+#define CONFIG_CONS_INDEX 2
+#define CONFIG_BAUDRATE  115200
+#define CONFIG_AML_MESON_SERIAL   1
+#define CONFIG_SERIAL_MULTI		1
+
+//Enable ir remote wake up for bl30
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_CNT 3
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL1 0xef10fe01 //amlogic tv ir --- power
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL2 0XBB44FB04 //amlogic tv ir --- ch+
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL3 0xF20DFE01 //amlogic tv ir --- ch-
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL4 0xFFFFFFFF
+
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL5 0x3ac5bd02
+/* args/envs */
+#define CONFIG_SYS_MAXARGS  64
+#define CONFIG_EXTRA_ENV_SETTINGS \
+        "firstboot=1\0"\
+        "upgrade_step=0\0"\
+        "jtag=disable\0"\
+        "loadaddr=1080000\0"\
+        "panel_type=lvds_1\0" \
+        "outputmode=1080p60hz\0" \
+        "hdmimode=1080p60hz\0" \
+        "cvbsmode=576cvbs\0" \
+        "display_width=1920\0" \
+        "display_height=1080\0" \
+        "display_bpp=16\0" \
+        "display_color_index=16\0" \
+        "display_layer=osd1\0" \
+        "display_color_fg=0xffff\0" \
+        "display_color_bg=0\0" \
+        "dtb_mem_addr=0x1000000\0" \
+        "fb_addr=0x3d800000\0" \
+        "fb_width=1920\0" \
+        "fb_height=1080\0" \
+        "usb_burning=update 1000\0" \
+        "fdt_high=0x20000000\0"\
+        "try_auto_burn=update 700 750;\0"\
+        "sdcburncfg=aml_sdc_burn.ini\0"\
+        "sdc_burning=sdc_burn ${sdcburncfg}\0"\
+        "wipe_data=successful\0"\
+        "wipe_cache=successful\0"\
+        "EnableSelinux=enforcing\0" \
+        "recovery_part=recovery\0"\
+        "recovery_offset=0\0"\
+        "cvbs_drv=0\0"\
+        "osd_reverse=0\0"\
+        "video_reverse=0\0"\
+        "initargs="\
+            "rootfstype=ramfs init=/init console=ttyS0,115200 no_console_suspend earlyprintk=aml-uart,0xc81004c0 ramoops.pstore_en=1 ramoops.record_size=0x8000 ramoops.console_size=0x4000 androidboot.selinux=${EnableSelinux} "\
+            "\0"\
+        "upgrade_check="\
+            "echo upgrade_step=${upgrade_step}; "\
+            "if itest ${upgrade_step} == 3; then "\
+                "run init_display; run storeargs; run update;"\
+            "else fi;"\
+            "\0"\
+        "storeargs="\
+            "setenv bootargs ${initargs} logo=${display_layer},loaded,${fb_addr} vout=${outputmode},enable panel_type=${panel_type} osd_reverse=${osd_reverse} video_reverse=${video_reverse} androidboot.firstboot=${firstboot} jtag=${jtag}; "\
+	"setenv bootargs ${bootargs} androidboot.hardware=amlogic;"\
+            "run cmdline_keys;"\
+            "\0"\
+        "switch_bootmode="\
+            "get_rebootmode;"\
+            "if test ${reboot_mode} = factory_reset; then "\
+                    "run recovery_from_flash;"\
+            "else if test ${reboot_mode} = update; then "\
+                    "run update;"\
+            "else if test ${reboot_mode} = cold_boot; then "\
+                /*"run try_auto_burn; "*/\
+            "fi;fi;fi;"\
+            "\0" \
+        "storeboot="\
+            "hdmitx output 1080p60hz;"\
+            "if imgread kernel boot ${loadaddr}; then bootm ${loadaddr}; fi;"\
+            "run update;"\
+            "\0"\
+        "factory_reset_poweroff_protect="\
+            "echo wipe_data=${wipe_data}; echo wipe_cache=${wipe_cache};"\
+            "if test ${wipe_data} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; "\
+            "if test ${wipe_cache} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; \0" \
+         "update="\
+            /*first usb burning, second sdc_burn, third ext-sd autoscr/recovery, last udisk autoscr/recovery*/\
+            "run usb_burning; "\
+            "run sdc_burning; "\
+            "if mmcinfo; then "\
+                "run recovery_from_sdcard;"\
+            "fi;"\
+            "if usb start 0; then "\
+                "run recovery_from_udisk;"\
+            "fi;"\
+            "run recovery_from_flash;"\
+            "\0"\
+        "recovery_from_sdcard="\
+            "if fatload mmc 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload mmc 0 ${loadaddr} recovery.img; then "\
+                    "if fatload mmc 0 ${dtb_mem_addr} dtb.img; then echo sd dtb.img loaded; fi;"\
+                    "wipeisb; "\
+                    "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_udisk="\
+            "if fatload usb 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload usb 0 ${loadaddr} recovery.img; then "\
+                "if fatload usb 0 ${dtb_mem_addr} dtb.img; then echo udisk dtb.img loaded; fi;"\
+                "wipeisb; "\
+                "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_flash="\
+            "setenv bootargs ${bootargs} aml_dt=${aml_dt} recovery_part={recovery_part} recovery_offset={recovery_offset};"\
+            "if imgread kernel ${recovery_part} ${loadaddr} ${recovery_offset}; then wipeisb; bootm ${loadaddr}; fi"\
+            "\0"\
+        "init_display="\
+            "osd open;osd clear;imgread pic logo bootup $loadaddr;bmp display $bootup_offset;bmp scale;vout output ${outputmode}"\
+            "\0"\
+        "cmdline_keys="\
+            "if keyman init 0x1234; then "\
+                "if keyman read usid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.serialno=${usid};"\
+                "fi;"\
+                "if keyman read mac ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} mac=${mac} androidboot.mac=${mac};"\
+                "fi;"\
+                "if keyman read deviceid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.deviceid=${deviceid};"\
+                "fi;"\
+            "fi;"\
+            "\0"\
+        "upgrade_key="\
+            "if gpio input GPIOAO_3; then "\
+                "echo detect upgrade key; run update;"\
+            "fi;"\
+            "\0"\
+	"irremote_update="\
+		"if irkey 0xe31cfb04 0xb748fb04 2500000; then "\
+			"echo read irkey ok!; " \
+		"if itest ${irkey_value} == 0xe31cfb04; then " \
+			"run update;" \
+		"else if itest ${irkey_value} == 0xb748fb04; then " \
+			"run update;\n" \
+			"fi;fi;" \
+		"fi;\0" \
+
+
+#define CONFIG_PREBOOT  \
+            "run factory_reset_poweroff_protect;"\
+            "run upgrade_check;"\
+            "run init_display;"\
+            "run storeargs;"\
+            "run upgrade_key;" \
+            "run switch_bootmode;"
+#define CONFIG_BOOTCOMMAND "run storeboot"
+
+//#define CONFIG_ENV_IS_NOWHERE  1
+#define CONFIG_ENV_SIZE   (64*1024)
+#define CONFIG_FIT 1
+#define CONFIG_OF_LIBFDT 1
+#define CONFIG_ANDROID_BOOT_IMAGE 1
+#define CONFIG_ANDROID_IMG 1
+#define CONFIG_SYS_BOOTM_LEN (64<<20) /* Increase max gunzip size*/
+
+/* cpu */
+#define CONFIG_CPU_CLK					1200 //MHz. Range: 600-1800, should be multiple of 24
+
+/* ddr */
+#define CONFIG_DDR_SIZE					0 //MB //0 means ddr size auto-detect
+#define CONFIG_DDR_CLK					792  //MHz, Range: 384-1200, should be multiple of 24
+#define CONFIG_DDR4_CLK					1008  //MHz, for boards which use different ddr chip
+#define CONFIG_NR_DRAM_BANKS			1
+/* DDR type setting
+ *    CONFIG_DDR_TYPE_LPDDR3   : LPDDR3
+ *    CONFIG_DDR_TYPE_DDR3     : DDR3
+ *    CONFIG_DDR_TYPE_DDR4     : DDR4
+ *    CONFIG_DDR_TYPE_AUTO     : DDR3/DDR4 auto detect */
+#define CONFIG_DDR_TYPE					CONFIG_DDR_TYPE_AUTO
+/* DDR channel setting, please refer hardware design.
+ *    CONFIG_DDR0_RANK0        : DDR0 rank0
+ *    CONFIG_DDR0_RANK01       : DDR0 rank0+1
+ *    CONFIG_DDR0_16BIT        : DDR0 16bit mode
+ *    CONFIG_DDR0_16BIT_2      : DDR0 16bit mode, 2ranks
+ *    CONFIG_DDR_CHL_AUTO      : auto detect RANK0 / RANK0+1 */
+#define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR0_RANK0
+/* ddr functions */
+#define CONFIG_DDR_FULL_TEST			0 //0:disable, 1:enable. ddr full test
+#define CONFIG_CMD_DDR_D2PLL			0 //0:disable, 1:enable. d2pll cmd
+#define CONFIG_CMD_DDR_TEST				0 //0:disable, 1:enable. ddrtest cmd
+#define CONFIG_DDR_LOW_POWER			0 //0:disable, 1:enable. ddr clk gate for lp
+#define CONFIG_DDR_ZQ_PD				0 //0:disable, 1:enable. ddr zq power down
+#define CONFIG_DDR_USE_EXT_VREF			0 //0:disable, 1:enable. ddr use external vref
+#define CONFIG_DDR4_TIMING_TEST			0 //0:disable, 1:enable. ddr4 timing test function
+#define CONFIG_DDR_PLL_BYPASS			0 //0:disable, 1:enable. ddr pll bypass function
+
+/* storage: emmc/nand/sd */
+#define		CONFIG_STORE_COMPATIBLE 1
+#define 	CONFIG_ENV_OVERWRITE
+#define 	CONFIG_CMD_SAVEENV
+/* fixme, need fix*/
+
+#if (defined(CONFIG_ENV_IS_IN_AMLNAND) || defined(CONFIG_ENV_IS_IN_MMC)) && defined(CONFIG_STORE_COMPATIBLE)
+#error env in amlnand/mmc already be compatible;
+#endif
+#define		CONFIG_AML_SD_EMMC 1
+#ifdef		CONFIG_AML_SD_EMMC
+	#define 	CONFIG_GENERIC_MMC 1
+	#define 	CONFIG_CMD_MMC 1
+	#define	CONFIG_SYS_MMC_ENV_DEV 1
+	#define CONFIG_EMMC_DDR52_EN 1
+	#define CONFIG_EMMC_DDR52_CLK 35000000
+#endif
+#define		CONFIG_PARTITIONS 1
+#define 	CONFIG_SYS_NO_FLASH  1
+
+/*SPI*/
+#define CONFIG_AMLOGIC_SPI_FLASH 1
+#ifdef 		CONFIG_AMLOGIC_SPI_FLASH
+#undef 		CONFIG_ENV_IS_NOWHERE
+//#define		CONFIG_SPI_BOOT 1
+#define 	CONFIG_SPI_FLASH_ATMEL
+#define 	CONFIG_SPI_FLASH_EON
+#define 	CONFIG_SPI_FLASH_MACRONIX
+#define 	CONFIG_SPI_FLASH_SPANSION
+#define 	CONFIG_SPI_FLASH_SST
+#define 	CONFIG_SPI_FLASH_STMICRO
+#define 	CONFIG_SPI_FLASH_WINBOND
+#define		CONFIG_SPI_FRAM_RAMTRON
+#define		CONFIG_SPI_M95XXX
+//#define		CONFIG_SPI_FLASH_GIGADEVICE
+//#define		CONFIG_SPI_FLASH_PMDEVICE
+//#define		CONFIG_SPI_NOR_SECURE_STORAGE
+#define		CONFIG_SPI_FLASH_ESMT
+#define		CONFIG_SPI_FLASH 1
+#define 	CONFIG_CMD_SF 1
+#ifdef CONFIG_SPI_BOOT
+	#define CONFIG_ENV_OVERWRITE
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+	#define CONFIG_CMD_SAVEENV
+	#define CONFIG_ENV_SECT_SIZE		0x10000
+	#define CONFIG_ENV_OFFSET           0x1f0000
+#endif
+#endif
+
+
+/* vpu */
+#define CONFIG_AML_VPU 1
+
+/* DISPLAY & HDMITX */
+//#define CONFIG_AML_HDMITX20 1
+#define CONFIG_AML_CANVAS 1
+#define CONFIG_AML_VOUT 1
+#define CONFIG_AML_OSD 1
+#define CONFIG_OSD_SCALE_ENABLE 1
+#define CONFIG_CMD_BMP 1
+
+// #if defined(CONFIG_AML_VOUT)
+// #define CONFIG_AML_CVBS 1
+// #endif
+
+#define CONFIG_AML_LCD    1
+#define CONFIG_AML_LCD_TV 1
+#define CONFIG_AML_LCD_TABLET 1
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+/* #define CONFIG_MUSB_UDC		1 */
+#define CONFIG_CMD_USB 1
+#if defined(CONFIG_CMD_USB)
+	#define CONFIG_GXL_XHCI_BASE		0xc9000000
+	#define CONFIG_GXL_USB_PHY2_BASE	0xd0078000
+	#define CONFIG_GXL_USB_PHY3_BASE	0xd0078080
+	#define CONFIG_USB_STORAGE      1
+	#define CONFIG_USB_XHCI		1
+	#define CONFIG_USB_XHCI_AMLOGIC_GXL 1
+#endif //#if defined(CONFIG_CMD_USB)
+
+//UBOOT Facotry usb/sdcard burning config
+#define CONFIG_AML_V2_FACTORY_BURN              1       //support facotry usb burning
+#define CONFIG_AML_FACTORY_BURN_LOCAL_UPGRADE   1       //support factory sdcard burning
+#define CONFIG_POWER_KEY_NOT_SUPPORTED_FOR_BURN 1       //There isn't power-key for factory sdcard burning
+#define CONFIG_SD_BURNING_SUPPORT_UI            1       //Displaying upgrading progress bar when sdcard/udisk burning
+
+#define CONFIG_AML_SECURITY_KEY                 1
+#define CONFIG_UNIFY_KEY_MANAGE                 1
+
+/* net */
+#define CONFIG_CMD_NET   1
+#if defined(CONFIG_CMD_NET)
+	#define CONFIG_DESIGNWARE_ETH 1
+	#define CONFIG_PHYLIB	1
+	#define CONFIG_NET_MULTI 1
+	#define CONFIG_CMD_PING 1
+	#define CONFIG_CMD_DHCP 1
+	#define CONFIG_CMD_RARP 1
+	#define CONFIG_HOSTNAME        arm_gxbb
+	#define CONFIG_ETHADDR         00:15:18:01:81:31   /* Ethernet address */
+	#define CONFIG_IPADDR          10.18.9.97          /* Our ip address */
+	#define CONFIG_GATEWAYIP       10.18.9.1           /* Our getway ip address */
+	#define CONFIG_SERVERIP        10.18.9.113         /* Tftp server ip address */
+	#define CONFIG_NETMASK         255.255.255.0
+#endif /* (CONFIG_CMD_NET) */
+
+/* other devices */
+#define CONFIG_EFUSE 1
+#define CONFIG_SYS_I2C_AML 1
+#define CONFIG_SYS_I2C_SPEED     400000
+
+/* commands */
+#define CONFIG_CMD_CACHE 1
+#define CONFIG_CMD_BOOTI 1
+#define CONFIG_CMD_EFUSE 1
+#define CONFIG_CMD_I2C 1
+#define CONFIG_CMD_MEMORY 1
+#define CONFIG_CMD_FAT 1
+#define CONFIG_CMD_GPIO 1
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_REBOOT 1
+#define CONFIG_CMD_ECHO 1
+#define CONFIG_CMD_JTAG	1
+#define CONFIG_CMD_AUTOSCRIPT 1
+#define CONFIG_CMD_MISC 1
+
+/*file system*/
+#define CONFIG_DOS_PARTITION 1
+#define CONFIG_MMC 1
+#define CONFIG_FS_FAT 1
+#define CONFIG_FS_EXT4 1
+#define CONFIG_LZO 1
+
+/* Cache Definitions */
+//#define CONFIG_SYS_DCACHE_OFF
+//#define CONFIG_SYS_ICACHE_OFF
+
+/* other functions */
+#define CONFIG_NEED_BL301	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+//#define CONFIG_FIP_IMG_SUPPORT	1
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_SYS_LONGHELP 1
+#define CONFIG_CMD_MISC     1
+#define CONFIG_CMD_ITEST    1
+#define CONFIG_CMD_CPU_TEMP 1
+#define CONFIG_SYS_MEM_TOP_HIDE 0x08000000 //hide 128MB for kernel reserve
+
+/* debug mode defines */
+//#define CONFIG_DEBUG_MODE           1
+#ifdef CONFIG_DEBUG_MODE
+#define CONFIG_DDR_CLK_DEBUG        636
+#define CONFIG_CPU_CLK_DEBUG        600
+#endif
+
+//support secure boot
+#define CONFIG_AML_SECURE_UBOOT   1
+
+#if defined(CONFIG_AML_SECURE_UBOOT)
+
+//for SRAM size limitation just disable NAND
+//as the socket board default has no NAND
+//#undef CONFIG_AML_NAND
+
+//unify build for generate encrypted bootloader "u-boot.bin.encrypt"
+#define CONFIG_AML_CRYPTO_UBOOT   1
+
+//unify build for generate encrypted kernel image
+//SRC : "board/amlogic/(board)/boot.img"
+//DST : "fip/boot.img.encrypt"
+//#define CONFIG_AML_CRYPTO_IMG       1
+
+#endif //CONFIG_AML_SECURE_UBOOT
+
+#define CONFIG_SECURE_STORAGE 1
+
+//build with uboot auto test
+//#define CONFIG_AML_UBOOT_AUTO_TEST 1
+
+//board customer ID
+//#define CONFIG_CUSTOMER_ID  (0x6472616F624C4D41)
+
+#if defined(CONFIG_CUSTOMER_ID)
+  #undef CONFIG_AML_CUSTOMER_ID
+  #define CONFIG_AML_CUSTOMER_ID  CONFIG_CUSTOMER_ID
+#endif
+#define ETHERNET_INTERNAL_PHY
+
+#endif
+
diff --git a/board/amlogic/configs/txl_p321_v1.h b/board/amlogic/configs/txl_p321_v1.h
new file mode 100644
index 0000000..e178bcb
--- /dev/null
+++ b/board/amlogic/configs/txl_p321_v1.h
@@ -0,0 +1,455 @@
+
+/*
+ * board/amlogic/configs/txl_p321_v1.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __TXL_P321_V1_H__
+#define __TXL_P321_V1_H__
+
+#include <asm/arch/cpu.h>
+
+#define CONFIG_SYS_GENERIC_BOARD  1
+#ifndef CONFIG_AML_MESON
+#warning "include warning"
+#endif
+
+/*
+ * platform power init config
+ */
+#define CONFIG_PLATFORM_POWER_INIT
+#define CONFIG_VCCK_INIT_VOLTAGE	1100
+#define CONFIG_VDDEE_INIT_VOLTAGE	1000		// voltage for power up
+#define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
+
+/* configs for CEC */
+#define CONFIG_CEC_OSD_NAME		"AML_TV"
+#define CONFIG_CEC_WAKEUP
+
+/* SMP Definitinos */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+/* config saradc*/
+#define CONFIG_CMD_SARADC 1
+
+/* Serial config */
+#define CONFIG_CONS_INDEX 2
+#define CONFIG_BAUDRATE  115200
+#define CONFIG_AML_MESON_SERIAL   1
+#define CONFIG_SERIAL_MULTI		1
+
+//Enable ir remote wake up for bl30
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_CNT 3
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL1 0xef10fe01 //amlogic tv ir --- power
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL2 0XBB44FB04 //amlogic tv ir --- ch+
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL3 0xF20DFE01 //amlogic tv ir --- ch-
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL4 0xFFFFFFFF
+
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL5 0x3ac5bd02
+/* args/envs */
+#define CONFIG_SYS_MAXARGS  64
+#define CONFIG_EXTRA_ENV_SETTINGS \
+        "firstboot=1\0"\
+        "upgrade_step=0\0"\
+        "jtag=disable\0"\
+        "hdmiuart_mode=open\0"\
+        "loadaddr=1080000\0"\
+        "panel_type=lvds_1\0" \
+        "outputmode=1080p60hz\0" \
+        "hdmimode=1080p60hz\0" \
+        "cvbsmode=576cvbs\0" \
+        "display_width=1920\0" \
+        "display_height=1080\0" \
+        "display_bpp=16\0" \
+        "display_color_index=16\0" \
+        "display_layer=osd1\0" \
+        "display_color_fg=0xffff\0" \
+        "display_color_bg=0\0" \
+        "dtb_mem_addr=0x1000000\0" \
+        "fb_addr=0x3d800000\0" \
+        "fb_width=1920\0" \
+        "fb_height=1080\0" \
+        "usb_burning=update 1000\0" \
+        "fdt_high=0x20000000\0"\
+        "try_auto_burn=update 700 750;\0"\
+        "sdcburncfg=aml_sdc_burn.ini\0"\
+        "sdc_burning=sdc_burn ${sdcburncfg}\0"\
+        "wipe_data=successful\0"\
+        "wipe_cache=successful\0"\
+        "EnableSelinux=enforcing\0" \
+        "recovery_part=recovery\0"\
+        "recovery_offset=0\0"\
+        "cvbs_drv=0\0"\
+        "osd_reverse=0\0"\
+        "video_reverse=0\0"\
+        "initargs="\
+            "rootfstype=ramfs init=/init console=ttyS0,115200 no_console_suspend earlyprintk=aml-uart,0xc81004c0 ramoops.pstore_en=1 ramoops.record_size=0x8000 ramoops.console_size=0x4000 androidboot.selinux=${EnableSelinux} "\
+            "\0"\
+        "upgrade_check="\
+            "echo upgrade_step=${upgrade_step}; "\
+            "if itest ${upgrade_step} == 3; then "\
+                "run init_display; run storeargs; run update;"\
+            "else fi;"\
+            "\0"\
+        "storeargs="\
+            "setenv bootargs ${initargs} logo=${display_layer},loaded,${fb_addr} vout=${outputmode},enable panel_type=${panel_type} osd_reverse=${osd_reverse} video_reverse=${video_reverse} androidboot.firstboot=${firstboot} jtag=${jtag}; "\
+	"setenv bootargs ${bootargs} androidboot.hardware=amlogic;"\
+            "run cmdline_keys;"\
+            "\0"\
+        "switch_bootmode="\
+            "get_rebootmode;"\
+            "if test ${reboot_mode} = factory_reset; then "\
+                    "run recovery_from_flash;"\
+            "else if test ${reboot_mode} = update; then "\
+                    "run update;"\
+            "else if test ${reboot_mode} = cold_boot; then "\
+                /*"run try_auto_burn; "*/\
+            "fi;fi;fi;"\
+            "\0" \
+        "storeboot="\
+            "hdmitx output 1080p60hz;"\
+            "if imgread kernel boot ${loadaddr}; then bootm ${loadaddr}; fi;"\
+            "run update;"\
+            "\0"\
+        "factory_reset_poweroff_protect="\
+            "echo wipe_data=${wipe_data}; echo wipe_cache=${wipe_cache};"\
+            "if test ${wipe_data} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; "\
+            "if test ${wipe_cache} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; \0" \
+         "update="\
+            /*first usb burning, second sdc_burn, third ext-sd autoscr/recovery, last udisk autoscr/recovery*/\
+            "run usb_burning; "\
+            "run sdc_burning; "\
+            "if mmcinfo; then "\
+                "run recovery_from_sdcard;"\
+            "fi;"\
+            "if usb start 0; then "\
+                "run recovery_from_udisk;"\
+            "fi;"\
+            "run recovery_from_flash;"\
+            "\0"\
+        "recovery_from_sdcard="\
+            "if fatload mmc 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload mmc 0 ${loadaddr} recovery.img; then "\
+                    "if fatload mmc 0 ${dtb_mem_addr} dtb.img; then echo sd dtb.img loaded; fi;"\
+                    "wipeisb; "\
+                    "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_udisk="\
+            "if fatload usb 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload usb 0 ${loadaddr} recovery.img; then "\
+                "if fatload usb 0 ${dtb_mem_addr} dtb.img; then echo udisk dtb.img loaded; fi;"\
+                "wipeisb; "\
+                "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_flash="\
+            "setenv bootargs ${bootargs} aml_dt=${aml_dt} recovery_part={recovery_part} recovery_offset={recovery_offset};"\
+            "if imgread kernel ${recovery_part} ${loadaddr} ${recovery_offset}; then wipeisb; bootm ${loadaddr}; fi"\
+            "\0"\
+        "init_display="\
+            "osd open;osd clear;imgread pic logo bootup $loadaddr;bmp display $bootup_offset;bmp scale;vout output ${outputmode}"\
+            "\0"\
+        "cmdline_keys="\
+            "if keyman init 0x1234; then "\
+                "if keyman read usid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.serialno=${usid};"\
+                "fi;"\
+                "if keyman read mac ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} mac=${mac} androidboot.mac=${mac};"\
+                "fi;"\
+                "if keyman read deviceid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.deviceid=${deviceid};"\
+                "fi;"\
+            "fi;"\
+            "\0"\
+        "upgrade_key="\
+            "if gpio input GPIOAO_3; then "\
+                "echo detect upgrade key; run update;"\
+            "fi;"\
+            "\0"\
+	"irremote_update="\
+		"if irkey 0xe31cfb04 0xb748fb04 2500000; then "\
+			"echo read irkey ok!; " \
+		"if itest ${irkey_value} == 0xe31cfb04; then " \
+			"run update;" \
+		"else if itest ${irkey_value} == 0xb748fb04; then " \
+			"run update;\n" \
+			"fi;fi;" \
+		"fi;\0" \
+
+
+#define CONFIG_PREBOOT  \
+            "run factory_reset_poweroff_protect;"\
+            "run upgrade_check;"\
+            "run init_display;"\
+            "run storeargs;"\
+            "run upgrade_key;" \
+            "run switch_bootmode;"
+#define CONFIG_BOOTCOMMAND "run storeboot"
+
+//#define CONFIG_ENV_IS_NOWHERE  1
+#define CONFIG_ENV_SIZE   (64*1024)
+#define CONFIG_FIT 1
+#define CONFIG_OF_LIBFDT 1
+#define CONFIG_ANDROID_BOOT_IMAGE 1
+#define CONFIG_ANDROID_IMG 1
+#define CONFIG_SYS_BOOTM_LEN (64<<20) /* Increase max gunzip size*/
+
+/* cpu */
+#define CONFIG_CPU_CLK					1200 //MHz. Range: 600-1800, should be multiple of 24
+
+/* ddr */
+#define CONFIG_DDR_SIZE					0 //MB //0 means ddr size auto-detect
+#define CONFIG_DDR_CLK					792  //MHz, Range: 384-1200, should be multiple of 24
+#define CONFIG_DDR4_CLK					1008  //MHz, for boards which use different ddr chip
+#define CONFIG_NR_DRAM_BANKS			1
+/* DDR type setting
+ *    CONFIG_DDR_TYPE_LPDDR3   : LPDDR3
+ *    CONFIG_DDR_TYPE_DDR3     : DDR3
+ *    CONFIG_DDR_TYPE_DDR4     : DDR4
+ *    CONFIG_DDR_TYPE_AUTO     : DDR3/DDR4 auto detect */
+#define CONFIG_DDR_TYPE					CONFIG_DDR_TYPE_DDR3
+/* DDR channel setting, please refer hardware design.
+ *    CONFIG_DDR0_RANK0        : DDR0 rank0
+ *    CONFIG_DDR0_RANK01       : DDR0 rank0+1
+ *    CONFIG_DDR0_16BIT        : DDR0 16bit mode
+ *    CONFIG_DDR0_16BIT_2      : DDR0 16bit mode, 2ranks
+ *    CONFIG_DDR_CHL_AUTO      : auto detect RANK0 / RANK0+1 */
+#define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR0_RANK0
+/* ddr functions */
+#define CONFIG_DDR_FULL_TEST			0 //0:disable, 1:enable. ddr full test
+#define CONFIG_CMD_DDR_D2PLL			0 //0:disable, 1:enable. d2pll cmd
+#define CONFIG_CMD_DDR_TEST				0 //0:disable, 1:enable. ddrtest cmd
+#define CONFIG_DDR_LOW_POWER			0 //0:disable, 1:enable. ddr clk gate for lp
+#define CONFIG_DDR_ZQ_PD				0 //0:disable, 1:enable. ddr zq power down
+#define CONFIG_DDR_USE_EXT_VREF			0 //0:disable, 1:enable. ddr use external vref
+#define CONFIG_DDR4_TIMING_TEST			0 //0:disable, 1:enable. ddr4 timing test function
+#define CONFIG_DDR_PLL_BYPASS			0 //0:disable, 1:enable. ddr pll bypass function
+
+/* storage: emmc/nand/sd */
+#define		CONFIG_STORE_COMPATIBLE 1
+#define 	CONFIG_ENV_OVERWRITE
+#define 	CONFIG_CMD_SAVEENV
+/* fixme, need fix*/
+
+#if (defined(CONFIG_ENV_IS_IN_AMLNAND) || defined(CONFIG_ENV_IS_IN_MMC)) && defined(CONFIG_STORE_COMPATIBLE)
+#error env in amlnand/mmc already be compatible;
+#endif
+#define		CONFIG_AML_SD_EMMC 1
+#ifdef		CONFIG_AML_SD_EMMC
+	#define 	CONFIG_GENERIC_MMC 1
+	#define 	CONFIG_CMD_MMC 1
+	#define	CONFIG_SYS_MMC_ENV_DEV 1
+	#define CONFIG_EMMC_DDR52_EN 1
+	#define CONFIG_EMMC_DDR52_CLK 35000000
+#endif
+#define		CONFIG_PARTITIONS 1
+#define 	CONFIG_SYS_NO_FLASH  1
+
+/*SPI*/
+#define CONFIG_AMLOGIC_SPI_FLASH 1
+#ifdef 		CONFIG_AMLOGIC_SPI_FLASH
+#undef 		CONFIG_ENV_IS_NOWHERE
+//#define		CONFIG_SPI_BOOT 1
+#define 	CONFIG_SPI_FLASH_ATMEL
+#define 	CONFIG_SPI_FLASH_EON
+#define 	CONFIG_SPI_FLASH_MACRONIX
+#define 	CONFIG_SPI_FLASH_SPANSION
+#define 	CONFIG_SPI_FLASH_SST
+#define 	CONFIG_SPI_FLASH_STMICRO
+#define 	CONFIG_SPI_FLASH_WINBOND
+#define		CONFIG_SPI_FRAM_RAMTRON
+#define		CONFIG_SPI_M95XXX
+//#define		CONFIG_SPI_FLASH_GIGADEVICE
+//#define		CONFIG_SPI_FLASH_PMDEVICE
+//#define		CONFIG_SPI_NOR_SECURE_STORAGE
+#define		CONFIG_SPI_FLASH_ESMT
+#define		CONFIG_SPI_FLASH 1
+#define 	CONFIG_CMD_SF 1
+#ifdef CONFIG_SPI_BOOT
+	#define CONFIG_ENV_OVERWRITE
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+	#define CONFIG_CMD_SAVEENV
+	#define CONFIG_ENV_SECT_SIZE		0x10000
+	#define CONFIG_ENV_OFFSET           0x1f0000
+#endif
+#endif
+
+
+/* vpu */
+#define CONFIG_AML_VPU 1
+
+/* DISPLAY & HDMITX */
+//#define CONFIG_AML_HDMITX20 1
+#define CONFIG_AML_CANVAS 1
+#define CONFIG_AML_VOUT 1
+#define CONFIG_AML_OSD 1
+#define CONFIG_OSD_SCALE_ENABLE 1
+#define CONFIG_CMD_BMP 1
+
+// #if defined(CONFIG_AML_VOUT)
+// #define CONFIG_AML_CVBS 1
+// #endif
+
+#define CONFIG_AML_LCD    1
+#define CONFIG_AML_LCD_TV 1
+#define CONFIG_AML_LCD_TABLET 1
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+/* #define CONFIG_MUSB_UDC		1 */
+#define CONFIG_CMD_USB 1
+#if defined(CONFIG_CMD_USB)
+	#define CONFIG_GXL_XHCI_BASE		0xc9000000
+	#define CONFIG_GXL_USB_PHY2_BASE	0xd0078000
+	#define CONFIG_GXL_USB_PHY3_BASE	0xd0078080
+	#define CONFIG_USB_STORAGE      1
+	#define CONFIG_USB_XHCI		1
+	#define CONFIG_USB_XHCI_AMLOGIC_GXL 1
+#endif //#if defined(CONFIG_CMD_USB)
+
+//UBOOT Facotry usb/sdcard burning config
+#define CONFIG_AML_V2_FACTORY_BURN              1       //support facotry usb burning
+#define CONFIG_AML_FACTORY_BURN_LOCAL_UPGRADE   1       //support factory sdcard burning
+#define CONFIG_POWER_KEY_NOT_SUPPORTED_FOR_BURN 1       //There isn't power-key for factory sdcard burning
+#define CONFIG_SD_BURNING_SUPPORT_UI            1       //Displaying upgrading progress bar when sdcard/udisk burning
+
+#define CONFIG_AML_SECURITY_KEY                 1
+#define CONFIG_UNIFY_KEY_MANAGE                 1
+
+/* net */
+#define CONFIG_CMD_NET   1
+#if defined(CONFIG_CMD_NET)
+	#define CONFIG_DESIGNWARE_ETH 1
+	#define CONFIG_PHYLIB	1
+	#define CONFIG_NET_MULTI 1
+	#define CONFIG_CMD_PING 1
+	#define CONFIG_CMD_DHCP 1
+	#define CONFIG_CMD_RARP 1
+	#define CONFIG_HOSTNAME        arm_gxbb
+	#define CONFIG_ETHADDR         00:15:18:01:81:31   /* Ethernet address */
+	#define CONFIG_IPADDR          10.18.9.97          /* Our ip address */
+	#define CONFIG_GATEWAYIP       10.18.9.1           /* Our getway ip address */
+	#define CONFIG_SERVERIP        10.18.9.113         /* Tftp server ip address */
+	#define CONFIG_NETMASK         255.255.255.0
+#endif /* (CONFIG_CMD_NET) */
+
+/* other devices */
+#define CONFIG_EFUSE 1
+#define CONFIG_SYS_I2C_AML 1
+#define CONFIG_SYS_I2C_SPEED     400000
+
+/* commands */
+#define CONFIG_CMD_CACHE 1
+#define CONFIG_CMD_BOOTI 1
+#define CONFIG_CMD_EFUSE 1
+#define CONFIG_CMD_I2C 1
+#define CONFIG_CMD_MEMORY 1
+#define CONFIG_CMD_FAT 1
+#define CONFIG_CMD_GPIO 1
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_REBOOT 1
+#define CONFIG_CMD_ECHO 1
+#define CONFIG_CMD_JTAG	1
+#define CONFIG_CMD_AUTOSCRIPT 1
+#define CONFIG_CMD_MISC 1
+
+/*file system*/
+#define CONFIG_DOS_PARTITION 1
+#define CONFIG_MMC 1
+#define CONFIG_FS_FAT 1
+#define CONFIG_FS_EXT4 1
+#define CONFIG_LZO 1
+
+/* Cache Definitions */
+//#define CONFIG_SYS_DCACHE_OFF
+//#define CONFIG_SYS_ICACHE_OFF
+
+/* other functions */
+#define CONFIG_NEED_BL301	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+//#define CONFIG_FIP_IMG_SUPPORT	1
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_SYS_LONGHELP 1
+#define CONFIG_CMD_MISC     1
+#define CONFIG_CMD_ITEST    1
+#define CONFIG_CMD_CPU_TEMP 1
+#define CONFIG_SYS_MEM_TOP_HIDE 0x08000000 //hide 128MB for kernel reserve
+
+/* debug mode defines */
+//#define CONFIG_DEBUG_MODE           1
+#ifdef CONFIG_DEBUG_MODE
+#define CONFIG_DDR_CLK_DEBUG        636
+#define CONFIG_CPU_CLK_DEBUG        600
+#endif
+
+//support secure boot
+#define CONFIG_AML_SECURE_UBOOT   1
+
+#if defined(CONFIG_AML_SECURE_UBOOT)
+
+//for SRAM size limitation just disable NAND
+//as the socket board default has no NAND
+//#undef CONFIG_AML_NAND
+
+//unify build for generate encrypted bootloader "u-boot.bin.encrypt"
+#define CONFIG_AML_CRYPTO_UBOOT   1
+
+//unify build for generate encrypted kernel image
+//SRC : "board/amlogic/(board)/boot.img"
+//DST : "fip/boot.img.encrypt"
+//#define CONFIG_AML_CRYPTO_IMG       1
+
+#endif //CONFIG_AML_SECURE_UBOOT
+
+#define CONFIG_SECURE_STORAGE 1
+
+//build with uboot auto test
+//#define CONFIG_AML_UBOOT_AUTO_TEST 1
+
+//board customer ID
+//#define CONFIG_CUSTOMER_ID  (0x6472616F624C4D41)
+
+#if defined(CONFIG_CUSTOMER_ID)
+  #undef CONFIG_AML_CUSTOMER_ID
+  #define CONFIG_AML_CUSTOMER_ID  CONFIG_CUSTOMER_ID
+#endif
+#define ETHERNET_INTERNAL_PHY
+
+#endif
+
diff --git a/board/amlogic/configs/txl_skt_v1.h b/board/amlogic/configs/txl_skt_v1.h
new file mode 100644
index 0000000..1317fed
--- /dev/null
+++ b/board/amlogic/configs/txl_skt_v1.h
@@ -0,0 +1,452 @@
+
+/*
+ * board/amlogic/configs/txl_skt_v1.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef __TXL_SKT_V1_H__
+#define __TXL_SKT_V1_H__
+
+#include <asm/arch/cpu.h>
+
+
+#define CONFIG_SYS_GENERIC_BOARD  1
+#ifndef CONFIG_AML_MESON
+#warning "include warning"
+#endif
+
+/*
+ * platform power init config
+ */
+#define CONFIG_PLATFORM_POWER_INIT
+#define CONFIG_VCCK_INIT_VOLTAGE	1100
+#define CONFIG_VDDEE_INIT_VOLTAGE	1100		// voltage for power up
+#define CONFIG_VDDEE_SLEEP_VOLTAGE	 850		// voltage for suspend
+
+/* configs for CEC */
+#define CONFIG_CEC_OSD_NAME		"AML_TV"
+#define CONFIG_CEC_WAKEUP
+
+/* SMP Definitinos */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+/* config saradc*/
+#define CONFIG_CMD_SARADC 1
+
+/* Serial config */
+#define CONFIG_CONS_INDEX 2
+#define CONFIG_BAUDRATE  115200
+#define CONFIG_AML_MESON_SERIAL   1
+#define CONFIG_SERIAL_MULTI		1
+
+//Enable ir remote wake up for bl30
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_CNT 3
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL1 0xef10fe01 //amlogic tv ir --- power
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL2 0XBB44FB04 //amlogic tv ir --- ch+
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL3 0xF20DFE01 //amlogic tv ir --- ch-
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL4 0xFFFFFFFF
+
+#define CONFIG_IR_REMOTE_POWER_UP_KEY_VAL5 0x3ac5bd02
+/* args/envs */
+#define CONFIG_SYS_MAXARGS  64
+#define CONFIG_EXTRA_ENV_SETTINGS \
+        "firstboot=1\0"\
+        "upgrade_step=0\0"\
+        "jtag=apao\0"\
+        "loadaddr=1080000\0"\
+        "panel_type=lvds_0\0" \
+        "outputmode=1080p60hz\0" \
+        "hdmimode=1080p60hz\0" \
+        "cvbsmode=576cvbs\0" \
+        "display_width=1920\0" \
+        "display_height=1080\0" \
+        "display_bpp=16\0" \
+        "display_color_index=16\0" \
+        "display_layer=osd1\0" \
+        "display_color_fg=0xffff\0" \
+        "display_color_bg=0\0" \
+        "dtb_mem_addr=0x1000000\0" \
+        "fb_addr=0x3d800000\0" \
+        "fb_width=1920\0" \
+        "fb_height=1080\0" \
+        "usb_burning=update 1000\0" \
+        "fdt_high=0x20000000\0"\
+        "try_auto_burn=update 700 750;\0"\
+        "sdcburncfg=aml_sdc_burn.ini\0"\
+        "sdc_burning=sdc_burn ${sdcburncfg}\0"\
+        "wipe_data=successful\0"\
+        "wipe_cache=successful\0"\
+        "recovery_part=recovery\0"\
+        "recovery_offset=0\0"\
+        "cvbs_drv=0\0"\
+        "initargs="\
+            "rootfstype=ramfs init=/init console=ttyS0,115200 no_console_suspend earlyprintk=aml-uart,0xc81004c0 ramoops.pstore_en=1 ramoops.record_size=0x8000 ramoops.console_size=0x4000 androidboot.selinux=enforcing"\
+            "\0"\
+        "upgrade_check="\
+            "echo upgrade_step=${upgrade_step}; "\
+            "if itest ${upgrade_step} == 3; then "\
+                "run init_display; run storeargs; run update;"\
+            "else fi;"\
+            "\0"\
+        "storeargs="\
+            "setenv bootargs ${initargs} logo=${display_layer},loaded,${fb_addr} vout=${outputmode},enable panel_type=${panel_type} androidboot.firstboot=${firstboot} jtag=${jtag}; "\
+	"setenv bootargs ${bootargs} androidboot.hardware=amlogic;"\
+            "run cmdline_keys;"\
+            "\0"\
+        "switch_bootmode="\
+            "get_rebootmode;"\
+            "if test ${reboot_mode} = factory_reset; then "\
+                    "run recovery_from_flash;"\
+            "else if test ${reboot_mode} = update; then "\
+                    "run update;"\
+            "else if test ${reboot_mode} = cold_boot; then "\
+                /*"run try_auto_burn; "*/\
+            "fi;fi;fi;"\
+            "\0" \
+        "storeboot="\
+            "hdmitx output 1080p60hz;"\
+            "if imgread kernel boot ${loadaddr}; then bootm ${loadaddr}; fi;"\
+            "run update;"\
+            "\0"\
+        "factory_reset_poweroff_protect="\
+            "echo wipe_data=${wipe_data}; echo wipe_cache=${wipe_cache};"\
+            "if test ${wipe_data} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; "\
+            "if test ${wipe_cache} = failed; then "\
+                "run init_display; run storeargs;"\
+                "if mmcinfo; then "\
+                    "run recovery_from_sdcard;"\
+                "fi;"\
+                "if usb start 0; then "\
+                    "run recovery_from_udisk;"\
+                "fi;"\
+                "run recovery_from_flash;"\
+            "fi; \0" \
+         "update="\
+            /*first usb burning, second sdc_burn, third ext-sd autoscr/recovery, last udisk autoscr/recovery*/\
+            "run usb_burning; "\
+            "run sdc_burning; "\
+            "if mmcinfo; then "\
+                "run recovery_from_sdcard;"\
+            "fi;"\
+            "if usb start 0; then "\
+                "run recovery_from_udisk;"\
+            "fi;"\
+            "run recovery_from_flash;"\
+            "\0"\
+        "recovery_from_sdcard="\
+            "if fatload mmc 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload mmc 0 ${loadaddr} recovery.img; then "\
+                    "if fatload mmc 0 ${dtb_mem_addr} dtb.img; then echo sd dtb.img loaded; fi;"\
+                    "wipeisb; "\
+                    "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_udisk="\
+            "if fatload usb 0 ${loadaddr} aml_autoscript; then autoscr ${loadaddr}; fi;"\
+            "if fatload usb 0 ${loadaddr} recovery.img; then "\
+                "if fatload usb 0 ${dtb_mem_addr} dtb.img; then echo udisk dtb.img loaded; fi;"\
+                "wipeisb; "\
+                "bootm ${loadaddr};fi;"\
+            "\0"\
+        "recovery_from_flash="\
+            "setenv bootargs ${bootargs} aml_dt=${aml_dt} recovery_part={recovery_part} recovery_offset={recovery_offset};"\
+            "if imgread kernel ${recovery_part} ${loadaddr} ${recovery_offset}; then wipeisb; bootm ${loadaddr}; fi"\
+            "\0"\
+        "init_display="\
+            "osd open;osd clear;imgread pic logo bootup $loadaddr;bmp display $bootup_offset;bmp scale;vout output ${outputmode}"\
+            "\0"\
+        "cmdline_keys="\
+            "if keyman init 0x1234; then "\
+                "if keyman read usid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.serialno=${usid};"\
+                "fi;"\
+                "if keyman read mac ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} mac=${mac} androidboot.mac=${mac};"\
+                "fi;"\
+                "if keyman read deviceid ${loadaddr} str; then "\
+                    "setenv bootargs ${bootargs} androidboot.deviceid=${deviceid};"\
+                "fi;"\
+            "fi;"\
+            "\0"\
+        "upgrade_key="\
+            "if gpio input GPIOAO_3; then "\
+                "echo detect upgrade key; run update;"\
+            "fi;"\
+            "\0"\
+	"irremote_update="\
+		"if irkey 0xe31cfb04 0xb748fb04 2500000; then "\
+			"echo read irkey ok!; " \
+		"if itest ${irkey_value} == 0xe31cfb04; then " \
+			"run update;" \
+		"else if itest ${irkey_value} == 0xb748fb04; then " \
+			"run update;\n" \
+			"fi;fi;" \
+		"fi;\0" \
+
+
+#define CONFIG_PREBOOT  \
+            "run factory_reset_poweroff_protect;"\
+            "run upgrade_check;"\
+            "run init_display;"\
+            "run storeargs;"\
+            "run upgrade_key;" \
+            "run switch_bootmode;"
+#define CONFIG_BOOTCOMMAND "run storeboot"
+
+//#define CONFIG_ENV_IS_NOWHERE  1
+#define CONFIG_ENV_SIZE   (64*1024)
+#define CONFIG_FIT 1
+#define CONFIG_OF_LIBFDT 1
+#define CONFIG_ANDROID_BOOT_IMAGE 1
+#define CONFIG_ANDROID_IMG 1
+#define CONFIG_SYS_BOOTM_LEN (64<<20) /* Increase max gunzip size*/
+
+/* cpu */
+#define CONFIG_CPU_CLK					1200 //MHz. Range: 600-1800, should be multiple of 24
+
+/* ddr */
+#define CONFIG_DDR_SIZE					0 //MB //0 means ddr size auto-detect
+#define CONFIG_DDR_CLK					792  //MHz, Range: 384-1200, should be multiple of 24
+#define CONFIG_DDR4_CLK					1008  //MHz, for boards which use different ddr chip
+#define CONFIG_NR_DRAM_BANKS			1
+/* DDR type setting
+ *    CONFIG_DDR_TYPE_LPDDR3   : LPDDR3
+ *    CONFIG_DDR_TYPE_DDR3     : DDR3
+ *    CONFIG_DDR_TYPE_DDR4     : DDR4
+ *    CONFIG_DDR_TYPE_AUTO     : DDR3/DDR4 auto detect */
+#define CONFIG_DDR_TYPE					CONFIG_DDR_TYPE_AUTO
+/* DDR channel setting, please refer hardware design.
+ *    CONFIG_DDR0_RANK0        : DDR0 rank0
+ *    CONFIG_DDR0_RANK01       : DDR0 rank0+1
+ *    CONFIG_DDR0_16BIT        : DDR0 16bit mode
+ *    CONFIG_DDR0_16BIT_2      : DDR0 16bit mode, 2ranks
+ *    CONFIG_DDR_CHL_AUTO      : auto detect RANK0 / RANK0+1 */
+#define CONFIG_DDR_CHANNEL_SET			CONFIG_DDR0_RANK0
+/* ddr functions */
+#define CONFIG_DDR_FULL_TEST			0 //0:disable, 1:enable. ddr full test
+#define CONFIG_CMD_DDR_D2PLL			0 //0:disable, 1:enable. d2pll cmd
+#define CONFIG_CMD_DDR_TEST				0 //0:disable, 1:enable. ddrtest cmd
+#define CONFIG_DDR_LOW_POWER			0 //0:disable, 1:enable. ddr clk gate for lp
+#define CONFIG_DDR_ZQ_PD				0 //0:disable, 1:enable. ddr zq power down
+#define CONFIG_DDR_USE_EXT_VREF			0 //0:disable, 1:enable. ddr use external vref
+#define CONFIG_DDR4_TIMING_TEST			0 //0:disable, 1:enable. ddr4 timing test function
+#define CONFIG_DDR_PLL_BYPASS			0 //0:disable, 1:enable. ddr pll bypass function
+
+/* storage: emmc/nand/sd */
+#define		CONFIG_STORE_COMPATIBLE 1
+#define 	CONFIG_ENV_OVERWRITE
+#define 	CONFIG_CMD_SAVEENV
+/* fixme, need fix*/
+
+#if (defined(CONFIG_ENV_IS_IN_AMLNAND) || defined(CONFIG_ENV_IS_IN_MMC)) && defined(CONFIG_STORE_COMPATIBLE)
+#error env in amlnand/mmc already be compatible;
+#endif
+#define		CONFIG_AML_SD_EMMC 1
+#ifdef		CONFIG_AML_SD_EMMC
+	#define 	CONFIG_GENERIC_MMC 1
+	#define 	CONFIG_CMD_MMC 1
+	#define	CONFIG_SYS_MMC_ENV_DEV 1
+	#define CONFIG_EMMC_DDR52_EN 1
+	#define CONFIG_EMMC_DDR52_CLK 35000000
+#endif
+#define		CONFIG_PARTITIONS 1
+#define 	CONFIG_SYS_NO_FLASH  1
+
+/*SPI*/
+#define CONFIG_AMLOGIC_SPI_FLASH 1
+#ifdef 		CONFIG_AMLOGIC_SPI_FLASH
+#undef 		CONFIG_ENV_IS_NOWHERE
+//#define		CONFIG_SPI_BOOT 1
+#define 	CONFIG_SPI_FLASH_ATMEL
+#define 	CONFIG_SPI_FLASH_EON
+#define 	CONFIG_SPI_FLASH_MACRONIX
+#define 	CONFIG_SPI_FLASH_SPANSION
+#define 	CONFIG_SPI_FLASH_SST
+#define 	CONFIG_SPI_FLASH_STMICRO
+#define 	CONFIG_SPI_FLASH_WINBOND
+#define		CONFIG_SPI_FRAM_RAMTRON
+#define		CONFIG_SPI_M95XXX
+//#define		CONFIG_SPI_FLASH_GIGADEVICE
+//#define		CONFIG_SPI_FLASH_PMDEVICE
+//#define		CONFIG_SPI_NOR_SECURE_STORAGE
+#define		CONFIG_SPI_FLASH_ESMT
+#define		CONFIG_SPI_FLASH 1
+#define 	CONFIG_CMD_SF 1
+#ifdef CONFIG_SPI_BOOT
+	#define CONFIG_ENV_OVERWRITE
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+	#define CONFIG_CMD_SAVEENV
+	#define CONFIG_ENV_SECT_SIZE		0x10000
+	#define CONFIG_ENV_OFFSET           0x1f0000
+#endif
+#endif
+
+
+/* vpu */
+#define CONFIG_AML_VPU 1
+
+/* DISPLAY & HDMITX */
+//#define CONFIG_AML_HDMITX20 1
+#define CONFIG_AML_CANVAS 1
+#define CONFIG_AML_VOUT 1
+#define CONFIG_AML_OSD 1
+#define CONFIG_OSD_SCALE_ENABLE 1
+#define CONFIG_CMD_BMP 1
+
+#if defined(CONFIG_AML_VOUT)
+//#define CONFIG_AML_CVBS 1
+#endif
+
+#define CONFIG_AML_LCD    1
+#define CONFIG_AML_LCD_TV 1
+#define CONFIG_AML_LCD_TABLET 1
+
+/* USB
+ * Enable CONFIG_MUSB_HCD for Host functionalities MSC, keyboard
+ * Enable CONFIG_MUSB_UDD for Device functionalities.
+ */
+/* #define CONFIG_MUSB_UDC		1 */
+#define CONFIG_CMD_USB 1
+#if defined(CONFIG_CMD_USB)
+	#define CONFIG_GXL_XHCI_BASE		0xc9000000
+	#define CONFIG_GXL_USB_PHY2_BASE	0xd0078000
+	#define CONFIG_GXL_USB_PHY3_BASE	0xd0078080
+	#define CONFIG_USB_STORAGE      1
+	#define CONFIG_USB_XHCI		1
+	#define CONFIG_USB_XHCI_AMLOGIC_GXL 1
+#endif //#if defined(CONFIG_CMD_USB)
+
+//UBOOT Facotry usb/sdcard burning config
+#define CONFIG_AML_V2_FACTORY_BURN              1       //support facotry usb burning
+#define CONFIG_AML_FACTORY_BURN_LOCAL_UPGRADE   1       //support factory sdcard burning
+#define CONFIG_POWER_KEY_NOT_SUPPORTED_FOR_BURN 1       //There isn't power-key for factory sdcard burning
+#define CONFIG_SD_BURNING_SUPPORT_UI            1       //Displaying upgrading progress bar when sdcard/udisk burning
+
+#define CONFIG_AML_SECURITY_KEY                 1
+#define CONFIG_UNIFY_KEY_MANAGE                 1
+
+/* net */
+#define CONFIG_CMD_NET   1
+#if defined(CONFIG_CMD_NET)
+	#define CONFIG_DESIGNWARE_ETH 1
+	#define CONFIG_PHYLIB	1
+	#define CONFIG_NET_MULTI 1
+	#define CONFIG_CMD_PING 1
+	#define CONFIG_CMD_DHCP 1
+	#define CONFIG_CMD_RARP 1
+	#define CONFIG_HOSTNAME        arm_gxbb
+	#define CONFIG_ETHADDR         00:15:18:01:81:31   /* Ethernet address */
+	#define CONFIG_IPADDR          10.18.9.97          /* Our ip address */
+	#define CONFIG_GATEWAYIP       10.18.9.1           /* Our getway ip address */
+	#define CONFIG_SERVERIP        10.18.9.113         /* Tftp server ip address */
+	#define CONFIG_NETMASK         255.255.255.0
+#endif /* (CONFIG_CMD_NET) */
+
+/* other devices */
+#define CONFIG_EFUSE 1
+#define CONFIG_SYS_I2C_AML 1
+#define CONFIG_SYS_I2C_SPEED     400000
+
+/* commands */
+#define CONFIG_CMD_CACHE 1
+#define CONFIG_CMD_BOOTI 1
+#define CONFIG_CMD_EFUSE 1
+#define CONFIG_CMD_I2C 1
+#define CONFIG_CMD_MEMORY 1
+#define CONFIG_CMD_FAT 1
+#define CONFIG_CMD_GPIO 1
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_REBOOT 1
+#define CONFIG_CMD_ECHO 1
+#define CONFIG_CMD_JTAG	1
+#define CONFIG_CMD_AUTOSCRIPT 1
+#define CONFIG_CMD_MISC 1
+
+/*file system*/
+#define CONFIG_DOS_PARTITION 1
+#define CONFIG_MMC 1
+#define CONFIG_FS_FAT 1
+#define CONFIG_FS_EXT4 1
+#define CONFIG_LZO 1
+
+/* Cache Definitions */
+//#define CONFIG_SYS_DCACHE_OFF
+//#define CONFIG_SYS_ICACHE_OFF
+
+/* other functions */
+#define CONFIG_NEED_BL301	1
+#define CONFIG_NEED_BL32	1
+#define CONFIG_CMD_RSVMEM	1
+//#define CONFIG_FIP_IMG_SUPPORT	1
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_SYS_LONGHELP 1
+#define CONFIG_CMD_MISC     1
+#define CONFIG_CMD_ITEST    1
+#define CONFIG_CMD_CPU_TEMP 1
+#define CONFIG_SYS_MEM_TOP_HIDE 0x08000000 //hide 128MB for kernel reserve
+
+/* debug mode defines */
+//#define CONFIG_DEBUG_MODE			1
+#ifdef CONFIG_DEBUG_MODE
+#define CONFIG_DDR_CLK_DEBUG		636
+#define CONFIG_CPU_CLK_DEBUG		600
+#endif
+
+//support secure boot
+#define CONFIG_AML_SECURE_UBOOT   1
+
+#if defined(CONFIG_AML_SECURE_UBOOT)
+
+//for GXBB SRAM size limitation just disable NAND
+//as the socket board default has no NAND
+//#undef CONFIG_AML_NAND
+
+//unify build for generate encrypted bootloader "u-boot.bin.encrypt"
+#define CONFIG_AML_CRYPTO_UBOOT   1
+
+//unify build for generate encrypted kernel image
+//SRC : "board/amlogic/gxb_skt_v1/boot.img"
+//DST : "fip/boot.img.encrypt"
+//#define CONFIG_AML_CRYPTO_IMG       1
+
+#endif //CONFIG_AML_SECURE_UBOOT
+
+#define CONFIG_SECURE_STORAGE 1
+
+//build with uboot auto test
+//#define CONFIG_AML_UBOOT_AUTO_TEST 1
+
+//board customer ID
+//#define CONFIG_CUSTOMER_ID  (0x6472616F624C4D41)
+
+#if defined(CONFIG_CUSTOMER_ID)
+  #undef CONFIG_AML_CUSTOMER_ID
+  #define CONFIG_AML_CUSTOMER_ID  CONFIG_CUSTOMER_ID
+#endif
+#define ETHERNET_INTERNAL_PHY
+
+#endif
+
diff --git a/board/amlogic/defconfigs/txl_p320_v1_defconfig b/board/amlogic/defconfigs/txl_p320_v1_defconfig
new file mode 100644
index 0000000..06f7915
--- /dev/null
+++ b/board/amlogic/defconfigs/txl_p320_v1_defconfig
@@ -0,0 +1,6 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GXTV=y
+CONFIG_TXL_P320_V1=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
diff --git a/board/amlogic/defconfigs/txl_p321_v1_defconfig b/board/amlogic/defconfigs/txl_p321_v1_defconfig
new file mode 100644
index 0000000..d307aaf
--- /dev/null
+++ b/board/amlogic/defconfigs/txl_p321_v1_defconfig
@@ -0,0 +1,6 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GXTV=y
+CONFIG_TXL_P321_V1=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
diff --git a/board/amlogic/defconfigs/txl_pxp_defconfig b/board/amlogic/defconfigs/txl_pxp_defconfig
new file mode 100644
index 0000000..d811065
--- /dev/null
+++ b/board/amlogic/defconfigs/txl_pxp_defconfig
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GX=y
+CONFIG_TXL_SKT_V1=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
+CONFIG_PXP_EMULATOR=y
diff --git a/board/amlogic/defconfigs/txl_skt_v1_defconfig b/board/amlogic/defconfigs/txl_skt_v1_defconfig
new file mode 100644
index 0000000..0c01c3e
--- /dev/null
+++ b/board/amlogic/defconfigs/txl_skt_v1_defconfig
@@ -0,0 +1,6 @@
+CONFIG_ARM=y
+CONFIG_TARGET_MESON_GXTV=y
+CONFIG_TXL_SKT_V1=y
+CONFIG_DM=y
+CONFIG_DM_GPIO=y
+CONFIG_AML_GPIO=y
diff --git a/board/amlogic/gxb_p200_v1/gxb_p200_v1.c b/board/amlogic/gxb_p200_v1/gxb_p200_v1.c
index 2ee6362..8f7f981 100644
--- a/board/amlogic/gxb_p200_v1/gxb_p200_v1.c
+++ b/board/amlogic/gxb_p200_v1/gxb_p200_v1.c
@@ -499,6 +499,7 @@ int checkhw(char * name)
 const char * const _env_args_reserve_[] =
 {
 		"aml_dt",
+		"firstboot",
 
 		NULL//Keep NULL be last to tell END
 };
diff --git a/board/amlogic/gxb_p201_v1/gxb_p201_v1.c b/board/amlogic/gxb_p201_v1/gxb_p201_v1.c
index 843a1da..725f0e5 100644
--- a/board/amlogic/gxb_p201_v1/gxb_p201_v1.c
+++ b/board/amlogic/gxb_p201_v1/gxb_p201_v1.c
@@ -477,3 +477,12 @@ phys_size_t get_effective_memsize(void)
 	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
 #endif
 }
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxb_skt_v1/firmware/board_init.c b/board/amlogic/gxb_skt_v1/firmware/board_init.c
index 212b57e..107f13e 100644
--- a/board/amlogic/gxb_skt_v1/firmware/board_init.c
+++ b/board/amlogic/gxb_skt_v1/firmware/board_init.c
@@ -19,10 +19,10 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
 
-//#include "power.c"
+#include "power.c"
 
 /* bl2 customer code */
 void board_init(void)
 {
-	//power_init(0);
+	power_init(0);
 }
\ No newline at end of file
diff --git a/board/amlogic/gxb_skt_v1/firmware/power.c b/board/amlogic/gxb_skt_v1/firmware/power.c
new file mode 100644
index 0000000..f3cc7ae
--- /dev/null
+++ b/board/amlogic/gxb_skt_v1/firmware/power.c
@@ -0,0 +1,183 @@
+
+/*
+ * board/amlogic/gxb_p200_v1/firmware/power.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "config.h"
+#include <serial.h>
+//#include <stdio.h>
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+static int pwm_voltage_table[][2] = {
+	{ 0x1c0000,  860},
+	{ 0x1b0001,  870},
+	{ 0x1a0002,  880},
+	{ 0x190003,  890},
+	{ 0x180004,  900},
+	{ 0x170005,  910},
+	{ 0x160006,  920},
+	{ 0x150007,  930},
+	{ 0x140008,  940},
+	{ 0x130009,  950},
+	{ 0x12000a,  960},
+	{ 0x11000b,  970},
+	{ 0x10000c,  980},
+	{ 0x0f000d,  990},
+	{ 0x0e000e, 1000},
+	{ 0x0d000f, 1010},
+	{ 0x0c0010, 1020},
+	{ 0x0b0011, 1030},
+	{ 0x0a0012, 1040},
+	{ 0x090013, 1050},
+	{ 0x080014, 1060},
+	{ 0x070015, 1070},
+	{ 0x060016, 1080},
+	{ 0x050017, 1090},
+	{ 0x040018, 1100},
+	{ 0x030019, 1110},
+	{ 0x02001a, 1120},
+	{ 0x01001b, 1130},
+	{ 0x00001c, 1140}
+};
+
+#define P_PIN_MUX_REG3		(*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG7		(*((volatile unsigned *)(0xda834400 + (0x33 << 2))))
+
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+#define P_PWM_PWM_B		(*((volatile unsigned *)(0xc1100000 + (0x2155 << 2))))
+#define P_PWM_MISC_REG_CD	(*((volatile unsigned *)(0xc1100000 + (0x2196 << 2))))
+#define P_PWM_PWM_D		(*((volatile unsigned *)(0xc1100000 + (0x2195 << 2))))
+
+#define P_EE_TIMER_E		(*((volatile unsigned *)(0xc1100000 + (0x2662 << 2))))
+
+enum pwm_id {
+    pwm_a = 0,
+    pwm_b,
+    pwm_c,
+    pwm_d,
+    pwm_e,
+    pwm_f,
+};
+
+unsigned int _get_time(void)
+{
+	return P_EE_TIMER_E;
+}
+
+void _udelay_(unsigned int us)
+{
+	unsigned int t0 = _get_time();
+
+	while (_get_time() - t0 <= us)
+		;
+}
+
+void pwm_init(int id)
+{
+	unsigned int reg;
+
+	/*
+	 * TODO: support more pwm controllers, right now only support
+	 * PWM_B, PWM_D
+	 */
+
+	switch (id) {
+	case pwm_b:
+		reg = P_PWM_MISC_REG_AB;
+		reg &= ~(0x7f << 16);
+		reg |=  ((1 << 23) | (1 << 1));
+		P_PWM_MISC_REG_AB = reg;
+		/*
+		 * default set to max voltage
+		 */
+		P_PWM_PWM_B = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+		reg  = P_PIN_MUX_REG7;
+		reg &= ~(1 << 22);
+		P_PIN_MUX_REG7 = reg;
+
+		reg  = P_PIN_MUX_REG3;
+		reg &= ~(1 << 22);
+		reg |=  (1 << 21);		// enable PWM_B
+		P_PIN_MUX_REG3 = reg;
+		break;
+
+	case pwm_d:
+		reg = P_PWM_MISC_REG_CD;
+		reg &= ~(0x7f << 16);
+		reg |=  ((1 << 23) | (1 << 1));
+		P_PWM_MISC_REG_CD = reg;
+		/*
+		 * default set to max voltage
+		 */
+		P_PWM_PWM_D = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+		reg  = P_PIN_MUX_REG7;
+		reg &= ~(1 << 23);
+		P_PIN_MUX_REG7 = reg;
+
+		reg  = P_PIN_MUX_REG3;
+		reg |=  (1 << 20);		// enable PWM_D
+		P_PIN_MUX_REG3 = reg;
+		break;
+	default:
+		break;
+	}
+
+	_udelay_(200);
+}
+
+void pwm_set_voltage(unsigned int id, unsigned int voltage)
+{
+	int to;
+
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= voltage) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	switch (id) {
+	case pwm_b:
+		P_PWM_PWM_B = pwm_voltage_table[to][0];
+		break;
+
+	case pwm_d:
+		P_PWM_PWM_D = pwm_voltage_table[to][0];
+		break;
+	default:
+		break;
+	}
+	_udelay_(200);
+}
+
+void power_init(int mode)
+{
+	pwm_init(pwm_b);
+	pwm_init(pwm_d);
+	serial_puts("set vcck to ");
+	serial_put_dec(CONFIG_VCCK_INIT_VOLTAGE);
+	serial_puts(" mv\n");
+	pwm_set_voltage(pwm_b, CONFIG_VCCK_INIT_VOLTAGE);
+	serial_puts("set vddee to ");
+	serial_put_dec(CONFIG_VDDEE_INIT_VOLTAGE);
+	serial_puts(" mv\n");
+	pwm_set_voltage(pwm_d, CONFIG_VDDEE_INIT_VOLTAGE);
+}
diff --git a/board/amlogic/gxb_skt_v1/firmware/scp_task/dvfs_board.c b/board/amlogic/gxb_skt_v1/firmware/scp_task/dvfs_board.c
index 8476996..191c865 100644
--- a/board/amlogic/gxb_skt_v1/firmware/scp_task/dvfs_board.c
+++ b/board/amlogic/gxb_skt_v1/firmware/scp_task/dvfs_board.c
@@ -1,5 +1,5 @@
 
-static int pwm_voltage_table[][2] = {
+int pwm_voltage_table[][2] = {
 	{ 0x1c0000,  860},
 	{ 0x1b0001,  870},
 	{ 0x1a0002,  880},
@@ -152,5 +152,6 @@ void set_dvfs(unsigned int domain, unsigned int index)
 		P_PWM_PWM_B = pwm_voltage_table[cur][0];
 		_udelay(100);
 	}
+	_udelay(200);
 }
 
diff --git a/board/amlogic/gxb_skt_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxb_skt_v1/firmware/scp_task/pwr_ctrl.c
index 404da5c..b2bdf6e 100644
--- a/board/amlogic/gxb_skt_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxb_skt_v1/firmware/scp_task/pwr_ctrl.c
@@ -1,20 +1,111 @@
+/*p200/201	GPIOAO_2  powr on	:0, power_off	:1*/
+
+#define __SUSPEND_FIRMWARE__
+#include <config.h>
+#undef __SUSPEND_FIRMWARE__
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
 #ifdef CONFIG_CEC_WAKEUP
 #include <cec_tx_reg.h>
 #endif
+
 #include <gpio-gxbb.h>
 
+extern int pwm_voltage_table[31][2];
+
+#define P_PIN_MUX_REG3		(*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG7		(*((volatile unsigned *)(0xda834400 + (0x33 << 2))))
+
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+#define P_PWM_PWM_B		(*((volatile unsigned *)(0xc1100000 + (0x2155 << 2))))
+#define P_PWM_MISC_REG_CD	(*((volatile unsigned *)(0xc1100000 + (0x2196 << 2))))
+#define P_PWM_PWM_D		(*((volatile unsigned *)(0xc1100000 + (0x2195 << 2))))
+
+#define P_EE_TIMER_E		(*((volatile unsigned *)(0xc1100000 + (0x2662 << 2))))
+
+enum pwm_id {
+    pwm_a = 0,
+    pwm_b,
+    pwm_c,
+    pwm_d,
+    pwm_e,
+    pwm_f,
+};
+
+void pwm_set_voltage(unsigned int id, unsigned int voltage)
+{
+	int to;
+
+	uart_puts("set vddee to 0x");
+	uart_put_hex(voltage, 16);
+	uart_puts("mv\n");
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= voltage) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	switch (id) {
+	case pwm_b:
+		P_PWM_PWM_B = pwm_voltage_table[to][0];
+		break;
+
+	case pwm_d:
+		P_PWM_PWM_D = pwm_voltage_table[to][0];
+		break;
+	default:
+		break;
+	}
+	_udelay(200);
+}
+
+static void power_off_3v3(void)
+{
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<2, 0);
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<18, 1<<18);
+}
+static void power_on_3v3(void)
+{
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<2, 0);
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<18, 0);
+}
+
+/*p200/201	GPIOAO_4  powr on	:1, power_off	:0*/
+static void power_off_vcck(void)
+{
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<4, 0);
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<20, 0);
+}
+static void power_on_vcck(void)
+{
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<4, 0);
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<20, 1<<20);
+}
+
 static void power_off_at_clk81(void)
 {
+	power_off_3v3();
+	power_off_vcck();
+	pwm_set_voltage(pwm_d, CONFIG_VDDEE_SLEEP_VOLTAGE);	// reduce power
 }
 static void power_on_at_clk81(void)
 {
+	pwm_set_voltage(pwm_d, CONFIG_VDDEE_INIT_VOLTAGE);
+	power_on_vcck();
+	power_on_3v3();
 }
 
 static void power_off_at_24M(void)
 {
+	//LED gpioao_13
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<29, 0);
 }
 static void power_on_at_24M(void)
 {
+	aml_update_bits(AO_GPIO_O_EN_N, 1<<29, 1<<29);
 }
 
 static void power_off_at_32k(void)
@@ -28,24 +119,94 @@ void get_wakeup_source(void *response, unsigned int suspend_from)
 {
 	struct wakeup_info *p = (struct wakeup_info *)response;
 	unsigned val;
+	struct wakeup_gpio_info *gpio;
 
 	p->status = RESPONSE_OK;
-	val = REMOTE_WAKEUP_SRC;
+	val = (POWER_KEY_WAKEUP_SRC | AUTO_WAKEUP_SRC | REMOTE_WAKEUP_SRC);
+#ifdef CONFIG_BT_WAKEUP
+	val |= BT_WAKEUP_SRC;
+#endif
+
 #ifdef CONFIG_CEC_WAKEUP
 	if (suspend_from != SYS_POWEROFF)
 		val |= CEC_WAKEUP_SRC;
 #endif
+#ifdef CONFIG_WIFI_WAKEUP
+	if (suspend_from != SYS_POWEROFF)
+		val |= WIFI_WAKEUP_SRC;
+#endif
+
 	p->sources = val;
-	p->gpio_info_count = 0;
+
+	/* Power Key: AO_GPIO[3]*/
+	gpio = &(p->gpio_info[0]);
+	gpio->wakeup_id = POWER_KEY_WAKEUP_SRC;
+	gpio->gpio_in_idx = GPIOAO_3;
+	gpio->gpio_in_ao = 1;
+	gpio->gpio_out_idx = -1;
+	gpio->gpio_out_ao = -1;
+	gpio->irq = IRQ_AO_GPIO0_NUM;
+	gpio->trig_type = GPIO_IRQ_FALLING_EDGE;
+
+	/* BT Wakeup: IN: GPIOX[21], OUT: GPIOX[20]*/
+	gpio = &(p->gpio_info[1]);
+	gpio->wakeup_id = BT_WAKEUP;
+	gpio->gpio_in_idx = GPIOX_21;
+	gpio->gpio_in_ao = 0;
+	gpio->gpio_out_idx = GPIOX_20;
+	gpio->gpio_out_ao = 0;
+	gpio->irq = IRQ_GPIO0_NUM;
+	gpio->trig_type = GPIO_IRQ_FALLING_EDGE;
+
+#ifdef CONFIG_WIFI_WAKEUP
+	if (suspend_from != SYS_POWEROFF) {
+		/*WIFI Wakeup: IN: GPIOX[7], OUT: GPIOX[6]*/
+		gpio = &(p->gpio_info[2]);
+		gpio->wakeup_id = WIFI_WAKEUP;
+		gpio->gpio_in_idx = GPIOX_7;
+		gpio->gpio_in_ao = 0;
+		gpio->gpio_out_idx = GPIOX_6;
+		gpio->gpio_out_ao = 0;
+		gpio->irq = IRQ_GPIO1_NUM;
+		gpio->trig_type = GPIO_IRQ_FALLING_EDGE;
+	}
+#endif
+	if (suspend_from != SYS_POWEROFF)
+		p->gpio_info_count = 3;
+	else
+		p->gpio_info_count = 2;
+}
+
+void wakeup_timer_setup(void)
+{
+	/* 1ms resolution*/
+	unsigned value;
+	value = readl(P_ISA_TIMER_MUX);
+	value |= ((0x3<<0) | (0x1<<12) | (0x1<<16));
+	writel(value, P_ISA_TIMER_MUX);
+	writel(10, P_ISA_TIMERA);
+}
+void wakeup_timer_clear(void)
+{
+	unsigned value;
+	value = readl(P_ISA_TIMER_MUX);
+	value &= ~((0x1<<12) | (0x1<<16));
+	writel(value, P_ISA_TIMER_MUX);
 }
 
 static unsigned int detect_key(unsigned int suspend_from)
 {
 	int exit_reason = 0;
+	unsigned int time_out = readl(AO_DEBUG_REG2);
+	unsigned time_out_ms = time_out*100;
 	unsigned *irq = (unsigned *)SECURE_TASK_SHARE_IRQ;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 
 	/* setup wakeup resources*/
+	/*auto suspend: timerA 10ms resolution*/
+	if (time_out_ms != 0)
+		wakeup_timer_setup();
+
 	init_remote();
 #ifdef CONFIG_CEC_WAKEUP
 	if (hdmi_cec_func_config & 0x1) {
@@ -74,10 +235,47 @@ static unsigned int detect_key(unsigned int suspend_from)
 				cec_node_init();
 		break;
 #endif
+		case IRQ_TIMERA_NUM:
+			if (time_out_ms != 0)
+				time_out_ms--;
+			if (time_out_ms == 0) {
+				wakeup_timer_clear();
+				exit_reason = AUTO_WAKEUP;
+			}
+			break;
+
 		case IRQ_AO_IR_DEC_NUM:
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
 			break;
+		case IRQ_AO_GPIO0_NUM:
+			if ((readl(AO_GPIO_I) & (1<<3)) == 0)
+				exit_reason = POWER_KEY_WAKEUP;
+			break;
+#ifdef CONFIG_BT_WAKEUP
+		case IRQ_GPIO0_NUM:
+			if (!(readl(PREG_PAD_GPIO4_EN_N)
+					&(0x01 << 20)) &&
+					(readl(PREG_PAD_GPIO4_O)
+					& (0x01 << 20)) &&
+					!(readl(PREG_PAD_GPIO4_I)
+					& (0x01 << 21)))
+						exit_reason = BT_WAKEUP;
+			break;
+#endif
+#ifdef CONFIG_WIFI_WAKEUP
+		case IRQ_GPIO1_NUM:
+			if (suspend_from) {
+				if (!(readl(PREG_PAD_GPIO4_EN_N)
+						& (0x01 << 6)) &&
+						(readl(PREG_PAD_GPIO4_O)
+						& (0x01 << 6)) &&
+						!(readl(PREG_PAD_GPIO4_I)
+						& (0x01 << 7)))
+						exit_reason = WIFI_WAKEUP;
+			}
+			break;
+#endif
 		default:
 			break;
 		}
@@ -88,6 +286,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 			asm volatile("wfi");
 	} while (1);
 
+	wakeup_timer_clear();
 	return exit_reason;
 }
 
diff --git a/board/amlogic/gxl_p212_v1/firmware/scp_task/dvfs_board.c b/board/amlogic/gxl_p212_v1/firmware/scp_task/dvfs_board.c
index 2d421fb..f15c3e4 100644
--- a/board/amlogic/gxl_p212_v1/firmware/scp_task/dvfs_board.c
+++ b/board/amlogic/gxl_p212_v1/firmware/scp_task/dvfs_board.c
@@ -32,16 +32,13 @@ int pwm_voltage_table[][2] = {
 };
 
 struct scpi_opp_entry cpu_dvfs_tbl[] = {
-	DVFS( 100000000,  860),
-	DVFS( 250000000,  860),
-	DVFS( 500000000,  860),
-	DVFS( 667000000,  900),
-	DVFS(1000000000,  940),
-	DVFS(1200000000, 1020),
-	DVFS(1416000000, 1110),
-	DVFS(1536000000, 1110),
-	DVFS(1752000000, 1110),
-	DVFS(2016000000, 1110)
+	DVFS( 100000000,  860+50),
+	DVFS( 250000000,  860+50),
+	DVFS( 500000000,  860+50),
+	DVFS( 667000000,  900+50),
+	DVFS(1000000000,  940+50),
+	DVFS(1200000000, 1020+50),
+	DVFS(1512000000, 1110+30),
 };
 
 
diff --git a/board/amlogic/gxl_p212_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxl_p212_v1/firmware/scp_task/pwr_ctrl.c
index cacf297..e9ea4cb 100644
--- a/board/amlogic/gxl_p212_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxl_p212_v1/firmware/scp_task/pwr_ctrl.c
@@ -106,16 +106,15 @@ static void power_on_at_clk81(void)
 static void power_off_at_24M(void)
 {
 	/* LED GPIODV_24*/
-        // turn off power led
 	aml_update_bits(PREG_PAD_GPIO0_EN_N, 1 << 24, 0);
-	aml_update_bits(PREG_PAD_GPIO0_O, 1 << 24, 1 << 24);
+	aml_update_bits(PREG_PAD_GPIO0_O, 1 << 24, 0);
 }
 
 static void power_on_at_24M(void)
 {
-        // turn on power led
 	aml_update_bits(PREG_PAD_GPIO0_EN_N, 1 << 24, 0);
-	aml_update_bits(PREG_PAD_GPIO0_O, 1 << 24, 0);
+	aml_update_bits(PREG_PAD_GPIO0_O, 1 << 24, 1 << 24);
+
 }
 
 static void power_off_at_32k(void)
@@ -192,8 +191,8 @@ static unsigned int detect_key(unsigned int suspend_from)
 
 	/* setup wakeup resources*/
 	/*auto suspend: timerA 10ms resolution*/
-	//if (time_out_ms != 0)
-		//wakeup_timer_setup();
+	if (time_out_ms != 0)
+		wakeup_timer_setup();
 
 	init_remote();
 #ifdef CONFIG_CEC_WAKEUP
@@ -227,10 +226,10 @@ static unsigned int detect_key(unsigned int suspend_from)
 			irq[IRQ_TIMERA] = 0xFFFFFFFF;
 			if (time_out_ms != 0)
 				time_out_ms--;
-			//if (time_out_ms == 0) {
-			//	wakeup_timer_clear();
-			//	exit_reason = AUTO_WAKEUP;
-			//}
+			if (time_out_ms == 0) {
+				wakeup_timer_clear();
+				exit_reason = AUTO_WAKEUP;
+			}
 		}
 
 		if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
@@ -238,8 +237,8 @@ static unsigned int detect_key(unsigned int suspend_from)
 			ret = remote_detect_key();
 			if (ret == 1)
 				exit_reason = REMOTE_WAKEUP;
-                        //if (ret == 2)
-			//	exit_reason = REMOTE_CUS_WAKEUP;
+			if (ret == 2)
+				exit_reason = REMOTE_CUS_WAKEUP;
 		}
 
 		if (irq[IRQ_AO_GPIO0] == IRQ_AO_GPIO0_NUM) {
@@ -250,8 +249,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 		if (irq[IRQ_GPIO0] == IRQ_GPIO0_NUM) {
 			irq[IRQ_GPIO0] = 0xFFFFFFFF;
 			if (!(readl(PREG_PAD_GPIO4_I) & (0x01 << 18)))
-				//exit_reason = BT_WAKEUP;
-			uart_puts("get GPIO4 Input\n");
+				exit_reason = BT_WAKEUP;
 		}
 		if (exit_reason)
 			break;
diff --git a/board/amlogic/gxl_p212_v1/gxl_p212_v1.c b/board/amlogic/gxl_p212_v1/gxl_p212_v1.c
index f5d1700..19a9401 100644
--- a/board/amlogic/gxl_p212_v1/gxl_p212_v1.c
+++ b/board/amlogic/gxl_p212_v1/gxl_p212_v1.c
@@ -364,7 +364,7 @@ int board_init(void)
 	//set output mode
 	clrbits_le32(PREG_PAD_GPIO0_EN_N, (1 << 24));
 	//set output 1
-	clrbits_le32(PREG_PAD_GPIO0_O, (1 << 24));
+	setbits_le32(PREG_PAD_GPIO0_O, (1 << 24));
 
 	/*Power on GPIOAO_2 for VCC_5V*/
 	clrbits_le32(P_AO_GPIO_O_EN_N, ((1<<2)|(1<<18)));
@@ -488,6 +488,7 @@ int checkhw(char * name)
 const char * const _env_args_reserve_[] =
 {
 		"aml_dt",
+		"firstboot",
 
 		NULL//Keep NULL be last to tell END
 };
diff --git a/board/amlogic/gxl_skt_v1/firmware/scp_task/dvfs_board.c b/board/amlogic/gxl_skt_v1/firmware/scp_task/dvfs_board.c
index 58e4fa4..5bb5d27 100644
--- a/board/amlogic/gxl_skt_v1/firmware/scp_task/dvfs_board.c
+++ b/board/amlogic/gxl_skt_v1/firmware/scp_task/dvfs_board.c
@@ -32,17 +32,16 @@ int pwm_voltage_table[][2] = {
 };
 
 struct scpi_opp_entry cpu_dvfs_tbl[] = {
-	DVFS( 100000000,  860),
-	DVFS( 250000000,  860),
-	DVFS( 500000000,  880),
-	DVFS( 667000000,  920),
-	DVFS(1000000000,  960),
-	DVFS(1200000000, 1040),
-	DVFS(1296000000, 1080),
-	DVFS(1416000000, 1110),
-	DVFS(1536000000, 1110),
-	DVFS(1752000000, 1110),
-	DVFS(2016000000, 1110)
+	DVFS( 100000000,  860+50),
+	DVFS( 250000000,  860+50),
+	DVFS( 500000000,  860+50),
+	DVFS( 667000000,  900+50),
+	DVFS(1000000000,  940+50),
+	DVFS(1200000000, 1020+50),
+	DVFS(1416000000, 1110+30),
+	DVFS(1536000000, 1110+30),
+	DVFS(1752000000, 1110+30),
+	DVFS(2016000000, 1110+30)
 };
 
 
diff --git a/board/amlogic/gxl_skt_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxl_skt_v1/firmware/scp_task/pwr_ctrl.c
index 8275905..1ebd8d0 100644
--- a/board/amlogic/gxl_skt_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxl_skt_v1/firmware/scp_task/pwr_ctrl.c
@@ -1,20 +1,116 @@
+#define __SUSPEND_FIRMWARE__
+#include <config.h>
+#undef __SUSPEND_FIRMWARE__
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 #ifdef CONFIG_CEC_WAKEUP
 #include <cec_tx_reg.h>
 #endif
 #include <gpio-gxbb.h>
 
+extern int pwm_voltage_table[31][2];
+
+#define P_PIN_MUX_REG3		(*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG7		(*((volatile unsigned *)(0xda834400 + (0x33 << 2))))
+
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+#define P_PWM_PWM_B		(*((volatile unsigned *)(0xc1100000 + (0x2155 << 2))))
+#define P_PWM_MISC_REG_CD	(*((volatile unsigned *)(0xc1100000 + (0x2192 << 2))))
+#define P_PWM_PWM_D		(*((volatile unsigned *)(0xc1100000 + (0x2191 << 2))))
+
+#define P_EE_TIMER_E		(*((volatile unsigned *)(0xc1100000 + (0x2662 << 2))))
+#define ON 1
+#define OFF 0
+enum pwm_id {
+    pwm_a = 0,
+    pwm_b,
+    pwm_c,
+    pwm_d,
+    pwm_e,
+    pwm_f,
+};
+
+void pwm_set_voltage(unsigned int id, unsigned int voltage)
+{
+	int to;
+
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= voltage) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	switch (id) {
+	case pwm_b:
+		uart_puts("set vddee to 0x");
+		uart_put_hex(pwm_voltage_table[to][1], 16);
+		uart_puts("mv\n");
+		P_PWM_PWM_B = pwm_voltage_table[to][0];
+		break;
+
+	case pwm_d:
+		uart_puts("set vcck to 0x");
+		uart_put_hex(pwm_voltage_table[to][1], 16);
+		uart_puts("mv\n");
+		P_PWM_PWM_D = pwm_voltage_table[to][0];
+		break;
+	default:
+		break;
+	}
+	_udelay(200);
+}
+/*GPIOH_3*/
+static void hdmi_5v_ctrl(unsigned int ctrl)
+{
+	if (ctrl == ON) {
+		/* VCC5V ON GPIOH_3 output mode*/
+		aml_update_bits(PREG_PAD_GPIO1_EN_N, 1 << 23, 0);
+	} else {
+		/* VCC5V OFF GPIOH_3 input mode*/
+		aml_update_bits(PREG_PAD_GPIO1_EN_N, 1 << 23, 1 << 23);
+	}
+}
+/*GPIODV_25*/
+static void vcck_ctrl(unsigned int ctrl)
+{
+	if (ctrl == ON) {
+		aml_update_bits(PREG_PAD_GPIO0_EN_N, 1 << 25, 0);
+		aml_update_bits(PREG_PAD_GPIO0_O, 1 << 25, 1 << 25);
+		/* after power on vcck, should init vcck*/
+		_udelay(5000);
+		pwm_set_voltage(pwm_b, CONFIG_VCCK_INIT_VOLTAGE);
+	} else {
+		aml_update_bits(PREG_PAD_GPIO0_EN_N, 1 << 25, 0);
+		aml_update_bits(PREG_PAD_GPIO0_O, 1 << 25, 0);
+	}
+}
+
 static void power_off_at_clk81(void)
 {
+	hdmi_5v_ctrl(OFF);
+	vcck_ctrl(OFF);
+	pwm_set_voltage(pwm_d, CONFIG_VDDEE_SLEEP_VOLTAGE);	// reduce power
 }
 static void power_on_at_clk81(void)
 {
+	pwm_set_voltage(pwm_d, CONFIG_VDDEE_INIT_VOLTAGE);
+	vcck_ctrl(ON);
+	hdmi_5v_ctrl(ON);
 }
 
 static void power_off_at_24M(void)
 {
+	/* LED GPIODV_24*/
+	aml_update_bits(PREG_PAD_GPIO0_EN_N, 1 << 24, 0);
+	aml_update_bits(PREG_PAD_GPIO0_O, 1 << 24, 0);
 }
 static void power_on_at_24M(void)
 {
+	aml_update_bits(PREG_PAD_GPIO0_EN_N, 1 << 24, 0);
+	aml_update_bits(PREG_PAD_GPIO0_O, 1 << 24, 1 << 24);
+
 }
 
 static void power_off_at_32k(void)
@@ -28,24 +124,70 @@ void get_wakeup_source(void *response, unsigned int suspend_from)
 {
 	struct wakeup_info *p = (struct wakeup_info *)response;
 	unsigned val;
+	struct wakeup_gpio_info *gpio;
 
 	p->status = RESPONSE_OK;
-	val = REMOTE_WAKEUP_SRC;
+	p->gpio_info_count = 0;
+	val = (POWER_KEY_WAKEUP_SRC | AUTO_WAKEUP_SRC | REMOTE_WAKEUP_SRC |
+	       BT_WAKEUP_SRC);
 #ifdef CONFIG_CEC_WAKEUP
 	if (suspend_from != SYS_POWEROFF)
 		val |= CEC_WAKEUP_SRC;
 #endif
 	p->sources = val;
-	p->gpio_info_count = 0;
-}
 
+	/* Power Key: AO_GPIO[2]*/
+	gpio = &(p->gpio_info[0]);
+	gpio->wakeup_id = POWER_KEY_WAKEUP_SRC;
+	gpio->gpio_in_idx = GPIOAO_2;
+	gpio->gpio_in_ao = 1;
+	gpio->gpio_out_idx = -1;
+	gpio->gpio_out_ao = -1;
+	gpio->irq = IRQ_AO_GPIO0_NUM;
+	gpio->trig_type = GPIO_IRQ_FALLING_EDGE;
+	p->gpio_info_count ++;
+
+	gpio = &(p->gpio_info[1]);
+	gpio->wakeup_id = BT_WAKEUP_SRC;
+	gpio->gpio_in_idx = GPIOX_18;
+	gpio->gpio_in_ao = 0;
+	gpio->gpio_out_idx = -1;
+	gpio->gpio_out_ao = -1;
+	gpio->irq = IRQ_GPIO0_NUM;
+	gpio->trig_type	= GPIO_IRQ_FALLING_EDGE;
+	p->gpio_info_count ++;
+
+}
+void wakeup_timer_setup(void)
+{
+	/* 1ms resolution*/
+	unsigned value;
+	value = readl(P_ISA_TIMER_MUX);
+	value |= ((0x3<<0) | (0x1<<12) | (0x1<<16));
+	writel(value, P_ISA_TIMER_MUX);
+	/*10ms generate an interrupt*/
+	writel(10, P_ISA_TIMERA);
+}
+void wakeup_timer_clear(void)
+{
+	unsigned value;
+	value = readl(P_ISA_TIMER_MUX);
+	value &= ~((0x1<<12) | (0x1<<16));
+	writel(value, P_ISA_TIMER_MUX);
+}
 static unsigned int detect_key(unsigned int suspend_from)
 {
 	int exit_reason = 0;
+	unsigned int time_out = readl(AO_DEBUG_REG2);
+	unsigned time_out_ms = time_out*100;
 	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 
 	/* setup wakeup resources*/
+	/*auto suspend: timerA 10ms resolution*/
+	if (time_out_ms != 0)
+		wakeup_timer_setup();
+
 	init_remote();
 #ifdef CONFIG_CEC_WAKEUP
 	if (hdmi_cec_func_config & 0x1) {
@@ -74,17 +216,37 @@ static unsigned int detect_key(unsigned int suspend_from)
 				cec_node_init();
 		}
 #endif
+		if (irq[IRQ_TIMERA] == IRQ_TIMERA_NUM) {
+			irq[IRQ_TIMERA] = 0xFFFFFFFF;
+			if (time_out_ms != 0)
+				time_out_ms--;
+			if (time_out_ms == 0) {
+				wakeup_timer_clear();
+				exit_reason = AUTO_WAKEUP;
+			}
+		}
 	if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
 		irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
 	}
+		if (irq[IRQ_AO_GPIO0] == IRQ_AO_GPIO0_NUM) {
+			irq[IRQ_AO_GPIO0] = 0xFFFFFFFF;
+			if ((readl(AO_GPIO_I) & (1<<2)) == 0)
+				exit_reason = POWER_KEY_WAKEUP;
+		}
+		if (irq[IRQ_GPIO0] == IRQ_GPIO0_NUM) {
+			irq[IRQ_GPIO0] = 0xFFFFFFFF;
+			if (!(readl(PREG_PAD_GPIO4_I) & (0x01 << 18)))
+				exit_reason = BT_WAKEUP;
+		}
 		if (exit_reason)
 			break;
 		else
 			asm volatile("wfi");
 	} while (1);
 
+	wakeup_timer_clear();
 	return exit_reason;
 }
 
diff --git a/board/amlogic/gxm_q200_v1/firmware/scp_task/dvfs_board.c b/board/amlogic/gxm_q200_v1/firmware/scp_task/dvfs_board.c
index 1184686..9e6a648 100644
--- a/board/amlogic/gxm_q200_v1/firmware/scp_task/dvfs_board.c
+++ b/board/amlogic/gxm_q200_v1/firmware/scp_task/dvfs_board.c
@@ -38,10 +38,7 @@ struct scpi_opp_entry cpu_dvfs_tbl[] = {
 	DVFS( 667000000,  900+50),
 	DVFS(1000000000,  940+50),
 	DVFS(1200000000, 1020+50),
-	DVFS(1416000000, 1110+30),
-	DVFS(1536000000, 1110+30),
-	DVFS(1752000000, 1110+30),
-	DVFS(2016000000, 1110+30)
+	DVFS(1512000000, 1110+30),
 };
 struct scpi_opp_entry vlittle_dvfs_tbl[] = {
 	DVFS( 100000000,  860+50),
diff --git a/board/amlogic/gxm_q200_v1/gxm_q200_v1.c b/board/amlogic/gxm_q200_v1/gxm_q200_v1.c
index 44ac088..ca68f64 100644
--- a/board/amlogic/gxm_q200_v1/gxm_q200_v1.c
+++ b/board/amlogic/gxm_q200_v1/gxm_q200_v1.c
@@ -452,3 +452,12 @@ phys_size_t get_effective_memsize(void)
 	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
 #endif
 }
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxm_q201_v1/firmware/scp_task/dvfs_board.c b/board/amlogic/gxm_q201_v1/firmware/scp_task/dvfs_board.c
index 1184686..9e6a648 100644
--- a/board/amlogic/gxm_q201_v1/firmware/scp_task/dvfs_board.c
+++ b/board/amlogic/gxm_q201_v1/firmware/scp_task/dvfs_board.c
@@ -38,10 +38,7 @@ struct scpi_opp_entry cpu_dvfs_tbl[] = {
 	DVFS( 667000000,  900+50),
 	DVFS(1000000000,  940+50),
 	DVFS(1200000000, 1020+50),
-	DVFS(1416000000, 1110+30),
-	DVFS(1536000000, 1110+30),
-	DVFS(1752000000, 1110+30),
-	DVFS(2016000000, 1110+30)
+	DVFS(1512000000, 1110+30),
 };
 struct scpi_opp_entry vlittle_dvfs_tbl[] = {
 	DVFS( 100000000,  860+50),
diff --git a/board/amlogic/gxm_q201_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxm_q201_v1/firmware/scp_task/pwr_ctrl.c
index 6956f81..4330662 100644
--- a/board/amlogic/gxm_q201_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxm_q201_v1/firmware/scp_task/pwr_ctrl.c
@@ -150,9 +150,11 @@ void get_wakeup_source(void *response, unsigned int suspend_from)
 	struct wakeup_info *p = (struct wakeup_info *)response;
 	unsigned val;
 	struct wakeup_gpio_info *gpio;
-
+	p->gpio_info_count = 0;
 	p->status = RESPONSE_OK;
-	val = (POWER_KEY_WAKEUP_SRC | AUTO_WAKEUP_SRC | REMOTE_WAKEUP_SRC);
+	//val = (POWER_KEY_WAKEUP_SRC | AUTO_WAKEUP_SRC | REMOTE_WAKEUP_SRC);
+	val = (POWER_KEY_WAKEUP_SRC | AUTO_WAKEUP_SRC | REMOTE_WAKEUP_SRC |
+	       BT_WAKEUP_SRC);
 #ifdef CONFIG_CEC_WAKEUP
 	if (suspend_from != SYS_POWEROFF)
 		val |= CEC_WAKEUP_SRC;
@@ -169,7 +171,18 @@ void get_wakeup_source(void *response, unsigned int suspend_from)
 	gpio->irq = IRQ_AO_GPIO0_NUM;
 	gpio->trig_type = GPIO_IRQ_FALLING_EDGE;
 
-	p->gpio_info_count = 1;
+	//p->gpio_info_count = 1;
+	p->gpio_info_count ++;
+
+	gpio = &(p->gpio_info[1]);
+	gpio->wakeup_id = BT_WAKEUP_SRC;
+	gpio->gpio_in_idx = GPIOX_18;
+	gpio->gpio_in_ao = 0;
+	gpio->gpio_out_idx = -1;
+	gpio->gpio_out_ao = -1;
+	gpio->irq = IRQ_GPIO0_NUM;
+	gpio->trig_type	= GPIO_IRQ_RISING_EDGE;
+	p->gpio_info_count ++;
 }
 void wakeup_timer_setup(void)
 {
@@ -255,6 +268,10 @@ static unsigned int detect_key(unsigned int suspend_from)
 			if ((readl(AO_GPIO_I) & (1<<2)) == 0)
 				exit_reason = POWER_KEY_WAKEUP;
 		}
+		if (irq[IRQ_GPIO0] == IRQ_GPIO0_NUM) {
+		    irq[IRQ_GPIO0] = 0xFFFFFFFF;
+			if ((readl(PREG_PAD_GPIO4_I) & (0x01 << 18)))
+			    exit_reason = BT_WAKEUP;}
 		if (exit_reason)
 			break;
 		else
diff --git a/board/amlogic/gxm_q201_v1/firmware/timing.c b/board/amlogic/gxm_q201_v1/firmware/timing.c
index 5537239..0f17a7a 100644
--- a/board/amlogic/gxm_q201_v1/firmware/timing.c
+++ b/board/amlogic/gxm_q201_v1/firmware/timing.c
@@ -22,7 +22,7 @@
 #include <asm/arch/ddr_define.h>
 
 /* DDR freq range */
-#define CONFIG_DDR_CLK_LOW  375
+#define CONFIG_DDR_CLK_LOW  20
 #define CONFIG_DDR_CLK_HIGH 1500
 /* DON'T OVER THESE RANGE */
 #if (CONFIG_DDR_CLK < CONFIG_DDR_CLK_LOW) || (CONFIG_DDR_CLK > CONFIG_DDR_CLK_HIGH)
@@ -94,11 +94,12 @@
 #define CFG_DDR_ODT  DDR4_ODT_60OHM //useless, no effect
 #endif
 
-#define CFG_DDR4_DRV  DDR4_DRV_34OHM//DDR4_DRV_48OHM //ddr4 driver use this one
-#define CFG_DDR4_ODT  DDR4_ODT_60OHM //ddr4 driver use this one
-#define CONFIG_SOC_VREF       0 //0 //0  is auto --70 ---range 44.07---88.04   %
-#define CONFIG_DRAM_VREF     0 //77 //0 //0  is auto ---70 --range -- 60---92.50    %
-
+#define CFG_DDR4_DRV  DDR4_DRV_48OHM//DDR4_DRV_48OHM //ddr4 driver use this one
+#define CFG_DDR4_ODT DDR4_ODT_60OHM// DDR4_ODT_80OHM //ddr4 driver use this one
+#define CONFIG_SOC_VREF      0// (738/12) //0 //0  is auto --70 ---range 44.07---88.04   %
+#define CONFIG_DRAM_VREF   0// (810/12) // 0 //77 //0 //0  is auto ---70 --range -- 45---92.50    %
+//#define CONFIG_ZQ_VREF   715/15//  60//0 //(50) % //tune ddr4 ,ddr3 use 0
+#define CONFIG_ZQ_VREF   51//60 //700/12//  60//0 //(50) % //tune ddr4 ,ddr3 use 0
 /*
  * these parameters are corresponding to the pcb layout,
  * please don't enable this function unless these signals
@@ -492,12 +493,17 @@ ddr_set_t __ddr_setting = {
 	//.t_pub_zq0pr			= 0x7b,   //PUB ZQ0PR
 	//.t_pub_zq1pr			= 0x7b,   //PUB ZQ1PR
 	//.t_pub_zq2pr			= 0x7b,   //PUB ZQ2PR
-	//.t_pub_zq3pr			= 0x7b,   //PUB ZQ3PR
-	.t_pub_zq0pr			= 0x59959,   //PUB ZQ0PR, 0x5aa59,0x59959,  0x58859,
-	.t_pub_zq1pr			= 0x3f94f,   //PUB ZQ1PR//0x3f95d, 0x4f95d,
-	.t_pub_zq2pr			= 0x3f94f,   //PUB ZQ2PR//0x3f95d, 0x4f95d,
+	//.t_pub_zq3pr			= 0x7b,   //PUB ZQ3PR  zqvref 0x13
+	//.t_pub_zq0pr			= 0x5aa59,   //PUB ZQ0PR, 0x5aa59,0x59959,  0x58859,  //99drriver s912 ddr4 maybe 950m is bad
+	//.t_pub_zq1pr			= 0x3f95d,   //PUB ZQ1PR//0x3f95d, 0x4f95d,
+	//.t_pub_zq2pr			= 0x3f95d,   //PUB ZQ2PR//0x3f95d, 0x4f95d,
 	.t_pub_zq3pr			= 0x1dd1d,   //PUB ZQ3PR
 
+	.t_pub_zq0pr			= 0x0000bf59,   //PUB ZQ0PR, 0x5aa59,0x59959,  0x58859,  //99drriver s912 ddr4 maybe 950m is bad
+	.t_pub_zq1pr			= 0x0002fc5d,   //PUB ZQ1PR//0x3f95d, 0x4f95d,
+	.t_pub_zq2pr			= 0x0002fc5d,   //PUB ZQ2PR//0x3f95d, 0x4f95d,
+	//.t_pub_zq3pr			= 0xf5f95d,   //PUB ZQ3PR
+
 	/* pctl0 defines */
 	/* pctl1 use same define as pctl0 */
 	.t_pctl0_1us_pck		= CONFIG_DDR_CLK / 2,   //PCTL TOGCNT1U
@@ -506,7 +512,7 @@ ddr_set_t __ddr_setting = {
 	.t_pctl0_rsth_us		= 2,   //PCTL TRSTH
 	.t_pctl0_mcfg			= 0XA2F01,   //PCTL MCFG default 1T
 	//.t_pctl0_mcfg1			= 0X80000000,  //PCTL MCFG1
-	.t_pctl0_mcfg1			=  0, //[B10,B9,B8] tfaw_cfg_offset
+	.t_pctl0_mcfg1			= 0, //[B10,B9,B8] tfaw_cfg_offset
 								//tFAW= (4 + MCFG.tfaw_cfg)*tRRD - tfaw_cfg_offset,  //PCTL MCFG1
 	.t_pctl0_scfg			= 0xF01,   //PCTL SCFG
 	.t_pctl0_sctl			= 0x1,   //PCTL SCTL
@@ -532,30 +538,33 @@ ddr_set_t __ddr_setting = {
 	.t_pctl0_dfiodtcfg1		= (0x0 | (0x6 << 16)),
 
 	.t_pctl0_dfilpcfg0		= ( 1 | (3 << 4) | (1 << 8) | (13 << 12) | (7 <<16) | (1 <<24) | ( 3 << 28)),
-	//.t_pub_acbdlr0		= 0x1a,
-	//.t_pub_aclcdlr		= 0x30,//0x18,   ///1t  ,if 2t can add some value
-	//.t_pub_acbdlr3		= 0xa,//0xa,  //cs
-	.t_pub_acbdlr0			= 0x0,
-	.t_pub_aclcdlr			= 0x10,//0x18,   ///1t  ,if 2t can add some value
-	.t_pub_acbdlr3			= 0,//0xa,  //cs
-
+	.t_pub_acbdlr0			= 0x28,
+	.t_pub_aclcdlr			= 0x38,//0x18,   ///1t  ,if 2t can add some value
+	.t_pub_acbdlr3			= 0x18,//0xa,  //cs
+	//.t_pub_acbdlr0		= 0x0,
+	//.t_pub_aclcdlr		= 0x10,//0x18,   ///1t  ,if 2t can add some value
+	//.t_pub_acbdlr3		= 0x14,//0xa,  //cs
+	.t_pub_soc_vref_dram_vref =((((CONFIG_SOC_VREF<45)?(0):((((CONFIG_SOC_VREF*1000-44070)/698)>0X3F)?(0X3F):(((CONFIG_SOC_VREF*1000-44070)/698))))<<8)|(
+	(((CONFIG_DRAM_VREF))<45)?(0):((((CONFIG_DRAM_VREF))<61)?((((((CONFIG_DRAM_VREF*1000-45000)/650)>0X32)?(0X32):(((CONFIG_DRAM_VREF*1000-45000)/650)))|(1<<6))):
+	((((CONFIG_DRAM_VREF*1000-60000)/650)>0X32)?(0X32):(((CONFIG_DRAM_VREF*1000-60000)/650)))))),
+	.t_pub_mr[7]	= ((CONFIG_ZQ_VREF<45)?(0):((((CONFIG_ZQ_VREF*1000-44070)/698)>0X3F)?(0X3F):(((CONFIG_ZQ_VREF*1000-44070)/698)))) ,//jiaxing use for tune zq vref 20160608
 	.ddr_func				= DDR_FUNC, /* ddr func demo 2016.01.26 */
 
 	.wr_adj_per 			= {
 							[0] = 100,
 							[1] = 100,
-							[2] = 100,
-							[3] = 100,
-							[4] = 100,
-							[5] = 100,
+							[2] = 105,
+							[3] = 105,
+							[4] = 105,
+							[5] = 105,
 							},
 	.rd_adj_per				= {
 							[0] = 100,
 							[1] = 100,
-							[2] = 100,
-							[3] = 100,
-							[4] = 100,
-							[5] = 100,},
+							[2] = 105,
+							[3] = 95,
+							[4] = 95,
+							[5] = 95,},
 };
 
 pll_set_t __pll_setting = {
diff --git a/board/amlogic/gxm_q201_v1/gxm_q201_v1.c b/board/amlogic/gxm_q201_v1/gxm_q201_v1.c
index 07d273f..5c1f6ee 100644
--- a/board/amlogic/gxm_q201_v1/gxm_q201_v1.c
+++ b/board/amlogic/gxm_q201_v1/gxm_q201_v1.c
@@ -510,6 +510,7 @@ int checkhw(char * name)
 const char * const _env_args_reserve_[] =
 {
 		"aml_dt",
+		"firstboot",
 
 		NULL//Keep NULL be last to tell END
 };
diff --git a/board/amlogic/gxm_skt_v1/gxm_skt_v1.c b/board/amlogic/gxm_skt_v1/gxm_skt_v1.c
index 44ac088..ca68f64 100644
--- a/board/amlogic/gxm_skt_v1/gxm_skt_v1.c
+++ b/board/amlogic/gxm_skt_v1/gxm_skt_v1.c
@@ -452,3 +452,12 @@ phys_size_t get_effective_memsize(void)
 	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
 #endif
 }
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxtvbb_9023_skt_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxtvbb_9023_skt_v1/firmware/scp_task/pwr_ctrl.c
index e9a8ade..56f095c 100644
--- a/board/amlogic/gxtvbb_9023_skt_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxtvbb_9023_skt_v1/firmware/scp_task/pwr_ctrl.c
@@ -80,7 +80,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 	int exit_reason = 0;
 	unsigned int time_out = readl(AO_DEBUG_REG2);
 	unsigned time_out_ms = time_out*100;
-	unsigned *irq = (unsigned *)SECURE_TASK_SHARE_IRQ;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 
 	/* setup wakeup resources*/
@@ -98,11 +98,11 @@ static unsigned int detect_key(unsigned int suspend_from)
 
 	/* *wakeup_en = 1;*/
 	do {
-		switch (*irq) {
 #ifdef CONFIG_CEC_WAKEUP
-		case IRQ_AO_CEC_NUM:
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
 			if (suspend_from == SYS_POWEROFF)
-				break;
+				continue;
 			if (cec_msg.log_addr) {
 				if (hdmi_cec_func_config & 0x1) {
 					cec_handler();
@@ -114,26 +114,23 @@ static unsigned int detect_key(unsigned int suspend_from)
 				}
 			} else if (hdmi_cec_func_config & 0x1)
 				cec_node_init();
-		break;
+		}
 #endif
-		case IRQ_TIMERA_NUM:
+		if (irq[IRQ_TIMERA] == IRQ_TIMERA_NUM) {
+			irq[IRQ_TIMERA] = 0xFFFFFFFF;
 			if (time_out_ms != 0)
 				time_out_ms--;
 			if (time_out_ms == 0) {
 				wakeup_timer_clear();
 				exit_reason = AUTO_WAKEUP;
 			}
-			break;
+		}
 
-		case IRQ_AO_IR_DEC_NUM:
+		if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+			irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
-			break;
-
-		default:
-			break;
 		}
-		*irq = 0xffffffff;
 		if (exit_reason)
 			break;
 		else
diff --git a/board/amlogic/gxtvbb_9023_skt_v1/gxtvbb_9023_skt_v1.c b/board/amlogic/gxtvbb_9023_skt_v1/gxtvbb_9023_skt_v1.c
index a833472..032fc67 100644
--- a/board/amlogic/gxtvbb_9023_skt_v1/gxtvbb_9023_skt_v1.c
+++ b/board/amlogic/gxtvbb_9023_skt_v1/gxtvbb_9023_skt_v1.c
@@ -653,3 +653,12 @@ int checkhw(char * name)
 	return 0;
 }
 #endif
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxtvbb_p300_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxtvbb_p300_v1/firmware/scp_task/pwr_ctrl.c
index 0dc3510..cc3a259 100644
--- a/board/amlogic/gxtvbb_p300_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxtvbb_p300_v1/firmware/scp_task/pwr_ctrl.c
@@ -307,7 +307,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 	int exit_reason = 0;
 	unsigned int time_out = readl(AO_DEBUG_REG2);
 	unsigned time_out_ms = time_out * 100;
-	unsigned *irq = (unsigned *)SECURE_TASK_SHARE_IRQ;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 	uart_puts("enter detect key\n");
 
@@ -337,9 +337,11 @@ static unsigned int detect_key(unsigned int suspend_from)
 
 	/* *wakeup_en = 1; */
 	do {
-		switch (*irq) {
 #ifdef CONFIG_CEC_WAKEUP
-		case IRQ_AO_CEC_NUM:
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
+			if (suspend_from == SYS_POWEROFF)
+				continue;
 			if (cec_msg.log_addr) {
 				if (hdmi_cec_func_config & 0x1) {
 					cec_handler();
@@ -351,34 +353,38 @@ static unsigned int detect_key(unsigned int suspend_from)
 				}
 			} else if (hdmi_cec_func_config & 0x1)
 				cec_node_init();
-			break;
+		}
 #endif
-		case IRQ_TIMERA_NUM:
+		if (irq[IRQ_TIMERA] == IRQ_TIMERA_NUM) {
+			irq[IRQ_TIMERA] = 0xFFFFFFFF;
 			if (time_out_ms != 0)
 				time_out_ms--;
 			if (time_out_ms == 0) {
 				wakeup_timer_clear();
 				exit_reason = AUTO_WAKEUP;
 			}
-			break;
+		}
 
-		case IRQ_AO_IR_DEC_NUM:
+		if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+			irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
-			break;
+		}
 
 #ifdef CONFIG_BT_WAKEUP
-		case IRQ_GPIO0_NUM:
+		if (irq[IRQ_GPIO0] == IRQ_GPIO0_NUM) {
+			irq[IRQ_GPIO0] = 0xFFFFFFFF;
 			if (!(readl(PREG_PAD_GPIO4_EN_N)
 			      & (0x01 << 20)) && (readl(PREG_PAD_GPIO4_O)
 						  & (0x01 << 20)) &&
 			    !(readl(PREG_PAD_GPIO4_I)
 			      & (0x01 << 21)))
 				exit_reason = BT_WAKEUP;
-			break;
+		}
 #endif
 #ifdef CONFIG_WIFI_WAKEUP
-		case IRQ_GPIO1_NUM:
+		if (irq[IRQ_GPIO1] == IRQ_GPIO1_NUM) {
+			irq[IRQ_GPIO1] = 0xFFFFFFFF;
 			if (suspend_from) {
 				if (!(readl(PREG_PAD_GPIO4_EN_N)
 				      & (0x01 << 6)) && (readl(PREG_PAD_GPIO4_O)
@@ -387,12 +393,8 @@ static unsigned int detect_key(unsigned int suspend_from)
 				      & (0x01 << 7)))
 					exit_reason = WIFI_WAKEUP;
 			}
-			break;
-#endif
-		default:
-			break;
 		}
-		*irq = 0xffffffff;
+#endif
 		if (exit_reason)
 			break;
 		else
diff --git a/board/amlogic/gxtvbb_p300_v1/gxtvbb_p300_v1.c b/board/amlogic/gxtvbb_p300_v1/gxtvbb_p300_v1.c
index 4c954ac..33b44ef 100644
--- a/board/amlogic/gxtvbb_p300_v1/gxtvbb_p300_v1.c
+++ b/board/amlogic/gxtvbb_p300_v1/gxtvbb_p300_v1.c
@@ -680,3 +680,12 @@ int checkhw(char * name)
 	return 0;
 }
 #endif
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxtvbb_p301_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxtvbb_p301_v1/firmware/scp_task/pwr_ctrl.c
index aadfe74..1479d37 100644
--- a/board/amlogic/gxtvbb_p301_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxtvbb_p301_v1/firmware/scp_task/pwr_ctrl.c
@@ -310,7 +310,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 	int exit_reason = 0;
 	unsigned int time_out = readl(AO_DEBUG_REG2);
 	unsigned time_out_ms = time_out * 100;
-	unsigned *irq = (unsigned *)SECURE_TASK_SHARE_IRQ;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 	uart_puts("enter detect key\n");
 
@@ -344,9 +344,11 @@ static unsigned int detect_key(unsigned int suspend_from)
 
 	/* *wakeup_en = 1; */
 	do {
-		switch (*irq) {
 #ifdef CONFIG_CEC_WAKEUP
-		case IRQ_AO_CEC_NUM:
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
+			if (suspend_from == SYS_POWEROFF)
+				continue;
 			if (cec_msg.log_addr) {
 				if (hdmi_cec_func_config & 0x1) {
 					cec_handler();
@@ -358,38 +360,43 @@ static unsigned int detect_key(unsigned int suspend_from)
 				}
 			} else if (hdmi_cec_func_config & 0x1)
 				cec_node_init();
-			break;
+		}
 #endif
-		case IRQ_TIMERA_NUM:
+		if (irq[IRQ_TIMERA] == IRQ_TIMERA_NUM) {
+			irq[IRQ_TIMERA] = 0xFFFFFFFF;
 			if (time_out_ms != 0)
 				time_out_ms--;
 			if (time_out_ms == 0) {
 				wakeup_timer_clear();
 				exit_reason = AUTO_WAKEUP;
 			}
-			break;
-		case IRQ_AO_TIMERA_NUM:
+		}
+		if (irq[IRQ_AO_TIMERA] == IRQ_AO_TIMERA_NUM) {
+			irq[IRQ_AO_TIMERA] = 0xFFFFFFFF;
 #ifdef CONFIG_AML_LED
 			pled_suspend_timer_proc();
 #endif
-			break;
-		case IRQ_AO_IR_DEC_NUM:
+		}
+		if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+			irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
-			break;
+		}
 
 #ifdef CONFIG_BT_WAKEUP
-		case IRQ_GPIO0_NUM:
+		if (irq[IRQ_GPIO0] == IRQ_GPIO0_NUM) {
+			irq[IRQ_GPIO0] = 0xFFFFFFFF;
 			if (!(readl(PREG_PAD_GPIO4_EN_N)
 			      & (0x01 << 20)) && (readl(PREG_PAD_GPIO4_O)
 						  & (0x01 << 20)) &&
 			    !(readl(PREG_PAD_GPIO4_I)
 			      & (0x01 << 21)))
 				exit_reason = BT_WAKEUP;
-			break;
+		}
 #endif
 #ifdef CONFIG_WIFI_WAKEUP
-		case IRQ_GPIO1_NUM:
+		if (irq[IRQ_GPIO1] == IRQ_GPIO1_NUM) {
+			irq[IRQ_GPIO1] = 0xFFFFFFFF;
 			if (suspend_from) {
 				if (!(readl(PREG_PAD_GPIO4_EN_N)
 				      & (0x01 << 6)) && (readl(PREG_PAD_GPIO4_O)
@@ -398,12 +405,8 @@ static unsigned int detect_key(unsigned int suspend_from)
 				      & (0x01 << 7)))
 					exit_reason = WIFI_WAKEUP;
 			}
-			break;
-#endif
-		default:
-			break;
 		}
-		*irq = 0xffffffff;
+#endif
 		if (exit_reason)
 			break;
 		else
diff --git a/board/amlogic/gxtvbb_p301_v1/gxtvbb_p301_v1.c b/board/amlogic/gxtvbb_p301_v1/gxtvbb_p301_v1.c
index a324fd4..199e769 100644
--- a/board/amlogic/gxtvbb_p301_v1/gxtvbb_p301_v1.c
+++ b/board/amlogic/gxtvbb_p301_v1/gxtvbb_p301_v1.c
@@ -25,6 +25,7 @@
 #include <environment.h>
 #include <fdt_support.h>
 #include <libfdt.h>
+#include <asm/cpu_id.h>
 #ifdef CONFIG_SYS_I2C_AML
 #include <aml_i2c.h>
 #include <asm/arch/secure_apb.h>
@@ -641,10 +642,12 @@ static int send_led_timer_data(void)
 }
 #endif
 
-#ifdef CONFIG_HDMI_UART_BOARD
-struct hdmi_uart_io {
+/*USE_HDMI_UART_FUNC*/
+#define HDMI_UART_PORT_NUM   3
+
+struct hdmi_uart_date_io {
 	char *power;
-	char *hpd;
+	char *scl;
 	volatile uint32_t * hdmi_sda_reg;
 	unsigned int hdmi_sda_bit;
 	volatile uint32_t * uart_tx_reg;
@@ -655,70 +658,100 @@ struct hdmi_uart_io {
 	unsigned int uart_rx_bit;
 };
 
-#define HDMI_UART_PORT_NUM   3
-struct hdmi_uart_io hdmi_uart_array[HDMI_UART_PORT_NUM+1]=
+struct hdmi_uart_date_io txl_hdmi_uart_date_io[HDMI_UART_PORT_NUM+1]=
+{
+	{"GPIOW_5" ,"GPIOW_7" ,P_PERIPHS_PIN_MUX_5,25,P_PERIPHS_PIN_MUX_5,13,P_PERIPHS_PIN_MUX_5 ,24 ,P_PERIPHS_PIN_MUX_5,12,},
+	{"GPIOW_9", "GPIOW_11",P_PERIPHS_PIN_MUX_5,21,P_PERIPHS_PIN_MUX_5,11,P_PERIPHS_PIN_MUX_5 ,20 ,P_PERIPHS_PIN_MUX_5,10,},
+	{"GPIOW_13","GPIOW_15",P_PERIPHS_PIN_MUX_5,17,P_PERIPHS_PIN_MUX_5,9, P_PERIPHS_PIN_MUX_5 ,16 ,P_PERIPHS_PIN_MUX_5,8,},
+	{NULL,      NULL,      0,                   0,P_AO_RTI_PIN_MUX_REG,12,0 ,                   0 ,P_AO_RTI_PIN_MUX_REG,11,},
+};
+
+struct hdmi_uart_date_io gxtvbb_hdmi_uart_date_io[HDMI_UART_PORT_NUM+1]=
 {
 	{"GPIOW_6" ,"GPIOW_5" ,P_PERIPHS_PIN_MUX_6 ,9  ,P_PERIPHS_PIN_MUX_10,1,P_PERIPHS_PIN_MUX_6 ,10 ,P_PERIPHS_PIN_MUX_6,11,},
 	{"GPIOW_10","GPIOW_9" ,P_PERIPHS_PIN_MUX_6 ,14 ,P_PERIPHS_PIN_MUX_10,2,P_PERIPHS_PIN_MUX_6 ,15 ,P_PERIPHS_PIN_MUX_6,16,},
 	{"GPIOW_14","GPIOW_13",P_PERIPHS_PIN_MUX_6 ,19 ,P_PERIPHS_PIN_MUX_10,3,P_PERIPHS_PIN_MUX_6 ,20 ,P_PERIPHS_PIN_MUX_6,21,},
 	{NULL,      NULL,      0,                   0  ,P_AO_RTI_PIN_MUX_REG,0,0 ,                   0 ,P_AO_RTI_PIN_MUX_REG,1,},
 };
-extern int gpio_direction_input(unsigned gpio);
-extern int gpio_get_value(unsigned gpio);
-extern int gpio_request(unsigned gpio, const char *label);
-extern int gpio_free(unsigned gpio);
-extern int gpio_lookup_name(const char *name, struct udevice **devp,
-		     unsigned int *offsetp, unsigned int *gpiop);
+
+struct hdmi_uart_det_io {
+	char *power;
+	char *scl;
+	volatile uint32_t * uart_det_power_reg;
+	unsigned int uart_det_power_bit;
+	unsigned int uart_det_power_need_level;
+	volatile uint32_t * uart_det_scl_reg;
+	unsigned int uart_det_scl_bit;
+	unsigned int uart_det_scl_need_level;
+};
+
+struct hdmi_uart_det_io txl_hdmi_uart_det_io[HDMI_UART_PORT_NUM]=
+{
+	{"GPIOW_5" , "GPIOW_7" ,  P_PREG_PAD_GPIO4_I , 5 , 0, P_PREG_PAD_GPIO4_I ,7 , 1,},
+	{"GPIOW_9",  "GPIOW_11",  P_PREG_PAD_GPIO4_I , 9 , 0, P_PREG_PAD_GPIO4_I ,11, 1,},
+	{"GPIOW_13", "GPIOW_15" , P_PREG_PAD_GPIO4_I , 13, 0, P_PREG_PAD_GPIO4_I ,15, 1,},
+};
+
+/* in gxtvbb,use hpd port as (txl)scl port */
+struct hdmi_uart_det_io gxtvbb_hdmi_uart_det_io[HDMI_UART_PORT_NUM]=
+{
+	{"GPIOW_6" ,"GPIOW_5" , P_PREG_PAD_GPIO0_I, 6 , 0, P_PREG_PAD_GPIO0_I ,5 , 1,},
+	{"GPIOW_10","GPIOW_9" , P_PREG_PAD_GPIO0_I, 10, 0, P_PREG_PAD_GPIO0_I ,9 , 1,},
+	{"GPIOW_14","GPIOW_13", P_PREG_PAD_GPIO0_I, 14, 0, P_PREG_PAD_GPIO0_I ,13, 1,},
+};
 
 static void init_hdmi_uart_board(void)
 {
-    unsigned int power_gpio,hpd_gpio;
 	int i=0;
-	int p_value=0,h_value=0;
+	int pwr_value=0,scl_value=0;
 	int flag=0;
+	struct hdmi_uart_date_io *hdmi_uart_date_io;
+	struct hdmi_uart_det_io  *hdmi_uart_det_io;
+
+	if (get_cpu_id().family_id <= MESON_CPU_MAJOR_ID_GXTVBB) {
+		hdmi_uart_det_io  = gxtvbb_hdmi_uart_det_io;
+		hdmi_uart_date_io = gxtvbb_hdmi_uart_date_io;
+		/*printf("choose gxtvbb board.\n");*/
+	} else {
+		hdmi_uart_det_io  = txl_hdmi_uart_det_io;
+		hdmi_uart_date_io = txl_hdmi_uart_date_io;
+		/*printf("choose txl board.\n");*/
+	}
 
 	for (i=0; i<HDMI_UART_PORT_NUM; i++) {
-        gpio_lookup_name(hdmi_uart_array[i].power, NULL, NULL, &power_gpio);
-		gpio_request(power_gpio, "cmd_gpio");
-	    gpio_direction_input(power_gpio);
-
-		p_value = gpio_get_value(power_gpio);
-		if (p_value == 0) {
-			gpio_lookup_name(hdmi_uart_array[i].hpd, NULL, NULL, &hpd_gpio);
-			gpio_request(hpd_gpio, "cmd_gpio");
-			gpio_direction_input(hpd_gpio);
-			h_value = gpio_get_value(hpd_gpio);
-			if (h_value == 1) {
-				flag = 1;
-				gpio_free(power_gpio);
-				gpio_free(hpd_gpio);
-				break;
-			}
-			gpio_free(hpd_gpio);
+		pwr_value = readl(hdmi_uart_det_io[i].uart_det_power_reg) >> hdmi_uart_det_io[i].uart_det_power_bit;
+		pwr_value &= 1;
+		scl_value = readl(hdmi_uart_det_io[i].uart_det_scl_reg) >> hdmi_uart_det_io[i].uart_det_scl_bit;
+		scl_value &= 1;
+
+		if ((pwr_value == hdmi_uart_det_io[i].uart_det_power_need_level)
+			&& (scl_value == hdmi_uart_det_io[i].uart_det_scl_need_level)) {
+			flag = 1;
+			break;
 		}
-        gpio_free(power_gpio);
 	}
 
 	if (flag == 1) {
-        /* clean default uart pinmux */
-        writel(readl(hdmi_uart_array[3].uart_tx_reg)&~(1 << hdmi_uart_array[3].uart_tx_bit),
-			(volatile void *)hdmi_uart_array[3].uart_tx_reg);
-        writel(readl(hdmi_uart_array[3].uart_rx_reg)&~(1 << hdmi_uart_array[3].uart_rx_bit),
-			(volatile void *)hdmi_uart_array[3].uart_rx_reg);
-
-        /* set hdmi_uart pinmux */
-		writel(readl(hdmi_uart_array[i].hdmi_sda_reg)&~(1 << hdmi_uart_array[i].hdmi_sda_bit),
-			(volatile void *)hdmi_uart_array[i].hdmi_sda_reg);
-		writel(readl(hdmi_uart_array[i].uart_tx_reg)|(1 << hdmi_uart_array[i].uart_tx_bit),
-			(volatile void *)hdmi_uart_array[i].uart_tx_reg);
-
-		writel(readl(hdmi_uart_array[i].hdmi_scl_reg)&~(1 << hdmi_uart_array[i].hdmi_scl_bit),
-			(volatile void *)hdmi_uart_array[i].hdmi_scl_reg);
-		writel(readl(hdmi_uart_array[i].uart_rx_reg)|(1 << hdmi_uart_array[i].uart_rx_bit),
-			(volatile void *)hdmi_uart_array[i].uart_rx_reg);
+		printf("switch to %d hdmirx_uart port\n",i);
+		/* clean default uart pinmux */
+		writel(readl(hdmi_uart_date_io[3].uart_tx_reg)&~(1 << hdmi_uart_date_io[3].uart_tx_bit),
+			(volatile void *)hdmi_uart_date_io[3].uart_tx_reg);
+		writel(readl(hdmi_uart_date_io[3].uart_rx_reg)&~(1 << hdmi_uart_date_io[3].uart_rx_bit),
+			(volatile void *)hdmi_uart_date_io[3].uart_rx_reg);
+
+		/* set hdmi_uart pinmux */
+		writel(readl(hdmi_uart_date_io[i].hdmi_sda_reg)&~(1 << hdmi_uart_date_io[i].hdmi_sda_bit),
+			(volatile void *)hdmi_uart_date_io[i].hdmi_sda_reg);
+		writel(readl(hdmi_uart_date_io[i].uart_tx_reg)|(1 << hdmi_uart_date_io[i].uart_tx_bit),
+			(volatile void *)hdmi_uart_date_io[i].uart_tx_reg);
+
+		writel(readl(hdmi_uart_date_io[i].hdmi_scl_reg)&~(1 << hdmi_uart_date_io[i].hdmi_scl_bit),
+			(volatile void *)hdmi_uart_date_io[i].hdmi_scl_reg);
+		writel(readl(hdmi_uart_date_io[i].uart_rx_reg)|(1 << hdmi_uart_date_io[i].uart_rx_bit),
+			(volatile void *)hdmi_uart_date_io[i].uart_rx_reg);
 	}
 }
-#endif
+/*endif*/
 
 int board_init(void)
 {
@@ -740,16 +773,25 @@ int board_init(void)
 	//run_command("mw 0xc8100024 BFFF3FDF", 0);
 	run_command("gpio s GPIOAO_5", 0);
 
-	#ifdef CONFIG_HDMI_UART_BOARD
-	printf("CONFIG_HDMI_UART_BOARD\n");
-	init_hdmi_uart_board();
-	#endif
 	return 0;
 }
 
 #ifdef CONFIG_BOARD_LATE_INIT
-int board_late_init(void){
+int board_late_init(void)
+{
 	int ret;
+	char* env;
+
+	/*USE_HDMI_UART_FUNC*/
+	env = getenv("hdmiuart_mode");
+	/*printf("hdmiuart_mode env:%s\n",env);*/
+	if (env) {
+		if (!strcmp(env,"open")) {
+		printf("CONFIG_HDMI_UART_BOARD\n");
+		init_hdmi_uart_board();
+		}
+	}
+	/*endif*/
 
 	//update env before anyone using it
 	run_command("get_rebootmode; echo reboot_mode=${reboot_mode}; "\
@@ -855,3 +897,12 @@ int checkhw(char * name)
 	return 0;
 }
 #endif
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxtvbb_p310_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxtvbb_p310_v1/firmware/scp_task/pwr_ctrl.c
index ab5e1e2..9cdeb97 100644
--- a/board/amlogic/gxtvbb_p310_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxtvbb_p310_v1/firmware/scp_task/pwr_ctrl.c
@@ -196,7 +196,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 	int exit_reason = 0;
 	unsigned int time_out = readl(AO_DEBUG_REG2);
 	unsigned time_out_ms = time_out*100;
-	unsigned *irq = (unsigned *)SECURE_TASK_SHARE_IRQ;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 
 	/* setup wakeup resources*/
@@ -214,9 +214,11 @@ static unsigned int detect_key(unsigned int suspend_from)
 
 	/* *wakeup_en = 1;*/
 	do {
-		switch (*irq) {
 #ifdef CONFIG_CEC_WAKEUP
-		case IRQ_AO_CEC_NUM:
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
+			if (suspend_from == SYS_POWEROFF)
+				continue;
 			if (cec_msg.log_addr) {
 				if (hdmi_cec_func_config & 0x1) {
 					cec_handler();
@@ -228,26 +230,23 @@ static unsigned int detect_key(unsigned int suspend_from)
 				}
 			} else if (hdmi_cec_func_config & 0x1)
 				cec_node_init();
-		break;
+		}
 #endif
-		case IRQ_TIMERA_NUM:
+		if (irq[IRQ_TIMERA] == IRQ_TIMERA_NUM) {
+			irq[IRQ_TIMERA] = 0xFFFFFFFF;
 			if (time_out_ms != 0)
 				time_out_ms--;
 			if (time_out_ms == 0) {
 				wakeup_timer_clear();
 				exit_reason = AUTO_WAKEUP;
 			}
-			break;
+		}
 
-		case IRQ_AO_IR_DEC_NUM:
+		if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+			irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
-			break;
-
-		default:
-			break;
 		}
-		*irq = 0xffffffff;
 		if (exit_reason)
 			break;
 		else
diff --git a/board/amlogic/gxtvbb_p310_v1/gxtvbb_p310_v1.c b/board/amlogic/gxtvbb_p310_v1/gxtvbb_p310_v1.c
index 2c91986..c20421a 100644
--- a/board/amlogic/gxtvbb_p310_v1/gxtvbb_p310_v1.c
+++ b/board/amlogic/gxtvbb_p310_v1/gxtvbb_p310_v1.c
@@ -662,3 +662,12 @@ int checkhw(char * name)
 	return 0;
 }
 #endif
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxtvbb_p311_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxtvbb_p311_v1/firmware/scp_task/pwr_ctrl.c
index ab5e1e2..9cdeb97 100644
--- a/board/amlogic/gxtvbb_p311_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxtvbb_p311_v1/firmware/scp_task/pwr_ctrl.c
@@ -196,7 +196,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 	int exit_reason = 0;
 	unsigned int time_out = readl(AO_DEBUG_REG2);
 	unsigned time_out_ms = time_out*100;
-	unsigned *irq = (unsigned *)SECURE_TASK_SHARE_IRQ;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 
 	/* setup wakeup resources*/
@@ -214,9 +214,11 @@ static unsigned int detect_key(unsigned int suspend_from)
 
 	/* *wakeup_en = 1;*/
 	do {
-		switch (*irq) {
 #ifdef CONFIG_CEC_WAKEUP
-		case IRQ_AO_CEC_NUM:
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
+			if (suspend_from == SYS_POWEROFF)
+				continue;
 			if (cec_msg.log_addr) {
 				if (hdmi_cec_func_config & 0x1) {
 					cec_handler();
@@ -228,26 +230,23 @@ static unsigned int detect_key(unsigned int suspend_from)
 				}
 			} else if (hdmi_cec_func_config & 0x1)
 				cec_node_init();
-		break;
+		}
 #endif
-		case IRQ_TIMERA_NUM:
+		if (irq[IRQ_TIMERA] == IRQ_TIMERA_NUM) {
+			irq[IRQ_TIMERA] = 0xFFFFFFFF;
 			if (time_out_ms != 0)
 				time_out_ms--;
 			if (time_out_ms == 0) {
 				wakeup_timer_clear();
 				exit_reason = AUTO_WAKEUP;
 			}
-			break;
+		}
 
-		case IRQ_AO_IR_DEC_NUM:
+		if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+			irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
-			break;
-
-		default:
-			break;
 		}
-		*irq = 0xffffffff;
 		if (exit_reason)
 			break;
 		else
diff --git a/board/amlogic/gxtvbb_p311_v1/gxtvbb_p311_v1.c b/board/amlogic/gxtvbb_p311_v1/gxtvbb_p311_v1.c
index 139e6c2..2612423 100644
--- a/board/amlogic/gxtvbb_p311_v1/gxtvbb_p311_v1.c
+++ b/board/amlogic/gxtvbb_p311_v1/gxtvbb_p311_v1.c
@@ -675,3 +675,12 @@ int checkhw(char * name)
 	return 0;
 }
 #endif
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/gxtvbb_skt_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxtvbb_skt_v1/firmware/scp_task/pwr_ctrl.c
index b845f8b..1f1e4ed 100644
--- a/board/amlogic/gxtvbb_skt_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxtvbb_skt_v1/firmware/scp_task/pwr_ctrl.c
@@ -279,7 +279,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 	int exit_reason = 0;
 	unsigned int time_out = readl(AO_DEBUG_REG2);
 	unsigned time_out_ms = time_out*100;
-	unsigned *irq = (unsigned *)SECURE_TASK_SHARE_IRQ;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 
 	/* setup wakeup resources */
@@ -308,11 +308,11 @@ static unsigned int detect_key(unsigned int suspend_from)
 
 	/* *wakeup_en = 1;*/
 	do {
-		switch (*irq) {
 #ifdef CONFIG_CEC_WAKEUP
-		case IRQ_AO_CEC_NUM:
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
 			if (suspend_from == SYS_POWEROFF)
-				break;
+				continue;
 			if (cec_msg.log_addr) {
 				if (hdmi_cec_func_config & 0x1) {
 					cec_handler();
@@ -324,34 +324,38 @@ static unsigned int detect_key(unsigned int suspend_from)
 				}
 			} else if (hdmi_cec_func_config & 0x1)
 				cec_node_init();
-		break;
+		}
 #endif
-		case IRQ_TIMERA_NUM:
+		if (irq[IRQ_TIMERA] == IRQ_TIMERA_NUM) {
+			irq[IRQ_TIMERA] = 0xFFFFFFFF;
 			if (time_out_ms != 0)
 				time_out_ms--;
 			if (time_out_ms == 0) {
 				wakeup_timer_clear();
 				exit_reason = AUTO_WAKEUP;
 			}
-			break;
+		}
 
-		case IRQ_AO_IR_DEC_NUM:
+		if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+			irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
-			break;
+		}
 
 #ifdef CONFIG_BT_WAKEUP
-		case IRQ_GPIO0_NUM:
+		if (irq[IRQ_GPIO0] == IRQ_GPIO0_NUM) {
+			irq[IRQ_GPIO0] = 0xFFFFFFFF;
 			if (!(readl(PREG_PAD_GPIO4_EN_N)
 			      & (0x01 << 20)) && (readl(PREG_PAD_GPIO4_O)
 						  & (0x01 << 20)) &&
 			    !(readl(PREG_PAD_GPIO4_I)
 			      & (0x01 << 21)))
 				exit_reason = BT_WAKEUP;
-			break;
+		}
 #endif
 #ifdef CONFIG_WIFI_WAKEUP
-		case IRQ_GPIO1_NUM:
+		if (irq[IRQ_GPIO1] == IRQ_GPIO1_NUM) {
+			irq[IRQ_GPIO1] = 0xFFFFFFFF;
 			if (suspend_from) {
 				if (!(readl(PREG_PAD_GPIO4_EN_N)
 				      & (0x01 << 6)) && (readl(PREG_PAD_GPIO4_O)
@@ -360,12 +364,8 @@ static unsigned int detect_key(unsigned int suspend_from)
 				      & (0x01 << 7)))
 					exit_reason = WIFI_WAKEUP;
 			}
-			break;
-#endif
-		default:
-			break;
 		}
-		*irq = 0xffffffff;
+#endif
 		if (exit_reason)
 			break;
 		else
diff --git a/board/amlogic/gxtvbb_t966_skt_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/gxtvbb_t966_skt_v1/firmware/scp_task/pwr_ctrl.c
index 6b9999a..a033341 100644
--- a/board/amlogic/gxtvbb_t966_skt_v1/firmware/scp_task/pwr_ctrl.c
+++ b/board/amlogic/gxtvbb_t966_skt_v1/firmware/scp_task/pwr_ctrl.c
@@ -81,7 +81,7 @@ static unsigned int detect_key(unsigned int suspend_from)
 	int exit_reason = 0;
 	unsigned int time_out = readl(AO_DEBUG_REG2);
 	unsigned time_out_ms = time_out*100;
-	unsigned *irq = (unsigned *)SECURE_TASK_SHARE_IRQ;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
 	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
 
 	/* setup wakeup resources*/
@@ -99,11 +99,11 @@ static unsigned int detect_key(unsigned int suspend_from)
 
 	/* *wakeup_en = 1;*/
 	do {
-		switch (*irq) {
 #ifdef CONFIG_CEC_WAKEUP
-		case IRQ_AO_CEC_NUM:
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
 			if (suspend_from == SYS_POWEROFF)
-				break;
+				continue;
 			if (cec_msg.log_addr) {
 				if (hdmi_cec_func_config & 0x1) {
 					cec_handler();
@@ -115,26 +115,48 @@ static unsigned int detect_key(unsigned int suspend_from)
 				}
 			} else if (hdmi_cec_func_config & 0x1)
 				cec_node_init();
-		break;
+		}
 #endif
-		case IRQ_TIMERA_NUM:
+		if (irq[IRQ_TIMERA] == IRQ_TIMERA_NUM) {
+			irq[IRQ_TIMERA] = 0xFFFFFFFF;
 			if (time_out_ms != 0)
 				time_out_ms--;
 			if (time_out_ms == 0) {
 				wakeup_timer_clear();
 				exit_reason = AUTO_WAKEUP;
 			}
-			break;
+		}
 
-		case IRQ_AO_IR_DEC_NUM:
+		if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+			irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
 			if (remote_detect_key())
 				exit_reason = REMOTE_WAKEUP;
-			break;
+		}
 
-		default:
-			break;
+#ifdef CONFIG_BT_WAKEUP
+		if (irq[IRQ_GPIO0] == IRQ_GPIO0_NUM) {
+			irq[IRQ_GPIO0] = 0xFFFFFFFF;
+			if (!(readl(PREG_PAD_GPIO4_EN_N)
+			      & (0x01 << 20)) && (readl(PREG_PAD_GPIO4_O)
+						  & (0x01 << 20)) &&
+			    !(readl(PREG_PAD_GPIO4_I)
+			      & (0x01 << 21)))
+				exit_reason = BT_WAKEUP;
 		}
-		*irq = 0xffffffff;
+#endif
+#ifdef CONFIG_WIFI_WAKEUP
+		if (irq[IRQ_GPIO1] == IRQ_GPIO1_NUM) {
+			irq[IRQ_GPIO1] = 0xFFFFFFFF;
+			if (suspend_from) {
+				if (!(readl(PREG_PAD_GPIO4_EN_N)
+				      & (0x01 << 6)) && (readl(PREG_PAD_GPIO4_O)
+							 & (0x01 << 6)) &&
+				    !(readl(PREG_PAD_GPIO4_I)
+				      & (0x01 << 7)))
+					exit_reason = WIFI_WAKEUP;
+			}
+		}
+#endif
 		if (exit_reason)
 			break;
 		else
diff --git a/board/amlogic/gxtvbb_t966_skt_v1/gxtvbb_t966_skt_v1.c b/board/amlogic/gxtvbb_t966_skt_v1/gxtvbb_t966_skt_v1.c
index a833472..032fc67 100644
--- a/board/amlogic/gxtvbb_t966_skt_v1/gxtvbb_t966_skt_v1.c
+++ b/board/amlogic/gxtvbb_t966_skt_v1/gxtvbb_t966_skt_v1.c
@@ -653,3 +653,12 @@ int checkhw(char * name)
 	return 0;
 }
 #endif
+
+const char * const _env_args_reserve_[] =
+{
+	"aml_dt",
+	"firstboot",
+
+	NULL//Keep NULL be last to tell END
+};
+
diff --git a/board/amlogic/txl_p320_v1/Kconfig b/board/amlogic/txl_p320_v1/Kconfig
new file mode 100644
index 0000000..4987595
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/Kconfig
@@ -0,0 +1,22 @@
+if TARGET_MESON_GXTV
+
+config SYS_CPU
+	string
+	default "armv8"
+
+config SYS_BOARD
+	string
+	default "txl_p320_v1"
+
+config SYS_VENDOR
+	string
+	default "amlogic"
+
+config SYS_SOC
+	string
+	default "txl"
+
+config SYS_CONFIG_NAME
+	default "txl_p320_v1"
+
+endif
diff --git a/board/amlogic/txl_p320_v1/Makefile b/board/amlogic/txl_p320_v1/Makefile
new file mode 100644
index 0000000..fb7f59a
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/Makefile
@@ -0,0 +1,3 @@
+
+obj-y += $(BOARD).o eth_setup.o
+obj-$(CONFIG_AML_LCD) += lcd.o
diff --git a/board/amlogic/txl_p320_v1/aml-user-key.sig b/board/amlogic/txl_p320_v1/aml-user-key.sig
new file mode 100644
index 0000000..e69de29
diff --git a/board/amlogic/txl_p320_v1/eth_setup.c b/board/amlogic/txl_p320_v1/eth_setup.c
new file mode 100644
index 0000000..882a37d
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/eth_setup.c
@@ -0,0 +1,51 @@
+
+/*
+ * board/amlogic/txl_skt_v1/eth_setup.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <asm/arch/eth_setup.h>
+/*
+ *
+ *setup eth device board socket
+ *
+ */
+struct eth_board_socket* eth_board_setup(char *name){
+	struct eth_board_socket* new_board;
+	new_board= (struct eth_board_socket*) malloc(sizeof(struct eth_board_socket));
+	if (NULL == new_board) return NULL;
+	if (name != NULL) {
+		new_board->name=(char*)malloc(strlen(name));
+		strncpy(new_board->name,name,strlen(name));
+	}else{
+		new_board->name="gxb";
+	}
+
+	new_board->eth_pinmux_setup=NULL ;
+	new_board->eth_clock_configure=NULL;
+	new_board->eth_hw_reset=NULL;
+	return new_board;
+}
+//pinmux   HHI_GCLK_MPEG1[bit 3]
+//
diff --git a/board/amlogic/txl_p320_v1/firmware/board_init.c b/board/amlogic/txl_p320_v1/firmware/board_init.c
new file mode 100644
index 0000000..96533c7
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/firmware/board_init.c
@@ -0,0 +1,86 @@
+
+/*
+ * board/amlogic/gxtvbb_p301_v1/firmware/board_init.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "power.c"
+
+/* bl2 customer code */
+
+#define PNL_PREG_PAD_GPIO1_EN_N           0x0f
+#define PNL_PREG_PAD_GPIO1_O              0x10
+#define PNL_PREG_PAD_GPIO1_I              0x11
+
+#define PNL_PREG_PAD_GPIO3_EN_N           0x15
+#define PNL_PREG_PAD_GPIO3_O              0x16
+#define PNL_PREG_PAD_GPIO3_I              0x17
+
+#define PNL_REG_BASE               (0xc8834400L)
+#define PNL_REG(reg)               (PNL_REG_BASE + (reg << 2))
+#define PNL_REG_R(_reg)            (*(volatile unsigned int *)PNL_REG(_reg))
+#define PNL_REG_W(_reg, _value)    *(volatile unsigned int *)PNL_REG(_reg) = (_value);
+void panel_power_init(void)
+{
+	serial_puts("init panel power\n");
+	/* GPIOZ_3 */
+	PNL_REG_W(PNL_PREG_PAD_GPIO3_O,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO3_O) & ~(1 << 3)));
+	PNL_REG_W(PNL_PREG_PAD_GPIO3_EN_N,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO3_EN_N) & ~(1 << 3)));
+	/* GPIOH_4/5/6/7 */
+	PNL_REG_W(PNL_PREG_PAD_GPIO1_O,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO1_O) & ~(0xf << 24)));
+	PNL_REG_W(PNL_PREG_PAD_GPIO1_EN_N,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO1_EN_N) & ~(0xf << 24)));
+
+	/* GPIOZ_2/6/7 */
+	PNL_REG_W(PNL_PREG_PAD_GPIO3_O,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO3_O) & ~((1 << 2) | (0x3 << 6))));
+	PNL_REG_W(PNL_PREG_PAD_GPIO3_EN_N,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO3_EN_N) & ~((1 << 2) | (0x3 << 6))));
+}
+
+#define SEC_AO_SEC_GP_CFG0			(0xda100000 + (0x90 << 2))
+static int check_is_ddr_inited(void)
+{
+	return ((readl(SEC_AO_SEC_GP_CFG0) >> 16) & 0xffff);
+}
+
+void board_init(void)
+{
+	power_init(0);
+
+	//only run once before ddr inited.
+	if (!check_is_ddr_inited()) {
+		/* dram 1.5V reset */
+		serial_puts("DRAM reset...\n");
+		/* power off ddr */
+		//aml_update_bits(P_AO_GPIO_O_EN_N, 1 << 3, 0);
+		//aml_update_bits(P_AO_GPIO_O_EN_N, 1 << 19, 0);
+		writel((readl(P_AO_GPIO_O_EN_N) & (~((1 << 3) | (1 << 19)))),P_AO_GPIO_O_EN_N);
+		/* need delay */
+		_udelay(40000);
+		/* power on ddr */
+		//aml_update_bits(P_AO_GPIO_O_EN_N, 1 << 3, 0);
+		//aml_update_bits(P_AO_GPIO_O_EN_N, 1 << 19, 1 << 19);
+		writel((readl(P_AO_GPIO_O_EN_N) | (1 << 19)),P_AO_GPIO_O_EN_N);
+	}
+
+	panel_power_init();
+}
diff --git a/board/amlogic/txl_p320_v1/firmware/power.c b/board/amlogic/txl_p320_v1/firmware/power.c
new file mode 100644
index 0000000..6cec314
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/firmware/power.c
@@ -0,0 +1,171 @@
+
+/*
+ * board/amlogic/txl_p321_v1/firmware/power.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "config.h"
+#include <serial.h>
+//#include <stdio.h>
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+static int pwm_voltage_table[][2] = {
+	{ 0x1c0000,  870},
+	{ 0x1b0001,  880},
+	{ 0x1a0002,  890},
+	{ 0x190003,  900},
+	{ 0x180004,  910},
+	{ 0x170005,  920},
+	{ 0x160006,  930},
+	{ 0x150007,  940},
+	{ 0x140008,  950},
+	{ 0x130009,  960},
+	{ 0x12000a,  970},
+	{ 0x11000b,  980},
+	{ 0x10000c,  990},
+	{ 0x0f000d, 1000},
+	{ 0x0e000e, 1010},
+	{ 0x0d000f, 1020},
+	{ 0x0c0010, 1030},
+	{ 0x0b0011, 1040},
+	{ 0x0a0012, 1050},
+	{ 0x090013, 1060},
+	{ 0x080014, 1070},
+	{ 0x070015, 1080},
+	{ 0x060016, 1090},
+	{ 0x050017, 1100},
+	{ 0x040018, 1110},
+	{ 0x030019, 1120},
+	{ 0x02001a, 1130},
+	{ 0x01001b, 1140},
+	{ 0x00001c, 1150}
+};
+
+
+#define P_PIN_MUX_REG3		(*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG4		(*((volatile unsigned *)(0xda834400 + (0x30 << 2))))
+
+#define P_PWM_PWM_A		(*((volatile unsigned *)(0xc1100000 + (0x2154 << 2))))
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+
+#define P_EE_TIMER_E		(*((volatile unsigned *)(0xc1100000 + (0x2662 << 2))))
+
+enum pwm_id {
+    pwm_a = 0,
+    pwm_ao_b,
+};
+
+unsigned int _get_time(void)
+{
+	return P_EE_TIMER_E;
+}
+
+void _udelay_(unsigned int us)
+{
+	unsigned int t0 = _get_time();
+
+	while (_get_time() - t0 <= us)
+		;
+}
+
+void pwm_init(int id)
+{
+	unsigned int reg;
+	int vol;
+
+	switch (id) {
+	case pwm_a:
+		reg = P_PWM_MISC_REG_AB;
+		reg &= ~(0x7f << 8);
+		reg |=  ((1 << 15) | (1 << 0));
+		P_PWM_MISC_REG_AB = reg;
+		/*
+		 * default set to max voltage
+		 */
+		P_PWM_PWM_A = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+		reg  = P_PIN_MUX_REG3;
+		reg &= ~(1 << 21);
+		P_PIN_MUX_REG3 = reg;
+
+		reg  = P_PIN_MUX_REG4;
+		reg &= ~(1 << 26);
+		reg |=  (1 << 17);
+		P_PIN_MUX_REG4 = reg;
+		break;
+
+	case pwm_ao_b:
+		reg = readl(AO_PWM_MISC_REG_AB);
+		reg &= ~(0x7f << 16);
+		reg |=  ((1 << 23) | (1 << 1));
+		writel(reg, AO_PWM_MISC_REG_AB);
+		/*
+		 * default set to max voltage
+		 */
+		vol = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+		writel(vol ,AO_PWM_PWM_B);
+		reg  = readl(AO_RTI_PIN_MUX_REG);
+		reg |= (1 << 3);
+		writel(reg, AO_RTI_PIN_MUX_REG);
+		break;
+	default:
+		break;
+	}
+
+	_udelay_(200);
+}
+
+void pwm_set_voltage(unsigned int id, unsigned int voltage)
+{
+	int to;
+
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= voltage) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	switch (id) {
+	case pwm_a:
+		P_PWM_PWM_A = pwm_voltage_table[to][0];
+		break;
+
+	case pwm_ao_b:
+		writel(pwm_voltage_table[to][0], AO_PWM_PWM_B);
+		break;
+	default:
+		break;
+	}
+	_udelay_(200);
+}
+
+void power_init(int mode)
+{
+	pwm_init(pwm_a);
+	pwm_init(pwm_ao_b);
+	serial_puts("set vcck to ");
+	serial_put_dec(CONFIG_VCCK_INIT_VOLTAGE);
+	serial_puts(" mv\n");
+	pwm_set_voltage(pwm_a, CONFIG_VCCK_INIT_VOLTAGE);
+	serial_puts("set vddee to ");
+	serial_put_dec(CONFIG_VDDEE_INIT_VOLTAGE);
+	serial_puts(" mv\n");
+	pwm_set_voltage(pwm_ao_b, CONFIG_VDDEE_INIT_VOLTAGE);
+}
diff --git a/board/amlogic/txl_p320_v1/firmware/scp_task/dvfs_board.c b/board/amlogic/txl_p320_v1/firmware/scp_task/dvfs_board.c
new file mode 100644
index 0000000..61d7b44
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/firmware/scp_task/dvfs_board.c
@@ -0,0 +1,189 @@
+
+/*
+ * board/amlogic/txl_p321_v1/firmware/scp_task/dvfs_board.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+static int pwm_voltage_table[][2] = {
+	{ 0x1c0000,  870},
+	{ 0x1b0001,  880},
+	{ 0x1a0002,  890},
+	{ 0x190003,  900},
+	{ 0x180004,  910},
+	{ 0x170005,  920},
+	{ 0x160006,  930},
+	{ 0x150007,  940},
+	{ 0x140008,  950},
+	{ 0x130009,  960},
+	{ 0x12000a,  970},
+	{ 0x11000b,  980},
+	{ 0x10000c,  990},
+	{ 0x0f000d, 1000},
+	{ 0x0e000e, 1010},
+	{ 0x0d000f, 1020},
+	{ 0x0c0010, 1030},
+	{ 0x0b0011, 1040},
+	{ 0x0a0012, 1050},
+	{ 0x090013, 1060},
+	{ 0x080014, 1070},
+	{ 0x070015, 1080},
+	{ 0x060016, 1090},
+	{ 0x050017, 1100},
+	{ 0x040018, 1110},
+	{ 0x030019, 1120},
+	{ 0x02001a, 1130},
+	{ 0x01001b, 1140},
+	{ 0x00001c, 1150}
+};
+
+struct scpi_opp_entry cpu_dvfs_tbl[] = {
+	DVFS( 100000000,  870+20),
+	DVFS( 250000000,  870+20),
+	DVFS( 500000000,  870+20),
+	DVFS( 667000000,  870+20),
+	DVFS(1000000000,  880+20),
+	DVFS(1200000000,  910+20),
+	DVFS(1296000000,  950+20),
+	DVFS(1416000000, 1020+20),
+	DVFS(1488000000, 1060+30),
+	DVFS(1536000000, 1090+30),
+};
+
+
+
+#define P_PIN_MUX_REG3         (*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG4         (*((volatile unsigned *)(0xda834400 + (0x30 << 2))))
+
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+#define P_PWM_PWM_A		(*((volatile unsigned *)(0xc1100000 + (0x2154 << 2))))
+
+
+enum pwm_id {
+	pwm_a = 0,
+};
+
+
+void pwm_init(int id)
+{
+	/*
+	 * TODO: support more pwm controllers, right now only support PWM_B
+	 */
+	unsigned int reg;
+	reg = P_PWM_MISC_REG_AB;
+	reg &= ~(0x7f << 8);
+	reg |=  ((1 << 15) | (1 << 0));
+	P_PWM_MISC_REG_AB = reg;
+	/*
+	 * default set to max voltage
+	 */
+	P_PWM_PWM_A = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+	reg  = P_PIN_MUX_REG3;
+	reg &= ~(1 << 21);
+	P_PIN_MUX_REG3 = reg;
+
+	reg  = P_PIN_MUX_REG4;
+	reg &= ~(1 << 26);		// clear PWM_VS
+	reg |=  (1 << 17);		// enable PWM_A
+	P_PIN_MUX_REG4 = reg;
+
+
+	_udelay(200);
+}
+
+int dvfs_get_voltage(void)
+{
+	int i = 0;
+	unsigned int reg_val;
+
+	reg_val = P_PWM_PWM_A;
+	for (i = 0; i < ARRAY_SIZE(pwm_voltage_table); i++) {
+		if (pwm_voltage_table[i][0] == reg_val) {
+			return i;
+		}
+	}
+	if (i >= ARRAY_SIZE(pwm_voltage_table)) {
+	    return -1;
+	}
+	return -1;
+}
+
+void set_dvfs(unsigned int domain, unsigned int index)
+{
+	int cur, to;
+	static int init_flag = 0;
+
+	if (!init_flag) {
+		pwm_init(pwm_a);
+		init_flag = 1;
+	}
+	cur = dvfs_get_voltage();
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= cpu_dvfs_tbl[index].volt_mv) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	if (cur < 0 || cur >=ARRAY_SIZE(pwm_voltage_table)) {
+		P_PWM_PWM_A = pwm_voltage_table[to][0];
+		_udelay(200);
+		return ;
+	}
+	while (cur != to) {
+		/*
+		 * if target step is far away from current step, don't change
+		 * voltage by one-step-done. You should change voltage step by
+		 * step to make sure voltage output is stable
+		 */
+		if (cur < to) {
+			if (cur < to - 3) {
+				cur += 3;
+			} else {
+				cur = to;
+			}
+		} else {
+			if (cur > to + 3) {
+				cur -= 3;
+			} else {
+				cur = to;
+			}
+		}
+		P_PWM_PWM_A = pwm_voltage_table[cur][0];
+		_udelay(100);
+	}
+	_udelay(200);
+}
+void get_dvfs_info_board(unsigned int domain,
+		unsigned char *info_out, unsigned int *size_out)
+{
+	unsigned int cnt;
+	cnt = ARRAY_SIZE(cpu_dvfs_tbl);
+
+	buf_opp.latency = 200;
+	buf_opp.count = cnt;
+	memset(&buf_opp.opp[0], 0,
+	       MAX_DVFS_OPPS * sizeof(struct scpi_opp_entry));
+
+	memcpy(&buf_opp.opp[0], cpu_dvfs_tbl ,
+		cnt * sizeof(struct scpi_opp_entry));
+
+	memcpy(info_out, &buf_opp, sizeof(struct scpi_opp));
+	*size_out = sizeof(struct scpi_opp);
+	return;
+}
diff --git a/board/amlogic/txl_p320_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/txl_p320_v1/firmware/scp_task/pwr_ctrl.c
new file mode 100644
index 0000000..3e559b0
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/firmware/scp_task/pwr_ctrl.c
@@ -0,0 +1,123 @@
+
+/*
+ * board/amlogic/txl_skt_v1/firmware/scp_task/pwr_ctrl.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifdef CONFIG_CEC_WAKEUP
+#include <cec_tx_reg.h>
+#endif
+#include <gpio-gxbb.h>
+
+static void power_off_at_clk81(void)
+{
+}
+static void power_on_at_clk81(void)
+{
+}
+
+static void power_off_at_24M(void)
+{
+}
+static void power_on_at_24M(void)
+{
+}
+
+static void power_off_at_32k(void)
+{
+}
+static void power_on_at_32k(void)
+{
+}
+
+void get_wakeup_source(void *response, unsigned int suspend_from)
+{
+	struct wakeup_info *p = (struct wakeup_info *)response;
+	unsigned val;
+
+	p->status = RESPONSE_OK;
+	val = REMOTE_WAKEUP_SRC;
+#ifdef CONFIG_CEC_WAKEUP
+	if (suspend_from != SYS_POWEROFF)
+		val |= CEC_WAKEUP_SRC;
+#endif
+	p->sources = val;
+	p->gpio_info_count = 0;
+}
+
+static unsigned int detect_key(unsigned int suspend_from)
+{
+	int exit_reason = 0;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
+	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
+
+	/* setup wakeup resources*/
+	init_remote();
+#ifdef CONFIG_CEC_WAKEUP
+	if (hdmi_cec_func_config & 0x1) {
+		remote_cec_hw_reset();
+		cec_node_init();
+	}
+#endif
+
+	/* *wakeup_en = 1;*/
+	do {
+#ifdef CONFIG_CEC_WAKEUP
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
+			if (suspend_from == SYS_POWEROFF)
+				continue;
+			if (cec_msg.log_addr) {
+				if (hdmi_cec_func_config & 0x1) {
+					cec_handler();
+					if (cec_msg.cec_power == 0x1) {
+						/*cec power key*/
+						exit_reason = CEC_WAKEUP;
+						break;
+					}
+				}
+			} else if (hdmi_cec_func_config & 0x1)
+				cec_node_init();
+		}
+#endif
+	if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+		irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
+			if (remote_detect_key())
+				exit_reason = REMOTE_WAKEUP;
+	}
+		if (exit_reason)
+			break;
+		else
+			asm volatile("wfi");
+	} while (1);
+
+	return exit_reason;
+}
+
+static void pwr_op_init(struct pwr_op *pwr_op)
+{
+	pwr_op->power_off_at_clk81 = power_off_at_clk81;
+	pwr_op->power_on_at_clk81 = power_on_at_clk81;
+	pwr_op->power_off_at_24M = power_off_at_24M;
+	pwr_op->power_on_at_24M = power_on_at_24M;
+	pwr_op->power_off_at_32k = power_off_at_32k;
+	pwr_op->power_on_at_32k = power_on_at_32k;
+
+	pwr_op->detect_key = detect_key;
+	pwr_op->get_wakeup_source = get_wakeup_source;
+}
diff --git a/board/amlogic/txl_p320_v1/firmware/timing.c b/board/amlogic/txl_p320_v1/firmware/timing.c
new file mode 100644
index 0000000..1c52562
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/firmware/timing.c
@@ -0,0 +1,579 @@
+
+/*
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/timing.h>
+#include <asm/arch/ddr_define.h>
+
+/* DDR freq range */
+#define CONFIG_DDR_CLK_LOW  20
+#define CONFIG_DDR_CLK_HIGH 1500
+/* DON'T OVER THESE RANGE */
+#if (CONFIG_DDR_CLK < CONFIG_DDR_CLK_LOW) || (CONFIG_DDR_CLK > CONFIG_DDR_CLK_HIGH)
+	#error "Over DDR PLL range! Please check CONFIG_DDR_CLK in board header file! \n"
+#endif
+
+/* CPU freq range */
+#define CONFIG_CPU_CLK_LOW  600
+#define CONFIG_CPU_CLK_HIGH 2000
+/* DON'T OVER THESE RANGE */
+#if (CONFIG_CPU_CLK < CONFIG_CPU_CLK_LOW) || (CONFIG_CPU_CLK > CONFIG_CPU_CLK_HIGH)
+	#error "Over CPU PLL range! Please check CONFIG_CPU_CLK in board header file! \n"
+#endif
+
+#define DDR3_DRV_40OHM		0
+#define DDR3_DRV_34OHM		1
+#define DDR3_ODT_0OHM		0
+#define DDR3_ODT_60OHM		1
+#define DDR3_ODT_120OHM		2
+#define DDR3_ODT_40OHM		3
+#define DDR3_ODT_20OHM		4
+#define DDR3_ODT_30OHM		5
+
+/* lpddr2 drv odt */
+#define LPDDR2_DRV_34OHM	1
+#define LPDDR2_DRV_40OHM	2
+#define LPDDR2_DRV_48OHM	3
+#define LPDDR2_DRV_60OHM	4
+#define LPDDR2_DRV_80OHM	6
+#define LPDDR2_DRV_120OHM	7
+#define LPDDR2_ODT_0OHM		0
+
+/* lpddr3 drv odt */
+#define LPDDR3_DRV_34OHM	1
+#define LPDDR3_DRV_40OHM	2
+#define LPDDR3_DRV_48OHM	3
+#define LPDDR3_DRV_60OHM	4
+#define LPDDR3_DRV_80OHM	6
+#define LPDDR3_DRV_34_40OHM	9
+#define LPDDR3_DRV_40_48OHM	10
+#define LPDDR3_DRV_34_48OHM	11
+#define LPDDR3_ODT_0OHM		0
+#define LPDDR3_ODT_60OHM	1
+#define LPDDR3_ODT_12OHM	2
+#define LPDDR3_ODT_240HM	3
+
+#define DDR4_DRV_34OHM		0
+#define DDR4_DRV_48OHM		1
+#define DDR4_ODT_0OHM		0
+#define DDR4_ODT_60OHM		1
+#define DDR4_ODT_120OHM		2
+#define DDR4_ODT_40OHM		3
+#define DDR4_ODT_240OHM		4
+#define DDR4_ODT_48OHM		5
+#define DDR4_ODT_80OHM		6
+#define DDR4_ODT_34OHM		7
+
+#if ((CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR3) || (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_AUTO))
+#define CFG_DDR_DRV  DDR3_DRV_34OHM
+#define CFG_DDR_ODT  DDR3_ODT_120OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR2)
+#define CFG_DDR_DRV  LPDDR2_DRV_48OHM
+#define CFG_DDR_ODT  DDR3_ODT_120OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR3)
+#define CFG_DDR_DRV  LPDDR3_DRV_48OHM
+#define CFG_DDR_ODT  LPDDR3_ODT_12OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR4)
+#define CFG_DDR_DRV  DDR4_DRV_34OHM //useless, no effect
+#define CFG_DDR_ODT  DDR4_ODT_60OHM //useless, no effect
+#endif
+
+#define CFG_DDR4_DRV  DDR4_DRV_48OHM//DDR4_DRV_48OHM //ddr4 driver use this one
+#define CFG_DDR4_ODT DDR4_ODT_60OHM// DDR4_ODT_80OHM //ddr4 driver use this one
+#define CONFIG_SOC_VREF      0// (738/12) //0 //0  is auto --70 ---range 44.07---88.04   %
+#define CONFIG_DRAM_VREF   0// (810/12) // 0 //77 //0 //0  is auto ---70 --range -- 45---92.50    %
+//#define CONFIG_ZQ_VREF   715/15//  60//0 //(50) % //tune ddr4 ,ddr3 use 0
+#define CONFIG_ZQ_VREF   51//60 //700/12//  60//0 //(50) % //tune ddr4 ,ddr3 use 0
+/*
+ * these parameters are corresponding to the pcb layout,
+ * please don't enable this function unless these signals
+ * has been measured by oscilloscope.
+ */
+#ifdef CONFIG_DDR_CMD_BDL_TUNE
+#define DDR_AC_LCDLR   0
+#define	DDR_CK0_BDL	18
+#define	DDR_RAS_BDL	18
+#define	DDR_CAS_BDL	24
+#define	DDR_WE_BDL	21
+#define	DDR_BA0_BDL	16
+#define	DDR_BA1_BDL	2
+#define	DDR_BA2_BDL	13
+#define	DDR_ACPDD_BDL	27
+#define	DDR_CS0_BDL	27
+#define	DDR_CS1_BDL	27
+#define	DDR_ODT0_BDL	27
+#define	DDR_ODT1_BDL	27
+#define	DDR_CKE0_BDL	27
+#define	DDR_CKE1_BDL	27
+#define	DDR_A0_BDL	14
+#define	DDR_A1_BDL	9
+#define	DDR_A2_BDL	5
+#define	DDR_A3_BDL	18
+#define	DDR_A4_BDL	4
+#define	DDR_A5_BDL	16
+#define	DDR_A6_BDL	1
+#define	DDR_A7_BDL	10
+#define	DDR_A8_BDL	4
+#define	DDR_A9_BDL	7
+#define	DDR_A10_BDL	10
+#define	DDR_A11_BDL	9
+#define	DDR_A12_BDL	6
+#define	DDR_A13_BDL	16
+#define	DDR_A14_BDL	8
+#define	DDR_A15_BDL	27
+#endif
+
+/* CAUTION!! */
+/*
+ * For DDR3:
+ *     7-7-7:    CONFIG_DDR_CLK range  375~ 533
+ *     9-9-9:    CONFIG_DDR_CLK range  533~ 667
+ *     11-11-11: CONFIG_DDR_CLK range  667~ 800
+ *     12-12-12: CONFIG_DDR_CLK range  800~ 933
+ *     13-13-13: CONFIG_DDR_CLK range  933~1066
+ *     14-14-14: CONFIG_DDR_CLK range 1066~1200
+ */
+ddr_timing_t __ddr_timming[] = {
+	//ddr3_7_7_7
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_7,
+		.cfg_ddr_rtp			= (6),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (7),
+		.cfg_ddr_rcd			= (7),
+		.cfg_ddr_ras			= (20),
+		.cfg_ddr_rrd			= (6),
+		.cfg_ddr_rc				= (27),
+		.cfg_ddr_mrd			= (4),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (27),
+		.cfg_ddr_rfc			= (160),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (6),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (4),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (7),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (5),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (4),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (512),
+		.cfg_ddr_xpdll			= (20),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_9_9_9
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_9,
+		.cfg_ddr_rtp			= (6),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (9),
+		.cfg_ddr_rcd			= (9),
+		.cfg_ddr_ras			= (27),
+		.cfg_ddr_rrd			= (6),
+		.cfg_ddr_rc				= (33),
+		.cfg_ddr_mrd			= (4),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (30),
+		.cfg_ddr_rfc			= (196),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (6),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (6),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (9),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (7),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (20),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_11_11_11
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_11,
+		.cfg_ddr_rtp			= (7),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (11),
+		.cfg_ddr_rcd			= (11),
+		.cfg_ddr_ras			= (35),
+		.cfg_ddr_rrd			= (7),
+		.cfg_ddr_rc				= (45),
+		.cfg_ddr_mrd			= (6),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (33),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (7),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (5),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (11),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (8),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_13_13_13
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_13,
+		.cfg_ddr_rtp			= (7),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (13),
+		.cfg_ddr_rcd			= (13),
+		.cfg_ddr_ras			= (37),
+		.cfg_ddr_rrd			= (7),
+		.cfg_ddr_rc				= (52),
+		.cfg_ddr_mrd			= (6),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (33),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (7),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (13),
+		.cfg_ddr_wr				= (16),
+		.cfg_ddr_cwl			= (9),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	/* ddr4 1600 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR4_1600,
+		.cfg_ddr_rtp			= (4),
+		.cfg_ddr_wtr			= (6),
+		.cfg_ddr_rp				= (11),
+		.cfg_ddr_rcd			= (11),
+		.cfg_ddr_ras			= (35),
+		.cfg_ddr_rrd			= (4),
+		.cfg_ddr_rc				= (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= (28),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (11),
+		.cfg_ddr_wr				= (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (5),
+	},
+	/* ddr4 2400 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR4_2400,
+		.cfg_ddr_rtp			= 9,//(4),
+		.cfg_ddr_wtr			= 9,//(6),
+		.cfg_ddr_rp				= 15*1.2,//(11),
+		.cfg_ddr_rcd			= 15*1.2,//(11),
+		.cfg_ddr_ras			= 35*1.2,//(35),
+		.cfg_ddr_rrd			= (8),
+		.cfg_ddr_rc				=50*1.2,// (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= 35*1.2,//(28),
+		.cfg_ddr_rfc			= 350*1.2,//(280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= 9.5*1.2,//(8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= 15*1.2,// (11),
+		.cfg_ddr_wr				= 15*1.2,// (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= 12,// (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (6),
+	},
+	/* lpddr3 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_LPDDR3,
+		.cfg_ddr_rtp			= (4),
+		.cfg_ddr_wtr			= (6),
+		.cfg_ddr_rp				= 15*1.2,//(11),
+		.cfg_ddr_rcd			= 15*1.2,//(11),
+		.cfg_ddr_ras			= 35*1.2,//(35),
+		.cfg_ddr_rrd			= (4),
+		.cfg_ddr_rc				= 50*1.2,// (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= 35*1.2,//(28),
+		.cfg_ddr_rfc			= 350*1.2,//(280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= 9.5*1.2,//(8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= 15*1.2,// (11),
+		.cfg_ddr_wr				= 15*1.2,// (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= 12,// (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (6),
+	}
+};
+
+ddr_set_t __ddr_setting = {
+	/* common and function defines */
+	.ddr_channel_set		= CONFIG_DDR_CHANNEL_SET,
+	.ddr_type				= CONFIG_DDR_TYPE,
+	.ddr_clk				= CONFIG_DDR_CLK,
+	.ddr4_clk				= CONFIG_DDR4_CLK,
+	.ddr_base_addr			= CFG_DDR_BASE_ADDR,
+	.ddr_start_offset		= CFG_DDR_START_OFFSET,
+	.ddr_timing_ind			= 0,
+	.ddr_size				= CONFIG_DDR_SIZE,
+	.ddr_pll_ctrl			= (0),
+	.ddr_dmc_ctrl			= 0,
+	.ddr0_addrmap			= {0},
+	.ddr1_addrmap			= {0},
+	.ddr_2t_mode			= 1,
+	.ddr_full_test			= CONFIG_DDR_FULL_TEST,
+#if (0 == CONFIG_DDR_SIZE)
+	.ddr_size_detect		= 1,
+#else
+	.ddr_size_detect		= 0,
+#endif
+	.ddr_drv				= CFG_DDR_DRV,
+	.ddr_odt				= CFG_DDR_ODT,
+	.ddr4_drv				= CFG_DDR4_DRV,
+	.ddr4_odt				= CFG_DDR4_ODT,
+
+	/* pub defines */
+	.t_pub_ptr				= {
+							[0] = ( 6 | (320 << 6) | (80 << 21)),
+							[1] = (120 | (1000 << 16)),
+							[2] = 0,
+							[3] = (20000 | (136 << 20)),
+							[4] = (1000 | (180 << 16)),
+							},  //PUB PTR0-3
+	.t_pub_odtcr			= 0x00030000,
+	.t_pub_mr				= {
+							(0X0 | (0X1 << 2) | (0X0 << 3) | (0X0 << 4) | (0X0 << 7) | (0X0 << 8) | (0X7 << 9) | (1 << 12)),
+							(0X6|(1<<6)),
+							0X20,
+							0,
+							},
+	.t_pub_dtpr				= {0},
+	.t_pub_pgcr0			= 0x07d81e3f,   //PUB PGCR0
+	.t_pub_pgcr1			= 0x02004620,   //PUB PGCR1
+	.t_pub_pgcr2			= 0x00f05f97,   //PUB PGCR2
+	//.t_pub_pgcr2			= 0x01f12480,   //PUB PGCR2
+	.t_pub_pgcr3			= 0xc0aae860,   //PUB PGCR3
+	.t_pub_dxccr			= 0x20c01ee4,   //PUB DXCCR
+	.t_pub_aciocr			= {0},  //PUB ACIOCRx
+	.t_pub_dx0gcr			= {0},  //PUB DX0GCRx
+	.t_pub_dx1gcr			= {0},  //PUB DX1GCRx
+	.t_pub_dx2gcr			= {0},  //PUB DX2GCRx
+	.t_pub_dx3gcr			= {0},  //PUB DX3GCRx
+#if (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR3)
+	.t_pub_dcr				= 0XB,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,    //PUB DTCR
+	.t_pub_dsgcr			= 0x020641b,
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR4)
+	.t_pub_dcr				= 0X40C,     //PUB DCR
+	.t_pub_dtcr0			= 0x800031c7,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,
+	.t_pub_dsgcr			= 0x020641b|(1<<2)|(1<<23),
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR3)
+	.t_pub_dcr				= 0X89,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,
+	.t_pub_dsgcr			= 0x02064db,
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_AUTO)
+	.t_pub_dcr				= 0XB,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,    //PUB DTCR
+	.t_pub_dsgcr			= 0x020641b,
+#endif
+	.t_pub_vtcr1			= 0x0fc00172,
+	.t_pub_dtar				= (0X0 | (0X0 <<12) | (0 << 28)),
+	//.t_pub_zq0pr			= 0x7b,   //PUB ZQ0PR
+	//.t_pub_zq1pr			= 0x7b,   //PUB ZQ1PR
+	//.t_pub_zq2pr			= 0x7b,   //PUB ZQ2PR
+	//.t_pub_zq3pr			= 0x7b,   //PUB ZQ3PR  zqvref 0x13
+	//.t_pub_zq0pr			= 0x5aa59,   //PUB ZQ0PR, 0x5aa59,0x59959,  0x58859,  //99drriver s912 ddr4 maybe 950m is bad
+	//.t_pub_zq1pr			= 0x3f95d,   //PUB ZQ1PR//0x3f95d, 0x4f95d,
+	//.t_pub_zq2pr			= 0x3f95d,   //PUB ZQ2PR//0x3f95d, 0x4f95d,
+	.t_pub_zq3pr			= 0x1dd1d,   //PUB ZQ3PR
+
+	.t_pub_zq0pr			= 0x0000bf59,   //PUB ZQ0PR, 0x5aa59,0x59959,  0x58859,  //99drriver s912 ddr4 maybe 950m is bad
+	.t_pub_zq1pr			= 0x0002fc5d,   //PUB ZQ1PR//0x3f95d, 0x4f95d,
+	.t_pub_zq2pr			= 0x0002fc5d,   //PUB ZQ2PR//0x3f95d, 0x4f95d,
+	//.t_pub_zq3pr			= 0xf5f95d,   //PUB ZQ3PR
+
+	/* pctl0 defines */
+	/* pctl1 use same define as pctl0 */
+	.t_pctl0_1us_pck		= CONFIG_DDR_CLK / 2,   //PCTL TOGCNT1U
+	.t_pctl0_100ns_pck		= CONFIG_DDR_CLK / 20, //PCTL TOGCNT100N
+	.t_pctl0_init_us		= 2,   //PCTL TINIT
+	.t_pctl0_rsth_us		= 2,   //PCTL TRSTH
+	.t_pctl0_mcfg			= 0XA2F01,   //PCTL MCFG default 1T
+	//.t_pctl0_mcfg1			= 0X80000000,  //PCTL MCFG1
+	.t_pctl0_mcfg1			= 0, //[B10,B9,B8] tfaw_cfg_offset
+								//tFAW= (4 + MCFG.tfaw_cfg)*tRRD - tfaw_cfg_offset,  //PCTL MCFG1
+	.t_pctl0_scfg			= 0xF01,   //PCTL SCFG
+	.t_pctl0_sctl			= 0x1,   //PCTL SCTL
+	.t_pctl0_ppcfg			= 0,
+	.t_pctl0_dfistcfg0		= 0x4,
+	.t_pctl0_dfistcfg1		= 0x1,
+	.t_pctl0_dfitctrldelay	= 2,
+	.t_pctl0_dfitphywrdata	= 2,
+	.t_pctl0_dfitphywrlta	= 7,
+	.t_pctl0_dfitrddataen	= 8,
+	.t_pctl0_dfitphyrdlat	= 22,
+	.t_pctl0_dfitdramclkdis	= 1,
+	.t_pctl0_dfitdramclken	= 1,
+	.t_pctl0_dfitphyupdtype0 = 16,
+	.t_pctl0_dfitphyupdtype1 = 16,
+	.t_pctl0_dfitctrlupdmin	= 16,
+	.t_pctl0_dfitctrlupdmax	= 64,
+	.t_pctl0_dfiupdcfg		= 0x3,
+	.t_pctl0_cmdtstaten		= 1,
+	//.t_pctl0_dfiodtcfg		= 8,
+	//.t_pctl0_dfiodtcfg1		= ( 0x0 | (0x6 << 16) ),
+	.t_pctl0_dfiodtcfg		= (1<<3)|(1<<11),
+	.t_pctl0_dfiodtcfg1		= (0x0 | (0x6 << 16)),
+
+	.t_pctl0_dfilpcfg0		= ( 1 | (3 << 4) | (1 << 8) | (13 << 12) | (7 <<16) | (1 <<24) | ( 3 << 28)),
+	.t_pub_acbdlr0			= 0x3f,
+	.t_pub_aclcdlr			= 0x28,//0x18,   ///1t  ,if 2t can add some value
+	.t_pub_acbdlr3			= 0x0,//0xa,  //cs
+	//.t_pub_acbdlr0		= 0x0,
+	//.t_pub_aclcdlr		= 0x10,//0x18,   ///1t  ,if 2t can add some value
+	//.t_pub_acbdlr3		= 0x14,//0xa,  //cs
+	.t_pub_soc_vref_dram_vref =((((CONFIG_SOC_VREF<45)?(0):((((CONFIG_SOC_VREF*1000-44070)/698)>0X3F)?(0X3F):(((CONFIG_SOC_VREF*1000-44070)/698))))<<8)|(
+	(((CONFIG_DRAM_VREF))<45)?(0):((((CONFIG_DRAM_VREF))<61)?((((((CONFIG_DRAM_VREF*1000-45000)/650)>0X32)?(0X32):(((CONFIG_DRAM_VREF*1000-45000)/650)))|(1<<6))):
+	((((CONFIG_DRAM_VREF*1000-60000)/650)>0X32)?(0X32):(((CONFIG_DRAM_VREF*1000-60000)/650)))))),
+	.t_pub_mr[7]	= ((CONFIG_ZQ_VREF<45)?(0):((((CONFIG_ZQ_VREF*1000-44070)/698)>0X3F)?(0X3F):(((CONFIG_ZQ_VREF*1000-44070)/698)))) ,//jiaxing use for tune zq vref 20160608
+	.ddr_func				= DDR_FUNC, /* ddr func demo 2016.01.26 */
+
+	.wr_adj_per 			= {
+							[0] = 100,
+							[1] = 100,
+							[2] = 100,
+							[3] = 100,
+							[4] = 100,
+							[5] = 100,
+							},
+	.rd_adj_per				= {
+							[0] = 100,
+							[1] = 100,
+							[2] = 100,
+							[3] = 100,
+							[4] = 100,
+							[5] = 100,},
+};
+
+pll_set_t __pll_setting = {
+	.cpu_clk				= CONFIG_CPU_CLK / 24 * 24,
+	.spi_ctrl				= 0,
+	.lCustomerID			= CONFIG_AML_CUSTOMER_ID,
+#ifdef CONFIG_DEBUG_MODE
+	.debug_mode				= CONFIG_DEBUG_MODE,
+	.ddr_clk_debug			= CONFIG_DDR_CLK_DEBUG,
+	.cpu_clk_debug			= CONFIG_CPU_CLK_DEBUG,
+#endif
+};
diff --git a/board/amlogic/txl_p320_v1/lcd.c b/board/amlogic/txl_p320_v1/lcd.c
new file mode 100644
index 0000000..b3ca408
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/lcd.c
@@ -0,0 +1,301 @@
+/*
+ * AMLOGIC TV LCD panel driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <amlogic/aml_lcd.h>
+#include <asm/arch/gpio.h>
+
+//Rsv_val = 0xffffffff
+
+static char lcd_cpu_gpio[LCD_CPU_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX] = {
+	"GPIOH_7",
+	"GPIOZ_3",
+	"GPIOH_4",
+	"GPIOH_5",
+	"GPIOH_6",
+	"invalid", /* ending flag */
+};
+
+static struct lcd_power_step_s lcd_power_on_step[] = {
+	{LCD_POWER_TYPE_CPU,   0,1,20,}, /* power on */
+	{LCD_POWER_TYPE_SIGNAL,0,0,0,},  /* signal */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},  /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_off_step[] = {
+	{LCD_POWER_TYPE_SIGNAL,0,0,20,},  /* signal */
+	{LCD_POWER_TYPE_CPU,   0,0,100,}, /* power off */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},   /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_on_step_3d_disable[] = {
+	{LCD_POWER_TYPE_CPU,   0,1,20,}, /* power on */
+	{LCD_POWER_TYPE_CPU,   1,0,10,}, /* 3d_disable */
+	{LCD_POWER_TYPE_SIGNAL,0,0,0,},  /* signal */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},  /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_off_step_3d_disable[] = {
+	{LCD_POWER_TYPE_SIGNAL,0,0,20,},  /* signal */
+	{LCD_POWER_TYPE_CPU,   1,2,0,},   /* 3d_disable */
+	{LCD_POWER_TYPE_CPU,   0,0,100,}, /* power off */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},   /* ending flag */
+};
+
+static char lcd_bl_gpio[BL_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX] = {
+	"GPIOZ_2",
+	"GPIOZ_6",
+	"GPIOZ_7",
+	"invalid", /* ending flag */
+};
+
+struct ext_lcd_config_s ext_lcd_config[LCD_NUM_MAX] = {
+	{"lvds_0",LCD_LVDS,8,
+	/* basic timing */
+	1920,1080,2200,1125,44,148,0,5,30,0,
+	/* clk_attr */
+	0,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* lvds_attr */
+	1,1,0,0,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{"lvds_1",LCD_LVDS,8,
+	/* basic timing */
+	1920,1080,2200,1125,44,148,0,5,30,0,
+	/* clk_attr */
+	1,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* lvds_attr */
+	1,1,0,0,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*public vx1 : 3840x2160@60hz 8lane */
+	"vbyone_0",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,65,0,
+	/* clk_attr */
+	0,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*LG: RDL550WY: 3840x2160@60hz 8lane */
+	"vbyone_1",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,65,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*INL: V580DJ2: 3840x2160@60hz 8lane */
+	"vbyone_2",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,65,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,1,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*BOE: HV550QU2: 3840x2160@60hz 8lane */
+	"vbyone_3",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,1,6,65,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step_3d_disable, lcd_power_off_step_3d_disable,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+};
+
+//**** Special parameters just for Vbyone ***//
+static struct vbyone_config_s lcd_vbyone_config = {
+	.lane_count   = 8,
+	.byte_mode    = 4,
+	.region_num   = 2,
+	.color_fmt    = 4,
+};
+
+//**** Special parameters just for lvds ***//
+static struct lvds_config_s lcd_lvds_config = {
+	.lvds_repack  = 1, //0=JEDIA mode,  1=VESA mode
+	.dual_port    = 1, //0=single port, 1=double port
+	.pn_swap      = 0, //0=normal,      1=swap
+	.port_swap    = 0, //0=normal,      1=swap
+};
+
+static struct lcd_power_ctrl_s lcd_power_ctrl = {
+	.power_on_step = {
+		{
+			.type = LCD_POWER_TYPE_CPU,
+			.index = 0, /* point to cpu_gpio[] struct */
+			.value = 1, /* 0=output_low, 1=output_high, 2=input */
+			.delay = 20, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_SIGNAL,
+			.delay = 0, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_MAX, /* ending flag */
+		},
+	},
+	.power_off_step = {
+		{
+			.type = LCD_POWER_TYPE_SIGNAL,
+			.delay = 20, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_CPU,
+			.index = 0, /* point to cpu_gpio[] struct */
+			.value = 0, /* 0=output_low, 1=output_high, 2=input */
+			.delay = 100, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_MAX, /* ending flag */
+		},
+	},
+};
+
+struct lcd_config_s lcd_config_dft = {
+	.lcd_mode = LCD_MODE_TV,
+	.lcd_basic = {
+		.model_name = "default",
+		.lcd_type = LCD_TYPE_MAX, //LCD_TTL /LCD_LVDS/LCD_VBYONE
+		.lcd_bits = 8,
+		.h_active = 1920,
+		.v_active = 1080,
+		.h_period = 2200,
+		.v_period = 1125,
+
+		.screen_width   = 16,
+		.screen_height  = 9,
+	},
+
+	.lcd_timing = {
+		.clk_auto = 1,
+		.lcd_clk = 60,
+		.ss_level = 0,
+		.fr_adjust_type = 0,
+
+		.hsync_width = 44,
+		.hsync_bp    = 148,
+		.hsync_pol   = 0,
+		.vsync_width = 5,
+		.vsync_bp    = 36,
+		.vsync_pol   = 0,
+	},
+
+	.lcd_control = {
+		.lvds_config   = &lcd_lvds_config,
+		.vbyone_config = &lcd_vbyone_config,
+	},
+	.lcd_power = &lcd_power_ctrl,
+	.pinmux_set = {{0, 0xc0000000}, {LCD_PINMUX_END, 0x0}},
+	.pinmux_clr = {{LCD_PINMUX_END, 0x0}},
+};
+
+struct bl_config_s bl_config_dft = {
+	.name = "default",
+	.level_default = 100,
+	.level_min = 10,
+	.level_max = 255,
+	.level_mid = 128,
+	.level_mid_mapping = 128,
+	.level = 0,
+
+	.method = BL_CTRL_MAX,
+	.power_on_delay = 200,
+	.power_off_delay = 200,
+
+	.en_gpio = 0xff,
+	.en_gpio_on = 1,
+	.en_gpio_off = 0,
+
+	.bl_pwm = NULL,
+	.bl_pwm_combo0 = NULL,
+	.bl_pwm_combo1 = NULL,
+	.pwm_on_delay = 10,
+	.pwm_off_delay = 10,
+
+	.pinmux_set = {{4, 0x00010000}, {LCD_PINMUX_END, 0x0}},
+	.pinmux_clr = {{4, 0x00008000}, {3, 0x00200000}, {LCD_PINMUX_END, 0x0}},
+};
+
+void lcd_config_gpio_init(void)
+{
+	int i, j;
+
+	for (i = 0; i < LCD_CPU_GPIO_NUM_MAX; i++) {
+		if (strcmp(lcd_cpu_gpio[i], "invalid") == 0)
+			break;
+		strcpy(lcd_power_ctrl.cpu_gpio[i], lcd_cpu_gpio[i]);
+	}
+	for (j = i; j < LCD_CPU_GPIO_NUM_MAX; j++)
+		strcpy(lcd_power_ctrl.cpu_gpio[j], "invalid");
+	for (i = 0; i < BL_GPIO_NUM_MAX; i++) {
+		if (strcmp(lcd_bl_gpio[i], "invalid") == 0)
+			break;
+		strcpy(bl_config_dft.gpio_name[i], lcd_bl_gpio[i]);
+	}
+	for (j = i; j < BL_GPIO_NUM_MAX; j++)
+		strcpy(bl_config_dft.gpio_name[j], "invalid");
+}
diff --git a/board/amlogic/txl_p320_v1/txl_p320_v1.c b/board/amlogic/txl_p320_v1/txl_p320_v1.c
new file mode 100644
index 0000000..72ff2b7
--- /dev/null
+++ b/board/amlogic/txl_p320_v1/txl_p320_v1.c
@@ -0,0 +1,454 @@
+
+/*
+ * board/amlogic/txl_skt_v1/txl_skt_v1.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#ifdef CONFIG_SYS_I2C_AML
+#include <aml_i2c.h>
+#include <asm/arch/secure_apb.h>
+#endif
+#ifdef CONFIG_AML_VPU
+#include <vpu.h>
+#endif
+#include <vpp.h>
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+#include <amlogic/aml_v2_burning.h>
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+#ifdef CONFIG_AML_HDMITX20
+#include <amlogic/hdmi.h>
+#endif
+#ifdef CONFIG_AML_LCD
+#include <amlogic/aml_lcd.h>
+#endif
+#include <asm/arch/eth_setup.h>
+#include <phy.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+//new static eth setup
+struct eth_board_socket*  eth_board_skt;
+
+
+int serial_set_pin_port(unsigned long port_base)
+{
+    //UART in "Always On Module"
+    //GPIOAO_0==tx,GPIOAO_1==rx
+    //setbits_le32(P_AO_RTI_PIN_MUX_REG,3<<11);
+    return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+/* secondary_boot_func
+ * this function should be write with asm, here, is is only for compiling pass
+ * */
+void secondary_boot_func(void)
+{
+}
+void internalPhyConfig(struct phy_device *phydev)
+{
+	/*Enable Analog and DSP register Bank access by*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0000);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0400);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0000);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0400);
+	/*Write Analog register 23*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x8E0D);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x4417);
+	/*Enable fractional PLL*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x0005);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1B);
+	//Programme fraction FR_PLL_DIV1
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x029A);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1D);
+	//## programme fraction FR_PLL_DiV1
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0xAAAA);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1C);
+}
+
+
+static void setup_net_chip(void)
+{
+	eth_aml_reg0_t eth_reg0;
+
+	eth_reg0.d32 = 0;
+	eth_reg0.b.phy_intf_sel = 0;
+	eth_reg0.b.data_endian = 0;
+	eth_reg0.b.desc_endian = 0;
+	eth_reg0.b.rx_clk_rmii_invert = 0;
+	eth_reg0.b.rgmii_tx_clk_src = 0;
+	eth_reg0.b.rgmii_tx_clk_phase = 0;
+	eth_reg0.b.rgmii_tx_clk_ratio = 0;
+	eth_reg0.b.phy_ref_clk_enable = 0;
+	eth_reg0.b.clk_rmii_i_invert = 1;
+	eth_reg0.b.clk_en = 1;
+	eth_reg0.b.adj_enable = 0;
+	eth_reg0.b.adj_setup = 0;
+	eth_reg0.b.adj_delay = 0;
+	eth_reg0.b.adj_skew = 0;
+	eth_reg0.b.cali_start = 0;
+	eth_reg0.b.cali_rise = 0;
+	eth_reg0.b.cali_sel = 0;
+	eth_reg0.b.rgmii_rx_reuse = 0;
+	eth_reg0.b.eth_urgent = 0;
+	setbits_le32(P_PREG_ETH_REG0, eth_reg0.d32);// rmii mode
+	*P_PREG_ETH_REG2 = 0x10110181;
+	*P_PREG_ETH_REG3 = 0xe409087f;
+	setbits_le32(HHI_GCLK_MPEG1,1<<3);
+	/* power on memory */
+	clrbits_le32(HHI_MEM_PD_REG0, (1 << 3) | (1<<2));
+
+}
+
+extern struct eth_board_socket* eth_board_setup(char *name);
+extern int designware_initialize(ulong base_addr, u32 interface);
+
+int board_eth_init(bd_t *bis)
+{
+	setup_net_chip();
+	udelay(1000);
+	designware_initialize(ETH_BASE, PHY_INTERFACE_MODE_RMII);
+	return 0;
+}
+
+#if CONFIG_AML_SD_EMMC
+#include <mmc.h>
+#include <asm/arch/sd_emmc.h>
+static int  sd_emmc_init(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+			//todo add card detect
+			//setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+			break;
+		case SDIO_PORT_C:
+			//enable pull up
+			//clrbits_le32(P_PAD_PULL_UP_REG3, 0xff<<0);
+			break;
+		default:
+			break;
+	}
+
+	return cpu_sd_emmc_init(port);
+}
+
+extern unsigned sd_debug_board_1bit_flag;
+static int  sd_emmc_detect(unsigned port)
+{
+	int ret;
+    switch (port) {
+
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+			setbits_le32(P_PREG_PAD_GPIO2_EN_N, 1 << 26);//CARD_6
+			ret = readl(P_PREG_PAD_GPIO2_I) & (1 << 26) ? 0 : 1;
+			printf("%s\n", ret ? "card in" : "card out");
+			if ((readl(P_PERIPHS_PIN_MUX_6) & (3 << 8))) { //if uart pinmux set, debug board in
+				if (!(readl(P_PREG_PAD_GPIO2_I) & (1 << 24))) {
+					printf("sdio debug board detected, sd card with 1bit mode\n");
+					sd_debug_board_1bit_flag = 1;
+				}
+				else{
+					printf("sdio debug board detected, no sd card in\n");
+					sd_debug_board_1bit_flag = 0;
+					return 1;
+				}
+			}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void sd_emmc_pwr_prepare(unsigned port)
+{
+	cpu_sd_emmc_pwr_prepare(port);
+}
+
+static void sd_emmc_pwr_on(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            clrbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			/// @todo NOT FINISH
+			break;
+		case SDIO_PORT_C:
+			break;
+		default:
+			break;
+	}
+	return;
+}
+static void sd_emmc_pwr_off(unsigned port)
+{
+	/// @todo NOT FINISH
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            setbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			break;
+		case SDIO_PORT_C:
+			break;
+				default:
+			break;
+	}
+	return;
+}
+
+// #define CONFIG_TSD      1
+static void board_mmc_register(unsigned port)
+{
+	struct aml_card_sd_info *aml_priv=cpu_sd_emmc_get(port);
+    if (aml_priv == NULL)
+		return;
+
+	aml_priv->sd_emmc_init=sd_emmc_init;
+	aml_priv->sd_emmc_detect=sd_emmc_detect;
+	aml_priv->sd_emmc_pwr_off=sd_emmc_pwr_off;
+	aml_priv->sd_emmc_pwr_on=sd_emmc_pwr_on;
+	aml_priv->sd_emmc_pwr_prepare=sd_emmc_pwr_prepare;
+	aml_priv->desc_buf = malloc(NEWSD_MAX_DESC_MUN*(sizeof(struct sd_emmc_desc_info)));
+
+	if (NULL == aml_priv->desc_buf)
+		printf(" desc_buf Dma alloc Fail!\n");
+	else
+		printf("aml_priv->desc_buf = 0x%p\n",aml_priv->desc_buf);
+
+	sd_emmc_register(aml_priv);
+}
+int board_mmc_init(bd_t	*bis)
+{
+#ifdef CONFIG_VLSI_EMULATOR
+	//board_mmc_register(SDIO_PORT_A);
+#else
+	//board_mmc_register(SDIO_PORT_B);
+#endif
+	board_mmc_register(SDIO_PORT_B);
+	board_mmc_register(SDIO_PORT_C);
+//	board_mmc_register(SDIO_PORT_B1);
+	return 0;
+}
+
+#ifdef CONFIG_SYS_I2C_AML
+#if 0
+static void board_i2c_set_pinmux(void){
+	/*********************************************/
+	/*                | I2C_Master_AO        |I2C_Slave            |       */
+	/*********************************************/
+	/*                | I2C_SCK                | I2C_SCK_SLAVE  |      */
+	/* GPIOAO_4  | [AO_PIN_MUX: 6]     | [AO_PIN_MUX: 2]   |     */
+	/*********************************************/
+	/*                | I2C_SDA                 | I2C_SDA_SLAVE  |     */
+	/* GPIOAO_5  | [AO_PIN_MUX: 5]     | [AO_PIN_MUX: 1]   |     */
+	/*********************************************/
+
+	//disable all other pins which share with I2C_SDA_AO & I2C_SCK_AO
+	clrbits_le32(P_AO_RTI_PIN_MUX_REG, ((1<<2)|(1<<24)|(1<<1)|(1<<23)));
+	//enable I2C MASTER AO pins
+	setbits_le32(P_AO_RTI_PIN_MUX_REG,
+	(MESON_I2C_MASTER_AO_GPIOAO_4_BIT | MESON_I2C_MASTER_AO_GPIOAO_5_BIT));
+
+	udelay(10);
+};
+#endif
+struct aml_i2c_platform g_aml_i2c_plat = {
+	.wait_count         = 1000000,
+	.wait_ack_interval  = 5,
+	.wait_read_interval = 5,
+	.wait_xfer_interval = 5,
+	.master_no          = AML_I2C_MASTER_AO,
+	.use_pio            = 0,
+	.master_i2c_speed   = AML_I2C_SPPED_400K,
+	.master_ao_pinmux = {
+		.scl_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_4_REG,
+		.scl_bit    = MESON_I2C_MASTER_AO_GPIOAO_4_BIT,
+		.sda_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_5_REG,
+		.sda_bit    = MESON_I2C_MASTER_AO_GPIOAO_5_BIT,
+	}
+};
+#if 0
+static void board_i2c_init(void)
+{
+	//set I2C pinmux with PCB board layout
+	board_i2c_set_pinmux();
+
+	//Amlogic I2C controller initialized
+	//note: it must be call before any I2C operation
+	aml_i2c_init();
+
+	udelay(10);
+}
+#endif
+#endif
+#endif
+
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+int board_early_init_f(void){
+	/*add board early init function here*/
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_XHCI_AMLOGIC_GXL
+#include <asm/arch/usb-new.h>
+#include <asm/arch/gpio.h>
+#define CONFIG_GXL_USB_U2_PORT_NUM	4
+#define CONFIG_GXL_USB_U3_PORT_NUM	0
+
+struct amlogic_usb_config g_usb_config_GXL_skt={
+	CONFIG_GXL_XHCI_BASE,
+	USB_ID_MODE_HARDWARE,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	CONFIG_GXL_USB_PHY2_BASE,
+	CONFIG_GXL_USB_PHY3_BASE,
+	CONFIG_GXL_USB_U2_PORT_NUM,
+	CONFIG_GXL_USB_U3_PORT_NUM,
+};
+#endif /*CONFIG_USB_XHCI_AMLOGIC*/
+
+#ifdef CONFIG_AML_HDMITX20
+static void hdmi_tx_set_hdmi_5v(void)
+{
+}
+#endif
+
+int board_init(void)
+{
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	aml_try_factory_usb_burning(0, gd->bd);
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+#ifdef CONFIG_USB_XHCI_AMLOGIC_GXL
+	board_usb_init(&g_usb_config_GXL_skt,BOARD_USB_MODE_HOST);
+#endif /*CONFIG_USB_XHCI_AMLOGIC*/
+
+/*
+AO4 -- AO10 change
+tmp for P320 5V_en
+*/
+	writel(readl(AO_GPIO_O_EN_N) & (~(0x1 << 10)), AO_GPIO_O_EN_N); //set mode: output
+	writel(readl(AO_GPIO_O_EN_N) | (0x1 << 26),AO_GPIO_O_EN_N);   //output 1
+
+#ifdef CONFIG_AML_NAND
+	extern int amlnf_init(unsigned char flag);
+	amlnf_init(0);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void){
+	int ret;
+
+	//update env before anyone using it
+	run_command("get_rebootmode; echo reboot_mode=${reboot_mode}; "\
+			"if test ${reboot_mode} = factory_reset; then "\
+			"defenv_reserv aml_dt;setenv upgrade_step 2;save; fi;", 0);
+	run_command("if itest ${upgrade_step} == 1; then "\
+				"defenv_reserv; setenv upgrade_step 2; saveenv; fi;", 0);
+	/*add board late init function here*/
+	ret = run_command("store dtb read $dtb_mem_addr", 1);
+	if (ret) {
+		printf("%s(): [store dtb read $dtb_mem_addr] fail\n", __func__);
+		#ifdef CONFIG_DTB_MEM_ADDR
+		char cmd[64];
+		printf("load dtb to %x\n", CONFIG_DTB_MEM_ADDR);
+		sprintf(cmd, "store dtb read %x", CONFIG_DTB_MEM_ADDR);
+		ret = run_command(cmd, 1);
+		if (ret) {
+			printf("%s(): %s fail\n", __func__, cmd);
+		}
+		#endif
+	}
+
+	/* load unifykey */
+	run_command("keyunify init 0x1234", 0);
+#ifdef CONFIG_AML_VPU
+	vpu_probe();
+#endif
+	vpp_init();
+#ifdef CONFIG_AML_HDMITX20
+	hdmi_tx_set_hdmi_5v();
+	hdmi_tx_init();
+#endif
+#ifdef CONFIG_AML_LCD
+	lcd_probe();
+#endif
+
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	/*aml_try_factory_sdcard_burning(0, gd->bd);*/
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+	/* enable 5V for USB, panel, wifi */
+	//run_command("gpio set GPIOAO_4", 0);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AML_TINY_USBTOOL
+int usb_get_update_result(void)
+{
+	unsigned long upgrade_step;
+	upgrade_step = simple_strtoul (getenv ("upgrade_step"), NULL, 16);
+	printf("upgrade_step = %d\n", (int)upgrade_step);
+	if (upgrade_step == 1)
+	{
+		run_command("defenv", 1);
+		run_command("setenv upgrade_step 2", 1);
+		run_command("saveenv", 1);
+		return 0;
+	}
+	else
+	{
+		return -1;
+	}
+}
+#endif
+
+phys_size_t get_effective_memsize(void)
+{
+	// >>16 -> MB, <<20 -> real size, so >>16<<20 = <<4
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4) - CONFIG_SYS_MEM_TOP_HIDE;
+#else
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
+#endif
+}
diff --git a/board/amlogic/txl_p321_v1/Kconfig b/board/amlogic/txl_p321_v1/Kconfig
new file mode 100644
index 0000000..b600bec
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/Kconfig
@@ -0,0 +1,22 @@
+if TARGET_MESON_GXTV
+
+config SYS_CPU
+	string
+	default "armv8"
+
+config SYS_BOARD
+	string
+	default "txl_p321_v1"
+
+config SYS_VENDOR
+	string
+	default "amlogic"
+
+config SYS_SOC
+	string
+	default "txl"
+
+config SYS_CONFIG_NAME
+	default "txl_p321_v1"
+
+endif
diff --git a/board/amlogic/txl_p321_v1/Makefile b/board/amlogic/txl_p321_v1/Makefile
new file mode 100644
index 0000000..fb7f59a
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/Makefile
@@ -0,0 +1,3 @@
+
+obj-y += $(BOARD).o eth_setup.o
+obj-$(CONFIG_AML_LCD) += lcd.o
diff --git a/board/amlogic/txl_p321_v1/aml-user-key.sig b/board/amlogic/txl_p321_v1/aml-user-key.sig
new file mode 100644
index 0000000..e69de29
diff --git a/board/amlogic/txl_p321_v1/eth_setup.c b/board/amlogic/txl_p321_v1/eth_setup.c
new file mode 100644
index 0000000..882a37d
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/eth_setup.c
@@ -0,0 +1,51 @@
+
+/*
+ * board/amlogic/txl_skt_v1/eth_setup.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <asm/arch/eth_setup.h>
+/*
+ *
+ *setup eth device board socket
+ *
+ */
+struct eth_board_socket* eth_board_setup(char *name){
+	struct eth_board_socket* new_board;
+	new_board= (struct eth_board_socket*) malloc(sizeof(struct eth_board_socket));
+	if (NULL == new_board) return NULL;
+	if (name != NULL) {
+		new_board->name=(char*)malloc(strlen(name));
+		strncpy(new_board->name,name,strlen(name));
+	}else{
+		new_board->name="gxb";
+	}
+
+	new_board->eth_pinmux_setup=NULL ;
+	new_board->eth_clock_configure=NULL;
+	new_board->eth_hw_reset=NULL;
+	return new_board;
+}
+//pinmux   HHI_GCLK_MPEG1[bit 3]
+//
diff --git a/board/amlogic/txl_p321_v1/firmware/board_init.c b/board/amlogic/txl_p321_v1/firmware/board_init.c
new file mode 100644
index 0000000..96533c7
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/firmware/board_init.c
@@ -0,0 +1,86 @@
+
+/*
+ * board/amlogic/gxtvbb_p301_v1/firmware/board_init.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "power.c"
+
+/* bl2 customer code */
+
+#define PNL_PREG_PAD_GPIO1_EN_N           0x0f
+#define PNL_PREG_PAD_GPIO1_O              0x10
+#define PNL_PREG_PAD_GPIO1_I              0x11
+
+#define PNL_PREG_PAD_GPIO3_EN_N           0x15
+#define PNL_PREG_PAD_GPIO3_O              0x16
+#define PNL_PREG_PAD_GPIO3_I              0x17
+
+#define PNL_REG_BASE               (0xc8834400L)
+#define PNL_REG(reg)               (PNL_REG_BASE + (reg << 2))
+#define PNL_REG_R(_reg)            (*(volatile unsigned int *)PNL_REG(_reg))
+#define PNL_REG_W(_reg, _value)    *(volatile unsigned int *)PNL_REG(_reg) = (_value);
+void panel_power_init(void)
+{
+	serial_puts("init panel power\n");
+	/* GPIOZ_3 */
+	PNL_REG_W(PNL_PREG_PAD_GPIO3_O,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO3_O) & ~(1 << 3)));
+	PNL_REG_W(PNL_PREG_PAD_GPIO3_EN_N,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO3_EN_N) & ~(1 << 3)));
+	/* GPIOH_4/5/6/7 */
+	PNL_REG_W(PNL_PREG_PAD_GPIO1_O,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO1_O) & ~(0xf << 24)));
+	PNL_REG_W(PNL_PREG_PAD_GPIO1_EN_N,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO1_EN_N) & ~(0xf << 24)));
+
+	/* GPIOZ_2/6/7 */
+	PNL_REG_W(PNL_PREG_PAD_GPIO3_O,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO3_O) & ~((1 << 2) | (0x3 << 6))));
+	PNL_REG_W(PNL_PREG_PAD_GPIO3_EN_N,
+		(PNL_REG_R(PNL_PREG_PAD_GPIO3_EN_N) & ~((1 << 2) | (0x3 << 6))));
+}
+
+#define SEC_AO_SEC_GP_CFG0			(0xda100000 + (0x90 << 2))
+static int check_is_ddr_inited(void)
+{
+	return ((readl(SEC_AO_SEC_GP_CFG0) >> 16) & 0xffff);
+}
+
+void board_init(void)
+{
+	power_init(0);
+
+	//only run once before ddr inited.
+	if (!check_is_ddr_inited()) {
+		/* dram 1.5V reset */
+		serial_puts("DRAM reset...\n");
+		/* power off ddr */
+		//aml_update_bits(P_AO_GPIO_O_EN_N, 1 << 3, 0);
+		//aml_update_bits(P_AO_GPIO_O_EN_N, 1 << 19, 0);
+		writel((readl(P_AO_GPIO_O_EN_N) & (~((1 << 3) | (1 << 19)))),P_AO_GPIO_O_EN_N);
+		/* need delay */
+		_udelay(40000);
+		/* power on ddr */
+		//aml_update_bits(P_AO_GPIO_O_EN_N, 1 << 3, 0);
+		//aml_update_bits(P_AO_GPIO_O_EN_N, 1 << 19, 1 << 19);
+		writel((readl(P_AO_GPIO_O_EN_N) | (1 << 19)),P_AO_GPIO_O_EN_N);
+	}
+
+	panel_power_init();
+}
diff --git a/board/amlogic/txl_p321_v1/firmware/power.c b/board/amlogic/txl_p321_v1/firmware/power.c
new file mode 100644
index 0000000..6cec314
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/firmware/power.c
@@ -0,0 +1,171 @@
+
+/*
+ * board/amlogic/txl_p321_v1/firmware/power.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "config.h"
+#include <serial.h>
+//#include <stdio.h>
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+static int pwm_voltage_table[][2] = {
+	{ 0x1c0000,  870},
+	{ 0x1b0001,  880},
+	{ 0x1a0002,  890},
+	{ 0x190003,  900},
+	{ 0x180004,  910},
+	{ 0x170005,  920},
+	{ 0x160006,  930},
+	{ 0x150007,  940},
+	{ 0x140008,  950},
+	{ 0x130009,  960},
+	{ 0x12000a,  970},
+	{ 0x11000b,  980},
+	{ 0x10000c,  990},
+	{ 0x0f000d, 1000},
+	{ 0x0e000e, 1010},
+	{ 0x0d000f, 1020},
+	{ 0x0c0010, 1030},
+	{ 0x0b0011, 1040},
+	{ 0x0a0012, 1050},
+	{ 0x090013, 1060},
+	{ 0x080014, 1070},
+	{ 0x070015, 1080},
+	{ 0x060016, 1090},
+	{ 0x050017, 1100},
+	{ 0x040018, 1110},
+	{ 0x030019, 1120},
+	{ 0x02001a, 1130},
+	{ 0x01001b, 1140},
+	{ 0x00001c, 1150}
+};
+
+
+#define P_PIN_MUX_REG3		(*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG4		(*((volatile unsigned *)(0xda834400 + (0x30 << 2))))
+
+#define P_PWM_PWM_A		(*((volatile unsigned *)(0xc1100000 + (0x2154 << 2))))
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+
+#define P_EE_TIMER_E		(*((volatile unsigned *)(0xc1100000 + (0x2662 << 2))))
+
+enum pwm_id {
+    pwm_a = 0,
+    pwm_ao_b,
+};
+
+unsigned int _get_time(void)
+{
+	return P_EE_TIMER_E;
+}
+
+void _udelay_(unsigned int us)
+{
+	unsigned int t0 = _get_time();
+
+	while (_get_time() - t0 <= us)
+		;
+}
+
+void pwm_init(int id)
+{
+	unsigned int reg;
+	int vol;
+
+	switch (id) {
+	case pwm_a:
+		reg = P_PWM_MISC_REG_AB;
+		reg &= ~(0x7f << 8);
+		reg |=  ((1 << 15) | (1 << 0));
+		P_PWM_MISC_REG_AB = reg;
+		/*
+		 * default set to max voltage
+		 */
+		P_PWM_PWM_A = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+		reg  = P_PIN_MUX_REG3;
+		reg &= ~(1 << 21);
+		P_PIN_MUX_REG3 = reg;
+
+		reg  = P_PIN_MUX_REG4;
+		reg &= ~(1 << 26);
+		reg |=  (1 << 17);
+		P_PIN_MUX_REG4 = reg;
+		break;
+
+	case pwm_ao_b:
+		reg = readl(AO_PWM_MISC_REG_AB);
+		reg &= ~(0x7f << 16);
+		reg |=  ((1 << 23) | (1 << 1));
+		writel(reg, AO_PWM_MISC_REG_AB);
+		/*
+		 * default set to max voltage
+		 */
+		vol = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+		writel(vol ,AO_PWM_PWM_B);
+		reg  = readl(AO_RTI_PIN_MUX_REG);
+		reg |= (1 << 3);
+		writel(reg, AO_RTI_PIN_MUX_REG);
+		break;
+	default:
+		break;
+	}
+
+	_udelay_(200);
+}
+
+void pwm_set_voltage(unsigned int id, unsigned int voltage)
+{
+	int to;
+
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= voltage) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	switch (id) {
+	case pwm_a:
+		P_PWM_PWM_A = pwm_voltage_table[to][0];
+		break;
+
+	case pwm_ao_b:
+		writel(pwm_voltage_table[to][0], AO_PWM_PWM_B);
+		break;
+	default:
+		break;
+	}
+	_udelay_(200);
+}
+
+void power_init(int mode)
+{
+	pwm_init(pwm_a);
+	pwm_init(pwm_ao_b);
+	serial_puts("set vcck to ");
+	serial_put_dec(CONFIG_VCCK_INIT_VOLTAGE);
+	serial_puts(" mv\n");
+	pwm_set_voltage(pwm_a, CONFIG_VCCK_INIT_VOLTAGE);
+	serial_puts("set vddee to ");
+	serial_put_dec(CONFIG_VDDEE_INIT_VOLTAGE);
+	serial_puts(" mv\n");
+	pwm_set_voltage(pwm_ao_b, CONFIG_VDDEE_INIT_VOLTAGE);
+}
diff --git a/board/amlogic/txl_p321_v1/firmware/scp_task/dvfs_board.c b/board/amlogic/txl_p321_v1/firmware/scp_task/dvfs_board.c
new file mode 100644
index 0000000..61d7b44
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/firmware/scp_task/dvfs_board.c
@@ -0,0 +1,189 @@
+
+/*
+ * board/amlogic/txl_p321_v1/firmware/scp_task/dvfs_board.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+static int pwm_voltage_table[][2] = {
+	{ 0x1c0000,  870},
+	{ 0x1b0001,  880},
+	{ 0x1a0002,  890},
+	{ 0x190003,  900},
+	{ 0x180004,  910},
+	{ 0x170005,  920},
+	{ 0x160006,  930},
+	{ 0x150007,  940},
+	{ 0x140008,  950},
+	{ 0x130009,  960},
+	{ 0x12000a,  970},
+	{ 0x11000b,  980},
+	{ 0x10000c,  990},
+	{ 0x0f000d, 1000},
+	{ 0x0e000e, 1010},
+	{ 0x0d000f, 1020},
+	{ 0x0c0010, 1030},
+	{ 0x0b0011, 1040},
+	{ 0x0a0012, 1050},
+	{ 0x090013, 1060},
+	{ 0x080014, 1070},
+	{ 0x070015, 1080},
+	{ 0x060016, 1090},
+	{ 0x050017, 1100},
+	{ 0x040018, 1110},
+	{ 0x030019, 1120},
+	{ 0x02001a, 1130},
+	{ 0x01001b, 1140},
+	{ 0x00001c, 1150}
+};
+
+struct scpi_opp_entry cpu_dvfs_tbl[] = {
+	DVFS( 100000000,  870+20),
+	DVFS( 250000000,  870+20),
+	DVFS( 500000000,  870+20),
+	DVFS( 667000000,  870+20),
+	DVFS(1000000000,  880+20),
+	DVFS(1200000000,  910+20),
+	DVFS(1296000000,  950+20),
+	DVFS(1416000000, 1020+20),
+	DVFS(1488000000, 1060+30),
+	DVFS(1536000000, 1090+30),
+};
+
+
+
+#define P_PIN_MUX_REG3         (*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG4         (*((volatile unsigned *)(0xda834400 + (0x30 << 2))))
+
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+#define P_PWM_PWM_A		(*((volatile unsigned *)(0xc1100000 + (0x2154 << 2))))
+
+
+enum pwm_id {
+	pwm_a = 0,
+};
+
+
+void pwm_init(int id)
+{
+	/*
+	 * TODO: support more pwm controllers, right now only support PWM_B
+	 */
+	unsigned int reg;
+	reg = P_PWM_MISC_REG_AB;
+	reg &= ~(0x7f << 8);
+	reg |=  ((1 << 15) | (1 << 0));
+	P_PWM_MISC_REG_AB = reg;
+	/*
+	 * default set to max voltage
+	 */
+	P_PWM_PWM_A = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+	reg  = P_PIN_MUX_REG3;
+	reg &= ~(1 << 21);
+	P_PIN_MUX_REG3 = reg;
+
+	reg  = P_PIN_MUX_REG4;
+	reg &= ~(1 << 26);		// clear PWM_VS
+	reg |=  (1 << 17);		// enable PWM_A
+	P_PIN_MUX_REG4 = reg;
+
+
+	_udelay(200);
+}
+
+int dvfs_get_voltage(void)
+{
+	int i = 0;
+	unsigned int reg_val;
+
+	reg_val = P_PWM_PWM_A;
+	for (i = 0; i < ARRAY_SIZE(pwm_voltage_table); i++) {
+		if (pwm_voltage_table[i][0] == reg_val) {
+			return i;
+		}
+	}
+	if (i >= ARRAY_SIZE(pwm_voltage_table)) {
+	    return -1;
+	}
+	return -1;
+}
+
+void set_dvfs(unsigned int domain, unsigned int index)
+{
+	int cur, to;
+	static int init_flag = 0;
+
+	if (!init_flag) {
+		pwm_init(pwm_a);
+		init_flag = 1;
+	}
+	cur = dvfs_get_voltage();
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= cpu_dvfs_tbl[index].volt_mv) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	if (cur < 0 || cur >=ARRAY_SIZE(pwm_voltage_table)) {
+		P_PWM_PWM_A = pwm_voltage_table[to][0];
+		_udelay(200);
+		return ;
+	}
+	while (cur != to) {
+		/*
+		 * if target step is far away from current step, don't change
+		 * voltage by one-step-done. You should change voltage step by
+		 * step to make sure voltage output is stable
+		 */
+		if (cur < to) {
+			if (cur < to - 3) {
+				cur += 3;
+			} else {
+				cur = to;
+			}
+		} else {
+			if (cur > to + 3) {
+				cur -= 3;
+			} else {
+				cur = to;
+			}
+		}
+		P_PWM_PWM_A = pwm_voltage_table[cur][0];
+		_udelay(100);
+	}
+	_udelay(200);
+}
+void get_dvfs_info_board(unsigned int domain,
+		unsigned char *info_out, unsigned int *size_out)
+{
+	unsigned int cnt;
+	cnt = ARRAY_SIZE(cpu_dvfs_tbl);
+
+	buf_opp.latency = 200;
+	buf_opp.count = cnt;
+	memset(&buf_opp.opp[0], 0,
+	       MAX_DVFS_OPPS * sizeof(struct scpi_opp_entry));
+
+	memcpy(&buf_opp.opp[0], cpu_dvfs_tbl ,
+		cnt * sizeof(struct scpi_opp_entry));
+
+	memcpy(info_out, &buf_opp, sizeof(struct scpi_opp));
+	*size_out = sizeof(struct scpi_opp);
+	return;
+}
diff --git a/board/amlogic/txl_p321_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/txl_p321_v1/firmware/scp_task/pwr_ctrl.c
new file mode 100644
index 0000000..19bf0f2
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/firmware/scp_task/pwr_ctrl.c
@@ -0,0 +1,122 @@
+
+/*
+ * board/amlogic/txl_skt_v1/firmware/scp_task/pwr_ctrl.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifdef CONFIG_CEC_WAKEUP
+#include <cec_tx_reg.h>
+#endif
+#include <gpio-gxbb.h>
+
+static void power_off_at_clk81(void)
+{
+}
+static void power_on_at_clk81(void)
+{
+}
+
+static void power_off_at_24M(void)
+{
+}
+static void power_on_at_24M(void)
+{
+}
+
+static void power_off_at_32k(void)
+{
+}
+static void power_on_at_32k(void)
+{
+}
+
+void get_wakeup_source(void *response, unsigned int suspend_from)
+{
+	struct wakeup_info *p = (struct wakeup_info *)response;
+	unsigned val;
+
+	p->status = RESPONSE_OK;
+	val = REMOTE_WAKEUP_SRC;
+#ifdef CONFIG_CEC_WAKEUP
+	val |= CEC_WAKEUP_SRC;
+#endif
+	p->sources = val;
+	p->gpio_info_count = 0;
+}
+
+static unsigned int detect_key(unsigned int suspend_from)
+{
+	int exit_reason = 0;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
+	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
+
+	/* setup wakeup resources*/
+	init_remote();
+#ifdef CONFIG_CEC_WAKEUP
+	if (hdmi_cec_func_config & 0x1) {
+		remote_cec_hw_reset();
+		cec_node_init();
+	}
+#endif
+
+	/* *wakeup_en = 1;*/
+	do {
+#ifdef CONFIG_CEC_WAKEUP
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
+//			if (suspend_from == SYS_POWEROFF)
+//				continue;
+			if (cec_msg.log_addr) {
+				if (hdmi_cec_func_config & 0x1) {
+					cec_handler();
+					if (cec_msg.cec_power == 0x1) {
+						/*cec power key*/
+						exit_reason = CEC_WAKEUP;
+						break;
+					}
+				}
+			} else if (hdmi_cec_func_config & 0x1)
+				cec_node_init();
+		}
+#endif
+	if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+		irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
+			if (remote_detect_key())
+				exit_reason = REMOTE_WAKEUP;
+	}
+		if (exit_reason)
+			break;
+		else
+			asm volatile("wfi");
+	} while (1);
+
+	return exit_reason;
+}
+
+static void pwr_op_init(struct pwr_op *pwr_op)
+{
+	pwr_op->power_off_at_clk81 = power_off_at_clk81;
+	pwr_op->power_on_at_clk81 = power_on_at_clk81;
+	pwr_op->power_off_at_24M = power_off_at_24M;
+	pwr_op->power_on_at_24M = power_on_at_24M;
+	pwr_op->power_off_at_32k = power_off_at_32k;
+	pwr_op->power_on_at_32k = power_on_at_32k;
+
+	pwr_op->detect_key = detect_key;
+	pwr_op->get_wakeup_source = get_wakeup_source;
+}
diff --git a/board/amlogic/txl_p321_v1/firmware/timing.c b/board/amlogic/txl_p321_v1/firmware/timing.c
new file mode 100644
index 0000000..1c52562
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/firmware/timing.c
@@ -0,0 +1,579 @@
+
+/*
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/timing.h>
+#include <asm/arch/ddr_define.h>
+
+/* DDR freq range */
+#define CONFIG_DDR_CLK_LOW  20
+#define CONFIG_DDR_CLK_HIGH 1500
+/* DON'T OVER THESE RANGE */
+#if (CONFIG_DDR_CLK < CONFIG_DDR_CLK_LOW) || (CONFIG_DDR_CLK > CONFIG_DDR_CLK_HIGH)
+	#error "Over DDR PLL range! Please check CONFIG_DDR_CLK in board header file! \n"
+#endif
+
+/* CPU freq range */
+#define CONFIG_CPU_CLK_LOW  600
+#define CONFIG_CPU_CLK_HIGH 2000
+/* DON'T OVER THESE RANGE */
+#if (CONFIG_CPU_CLK < CONFIG_CPU_CLK_LOW) || (CONFIG_CPU_CLK > CONFIG_CPU_CLK_HIGH)
+	#error "Over CPU PLL range! Please check CONFIG_CPU_CLK in board header file! \n"
+#endif
+
+#define DDR3_DRV_40OHM		0
+#define DDR3_DRV_34OHM		1
+#define DDR3_ODT_0OHM		0
+#define DDR3_ODT_60OHM		1
+#define DDR3_ODT_120OHM		2
+#define DDR3_ODT_40OHM		3
+#define DDR3_ODT_20OHM		4
+#define DDR3_ODT_30OHM		5
+
+/* lpddr2 drv odt */
+#define LPDDR2_DRV_34OHM	1
+#define LPDDR2_DRV_40OHM	2
+#define LPDDR2_DRV_48OHM	3
+#define LPDDR2_DRV_60OHM	4
+#define LPDDR2_DRV_80OHM	6
+#define LPDDR2_DRV_120OHM	7
+#define LPDDR2_ODT_0OHM		0
+
+/* lpddr3 drv odt */
+#define LPDDR3_DRV_34OHM	1
+#define LPDDR3_DRV_40OHM	2
+#define LPDDR3_DRV_48OHM	3
+#define LPDDR3_DRV_60OHM	4
+#define LPDDR3_DRV_80OHM	6
+#define LPDDR3_DRV_34_40OHM	9
+#define LPDDR3_DRV_40_48OHM	10
+#define LPDDR3_DRV_34_48OHM	11
+#define LPDDR3_ODT_0OHM		0
+#define LPDDR3_ODT_60OHM	1
+#define LPDDR3_ODT_12OHM	2
+#define LPDDR3_ODT_240HM	3
+
+#define DDR4_DRV_34OHM		0
+#define DDR4_DRV_48OHM		1
+#define DDR4_ODT_0OHM		0
+#define DDR4_ODT_60OHM		1
+#define DDR4_ODT_120OHM		2
+#define DDR4_ODT_40OHM		3
+#define DDR4_ODT_240OHM		4
+#define DDR4_ODT_48OHM		5
+#define DDR4_ODT_80OHM		6
+#define DDR4_ODT_34OHM		7
+
+#if ((CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR3) || (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_AUTO))
+#define CFG_DDR_DRV  DDR3_DRV_34OHM
+#define CFG_DDR_ODT  DDR3_ODT_120OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR2)
+#define CFG_DDR_DRV  LPDDR2_DRV_48OHM
+#define CFG_DDR_ODT  DDR3_ODT_120OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR3)
+#define CFG_DDR_DRV  LPDDR3_DRV_48OHM
+#define CFG_DDR_ODT  LPDDR3_ODT_12OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR4)
+#define CFG_DDR_DRV  DDR4_DRV_34OHM //useless, no effect
+#define CFG_DDR_ODT  DDR4_ODT_60OHM //useless, no effect
+#endif
+
+#define CFG_DDR4_DRV  DDR4_DRV_48OHM//DDR4_DRV_48OHM //ddr4 driver use this one
+#define CFG_DDR4_ODT DDR4_ODT_60OHM// DDR4_ODT_80OHM //ddr4 driver use this one
+#define CONFIG_SOC_VREF      0// (738/12) //0 //0  is auto --70 ---range 44.07---88.04   %
+#define CONFIG_DRAM_VREF   0// (810/12) // 0 //77 //0 //0  is auto ---70 --range -- 45---92.50    %
+//#define CONFIG_ZQ_VREF   715/15//  60//0 //(50) % //tune ddr4 ,ddr3 use 0
+#define CONFIG_ZQ_VREF   51//60 //700/12//  60//0 //(50) % //tune ddr4 ,ddr3 use 0
+/*
+ * these parameters are corresponding to the pcb layout,
+ * please don't enable this function unless these signals
+ * has been measured by oscilloscope.
+ */
+#ifdef CONFIG_DDR_CMD_BDL_TUNE
+#define DDR_AC_LCDLR   0
+#define	DDR_CK0_BDL	18
+#define	DDR_RAS_BDL	18
+#define	DDR_CAS_BDL	24
+#define	DDR_WE_BDL	21
+#define	DDR_BA0_BDL	16
+#define	DDR_BA1_BDL	2
+#define	DDR_BA2_BDL	13
+#define	DDR_ACPDD_BDL	27
+#define	DDR_CS0_BDL	27
+#define	DDR_CS1_BDL	27
+#define	DDR_ODT0_BDL	27
+#define	DDR_ODT1_BDL	27
+#define	DDR_CKE0_BDL	27
+#define	DDR_CKE1_BDL	27
+#define	DDR_A0_BDL	14
+#define	DDR_A1_BDL	9
+#define	DDR_A2_BDL	5
+#define	DDR_A3_BDL	18
+#define	DDR_A4_BDL	4
+#define	DDR_A5_BDL	16
+#define	DDR_A6_BDL	1
+#define	DDR_A7_BDL	10
+#define	DDR_A8_BDL	4
+#define	DDR_A9_BDL	7
+#define	DDR_A10_BDL	10
+#define	DDR_A11_BDL	9
+#define	DDR_A12_BDL	6
+#define	DDR_A13_BDL	16
+#define	DDR_A14_BDL	8
+#define	DDR_A15_BDL	27
+#endif
+
+/* CAUTION!! */
+/*
+ * For DDR3:
+ *     7-7-7:    CONFIG_DDR_CLK range  375~ 533
+ *     9-9-9:    CONFIG_DDR_CLK range  533~ 667
+ *     11-11-11: CONFIG_DDR_CLK range  667~ 800
+ *     12-12-12: CONFIG_DDR_CLK range  800~ 933
+ *     13-13-13: CONFIG_DDR_CLK range  933~1066
+ *     14-14-14: CONFIG_DDR_CLK range 1066~1200
+ */
+ddr_timing_t __ddr_timming[] = {
+	//ddr3_7_7_7
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_7,
+		.cfg_ddr_rtp			= (6),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (7),
+		.cfg_ddr_rcd			= (7),
+		.cfg_ddr_ras			= (20),
+		.cfg_ddr_rrd			= (6),
+		.cfg_ddr_rc				= (27),
+		.cfg_ddr_mrd			= (4),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (27),
+		.cfg_ddr_rfc			= (160),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (6),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (4),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (7),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (5),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (4),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (512),
+		.cfg_ddr_xpdll			= (20),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_9_9_9
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_9,
+		.cfg_ddr_rtp			= (6),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (9),
+		.cfg_ddr_rcd			= (9),
+		.cfg_ddr_ras			= (27),
+		.cfg_ddr_rrd			= (6),
+		.cfg_ddr_rc				= (33),
+		.cfg_ddr_mrd			= (4),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (30),
+		.cfg_ddr_rfc			= (196),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (6),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (6),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (9),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (7),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (20),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_11_11_11
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_11,
+		.cfg_ddr_rtp			= (7),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (11),
+		.cfg_ddr_rcd			= (11),
+		.cfg_ddr_ras			= (35),
+		.cfg_ddr_rrd			= (7),
+		.cfg_ddr_rc				= (45),
+		.cfg_ddr_mrd			= (6),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (33),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (7),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (5),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (11),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (8),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_13_13_13
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_13,
+		.cfg_ddr_rtp			= (7),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (13),
+		.cfg_ddr_rcd			= (13),
+		.cfg_ddr_ras			= (37),
+		.cfg_ddr_rrd			= (7),
+		.cfg_ddr_rc				= (52),
+		.cfg_ddr_mrd			= (6),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (33),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (7),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (13),
+		.cfg_ddr_wr				= (16),
+		.cfg_ddr_cwl			= (9),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	/* ddr4 1600 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR4_1600,
+		.cfg_ddr_rtp			= (4),
+		.cfg_ddr_wtr			= (6),
+		.cfg_ddr_rp				= (11),
+		.cfg_ddr_rcd			= (11),
+		.cfg_ddr_ras			= (35),
+		.cfg_ddr_rrd			= (4),
+		.cfg_ddr_rc				= (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= (28),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (11),
+		.cfg_ddr_wr				= (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (5),
+	},
+	/* ddr4 2400 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR4_2400,
+		.cfg_ddr_rtp			= 9,//(4),
+		.cfg_ddr_wtr			= 9,//(6),
+		.cfg_ddr_rp				= 15*1.2,//(11),
+		.cfg_ddr_rcd			= 15*1.2,//(11),
+		.cfg_ddr_ras			= 35*1.2,//(35),
+		.cfg_ddr_rrd			= (8),
+		.cfg_ddr_rc				=50*1.2,// (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= 35*1.2,//(28),
+		.cfg_ddr_rfc			= 350*1.2,//(280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= 9.5*1.2,//(8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= 15*1.2,// (11),
+		.cfg_ddr_wr				= 15*1.2,// (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= 12,// (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (6),
+	},
+	/* lpddr3 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_LPDDR3,
+		.cfg_ddr_rtp			= (4),
+		.cfg_ddr_wtr			= (6),
+		.cfg_ddr_rp				= 15*1.2,//(11),
+		.cfg_ddr_rcd			= 15*1.2,//(11),
+		.cfg_ddr_ras			= 35*1.2,//(35),
+		.cfg_ddr_rrd			= (4),
+		.cfg_ddr_rc				= 50*1.2,// (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= 35*1.2,//(28),
+		.cfg_ddr_rfc			= 350*1.2,//(280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= 9.5*1.2,//(8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= 15*1.2,// (11),
+		.cfg_ddr_wr				= 15*1.2,// (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= 12,// (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (6),
+	}
+};
+
+ddr_set_t __ddr_setting = {
+	/* common and function defines */
+	.ddr_channel_set		= CONFIG_DDR_CHANNEL_SET,
+	.ddr_type				= CONFIG_DDR_TYPE,
+	.ddr_clk				= CONFIG_DDR_CLK,
+	.ddr4_clk				= CONFIG_DDR4_CLK,
+	.ddr_base_addr			= CFG_DDR_BASE_ADDR,
+	.ddr_start_offset		= CFG_DDR_START_OFFSET,
+	.ddr_timing_ind			= 0,
+	.ddr_size				= CONFIG_DDR_SIZE,
+	.ddr_pll_ctrl			= (0),
+	.ddr_dmc_ctrl			= 0,
+	.ddr0_addrmap			= {0},
+	.ddr1_addrmap			= {0},
+	.ddr_2t_mode			= 1,
+	.ddr_full_test			= CONFIG_DDR_FULL_TEST,
+#if (0 == CONFIG_DDR_SIZE)
+	.ddr_size_detect		= 1,
+#else
+	.ddr_size_detect		= 0,
+#endif
+	.ddr_drv				= CFG_DDR_DRV,
+	.ddr_odt				= CFG_DDR_ODT,
+	.ddr4_drv				= CFG_DDR4_DRV,
+	.ddr4_odt				= CFG_DDR4_ODT,
+
+	/* pub defines */
+	.t_pub_ptr				= {
+							[0] = ( 6 | (320 << 6) | (80 << 21)),
+							[1] = (120 | (1000 << 16)),
+							[2] = 0,
+							[3] = (20000 | (136 << 20)),
+							[4] = (1000 | (180 << 16)),
+							},  //PUB PTR0-3
+	.t_pub_odtcr			= 0x00030000,
+	.t_pub_mr				= {
+							(0X0 | (0X1 << 2) | (0X0 << 3) | (0X0 << 4) | (0X0 << 7) | (0X0 << 8) | (0X7 << 9) | (1 << 12)),
+							(0X6|(1<<6)),
+							0X20,
+							0,
+							},
+	.t_pub_dtpr				= {0},
+	.t_pub_pgcr0			= 0x07d81e3f,   //PUB PGCR0
+	.t_pub_pgcr1			= 0x02004620,   //PUB PGCR1
+	.t_pub_pgcr2			= 0x00f05f97,   //PUB PGCR2
+	//.t_pub_pgcr2			= 0x01f12480,   //PUB PGCR2
+	.t_pub_pgcr3			= 0xc0aae860,   //PUB PGCR3
+	.t_pub_dxccr			= 0x20c01ee4,   //PUB DXCCR
+	.t_pub_aciocr			= {0},  //PUB ACIOCRx
+	.t_pub_dx0gcr			= {0},  //PUB DX0GCRx
+	.t_pub_dx1gcr			= {0},  //PUB DX1GCRx
+	.t_pub_dx2gcr			= {0},  //PUB DX2GCRx
+	.t_pub_dx3gcr			= {0},  //PUB DX3GCRx
+#if (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR3)
+	.t_pub_dcr				= 0XB,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,    //PUB DTCR
+	.t_pub_dsgcr			= 0x020641b,
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR4)
+	.t_pub_dcr				= 0X40C,     //PUB DCR
+	.t_pub_dtcr0			= 0x800031c7,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,
+	.t_pub_dsgcr			= 0x020641b|(1<<2)|(1<<23),
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR3)
+	.t_pub_dcr				= 0X89,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,
+	.t_pub_dsgcr			= 0x02064db,
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_AUTO)
+	.t_pub_dcr				= 0XB,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,    //PUB DTCR
+	.t_pub_dsgcr			= 0x020641b,
+#endif
+	.t_pub_vtcr1			= 0x0fc00172,
+	.t_pub_dtar				= (0X0 | (0X0 <<12) | (0 << 28)),
+	//.t_pub_zq0pr			= 0x7b,   //PUB ZQ0PR
+	//.t_pub_zq1pr			= 0x7b,   //PUB ZQ1PR
+	//.t_pub_zq2pr			= 0x7b,   //PUB ZQ2PR
+	//.t_pub_zq3pr			= 0x7b,   //PUB ZQ3PR  zqvref 0x13
+	//.t_pub_zq0pr			= 0x5aa59,   //PUB ZQ0PR, 0x5aa59,0x59959,  0x58859,  //99drriver s912 ddr4 maybe 950m is bad
+	//.t_pub_zq1pr			= 0x3f95d,   //PUB ZQ1PR//0x3f95d, 0x4f95d,
+	//.t_pub_zq2pr			= 0x3f95d,   //PUB ZQ2PR//0x3f95d, 0x4f95d,
+	.t_pub_zq3pr			= 0x1dd1d,   //PUB ZQ3PR
+
+	.t_pub_zq0pr			= 0x0000bf59,   //PUB ZQ0PR, 0x5aa59,0x59959,  0x58859,  //99drriver s912 ddr4 maybe 950m is bad
+	.t_pub_zq1pr			= 0x0002fc5d,   //PUB ZQ1PR//0x3f95d, 0x4f95d,
+	.t_pub_zq2pr			= 0x0002fc5d,   //PUB ZQ2PR//0x3f95d, 0x4f95d,
+	//.t_pub_zq3pr			= 0xf5f95d,   //PUB ZQ3PR
+
+	/* pctl0 defines */
+	/* pctl1 use same define as pctl0 */
+	.t_pctl0_1us_pck		= CONFIG_DDR_CLK / 2,   //PCTL TOGCNT1U
+	.t_pctl0_100ns_pck		= CONFIG_DDR_CLK / 20, //PCTL TOGCNT100N
+	.t_pctl0_init_us		= 2,   //PCTL TINIT
+	.t_pctl0_rsth_us		= 2,   //PCTL TRSTH
+	.t_pctl0_mcfg			= 0XA2F01,   //PCTL MCFG default 1T
+	//.t_pctl0_mcfg1			= 0X80000000,  //PCTL MCFG1
+	.t_pctl0_mcfg1			= 0, //[B10,B9,B8] tfaw_cfg_offset
+								//tFAW= (4 + MCFG.tfaw_cfg)*tRRD - tfaw_cfg_offset,  //PCTL MCFG1
+	.t_pctl0_scfg			= 0xF01,   //PCTL SCFG
+	.t_pctl0_sctl			= 0x1,   //PCTL SCTL
+	.t_pctl0_ppcfg			= 0,
+	.t_pctl0_dfistcfg0		= 0x4,
+	.t_pctl0_dfistcfg1		= 0x1,
+	.t_pctl0_dfitctrldelay	= 2,
+	.t_pctl0_dfitphywrdata	= 2,
+	.t_pctl0_dfitphywrlta	= 7,
+	.t_pctl0_dfitrddataen	= 8,
+	.t_pctl0_dfitphyrdlat	= 22,
+	.t_pctl0_dfitdramclkdis	= 1,
+	.t_pctl0_dfitdramclken	= 1,
+	.t_pctl0_dfitphyupdtype0 = 16,
+	.t_pctl0_dfitphyupdtype1 = 16,
+	.t_pctl0_dfitctrlupdmin	= 16,
+	.t_pctl0_dfitctrlupdmax	= 64,
+	.t_pctl0_dfiupdcfg		= 0x3,
+	.t_pctl0_cmdtstaten		= 1,
+	//.t_pctl0_dfiodtcfg		= 8,
+	//.t_pctl0_dfiodtcfg1		= ( 0x0 | (0x6 << 16) ),
+	.t_pctl0_dfiodtcfg		= (1<<3)|(1<<11),
+	.t_pctl0_dfiodtcfg1		= (0x0 | (0x6 << 16)),
+
+	.t_pctl0_dfilpcfg0		= ( 1 | (3 << 4) | (1 << 8) | (13 << 12) | (7 <<16) | (1 <<24) | ( 3 << 28)),
+	.t_pub_acbdlr0			= 0x3f,
+	.t_pub_aclcdlr			= 0x28,//0x18,   ///1t  ,if 2t can add some value
+	.t_pub_acbdlr3			= 0x0,//0xa,  //cs
+	//.t_pub_acbdlr0		= 0x0,
+	//.t_pub_aclcdlr		= 0x10,//0x18,   ///1t  ,if 2t can add some value
+	//.t_pub_acbdlr3		= 0x14,//0xa,  //cs
+	.t_pub_soc_vref_dram_vref =((((CONFIG_SOC_VREF<45)?(0):((((CONFIG_SOC_VREF*1000-44070)/698)>0X3F)?(0X3F):(((CONFIG_SOC_VREF*1000-44070)/698))))<<8)|(
+	(((CONFIG_DRAM_VREF))<45)?(0):((((CONFIG_DRAM_VREF))<61)?((((((CONFIG_DRAM_VREF*1000-45000)/650)>0X32)?(0X32):(((CONFIG_DRAM_VREF*1000-45000)/650)))|(1<<6))):
+	((((CONFIG_DRAM_VREF*1000-60000)/650)>0X32)?(0X32):(((CONFIG_DRAM_VREF*1000-60000)/650)))))),
+	.t_pub_mr[7]	= ((CONFIG_ZQ_VREF<45)?(0):((((CONFIG_ZQ_VREF*1000-44070)/698)>0X3F)?(0X3F):(((CONFIG_ZQ_VREF*1000-44070)/698)))) ,//jiaxing use for tune zq vref 20160608
+	.ddr_func				= DDR_FUNC, /* ddr func demo 2016.01.26 */
+
+	.wr_adj_per 			= {
+							[0] = 100,
+							[1] = 100,
+							[2] = 100,
+							[3] = 100,
+							[4] = 100,
+							[5] = 100,
+							},
+	.rd_adj_per				= {
+							[0] = 100,
+							[1] = 100,
+							[2] = 100,
+							[3] = 100,
+							[4] = 100,
+							[5] = 100,},
+};
+
+pll_set_t __pll_setting = {
+	.cpu_clk				= CONFIG_CPU_CLK / 24 * 24,
+	.spi_ctrl				= 0,
+	.lCustomerID			= CONFIG_AML_CUSTOMER_ID,
+#ifdef CONFIG_DEBUG_MODE
+	.debug_mode				= CONFIG_DEBUG_MODE,
+	.ddr_clk_debug			= CONFIG_DDR_CLK_DEBUG,
+	.cpu_clk_debug			= CONFIG_CPU_CLK_DEBUG,
+#endif
+};
diff --git a/board/amlogic/txl_p321_v1/lcd.c b/board/amlogic/txl_p321_v1/lcd.c
new file mode 100644
index 0000000..b35f826
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/lcd.c
@@ -0,0 +1,301 @@
+/*
+ * AMLOGIC TV LCD panel driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <amlogic/aml_lcd.h>
+#include <asm/arch/gpio.h>
+
+//Rsv_val = 0xffffffff
+
+static char lcd_cpu_gpio[LCD_CPU_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX] = {
+	"GPIOH_7",
+	"GPIOZ_3",
+	"GPIOH_4",
+	"GPIOH_5",
+	"GPIOH_6",
+	"invalid", /* ending flag */
+};
+
+static struct lcd_power_step_s lcd_power_on_step[] = {
+	{LCD_POWER_TYPE_CPU,   0,1,20,}, /* power on */
+	{LCD_POWER_TYPE_SIGNAL,0,0,0,},  /* signal */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},  /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_off_step[] = {
+	{LCD_POWER_TYPE_SIGNAL,0,0,20,},  /* signal */
+	{LCD_POWER_TYPE_CPU,   0,0,100,}, /* power off */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},   /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_on_step_3d_disable[] = {
+	{LCD_POWER_TYPE_CPU,   0,1,20,}, /* power on */
+	{LCD_POWER_TYPE_CPU,   4,0,10,}, /* 3d_disable */
+	{LCD_POWER_TYPE_SIGNAL,0,0,0,},  /* signal */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},  /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_off_step_3d_disable[] = {
+	{LCD_POWER_TYPE_SIGNAL,0,0,20,},  /* signal */
+	{LCD_POWER_TYPE_CPU,   4,2,0,},   /* 3d_disable */
+	{LCD_POWER_TYPE_CPU,   0,0,100,}, /* power off */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},   /* ending flag */
+};
+
+static char lcd_bl_gpio[BL_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX] = {
+	"GPIOZ_2",
+	"GPIOZ_6",
+	"GPIOZ_7",
+	"invalid", /* ending flag */
+};
+
+struct ext_lcd_config_s ext_lcd_config[LCD_NUM_MAX] = {
+	{"lvds_0",LCD_LVDS,8,
+	/* basic timing */
+	1920,1080,2200,1125,44,148,0,5,30,0,
+	/* clk_attr */
+	0,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* lvds_attr */
+	1,1,0,0,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{"lvds_1",LCD_LVDS,8,
+	/* basic timing */
+	1920,1080,2200,1125,44,148,0,5,30,0,
+	/* clk_attr */
+	1,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* lvds_attr */
+	1,1,0,0,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*public vx1 : 3840x2160@60hz 8lane */
+	"vbyone_0",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,65,0,
+	/* clk_attr */
+	0,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*LG: RDL550WY: 3840x2160@60hz 8lane */
+	"vbyone_1",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,65,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*INL: V580DJ2: 3840x2160@60hz 8lane */
+	"vbyone_2",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,65,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,1,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*BOE: HV550QU2: 3840x2160@60hz 8lane */
+	"vbyone_3",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,1,6,65,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step_3d_disable, lcd_power_off_step_3d_disable,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+};
+
+//**** Special parameters just for Vbyone ***//
+static struct vbyone_config_s lcd_vbyone_config = {
+	.lane_count   = 8,
+	.byte_mode    = 4,
+	.region_num   = 2,
+	.color_fmt    = 4,
+};
+
+//**** Special parameters just for lvds ***//
+static struct lvds_config_s lcd_lvds_config = {
+	.lvds_repack  = 1, //0=JEDIA mode,  1=VESA mode
+	.dual_port    = 1, //0=single port, 1=double port
+	.pn_swap      = 0, //0=normal,      1=swap
+	.port_swap    = 0, //0=normal,      1=swap
+};
+
+static struct lcd_power_ctrl_s lcd_power_ctrl = {
+	.power_on_step = {
+		{
+			.type = LCD_POWER_TYPE_CPU,
+			.index = 0, /* point to cpu_gpio[] struct */
+			.value = 1, /* 0=output_low, 1=output_high, 2=input */
+			.delay = 20, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_SIGNAL,
+			.delay = 0, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_MAX, /* ending flag */
+		},
+	},
+	.power_off_step = {
+		{
+			.type = LCD_POWER_TYPE_SIGNAL,
+			.delay = 20, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_CPU,
+			.index = 0, /* point to cpu_gpio[] struct */
+			.value = 0, /* 0=output_low, 1=output_high, 2=input */
+			.delay = 100, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_MAX, /* ending flag */
+		},
+	},
+};
+
+struct lcd_config_s lcd_config_dft = {
+	.lcd_mode = LCD_MODE_TV,
+	.lcd_basic = {
+		.model_name = "default",
+		.lcd_type = LCD_TYPE_MAX, //LCD_TTL /LCD_LVDS/LCD_VBYONE
+		.lcd_bits = 8,
+		.h_active = 1920,
+		.v_active = 1080,
+		.h_period = 2200,
+		.v_period = 1125,
+
+		.screen_width   = 16,
+		.screen_height  = 9,
+	},
+
+	.lcd_timing = {
+		.clk_auto = 1,
+		.lcd_clk = 60,
+		.ss_level = 0,
+		.fr_adjust_type = 0,
+
+		.hsync_width = 44,
+		.hsync_bp    = 148,
+		.hsync_pol   = 0,
+		.vsync_width = 5,
+		.vsync_bp    = 36,
+		.vsync_pol   = 0,
+	},
+
+	.lcd_control = {
+		.lvds_config   = &lcd_lvds_config,
+		.vbyone_config = &lcd_vbyone_config,
+	},
+	.lcd_power = &lcd_power_ctrl,
+	.pinmux_set = {{0, 0xc0000000}, {LCD_PINMUX_END, 0x0}},
+	.pinmux_clr = {{LCD_PINMUX_END, 0x0}},
+};
+
+struct bl_config_s bl_config_dft = {
+	.name = "default",
+	.level_default = 100,
+	.level_min = 10,
+	.level_max = 255,
+	.level_mid = 128,
+	.level_mid_mapping = 128,
+	.level = 0,
+
+	.method = BL_CTRL_MAX,
+	.power_on_delay = 200,
+	.power_off_delay = 200,
+
+	.en_gpio = 0xff,
+	.en_gpio_on = 1,
+	.en_gpio_off = 0,
+
+	.bl_pwm = NULL,
+	.bl_pwm_combo0 = NULL,
+	.bl_pwm_combo1 = NULL,
+	.pwm_on_delay = 10,
+	.pwm_off_delay = 10,
+
+	.pinmux_set = {{4, 0x00010000}, {LCD_PINMUX_END, 0x0}},
+	.pinmux_clr = {{4, 0x00008000}, {3, 0x00200000}, {LCD_PINMUX_END, 0x0}},
+};
+
+void lcd_config_gpio_init(void)
+{
+	int i, j;
+
+	for (i = 0; i < LCD_CPU_GPIO_NUM_MAX; i++) {
+		if (strcmp(lcd_cpu_gpio[i], "invalid") == 0)
+			break;
+		strcpy(lcd_power_ctrl.cpu_gpio[i], lcd_cpu_gpio[i]);
+	}
+	for (j = i; j < LCD_CPU_GPIO_NUM_MAX; j++)
+		strcpy(lcd_power_ctrl.cpu_gpio[j], "invalid");
+	for (i = 0; i < BL_GPIO_NUM_MAX; i++) {
+		if (strcmp(lcd_bl_gpio[i], "invalid") == 0)
+			break;
+		strcpy(bl_config_dft.gpio_name[i], lcd_bl_gpio[i]);
+	}
+	for (j = i; j < BL_GPIO_NUM_MAX; j++)
+		strcpy(bl_config_dft.gpio_name[j], "invalid");
+}
diff --git a/board/amlogic/txl_p321_v1/txl_p321_v1.c b/board/amlogic/txl_p321_v1/txl_p321_v1.c
new file mode 100644
index 0000000..06461a7
--- /dev/null
+++ b/board/amlogic/txl_p321_v1/txl_p321_v1.c
@@ -0,0 +1,573 @@
+
+/*
+ * board/amlogic/txl_skt_v1/txl_skt_v1.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <asm/cpu_id.h>
+#ifdef CONFIG_SYS_I2C_AML
+#include <aml_i2c.h>
+#include <asm/arch/secure_apb.h>
+#endif
+#ifdef CONFIG_AML_VPU
+#include <vpu.h>
+#endif
+#include <vpp.h>
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+#include <amlogic/aml_v2_burning.h>
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+#ifdef CONFIG_AML_HDMITX20
+#include <amlogic/hdmi.h>
+#endif
+#ifdef CONFIG_AML_LCD
+#include <amlogic/aml_lcd.h>
+#endif
+#include <asm/arch/eth_setup.h>
+#include <phy.h>
+#include <asm-generic/gpio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+//new static eth setup
+struct eth_board_socket*  eth_board_skt;
+
+
+int serial_set_pin_port(unsigned long port_base)
+{
+    //UART in "Always On Module"
+    //GPIOAO_0==tx,GPIOAO_1==rx
+    //setbits_le32(P_AO_RTI_PIN_MUX_REG,3<<11);
+    return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+/* secondary_boot_func
+ * this function should be write with asm, here, is is only for compiling pass
+ * */
+void secondary_boot_func(void)
+{
+}
+void internalPhyConfig(struct phy_device *phydev)
+{
+	/*Enable Analog and DSP register Bank access by*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0000);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0400);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0000);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0400);
+	/*Write Analog register 23*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x8E0D);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x4417);
+	/*Enable fractional PLL*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x0005);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1B);
+	//Programme fraction FR_PLL_DIV1
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x029A);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1D);
+	//## programme fraction FR_PLL_DiV1
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0xAAAA);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1C);
+}
+
+
+static void setup_net_chip(void)
+{
+	eth_aml_reg0_t eth_reg0;
+
+	eth_reg0.d32 = 0;
+	eth_reg0.b.phy_intf_sel = 0;
+	eth_reg0.b.data_endian = 0;
+	eth_reg0.b.desc_endian = 0;
+	eth_reg0.b.rx_clk_rmii_invert = 0;
+	eth_reg0.b.rgmii_tx_clk_src = 0;
+	eth_reg0.b.rgmii_tx_clk_phase = 0;
+	eth_reg0.b.rgmii_tx_clk_ratio = 0;
+	eth_reg0.b.phy_ref_clk_enable = 0;
+	eth_reg0.b.clk_rmii_i_invert = 1;
+	eth_reg0.b.clk_en = 1;
+	eth_reg0.b.adj_enable = 0;
+	eth_reg0.b.adj_setup = 0;
+	eth_reg0.b.adj_delay = 0;
+	eth_reg0.b.adj_skew = 0;
+	eth_reg0.b.cali_start = 0;
+	eth_reg0.b.cali_rise = 0;
+	eth_reg0.b.cali_sel = 0;
+	eth_reg0.b.rgmii_rx_reuse = 0;
+	eth_reg0.b.eth_urgent = 0;
+	setbits_le32(P_PREG_ETH_REG0, eth_reg0.d32);// rmii mode
+	*P_PREG_ETH_REG2 = 0x10110181;
+	*P_PREG_ETH_REG3 = 0xe409087f;
+	setbits_le32(HHI_GCLK_MPEG1,1<<3);
+	/* power on memory */
+	clrbits_le32(HHI_MEM_PD_REG0, (1 << 3) | (1<<2));
+
+}
+
+extern struct eth_board_socket* eth_board_setup(char *name);
+extern int designware_initialize(ulong base_addr, u32 interface);
+
+int board_eth_init(bd_t *bis)
+{
+	setup_net_chip();
+	udelay(1000);
+	designware_initialize(ETH_BASE, PHY_INTERFACE_MODE_RMII);
+	return 0;
+}
+
+#if CONFIG_AML_SD_EMMC
+#include <mmc.h>
+#include <asm/arch/sd_emmc.h>
+static int  sd_emmc_init(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+			//todo add card detect
+			//setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+			break;
+		case SDIO_PORT_C:
+			//enable pull up
+			//clrbits_le32(P_PAD_PULL_UP_REG3, 0xff<<0);
+			break;
+		default:
+			break;
+	}
+
+	return cpu_sd_emmc_init(port);
+}
+
+extern unsigned sd_debug_board_1bit_flag;
+static int  sd_emmc_detect(unsigned port)
+{
+	int ret;
+    switch (port) {
+
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+			setbits_le32(P_PREG_PAD_GPIO2_EN_N, 1 << 26);//CARD_6
+			ret = readl(P_PREG_PAD_GPIO2_I) & (1 << 26) ? 0 : 1;
+			printf("%s\n", ret ? "card in" : "card out");
+			if ((readl(P_PERIPHS_PIN_MUX_6) & (3 << 8))) { //if uart pinmux set, debug board in
+				if (!(readl(P_PREG_PAD_GPIO2_I) & (1 << 24))) {
+					printf("sdio debug board detected, sd card with 1bit mode\n");
+					sd_debug_board_1bit_flag = 1;
+				}
+				else{
+					printf("sdio debug board detected, no sd card in\n");
+					sd_debug_board_1bit_flag = 0;
+					return 1;
+				}
+			}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void sd_emmc_pwr_prepare(unsigned port)
+{
+	cpu_sd_emmc_pwr_prepare(port);
+}
+
+static void sd_emmc_pwr_on(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            clrbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			/// @todo NOT FINISH
+			break;
+		case SDIO_PORT_C:
+			break;
+		default:
+			break;
+	}
+	return;
+}
+static void sd_emmc_pwr_off(unsigned port)
+{
+	/// @todo NOT FINISH
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            setbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			break;
+		case SDIO_PORT_C:
+			break;
+				default:
+			break;
+	}
+	return;
+}
+
+// #define CONFIG_TSD      1
+static void board_mmc_register(unsigned port)
+{
+	struct aml_card_sd_info *aml_priv=cpu_sd_emmc_get(port);
+    if (aml_priv == NULL)
+		return;
+
+	aml_priv->sd_emmc_init=sd_emmc_init;
+	aml_priv->sd_emmc_detect=sd_emmc_detect;
+	aml_priv->sd_emmc_pwr_off=sd_emmc_pwr_off;
+	aml_priv->sd_emmc_pwr_on=sd_emmc_pwr_on;
+	aml_priv->sd_emmc_pwr_prepare=sd_emmc_pwr_prepare;
+	aml_priv->desc_buf = malloc(NEWSD_MAX_DESC_MUN*(sizeof(struct sd_emmc_desc_info)));
+
+	if (NULL == aml_priv->desc_buf)
+		printf(" desc_buf Dma alloc Fail!\n");
+	else
+		printf("aml_priv->desc_buf = 0x%p\n",aml_priv->desc_buf);
+
+	sd_emmc_register(aml_priv);
+}
+int board_mmc_init(bd_t	*bis)
+{
+#ifdef CONFIG_VLSI_EMULATOR
+	//board_mmc_register(SDIO_PORT_A);
+#else
+	//board_mmc_register(SDIO_PORT_B);
+#endif
+	board_mmc_register(SDIO_PORT_B);
+	board_mmc_register(SDIO_PORT_C);
+//	board_mmc_register(SDIO_PORT_B1);
+	return 0;
+}
+
+#ifdef CONFIG_SYS_I2C_AML
+#if 0
+static void board_i2c_set_pinmux(void){
+	/*********************************************/
+	/*                | I2C_Master_AO        |I2C_Slave            |       */
+	/*********************************************/
+	/*                | I2C_SCK                | I2C_SCK_SLAVE  |      */
+	/* GPIOAO_4  | [AO_PIN_MUX: 6]     | [AO_PIN_MUX: 2]   |     */
+	/*********************************************/
+	/*                | I2C_SDA                 | I2C_SDA_SLAVE  |     */
+	/* GPIOAO_5  | [AO_PIN_MUX: 5]     | [AO_PIN_MUX: 1]   |     */
+	/*********************************************/
+
+	//disable all other pins which share with I2C_SDA_AO & I2C_SCK_AO
+	clrbits_le32(P_AO_RTI_PIN_MUX_REG, ((1<<2)|(1<<24)|(1<<1)|(1<<23)));
+	//enable I2C MASTER AO pins
+	setbits_le32(P_AO_RTI_PIN_MUX_REG,
+	(MESON_I2C_MASTER_AO_GPIOAO_4_BIT | MESON_I2C_MASTER_AO_GPIOAO_5_BIT));
+
+	udelay(10);
+};
+#endif
+struct aml_i2c_platform g_aml_i2c_plat = {
+	.wait_count         = 1000000,
+	.wait_ack_interval  = 5,
+	.wait_read_interval = 5,
+	.wait_xfer_interval = 5,
+	.master_no          = AML_I2C_MASTER_AO,
+	.use_pio            = 0,
+	.master_i2c_speed   = AML_I2C_SPPED_400K,
+	.master_ao_pinmux = {
+		.scl_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_4_REG,
+		.scl_bit    = MESON_I2C_MASTER_AO_GPIOAO_4_BIT,
+		.sda_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_5_REG,
+		.sda_bit    = MESON_I2C_MASTER_AO_GPIOAO_5_BIT,
+	}
+};
+#if 0
+static void board_i2c_init(void)
+{
+	//set I2C pinmux with PCB board layout
+	board_i2c_set_pinmux();
+
+	//Amlogic I2C controller initialized
+	//note: it must be call before any I2C operation
+	aml_i2c_init();
+
+	udelay(10);
+}
+#endif
+#endif
+#endif
+
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+int board_early_init_f(void){
+	/*add board early init function here*/
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_XHCI_AMLOGIC_GXL
+#include <asm/arch/usb-new.h>
+#include <asm/arch/gpio.h>
+#define CONFIG_GXL_USB_U2_PORT_NUM	4
+#define CONFIG_GXL_USB_U3_PORT_NUM	0
+
+struct amlogic_usb_config g_usb_config_GXL_skt={
+	CONFIG_GXL_XHCI_BASE,
+	USB_ID_MODE_HARDWARE,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	CONFIG_GXL_USB_PHY2_BASE,
+	CONFIG_GXL_USB_PHY3_BASE,
+	CONFIG_GXL_USB_U2_PORT_NUM,
+	CONFIG_GXL_USB_U3_PORT_NUM,
+};
+#endif /*CONFIG_USB_XHCI_AMLOGIC*/
+
+#ifdef CONFIG_AML_HDMITX20
+static void hdmi_tx_set_hdmi_5v(void)
+{
+}
+#endif
+
+/*USE_HDMI_UART_FUNC*/
+#define HDMI_UART_PORT_NUM   3
+
+struct hdmi_uart_date_io {
+	char *power;
+	char *scl;
+	volatile uint32_t * hdmi_sda_reg;
+	unsigned int hdmi_sda_bit;
+	volatile uint32_t * uart_tx_reg;
+	unsigned int uart_tx_bit;
+	volatile uint32_t * hdmi_scl_reg;
+	unsigned int hdmi_scl_bit;
+	volatile uint32_t * uart_rx_reg;
+	unsigned int uart_rx_bit;
+};
+
+struct hdmi_uart_date_io txl_hdmi_uart_date_io[HDMI_UART_PORT_NUM+1]=
+{
+	{"GPIOW_5" ,"GPIOW_7" ,P_PERIPHS_PIN_MUX_5,25,P_PERIPHS_PIN_MUX_5,13,P_PERIPHS_PIN_MUX_5 ,24 ,P_PERIPHS_PIN_MUX_5,12,},
+	{"GPIOW_9", "GPIOW_11",P_PERIPHS_PIN_MUX_5,21,P_PERIPHS_PIN_MUX_5,11,P_PERIPHS_PIN_MUX_5 ,20 ,P_PERIPHS_PIN_MUX_5,10,},
+	{"GPIOW_13","GPIOW_15",P_PERIPHS_PIN_MUX_5,17,P_PERIPHS_PIN_MUX_5,9, P_PERIPHS_PIN_MUX_5 ,16 ,P_PERIPHS_PIN_MUX_5,8,},
+	{NULL,      NULL,      0,                   0,P_AO_RTI_PIN_MUX_REG,12,0 ,                   0 ,P_AO_RTI_PIN_MUX_REG,11,},
+};
+
+struct hdmi_uart_date_io gxtvbb_hdmi_uart_date_io[HDMI_UART_PORT_NUM+1]=
+{
+	{"GPIOW_6" ,"GPIOW_5" ,P_PERIPHS_PIN_MUX_6 ,9  ,P_PERIPHS_PIN_MUX_10,1,P_PERIPHS_PIN_MUX_6 ,10 ,P_PERIPHS_PIN_MUX_6,11,},
+	{"GPIOW_10","GPIOW_9" ,P_PERIPHS_PIN_MUX_6 ,14 ,P_PERIPHS_PIN_MUX_10,2,P_PERIPHS_PIN_MUX_6 ,15 ,P_PERIPHS_PIN_MUX_6,16,},
+	{"GPIOW_14","GPIOW_13",P_PERIPHS_PIN_MUX_6 ,19 ,P_PERIPHS_PIN_MUX_10,3,P_PERIPHS_PIN_MUX_6 ,20 ,P_PERIPHS_PIN_MUX_6,21,},
+	{NULL,      NULL,      0,                   0  ,P_AO_RTI_PIN_MUX_REG,0,0 ,                   0 ,P_AO_RTI_PIN_MUX_REG,1,},
+};
+
+struct hdmi_uart_det_io {
+	char *power;
+	char *scl;
+	volatile uint32_t * uart_det_power_reg;
+	unsigned int uart_det_power_bit;
+	unsigned int uart_det_power_need_level;
+	volatile uint32_t * uart_det_scl_reg;
+	unsigned int uart_det_scl_bit;
+	unsigned int uart_det_scl_need_level;
+};
+
+struct hdmi_uart_det_io txl_hdmi_uart_det_io[HDMI_UART_PORT_NUM]=
+{
+	{"GPIOW_5" , "GPIOW_7" ,  P_PREG_PAD_GPIO4_I , 5 , 0, P_PREG_PAD_GPIO4_I ,7 , 1,},
+	{"GPIOW_9",  "GPIOW_11",  P_PREG_PAD_GPIO4_I , 9 , 0, P_PREG_PAD_GPIO4_I ,11, 1,},
+	{"GPIOW_13", "GPIOW_15" , P_PREG_PAD_GPIO4_I , 13, 0, P_PREG_PAD_GPIO4_I ,15, 1,},
+};
+
+/* in gxtvbb,use hpd port as (txl)scl port */
+struct hdmi_uart_det_io gxtvbb_hdmi_uart_det_io[HDMI_UART_PORT_NUM]=
+{
+	{"GPIOW_6" ,"GPIOW_5" , P_PREG_PAD_GPIO0_I, 6 , 0, P_PREG_PAD_GPIO0_I ,5 , 1,},
+	{"GPIOW_10","GPIOW_9" , P_PREG_PAD_GPIO0_I, 10, 0, P_PREG_PAD_GPIO0_I ,9 , 1,},
+	{"GPIOW_14","GPIOW_13", P_PREG_PAD_GPIO0_I, 14, 0, P_PREG_PAD_GPIO0_I ,13, 1,},
+};
+
+static void init_hdmi_uart_board(void)
+{
+	int i=0;
+	int pwr_value=0,scl_value=0;
+	int flag=0;
+	struct hdmi_uart_date_io *hdmi_uart_date_io;
+	struct hdmi_uart_det_io  *hdmi_uart_det_io;
+
+	if (get_cpu_id().family_id <= MESON_CPU_MAJOR_ID_GXTVBB) {
+		hdmi_uart_det_io  = gxtvbb_hdmi_uart_det_io;
+		hdmi_uart_date_io = gxtvbb_hdmi_uart_date_io;
+		/*printf("choose gxtvbb board.\n");*/
+	} else {
+		hdmi_uart_det_io  = txl_hdmi_uart_det_io;
+		hdmi_uart_date_io = txl_hdmi_uart_date_io;
+		/*printf("choose txl board.\n");*/
+	}
+
+	for (i=0; i<HDMI_UART_PORT_NUM; i++) {
+		pwr_value = readl(hdmi_uart_det_io[i].uart_det_power_reg) >> hdmi_uart_det_io[i].uart_det_power_bit;
+		pwr_value &= 1;
+		scl_value = readl(hdmi_uart_det_io[i].uart_det_scl_reg) >> hdmi_uart_det_io[i].uart_det_scl_bit;
+		scl_value &= 1;
+
+		if ((pwr_value == hdmi_uart_det_io[i].uart_det_power_need_level)
+			&& (scl_value == hdmi_uart_det_io[i].uart_det_scl_need_level)) {
+			flag = 1;
+			break;
+		}
+	}
+
+	if (flag == 1) {
+		printf("switch to %d hdmirx_uart port\n",i);
+        /* clean default uart pinmux */
+        writel(readl(hdmi_uart_date_io[3].uart_tx_reg)&~(1 << hdmi_uart_date_io[3].uart_tx_bit),
+			(volatile void *)hdmi_uart_date_io[3].uart_tx_reg);
+        writel(readl(hdmi_uart_date_io[3].uart_rx_reg)&~(1 << hdmi_uart_date_io[3].uart_rx_bit),
+			(volatile void *)hdmi_uart_date_io[3].uart_rx_reg);
+
+        /* set hdmi_uart pinmux */
+		writel(readl(hdmi_uart_date_io[i].hdmi_sda_reg)&~(1 << hdmi_uart_date_io[i].hdmi_sda_bit),
+			(volatile void *)hdmi_uart_date_io[i].hdmi_sda_reg);
+		writel(readl(hdmi_uart_date_io[i].uart_tx_reg)|(1 << hdmi_uart_date_io[i].uart_tx_bit),
+			(volatile void *)hdmi_uart_date_io[i].uart_tx_reg);
+
+		writel(readl(hdmi_uart_date_io[i].hdmi_scl_reg)&~(1 << hdmi_uart_date_io[i].hdmi_scl_bit),
+			(volatile void *)hdmi_uart_date_io[i].hdmi_scl_reg);
+		writel(readl(hdmi_uart_date_io[i].uart_rx_reg)|(1 << hdmi_uart_date_io[i].uart_rx_bit),
+			(volatile void *)hdmi_uart_date_io[i].uart_rx_reg);
+	}
+}
+/*endif*/
+
+int board_init(void)
+{
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	aml_try_factory_usb_burning(0, gd->bd);
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+#ifdef CONFIG_USB_XHCI_AMLOGIC_GXL
+	board_usb_init(&g_usb_config_GXL_skt,BOARD_USB_MODE_HOST);
+#endif /*CONFIG_USB_XHCI_AMLOGIC*/
+
+#ifdef CONFIG_AML_NAND
+	extern int amlnf_init(unsigned char flag);
+	amlnf_init(0);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+	int ret;
+	char* env;
+
+	/*USE_HDMI_UART_FUNC*/
+	env = getenv("hdmiuart_mode");
+	/*printf("hdmiuart_mode env:%s\n",env);*/
+	if (env) {
+		if (!strcmp(env,"open")) {
+		printf("CONFIG_HDMI_UART_BOARD\n");
+		init_hdmi_uart_board();
+		}
+	}
+	/*endif*/
+
+	//update env before anyone using it
+	run_command("get_rebootmode; echo reboot_mode=${reboot_mode}; "\
+			"if test ${reboot_mode} = factory_reset; then "\
+			"defenv_reserv aml_dt;setenv upgrade_step 2;save; fi;", 0);
+	run_command("if itest ${upgrade_step} == 1; then "\
+				"defenv_reserv; setenv upgrade_step 2; saveenv; fi;", 0);
+	/*add board late init function here*/
+	ret = run_command("store dtb read $dtb_mem_addr", 1);
+	if (ret) {
+		printf("%s(): [store dtb read $dtb_mem_addr] fail\n", __func__);
+		#ifdef CONFIG_DTB_MEM_ADDR
+		char cmd[64];
+		printf("load dtb to %x\n", CONFIG_DTB_MEM_ADDR);
+		sprintf(cmd, "store dtb read %x", CONFIG_DTB_MEM_ADDR);
+		ret = run_command(cmd, 1);
+		if (ret) {
+			printf("%s(): %s fail\n", __func__, cmd);
+		}
+		#endif
+	}
+
+	/* load unifykey */
+	run_command("keyunify init 0x1234", 0);
+#ifdef CONFIG_AML_VPU
+	vpu_probe();
+#endif
+	vpp_init();
+#ifdef CONFIG_AML_HDMITX20
+	hdmi_tx_set_hdmi_5v();
+	hdmi_tx_init();
+#endif
+#ifdef CONFIG_AML_LCD
+	lcd_probe();
+#endif
+
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	/*aml_try_factory_sdcard_burning(0, gd->bd);*/
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+	/* enable 5V for USB, panel, wifi */
+	run_command("gpio set GPIOAO_4", 0);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AML_TINY_USBTOOL
+int usb_get_update_result(void)
+{
+	unsigned long upgrade_step;
+	upgrade_step = simple_strtoul (getenv ("upgrade_step"), NULL, 16);
+	printf("upgrade_step = %d\n", (int)upgrade_step);
+	if (upgrade_step == 1)
+	{
+		run_command("defenv", 1);
+		run_command("setenv upgrade_step 2", 1);
+		run_command("saveenv", 1);
+		return 0;
+	}
+	else
+	{
+		return -1;
+	}
+}
+#endif
+
+phys_size_t get_effective_memsize(void)
+{
+	// >>16 -> MB, <<20 -> real size, so >>16<<20 = <<4
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4) - CONFIG_SYS_MEM_TOP_HIDE;
+#else
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
+#endif
+}
diff --git a/board/amlogic/txl_skt_v1/Kconfig b/board/amlogic/txl_skt_v1/Kconfig
new file mode 100644
index 0000000..4ed5132
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/Kconfig
@@ -0,0 +1,22 @@
+if TARGET_MESON_GXTV
+
+config SYS_CPU
+	string
+	default "armv8"
+
+config SYS_BOARD
+	string
+	default "txl_skt_v1"
+
+config SYS_VENDOR
+	string
+	default "amlogic"
+
+config SYS_SOC
+	string
+	default "txl"
+
+config SYS_CONFIG_NAME
+	default "txl_skt_v1"
+
+endif
diff --git a/board/amlogic/txl_skt_v1/Makefile b/board/amlogic/txl_skt_v1/Makefile
new file mode 100644
index 0000000..fb7f59a
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/Makefile
@@ -0,0 +1,3 @@
+
+obj-y += $(BOARD).o eth_setup.o
+obj-$(CONFIG_AML_LCD) += lcd.o
diff --git a/board/amlogic/txl_skt_v1/aml-user-key.sig b/board/amlogic/txl_skt_v1/aml-user-key.sig
new file mode 100644
index 0000000..e69de29
diff --git a/board/amlogic/txl_skt_v1/eth_setup.c b/board/amlogic/txl_skt_v1/eth_setup.c
new file mode 100644
index 0000000..882a37d
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/eth_setup.c
@@ -0,0 +1,51 @@
+
+/*
+ * board/amlogic/txl_skt_v1/eth_setup.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <asm/arch/eth_setup.h>
+/*
+ *
+ *setup eth device board socket
+ *
+ */
+struct eth_board_socket* eth_board_setup(char *name){
+	struct eth_board_socket* new_board;
+	new_board= (struct eth_board_socket*) malloc(sizeof(struct eth_board_socket));
+	if (NULL == new_board) return NULL;
+	if (name != NULL) {
+		new_board->name=(char*)malloc(strlen(name));
+		strncpy(new_board->name,name,strlen(name));
+	}else{
+		new_board->name="gxb";
+	}
+
+	new_board->eth_pinmux_setup=NULL ;
+	new_board->eth_clock_configure=NULL;
+	new_board->eth_hw_reset=NULL;
+	return new_board;
+}
+//pinmux   HHI_GCLK_MPEG1[bit 3]
+//
diff --git a/board/amlogic/txl_skt_v1/firmware/board_init.c b/board/amlogic/txl_skt_v1/firmware/board_init.c
new file mode 100644
index 0000000..2771433
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/firmware/board_init.c
@@ -0,0 +1,28 @@
+
+/*
+ * board/amlogic/txl_skt_v1/firmware/board_init.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "power.c"
+
+/* bl2 customer code */
+void board_init(void)
+{
+	power_init(0);
+}
\ No newline at end of file
diff --git a/board/amlogic/txl_skt_v1/firmware/power.c b/board/amlogic/txl_skt_v1/firmware/power.c
new file mode 100644
index 0000000..12843e2
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/firmware/power.c
@@ -0,0 +1,173 @@
+
+/*
+ * board/amlogic/txl_skt_v1/firmware/power.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "config.h"
+#include <serial.h>
+//#include <stdio.h>
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+static int pwm_voltage_table[][2] = {
+	{ 0x1c0000,  860},
+	{ 0x1b0001,  870},
+	{ 0x1a0002,  880},
+	{ 0x190003,  890},
+	{ 0x180004,  900},
+	{ 0x170005,  910},
+	{ 0x160006,  920},
+	{ 0x150007,  930},
+	{ 0x140008,  940},
+	{ 0x130009,  950},
+	{ 0x12000a,  960},
+	{ 0x11000b,  970},
+	{ 0x10000c,  980},
+	{ 0x0f000d,  990},
+	{ 0x0e000e, 1000},
+	{ 0x0d000f, 1010},
+	{ 0x0c0010, 1020},
+	{ 0x0b0011, 1030},
+	{ 0x0a0012, 1040},
+	{ 0x090013, 1050},
+	{ 0x080014, 1060},
+	{ 0x070015, 1070},
+	{ 0x060016, 1080},
+	{ 0x050017, 1090},
+	{ 0x040018, 1100},
+	{ 0x030019, 1110},
+	{ 0x02001a, 1120},
+	{ 0x01001b, 1130},
+	{ 0x00001c, 1140}
+};
+#define P_PIN_MUX_REG3		(*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG4		(*((volatile unsigned *)(0xda834400 + (0x30 << 2))))
+
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+#define P_PWM_PWM_A		(*((volatile unsigned *)(0xc1100000 + (0x2154 << 2))))
+
+#define AO_PIN_MUX_REG		(*((volatile unsigned *)(0xc8100000 + (0x5 << 2))))
+#define P_EE_TIMER_E		(*((volatile unsigned *)(0xc1100000 + (0x2662 << 2))))
+
+enum pwm_id {
+    pwm_a = 0,
+    pwm_ao_b,
+};
+
+unsigned int _get_time(void)
+{
+	return P_EE_TIMER_E;
+}
+
+void _udelay_(unsigned int us)
+{
+	unsigned int t0 = _get_time();
+
+	while (_get_time() - t0 <= us)
+		;
+}
+
+void pwm_init(int id)
+{
+	unsigned int reg;
+
+	/*
+	 * TODO: support more pwm controllers, right now only support
+	 */
+
+	switch (id) {
+	case pwm_a:
+		reg = P_PWM_MISC_REG_AB;
+		reg &= ~(0x7f << 8);
+		reg |=  ((1 << 15) | (1 << 0));
+		P_PWM_MISC_REG_AB = reg;
+		/*
+		 * default set to max voltage
+		 */
+		P_PWM_PWM_A = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+		reg  = P_PIN_MUX_REG3;
+		reg &= ~(1 << 21);
+		P_PIN_MUX_REG3 = reg;
+
+		reg  = P_PIN_MUX_REG4;
+		reg &= ~(1 << 26);
+		reg |=  (1 << 17);		// enable PWM_A
+		P_PIN_MUX_REG4 = reg;
+		break;
+
+	case pwm_ao_b:
+		reg = readl(AO_PWM_MISC_REG_AB);
+		reg &= ~(0x7f << 16);
+		reg |=  ((1 << 23) | (1 << 1));
+		writel(reg, AO_PWM_MISC_REG_AB);
+		/*
+		 * default set to max voltage
+		 */
+		writel( pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0],AO_PWM_PWM_B);
+		reg  = AO_PIN_MUX_REG;
+		reg |= (1 << 3);
+		AO_PIN_MUX_REG = reg;
+
+		break;
+	default:
+		break;
+	}
+
+	_udelay_(200);
+}
+
+void pwm_set_voltage(unsigned int id, unsigned int voltage)
+{
+	int to;
+
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= voltage) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	switch (id) {
+	case pwm_a:
+		P_PWM_PWM_A = pwm_voltage_table[to][0];
+		break;
+
+	case pwm_ao_b:
+		writel(pwm_voltage_table[to][0],AO_PWM_PWM_B);
+		break;
+	default:
+		break;
+	}
+	_udelay_(200);
+}
+
+void power_init(int mode)
+{
+	pwm_init(pwm_a);
+	pwm_init(pwm_ao_b);
+	serial_puts("set vcck to ");
+	serial_put_dec(CONFIG_VCCK_INIT_VOLTAGE);
+	serial_puts(" mv\n");
+	pwm_set_voltage(pwm_a, CONFIG_VCCK_INIT_VOLTAGE);
+	serial_puts("set vddee to ");
+	serial_put_dec(CONFIG_VDDEE_INIT_VOLTAGE);
+	serial_puts(" mv\n");
+	pwm_set_voltage(pwm_ao_b, CONFIG_VDDEE_INIT_VOLTAGE);
+}
diff --git a/board/amlogic/txl_skt_v1/firmware/scp_task/dvfs_board.c b/board/amlogic/txl_skt_v1/firmware/scp_task/dvfs_board.c
new file mode 100644
index 0000000..02f277a
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/firmware/scp_task/dvfs_board.c
@@ -0,0 +1,190 @@
+
+/*
+ * board/amlogic/txl_skt_v1/firmware/scp_task/dvfs_board.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+int pwm_voltage_table[ ][2] = {
+	{ 0x1c0000,  860},
+	{ 0x1b0001,  870},
+	{ 0x1a0002,  880},
+	{ 0x190003,  890},
+	{ 0x180004,  900},
+	{ 0x170005,  910},
+	{ 0x160006,  920},
+	{ 0x150007,  930},
+	{ 0x140008,  940},
+	{ 0x130009,  950},
+	{ 0x12000a,  960},
+	{ 0x11000b,  970},
+	{ 0x10000c,  980},
+	{ 0x0f000d,  990},
+	{ 0x0e000e, 1000},
+	{ 0x0d000f, 1010},
+	{ 0x0c0010, 1020},
+	{ 0x0b0011, 1030},
+	{ 0x0a0012, 1040},
+	{ 0x090013, 1050},
+	{ 0x080014, 1060},
+	{ 0x070015, 1070},
+	{ 0x060016, 1080},
+	{ 0x050017, 1090},
+	{ 0x040018, 1100},
+	{ 0x030019, 1110},
+	{ 0x02001a, 1120},
+	{ 0x01001b, 1130},
+	{ 0x00001c, 1140}
+};
+
+struct scpi_opp_entry cpu_dvfs_tbl[] = {
+	DVFS( 100000000,  860),
+	DVFS( 250000000,  860),
+	DVFS( 500000000,  880),
+	DVFS( 667000000,  920),
+	DVFS(1000000000,  960),
+	DVFS(1200000000, 1040),
+	DVFS(1296000000, 1080),
+	DVFS(1416000000, 1110),
+	DVFS(1536000000, 1110),
+	DVFS(1752000000, 1110),
+	DVFS(2016000000, 1110)
+};
+
+
+
+#define P_PIN_MUX_REG3         (*((volatile unsigned *)(0xda834400 + (0x2f << 2))))
+#define P_PIN_MUX_REG4         (*((volatile unsigned *)(0xda834400 + (0x30 << 2))))
+
+#define P_PWM_MISC_REG_AB	(*((volatile unsigned *)(0xc1100000 + (0x2156 << 2))))
+#define P_PWM_PWM_A		(*((volatile unsigned *)(0xc1100000 + (0x2154 << 2))))
+
+
+enum pwm_id {
+	pwm_a = 0,
+};
+
+
+void pwm_init(int id)
+{
+	/*
+	 * TODO: support more pwm controllers, right now only support PWM_B
+	 */
+	unsigned int reg;
+	reg = P_PWM_MISC_REG_AB;
+	reg &= ~(0x7f << 8);
+	reg |=  ((1 << 15) | (1 << 0));
+	P_PWM_MISC_REG_AB = reg;
+	/*
+	 * default set to max voltage
+	 */
+	P_PWM_PWM_A = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
+	reg  = P_PIN_MUX_REG3;
+	reg &= ~(1 << 21);
+	P_PIN_MUX_REG3 = reg;
+
+	reg  = P_PIN_MUX_REG4;
+	reg &= ~(1 << 26);		// clear PWM_VS
+	reg |=  (1 << 17);		// enable PWM_A
+	P_PIN_MUX_REG4 = reg;
+
+
+	_udelay(200);
+}
+
+int dvfs_get_voltage(void)
+{
+	int i = 0;
+	unsigned int reg_val;
+
+	reg_val = P_PWM_PWM_A;
+	for (i = 0; i < ARRAY_SIZE(pwm_voltage_table); i++) {
+		if (pwm_voltage_table[i][0] == reg_val) {
+			return i;
+		}
+	}
+	if (i >= ARRAY_SIZE(pwm_voltage_table)) {
+	    return -1;
+	}
+	return -1;
+}
+
+void set_dvfs(unsigned int domain, unsigned int index)
+{
+	int cur, to;
+	static int init_flag = 0;
+
+	if (!init_flag) {
+		pwm_init(pwm_a);
+		init_flag = 1;
+	}
+	cur = dvfs_get_voltage();
+	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
+		if (pwm_voltage_table[to][1] >= cpu_dvfs_tbl[index].volt_mv) {
+			break;
+		}
+	}
+	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
+		to = ARRAY_SIZE(pwm_voltage_table) - 1;
+	}
+	if (cur < 0 || cur >=ARRAY_SIZE(pwm_voltage_table)) {
+		P_PWM_PWM_A = pwm_voltage_table[to][0];
+		_udelay(200);
+		return ;
+	}
+	while (cur != to) {
+		/*
+		 * if target step is far away from current step, don't change
+		 * voltage by one-step-done. You should change voltage step by
+		 * step to make sure voltage output is stable
+		 */
+		if (cur < to) {
+			if (cur < to - 3) {
+				cur += 3;
+			} else {
+				cur = to;
+			}
+		} else {
+			if (cur > to + 3) {
+				cur -= 3;
+			} else {
+				cur = to;
+			}
+		}
+		P_PWM_PWM_A = pwm_voltage_table[cur][0];
+		_udelay(100);
+	}
+	_udelay(200);
+}
+void get_dvfs_info_board(unsigned int domain,
+		unsigned char *info_out, unsigned int *size_out)
+{
+	unsigned int cnt;
+	cnt = ARRAY_SIZE(cpu_dvfs_tbl);
+
+	buf_opp.latency = 200;
+	buf_opp.count = cnt;
+	memset(&buf_opp.opp[0], 0,
+	       MAX_DVFS_OPPS * sizeof(struct scpi_opp_entry));
+
+	memcpy(&buf_opp.opp[0], cpu_dvfs_tbl ,
+		cnt * sizeof(struct scpi_opp_entry));
+
+	memcpy(info_out, &buf_opp, sizeof(struct scpi_opp));
+	*size_out = sizeof(struct scpi_opp);
+	return;
+}
diff --git a/board/amlogic/txl_skt_v1/firmware/scp_task/pwr_ctrl.c b/board/amlogic/txl_skt_v1/firmware/scp_task/pwr_ctrl.c
new file mode 100644
index 0000000..3e559b0
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/firmware/scp_task/pwr_ctrl.c
@@ -0,0 +1,123 @@
+
+/*
+ * board/amlogic/txl_skt_v1/firmware/scp_task/pwr_ctrl.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifdef CONFIG_CEC_WAKEUP
+#include <cec_tx_reg.h>
+#endif
+#include <gpio-gxbb.h>
+
+static void power_off_at_clk81(void)
+{
+}
+static void power_on_at_clk81(void)
+{
+}
+
+static void power_off_at_24M(void)
+{
+}
+static void power_on_at_24M(void)
+{
+}
+
+static void power_off_at_32k(void)
+{
+}
+static void power_on_at_32k(void)
+{
+}
+
+void get_wakeup_source(void *response, unsigned int suspend_from)
+{
+	struct wakeup_info *p = (struct wakeup_info *)response;
+	unsigned val;
+
+	p->status = RESPONSE_OK;
+	val = REMOTE_WAKEUP_SRC;
+#ifdef CONFIG_CEC_WAKEUP
+	if (suspend_from != SYS_POWEROFF)
+		val |= CEC_WAKEUP_SRC;
+#endif
+	p->sources = val;
+	p->gpio_info_count = 0;
+}
+
+static unsigned int detect_key(unsigned int suspend_from)
+{
+	int exit_reason = 0;
+	unsigned *irq = (unsigned *)WAKEUP_SRC_IRQ_ADDR_BASE;
+	/* unsigned *wakeup_en = (unsigned *)SECURE_TASK_RESPONSE_WAKEUP_EN; */
+
+	/* setup wakeup resources*/
+	init_remote();
+#ifdef CONFIG_CEC_WAKEUP
+	if (hdmi_cec_func_config & 0x1) {
+		remote_cec_hw_reset();
+		cec_node_init();
+	}
+#endif
+
+	/* *wakeup_en = 1;*/
+	do {
+#ifdef CONFIG_CEC_WAKEUP
+		if (irq[IRQ_AO_CEC] == IRQ_AO_CEC_NUM) {
+			irq[IRQ_AO_CEC] = 0xFFFFFFFF;
+			if (suspend_from == SYS_POWEROFF)
+				continue;
+			if (cec_msg.log_addr) {
+				if (hdmi_cec_func_config & 0x1) {
+					cec_handler();
+					if (cec_msg.cec_power == 0x1) {
+						/*cec power key*/
+						exit_reason = CEC_WAKEUP;
+						break;
+					}
+				}
+			} else if (hdmi_cec_func_config & 0x1)
+				cec_node_init();
+		}
+#endif
+	if (irq[IRQ_AO_IR_DEC] == IRQ_AO_IR_DEC_NUM) {
+		irq[IRQ_AO_IR_DEC] = 0xFFFFFFFF;
+			if (remote_detect_key())
+				exit_reason = REMOTE_WAKEUP;
+	}
+		if (exit_reason)
+			break;
+		else
+			asm volatile("wfi");
+	} while (1);
+
+	return exit_reason;
+}
+
+static void pwr_op_init(struct pwr_op *pwr_op)
+{
+	pwr_op->power_off_at_clk81 = power_off_at_clk81;
+	pwr_op->power_on_at_clk81 = power_on_at_clk81;
+	pwr_op->power_off_at_24M = power_off_at_24M;
+	pwr_op->power_on_at_24M = power_on_at_24M;
+	pwr_op->power_off_at_32k = power_off_at_32k;
+	pwr_op->power_on_at_32k = power_on_at_32k;
+
+	pwr_op->detect_key = detect_key;
+	pwr_op->get_wakeup_source = get_wakeup_source;
+}
diff --git a/board/amlogic/txl_skt_v1/firmware/timing.c b/board/amlogic/txl_skt_v1/firmware/timing.c
new file mode 100644
index 0000000..e48bb6a
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/firmware/timing.c
@@ -0,0 +1,569 @@
+
+/*
+ * board/amlogic/txl_skt_v1/firmware/timing.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <asm/arch/timing.h>
+#include <asm/arch/ddr_define.h>
+
+/* DDR freq range */
+#define CONFIG_DDR_CLK_LOW  375
+#define CONFIG_DDR_CLK_HIGH 1500
+/* DON'T OVER THESE RANGE */
+#if (CONFIG_DDR_CLK < CONFIG_DDR_CLK_LOW) || (CONFIG_DDR_CLK > CONFIG_DDR_CLK_HIGH)
+	#error "Over DDR PLL range! Please check CONFIG_DDR_CLK in board header file! \n"
+#endif
+
+/* CPU freq range */
+#define CONFIG_CPU_CLK_LOW  600
+#define CONFIG_CPU_CLK_HIGH 2000
+/* DON'T OVER THESE RANGE */
+#if (CONFIG_CPU_CLK < CONFIG_CPU_CLK_LOW) || (CONFIG_CPU_CLK > CONFIG_CPU_CLK_HIGH)
+	#error "Over CPU PLL range! Please check CONFIG_CPU_CLK in board header file! \n"
+#endif
+
+#define DDR3_DRV_40OHM		0
+#define DDR3_DRV_34OHM		1
+#define DDR3_ODT_0OHM		0
+#define DDR3_ODT_60OHM		1
+#define DDR3_ODT_120OHM		2
+#define DDR3_ODT_40OHM		3
+#define DDR3_ODT_20OHM		4
+#define DDR3_ODT_30OHM		5
+
+/* lpddr2 drv odt */
+#define LPDDR2_DRV_34OHM	1
+#define LPDDR2_DRV_40OHM	2
+#define LPDDR2_DRV_48OHM	3
+#define LPDDR2_DRV_60OHM	4
+#define LPDDR2_DRV_80OHM	6
+#define LPDDR2_DRV_120OHM	7
+#define LPDDR2_ODT_0OHM		0
+
+/* lpddr3 drv odt */
+#define LPDDR3_DRV_34OHM	1
+#define LPDDR3_DRV_40OHM	2
+#define LPDDR3_DRV_48OHM	3
+#define LPDDR3_DRV_60OHM	4
+#define LPDDR3_DRV_80OHM	6
+#define LPDDR3_DRV_34_40OHM	9
+#define LPDDR3_DRV_40_48OHM	10
+#define LPDDR3_DRV_34_48OHM	11
+#define LPDDR3_ODT_0OHM		0
+#define LPDDR3_ODT_60OHM	1
+#define LPDDR3_ODT_12OHM	2
+#define LPDDR3_ODT_240HM	3
+
+#define DDR4_DRV_34OHM		0
+#define DDR4_DRV_48OHM		1
+#define DDR4_ODT_0OHM		0
+#define DDR4_ODT_60OHM		1
+#define DDR4_ODT_120OHM		2
+#define DDR4_ODT_40OHM		3
+#define DDR4_ODT_240OHM		4
+#define DDR4_ODT_48OHM		5
+#define DDR4_ODT_80OHM		6
+#define DDR4_ODT_34OHM		7
+
+#if ((CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR3) || (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_AUTO))
+#define CFG_DDR_DRV  DDR3_DRV_34OHM
+#define CFG_DDR_ODT  DDR3_ODT_60OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR2)
+#define CFG_DDR_DRV  LPDDR2_DRV_48OHM
+#define CFG_DDR_ODT  DDR3_ODT_120OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR3)
+#define CFG_DDR_DRV  LPDDR3_DRV_48OHM
+#define CFG_DDR_ODT  LPDDR3_ODT_12OHM
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR4)
+#define CFG_DDR_DRV  DDR4_DRV_34OHM //useless, no effect
+#define CFG_DDR_ODT  DDR4_ODT_60OHM //useless, no effect
+#endif
+
+#define CFG_DDR4_DRV  DDR4_DRV_48OHM //ddr4 driver use this one
+#define CFG_DDR4_ODT  DDR4_ODT_60OHM //ddr4 driver use this one
+
+/*
+ * these parameters are corresponding to the pcb layout,
+ * please don't enable this function unless these signals
+ * has been measured by oscilloscope.
+ */
+#ifdef CONFIG_DDR_CMD_BDL_TUNE
+#define DDR_AC_LCDLR   0
+#define	DDR_CK0_BDL	18
+#define	DDR_RAS_BDL	18
+#define	DDR_CAS_BDL	24
+#define	DDR_WE_BDL	21
+#define	DDR_BA0_BDL	16
+#define	DDR_BA1_BDL	2
+#define	DDR_BA2_BDL	13
+#define	DDR_ACPDD_BDL	27
+#define	DDR_CS0_BDL	27
+#define	DDR_CS1_BDL	27
+#define	DDR_ODT0_BDL	27
+#define	DDR_ODT1_BDL	27
+#define	DDR_CKE0_BDL	27
+#define	DDR_CKE1_BDL	27
+#define	DDR_A0_BDL	14
+#define	DDR_A1_BDL	9
+#define	DDR_A2_BDL	5
+#define	DDR_A3_BDL	18
+#define	DDR_A4_BDL	4
+#define	DDR_A5_BDL	16
+#define	DDR_A6_BDL	1
+#define	DDR_A7_BDL	10
+#define	DDR_A8_BDL	4
+#define	DDR_A9_BDL	7
+#define	DDR_A10_BDL	10
+#define	DDR_A11_BDL	9
+#define	DDR_A12_BDL	6
+#define	DDR_A13_BDL	16
+#define	DDR_A14_BDL	8
+#define	DDR_A15_BDL	27
+#endif
+
+/* CAUTION!! */
+/*
+ * For DDR3:
+ *     7-7-7:    CONFIG_DDR_CLK range  375~ 533
+ *     9-9-9:    CONFIG_DDR_CLK range  533~ 667
+ *     11-11-11: CONFIG_DDR_CLK range  667~ 800
+ *     12-12-12: CONFIG_DDR_CLK range  800~ 933
+ *     13-13-13: CONFIG_DDR_CLK range  933~1066
+ *     14-14-14: CONFIG_DDR_CLK range 1066~1200
+ */
+ddr_timing_t __ddr_timming[] = {
+	//ddr3_7_7_7
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_7,
+		.cfg_ddr_rtp			= (6),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (7),
+		.cfg_ddr_rcd			= (7),
+		.cfg_ddr_ras			= (20),
+		.cfg_ddr_rrd			= (6),
+		.cfg_ddr_rc				= (27),
+		.cfg_ddr_mrd			= (4),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (27),
+		.cfg_ddr_rfc			= (160),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (6),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (4),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (7),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (5),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (4),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (512),
+		.cfg_ddr_xpdll			= (20),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_9_9_9
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_9,
+		.cfg_ddr_rtp			= (6),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (9),
+		.cfg_ddr_rcd			= (9),
+		.cfg_ddr_ras			= (27),
+		.cfg_ddr_rrd			= (6),
+		.cfg_ddr_rc				= (33),
+		.cfg_ddr_mrd			= (4),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (30),
+		.cfg_ddr_rfc			= (196),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (6),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (6),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (9),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (7),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (20),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_11_11_11
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_11,
+		.cfg_ddr_rtp			= (7),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (11),
+		.cfg_ddr_rcd			= (11),
+		.cfg_ddr_ras			= (35),
+		.cfg_ddr_rrd			= (7),
+		.cfg_ddr_rc				= (45),
+		.cfg_ddr_mrd			= (6),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (33),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (7),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (5),
+		.cfg_ddr_cke			= (4),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (11),
+		.cfg_ddr_wr				= (12),
+		.cfg_ddr_cwl			= (8),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	//ddr3_13_13_13
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR3_13,
+		.cfg_ddr_rtp			= (7),
+		.cfg_ddr_wtr			= (7),
+		.cfg_ddr_rp				= (13),
+		.cfg_ddr_rcd			= (13),
+		.cfg_ddr_ras			= (37),
+		.cfg_ddr_rrd			= (7),
+		.cfg_ddr_rc				= (52),
+		.cfg_ddr_mrd			= (6),
+		.cfg_ddr_mod			= (12),
+		.cfg_ddr_faw			= (33),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (7),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (512),
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (13),
+		.cfg_ddr_wr				= (16),
+		.cfg_ddr_cwl			= (9),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (512),
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= (64),
+		.cfg_ddr_zqcl			= (136),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+	},
+	/* ddr4 1600 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR4_1600,
+		.cfg_ddr_rtp			= (4),
+		.cfg_ddr_wtr			= (6),
+		.cfg_ddr_rp				= (11),
+		.cfg_ddr_rcd			= (11),
+		.cfg_ddr_ras			= (35),
+		.cfg_ddr_rrd			= (4),
+		.cfg_ddr_rc				= (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= (28),
+		.cfg_ddr_rfc			= (280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= (8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= (11),
+		.cfg_ddr_wr				= (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (5),
+	},
+	/* ddr4 2400 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_DDR4_2400,
+		.cfg_ddr_rtp			= 9,//(4),
+		.cfg_ddr_wtr			= 9,//(6),
+		.cfg_ddr_rp				= 15*1.2,//(11),
+		.cfg_ddr_rcd			= 15*1.2,//(11),
+		.cfg_ddr_ras			= 35*1.2,//(35),
+		.cfg_ddr_rrd			= (8),
+		.cfg_ddr_rc				=50*1.2,// (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= 35*1.2,//(28),
+		.cfg_ddr_rfc			= 350*1.2,//(280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= 9.5*1.2,//(8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= 15*1.2,// (11),
+		.cfg_ddr_wr				= 15*1.2,// (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= 12,// (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (6),
+	},
+	/* lpddr3 timing */
+	{
+		.identifier				= CONFIG_DDR_TIMMING_LPDDR3,
+		.cfg_ddr_rtp			= (4),
+		.cfg_ddr_wtr			= (6),
+		.cfg_ddr_rp				= 15*1.2,//(11),
+		.cfg_ddr_rcd			= 15*1.2,//(11),
+		.cfg_ddr_ras			= 35*1.2,//(35),
+		.cfg_ddr_rrd			= (4),
+		.cfg_ddr_rc				= 50*1.2,// (46),//RAS+RP
+		.cfg_ddr_mrd			= (8),
+		.cfg_ddr_mod			= (24),
+		.cfg_ddr_faw			= 35*1.2,//(28),
+		.cfg_ddr_rfc			= 350*1.2,//(280),
+		.cfg_ddr_wlmrd			= (40),
+		.cfg_ddr_wlo			= 9.5*1.2,//(8),
+		.cfg_ddr_xs				= (512),
+		.cfg_ddr_xp				= (7),
+		.cfg_ddr_cke			= (5),
+		.cfg_ddr_dllk			= (1024),  //597 768 1024
+		.cfg_ddr_rtodt			= (0),
+		.cfg_ddr_rtw			= (7),
+		.cfg_ddr_refi			= (78),
+		.cfg_ddr_refi_mddr3		= (4),
+		.cfg_ddr_cl				= 15*1.2,// (11),
+		.cfg_ddr_wr				= 15*1.2,// (13),  //15NS+1CLK
+		.cfg_ddr_cwl			= 12,// (11),
+		.cfg_ddr_al				= (0),
+		.cfg_ddr_exsr			= (1024),  //597 768 1024
+		.cfg_ddr_dqs			= (23),
+		.cfg_ddr_cksre			= (15),
+		.cfg_ddr_cksrx			= (15),
+		.cfg_ddr_zqcs			= 128,
+		.cfg_ddr_zqcl			= (256),
+		.cfg_ddr_xpdll			= (23),
+		.cfg_ddr_zqcsi			= (1000),
+		.cfg_ddr_tccdl			= (6),
+	}
+};
+
+ddr_set_t __ddr_setting = {
+	/* common and function defines */
+	.ddr_channel_set		= CONFIG_DDR_CHANNEL_SET,
+	.ddr_type				= CONFIG_DDR_TYPE,
+	.ddr_clk				= CONFIG_DDR_CLK,
+	.ddr4_clk				= CONFIG_DDR4_CLK,
+	.ddr_base_addr			= CFG_DDR_BASE_ADDR,
+	.ddr_start_offset		= CFG_DDR_START_OFFSET,
+	.ddr_timing_ind			= 0,
+	.ddr_size				= CONFIG_DDR_SIZE,
+	.ddr_pll_ctrl			= (0),
+	.ddr_dmc_ctrl			= 0,
+	.ddr0_addrmap			= {0},
+	.ddr1_addrmap			= {0},
+	.ddr_2t_mode			= 1,
+	.ddr_full_test			= CONFIG_DDR_FULL_TEST,
+#if (0 == CONFIG_DDR_SIZE)
+	.ddr_size_detect		= 1,
+#else
+	.ddr_size_detect		= 0,
+#endif
+	.ddr_drv				= CFG_DDR_DRV,
+	.ddr_odt				= CFG_DDR_ODT,
+	.ddr4_drv				= CFG_DDR4_DRV,
+	.ddr4_odt				= CFG_DDR4_ODT,
+
+	/* pub defines */
+	.t_pub_ptr				= {
+							[0] = ( 6 | (320 << 6) | (80 << 21)),
+							[1] = (120 | (1000 << 16)),
+							[2] = 0,
+							[3] = (20000 | (136 << 20)),
+							[4] = (1000 | (180 << 16)),
+							},  //PUB PTR0-3
+	.t_pub_odtcr			= 0x00030000,
+	.t_pub_mr				= {
+							(0X0 | (0X1 << 2) | (0X0 << 3) | (0X0 << 4) | (0X0 << 7) | (0X0 << 8) | (0X7 << 9) | (1 << 12)),
+							(0X6|(1<<6)),
+							0X20,
+							0,
+							},
+	.t_pub_dtpr				= {0},
+	.t_pub_pgcr0			= 0x07d81e3f,   //PUB PGCR0
+	.t_pub_pgcr1			= 0x02004620,   //PUB PGCR1
+	.t_pub_pgcr2			= 0x00f05f97,   //PUB PGCR2
+	//.t_pub_pgcr2			= 0x01f12480,   //PUB PGCR2
+	.t_pub_pgcr3			= 0xc0aae860,   //PUB PGCR3
+	.t_pub_dxccr			= 0x20c01ee4,   //PUB DXCCR
+	.t_pub_aciocr			= {0},  //PUB ACIOCRx
+	.t_pub_dx0gcr			= {0},  //PUB DX0GCRx
+	.t_pub_dx1gcr			= {0},  //PUB DX1GCRx
+	.t_pub_dx2gcr			= {0},  //PUB DX2GCRx
+	.t_pub_dx3gcr			= {0},  //PUB DX3GCRx
+#if (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR3)
+	.t_pub_dcr				= 0XB,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,    //PUB DTCR
+	.t_pub_dsgcr			= 0x020641b,
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_DDR4)
+	.t_pub_dcr				= 0X40C,     //PUB DCR
+	.t_pub_dtcr0			= 0x800031c7,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,
+	.t_pub_dsgcr			= 0x020641b|(1<<2)|(1<<23),
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_LPDDR3)
+	.t_pub_dcr				= 0X89,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,
+	.t_pub_dsgcr			= 0x02064db,
+#elif (CONFIG_DDR_TYPE == CONFIG_DDR_TYPE_AUTO)
+	.t_pub_dcr				= 0XB,     //PUB DCR
+	.t_pub_dtcr0			= 0x80003187,    //PUB DTCR //S905 use 0x800031c7
+	.t_pub_dtcr1			= 0x00010237,    //PUB DTCR
+	.t_pub_dsgcr			= 0x020641b,
+#endif
+	.t_pub_vtcr1			= 0x0fc00172,
+	.t_pub_dtar				= (0X0 | (0X0 <<12) | (0 << 28)),
+	//.t_pub_zq0pr			= 0x7b,   //PUB ZQ0PR
+	//.t_pub_zq1pr			= 0x7b,   //PUB ZQ1PR
+	//.t_pub_zq2pr			= 0x7b,   //PUB ZQ2PR
+	//.t_pub_zq3pr			= 0x7b,   //PUB ZQ3PR
+	.t_pub_zq0pr			= 0x5995d,   //PUB ZQ0PR
+	.t_pub_zq1pr			= 0x3f95d,   //PUB ZQ1PR
+	.t_pub_zq2pr			= 0x3f95d,   //PUB ZQ2PR
+	.t_pub_zq3pr			= 0x1dd1d,   //PUB ZQ3PR
+
+	/* pctl0 defines */
+	/* pctl1 use same define as pctl0 */
+	.t_pctl0_1us_pck		= CONFIG_DDR_CLK / 2,   //PCTL TOGCNT1U
+	.t_pctl0_100ns_pck		= CONFIG_DDR_CLK / 20, //PCTL TOGCNT100N
+	.t_pctl0_init_us		= 2,   //PCTL TINIT
+	.t_pctl0_rsth_us		= 2,   //PCTL TRSTH
+	.t_pctl0_mcfg			= 0XA2F01,   //PCTL MCFG default 1T
+	//.t_pctl0_mcfg1			= 0X80000000,  //PCTL MCFG1
+	.t_pctl0_mcfg1			=  0, //[B10,B9,B8] tfaw_cfg_offset
+								//tFAW= (4 + MCFG.tfaw_cfg)*tRRD - tfaw_cfg_offset,  //PCTL MCFG1
+	.t_pctl0_scfg			= 0xF01,   //PCTL SCFG
+	.t_pctl0_sctl			= 0x1,   //PCTL SCTL
+	.t_pctl0_ppcfg			= 0,
+	.t_pctl0_dfistcfg0		= 0x4,
+	.t_pctl0_dfistcfg1		= 0x1,
+	.t_pctl0_dfitctrldelay	= 2,
+	.t_pctl0_dfitphywrdata	= 2,
+	.t_pctl0_dfitphywrlta	= 7,
+	.t_pctl0_dfitrddataen	= 8,
+	.t_pctl0_dfitphyrdlat	= 22,
+	.t_pctl0_dfitdramclkdis	= 1,
+	.t_pctl0_dfitdramclken	= 1,
+	.t_pctl0_dfitphyupdtype0 = 16,
+	.t_pctl0_dfitphyupdtype1 = 16,
+	.t_pctl0_dfitctrlupdmin	= 16,
+	.t_pctl0_dfitctrlupdmax	= 64,
+	.t_pctl0_dfiupdcfg		= 0x3,
+	.t_pctl0_cmdtstaten		= 1,
+	//.t_pctl0_dfiodtcfg		= 8,
+	//.t_pctl0_dfiodtcfg1		= ( 0x0 | (0x6 << 16) ),
+	.t_pctl0_dfiodtcfg		= (1<<3)|(1<<11),
+	.t_pctl0_dfiodtcfg1		= (0x0 | (0x6 << 16)),
+
+	.t_pctl0_dfilpcfg0		= ( 1 | (3 << 4) | (1 << 8) | (13 << 12) | (7 <<16) | (1 <<24) | ( 3 << 28)),
+	.t_pub_acbdlr0			= 0,  //CK0 delay fine tune
+	.t_pub_aclcdlr			= 0x10,
+	.ddr_func				= DDR_FUNC, /* ddr func demo 2016.01.26 */
+
+	.wr_adj_per 			= {
+							[0] = 100,
+							[1] = 100,
+							[2] = 100,
+							[3] = 100,
+							[4] = 100,
+							[5] = 100,
+							},
+	.rd_adj_per				= {
+							[0] = 100,
+							[1] = 100,
+							[2] = 100,
+							[3] = 100,
+							[4] = 100,
+							[5] = 100,},
+};
+
+pll_set_t __pll_setting = {
+	.cpu_clk				= CONFIG_CPU_CLK / 24 * 24,
+#ifdef CONFIG_PXP_EMULATOR
+	.pxp					= 1,
+#else
+	.pxp					= 0,
+#endif
+	.spi_ctrl				= 0,
+	.lCustomerID			= CONFIG_AML_CUSTOMER_ID,
+#ifdef CONFIG_DEBUG_MODE
+	.debug_mode				= CONFIG_DEBUG_MODE,
+	.ddr_clk_debug			= CONFIG_DDR_CLK_DEBUG,
+	.cpu_clk_debug			= CONFIG_CPU_CLK_DEBUG,
+#endif
+};
diff --git a/board/amlogic/txl_skt_v1/lcd.c b/board/amlogic/txl_skt_v1/lcd.c
new file mode 100644
index 0000000..9b990f4
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/lcd.c
@@ -0,0 +1,281 @@
+/*
+ * AMLOGIC TV LCD panel driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <amlogic/aml_lcd.h>
+#include <asm/arch/gpio.h>
+
+//Rsv_val = 0xffffffff
+
+static char lcd_cpu_gpio[LCD_CPU_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX] = {
+	//"GPIOX_3",
+	//"GPIOX_2",
+	"invalid", /* ending flag */
+};
+
+static struct lcd_power_step_s lcd_power_on_step[] = {
+	//{LCD_POWER_TYPE_CPU,   0,1,50,}, /* power on */
+	{LCD_POWER_TYPE_SIGNAL,0,0,0,},  /* signal */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},  /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_off_step[] = {
+	{LCD_POWER_TYPE_SIGNAL,0,0,50,},  /* signal */
+	//{LCD_POWER_TYPE_CPU,   0,0,100,}, /* power off */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},   /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_on_step_3d_disable[] = {
+	//{LCD_POWER_TYPE_CPU,   0,1,20,}, /* power on */
+	//{LCD_POWER_TYPE_CPU,   1,0,10,}, /* 3d_disable */
+	{LCD_POWER_TYPE_SIGNAL,0,0,0,},  /* signal */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},  /* ending flag */
+};
+static struct lcd_power_step_s lcd_power_off_step_3d_disable[] = {
+	{LCD_POWER_TYPE_SIGNAL,0,0,30,},  /* signal */
+	//{LCD_POWER_TYPE_CPU,   1,2,0,},   /* 3d_disable */
+	//{LCD_POWER_TYPE_CPU,   0,0,100,}, /* power off */
+	{LCD_POWER_TYPE_MAX,   0,0,0,},   /* ending flag */
+};
+
+static char lcd_bl_gpio[BL_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX] = {
+	//"GPIOAO_4",
+	//"GPIOY_13",
+	"invalid", /* ending flag */
+};
+
+struct ext_lcd_config_s ext_lcd_config[LCD_NUM_MAX] = {
+	{/* AOC: public Platform lvds : 1920x1080@60hz 8bit pixel clk@74.25mhz 2prot*/
+	"lvds_0",LCD_LVDS,8,
+	/* basic timing */
+	1920,1080,2200,1125,44,148,0,5,36,0,
+	/* clk_attr */
+	0,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* lvds_attr */
+	1,1,0,0,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_MAX,0xff,1,0,0,0,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*public vx1 : 3840x2160@60hz 8lane */
+	"vbyone_0",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,81,0,
+	/* clk_attr */
+	0,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*LG: RDL550WY: 3840x2160@60hz 8lane */
+	"vbyone_1",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,81,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*INL: V580DJ2: 3840x2160@60hz 8lane */
+	"vbyone_2",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,0,6,81,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,1,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step, lcd_power_off_step,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+
+	{/*BOE: HV550QU2: 3840x2160@60hz 8lane */
+	"vbyone_3",LCD_VBYONE,10,
+	/* basic timing */
+	3840,2160,4400,2250,33,477,1,6,81,0,
+	/* clk_attr */
+	2,0,1,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* vbyone_attr */
+	8,2,4,4,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	/* power step */
+	lcd_power_on_step_3d_disable, lcd_power_off_step_3d_disable,
+	/* backlight */
+	60,255,10,128,128,
+	BL_CTRL_PWM,0,1,0,200,200,
+	BL_PWM_POSITIVE,BL_PWM_B,180,100,25,1,0,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	Rsv_val,Rsv_val,Rsv_val,Rsv_val,
+	10,10,Rsv_val},
+};
+
+//**** Special parameters just for Vbyone ***//
+static struct vbyone_config_s lcd_vbyone_config = {
+	.lane_count   = 8,
+	.byte_mode    = 4,
+	.region_num   = 2,
+	.color_fmt    = 4,
+};
+
+//**** Special parameters just for lvds ***//
+static struct lvds_config_s lcd_lvds_config = {
+	.lvds_repack  = 1, //0=JEDIA mode,  1=VESA mode
+	.dual_port    = 1, //0=single port, 1=double port
+	.pn_swap      = 0, //0=normal,      1=swap
+	.port_swap    = 0, //0=normal,      1=swap
+};
+
+static struct lcd_power_ctrl_s lcd_power_ctrl = {
+	.power_on_step = {
+		// {
+			// .type = LCD_POWER_TYPE_CPU,
+			// .index = 0, /* point to cpu_gpio[] struct */
+			// .value = 1, /* 0=output_low, 1=output_high, 2=input */
+			// .delay = 50, /* unit: ms */
+		// },
+		{
+			.type = LCD_POWER_TYPE_SIGNAL,
+			.delay = 0, /* unit: ms */
+		},
+		{
+			.type = LCD_POWER_TYPE_MAX, /* ending flag */
+		},
+	},
+	.power_off_step = {
+		{
+			.type = LCD_POWER_TYPE_SIGNAL,
+			.delay = 50, /* unit: ms */
+		},
+		// {
+			// .type = LCD_POWER_TYPE_CPU,
+			// .index = 0, /* point to cpu_gpio[] struct */
+			// .value = 0, /* 0=output_low, 1=output_high, 2=input */
+			// .delay = 100, /* unit: ms */
+		// },
+		{
+			.type = LCD_POWER_TYPE_MAX, /* ending flag */
+		},
+	},
+};
+
+struct lcd_config_s lcd_config_dft = {
+	.lcd_mode = LCD_MODE_TV,
+	.lcd_basic = {
+		.model_name = "default",
+		.lcd_type = LCD_TYPE_MAX, //LCD_TTL /LCD_LVDS/LCD_VBYONE
+		.lcd_bits = 8,
+		.h_active = 1920,
+		.v_active = 1080,
+		.h_period = 2200,
+		.v_period = 1125,
+
+		.screen_width   = 16,
+		.screen_height  = 9,
+	},
+
+	.lcd_timing = {
+		.clk_auto = 1,
+		.lcd_clk = 60,
+		.ss_level = 0,
+		.fr_adjust_type = 0,
+
+		.hsync_width = 44,
+		.hsync_bp    = 148,
+		.hsync_pol   = 0,
+		.vsync_width = 5,
+		.vsync_bp    = 36,
+		.vsync_pol   = 0,
+	},
+
+	.lcd_control = {
+		.lvds_config   = &lcd_lvds_config,
+		.vbyone_config = &lcd_vbyone_config,
+	},
+	.lcd_power = &lcd_power_ctrl,
+	.pinmux_set = {{7, 0x00001800}, {LCD_PINMUX_END, 0x0}},
+	.pinmux_clr = {{7, 0x00000603}, {LCD_PINMUX_END, 0x0}},
+};
+
+struct bl_config_s bl_config_dft = {
+	.name = "default",
+	.level_default = 100,
+	.level_min = 10,
+	.level_max = 255,
+	.level_mid = 128,
+	.level_mid_mapping = 128,
+	.level = 0,
+
+	.method = BL_CTRL_MAX,
+	.power_on_delay = 200,
+	.power_off_delay = 200,
+
+	.en_gpio = 0xff,
+	.en_gpio_on = 1,
+	.en_gpio_off = 0,
+
+	.bl_pwm = NULL,
+	.bl_pwm_combo0 = NULL,
+	.bl_pwm_combo1 = NULL,
+	.pwm_on_delay = 10,
+	.pwm_off_delay = 10,
+
+	.pinmux_set = {{10, 0x00800000}, {LCD_PINMUX_END, 0x0}},
+	.pinmux_clr = {{10, 0x0100a000}, {LCD_PINMUX_END, 0x0}},
+};
+
+void lcd_config_gpio_init(void)
+{
+	int i, j;
+
+	for (i = 0; i < LCD_CPU_GPIO_NUM_MAX; i++) {
+		if (strcmp(lcd_cpu_gpio[i], "invalid") == 0)
+			break;
+		strcpy(lcd_power_ctrl.cpu_gpio[i], lcd_cpu_gpio[i]);
+	}
+	for (j = i; j < LCD_CPU_GPIO_NUM_MAX; j++)
+		strcpy(lcd_power_ctrl.cpu_gpio[j], "invalid");
+	for (i = 0; i < BL_GPIO_NUM_MAX; i++) {
+		if (strcmp(lcd_bl_gpio[i], "invalid") == 0)
+			break;
+		strcpy(bl_config_dft.gpio_name[i], lcd_bl_gpio[i]);
+	}
+	for (j = i; j < BL_GPIO_NUM_MAX; j++)
+		strcpy(bl_config_dft.gpio_name[j], "invalid");
+}
diff --git a/board/amlogic/txl_skt_v1/txl_skt_v1.c b/board/amlogic/txl_skt_v1/txl_skt_v1.c
new file mode 100644
index 0000000..6df4ace
--- /dev/null
+++ b/board/amlogic/txl_skt_v1/txl_skt_v1.c
@@ -0,0 +1,445 @@
+
+/*
+ * board/amlogic/txl_skt_v1/txl_skt_v1.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#ifdef CONFIG_SYS_I2C_AML
+#include <aml_i2c.h>
+#include <asm/arch/secure_apb.h>
+#endif
+#ifdef CONFIG_AML_VPU
+#include <vpu.h>
+#endif
+#include <vpp.h>
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+#include <amlogic/aml_v2_burning.h>
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+#ifdef CONFIG_AML_HDMITX20
+#include <amlogic/hdmi.h>
+#endif
+#ifdef CONFIG_AML_LCD
+#include <amlogic/aml_lcd.h>
+#endif
+#include <asm/arch/eth_setup.h>
+#include <phy.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+//new static eth setup
+struct eth_board_socket*  eth_board_skt;
+
+
+int serial_set_pin_port(unsigned long port_base)
+{
+    //UART in "Always On Module"
+    //GPIOAO_0==tx,GPIOAO_1==rx
+    //setbits_le32(P_AO_RTI_PIN_MUX_REG,3<<11);
+    return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+/* secondary_boot_func
+ * this function should be write with asm, here, is is only for compiling pass
+ * */
+void secondary_boot_func(void)
+{
+}
+void internalPhyConfig(struct phy_device *phydev)
+{
+	/*Enable Analog and DSP register Bank access by*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0000);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0400);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0000);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x0400);
+	/*Write Analog register 23*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x8E0D);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x4417);
+	/*Enable fractional PLL*/
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x0005);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1B);
+	//Programme fraction FR_PLL_DIV1
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x029A);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1D);
+	//## programme fraction FR_PLL_DiV1
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0xAAAA);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x14, 0x5C1C);
+}
+
+
+static void setup_net_chip(void)
+{
+	eth_aml_reg0_t eth_reg0;
+
+	eth_reg0.d32 = 0;
+	eth_reg0.b.phy_intf_sel = 0;
+	eth_reg0.b.data_endian = 0;
+	eth_reg0.b.desc_endian = 0;
+	eth_reg0.b.rx_clk_rmii_invert = 0;
+	eth_reg0.b.rgmii_tx_clk_src = 0;
+	eth_reg0.b.rgmii_tx_clk_phase = 0;
+	eth_reg0.b.rgmii_tx_clk_ratio = 0;
+	eth_reg0.b.phy_ref_clk_enable = 0;
+	eth_reg0.b.clk_rmii_i_invert = 1;
+	eth_reg0.b.clk_en = 1;
+	eth_reg0.b.adj_enable = 0;
+	eth_reg0.b.adj_setup = 0;
+	eth_reg0.b.adj_delay = 0;
+	eth_reg0.b.adj_skew = 0;
+	eth_reg0.b.cali_start = 0;
+	eth_reg0.b.cali_rise = 0;
+	eth_reg0.b.cali_sel = 0;
+	eth_reg0.b.rgmii_rx_reuse = 0;
+	eth_reg0.b.eth_urgent = 0;
+	setbits_le32(P_PREG_ETH_REG0, eth_reg0.d32);// rmii mode
+	*P_PREG_ETH_REG2 = 0x10110181;
+	*P_PREG_ETH_REG3 = 0xe409087f;
+	setbits_le32(HHI_GCLK_MPEG1,1<<3);
+	/* power on memory */
+	clrbits_le32(HHI_MEM_PD_REG0, (1 << 3) | (1<<2));
+
+}
+
+extern struct eth_board_socket* eth_board_setup(char *name);
+extern int designware_initialize(ulong base_addr, u32 interface);
+
+int board_eth_init(bd_t *bis)
+{
+	setup_net_chip();
+	udelay(1000);
+	designware_initialize(ETH_BASE, PHY_INTERFACE_MODE_RMII);
+	return 0;
+}
+
+#if CONFIG_AML_SD_EMMC
+#include <mmc.h>
+#include <asm/arch/sd_emmc.h>
+static int  sd_emmc_init(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+			//todo add card detect
+			//setbits_le32(P_PREG_PAD_GPIO5_EN_N,1<<29);//CARD_6
+			break;
+		case SDIO_PORT_C:
+			//enable pull up
+			//clrbits_le32(P_PAD_PULL_UP_REG3, 0xff<<0);
+			break;
+		default:
+			break;
+	}
+
+	return cpu_sd_emmc_init(port);
+}
+
+extern unsigned sd_debug_board_1bit_flag;
+static int  sd_emmc_detect(unsigned port)
+{
+	int ret;
+    switch (port) {
+
+	case SDIO_PORT_A:
+		break;
+	case SDIO_PORT_B:
+			setbits_le32(P_PREG_PAD_GPIO2_EN_N, 1 << 26);//CARD_6
+			ret = readl(P_PREG_PAD_GPIO2_I) & (1 << 26) ? 0 : 1;
+			printf("%s\n", ret ? "card in" : "card out");
+			if ((readl(P_PERIPHS_PIN_MUX_6) & (3 << 8))) { //if uart pinmux set, debug board in
+				if (!(readl(P_PREG_PAD_GPIO2_I) & (1 << 24))) {
+					printf("sdio debug board detected, sd card with 1bit mode\n");
+					sd_debug_board_1bit_flag = 1;
+				}
+				else{
+					printf("sdio debug board detected, no sd card in\n");
+					sd_debug_board_1bit_flag = 0;
+					return 1;
+				}
+			}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void sd_emmc_pwr_prepare(unsigned port)
+{
+	cpu_sd_emmc_pwr_prepare(port);
+}
+
+static void sd_emmc_pwr_on(unsigned port)
+{
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            clrbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			/// @todo NOT FINISH
+			break;
+		case SDIO_PORT_C:
+			break;
+		default:
+			break;
+	}
+	return;
+}
+static void sd_emmc_pwr_off(unsigned port)
+{
+	/// @todo NOT FINISH
+    switch (port)
+	{
+		case SDIO_PORT_A:
+			break;
+		case SDIO_PORT_B:
+//            setbits_le32(P_PREG_PAD_GPIO5_O,(1<<31)); //CARD_8
+//            clrbits_le32(P_PREG_PAD_GPIO5_EN_N,(1<<31));
+			break;
+		case SDIO_PORT_C:
+			break;
+				default:
+			break;
+	}
+	return;
+}
+
+// #define CONFIG_TSD      1
+static void board_mmc_register(unsigned port)
+{
+	struct aml_card_sd_info *aml_priv=cpu_sd_emmc_get(port);
+    if (aml_priv == NULL)
+		return;
+
+	aml_priv->sd_emmc_init=sd_emmc_init;
+	aml_priv->sd_emmc_detect=sd_emmc_detect;
+	aml_priv->sd_emmc_pwr_off=sd_emmc_pwr_off;
+	aml_priv->sd_emmc_pwr_on=sd_emmc_pwr_on;
+	aml_priv->sd_emmc_pwr_prepare=sd_emmc_pwr_prepare;
+	aml_priv->desc_buf = malloc(NEWSD_MAX_DESC_MUN*(sizeof(struct sd_emmc_desc_info)));
+
+	if (NULL == aml_priv->desc_buf)
+		printf(" desc_buf Dma alloc Fail!\n");
+	else
+		printf("aml_priv->desc_buf = 0x%p\n",aml_priv->desc_buf);
+
+	sd_emmc_register(aml_priv);
+}
+int board_mmc_init(bd_t	*bis)
+{
+#ifdef CONFIG_VLSI_EMULATOR
+	//board_mmc_register(SDIO_PORT_A);
+#else
+	//board_mmc_register(SDIO_PORT_B);
+#endif
+	board_mmc_register(SDIO_PORT_B);
+	board_mmc_register(SDIO_PORT_C);
+//	board_mmc_register(SDIO_PORT_B1);
+	return 0;
+}
+
+#ifdef CONFIG_SYS_I2C_AML
+#if 0
+static void board_i2c_set_pinmux(void){
+	/*********************************************/
+	/*                | I2C_Master_AO        |I2C_Slave            |       */
+	/*********************************************/
+	/*                | I2C_SCK                | I2C_SCK_SLAVE  |      */
+	/* GPIOAO_4  | [AO_PIN_MUX: 6]     | [AO_PIN_MUX: 2]   |     */
+	/*********************************************/
+	/*                | I2C_SDA                 | I2C_SDA_SLAVE  |     */
+	/* GPIOAO_5  | [AO_PIN_MUX: 5]     | [AO_PIN_MUX: 1]   |     */
+	/*********************************************/
+
+	//disable all other pins which share with I2C_SDA_AO & I2C_SCK_AO
+	clrbits_le32(P_AO_RTI_PIN_MUX_REG, ((1<<2)|(1<<24)|(1<<1)|(1<<23)));
+	//enable I2C MASTER AO pins
+	setbits_le32(P_AO_RTI_PIN_MUX_REG,
+	(MESON_I2C_MASTER_AO_GPIOAO_4_BIT | MESON_I2C_MASTER_AO_GPIOAO_5_BIT));
+
+	udelay(10);
+};
+#endif
+struct aml_i2c_platform g_aml_i2c_plat = {
+	.wait_count         = 1000000,
+	.wait_ack_interval  = 5,
+	.wait_read_interval = 5,
+	.wait_xfer_interval = 5,
+	.master_no          = AML_I2C_MASTER_AO,
+	.use_pio            = 0,
+	.master_i2c_speed   = AML_I2C_SPPED_400K,
+	.master_ao_pinmux = {
+		.scl_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_4_REG,
+		.scl_bit    = MESON_I2C_MASTER_AO_GPIOAO_4_BIT,
+		.sda_reg    = (unsigned long)MESON_I2C_MASTER_AO_GPIOAO_5_REG,
+		.sda_bit    = MESON_I2C_MASTER_AO_GPIOAO_5_BIT,
+	}
+};
+#if 0
+static void board_i2c_init(void)
+{
+	//set I2C pinmux with PCB board layout
+	board_i2c_set_pinmux();
+
+	//Amlogic I2C controller initialized
+	//note: it must be call before any I2C operation
+	aml_i2c_init();
+
+	udelay(10);
+}
+#endif
+#endif
+#endif
+
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+int board_early_init_f(void){
+	/*add board early init function here*/
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_XHCI_AMLOGIC_GXL
+#include <asm/arch/usb-new.h>
+#include <asm/arch/gpio.h>
+#define CONFIG_GXL_USB_U2_PORT_NUM	4
+#define CONFIG_GXL_USB_U3_PORT_NUM	0
+
+struct amlogic_usb_config g_usb_config_GXL_skt={
+	CONFIG_GXL_XHCI_BASE,
+	USB_ID_MODE_HARDWARE,
+	NULL,//gpio_set_vbus_power, //set_vbus_power
+	CONFIG_GXL_USB_PHY2_BASE,
+	CONFIG_GXL_USB_PHY3_BASE,
+	CONFIG_GXL_USB_U2_PORT_NUM,
+	CONFIG_GXL_USB_U3_PORT_NUM,
+};
+#endif /*CONFIG_USB_XHCI_AMLOGIC*/
+
+#ifdef CONFIG_AML_HDMITX20
+static void hdmi_tx_set_hdmi_5v(void)
+{
+}
+#endif
+
+int board_init(void)
+{
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	aml_try_factory_usb_burning(0, gd->bd);
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+#ifdef CONFIG_USB_XHCI_AMLOGIC_GXL
+	board_usb_init(&g_usb_config_GXL_skt,BOARD_USB_MODE_HOST);
+#endif /*CONFIG_USB_XHCI_AMLOGIC*/
+
+#ifdef CONFIG_AML_NAND
+	extern int amlnf_init(unsigned char flag);
+	amlnf_init(0);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void){
+	int ret;
+
+	//update env before anyone using it
+	run_command("get_rebootmode; echo reboot_mode=${reboot_mode}; "\
+			"if test ${reboot_mode} = factory_reset; then "\
+			"defenv_reserv aml_dt;setenv upgrade_step 2;save; fi;", 0);
+	run_command("if itest ${upgrade_step} == 1; then "\
+				"defenv_reserv; setenv upgrade_step 2; saveenv; fi;", 0);
+	/*add board late init function here*/
+	ret = run_command("store dtb read $dtb_mem_addr", 1);
+	if (ret) {
+		printf("%s(): [store dtb read $dtb_mem_addr] fail\n", __func__);
+		#ifdef CONFIG_DTB_MEM_ADDR
+		char cmd[64];
+		printf("load dtb to %x\n", CONFIG_DTB_MEM_ADDR);
+		sprintf(cmd, "store dtb read %x", CONFIG_DTB_MEM_ADDR);
+		ret = run_command(cmd, 1);
+		if (ret) {
+			printf("%s(): %s fail\n", __func__, cmd);
+		}
+		#endif
+	}
+
+	/* load unifykey */
+	run_command("keyunify init 0x1234", 0);
+#ifdef CONFIG_AML_VPU
+	vpu_probe();
+#endif
+	vpp_init();
+#ifdef CONFIG_AML_HDMITX20
+	hdmi_tx_set_hdmi_5v();
+	hdmi_tx_init();
+#endif
+#ifdef CONFIG_AML_LCD
+	lcd_probe();
+#endif
+
+#ifdef CONFIG_AML_V2_FACTORY_BURN
+	/*aml_try_factory_sdcard_burning(0, gd->bd);*/
+#endif// #ifdef CONFIG_AML_V2_FACTORY_BURN
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AML_TINY_USBTOOL
+int usb_get_update_result(void)
+{
+	unsigned long upgrade_step;
+	upgrade_step = simple_strtoul (getenv ("upgrade_step"), NULL, 16);
+	printf("upgrade_step = %d\n", (int)upgrade_step);
+	if (upgrade_step == 1)
+	{
+		run_command("defenv", 1);
+		run_command("setenv upgrade_step 2", 1);
+		run_command("saveenv", 1);
+		return 0;
+	}
+	else
+	{
+		return -1;
+	}
+}
+#endif
+
+phys_size_t get_effective_memsize(void)
+{
+	// >>16 -> MB, <<20 -> real size, so >>16<<20 = <<4
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4) - CONFIG_SYS_MEM_TOP_HIDE;
+#else
+	return (((readl(AO_SEC_GP_CFG0)) & 0xFFFF0000) << 4);
+#endif
+}
diff --git a/common/aml_dt.c b/common/aml_dt.c
index 2cd6a04..3e0873e 100644
--- a/common/aml_dt.c
+++ b/common/aml_dt.c
@@ -5,6 +5,13 @@
 #include <malloc.h>
 #include <asm/arch/io.h>
 
+//#define AML_DT_DEBUG
+#ifdef AML_DT_DEBUG
+#define dbg_printf(...) printf(__VA_ARGS__)
+#else
+#define dbg_printf(...) ((void)0)
+#endif
+
 #define AML_DT_IND_LENGTH_V1		4	/*fixed*/
 #define AML_DT_IND_LENGTH_V2		16	/*fixed*/
 
@@ -25,6 +32,10 @@
 #define DT_HEADER_MAGIC		0xedfe0dd0	/*header of dtb file*/
 #define AML_DT_HEADER_MAGIC	0x5f4c4d41	/*"AML_", multi dtbs supported*/
 
+#define IS_GZIP_FORMAT(data)		((data & (0x0000FFFF)) == (0x00008B1F))
+#define GUNZIP_BUF_SIZE				(0x500000) /* 5MB */
+#define DTB_MAX_SIZE				(0x40000) /* 256KB */
+
 //#define readl(addr) (*(volatile unsigned int*)(addr))
 extern int checkhw(char * name);
 
@@ -32,10 +43,41 @@ unsigned long get_multi_dt_entry(unsigned long fdt_addr){
 	unsigned int dt_magic = readl(fdt_addr);
 	unsigned int dt_total = 0;
 	unsigned int dt_tool_version = 0;
+	unsigned int gzip_format = 0;
+	void * gzip_buf = NULL;
+	unsigned long dt_entry = fdt_addr;
+
 	printf("      Amlogic multi-dtb tool\n");
+
+	/* first check the file header, support GZIP format */
+	gzip_format = IS_GZIP_FORMAT(dt_magic);
+	if (gzip_format) {
+		printf("      GZIP format, decompress...\n");
+		gzip_buf = malloc(GUNZIP_BUF_SIZE);
+		memset(gzip_buf, 0, GUNZIP_BUF_SIZE);
+		unsigned long unzip_size = GUNZIP_BUF_SIZE;
+		gunzip(gzip_buf, GUNZIP_BUF_SIZE, (void *)fdt_addr, &unzip_size);
+		dbg_printf("      DBG: unzip_size: 0x%x\n", (unsigned int)unzip_size);
+		if (unzip_size > GUNZIP_BUF_SIZE) {
+			printf("      Warning! GUNZIP overflow...\n");
+		}
+		fdt_addr = (unsigned long)gzip_buf;
+		dt_magic = readl(fdt_addr);
+	}
+
+	dbg_printf("      DBG: fdt_addr: 0x%x\n", (unsigned int)fdt_addr);
+	dbg_printf("      DBG: dt_magic: 0x%x\n", (unsigned int)dt_magic);
+	dbg_printf("      DBG: gzip_format: %d\n", gzip_format);
+
 	/*printf("      Process device tree. dt magic: %x\n", dt_magic);*/
 	if (dt_magic == DT_HEADER_MAGIC) {/*normal dtb*/
 		printf("      Single dtb detected\n");
+		if (gzip_format) {
+			memcpy((void *)dt_entry, (void *)fdt_addr, DTB_MAX_SIZE);
+			fdt_addr = dt_entry;
+			if (gzip_buf)
+				free(gzip_buf);
+		}
 		return fdt_addr;
 	}
 	else if (dt_magic == AML_DT_HEADER_MAGIC) {/*multi dtb*/
@@ -45,17 +87,25 @@ unsigned long get_multi_dt_entry(unsigned long fdt_addr){
 		char *aml_dt_buf;
 		aml_dt_buf = (char *)malloc(sizeof(char)*64);
 		memset(aml_dt_buf, 0, sizeof(aml_dt_buf));
-		char *aml_dt = getenv(AML_DT_UBOOT_ENV);
 
+		/* update 2016.07.27, checkhw and setenv everytime,
+		or else aml_dt will set only once if it is reserved */
+#if 1
+		checkhw(aml_dt_buf);
+#else
+		char *aml_dt = getenv(AML_DT_UBOOT_ENV);
 		/* if aml_dt not exist or env not ready, get correct dtb by name */
 		if (NULL == aml_dt)
 			checkhw(aml_dt_buf);
 		else
 			memcpy(aml_dt_buf, aml_dt, (strlen(aml_dt)>64?64:(strlen(aml_dt)+1)));
+#endif
 
 		unsigned int aml_dt_len = aml_dt_buf ? strlen(aml_dt_buf) : 0;
 		if (aml_dt_len <= 0) {
 			printf("      Get env aml_dt failed!\n");
+			if (aml_dt_buf)
+				free(aml_dt_buf);
 			return fdt_addr;
 		}
 
@@ -146,11 +196,20 @@ unsigned long get_multi_dt_entry(unsigned long fdt_addr){
 		if (0xffff != dtb_match_num) {
 			printf("      Find match dtb: %d\n", dtb_match_num);
 			/*this offset is based on dtb image package, so should add on base address*/
-			return (fdt_addr + readl(fdt_addr + AML_DT_FIRST_DTB_OFFSET + \
+			fdt_addr = (fdt_addr + readl(fdt_addr + AML_DT_FIRST_DTB_OFFSET + \
 				dtb_match_num * aml_dtb_header_size + aml_dtb_offset_offset));
+			if (gzip_format) {
+				memcpy((void *)dt_entry, (void *)fdt_addr, DTB_MAX_SIZE);
+				fdt_addr = dt_entry;
+				if (gzip_buf)
+					free(gzip_buf);
+			}
+			return fdt_addr;
 		}
 		else{
 			printf("      Not match any dtb.\n");
+			if (gzip_buf)
+				free(gzip_buf);
 			return fdt_addr;
 		}
 	}
diff --git a/common/bootm.c b/common/bootm.c
index 961b08b..c3b0c4b 100644
--- a/common/bootm.c
+++ b/common/bootm.c
@@ -323,7 +323,7 @@ static int decomp_image(int comp, ulong load, ulong image_start, int type,
 			printf("   XIP %s ... ", type_name);
 		} else */
 		{
-			printf("   Loading %s ... ", type_name);
+			printf("   Loading %s(COMP_NONE) ... ", type_name);
 			memmove_wd(load_buf, image_buf, image_len, CHUNKSZ);
 		}
 		*load_end = load + image_len;
@@ -453,6 +453,12 @@ static int bootm_load_os(bootm_headers_t *images, unsigned long *load_end,
 			bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);
 			return BOOTM_ERR_RESET;
 		}
+#else
+		#define LINUX_ARM64_IMAGE_MAGIC	0x644d5241
+		if (*(uint32_t *)((images->ep) + 0x38) != le32_to_cpu(LINUX_ARM64_IMAGE_MAGIC)) {
+			printf("Bad Linux ARM64 Image magic!(Maybe unsupported zip mode.)\n");
+			return 1;
+		}
 #endif
 	}
 
diff --git a/common/cmd_aml_mmc.c b/common/cmd_aml_mmc.c
index 157ddeb..88e92f8 100644
--- a/common/cmd_aml_mmc.c
+++ b/common/cmd_aml_mmc.c
@@ -35,6 +35,8 @@
 
 extern int mmc_key_erase(void);
 extern int find_dev_num_by_partition_name (char *name);
+extern int mmc_get_ext_csd(struct mmc *mmc, u8 *ext_csd);
+extern int mmc_set_ext_csd(struct mmc *mmc, u8 index, u8 value);
 #define DTB_BLOCK_CNT       1024
 #define DTB_ADDR_SIZE       (SZ_1M * 40)
 #define CONFIG_SECURITYKEY
@@ -305,6 +307,7 @@ int do_amlmmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
                                                         blk -= PARTITION_RESERVED;
                                                 }
                                                 blk >>= blk_shift;
+                                                blk -= start_blk;
 
                                                 n=0;
 
@@ -488,16 +491,44 @@ int do_amlmmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
                                 else
                                         printf("%s failed\n", argv[3]);
                                 return rc;
-                        }
+                        } else if (strcmp(argv[1], "ext_csd") == 0) {
+                            int ret;
+                            u8 ext_csd[512] = {0};
+                            int dev = simple_strtoul(argv[2], NULL, 10);
+                            int bit = simple_strtoul(argv[3], NULL, 10);
+                            if ((bit > 511) || (bit < 0)) {
+                                printf("bit is out of area!\n");
+                                return 1;
+                            }
+                            struct mmc* mmc = find_mmc_device(dev);
+                            if (!mmc) {
+                                puts("no mmc devices available\n");
+                                return 1;
+                            }
+                            mmc_init(mmc);
+                            ret = mmc_get_ext_csd(mmc, ext_csd);
+                            printf("read EXT_CSD bit[%d] val[0x%x] %s\n",
+                                    bit, ext_csd[bit], (ret == 0) ? "ok" : "fail");
+                            return ret;
+                        } else if (strcmp(argv[1], "size") == 0) {
+                            char *name;
+                            uint64_t* addr =NULL;
+                            name = argv[2];
+                            addr = (uint64_t *)simple_strtoul(argv[3], NULL, 16);
+                            if (!strcmp(name, "wholeDev")) {
+                                int dev = CONFIG_SYS_MMC_BOOT_DEV;
+                                struct mmc* mmc = find_mmc_device(dev);
+                                if (!mmc) {
+                                    puts("no mmc devices available\n");
+                                    return 1;
+                                }
+                                mmc_init(mmc);
 
-                        if (strcmp(argv[1], "size") == 0) {
-                                char *name;
-                                uint64_t* addr =NULL;
-                                name = argv[2];
-                                addr = (uint64_t *)simple_strtoul(argv[3], NULL, 16);
-                                return get_partition_size((unsigned char *)name, addr);
+                                *addr = mmc->capacity >> 9; // unit: 512 bytes
+                                return 0;
+                            }
+                            return get_partition_size((unsigned char *)name, addr);
                         }
-
                         return cmd_usage(cmdtp);
 
                 case 2:
@@ -788,6 +819,26 @@ int do_amlmmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
                                 return (n == 0) ? 0 : 1;
 
+                        } else if (strcmp(argv[1], "ext_csd") == 0) {
+                            int ret;
+                            int dev = simple_strtoul(argv[2], NULL, 10);
+                            int bit = simple_strtoul(argv[3], NULL, 10);
+                            int val = simple_strtoul(argv[4], NULL, 16);
+                            if ((bit > 191) || (bit < 0)) {
+                                printf("bit is not able to write!\n");
+                                return 1;
+                            }
+                            struct mmc* mmc = find_mmc_device(dev);
+                            if (!mmc) {
+                                puts("no mmc devices available\n");
+                                return 1;
+                            }
+                            mmc_init(mmc);
+                            ret = mmc_set_ext_csd(mmc, bit, val);
+                            printf("write EXT_CSD bit[%d] val[0x%x] %s\n",
+                                    bit, val, (ret == 0) ? "ok" : "fail");
+                            return ret;
+
                         } else
                                 rc = cmd_usage(cmdtp);
 
@@ -807,6 +858,7 @@ U_BOOT_CMD(
     "amlmmc list - lists available devices\n"
     "amlmmc switch <device_num> <part name> - part name : boot0, boot1, user\n"
     "amlmmc status <device_num> - read sd/emmc device status\n"
+    "amlmmc ext_csd <bit> <value> - read/write sd/emmc device EXT_CSD [bit] value\n"
     "amlmmc response <device_num> - read sd/emmc last command response\n"
     "amlmmc controller <device_num> - read sd/emmc controller register\n");
 
diff --git a/common/cmd_cpu_temp.c b/common/cmd_cpu_temp.c
index 8ae6ac3..beaa176 100644
--- a/common/cmd_cpu_temp.c
+++ b/common/cmd_cpu_temp.c
@@ -29,9 +29,12 @@
 #include <asm/cpu_id.h>
 
 //#define HHI_SAR_CLK_CNTL    0xc883c000+0xf6*4 //0xc883c3d8
-
 int temp_base = 27;
 #define NUM 30
+uint32_t vref_en = 0;
+uint32_t trim = 0;
+int saradc_vref = -1;
+
 
 static int get_tsc(int temp)
 {
@@ -46,10 +49,24 @@ static int get_tsc(int temp)
 		break;
 	case MESON_CPU_MAJOR_ID_GXL:
 	case MESON_CPU_MAJOR_ID_GXM:
-		/*TS_C = 16-(adc-1778)/41*/
-		vmeasure = temp-(1778+(temp_base-27)*17);
+		if (vref_en) {
+			/*TS_C = 16-(adc-1655)/37.6*/
+			vmeasure = temp-(1655+(temp_base-27)*15.3);
+			printf("vmeasure=%d\n", vmeasure);
+			TS_C = 16-((vmeasure)/37.6);
+			break;
+		} else {
+			/*TS_C = 16-(adc-1778)/42*/
+			vmeasure = temp-(1778+(temp_base-27)*17);
+			printf("vmeasure=%d\n", vmeasure);
+			TS_C = 16-((vmeasure)/42);
+			break;
+		}
+	case MESON_CPU_MAJOR_ID_TXL:
+		/*TS_C = 16-(adc-1530)/40*/
+		vmeasure = temp-(1530+(temp_base-27)*15.5);
 		printf("vmeasure=%d\n", vmeasure);
-		TS_C = 16-((vmeasure)/42);
+		TS_C = 16-((vmeasure)/40);
 		break;
 	default:
 		printf("cpu family id not support!!!\n");
@@ -97,6 +114,18 @@ static int adc_init_chan6(void)
 		writel(0x0c00c400, SAR_ADC_DELTA_10);
 		writel(0x00000114, SAR_CLK_CNTL);/*Clock*/
 		break;
+	case MESON_CPU_MAJOR_ID_TXL:
+		writel(0x00000006, SAR_ADC_CHAN_LIST);/*channel 6*/
+		writel(0x00003000, SAR_ADC_AVG_CNTL);
+		writel(0xc8a8500a, SAR_ADC_REG3);/*bit27:1 disable*/
+		writel(0x010a000a, SAR_ADC_DELAY);
+		writel(0x03eb1a0c, SAR_ADC_AUX_SW);
+		writel(0x008c000c, SAR_ADC_CHAN_10_SW);
+		writel(0x030e030c, SAR_ADC_DETECT_IDLE_SW);
+		writel(0x0c00c400, SAR_ADC_DELTA_10);
+		writel(0x00000110, SAR_CLK_CNTL);/*Clock*/
+		writel(0x002c2060, SAR_ADC_REG11);/*bit20 disabled*/
+		break;
 	default:
 		printf("cpu family id not support!!!\n");
 		return -1;
@@ -137,7 +166,28 @@ static int get_adc_sample(int chan)
 			udelay(20);
 		}
 	}
-
+#ifndef CONFIG_CHIP_AML_GXB
+	/* if thermal VREF(5 bits) is not zero, write it to SAR_ADC_REG13[13:9]
+	 * and set SAR_ADC_REG13[8]:0, chipid >= GXL
+	 */
+	if (get_cpu_id().family_id >= MESON_CPU_MAJOR_ID_GXL) {
+		saradc_vref = (readl(SAR_ADC_REG13)>>8)&0x3f; /*back up SAR_ADC_REG13[13:8]*/
+		if ((readl(AO_SEC_SD_CFG12)>>19) & 0x1f) { /*thermal VREF*/
+			writel(((readl(SAR_ADC_REG13))&(~(0x3f<<8))) /*SAR_ADC_REG13[8]:0*/
+				|(((readl(AO_SEC_SD_CFG12)>>19) & 0x1f)<<9), /*SAR_ADC_REG13[13:9]*/
+				SAR_ADC_REG13);
+			vref_en = 1;
+		} else if ((get_cpu_id().family_id == MESON_CPU_MAJOR_ID_TXL)&&
+			((trim == 1)||
+			((((readl(SEC_AO_SEC_SD_CFG12))>>24)&0xff)==0xc0))) {
+			writel(((readl(SAR_ADC_REG13))&(~(0x3f<<8))) /*SAR_ADC_REG13[13:8]:0*/
+				|(0x1e<<8), /*SAR_ADC_REG13[13:8]:[0x1e]*/
+				SAR_ADC_REG13);
+		} else {
+			writel((readl(SAR_ADC_REG13))&(~(0x3f<<8)), SAR_ADC_REG13);
+		}
+	}
+#endif
 	writel(0x00000006, SAR_ADC_CHAN_LIST);/*channel 6*/
 	writel(0xc000c|(0x6<<23)|(0x6<<7), SAR_ADC_DETECT_IDLE_SW);/*channel 6*/
 
@@ -158,6 +208,12 @@ static int get_adc_sample(int chan)
 	}
 
 	value = readl(SAR_ADC_FIFO_RD);
+#ifndef CONFIG_CHIP_AML_GXB
+	if (saradc_vref >= 0) /*write back SAR_ADC_REG13[13:8]*/
+		writel(((readl(SAR_ADC_REG13))&(~(0x3f<<8)))|
+				((saradc_vref & 0x3f)<<8),
+				SAR_ADC_REG13);
+#endif
 	writel(readl(SAR_ADC_DELAY)&(~(FLAG_BUSY_BL30)), SAR_ADC_DELAY);
 	if (((value>>12) & 0x7) == 0x6)
 		value = value&SAMPLE_BIT_MASK;
@@ -240,6 +296,7 @@ static unsigned do_read_calib_data(int *flag, int *temp, int *TS_C)
 
 	if (get_cpu_id().family_id >= MESON_CPU_MAJOR_ID_GXL)
 		*temp = (*temp)<<2; /*adc 12bit sample*/
+
 	printf("adc=%d,TS_C=%d,flag=%d\n", *temp, *TS_C, *flag);
 	return ret;
 }
@@ -270,6 +327,7 @@ static int do_write_trim(cmd_tbl_t *cmdtp, int flag1,
 		flag = 0;
 		temp = 0;
 		TS_C = 0;
+		trim = 1;
 	}
 	for (i = 0; i < NUM; i++) {
 		udelay(10000);
@@ -324,7 +382,17 @@ static int do_write_trim(cmd_tbl_t *cmdtp, int flag1,
 		break;
 	case MESON_CPU_MAJOR_ID_GXL:/*12bit*/
 	case MESON_CPU_MAJOR_ID_GXM:
-		temp = temp - 17*(temp_base - 27);
+		if (vref_en) {
+			temp = temp - 15.3*(temp_base - 27);
+			temp = temp>>2;/*efuse only 10bit adc*/
+			break;
+		} else {
+			temp = temp - 17*(temp_base - 27);
+			temp = temp>>2;/*efuse only 10bit adc*/
+			break;
+		}
+	case MESON_CPU_MAJOR_ID_TXL:
+		temp = temp - 15.5*(temp_base - 27);
 		temp = temp>>2;/*efuse only 10bit adc*/
 		break;
 	default:
@@ -377,7 +445,13 @@ static int do_read_temp(cmd_tbl_t *cmdtp, int flag1,
 				break;
 			case MESON_CPU_MAJOR_ID_GXL:
 			case MESON_CPU_MAJOR_ID_GXM:
-				tempa = (10*(adc-temp))/171+27;
+				if (vref_en)/*thermal VREF*/
+					tempa = (10*(adc-temp))/153+27;
+				else
+					tempa = (10*(adc-temp))/171+27;
+				break;
+			case MESON_CPU_MAJOR_ID_TXL:
+				tempa = (10*(adc-temp))/155+27;
 				break;
 			}
 			printf("tempa=%d\n", tempa);
diff --git a/common/cmd_d2pll.c b/common/cmd_d2pll.c
index 67f077b..4488698 100644
--- a/common/cmd_d2pll.c
+++ b/common/cmd_d2pll.c
@@ -7,26 +7,8 @@
 #include <asm/arch/io.h>
 #include <asm/arch/secure_apb.h>
 #include <asm/arch/romboot.h>
-
-void watchdog_reset_system(void)
-{
-		int i;
-
-		while (1) {
-		writel(	0x3	| (1 << 21) // sys reset en
-				| (1 << 23) // interrupt en
-				| (1 << 24) // clk en
-				| (1 << 25) // clk div en
-				| (1 << 26) // sys reset now
-			, P_WATCHDOG_CNTL);
-				writel(0, P_WATCHDOG_RESET);
-
-				writel(readl(P_WATCHDOG_CNTL) | (1<<18), // watchdog en
-			P_WATCHDOG_CNTL);
-				for (i=0; i<100; i++)
-						readl(P_WATCHDOG_CNTL);/*Deceive gcc for waiting some cycles */
-	}
-}
+#include <asm/arch/watchdog.h>
+#include <asm/cpu_id.h>
 
 int do_ddr2pll(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -42,31 +24,29 @@ int do_ddr2pll(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		printf ("Error: Wrong format parament!\n");
 		return 1;
 	}
-if (argc >2)
-{
-	zqcr = simple_strtoul(argv[2], &endp, 16);
-	if (*argv[2] == 0 || *endp != 0) {
+	if (argc >2)
+	{
+		zqcr = simple_strtoul(argv[2], &endp, 16);
+		if (*argv[2] == 0 || *endp != 0) {
+			zqcr = 0;
+		}
+	}
+	else
+	{
 		zqcr = 0;
 	}
-}
-else
-{
-	  zqcr = 0;
-}
 
 #if defined(CONFIG_M6TV) || defined(CONFIG_M6TVD)
 	writel(zqcr | (0x3c << 24), P_PREG_STICKY_REG0);
 #else
 	writel(zqcr | (0xf13 << 20), P_PREG_STICKY_REG0);
 #endif
-	writel(pll, P_PREG_STICKY_REG1);
+	writel(pll | (readl(P_PREG_STICKY_REG1)), P_PREG_STICKY_REG1);
 	printf("Set pll done [0x%08x]\n", readl(P_PREG_STICKY_REG1));
 #ifdef CONFIG_M8B
 	writel(0xf080000 | 2000, WATCHDOG_TC);
 #else
-  //  writel(WATCHDOG_TC, 0xf400000 | 2000);
- // *P_WATCHDOG_RESET = 0;
- watchdog_reset_system();
+	reset_system();
 #endif
 
 	return 0;
@@ -82,6 +62,52 @@ U_BOOT_CMD(
 	"DDR PLL set: d2pll PLL [ZQCR], e...g... 0x1022c.\n"
 );
 
+#define DDR_FULL_TEST_CTRL_BIT		21 //use sticky1 bit21
+int do_ddrft(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) {
+	unsigned long ddr_full_test = 0;
+	//printf("sticky1: 0x%x\n", readl(P_PREG_STICKY_REG1));
+
+	if (get_cpu_id().family_id <= MESON_CPU_MAJOR_ID_GXTVBB) {
+		printf("Only support gxl/gxm/txl... chips!\n");
+		return 0;
+	}
+
+	if (argc == 1) {
+		/* no parameters, switch 1/0 */
+		if ((readl(P_PREG_STICKY_REG1)) & (1<<DDR_FULL_TEST_CTRL_BIT)) {
+			writel((~(1<<DDR_FULL_TEST_CTRL_BIT)) & (readl(P_PREG_STICKY_REG1)), P_PREG_STICKY_REG1);
+		}
+		else {
+			writel((1<<DDR_FULL_TEST_CTRL_BIT) | (readl(P_PREG_STICKY_REG1)), P_PREG_STICKY_REG1);
+		}
+	}
+	else if (argc == 2) {
+		ddr_full_test = simple_strtoul(argv[1], NULL,0);
+		if (ddr_full_test)
+			ddr_full_test = 1;
+		writel((~(1<<DDR_FULL_TEST_CTRL_BIT)) & (readl(P_PREG_STICKY_REG1)), P_PREG_STICKY_REG1);
+		writel((ddr_full_test << DDR_FULL_TEST_CTRL_BIT) | (readl(P_PREG_STICKY_REG1)), P_PREG_STICKY_REG1);
+	}
+
+	//printf("sticky1: 0x%x\n", readl(P_PREG_STICKY_REG1));
+	if (readl(P_PREG_STICKY_REG1) & (1<<DDR_FULL_TEST_CTRL_BIT))
+		printf("ddr full test enabled!\n");
+	else
+		printf("ddr full test disabled!\n");
+	return 0;
+}
+
+/* ddr full test support, co-work with d2pll function */
+/*
+  before d2pll command, use
+  ddrft 1
+  cmd enable ddr full test function
+*/
+U_BOOT_CMD(
+	ddrft,	5,	1,	do_ddrft,
+	"Enable/Disable ddr full test at runtime\n\nOnly support gxl/gxm/txl",
+	"[1/0]\n"
+);
 
 int do_ddr_sram_tune(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -98,17 +124,17 @@ int do_ddr_sram_tune(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		return 1;
 	}
 
-if (argc >2)
-{
-	zqcr = simple_strtoul(argv[2], &endp, 16);
-	if (*argv[2] == 0 || *endp != 0) {
+	if (argc >2)
+	{
+		zqcr = simple_strtoul(argv[2], &endp, 16);
+		if (*argv[2] == 0 || *endp != 0) {
+			zqcr = 0;
+		}
+	}
+	else
+	{
 		zqcr = 0;
 	}
-}
-else
-{
-	  zqcr = 0;
-}
 #if defined(CONFIG_M6TV) || defined(CONFIG_M6TVD)
 	writel(zqcr | (0x3c << 24), P_PREG_STICKY_REG0);
 #else
@@ -120,9 +146,7 @@ else
 #ifdef CONFIG_M8B
 	writel(0xf080000 | 2000, WATCHDOG_TC);
 #else
-	//writel(WATCHDOG_TC, 0xf400000 | 2000);
-	//*P_WATCHDOG_RESET = 0;
-	watchdog_reset_system();
+	reset_system();
 #endif
 
 	return 0;
diff --git a/common/cmd_efuse.c b/common/cmd_efuse.c
index f05f3e9..d36fdb8 100644
--- a/common/cmd_efuse.c
+++ b/common/cmd_efuse.c
@@ -33,6 +33,7 @@
 #define CMD_EFUSE_PASSWORD_SET     7
 #define CMD_EFUSE_CUSTOMER_ID_SET  8
 
+#define CMD_EFUSE_AMLOGIC_SET      20
 
 
 int cmd_efuse(int argc, char * const argv[], char *buf)
@@ -58,6 +59,9 @@ int cmd_efuse(int argc, char * const argv[], char *buf)
 	} else if (strncmp(argv[1], "customer_id_set", 15) == 0) {
 		action = CMD_EFUSE_CUSTOMER_ID_SET;
 		goto efuse_action;
+	} else if (strncmp(argv[1], "amlogic_set", 11) == 0) {
+		action = CMD_EFUSE_AMLOGIC_SET;
+		goto efuse_action;
 	} else{
 		printf("%s arg error\n", argv[1]);
 		return CMD_RET_USAGE;
@@ -146,6 +150,28 @@ efuse_action:
 			printf("aml log : Secure boot EFUSE pattern programming success!\n");
 
 		return ret;
+	} else if (CMD_EFUSE_AMLOGIC_SET == action) {
+		/*efuse amlogic_set*/
+
+		lAddr1 = GXB_IMG_LOAD_ADDR;
+
+		if (argc > 2)
+			lAddr1 = simple_strtoul(argv[2], &end, 16);
+
+		lAddr2 = get_sharemem_info(GET_SHARE_MEM_INPUT_BASE);
+		memcpy((void *)lAddr2, (void *)lAddr1, GXB_EFUSE_PATTERN_SIZE);
+		flush_cache(lAddr2,GXB_EFUSE_PATTERN_SIZE);
+
+		ret = aml_sec_boot_check(AML_D_P_W_EFUSE_AMLOGIC, lAddr2,
+			GXB_EFUSE_PATTERN_SIZE, 0);
+
+		if (ret)
+			printf("aml log : Amlogic EFUSE pattern programming fail [%d]!\n",
+			       ret);
+		else
+			printf("aml log : Amlogic EFUSE pattern programming success!\n");
+
+		return ret;
 	} else if(CMD_EFUSE_PASSWORD_SET == action)	{
 		/*efuse password_set*/
 
diff --git a/common/cmd_hdmitx.c b/common/cmd_hdmitx.c
index 3051cf7..cbb79f2 100644
--- a/common/cmd_hdmitx.c
+++ b/common/cmd_hdmitx.c
@@ -78,6 +78,91 @@ static int do_edid(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 	return st;
 }
 
+static int do_rx_det(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned char edid_addr = 0xf8;     // Fixed Address
+	unsigned char st = 0;
+
+	memset(edid_raw_buf, 0, ARRAY_SIZE(edid_raw_buf));
+
+	// read edid raw data
+	// current only support read 1 byte edid data
+	st = hdmitx_device.HWOp.read_edid(&edid_raw_buf[edid_addr & 0xf8], edid_addr & 0xf8, 8);
+	if (1)      // Debug only
+		dump_edid_raw(&edid_raw_buf[edid_addr & 0xf8]);
+	if (st) {
+#if 0
+		// set fake value for debug
+		edid_raw_buf[250] = 0xfb;
+		edid_raw_buf[251] = 0x0c;
+		edid_raw_buf[252] = 0x01;
+#endif
+		if ((edid_raw_buf[250] == 0xfb) & (edid_raw_buf[251] == 0x0c)) {
+			printf("RX is FBC\n");
+
+			// set outputmode ENV
+			switch (edid_raw_buf[252] & 0x0f) {
+			case 0x0:
+				run_command("setenv outputmode 1080p50hz", 0);
+				break;
+			case 0x1:
+				run_command("setenv outputmode 2160p50hz420", 0);
+				break;
+			case 0x2:
+				run_command("setenv outputmode 1080p50hz44410bit", 0);
+				break;
+			case 0x3:
+				run_command("setenv outputmode 2160p50hz42010bit", 0);
+				break;
+			case 0x4:
+				run_command("setenv outputmode 2160p50hz42210bit", 0);
+				break;
+			case 0x5:
+				run_command("setenv outputmode 2160p50hz", 0);
+				break;
+			default:
+				run_command("setenv outputmode 1080p50hz", 0);
+				break;
+			}
+
+			// set RX 3D Info
+			switch ((edid_raw_buf[252] >> 4) & 0x0f) {
+			case 0x00:
+				run_command("setenv rx_3d_info 0", 0);
+				break;
+			case 0x01:
+				run_command("setenv rx_3d_info 1", 0);
+				break;
+			case 0x02:
+				run_command("setenv rx_3d_info 2", 0);
+				break;
+			case 0x03:
+				run_command("setenv rx_3d_info 3", 0);
+				break;
+			case 0x04:
+				run_command("setenv rx_3d_info 4", 0);
+				break;
+			default:
+				break;
+			}
+
+			switch (edid_raw_buf[253]) {
+			case 0x1:
+				// TODO
+				break;
+			case 0x2:
+				// TODO
+				break;
+			default:
+				break;
+			}
+		}
+	} else
+		printf("edid read failed\n");
+
+	return st;
+}
+
 static int do_output(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	if (argc < 1)
@@ -145,6 +230,7 @@ static int do_info(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 static cmd_tbl_t cmd_hdmi_sub[] = {
 	U_BOOT_CMD_MKENT(hpd, 1, 1, do_hpd_detect, "", ""),
 	U_BOOT_CMD_MKENT(edid, 3, 1, do_edid, "", ""),
+	U_BOOT_CMD_MKENT(rx_det, 1, 1, do_rx_det, "", ""),
 	U_BOOT_CMD_MKENT(output, 3, 1, do_output, "", ""),
 	U_BOOT_CMD_MKENT(blank, 3, 1, do_blank, "", ""),
 	U_BOOT_CMD_MKENT(off, 1, 1, do_off, "", ""),
@@ -190,4 +276,6 @@ U_BOOT_CMD(hdmitx, CONFIG_SYS_MAXARGS, 0, do_hdmitx,
 	"    Turn off hdmitx output\n"
 	"hdmitx info\n"
 	"    current mode info\n"
+	"hdmitx rx_det\n"
+	"    Auto detect if RX is FBC and set outputmode\n"
 );
diff --git a/common/cmd_mmc.c b/common/cmd_mmc.c
index 868031c..6219c63 100644
--- a/common/cmd_mmc.c
+++ b/common/cmd_mmc.c
@@ -445,7 +445,7 @@ static int do_mmc_list(cmd_tbl_t *cmdtp, int flag,
 	return CMD_RET_SUCCESS;
 }
 
-static int do_mmc_ext_csd(cmd_tbl_t *cmdtp, int flag,
+static int do_mmc_lifetime(cmd_tbl_t *cmdtp, int flag,
 		       int argc, char * const argv[])
 {
 	int dev;
@@ -463,6 +463,33 @@ static int do_mmc_ext_csd(cmd_tbl_t *cmdtp, int flag,
 	return CMD_RET_SUCCESS;
 }
 
+static int do_mmc_ext_csd(cmd_tbl_t *cmdtp, int flag,
+		       int argc, char * const argv[])
+{
+	int bit = 0, value = 0, ret = 0;
+	struct mmc *mmc;
+	char str[128] = {0};
+
+	if ((argc != 2) && (argc != 3))
+		return CMD_RET_USAGE;
+
+	bit = simple_strtoul(argv[1], NULL, 10);
+	if (argc == 3)
+		value = simple_strtoul(argv[2], NULL, 16);
+
+	mmc = init_mmc_device(curr_device, false);
+	if (!mmc)
+		return CMD_RET_FAILURE;
+
+	if (argc == 2)
+		sprintf(str, "amlmmc ext_csd 1 %d", bit);
+	else
+		sprintf(str, "amlmmc ext_csd 1 %d %x", bit, value);
+
+	ret = run_command(str, 0);
+	return (ret == 0) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+}
+
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
 static int do_mmc_bootbus(cmd_tbl_t *cmdtp, int flag,
 			  int argc, char * const argv[])
@@ -620,7 +647,8 @@ static cmd_tbl_t cmd_mmc[] = {
 	U_BOOT_CMD_MKENT(part, 1, 1, do_mmc_part, "", ""),
 	U_BOOT_CMD_MKENT(dev, 3, 0, do_mmc_dev, "", ""),
 	U_BOOT_CMD_MKENT(list, 1, 1, do_mmc_list, "", ""),
-	U_BOOT_CMD_MKENT(lifetime, 1, 1, do_mmc_ext_csd, "", ""),
+	U_BOOT_CMD_MKENT(lifetime, 1, 1, do_mmc_lifetime, "", ""),
+	U_BOOT_CMD_MKENT(ext_csd, 3, 0, do_mmc_ext_csd, "", ""),
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
 	U_BOOT_CMD_MKENT(bootbus, 5, 0, do_mmc_bootbus, "", ""),
 	U_BOOT_CMD_MKENT(bootpart-resize, 4, 0, do_mmc_boot_resize, "", ""),
@@ -671,6 +699,7 @@ U_BOOT_CMD(
 	"mmc dev [dev] [part] - show or set current mmc device [partition]\n"
 	"mmc list - lists available devices\n"
 	"mmc lifetime - show dev life time estimate type A/B\n"
+	"mmc ext_csd [bit] <val> - read/write ext_csd [bit] value\n"
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
 	"mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode\n"
 	" - Set the BOOT_BUS_WIDTH field of the specified device\n"
diff --git a/common/store_interface.c b/common/store_interface.c
index efe9ad9..57c07ae 100644
--- a/common/store_interface.c
+++ b/common/store_interface.c
@@ -13,19 +13,24 @@
 #include <div64.h>
 #include <linux/err.h>
 #include<partition_table.h>
+#include<emmc_partitions.h>
 #include <libfdt.h>
 #include <linux/string.h>
 #include <asm/cpu_id.h>
 
 #if defined(CONFIG_AML_NAND)
 extern int amlnf_init(unsigned flag);
-extern int amlnf_key_write(u8 *buf, int len);
-extern int amlnf_key_read(u8 * buf, int len);
+extern int amlnf_key_write(u8 *buf, int len, uint32_t *actual_lenth);
+extern int amlnf_key_read(u8 * buf, int len, uint32_t *actual_lenth);
 #endif
 extern int get_partition_from_dts(unsigned char * buffer);
-extern int mmc_key_read(unsigned char *buf, unsigned int size);
-extern int mmc_key_write(unsigned char *buf, unsigned int size);
+extern int mmc_key_read(unsigned char *buf,
+		unsigned int size, uint32_t *actual_lenth);
+extern int mmc_key_write(unsigned char *buf,
+		unsigned int size, uint32_t *actual_lenth);
 extern int mmc_key_erase(void);
+extern int find_dev_num_by_partition_name (char *name);
+extern unsigned emmc_cur_partition;
 
 #define MsgP(fmt...)   printf("[store]"fmt)
 #define ErrP(fmt...)   printf("[store]Err:%s,L%d:", __func__, __LINE__),printf(fmt)
@@ -295,7 +300,7 @@ static int do_store_key_ops(cmd_tbl_t * cmdtp, int flag, int argc, char * const
 	return ret;
 }
 
-int store_key_read(uint8_t * buffer,  uint32_t length)
+int store_key_read(uint8_t * buffer, uint32_t length, uint32_t *actual_lenth)
 {
 	int ret = 0;
 	switch (device_boot_flag)
@@ -303,12 +308,12 @@ int store_key_read(uint8_t * buffer,  uint32_t length)
 #if defined(CONFIG_AML_NAND)
 		case NAND_BOOT_FLAG:
 		case SPI_NAND_FLAG:
-		ret = amlnf_key_read(buffer, (int) length);
+		ret = amlnf_key_read(buffer, (int) length, actual_lenth);
 		break;
 #endif
 		case EMMC_BOOT_FLAG:
 		case SPI_EMMC_FLAG:
-		ret = mmc_key_read(buffer, (int) length);
+		ret = mmc_key_read(buffer, (int) length, actual_lenth);
 		break;
 		default:
 		ErrP("device_boot_flag=0x%x err\n", device_boot_flag);
@@ -317,20 +322,21 @@ int store_key_read(uint8_t * buffer,  uint32_t length)
 	return ret;
 }
 
-int store_key_write(uint8_t * buffer, uint32_t length)
+int store_key_write(uint8_t * buffer, uint32_t length, uint32_t *actual_lenth)
 {
 	int ret = 0;
+
 	switch (device_boot_flag)
 	{
 #if defined(CONFIG_AML_NAND)
 		case NAND_BOOT_FLAG:
 		case SPI_NAND_FLAG:
-		ret = amlnf_key_write(buffer, (int) length);
+		ret = amlnf_key_write(buffer, (int) length,  actual_lenth);
 		break;
 #endif
 		case EMMC_BOOT_FLAG:
 		case SPI_EMMC_FLAG:
-		ret = mmc_key_write(buffer, (int) length);
+		ret = mmc_key_write(buffer, (int) length, actual_lenth);
 		break;
 		default:
 		ErrP("device_boot_flag=0x%x err\n", device_boot_flag);
@@ -840,7 +846,52 @@ E_SWITCH_BACK:
             }
         #endif
         }
-    }
+	} else if (strcmp(area, "partition") == 0) {
+		if (device_boot_flag == EMMC_BOOT_FLAG) {
+			int blk_shift;
+			int dev, n;
+			u64 cnt=0, blk =0;
+			struct partitions *part_info;
+			struct mmc *mmc = NULL;
+			char *p_name = NULL;
+
+			p_name = argv[3];
+			if (!p_name)
+				return CMD_RET_USAGE;
+
+			dev = find_dev_num_by_partition_name(p_name);
+			mmc = find_mmc_device(dev);
+			if (!mmc)
+				return CMD_RET_FAILURE;
+
+			mmc_init(mmc);
+			blk_shift = ffs(mmc->read_bl_len) -1;
+			if (!(info_disprotect & DISPROTECT_KEY)
+					&& (strncmp(p_name, MMC_RESERVED_NAME,
+							sizeof(MMC_RESERVED_NAME)) == 0x00)) {
+				printf("\"%s-partition\" is been protecting and should no be erased!\n",
+						MMC_RESERVED_NAME);
+				return CMD_RET_FAILURE;
+			}
+
+			part_info = find_mmc_partition_by_name(p_name);
+			if (part_info == NULL)
+				return CMD_RET_FAILURE;
+
+			blk = part_info->offset>> blk_shift;
+			if (emmc_cur_partition
+					&& !strncmp(p_name, "bootloader", strlen("bootloader")))
+				cnt = mmc->boot_size>> blk_shift;
+			else
+				cnt = part_info->size>> blk_shift;
+			n = mmc->block_dev.block_erase(dev, blk, cnt);
+			printf("store erase \"%s-partition\" is %s\n", p_name, n ? "fail" : "ok");
+			if (n)
+				return CMD_RET_FAILURE;
+		}
+	} else
+		return CMD_RET_USAGE;
+
     return 0;
 }
 
@@ -1361,8 +1412,11 @@ U_BOOT_CMD(store, CONFIG_SYS_MAXARGS, 1, do_store,
 	"	write uboot to the boot device\n"
 	"store erase boot/data: \n"
 	"	erase the area which is uboot or data \n"
+	"store erase partition <partition_name>: \n"
+	"	erase the area which partition in u-boot \n"
 	"store erase dtb \n"
 	"store erase key \n"
+	"store disprotect key \n"
 	"store rom_protect on/off \n"
 	"store scrub off|partition size\n"
 	"	scrub the area from offset and size \n"
diff --git a/drivers/display/canvas/canvas.c b/drivers/display/canvas/canvas.c
index 85462a6..87343ea 100644
--- a/drivers/display/canvas/canvas.c
+++ b/drivers/display/canvas/canvas.c
@@ -37,6 +37,25 @@
 
 #define CANVAS_NUM 192
 static canvas_t canvasPool[CANVAS_NUM];
+static int canvas_inited = 0;
+
+static void canvas_init(void)
+{
+	int index = 0;
+
+	if (canvas_inited == 1)
+		return;
+
+	canvas_log("canvas init");
+	canvas_reg_write(0, DC_CAV_LUT_DATAL);
+	canvas_reg_write(0, DC_CAV_LUT_DATAH);
+	for (index = 0; index < CANVAS_NUM; index++) {
+		canvas_reg_write(CANVAS_LUT_WR_EN | index, DC_CAV_LUT_ADDR);
+		canvas_reg_read(DC_CAV_LUT_DATAH);
+	}
+
+	canvas_inited = 1;
+}
 
 void canvas_config(u32 index, ulong addr, u32 width,
 		   u32 height, u32 wrap, u32 blkmode)
@@ -46,8 +65,9 @@ void canvas_config(u32 index, ulong addr, u32 width,
 	if (index >= CANVAS_NUM)
 		return;
 
-	canvas_log("addr=0x%08lx width=%d, height=%d\n", addr, width, height);
+	canvas_init();
 
+	canvas_log("addr=0x%08lx width=%d, height=%d", addr, width, height);
 	canvas_reg_write((((addr + 7) >> 3) & CANVAS_ADDR_LMASK) |
 			 ((((width + 7) >> 3) & CANVAS_WIDTH_LMASK) << CANVAS_WIDTH_LBIT),
 			 DC_CAV_LUT_DATAL);
diff --git a/drivers/display/lcd/aml_lcd.c b/drivers/display/lcd/aml_lcd.c
index 2f560ca..40dc48c 100644
--- a/drivers/display/lcd/aml_lcd.c
+++ b/drivers/display/lcd/aml_lcd.c
@@ -15,6 +15,7 @@
 
 #include <common.h>
 #include <malloc.h>
+#include <asm/cpu_id.h>
 #include <asm/arch/gpio.h>
 #ifdef CONFIG_OF_LIBFDT
 #include <libfdt.h>
@@ -34,10 +35,10 @@ static struct aml_lcd_drv_s aml_lcd_driver;
 
 static void lcd_chip_detect(void)
 {
-#if 0
+#if 1
 	unsigned int cpu_type;
 
-	cpu_type = get_cpu_type();
+	cpu_type = get_cpu_id().family_id;
 	switch (cpu_type) {
 	case MESON_CPU_MAJOR_ID_M8:
 		aml_lcd_driver.chip_type = LCD_CHIP_M8;
@@ -54,11 +55,14 @@ static void lcd_chip_detect(void)
 	case MESON_CPU_MAJOR_ID_GXTVBB:
 		aml_lcd_driver.chip_type = LCD_CHIP_GXTVBB;
 		break;
+	case MESON_CPU_MAJOR_ID_TXL:
+		aml_lcd_driver.chip_type = LCD_CHIP_TXL;
+		break;
 	default:
 		aml_lcd_driver.chip_type = LCD_CHIP_MAX;
 	}
 #else
-	aml_lcd_driver.chip_type = LCD_CHIP_GXTVBB;
+	aml_lcd_driver.chip_type = LCD_CHIP_TXL;
 #endif
 	if (lcd_debug_print_flag)
 		LCDPR("check chip: %d\n", aml_lcd_driver.chip_type);
@@ -215,17 +219,27 @@ static void lcd_timing_info_print(struct lcd_config_s * pconf)
 	vs_pol = pconf->lcd_timing.vsync_pol;
 
 	printf("h_period          %d\n"
-	   "v_period          %d\n"
-	   "hs_width          %d\n"
-	   "hs_backporch      %d\n"
-	   "hs_pol            %d\n"
-	   "vs_width          %d\n"
-	   "vs_backporch      %d\n"
-	   "vs_pol            %d\n"
-	   "video_on_pixel    %d\n"
-	   "video_on_line     %d\n\n",
-	   h_period, v_period, hs_width, hs_bp, hs_pol,
-	   vs_width, vs_bp, vs_pol, video_on_pixel, video_on_line);
+		"v_period          %d\n"
+		"hs_width          %d\n"
+		"hs_backporch      %d\n"
+		"hs_pol            %d\n"
+		"vs_width          %d\n"
+		"vs_backporch      %d\n"
+		"vs_pol            %d\n"
+		"video_on_pixel    %d\n"
+		"video_on_line     %d\n\n",
+		h_period, v_period, hs_width, hs_bp, hs_pol,
+		vs_width, vs_bp, vs_pol, video_on_pixel, video_on_line);
+
+	printf("h_period_min      %d\n"
+		"h_period_max      %d\n"
+		"v_period_min      %d\n"
+		"v_period_max      %d\n"
+		"pclk_min          %d\n"
+		"pclk_max          %d\n\n",
+		pconf->lcd_basic.h_period_min, pconf->lcd_basic.h_period_max,
+		pconf->lcd_basic.v_period_min, pconf->lcd_basic.v_period_max,
+		pconf->lcd_basic.lcd_clk_min, pconf->lcd_basic.lcd_clk_max);
 }
 
 static void lcd_power_info_print(struct lcd_config_s *pconf, int status)
@@ -306,13 +320,17 @@ static void lcd_info_print(void)
 		   "pn_swap           %u\n"
 		   "port_swap         %u\n"
 		   "phy_vswing        %u\n"
-		   "phy_preemphasis   %u\n\n",
+		   "phy_preem         %u\n"
+		   "phy_clk_vswing    %u\n"
+		   "phy_clk_preem     %u\n\n",
 		   pconf->lcd_control.lvds_config->lvds_repack,
 		   pconf->lcd_control.lvds_config->dual_port,
 		   pconf->lcd_control.lvds_config->pn_swap,
 		   pconf->lcd_control.lvds_config->port_swap,
 		   pconf->lcd_control.lvds_config->phy_vswing,
-		   pconf->lcd_control.lvds_config->phy_preem);
+		   pconf->lcd_control.lvds_config->phy_preem,
+		   pconf->lcd_control.lvds_config->phy_clk_vswing,
+		   pconf->lcd_control.lvds_config->phy_clk_preem);
 		break;
 	case LCD_VBYONE:
 		printf("lane_count        %u\n"
@@ -326,6 +344,18 @@ static void lcd_info_print(void)
 		   pconf->lcd_control.lvds_config->phy_vswing,
 		   pconf->lcd_control.lvds_config->phy_preem);
 		break;
+	case LCD_TTL:
+		printf("clk_pol           %u\n"
+		   "hvsync_valid      %u\n"
+		   "DE_valid          %u\n"
+		   "bit_swap          %u\n"
+		   "rb_swap           %u\n\n",
+		   pconf->lcd_control.ttl_config->clk_pol,
+		   (pconf->lcd_control.ttl_config->sync_valid >> 0) & 1,
+		   (pconf->lcd_control.ttl_config->sync_valid >> 1) & 1,
+		   (pconf->lcd_control.ttl_config->swap_ctrl >> 0) & 1,
+		   (pconf->lcd_control.ttl_config->swap_ctrl >> 1) & 1);
+		break;
 	default:
 		break;
 	}
@@ -442,7 +472,17 @@ static void lcd_vbyone_reg_print(void)
 	unsigned int reg;
 
 	printf("\nvbyone registers:\n");
-	reg = PERIPHS_PIN_MUX_7;
+	switch (aml_lcd_driver.chip_type) {
+	case LCD_CHIP_GXTVBB:
+		reg = PERIPHS_PIN_MUX_7;
+		break;
+	case LCD_CHIP_TXL:
+		reg = PERIPHS_PIN_MUX_0;
+		break;
+	default:
+		reg = PERIPHS_PIN_MUX_0;
+		break;
+	}
 	printf("VX1_PINMUX          [0x%04x] = 0x%08x\n",
 		reg, lcd_periphs_read(reg));
 	reg = VBO_STATUS_L;
@@ -653,7 +693,7 @@ static int lcd_mode_probe(void)
 {
 	int load_id = 0;
 	unsigned int lcd_debug_test = 0;
-	char *dt_addr;
+	char *dt_addr, *str;
 	int ret;
 
 	dt_addr = NULL;
@@ -671,7 +711,14 @@ static int lcd_mode_probe(void)
 	}
 #endif
 
-	lcd_debug_test = simple_strtoul(getenv("lcd_debug_test"), NULL, 10);
+	str = getenv("lcd_debug_test");
+	if (str == NULL) {
+		lcd_debug_test = 0;
+		LCDPR("no lcd_debug_test flag\n");
+	} else {
+		lcd_debug_test = simple_strtoul(str, NULL, 10);
+		LCDPR("lcd_debug_test flag: %d\n", lcd_debug_test);
+	}
 	if (lcd_debug_test)
 		load_id = 0x0;
 
@@ -752,8 +799,16 @@ int lcd_probe(void)
 #ifdef LCD_DEBUG_INFO
 	lcd_debug_print_flag = 1;
 #else
-	lcd_debug_print_flag = 0;
-	lcd_debug_print_flag = simple_strtoul(getenv("lcd_debug_print"), NULL, 10);
+	char *str;
+
+	str = getenv("lcd_debug_print");
+	if (str == NULL) {
+		lcd_debug_print_flag = 0;
+		LCDPR("no lcd_debug_print flag\n");
+	} else {
+		lcd_debug_print_flag = simple_strtoul(str, NULL, 10);
+		LCDPR("lcd_debug_print flag: %d\n", lcd_debug_print_flag);
+	}
 #endif
 
 	lcd_chip_detect();
diff --git a/drivers/display/lcd/aml_lcd_bl.c b/drivers/display/lcd/aml_lcd_bl.c
index c45cd26..be112c0 100644
--- a/drivers/display/lcd/aml_lcd_bl.c
+++ b/drivers/display/lcd/aml_lcd_bl.c
@@ -1931,6 +1931,11 @@ int aml_bl_config_load(char *dt_addr, int load_id)
 			if (lcd_debug_print_flag)
 				LCDPR("bl: load bl_config from dts\n");
 			index = lcd_drv->lcd_config->backlight_index;
+			if (index == 0xff) {
+				lcd_drv->bl_config->method = BL_CTRL_MAX;
+				LCDPR("bl: no backlight exist\n");
+				return -1;
+			}
 			ret = aml_bl_config_load_from_dts(dt_addr, index, lcd_drv->bl_config);
 #endif
 		}
diff --git a/drivers/display/lcd/aml_lcd_clk_config.c b/drivers/display/lcd/aml_lcd_clk_config.c
index c81d20f..c6ee6a4 100644
--- a/drivers/display/lcd/aml_lcd_clk_config.c
+++ b/drivers/display/lcd/aml_lcd_clk_config.c
@@ -22,6 +22,8 @@
 #include "aml_lcd_reg.h"
 #include "aml_lcd_common.h"
 
+static const unsigned int od_fb_table[2] = {1, 2};
+
 static const unsigned int od_table[4] = {
 	1, 2, 4, 8
 };
@@ -92,6 +94,14 @@ static char *lcd_pll_ss_table_gxtvbb[] = {
 	"4, +/-1.2%",
 };
 
+static char *lcd_pll_ss_table_txl[] = {
+	"0, disable",
+	"1, +/-0.3%",
+	"2, +/-0.5%",
+	"3, +/-0.9%",
+	"4, +/-1.2%",
+};
+
 static struct lcd_clk_config_s clk_conf = { /* unit: kHz */
 	/* IN-OUT parameters */
 	.fin = FIN_FREQ,
@@ -153,13 +163,13 @@ static void lcd_clk_config_init_print(void)
 	case LCD_CHIP_M8M2:
 	case LCD_CHIP_M8B:
 		LCDPR("lcd clk config init:\n"
-			"pll_m_max:      %d\n"
-			"pll_m_min:      %d\n"
-			"pll_n_max:      %d\n"
-			"pll_n_min:      %d\n"
-			"pll_frac_range: %d\n"
-			"pll_od_sel_max: %d\n"
-			"ss_level_max:   %d\n"
+			"pll_m_max:         %d\n"
+			"pll_m_min:         %d\n"
+			"pll_n_max:         %d\n"
+			"pll_n_min:         %d\n"
+			"pll_frac_range:    %d\n"
+			"pll_od_sel_max:    %d\n"
+			"ss_level_max:      %d\n"
 			"pll_ref_fmax:      %d\n"
 			"pll_ref_fmin:      %d\n"
 			"pll_vco_fmax:      %d\n"
@@ -180,17 +190,15 @@ static void lcd_clk_config_init_print(void)
 			clk_conf.div_pre_in_fmax, clk_conf.div_pre_out_fmax,
 			clk_conf.div_post_out_fmax, clk_conf.xd_out_fmax);
 		break;
-	case LCD_CHIP_G9TV:
-	case LCD_CHIP_G9BB:
-	case LCD_CHIP_GXTVBB:
+	default:
 		LCDPR("lcd clk config:\n"
-			"pll_m_max:      %d\n"
-			"pll_m_min:      %d\n"
-			"pll_n_max:      %d\n"
-			"pll_n_min:      %d\n"
-			"pll_frac_range: %d\n"
-			"pll_od_sel_max: %d\n"
-			"ss_level_max:   %d\n"
+			"pll_m_max:         %d\n"
+			"pll_m_min:         %d\n"
+			"pll_n_max:         %d\n"
+			"pll_n_min:         %d\n"
+			"pll_frac_range:    %d\n"
+			"pll_od_sel_max:    %d\n"
+			"ss_level_max:      %d\n"
 			"pll_ref_fmax:      %d\n"
 			"pll_ref_fmin:      %d\n"
 			"pll_vco_fmax:      %d\n"
@@ -210,8 +218,6 @@ static void lcd_clk_config_init_print(void)
 			clk_conf.div_in_fmax, clk_conf.div_out_fmax,
 			clk_conf.xd_out_fmax);
 		break;
-	default:
-		break;
 	}
 }
 
@@ -241,9 +247,7 @@ void lcd_clk_config_print(void)
 			clk_conf.div_pre, clk_conf.div_post,
 			clk_conf.xd, clk_conf.fout, clk_conf.ss_level);
 		break;
-	case LCD_CHIP_G9TV:
-	case LCD_CHIP_G9BB:
-	case LCD_CHIP_GXTVBB:
+	default:
 		LCDPR("lcd clk config:\n"
 			"pll_m:        %d\n"
 			"pll_n:        %d\n"
@@ -265,8 +269,6 @@ void lcd_clk_config_print(void)
 			clk_conf.div_sel, clk_conf.xd,
 			clk_conf.fout, clk_conf.ss_level);
 		break;
-	default:
-		break;
 	}
 }
 
@@ -331,8 +333,7 @@ static void lcd_clk_config_chip_init(void)
 		cConf->pll_vco_fmax = PLL_VCO_MAX_G9TV;
 		cConf->pll_vco_fmin = PLL_VCO_MIN_G9TV;
 		cConf->pll_out_fmax = CLK_DIV_IN_MAX_G9TV;
-		cConf->pll_out_fmin = cConf->pll_vco_fmin /
-			od_table[cConf->pll_od_sel_max - 1];
+		cConf->pll_out_fmin = cConf->pll_vco_fmin / 16;
 		cConf->div_in_fmax = CLK_DIV_IN_MAX_G9TV;
 		cConf->div_out_fmax = CRT_VID_CLK_IN_MAX_G9TV;
 		cConf->xd_out_fmax = ENCL_CLK_IN_MAX_G9TV;
@@ -350,8 +351,7 @@ static void lcd_clk_config_chip_init(void)
 		cConf->pll_vco_fmax = PLL_VCO_MAX_G9BB;
 		cConf->pll_vco_fmin = PLL_VCO_MIN_G9BB;
 		cConf->pll_out_fmax = CLK_DIV_IN_MAX_G9BB;
-		cConf->pll_out_fmin = cConf->pll_vco_fmin /
-			od_table[cConf->pll_od_sel_max - 1];
+		cConf->pll_out_fmin = cConf->pll_vco_fmin / 16;
 		cConf->div_in_fmax = CLK_DIV_IN_MAX_G9BB;
 		cConf->div_out_fmax = CRT_VID_CLK_IN_MAX_G9BB;
 		cConf->xd_out_fmax = ENCL_CLK_IN_MAX_G9BB;
@@ -369,12 +369,29 @@ static void lcd_clk_config_chip_init(void)
 		cConf->pll_vco_fmax = PLL_VCO_MAX_GXTVBB;
 		cConf->pll_vco_fmin = PLL_VCO_MIN_GXTVBB;
 		cConf->pll_out_fmax = CLK_DIV_IN_MAX_GXTVBB;
-		cConf->pll_out_fmin = cConf->pll_vco_fmin /
-			od_table[cConf->pll_od_sel_max - 1];
+		cConf->pll_out_fmin = cConf->pll_vco_fmin / 16;
 		cConf->div_in_fmax = CLK_DIV_IN_MAX_GXTVBB;
 		cConf->div_out_fmax = CRT_VID_CLK_IN_MAX_GXTVBB;
 		cConf->xd_out_fmax = ENCL_CLK_IN_MAX_GXTVBB;
 		break;
+	case LCD_CHIP_TXL:
+		cConf->ss_level_max = SS_LEVEL_MAX_TXL;
+		cConf->pll_m_max = PLL_M_MAX_TXL;
+		cConf->pll_m_min = PLL_M_MIN_TXL;
+		cConf->pll_n_max = PLL_N_MAX_TXL;
+		cConf->pll_n_min = PLL_N_MIN_TXL;
+		cConf->pll_frac_range = PLL_FRAC_RANGE_TXL;
+		cConf->pll_od_sel_max = PLL_OD_SEL_MAX_TXL;
+		cConf->pll_ref_fmax = PLL_FREF_MAX_TXL;
+		cConf->pll_ref_fmin = PLL_FREF_MIN_TXL;
+		cConf->pll_vco_fmax = PLL_VCO_MAX_TXL;
+		cConf->pll_vco_fmin = PLL_VCO_MIN_TXL;
+		cConf->pll_out_fmax = CLK_DIV_IN_MAX_TXL;
+		cConf->pll_out_fmin = cConf->pll_vco_fmin / 16;
+		cConf->div_in_fmax = CLK_DIV_IN_MAX_TXL;
+		cConf->div_out_fmax = CRT_VID_CLK_IN_MAX_TXL;
+		cConf->xd_out_fmax = ENCL_CLK_IN_MAX_TXL;
+		break;
 	default:
 		LCDPR("%s invalid chip type\n", __func__);
 		break;
@@ -906,13 +923,57 @@ static void lcd_update_pll_frac_gxtvbb(struct lcd_clk_config_s *cConf)
 	if (lcd_debug_print_flag == 2)
 		LCDPR("%s\n", __func__);
 
-	if (cConf->pll_frac > 0) {
-		lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, 1, 14, 1);
+	if (cConf->pll_frac > 0)
 		lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, cConf->pll_frac, 0, 12);
-	} else {
-		lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, 0, 14, 1);
+	else
 		lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, 0, 0, 12);
-	}
+}
+
+static void lcd_set_pll_ss_txl(struct lcd_clk_config_s *cConf)
+{
+	/* to do */
+}
+
+static void lcd_set_pll_txl(struct lcd_clk_config_s *cConf)
+{
+	unsigned int pll_ctrl, pll_ctrl2, pll_ctrl3;
+	int ret;
+
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s\n", __func__);
+	pll_ctrl = ((1 << LCD_PLL_EN_TXL) |
+		(cConf->pll_n << LCD_PLL_N_TXL) |
+		(cConf->pll_m << LCD_PLL_M_TXL));
+	pll_ctrl2 = 0x800ca000;
+	pll_ctrl2 |= ((1 << 12) | (cConf->pll_frac << 0));
+	pll_ctrl3 = 0x860730c4;
+	pll_ctrl3 |= ((cConf->pll_od3_sel << LCD_PLL_OD3_TXL) |
+		(cConf->pll_od2_sel << LCD_PLL_OD2_TXL) |
+		(cConf->pll_od1_sel << LCD_PLL_OD1_TXL));
+
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL, pll_ctrl);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL2, pll_ctrl2);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL3, pll_ctrl3);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL5, 0x001fa729);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL6, 0x01a31500);
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 1, LCD_PLL_RST_TXL, 1);
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 0, LCD_PLL_RST_TXL, 1);
+
+	ret = lcd_pll_wait_lock(HHI_HDMI_PLL_CNTL, LCD_PLL_LOCK_TXL);
+	if (ret)
+		LCDERR("hpll lock failed\n");
+
+	if (cConf->ss_level > 0)
+		lcd_set_pll_ss_txl(cConf);
+}
+
+static void lcd_update_pll_frac_txl(struct lcd_clk_config_s *cConf)
+{
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s\n", __func__);
+
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, cConf->pll_frac, 0, 12);
 }
 
 static void lcd_set_clk_div_m8(int lcd_type, struct lcd_clk_config_s *cConf)
@@ -1075,15 +1136,10 @@ static void lcd_set_vclk_crt(int lcd_type, struct lcd_clk_config_s *cConf)
 		/* select vid_pll2_clk */
 		lcd_hiu_setb(HHI_VIID_CLK_CNTL, 4, VCLK2_CLK_IN_SEL, 3);
 		break;
-	case LCD_CHIP_M8B:
-	case LCD_CHIP_G9TV:
-	case LCD_CHIP_G9BB:
-	case LCD_CHIP_GXTVBB:
+	default:
 		/* select vid_pll_clk */
 		lcd_hiu_setb(HHI_VIID_CLK_CNTL, 0, VCLK2_CLK_IN_SEL, 3);
 		break;
-	default:
-		break;
 	}
 	lcd_hiu_setb(HHI_VIID_CLK_CNTL, 1, VCLK2_EN, 1);
 	udelay(2);
@@ -1107,6 +1163,7 @@ static void lcd_set_vclk_crt(int lcd_type, struct lcd_clk_config_s *cConf)
 	case LCD_CHIP_G9TV:
 	case LCD_CHIP_G9BB:
 	case LCD_CHIP_GXTVBB:
+	case LCD_CHIP_TXL:
 		lcd_hiu_setb(HHI_VID_CLK_CNTL2, 1, ENCL_GATE_VCLK, 1);
 		break;
 	default:
@@ -1160,7 +1217,7 @@ static int check_pll_m8(struct lcd_clk_config_s *cConf,
 		}
 		cConf->pll_fvco = pll_fvco;
 		n = 1;
-		pll_fvco = pll_fvco / (od_fb + 1);
+		pll_fvco = pll_fvco / od_fb_table[od_fb];
 		m = pll_fvco / cConf->fin;
 		pll_frac = (pll_fvco % cConf->fin) * 4096 / cConf->fin;
 		cConf->pll_m = m;
@@ -1614,7 +1671,7 @@ static int check_pll_g9_gxtvbb(struct lcd_clk_config_s *cConf,
 				cConf->pll_fvco = pll_fvco;
 				n = 1;
 				od_fb = 0; /* pll default */
-				pll_fvco = pll_fvco / ((od_fb + 1) * 2);
+				pll_fvco = pll_fvco / od_fb_table[od_fb + 1];
 				m = pll_fvco / cConf->fin;
 				pll_frac = (pll_fvco % cConf->fin) *
 					cConf->pll_frac_range / cConf->fin;
@@ -1838,7 +1895,7 @@ static void lcd_pll_frac_generate_g9_gxtvbb(struct lcd_config_s *pconf)
 
 	cConf->pll_fvco = pll_fvco;
 	od_fb = 0; /* pll default */
-	pll_fvco = pll_fvco / ((od_fb + 1) * 2);
+	pll_fvco = pll_fvco / od_fb_table[od_fb + 1];
 	temp = cConf->fin * m / n;
 	if (pll_fvco >= temp) {
 		temp = pll_fvco - temp;
@@ -1858,6 +1915,262 @@ static void lcd_pll_frac_generate_g9_gxtvbb(struct lcd_config_s *pconf)
 		LCDPR("lcd_pll_frac_generate frac=%d\n", frac);
 }
 
+static int check_pll_txl(struct lcd_clk_config_s *cConf,
+		unsigned int pll_fout)
+{
+	unsigned int m, n;
+	unsigned int od1_sel, od2_sel, od3_sel, od1, od2, od3;
+	unsigned int pll_fod2_in, pll_fod3_in, pll_fvco;
+	unsigned int od_fb = 0, pll_frac;
+	int done;
+
+	done = 0;
+	if ((pll_fout > cConf->pll_out_fmax) ||
+		(pll_fout < cConf->pll_out_fmin)) {
+		return done;
+	}
+	for (od3_sel = cConf->pll_od_sel_max; od3_sel > 0; od3_sel--) {
+		od3 = od_table[od3_sel - 1];
+		pll_fod3_in = pll_fout * od3;
+		for (od2_sel = od3_sel; od2_sel > 0; od2_sel--) {
+			od2 = od_table[od2_sel - 1];
+			pll_fod2_in = pll_fod3_in * od2;
+			for (od1_sel = od2_sel; od1_sel > 0; od1_sel--) {
+				od1 = od_table[od1_sel - 1];
+				pll_fvco = pll_fod2_in * od1;
+				if ((pll_fvco < cConf->pll_vco_fmin) ||
+					(pll_fvco > cConf->pll_vco_fmax)) {
+					continue;
+				}
+				cConf->pll_od1_sel = od1_sel - 1;
+				cConf->pll_od2_sel = od2_sel - 1;
+				cConf->pll_od3_sel = od3_sel - 1;
+				cConf->pll_fout = pll_fout;
+				if (lcd_debug_print_flag == 2) {
+					LCDPR("od1=%d, od2=%d, od3=%d\n",
+						(od1_sel - 1), (od2_sel - 1),
+						(od3_sel - 1));
+					LCDPR("pll_fvco=%d\n", pll_fvco);
+				}
+				cConf->pll_fvco = pll_fvco;
+				n = 1;
+				od_fb = 0; /* pll default */
+				pll_fvco = pll_fvco / od_fb_table[od_fb];
+				m = pll_fvco / cConf->fin;
+				pll_frac = (pll_fvco % cConf->fin) *
+					cConf->pll_frac_range / cConf->fin;
+				cConf->pll_m = m;
+				cConf->pll_n = n;
+				cConf->pll_frac = pll_frac;
+				if (lcd_debug_print_flag == 2) {
+					LCDPR("m=%d, n=%d, frac=%d\n",
+						m, n, pll_frac);
+				}
+				done = 1;
+				break;
+			}
+		}
+	}
+	return done;
+}
+
+static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
+{
+	unsigned int pll_fout;
+	unsigned int clk_div_in, clk_div_out;
+	unsigned int clk_div_sel, xd;
+	struct lcd_clk_config_s *cConf;
+	int done;
+
+	done = 0;
+	cConf = get_lcd_clk_config();
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	cConf->err_fmin = MAX_ERROR;
+
+	if (cConf->fout > cConf->xd_out_fmax) {
+		LCDERR("%s: wrong lcd_clk value %dkHz\n",
+			__func__, cConf->fout);
+		goto generate_clk_done_txl;
+	}
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_LVDS:
+		clk_div_sel = CLK_DIV_SEL_7;
+		xd = 1;
+		clk_div_out = cConf->fout * xd;
+		if (clk_div_out > cConf->div_out_fmax)
+			goto generate_clk_done_txl;
+		if (lcd_debug_print_flag == 2) {
+			LCDPR("fout=%d, xd=%d, clk_div_out=%d\n",
+				cConf->fout, xd, clk_div_out);
+		}
+		clk_div_in = clk_div_calc_g9_gxtvbb(clk_div_out,
+				clk_div_sel, CLK_DIV_O2I);
+		if (clk_div_in > cConf->div_in_fmax)
+			goto generate_clk_done_txl;
+		cConf->xd = xd;
+		cConf->div_sel = clk_div_sel;
+		pll_fout = clk_div_in;
+		if (lcd_debug_print_flag == 2) {
+			LCDPR("clk_div_sel=%s(index %d), pll_fout=%d\n",
+				lcd_clk_div_sel_table[clk_div_sel],
+				clk_div_sel, pll_fout);
+		}
+		done = check_pll_txl(cConf, pll_fout);
+		if (done)
+			goto generate_clk_done_txl;
+		break;
+	case LCD_VBYONE:
+		cConf->div_sel_max = CLK_DIV_SEL_MAX;
+		cConf->xd_max = CRT_VID_DIV_MAX;
+		pll_fout = pconf->lcd_control.vbyone_config->bit_rate / 1000;
+		clk_div_in = pll_fout;
+		if (clk_div_in > cConf->div_in_fmax)
+			goto generate_clk_done_txl;
+		if (lcd_debug_print_flag == 2)
+			LCDPR("pll_fout=%d\n", pll_fout);
+		if ((clk_div_in / cConf->fout) > 15)
+			cConf->xd = 4;
+		else
+			cConf->xd = 1;
+		clk_div_out = cConf->fout * cConf->xd;
+		if (lcd_debug_print_flag == 2) {
+			LCDPR("clk_div_in=%d, fout=%d, xd=%d, clk_div_out=%d\n",
+				clk_div_in, cConf->fout,
+				clk_div_out, cConf->xd);
+		}
+		if (clk_div_out > cConf->div_out_fmax)
+			goto generate_clk_done_txl;
+		clk_div_sel = clk_div_get_g9_gxtvbb(
+				clk_div_in * 100 / clk_div_out);
+		cConf->div_sel = clk_div_sel;
+		if (lcd_debug_print_flag == 2) {
+			LCDPR("clk_div_sel=%s(index %d)\n",
+				lcd_clk_div_sel_table[clk_div_sel],
+				cConf->div_sel);
+		}
+		done = check_pll_txl(cConf, pll_fout);
+		break;
+	default:
+		break;
+	}
+
+generate_clk_done_txl:
+	if (done) {
+		pconf->lcd_timing.pll_ctrl =
+			(cConf->pll_od1_sel << PLL_CTRL_OD1) |
+			(cConf->pll_od2_sel << PLL_CTRL_OD2) |
+			(cConf->pll_od3_sel << PLL_CTRL_OD3) |
+			(cConf->pll_n << PLL_CTRL_N)         |
+			(cConf->pll_m << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl =
+			(cConf->div_sel << DIV_CTRL_DIV_SEL) |
+			(cConf->xd << DIV_CTRL_XD);
+		pconf->lcd_timing.clk_ctrl =
+			(cConf->pll_frac << CLK_CTRL_FRAC);
+	} else {
+		pconf->lcd_timing.pll_ctrl =
+			(1 << PLL_CTRL_OD1) |
+			(1 << PLL_CTRL_OD2) |
+			(1 << PLL_CTRL_OD3) |
+			(1 << PLL_CTRL_N)   |
+			(50 << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl =
+			(CLK_DIV_SEL_1 << DIV_CTRL_DIV_SEL) |
+			(7 << DIV_CTRL_XD);
+		pconf->lcd_timing.clk_ctrl = (0 << CLK_CTRL_FRAC);
+		LCDERR("Out of clock range, reset to default setting\n");
+	}
+}
+
+static void lcd_pll_frac_generate_txl(struct lcd_config_s *pconf)
+{
+	unsigned int pll_fout;
+	unsigned int clk_div_in, clk_div_out, clk_div_sel;
+	unsigned int od1, od2, od3, pll_fvco;
+	unsigned int m, n, od_fb, frac, offset, temp;
+	struct lcd_clk_config_s *cConf;
+
+	cConf = get_lcd_clk_config();
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	clk_div_sel = cConf->div_sel;
+	od1 = od_table[cConf->pll_od1_sel];
+	od2 = od_table[cConf->pll_od2_sel];
+	od3 = od_table[cConf->pll_od3_sel];
+	m = cConf->pll_m;
+	n = cConf->pll_n;
+
+	if (lcd_debug_print_flag == 2) {
+		LCDPR("m=%d, n=%d, od1=%d, od2=%d, od3=%d\n",
+			m, n, cConf->pll_od1_sel, cConf->pll_od2_sel,
+			cConf->pll_od3_sel);
+		LCDPR("clk_div_sel=%s(index %d), xd=%d\n",
+			lcd_clk_div_sel_table[clk_div_sel],
+			clk_div_sel, cConf->xd);
+	}
+	if (cConf->fout > cConf->xd_out_fmax) {
+		LCDERR("%s: wrong lcd_clk value %dkHz\n",
+			__func__, cConf->fout);
+		return;
+	}
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s pclk=%d\n", __func__, cConf->fout);
+
+	clk_div_out = cConf->fout * cConf->xd;
+	if (clk_div_out > cConf->div_out_fmax) {
+		LCDERR("%s: wrong clk_div_out value %dkHz\n",
+			__func__, clk_div_out);
+		return;
+	}
+
+	clk_div_in =
+		clk_div_calc_g9_gxtvbb(clk_div_out, clk_div_sel, CLK_DIV_O2I);
+	if (clk_div_in > cConf->div_in_fmax) {
+		LCDERR("%s: wrong clk_div_in value %dkHz\n",
+			__func__, clk_div_in);
+		return;
+	}
+
+	pll_fout = clk_div_in;
+	if ((pll_fout > cConf->pll_out_fmax) ||
+		(pll_fout < cConf->pll_out_fmin)) {
+		LCDERR("%s: wrong pll_fout value %dkHz\n", __func__, pll_fout);
+		return;
+	}
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s pll_fout=%d\n", __func__, pll_fout);
+
+	pll_fvco = pll_fout * od1 * od2 * od3;
+	if ((pll_fvco < cConf->pll_vco_fmin) ||
+		(pll_fvco > cConf->pll_vco_fmax)) {
+		LCDERR("%s: wrong pll_fvco value %dkHz\n", __func__, pll_fvco);
+		return;
+	}
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s pll_fvco=%d\n", __func__, pll_fvco);
+
+	cConf->pll_fvco = pll_fvco;
+	od_fb = 0; /* pll default */
+	pll_fvco = pll_fvco / od_fb_table[od_fb];
+	temp = cConf->fin * m / n;
+	if (pll_fvco >= temp) {
+		temp = pll_fvco - temp;
+		offset = 0;
+	} else {
+		temp = temp - pll_fvco;
+		offset = 1;
+	}
+	if (temp >= (2 * cConf->fin)) {
+		LCDERR("%s: pll changing %dkHz is too much\n",
+			__func__, temp);
+		return;
+	}
+	frac = temp * cConf->pll_frac_range * n / cConf->fin;
+	cConf->pll_frac = frac | (offset << 11);
+	if (lcd_debug_print_flag)
+		LCDPR("lcd_pll_frac_generate: frac=0x%x\n", frac);
+}
+
 void lcd_clk_generate_parameter(struct lcd_config_s *pconf)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
@@ -1873,6 +2186,9 @@ void lcd_clk_generate_parameter(struct lcd_config_s *pconf)
 	case LCD_CHIP_GXTVBB:
 		lcd_clk_generate_g9_gxtvbb(pconf);
 		break;
+	case LCD_CHIP_TXL:
+		lcd_clk_generate_txl(pconf);
+		break;
 	default:
 		break;
 	}
@@ -1903,6 +2219,9 @@ char *lcd_get_spread_spectrum(void)
 	case LCD_CHIP_GXTVBB:
 		ss_str = lcd_pll_ss_table_gxtvbb[ss_level];
 		break;
+	case LCD_CHIP_TXL:
+		ss_str = lcd_pll_ss_table_txl[ss_level];
+		break;
 	default:
 		ss_str = "unknown";
 		break;
@@ -1938,6 +2257,9 @@ void lcd_set_spread_spectrum(void)
 	case LCD_CHIP_GXTVBB:
 		lcd_set_pll_ss_gxtvbb(&clk_conf);
 		break;
+	case LCD_CHIP_TXL:
+		lcd_set_pll_ss_txl(&clk_conf);
+		break;
 	default:
 		break;
 	}
@@ -1972,6 +2294,10 @@ void lcd_clk_update(struct lcd_config_s *pconf)
 		lcd_pll_frac_generate_g9_gxtvbb(pconf);
 		lcd_update_pll_frac_gxtvbb(&clk_conf);
 		break;
+	case LCD_CHIP_TXL:
+		lcd_pll_frac_generate_txl(pconf);
+		lcd_update_pll_frac_txl(&clk_conf);
+		break;
 	default:
 		break;
 	}
@@ -2007,6 +2333,10 @@ void lcd_clk_set(struct lcd_config_s *pconf)
 		lcd_set_pll_gxtvbb(&clk_conf);
 		lcd_set_clk_div_g9_gxtvbb(&clk_conf);
 		break;
+	case LCD_CHIP_TXL:
+		lcd_set_pll_txl(&clk_conf);
+		lcd_set_clk_div_g9_gxtvbb(&clk_conf);
+		break;
 	default:
 		break;
 	}
@@ -2028,6 +2358,7 @@ void lcd_clk_disable(void)
 	case LCD_CHIP_G9TV:
 	case LCD_CHIP_G9BB:
 	case LCD_CHIP_GXTVBB:
+	case LCD_CHIP_TXL:
 		lcd_hiu_setb(HHI_VID_CLK_CNTL2, 0, ENCL_GATE_VCLK, 1);
 		break;
 	default:
@@ -2067,6 +2398,10 @@ void lcd_clk_disable(void)
 		lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 0, LCD_PLL_EN_GXTVBB, 1);
 		lcd_hiu_setb(HHI_HDMI_PLL_CNTL5, 0, 30, 1); /* bandgap */
 		break;
+	case LCD_CHIP_TXL:
+		/* disable hdmi_pll: 0x10c8[30] */
+		lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 0, LCD_PLL_EN_TXL, 1);
+		break;
 	default:
 		break;
 	}
diff --git a/drivers/display/lcd/aml_lcd_clk_config.h b/drivers/display/lcd/aml_lcd_clk_config.h
index 936dd35..9d6e1c3 100644
--- a/drivers/display/lcd/aml_lcd_clk_config.h
+++ b/drivers/display/lcd/aml_lcd_clk_config.h
@@ -281,6 +281,40 @@ enum div_sel_e {
 #define CRT_VID_CLK_IN_MAX_GXTVBB   (3100 * 1000)
 #define ENCL_CLK_IN_MAX_GXTVBB      (620 * 1000)
 
+/* **********************************
+ * TXL
+ * ********************************** */
+/* ******** register bit ******** */
+/* PLL_CNTL 0x10c8 */
+#define LCD_PLL_LOCK_TXL            31
+#define LCD_PLL_EN_TXL              30
+#define LCD_PLL_RST_TXL             28
+#define LCD_PLL_N_TXL               9
+#define LCD_PLL_M_TXL               0
+
+#define LCD_PLL_OD3_TXL             19
+#define LCD_PLL_OD2_TXL             23
+#define LCD_PLL_OD1_TXL             21
+
+/* ******** frequency limit (unit: kHz) ******** */
+/* pll */
+#define SS_LEVEL_MAX_TXL            5
+#define PLL_M_MIN_TXL               2
+#define PLL_M_MAX_TXL               511
+#define PLL_N_MIN_TXL               1
+#define PLL_N_MAX_TXL               1
+#define PLL_FRAC_RANGE_TXL          (1 << 10)
+#define PLL_OD_SEL_MAX_TXL          3
+#define PLL_FREF_MIN_TXL            (5 * 1000)
+#define PLL_FREF_MAX_TXL            (25 * 1000)
+#define PLL_VCO_MIN_TXL             (3000 * 1000)
+#define PLL_VCO_MAX_TXL             (6000 * 1000)
+
+/* video */
+#define CLK_DIV_IN_MAX_TXL          (3100 * 1000)
+#define CRT_VID_CLK_IN_MAX_TXL      (3100 * 1000)
+#define ENCL_CLK_IN_MAX_TXL         (620 * 1000)
+
 
 extern struct lcd_clk_config_s *get_lcd_clk_config(void);
 extern void lcd_clk_config_print(void);
diff --git a/drivers/display/lcd/aml_lcd_common.c b/drivers/display/lcd/aml_lcd_common.c
index 5b656e2..3cfd685 100644
--- a/drivers/display/lcd/aml_lcd_common.c
+++ b/drivers/display/lcd/aml_lcd_common.c
@@ -146,6 +146,7 @@ void lcd_tcon_config(struct lcd_config_s *pconf)
 	}
 }
 
+#if 0
 /* change clock(frame_rate) for different vmode */
 int lcd_vmode_change(struct lcd_config_s *pconf)
 {
@@ -199,4 +200,139 @@ int lcd_vmode_change(struct lcd_config_s *pconf)
 
 	return 0;
 }
+#else
+int lcd_vmode_change(struct lcd_config_s *pconf)
+{
+	unsigned char type = pconf->lcd_timing.fr_adjust_type;
+	 /* use default value to avoid offset */
+	unsigned int pclk = pconf->lcd_timing.lcd_clk_dft;
+	unsigned int h_period = pconf->lcd_timing.h_period_dft;
+	unsigned int v_period = pconf->lcd_timing.v_period_dft;
+	unsigned int pclk_min = pconf->lcd_basic.lcd_clk_min;
+	unsigned int pclk_max = pconf->lcd_basic.lcd_clk_max;
+	unsigned int duration_num = pconf->lcd_timing.sync_duration_num;
+	unsigned int duration_den = pconf->lcd_timing.sync_duration_den;
+	char str[100];
+	int len = 0;
+
+	pconf->lcd_timing.clk_change = 0; /* clear clk flga */
+	switch (type) {
+	case 0: /* pixel clk adjust */
+		pclk = (h_period * v_period) / duration_den * duration_num;
+		if (pconf->lcd_timing.lcd_clk != pclk)
+			pconf->lcd_timing.clk_change = LCD_CLK_PLL_CHANGE;
+		break;
+	case 1: /* htotal adjust */
+		h_period = ((pclk / v_period) * duration_den * 10) /
+				duration_num;
+		h_period = (h_period + 5) / 10; /* round off */
+		if (pconf->lcd_basic.h_period != h_period) {
+			/* check clk frac update */
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk) {
+				pconf->lcd_timing.clk_change =
+					LCD_CLK_FRAC_UPDATE;
+			}
+		}
+		break;
+	case 2: /* vtotal adjust */
+		v_period = ((pclk / h_period) * duration_den * 10) /
+				duration_num;
+		v_period = (v_period + 5) / 10; /* round off */
+		if (pconf->lcd_basic.v_period != v_period) {
+			/* check clk frac update */
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk) {
+				pconf->lcd_timing.clk_change =
+					LCD_CLK_FRAC_UPDATE;
+			}
+		}
+		break;
+	case 3: /* free adjust, use min/max range to calculate */
+	default:
+		v_period = ((pclk / h_period) * duration_den * 10) /
+			duration_num;
+		v_period = (v_period + 5) / 10; /* round off */
+		if (v_period > pconf->lcd_basic.v_period_max) {
+			v_period = pconf->lcd_basic.v_period_max;
+			h_period = ((pclk / v_period) * duration_den * 10) /
+				duration_num;
+			h_period = (h_period + 5) / 10; /* round off */
+			if (h_period > pconf->lcd_basic.h_period_max) {
+				h_period = pconf->lcd_basic.h_period_max;
+				pclk = (h_period * v_period) / duration_den *
+					duration_num;
+				if (pconf->lcd_timing.lcd_clk != pclk) {
+					if (pclk > pclk_max) {
+						pclk = pclk_max;
+						LCDERR("invalid vmode\n");
+						return -1;
+					}
+					pconf->lcd_timing.clk_change =
+						LCD_CLK_PLL_CHANGE;
+				}
+			}
+		} else if (v_period < pconf->lcd_basic.v_period_min) {
+			v_period = pconf->lcd_basic.v_period_min;
+			h_period = ((pclk / v_period) * duration_den * 10) /
+				duration_num;
+			h_period = (h_period + 5) / 10; /* round off */
+			if (h_period < pconf->lcd_basic.h_period_min) {
+				h_period = pconf->lcd_basic.h_period_min;
+				pclk = (h_period * v_period) / duration_den *
+					duration_num;
+				if (pconf->lcd_timing.lcd_clk != pclk) {
+					if (pclk < pclk_min) {
+						pclk = pclk_min;
+						LCDERR("invalid vmode\n");
+						return -1;
+					}
+					pconf->lcd_timing.clk_change =
+						LCD_CLK_PLL_CHANGE;
+				}
+			}
+		}
+		/* check clk frac update */
+		if ((pconf->lcd_timing.clk_change & LCD_CLK_PLL_CHANGE) == 0) {
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk) {
+				pconf->lcd_timing.clk_change =
+					LCD_CLK_FRAC_UPDATE;
+			}
+		}
+		break;
+	}
+
+	if (pconf->lcd_basic.v_period != v_period) {
+		len += sprintf(str+len, "v_period %u->%u",
+			pconf->lcd_basic.v_period, v_period);
+		/* update v_period */
+		pconf->lcd_basic.v_period = v_period;
+	}
+	if (pconf->lcd_basic.h_period != h_period) {
+		if (len > 0)
+			len += sprintf(str+len, ", ");
+		len += sprintf(str+len, "h_period %u->%u",
+			pconf->lcd_basic.h_period, h_period);
+		/* update h_period */
+		pconf->lcd_basic.h_period = h_period;
+	}
+	if (pconf->lcd_timing.lcd_clk != pclk) {
+		if (len > 0)
+			len += sprintf(str+len, ", ");
+		len += sprintf(str+len, "pclk %u.%03uMHz->%u.%03uMHz",
+			(pconf->lcd_timing.lcd_clk / 1000000),
+			((pconf->lcd_timing.lcd_clk / 1000) % 1000),
+			(pclk / 1000000), ((pclk / 1000) % 1000));
+		pconf->lcd_timing.lcd_clk = pclk;
+	}
+	if (len > 0)
+		LCDPR("%s: %s\n", __func__, str);
+
+	return 0;
+}
+#endif
 
diff --git a/drivers/display/lcd/aml_lcd_unifykey.h b/drivers/display/lcd/aml_lcd_unifykey.h
index 378e868..28e233a 100644
--- a/drivers/display/lcd/aml_lcd_unifykey.h
+++ b/drivers/display/lcd/aml_lcd_unifykey.h
@@ -71,10 +71,12 @@ struct aml_lcd_unifykey_header_s {
 #define LCD_UKEY_SS_LEVEL          1
 #define LCD_UKEY_CLK_AUTO_GEN      1
 #define LCD_UKEY_PCLK              4
-#define LCD_UKEY_CUST_VAL_4        4
-#define LCD_UKEY_CUST_VAL_5        4
-#define LCD_UKEY_CUST_VAL_6        4
-#define LCD_UKEY_CUST_VAL_7        4
+#define LCD_UKEY_H_PERIOD_MIN      2
+#define LCD_UKEY_H_PERIOD_MAX      2
+#define LCD_UKEY_V_PERIOD_MIN      2
+#define LCD_UKEY_V_PERIOD_MAX      2
+#define LCD_UKEY_PCLK_MIN          4
+#define LCD_UKEY_PCLK_MAX          4
 #define LCD_UKEY_CUST_VAL_8        4
 #define LCD_UKEY_CUST_VAL_9        4
 /* interface (20Byte) */
diff --git a/drivers/display/lcd/aml_ldim/Makefile b/drivers/display/lcd/aml_ldim/Makefile
index 2a8f2d2..b7bcfe3 100644
--- a/drivers/display/lcd/aml_ldim/Makefile
+++ b/drivers/display/lcd/aml_ldim/Makefile
@@ -1,3 +1,3 @@
 obj-$(CONFIG_AML_LOCAL_DIMMING) += ldim_drv.o ldim_dev_drv.o
 obj-$(CONFIG_AML_LOCAL_DIMMING_IW7019) += iw7019.o
-
+obj-$(CONFIG_AML_LOCAL_DIMMING_OB3350) += ob3350.o
diff --git a/drivers/display/lcd/aml_ldim/iw7019.c b/drivers/display/lcd/aml_ldim/iw7019.c
index e8d3301..3c9ce26 100644
--- a/drivers/display/lcd/aml_ldim/iw7019.c
+++ b/drivers/display/lcd/aml_ldim/iw7019.c
@@ -39,6 +39,7 @@
 #define IW7019_REG_BRIGHTNESS_CHK  0x00
 
 static int iw7019_on_flag;
+static int iw7019_wr_err_cnt;
 
 struct iw7019 {
 	int cs_hold_delay;
@@ -49,6 +50,8 @@ struct iw7019 {
 };
 struct iw7019 *bl_iw7019;
 
+extern struct ldim_spi_dev_info_s ldim_spi_dev;
+
 #if 0
 static u8 iw7019_ini_data[LDIM_SPI_INIT_ON_SIZE] = {
 #if 1
@@ -289,6 +292,8 @@ static int iw7019_power_on_init(void)
 			mdelay(bl_iw7019->init_data[i+3]);
 	}
 
+	iw7019_wr_err_cnt = 0;
+
 	return ret;
 }
 
@@ -298,6 +303,7 @@ static int iw7019_hw_init_on(void)
 
 	ldim_set_gpio(ldim_drv->ldev_conf->en_gpio, ldim_drv->ldev_conf->en_gpio_on);
 	mdelay(2);
+	ldim_set_duty_pwm(&(ldim_drv->ldev_conf->pwm_config));
 	ldim_drv->pinmux_ctrl(1);
 	mdelay(100);
 	iw7019_power_on_init();
@@ -330,6 +336,24 @@ static int iw7019_reset_handler(void)
 	return 0;
 }
 
+static int iw7019_short_reset_handler(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	/* disable BL_ON once */
+	LDIMPR("short reset iw7019 BL_ON\n");
+	reset_cnt++;
+	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
+		ldim_drv->ldev_conf->en_gpio_off);
+	mdelay(300);
+	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
+		ldim_drv->ldev_conf->en_gpio_on);
+	mdelay(2);
+	iw7019_power_on_init(IW7019_POWER_RESET);
+
+	return 0;
+}
+
 static unsigned int iw7019_get_value(unsigned int level)
 {
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
@@ -351,7 +375,7 @@ static int iw7019_smr(unsigned short *buf, unsigned char len)
 	unsigned char val[13];
 	int br0, br1;
 	unsigned char bri_reg;
-	unsigned char temp, reg_chk, clk_sel;
+	unsigned char temp, reg_chk, clk_sel, wr_err_flag = 0;
 
 	if (iw7019_on_flag == 0) {
 		if (lcd_debug_print_flag)
@@ -392,7 +416,7 @@ static int iw7019_smr(unsigned short *buf, unsigned char len)
 		}
 		clk_sel = (reg_chk >> 1) & 0x3;
 		if ((reg_chk == 0xff) || (clk_sel == 0x1) || (clk_sel == 0x2)) {
-			LDIMERR("%s: spi write failed, 0x00=0x%02x\n",
+			LDIMERR("%s: reg check failed, 0x00=0x%02x\n",
 				__func__, reg_chk);
 			iw7019_reset_handler();
 			goto iw7019_smr_end;
@@ -403,13 +427,22 @@ iw7019_smr_write_chk2:
 			for (i = 1; i < 3; i++) {
 				iw7019_rreg(bl_iw7019->spi, j, &reg_chk);
 				if (val[j] == reg_chk) {
+					wr_err_flag = 0;
 					break;
 				} else {
 					LDIMERR("%s: failed, 0x%02x=0x%02x, w_val=0x%02x\n",
 						__func__, j, reg_chk, val[j]);
 					iw7019_wreg(bl_iw7019->spi, j, val[j]);
+					wr_err_flag = 1;
 				}
 			}
+			if (wr_err_flag)
+				iw7019_wr_err_cnt++;
+		}
+		if (iw7019_wr_err_cnt >= 60) {
+			LDIMERR("%s: spi write failed\n", __func__);
+			iw7019_short_reset_handler();
+			goto iw7019_smr_end;
 		}
 	}
 
@@ -457,7 +490,21 @@ int ldim_dev_iw7019_probe(void)
 	memset(bl_iw7019, 0, sizeof(struct iw7019));
 
 	iw7019_on_flag = 0;
-	bl_iw7019->spi = ldim_drv->spi;
+	iw7019_wr_err_cnt = 0;
+
+	/* register spi */
+	ldim_drv->spi_dev->spi =
+		spi_setup_slave(ldim_drv->spi_dev->bus_num,
+					ldim_drv->spi_dev->chip_select,
+					ldim_drv->spi_dev->max_speed_hz,
+					ldim_drv->spi_dev->mode);
+	if (ldim_drv->spi_dev->spi == NULL) {
+		LDIMERR("register ldim_dev spi driver failed\n");
+		return -1;
+	}
+	spi_cs_deactivate(ldim_drv->spi_dev->spi);
+
+	bl_iw7019->spi = ldim_drv->spi_dev->spi;
 	bl_iw7019->cs_hold_delay = ldim_drv->ldev_conf->cs_hold_delay;
 	bl_iw7019->cs_clk_delay = ldim_drv->ldev_conf->cs_clk_delay;
 	bl_iw7019->cmd_size = ldim_drv->ldev_conf->cmd_size;
diff --git a/drivers/display/lcd/aml_ldim/ldim_dev_drv.c b/drivers/display/lcd/aml_ldim/ldim_dev_drv.c
index b66d462..1a1fc28 100644
--- a/drivers/display/lcd/aml_ldim/ldim_dev_drv.c
+++ b/drivers/display/lcd/aml_ldim/ldim_dev_drv.c
@@ -27,13 +27,8 @@
 #include "ldim_drv.h"
 #include "ldim_dev_drv.h"
 
-struct ldim_spi_dev_info_s {
-	char modalias[20];
-	int mode;
-	int max_speed_hz;
-	int bus_num;
-	int chip_select;
-};
+static unsigned char ldim_ini_data_on[LDIM_SPI_INIT_ON_SIZE];
+static unsigned char ldim_ini_data_off[LDIM_SPI_INIT_OFF_SIZE];
 
 struct ldim_spi_dev_info_s ldim_spi_dev = {
 	.modalias = "ldim_dev",
@@ -43,10 +38,8 @@ struct ldim_spi_dev_info_s ldim_spi_dev = {
 	.chip_select = 0, /* the device index on the spi bus */
 };
 
-static unsigned char ldim_ini_data_on[LDIM_SPI_INIT_ON_SIZE];
-static unsigned char ldim_ini_data_off[LDIM_SPI_INIT_OFF_SIZE];
-
 struct ldim_dev_config_s ldim_dev_config = {
+	.type = LDIM_DEV_TYPE_NORMAL,
 	.cs_hold_delay = 0,
 	.cs_clk_delay = 0,
 	.en_gpio = 0xff,
@@ -122,7 +115,7 @@ static unsigned int pwm_reg[6] = {
 	PWM_PWM_F,
 };
 
-static void ldim_set_duty_pwm(struct bl_pwm_config_s *bl_pwm)
+void ldim_set_duty_pwm(struct bl_pwm_config_s *bl_pwm)
 {
 	unsigned int pwm_hi = 0, pwm_lo = 0;
 	unsigned int port = bl_pwm->pwm_port;
@@ -198,7 +191,6 @@ static int ldim_pwm_pinmux_ctrl(int status)
 		LDIMPR("%s: %d\n", __func__, status);
 
 	if (status) {
-		ldim_set_duty_pwm(ld_pwm);
 		bl_pwm_ctrl(ld_pwm, 1);
 		/* set pinmux */
 		ld_pwm->pinmux_flag = 1;
@@ -263,6 +255,7 @@ static int ldim_dev_get_config_from_dts(char *dt_addr, int index)
 	unsigned char cmd_size;
 	int temp, len = 0;
 	struct bl_pwm_config_s *ld_pwm = &ldim_dev_config.pwm_config;
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 	int i, j;
 
 	strcpy(ldim_dev_config.name, "ldim_dev");
@@ -293,36 +286,6 @@ static int ldim_dev_get_config_from_dts(char *dt_addr, int index)
 		}
 	}
 
-	/* get spi config */
-	/*
-	propdata = (char *)fdt_getprop(dt_addr, parent_offset, "spi_bus_num", NULL);
-	if (propdata == NULL)
-		LDIMERR("failed to get spi_bus_num\n");
-	else
-		ldim_spi_dev.bus_num = be32_to_cpup((u32*)propdata);
-	*/
-	ldim_spi_dev.bus_num = 2; /* fix value */
-	propdata = (char *)fdt_getprop(dt_addr, parent_offset, "spi_chip_select", NULL);
-	if (propdata == NULL)
-		LDIMERR("failed to get spi_chip_select\n");
-	else
-		ldim_spi_dev.chip_select = be32_to_cpup((u32*)propdata);
-	propdata = (char *)fdt_getprop(dt_addr, parent_offset, "spi_max_frequency", NULL);
-	if (propdata == NULL)
-		LDIMERR("failed to get spi_max_frequency\n");
-	else
-		ldim_spi_dev.max_speed_hz = be32_to_cpup((u32*)propdata);
-	propdata = (char *)fdt_getprop(dt_addr, parent_offset, "spi_mode", NULL);
-	if (propdata == NULL)
-		LDIMERR("failed to get spi_mode\n");
-	else
-		ldim_spi_dev.mode = be32_to_cpup((u32*)propdata);
-	if (lcd_debug_print_flag) {
-		LDIMPR("spi bus_num=%d, chip_select=%d, max_frequency=%d, mode=%d\n",
-			ldim_spi_dev.bus_num, ldim_spi_dev.chip_select,
-			ldim_spi_dev.max_speed_hz, ldim_spi_dev.mode);
-	}
-
 	/* init gpio */
 	i = 0;
 	propdata = (char *)fdt_getprop(dt_addr, parent_offset, "ldim_dev_gpio_names", NULL);
@@ -397,18 +360,6 @@ static int ldim_dev_get_config_from_dts(char *dt_addr, int index)
 			ld_pwm->pwm_method, ld_pwm->pwm_freq, ld_pwm->pwm_duty);
 	}
 
-	propdata = (char *)fdt_getprop(dt_addr, child_offset, "spi_cs_delay", NULL);
-	if (propdata == NULL) {
-		LDIMERR("failed to get spi_cs_delay\n");
-	} else {
-		ldim_dev_config.cs_hold_delay = be32_to_cpup((u32*)propdata);
-		ldim_dev_config.cs_clk_delay = be32_to_cpup((((u32*)propdata)+1));
-	}
-	if (lcd_debug_print_flag) {
-		LDIMPR("cs_hold_delay=%dus, cs_clk_delay=%dus\n",
-			ldim_dev_config.cs_hold_delay, ldim_dev_config.cs_clk_delay);
-	}
-
 	propdata = (char *)fdt_getprop(dt_addr, child_offset, "en_gpio_on_off", NULL);
 	if (propdata == NULL) {
 		LDIMERR("failed to get en_gpio_on_off\n");
@@ -419,19 +370,11 @@ static int ldim_dev_get_config_from_dts(char *dt_addr, int index)
 	}
 	if (lcd_debug_print_flag) {
 		LDIMPR("en_gpio=%s(%d), en_gpio_on=%d, en_gpio_off=%d\n",
-			ldim_dev_config.gpio_name[ldim_dev_config.en_gpio],
-			ldim_dev_config.en_gpio, ldim_dev_config.en_gpio_on,
-			ldim_dev_config.en_gpio_off);
+		ldim_dev_config.gpio_name[ldim_dev_config.en_gpio],
+		ldim_dev_config.en_gpio, ldim_dev_config.en_gpio_on,
+		ldim_dev_config.en_gpio_off);
 	}
 
-	propdata = (char *)fdt_getprop(dt_addr, child_offset, "spi_write_check", NULL);
-	if (propdata == NULL)
-		LDIMERR("failed to get spi_write_check\n");
-	else
-		ldim_dev_config.write_check = (unsigned char)(be32_to_cpup((u32*)propdata));
-	if (lcd_debug_print_flag)
-		LDIMPR("write_check=%d\n", ldim_dev_config.write_check);
-
 	propdata = (char *)fdt_getprop(dt_addr, child_offset, "dim_max_min", NULL);
 	if (propdata == NULL) {
 		LDIMERR("failed to get dim_max_min\n");
@@ -441,62 +384,147 @@ static int ldim_dev_get_config_from_dts(char *dt_addr, int index)
 	}
 	if (lcd_debug_print_flag) {
 		LDIMPR("dim_max=0x%03x, dim_min=0x%03x\n",
-			ldim_dev_config.dim_max, ldim_dev_config.dim_min);
+		ldim_dev_config.dim_max, ldim_dev_config.dim_min);
 	}
 
-	/* get init_cmd */
-	propdata = (char *)fdt_getprop(dt_addr, child_offset, "cmd_size", NULL);
-	if (propdata == NULL) {
-		LDIMERR("failed to get cmd_size\n");
-	} else {
-		temp = be32_to_cpup((u32*)propdata);
-		if (temp > 1)
-			ldim_dev_config.cmd_size = (unsigned char)temp;
-		else
-			ldim_dev_config.cmd_size = 1;
+	propdata = (char *)fdt_getprop(dt_addr, child_offset, "type", NULL);
+	if (propdata == NULL)
+		LDIMERR("failed to get type\n");
+	else {
+		ldim_dev_config.type = be32_to_cpup((u32*)propdata);
+		LDIMPR("type: %d\n", ldim_dev_config.type);
+		}
+
+	propdata = (char *)fdt_getprop(dt_addr, child_offset, "ldim_pwm_pinmux_sel", NULL);
+	if (propdata == NULL)
+		LDIMERR("failed to get ldim_pwm_name\n");
+	else
+		strcpy(ldim_dev_config.pinmux_name, propdata);
+	LDIMPR("ldim_pwm_pinmux_sel: %s\n", ldim_dev_config.pinmux_name);
+
+	if (ldim_dev_config.type >= LDIM_DEV_TYPE_MAX) {
+		LDIMERR("type num is out of support\n");
+		return -1;
 	}
-	if (lcd_debug_print_flag)
-		LDIMPR("cmd_size=%d\n", ldim_dev_config.cmd_size);
-	cmd_size = ldim_dev_config.cmd_size;
-	if (cmd_size > 1) {
-		propdata = (char *)fdt_getprop(dt_addr, child_offset, "init_on", NULL);
+
+	switch (ldim_dev_config.type) {
+	case LDIM_DEV_TYPE_SPI:
+		ldim_drv->spi_dev = &ldim_spi_dev;
+		/* get spi config */
+		/*
+		propdata = (char *)fdt_getprop(dt_addr, parent_offset, "spi_bus_num", NULL);
+		if (propdata == NULL)
+			LDIMERR("failed to get spi_bus_num\n");
+		else
+			ldim_spi_dev.bus_num = be32_to_cpup((u32*)propdata);
+		*/
+
+		ldim_spi_dev.bus_num = 2; /* fix value */
+		propdata = (char *)fdt_getprop(dt_addr, child_offset, "spi_chip_select", NULL);
+		if (propdata == NULL)
+			LDIMERR("failed to get spi_chip_select\n");
+		else
+			ldim_spi_dev.chip_select = be32_to_cpup((u32*)propdata);
+
+		propdata = (char *)fdt_getprop(dt_addr, child_offset, "spi_max_frequency", NULL);
+		if (propdata == NULL)
+			LDIMERR("failed to get spi_max_frequency\n");
+		else
+			ldim_spi_dev.max_speed_hz = be32_to_cpup((u32*)propdata);
+
+		propdata = (char *)fdt_getprop(dt_addr, child_offset, "spi_mode", NULL);
+		if (propdata == NULL)
+			LDIMERR("failed to get spi_mode\n");
+		else
+			ldim_spi_dev.mode = be32_to_cpup((u32*)propdata);
+
+		if (lcd_debug_print_flag) {
+			LDIMPR("spi bus_num=%d, chip_select=%d, max_frequency=%d, mode=%d\n",
+				ldim_spi_dev.bus_num, ldim_spi_dev.chip_select,
+				ldim_spi_dev.max_speed_hz, ldim_spi_dev.mode);
+		}
+
+		propdata = (char *)fdt_getprop(dt_addr, child_offset, "spi_cs_delay", NULL);
 		if (propdata == NULL) {
-			LDIMPR("no init_on\n");
-			ldim_dev_config.init_on[0] = 0xff;
+			LDIMERR("failed to get spi_cs_delay\n");
 		} else {
-			i = 0;
-			while (i < LDIM_SPI_INIT_ON_SIZE) {
-				for (j = 0; j < cmd_size; j++) {
-					ldim_dev_config.init_on[i+j] =
-						(unsigned char)(be32_to_cpup((((u32*)propdata)+i+j)));
-				}
-				if (ldim_dev_config.init_on[i] == 0xff)
-					break;
-				else
-					i += cmd_size;
-			}
+			ldim_dev_config.cs_hold_delay = be32_to_cpup((u32*)propdata);
+			ldim_dev_config.cs_clk_delay = be32_to_cpup((((u32*)propdata)+1));
 		}
-		propdata = (char *)fdt_getprop(dt_addr, child_offset, "init_off", NULL);
+		if (lcd_debug_print_flag) {
+			LDIMPR("cs_hold_delay=%dus, cs_clk_delay=%dus\n",
+				ldim_dev_config.cs_hold_delay, ldim_dev_config.cs_clk_delay);
+		}
+
+		propdata = (char *)fdt_getprop(dt_addr, child_offset, "spi_write_check", NULL);
+		if (propdata == NULL)
+			LDIMERR("failed to get spi_write_check\n");
+		else
+			ldim_dev_config.write_check = (unsigned char)(be32_to_cpup((u32*)propdata));
+		if (lcd_debug_print_flag)
+			LDIMPR("write_check=%d\n", ldim_dev_config.write_check);
+
+		/* get init_cmd */
+		propdata = (char *)fdt_getprop(dt_addr, child_offset, "cmd_size", NULL);
 		if (propdata == NULL) {
-			LDIMPR("no init_off\n");
-			ldim_dev_config.init_off[0] = 0xff;
+			LDIMERR("failed to get cmd_size\n");
 		} else {
-			i = 0;
-			while (i < LDIM_SPI_INIT_OFF_SIZE) {
-				for (j = 0; j < cmd_size; j++) {
-					ldim_dev_config.init_off[i+j] =
-						(unsigned char)(be32_to_cpup((((u32*)propdata)+i+j)));
+			temp = be32_to_cpup((u32*)propdata);
+			if (temp > 1)
+				ldim_dev_config.cmd_size = (unsigned char)temp;
+			else
+				ldim_dev_config.cmd_size = 1;
+		}
+		if (lcd_debug_print_flag)
+			LDIMPR("cmd_size=%d\n", ldim_dev_config.cmd_size);
+		cmd_size = ldim_dev_config.cmd_size;
+		if (cmd_size > 1) {
+			propdata = (char *)fdt_getprop(dt_addr, child_offset, "init_on", NULL);
+			if (propdata == NULL) {
+				LDIMPR("no init_on\n");
+				ldim_dev_config.init_on[0] = 0xff;
+			} else {
+				i = 0;
+				while (i < LDIM_SPI_INIT_ON_SIZE) {
+					for (j = 0; j < cmd_size; j++) {
+						ldim_dev_config.init_on[i+j] =
+							(unsigned char)(be32_to_cpup((((u32*)propdata)+i+j)));
+					}
+					if (ldim_dev_config.init_on[i] == 0xff)
+						break;
+					else
+						i += cmd_size;
+				}
+			}
+			propdata = (char *)fdt_getprop(dt_addr, child_offset, "init_off", NULL);
+			if (propdata == NULL) {
+				LDIMPR("no init_off\n");
+				ldim_dev_config.init_off[0] = 0xff;
+			} else {
+				i = 0;
+				while (i < LDIM_SPI_INIT_OFF_SIZE) {
+					for (j = 0; j < cmd_size; j++) {
+						ldim_dev_config.init_off[i+j] =
+							(unsigned char)(be32_to_cpup((((u32*)propdata)+i+j)));
+					}
+					if (ldim_dev_config.init_off[i] == 0xff)
+						break;
+					else
+						i += cmd_size;
 				}
-				if (ldim_dev_config.init_off[i] == 0xff)
-					break;
-				else
-					i += cmd_size;
 			}
 		}
+		break;
+	case LDIM_DEV_TYPE_I2C:
+		break;
+	case LDIM_DEV_TYPE_NORMAL:
+	default:
+		break;
 	}
 
 	/* get pinmux */
-	parent_offset = fdt_path_offset(dt_addr, "/pinmux/ldim_pwm_pin");
+	sprintf(propname, "/pinmux/%s_pin", ldim_dev_config.pinmux_name);
+	parent_offset = fdt_path_offset(dt_addr, propname);
 	if (parent_offset < 0) {
 		LDIMERR("not find ldim_pwm_pin node\n");
 		ld_pwm->pinmux_set[0][0] = LCD_PINMUX_END;
@@ -521,6 +549,7 @@ static int ldim_dev_get_config_from_dts(char *dt_addr, int index)
 				ld_pwm->pinmux_set[temp][1] = 0x0;
 			}
 		}
+
 		propdata = (char *)fdt_getprop(dt_addr, parent_offset, "amlogic,clrmask", &len);
 		if (propdata == NULL) {
 			LDIMERR("failed to get amlogic,clrmask\n");
@@ -543,7 +572,7 @@ static int ldim_dev_get_config_from_dts(char *dt_addr, int index)
 				if (ld_pwm->pinmux_set[i][0] == LCD_PINMUX_END)
 					break;
 				LDIMPR("pinmux set: %d, 0x%08x\n",
-					ld_pwm->pinmux_set[i][0], ld_pwm->pinmux_set[i][1]);
+				ld_pwm->pinmux_set[i][0], ld_pwm->pinmux_set[i][1]);
 				i++;
 			}
 			i = 0;
@@ -551,11 +580,12 @@ static int ldim_dev_get_config_from_dts(char *dt_addr, int index)
 				if (ld_pwm->pinmux_clr[i][0] == LCD_PINMUX_END)
 					break;
 				LDIMPR("pinmux clr: %d, 0x%08x\n",
-					ld_pwm->pinmux_clr[i][0], ld_pwm->pinmux_clr[i][1]);
+				ld_pwm->pinmux_clr[i][0], ld_pwm->pinmux_clr[i][1]);
 				i++;
 			}
 		}
 	}
+
 #endif
 
 	return 0;
@@ -568,22 +598,32 @@ static int ldim_dev_add_driver(struct ldim_dev_config_s *ldev_conf, int index)
 #ifdef CONFIG_AML_SPICC
 	if (strcmp(ldev_conf->name, "iw7019") == 0) {
 #ifdef CONFIG_AML_LOCAL_DIMMING_IW7019
-	ret = ldim_dev_iw7019_probe();
+		ret = ldim_dev_iw7019_probe();
+		goto ldim_dev_add_driver_next;
+#endif
+	}
+#else
+	LDIMERR("%s: no AML_SPICC config\n", __func__);
+	ret = -1;
+#endif
+
+	if (strcmp(ldev_conf->name, "ob3350") == 0) {
+#ifdef CONFIG_AML_LOCAL_DIMMING_OB3350
+		ret = ldim_dev_ob3350_probe();
+		goto ldim_dev_add_driver_next;
 #endif
 	} else {
 		LDIMERR("invalid device name: %s\n", ldev_conf->name);
 		ret = -1;
 	}
+
+ldim_dev_add_driver_next:
 	if (ret) {
 		LDIMERR("add device driver failed %s(%d)\n",
 			ldev_conf->name, index);
 	} else {
 		LDIMPR("add device driver %s(%d)\n", ldev_conf->name, index);
 	}
-#else
-	LDIMERR("%s: no AML_SPICC config\n", __func__);
-	ret = -1;
-#endif
 
 	return ret;
 }
@@ -597,21 +637,31 @@ static int ldim_dev_remove_driver(struct ldim_dev_config_s *ldev_conf,
 	if (strcmp(ldev_conf->name, "iw7019") == 0) {
 #ifdef CONFIG_AML_LOCAL_DIMMING_IW7019
 		ret = ldim_dev_iw7019_remove();
+		goto ldim_dev_remove_driver_next;
+#endif
+	}
+#else
+	LDIMERR("%s: no AML_SPICC config\n", __func__);
+	ret = -1;
+#endif
+
+	if (strcmp(ldev_conf->name, "ob3350") == 0) {
+#ifdef CONFIG_AML_LOCAL_DIMMING_OB3350
+		ret = ldim_dev_ob3350_remove();
+		goto ldim_dev_remove_driver_next;
 #endif
 	} else {
 		LDIMERR("invalid device name: %s\n", ldev_conf->name);
 		ret = -1;
 	}
+
+ldim_dev_remove_driver_next:
 	if (ret) {
-		LDIMERR("remove device driver failed %s(%d)\n",
+		LDIMERR("add device driver failed %s(%d)\n",
 			ldev_conf->name, index);
 	} else {
-		LDIMPR("remove device driver %s(%d)\n", ldev_conf->name, index);
+		LDIMPR("add device driver %s(%d)\n", ldev_conf->name, index);
 	}
-#else
-	LDIMERR("%s: no AML_SPICC config\n", __func__);
-	ret = -1;
-#endif
 
 	return ret;
 }
@@ -628,17 +678,6 @@ int aml_ldim_device_probe(char *dt_addr)
 	if (ret)
 		return -1;
 
-	/* register spi */
-	ldim_drv->spi = spi_setup_slave(ldim_spi_dev.bus_num,
-					ldim_spi_dev.chip_select,
-					ldim_spi_dev.max_speed_hz,
-					ldim_spi_dev.mode);
-	if (ldim_drv->spi == NULL) {
-		LDIMERR("register ldim_dev spi driver failed\n");
-		return -1;
-	}
-	spi_cs_deactivate(ldim_drv->spi);
-
 	/* add device driver */
 	ret = ldim_dev_add_driver(ldim_drv->ldev_conf, ldim_drv->dev_index);
 
diff --git a/drivers/display/lcd/aml_ldim/ldim_dev_drv.h b/drivers/display/lcd/aml_ldim/ldim_dev_drv.h
index 6926d50..b1e8f53 100644
--- a/drivers/display/lcd/aml_ldim/ldim_dev_drv.h
+++ b/drivers/display/lcd/aml_ldim/ldim_dev_drv.h
@@ -21,6 +21,8 @@
 
 extern void ldim_set_gpio(int index, int value);
 extern unsigned int ldim_get_gpio(int index);
+extern void ldim_set_duty_pwm(struct bl_pwm_config_s *bl);
+
 
 /* ldim device probe function */
 #ifdef CONFIG_AML_SPICC
@@ -31,4 +33,9 @@ extern int ldim_dev_iw7019_remove(void);
 
 #endif
 
+#ifdef CONFIG_AML_LOCAL_DIMMING_OB3350
+extern int ldim_dev_ob3350_probe(void);
+extern int ldim_dev_ob3350_remove(void);
+#endif
+
 #endif
diff --git a/drivers/display/lcd/aml_ldim/ldim_drv.c b/drivers/display/lcd/aml_ldim/ldim_drv.c
index e52d44f..2796dfe 100644
--- a/drivers/display/lcd/aml_ldim/ldim_drv.c
+++ b/drivers/display/lcd/aml_ldim/ldim_drv.c
@@ -25,6 +25,7 @@
 #include "../aml_lcd_common.h"
 #include "ldim_drv.h"
 
+#define LD_DATA_MIN           10
 #define LDIM_BRI_LEVEL_MAX    0xfff
 #define LDIM_BRI_LEVEL_MIN    0x7f
 static unsigned int ldim_blk_row = 1;
@@ -62,10 +63,10 @@ static void ldim_brightness_update(unsigned int level)
 
 	size = ldim_blk_row * ldim_blk_col;
 	for (i = 0; i < size; i++)
-		ldim_driver.ldim_matrix_2_spi[i] = (unsigned short)level;
+		ldim_driver.ldim_matrix_buf[i] = (unsigned short)level;
 
 	if (ldim_driver.device_bri_update)
-		ldim_driver.device_bri_update(ldim_driver.ldim_matrix_2_spi, size);
+		ldim_driver.device_bri_update(ldim_driver.ldim_matrix_buf, size);
 	else
 		LDIMPR("%s: device_bri_update is null\n", __func__);
 }
@@ -84,8 +85,9 @@ static int ldim_set_level(unsigned int level)
 	level_max = lcd_drv->bl_config->level_max;
 	level_min = lcd_drv->bl_config->level_min;
 
-	level = ((level - level_min) * LD_DATA_MAX) / (level_max - level_min);
-	level &= LD_DATA_MAX;
+	level = ((level - level_min) * (LD_DATA_MAX - LD_DATA_MIN)) /
+		(level_max - level_min) + LD_DATA_MIN;
+	level &= 0xfff;
 	ldim_brightness_update(level);
 
 	return ret;
@@ -143,7 +145,7 @@ static struct aml_ldim_driver_s ldim_driver = {
 	.valid_flag = 0, /* default invalid, active when bl_ctrl_method=ldim */
 	.dev_index = 0,
 	.ldev_conf = NULL,
-	.ldim_matrix_2_spi = NULL,
+	.ldim_matrix_buf = NULL,
 	.power_on = ldim_power_on,
 	.power_off = ldim_power_off,
 	.set_level = ldim_set_level,
@@ -232,9 +234,9 @@ int aml_ldim_probe(char *dt_addr, int flag)
 		break;
 	}
 	size = ldim_blk_row * ldim_blk_col;
-	ldim_driver.ldim_matrix_2_spi = (unsigned short *)malloc(sizeof(unsigned short) * size);
-	if (ldim_driver.ldim_matrix_2_spi == NULL) {
-		LDIMERR("ldim_matrix_2_spi malloc error\n");
+	ldim_driver.ldim_matrix_buf = (unsigned short *)malloc(sizeof(unsigned short) * size);
+	if (ldim_driver.ldim_matrix_buf == NULL) {
+		LDIMERR("ldim_matrix_buf malloc error\n");
 		return -1;
 	}
 
diff --git a/drivers/display/lcd/aml_ldim/ob3350.c b/drivers/display/lcd/aml_ldim/ob3350.c
new file mode 100644
index 0000000..a31d9cb
--- /dev/null
+++ b/drivers/display/lcd/aml_ldim/ob3350.c
@@ -0,0 +1,135 @@
+/*
+ * drivers/display/lcd/lcd_bl_ldim/ob3350_bl.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/arch/gpio.h>
+#ifdef CONFIG_OF_LIBFDT
+#include <libfdt.h>
+#endif
+#include <amlogic/aml_lcd.h>
+#include <amlogic/aml_ldim.h>
+#include "../aml_lcd_reg.h"
+#include "../aml_lcd_common.h"
+#include "ldim_drv.h"
+#include "ldim_dev_drv.h"
+
+static int ob3350_on_flag;
+
+static int ob3350_hw_init_on(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_set_gpio(ldim_drv->ldev_conf->en_gpio, ldim_drv->ldev_conf->en_gpio_on);
+	mdelay(2);
+	ldim_drv->pinmux_ctrl(1);
+	mdelay(20);
+
+	return 0;
+}
+
+static int ob3350_hw_init_off(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_drv->pinmux_ctrl(0);
+	ldim_set_gpio(ldim_drv->ldev_conf->en_gpio, ldim_drv->ldev_conf->en_gpio_off);
+
+	return 0;
+}
+
+static unsigned int ob3350_get_value(unsigned int level)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	unsigned int val;
+	unsigned int dim_max, dim_min;
+
+	dim_max = ldim_drv->ldev_conf->dim_max;
+	dim_min = ldim_drv->ldev_conf->dim_min;
+
+	val = dim_min + ((level * (dim_max - dim_min)) / LD_DATA_MAX);
+
+	return val;
+}
+
+static int ob3350_smr(unsigned short *buf, unsigned char len)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	unsigned short val;
+
+	val = ob3350_get_value(buf[0]);
+	ldim_drv->ldev_conf->pwm_config.pwm_duty = val;
+
+	if (ob3350_on_flag == 0) {
+		if (lcd_debug_print_flag)
+			LDIMPR("%s: on_flag=%d\n", __func__, ob3350_on_flag);
+		return 0;
+	}
+
+	if (len != 1) {
+		LDIMERR("%s: data len %d invalid\n", __func__, len);
+		return -1;
+	}
+
+	ldim_set_duty_pwm(&(ldim_drv->ldev_conf->pwm_config));
+
+	return 0;
+}
+
+static int ob3350_power_on(void)
+{
+	ob3350_hw_init_on();
+	ob3350_on_flag = 1;
+	/* init brightness level */
+	ldim_set_duty_pwm(&(ldim_drv->ldev_conf->pwm_config));
+
+	LDIMPR("%s: ok\n", __func__);
+	return 0;
+}
+
+static int ob3350_power_off(void)
+{
+	ob3350_on_flag = 0;
+	ob3350_hw_init_off();
+
+	LDIMPR("%s: ok\n", __func__);
+	return 0;
+}
+
+static int ob3350_ldim_driver_update(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_drv->device_power_on = ob3350_power_on;
+	ldim_drv->device_power_off = ob3350_power_off;
+	ldim_drv->device_bri_update = ob3350_smr;
+
+	return 0;
+}
+
+int ldim_dev_ob3350_probe(void)
+{
+	ob3350_on_flag = 0;
+	ob3350_ldim_driver_update();
+
+	return 0;
+}
+
+int ldim_dev_ob3350_remove(void)
+{
+	return 0;
+}
+
diff --git a/drivers/display/lcd/lcd_tablet/lcd_drv.c b/drivers/display/lcd/lcd_tablet/lcd_drv.c
index bf58c28..ad42e5c 100644
--- a/drivers/display/lcd/lcd_tablet/lcd_drv.c
+++ b/drivers/display/lcd/lcd_tablet/lcd_drv.c
@@ -178,7 +178,7 @@ static void lcd_ttl_pinmux_set(int status)
 
 static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 {
-	unsigned int vswing, preem;
+	unsigned int vswing, preem, clk_vswing, clk_preem;
 	unsigned int data32;
 
 	if (lcd_debug_print_flag)
@@ -187,6 +187,8 @@ static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 	if (status) {
 		vswing = pconf->lcd_control.lvds_config->phy_vswing;
 		preem = pconf->lcd_control.lvds_config->phy_preem;
+		clk_vswing = pconf->lcd_control.lvds_config->phy_clk_vswing;
+		clk_preem = pconf->lcd_control.lvds_config->phy_clk_preem;
 		if (vswing > 7) {
 			LCDERR("%s: wrong vswing_level=%d, use default\n",
 				__func__, vswing);
@@ -197,11 +199,23 @@ static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 				__func__, preem);
 			preem = LVDS_PHY_PREEM_DFT;
 		}
+		if (clk_vswing > 7) {
+			LCDERR("%s: wrong clk_vswing_level=%d, use default\n",
+				__func__, clk_vswing);
+			clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
+		}
+		if (clk_preem > 7) {
+			LCDERR("%s: wrong clk_preem_level=%d, use default\n",
+				__func__, clk_preem);
+			clk_preem = LVDS_PHY_CLK_PREEM_DFT;
+		}
 		data32 = 0x606cca80 | (vswing << 26) | (preem << 0);
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, data32);
 		/*lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);*/
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
-		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
+		data32 = 0x0fff0800 | (clk_vswing << 8) | (clk_preem << 5);
+		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, data32);
+		/*lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);*/
 	} else {
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, 0x0);
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, 0x0);
@@ -305,19 +319,12 @@ static void lcd_ttl_control_set(struct lcd_config_s *pconf)
 
 static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 {
-	unsigned int fifo_mode, phy_div, dual_port;
+	unsigned int phy_div;
 
-	dual_port = pconf->lcd_control.lvds_config->dual_port;
-	if (dual_port) {
-		fifo_mode = 0x3;
+	if (pconf->lcd_control.lvds_config->dual_port)
 		phy_div = 2;
-	} else {
-		fifo_mode = 0x1;
+	else
 		phy_div = 1;
-	}
-
-	lcd_vcbus_write(LVDS_GEN_CNTL, (lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
-	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 
 	/* set fifo_clk_sel: div 7 */
 	lcd_hiu_write(HHI_LVDS_TX_PHY_CNTL0, (1 << 6));
@@ -334,10 +341,9 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 {
 	unsigned int bit_num = 1;
-	unsigned int pn_swap = 0;
-	unsigned int dual_port = 1;
+	unsigned int pn_swap, port_swap;
+	unsigned int dual_port, fifo_mode;
 	unsigned int lvds_repack = 1;
-	unsigned int port_swap = 0;
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
@@ -366,6 +372,10 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		bit_num=1;
 		break;
 	}
+	if (dual_port)
+		fifo_mode = 0x3;
+	else
+		fifo_mode = 0x1;
 
 	lcd_vcbus_write(LVDS_PACK_CNTL_ADDR,
 			(lvds_repack << 0) | // repack
@@ -379,6 +389,14 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 			(0 << 10) |		//r_select  //0:R, 1:G, 2:B, 3:0
 			(1 << 12) |		//g_select  //0:R, 1:G, 2:B, 3:0
 			(2 << 14));		//b_select  //0:R, 1:G, 2:B, 3:0;
+
+	lcd_vcbus_write(LVDS_GEN_CNTL, (lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
+	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
+}
+
+static void lcd_lvds_disable(void)
+{
+	lcd_vcbus_setb(LVDS_GEN_CNTL, 0, 3, 1); /* disable lvds fifo */
 }
 
 static void lcd_venc_set(struct lcd_config_s *pconf)
@@ -426,8 +444,9 @@ void lcd_tablet_driver_init_pre(void)
 	struct lcd_config_s *pconf;
 	int ret;
 
-	LCDPR("tablet driver init(ver: %s)\n", lcd_drv->version);
 	pconf = lcd_drv->lcd_config;
+	LCDPR("tablet driver init(ver %s): %s\n", lcd_drv->version,
+		lcd_type_type_to_str(pconf->lcd_basic.lcd_type));
 	ret = lcd_type_supported(pconf);
 	if (ret)
 		return;
@@ -487,7 +506,7 @@ void lcd_tablet_driver_disable(void)
 		break;
 	case LCD_LVDS:
 		lcd_lvds_phy_set(pconf, 0);
-		lcd_vcbus_setb(LVDS_GEN_CNTL, 0, 3, 1); /* disable lvds fifo */
+		lcd_lvds_disable();
 		break;
 	default:
 		break;
diff --git a/drivers/display/lcd/lcd_tablet/lcd_tablet.c b/drivers/display/lcd/lcd_tablet/lcd_tablet.c
index 2bf70dd..469c535 100644
--- a/drivers/display/lcd/lcd_tablet/lcd_tablet.c
+++ b/drivers/display/lcd/lcd_tablet/lcd_tablet.c
@@ -55,6 +55,13 @@ static void lcd_config_load_print(struct lcd_config_s *pconf)
 	LCDPR("h_period = %d\n", pconf->lcd_basic.h_period);
 	LCDPR("v_period = %d\n", pconf->lcd_basic.v_period);
 
+	LCDPR("h_period_min = %d\n", pconf->lcd_basic.h_period_min);
+	LCDPR("h_period_max = %d\n", pconf->lcd_basic.h_period_max);
+	LCDPR("v_period_min = %d\n", pconf->lcd_basic.v_period_min);
+	LCDPR("v_period_max = %d\n", pconf->lcd_basic.v_period_max);
+	LCDPR("pclk_min = %d\n", pconf->lcd_basic.lcd_clk_min);
+	LCDPR("pclk_max = %d\n", pconf->lcd_basic.lcd_clk_max);
+
 	LCDPR("hsync_width = %d\n", pconf->lcd_timing.hsync_width);
 	LCDPR("hsync_bp = %d\n", pconf->lcd_timing.hsync_bp);
 	LCDPR("hsync_pol = %d\n", pconf->lcd_timing.hsync_pol);
@@ -88,6 +95,7 @@ static int lcd_config_load_from_dts(char *dt_addr, struct lcd_config_s *pconf)
 	char *p;
 	const char *str;
 	unsigned int i, j, temp;
+	int len;
 
 	parent_offset = fdt_path_offset(dt_addr, "/lcd");
 	if (parent_offset < 0) {
@@ -141,6 +149,24 @@ static int lcd_config_load_from_dts(char *dt_addr, struct lcd_config_s *pconf)
 		pconf->lcd_basic.screen_height = be32_to_cpup((((u32*)propdata)+6));
 	}
 
+	propdata = (char *)fdt_getprop(dt_addr, child_offset, "range_setting", NULL);
+	if (propdata == NULL) {
+		LCDERR("failed to get range_setting\n");
+		pconf->lcd_basic.h_period_min = pconf->lcd_basic.h_period;
+		pconf->lcd_basic.h_period_max = pconf->lcd_basic.h_period;
+		pconf->lcd_basic.v_period_min = pconf->lcd_basic.v_period;
+		pconf->lcd_basic.v_period_max = pconf->lcd_basic.v_period;
+		pconf->lcd_basic.lcd_clk_min = 0;
+		pconf->lcd_basic.lcd_clk_max = 0;
+	} else {
+		pconf->lcd_basic.h_period_min = be32_to_cpup((u32*)propdata);
+		pconf->lcd_basic.h_period_max = be32_to_cpup((((u32*)propdata)+1));
+		pconf->lcd_basic.v_period_min = be32_to_cpup((((u32*)propdata)+2));
+		pconf->lcd_basic.v_period_max = be32_to_cpup((((u32*)propdata)+3));
+		pconf->lcd_basic.lcd_clk_min = be32_to_cpup((((u32*)propdata)+4));
+		pconf->lcd_basic.lcd_clk_max = be32_to_cpup((((u32*)propdata)+5));
+	}
+
 	propdata = (char *)fdt_getprop(dt_addr, child_offset, "lcd_timing", NULL);
 	if (propdata == NULL) {
 		LCDERR("failed to get lcd_timing\n");
@@ -212,18 +238,36 @@ static int lcd_config_load_from_dts(char *dt_addr, struct lcd_config_s *pconf)
 			pconf->lcd_control.lvds_config->pn_swap     = be32_to_cpup((((u32*)propdata)+2));
 			pconf->lcd_control.lvds_config->port_swap   = be32_to_cpup((((u32*)propdata)+3));
 		}
-		propdata = (char *)fdt_getprop(dt_addr, child_offset, "phy_attr", NULL);
+		propdata = (char *)fdt_getprop(dt_addr, child_offset, "phy_attr", &len);
 		if (propdata == NULL) {
 			if (lcd_debug_print_flag)
 				LCDPR("failed to get phy_attr\n");
 			pconf->lcd_control.lvds_config->phy_vswing = LVDS_PHY_VSWING_DFT;
 			pconf->lcd_control.lvds_config->phy_preem  = LVDS_PHY_PREEM_DFT;
 		} else {
-			pconf->lcd_control.lvds_config->phy_vswing = be32_to_cpup((u32*)propdata);
-			pconf->lcd_control.lvds_config->phy_preem  = be32_to_cpup((((u32*)propdata)+1));
-			LCDPR("set phy vswing=%d, preemphasis=%d\n",
-				pconf->lcd_control.lvds_config->phy_vswing,
-				pconf->lcd_control.lvds_config->phy_preem);
+			len = len / 4;
+			if (len == 4) {
+				pconf->lcd_control.lvds_config->phy_vswing = be32_to_cpup((u32*)propdata);
+				pconf->lcd_control.lvds_config->phy_preem  = be32_to_cpup((((u32*)propdata)+1));
+				pconf->lcd_control.lvds_config->phy_clk_vswing = be32_to_cpup((((u32*)propdata)+2));
+				pconf->lcd_control.lvds_config->phy_clk_preem  = be32_to_cpup((((u32*)propdata)+3));
+				LCDPR("set phy vswing=%d, preemphasis=%d\n",
+					pconf->lcd_control.lvds_config->phy_vswing,
+					pconf->lcd_control.lvds_config->phy_preem);
+				LCDPR("set phy clk_vswing=%d, clk_preemphasis=%d\n",
+					pconf->lcd_control.lvds_config->phy_clk_vswing,
+					pconf->lcd_control.lvds_config->phy_clk_preem);
+			} else if (len == 2) {
+				pconf->lcd_control.lvds_config->phy_vswing = be32_to_cpup((u32*)propdata);
+				pconf->lcd_control.lvds_config->phy_preem  = be32_to_cpup((((u32*)propdata)+1));
+				pconf->lcd_control.lvds_config->phy_clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
+				pconf->lcd_control.lvds_config->phy_clk_preem  = LVDS_PHY_CLK_PREEM_DFT;
+				LCDPR("set phy vswing=%d, preemphasis=%d\n",
+					pconf->lcd_control.lvds_config->phy_vswing,
+					pconf->lcd_control.lvds_config->phy_preem);
+			} else {
+				LCDERR("invalid phy_attr parameters cnt: %d\n", len);
+			}
 		}
 		break;
 	default:
@@ -303,7 +347,7 @@ static int lcd_config_load_from_dts(char *dt_addr, struct lcd_config_s *pconf)
 	propdata = (char *)fdt_getprop(dt_addr, child_offset, "backlight_index", NULL);
 	if (propdata == NULL) {
 		LCDERR("failed to get backlight_index\n");
-		pconf->backlight_index = 0;
+		pconf->backlight_index = 0xff;
 		return 0;
 	} else {
 		pconf->backlight_index = be32_to_cpup((u32*)propdata);
@@ -344,6 +388,14 @@ static int lcd_config_load_from_bsp(struct lcd_config_s *pconf)
 	pconf->lcd_basic.v_active = ext_lcd->v_active;
 	pconf->lcd_basic.h_period = ext_lcd->h_period;
 	pconf->lcd_basic.v_period = ext_lcd->v_period;
+
+	pconf->lcd_basic.h_period_min = pconf->lcd_basic.h_period;
+	pconf->lcd_basic.h_period_max = pconf->lcd_basic.h_period;
+	pconf->lcd_basic.v_period_min = pconf->lcd_basic.v_period;
+	pconf->lcd_basic.v_period_max = pconf->lcd_basic.v_period;
+	pconf->lcd_basic.lcd_clk_min = 0;
+	pconf->lcd_basic.lcd_clk_max = 0;
+
 	pconf->lcd_timing.hsync_width = ext_lcd->hsync_width;
 	pconf->lcd_timing.hsync_bp    = ext_lcd->hsync_bp;
 	pconf->lcd_timing.hsync_pol    = ext_lcd->hsync_pol;
@@ -385,6 +437,8 @@ static int lcd_config_load_from_bsp(struct lcd_config_s *pconf)
 		pconf->lcd_control.lvds_config->port_swap   = ext_lcd->lcd_spc_val3;
 		pconf->lcd_control.lvds_config->phy_vswing = LVDS_PHY_VSWING_DFT;
 		pconf->lcd_control.lvds_config->phy_preem  = LVDS_PHY_PREEM_DFT;
+		pconf->lcd_control.lvds_config->phy_clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
+		pconf->lcd_control.lvds_config->phy_clk_preem  = LVDS_PHY_CLK_PREEM_DFT;
 	}
 
 	i = 0;
@@ -526,10 +580,20 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
 	p += LCD_UKEY_PCLK;
 	/* dummy pointer */
-	p += LCD_UKEY_CUST_VAL_4;
-	p += LCD_UKEY_CUST_VAL_5;
-	p += LCD_UKEY_CUST_VAL_6;
-	p += LCD_UKEY_CUST_VAL_7;
+	pconf->lcd_basic.h_period_min = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_H_PERIOD_MIN;
+	pconf->lcd_basic.h_period_max = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_H_PERIOD_MAX;
+	pconf->lcd_basic.v_period_min = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_V_PERIOD_MIN;
+	pconf->lcd_basic.v_period_max = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_V_PERIOD_MAX;
+	pconf->lcd_basic.lcd_clk_min = (*p | ((*(p + 1)) << 8) |
+		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
+	p += LCD_UKEY_PCLK_MIN;
+	pconf->lcd_basic.lcd_clk_max = (*p | ((*(p + 1)) << 8) |
+		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
+	/* dummy pointer */
 	p += LCD_UKEY_CUST_VAL_8;
 	p += LCD_UKEY_CUST_VAL_9;
 
@@ -547,9 +611,11 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		p += LCD_UKEY_IF_ATTR_4;
 		pconf->lcd_control.lvds_config->phy_vswing = (*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_5;
-		/* dummy pointer */
+		pconf->lcd_control.lvds_config->phy_clk_vswing = (*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_6;
+		pconf->lcd_control.lvds_config->phy_clk_preem = (*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_7;
+		/* dummy pointer */
 		p += LCD_UKEY_IF_ATTR_8;
 		p += LCD_UKEY_IF_ATTR_9;
 	} else if (pconf->lcd_basic.lcd_type == LCD_TTL) {
@@ -672,6 +738,9 @@ static void lcd_config_init(struct lcd_config_s *pconf)
 	} else { /* regard as pixel clock */
 		sync_duration = ((clk / h_period) * 100) / v_period;
 	}
+	pconf->lcd_timing.lcd_clk_dft = pconf->lcd_timing.lcd_clk;
+	pconf->lcd_timing.h_period_dft = pconf->lcd_basic.h_period;
+	pconf->lcd_timing.v_period_dft = pconf->lcd_basic.v_period;
 	pconf->lcd_timing.sync_duration_num = sync_duration;
 	pconf->lcd_timing.sync_duration_den = 100;
 
diff --git a/drivers/display/lcd/lcd_tablet/lcd_tablet.h b/drivers/display/lcd/lcd_tablet/lcd_tablet.h
index ebe7f64..17e2602 100644
--- a/drivers/display/lcd/lcd_tablet/lcd_tablet.h
+++ b/drivers/display/lcd/lcd_tablet/lcd_tablet.h
@@ -24,7 +24,7 @@
 //**********************************
 #define LCD_DRV_TYPE      "tablet"
 
-#define LCD_DRV_VERSION    "20160415"
+#define LCD_DRV_VERSION    "20160630"
 //**********************************
 
 extern void lcd_tablet_driver_init_pre(void);
diff --git a/drivers/display/lcd/lcd_tv/lcd_drv.c b/drivers/display/lcd/lcd_tv/lcd_drv.c
index c419447..0a77cbb 100644
--- a/drivers/display/lcd/lcd_tv/lcd_drv.c
+++ b/drivers/display/lcd/lcd_tv/lcd_drv.c
@@ -44,14 +44,34 @@ static int lcd_type_supported(struct lcd_config_s *pconf)
 /* set VX1_LOCKN && VX1_HTPDN */
 static void lcd_vbyone_pinmux_set(int status)
 {
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
 	if (lcd_debug_print_flag)
 		LCDPR("%s: %d\n", __func__, status);
 
 	if (status) {
-		lcd_pinmux_clr_mask(7, ((1 << 1) | (1 << 2) | (1 << 9) | (1 << 10)));
-		lcd_pinmux_set_mask(7, ((1 << 11) | (1 << 12)));
+		switch (lcd_drv->chip_type) {
+		case LCD_CHIP_GXTVBB:
+			lcd_pinmux_clr_mask(7, ((1 << 1) | (1 << 2) | (1 << 9) | (1 << 10)));
+			lcd_pinmux_set_mask(7, ((1 << 11) | (1 << 12)));
+			break;
+		case LCD_CHIP_TXL:
+			lcd_pinmux_set_mask(0, ((1 << 30) | (1 << 31)));
+			break;
+		default:
+			break;
+		}
 	} else {
-		lcd_pinmux_clr_mask(7, ((1 << 11) | (1 << 12)));
+		switch (lcd_drv->chip_type) {
+		case LCD_CHIP_GXTVBB:
+			lcd_pinmux_clr_mask(7, ((1 << 11) | (1 << 12)));
+			break;
+		case LCD_CHIP_TXL:
+			lcd_pinmux_clr_mask(0, ((1 << 30) | (1 << 31)));
+			break;
+		default:
+			break;
+		}
 	}
 }
 
@@ -92,7 +112,7 @@ static void lcd_vbyone_phy_set(struct lcd_config_s *pconf, int status)
 
 static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 {
-	unsigned int vswing, preem;
+	unsigned int vswing, preem, clk_vswing, clk_preem;
 	unsigned int data32;
 
 	if (lcd_debug_print_flag)
@@ -101,6 +121,8 @@ static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 	if (status) {
 		vswing = pconf->lcd_control.lvds_config->phy_vswing;
 		preem = pconf->lcd_control.lvds_config->phy_preem;
+		clk_vswing = pconf->lcd_control.lvds_config->phy_clk_vswing;
+		clk_preem = pconf->lcd_control.lvds_config->phy_clk_preem;
 		if (vswing > 7) {
 			LCDERR("%s: wrong vswing_level=%d, use default\n",
 				__func__, vswing);
@@ -111,11 +133,23 @@ static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 				__func__, preem);
 			preem = LVDS_PHY_PREEM_DFT;
 		}
+		if (clk_vswing > 7) {
+			LCDERR("%s: wrong clk_vswing_level=%d, use default\n",
+				__func__, clk_vswing);
+			clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
+		}
+		if (clk_preem > 7) {
+			LCDERR("%s: wrong clk_preem_level=%d, use default\n",
+				__func__, clk_preem);
+			clk_preem = LVDS_PHY_CLK_PREEM_DFT;
+		}
 		data32 = 0x606cca80 | (vswing << 26) | (preem << 0);
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, data32);
 		/*lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);*/
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
-		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
+		data32 = 0x0fff0800 | (clk_vswing << 8) | (clk_preem << 5);
+		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, data32);
+		/*lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);*/
 	} else {
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, 0x0);
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, 0x0);
@@ -152,19 +186,12 @@ static void lcd_tcon_set(struct lcd_config_s *pconf)
 
 static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 {
-	unsigned int fifo_mode, phy_div, dual_port;
+	unsigned int phy_div;
 
-	dual_port = pconf->lcd_control.lvds_config->dual_port;
-	if (dual_port) {
-		fifo_mode = 0x3;
+	if (pconf->lcd_control.lvds_config->dual_port)
 		phy_div = 2;
-	} else {
-		fifo_mode = 0x1;
+	else
 		phy_div = 1;
-	}
-
-	lcd_vcbus_write(LVDS_GEN_CNTL, (lcd_vcbus_read(LVDS_GEN_CNTL)| (1 << 4) | (fifo_mode << 0)));
-	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 
 	/* set fifo_clk_sel: div 7 */
 	lcd_hiu_write(HHI_LVDS_TX_PHY_CNTL0, (1 << 6));
@@ -181,10 +208,9 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 {
 	unsigned int bit_num = 1;
-	unsigned int pn_swap = 0;
-	unsigned int dual_port = 1;
+	unsigned int pn_swap, port_swap;
+	unsigned int dual_port, fifo_mode;
 	unsigned int lvds_repack = 1;
-	unsigned int port_swap = 0;
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
@@ -213,6 +239,10 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		bit_num=1;
 		break;
 	}
+	if (dual_port)
+		fifo_mode = 0x3;
+	else
+		fifo_mode = 0x1;
 
 	lcd_vcbus_write(LVDS_PACK_CNTL_ADDR,
 			(lvds_repack << 0) | // repack
@@ -226,6 +256,9 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 			(0 << 10) |		//r_select  //0:R, 1:G, 2:B, 3:0
 			(1 << 12) |		//g_select  //0:R, 1:G, 2:B, 3:0
 			(2 << 14));		//b_select  //0:R, 1:G, 2:B, 3:0;
+
+	lcd_vcbus_write(LVDS_GEN_CNTL, (lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
+	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 }
 
 static void lcd_lvds_disable(void)
@@ -482,6 +515,22 @@ static void lcd_vbyone_wait_stable(void)
 	LCDPR("%s status: 0x%x, i=%d\n", __func__, lcd_vcbus_read(VBO_STATUS_L), (500 - i));
 }
 
+static void lcd_vx1_wait_hpd(void)
+{
+	int i = 0;
+	while (lcd_vcbus_read(VBO_STATUS_L) & 0x40) {
+		if (i++ >= 10000)
+			break;
+		udelay(50);
+	}
+	if (lcd_vcbus_read(VBO_STATUS_L) & 0x40)
+		LCDPR("%s: hpd=%d\n", __func__,
+			((lcd_vcbus_read(VBO_STATUS_L) >> 6) & 0x1));
+	else
+		LCDPR("%s: hpd=%d, i=%d\n", __func__,
+			((lcd_vcbus_read(VBO_STATUS_L) >> 6) & 0x1), i);
+}
+
 static void lcd_venc_set(struct lcd_config_s *pconf)
 {
 	unsigned int h_active, v_active;
@@ -610,8 +659,9 @@ void lcd_tv_driver_init_pre(void)
 	struct lcd_config_s *pconf;
 	int ret;
 
-	LCDPR("tv driver init(ver: %s)\n", lcd_drv->version);
 	pconf = lcd_drv->lcd_config;
+	LCDPR("tv driver init(ver %s): %s\n", lcd_drv->version,
+		lcd_type_type_to_str(pconf->lcd_basic.lcd_type));
 	ret = lcd_type_supported(pconf);
 	if (ret)
 		return;
@@ -641,6 +691,7 @@ int lcd_tv_driver_init(void)
 	case LCD_VBYONE:
 		lcd_vbyone_pinmux_set(1);
 		lcd_vbyone_control_set(pconf);
+		lcd_vx1_wait_hpd();
 		lcd_vbyone_phy_set(pconf, 1);
 		lcd_vbyone_wait_stable();
 		break;
diff --git a/drivers/display/lcd/lcd_tv/lcd_tv.c b/drivers/display/lcd/lcd_tv/lcd_tv.c
index 5e869e7..96732f7 100644
--- a/drivers/display/lcd/lcd_tv/lcd_tv.c
+++ b/drivers/display/lcd/lcd_tv/lcd_tv.c
@@ -21,143 +21,184 @@
 #ifdef CONFIG_OF_LIBFDT
 #include <libfdt.h>
 #endif
+#include <amlogic/vmode.h>
 #include <amlogic/aml_lcd.h>
 #include "../aml_lcd_reg.h"
 #include "../aml_lcd_common.h"
 #include "lcd_tv.h"
 
-enum {
-	LCD_OUTPUT_MODE_768P = 0,
-	LCD_OUTPUT_MODE_768P50HZ,
-	LCD_OUTPUT_MODE_1080P,
-	LCD_OUTPUT_MODE_1080P50HZ,
-	LCD_OUTPUT_MODE_4K2K60HZ420,
-	LCD_OUTPUT_MODE_4K2K50HZ420,
-	LCD_OUTPUT_MODE_4K2K60HZ,
-	LCD_OUTPUT_MODE_4K2K50HZ,
-	LCD_OUTPUT_MODE_MAX,
+/* ************************************************** *
+   lcd mode function
+ * ************************************************** */
+static unsigned int lcd_std_frame_rate[] = {
+	50,
+	60,
+	48,
 };
 
-struct lcd_info_s {
+struct lcd_vmode_info_s {
 	char *name;
-	int width;
-	int height;
-	int sync_duration_num;
-	int sync_duration_den;
+	enum vmode_e mode;
+	unsigned int width;
+	unsigned int height;
+	unsigned int frame_rate;
 };
 
-static struct lcd_info_s lcd_info[] = {
+
+enum lcd_vmode_e {
+	LCD_VMODE_600P = 0,
+	LCD_VMODE_768P,
+	LCD_VMODE_1080P,
+	LCD_VMODE_2160P,
+	LCD_VMODE_MAX,
+};
+
+static struct lcd_vmode_info_s lcd_vmode_info[] = {
 	{
-		.name              = "768p60hz",
-		.width             = 1366,
-		.height            = 768,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
+		.name              = "600p",
+		.mode              = VMODE_LCD,
+		.width             = 1024,
+		.height            = 600,
+		.frame_rate        = 60,
 	},
 	{
-		.name              = "768p50hz",
+		.name              = "768p",
+		.mode              = VMODE_LCD,
 		.width             = 1366,
 		.height            = 768,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-	},
-	{
-		.name              = "1080p60hz",
-		.width             = 1920,
-		.height            = 1080,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
+		.frame_rate        = 60,
 	},
 	{
-		.name              = "1080p50hz",
+		.name              = "1080p",
+		.mode              = VMODE_LCD,
 		.width             = 1920,
 		.height            = 1080,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-	},
-	{
-		.name              = "2160p60hz420",
-		.width             = 3840,
-		.height            = 2160,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-	},
-	{
-		.name              = "2160p50hz420",
-		.width             = 3840,
-		.height            = 2160,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-	},
-	{
-		.name              = "2160p60hz",
-		.width             = 3840,
-		.height            = 2160,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
+		.frame_rate        = 60,
 	},
 	{
-		.name              = "2160p50hz",
+		.name              = "2160p",
+		.mode              = VMODE_LCD,
 		.width             = 3840,
 		.height            = 2160,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
+		.frame_rate        = 60,
 	},
 	{
 		.name              = "invalid",
+		.mode              = VMODE_INIT_NULL,
 		.width             = 1920,
 		.height            = 1080,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
+		.frame_rate        = 60,
 	},
 };
 
-static int lcd_vmode_is_mached(struct lcd_config_s *pconf, int vmode)
+static int lcd_vmode_is_mached(struct lcd_config_s *pconf, int index)
 {
-	if ((pconf->lcd_basic.h_active != lcd_info[vmode].width) ||
-		(pconf->lcd_basic.v_active != lcd_info[vmode].height)) {
-		LCDERR("outputmode[%s] and panel_type is not match\n",
-			lcd_info[vmode].name);
+	if ((pconf->lcd_basic.h_active == lcd_vmode_info[index].width) &&
+		(pconf->lcd_basic.v_active == lcd_vmode_info[index].height))
+		return 0;
+	else
 		return -1;
+}
+
+static int lcd_outputmode_to_lcd_vmode(const char *mode)
+{
+	int lcd_vmode = LCD_VMODE_MAX;
+	int i, count = ARRAY_SIZE(lcd_vmode_info) - 1;
+	char temp[30], *p;
+	int n;
+
+	p = strchr(mode, 'p');
+	if (p == NULL)
+		return LCD_VMODE_MAX;
+	n = p - mode + 1;
+	strncpy(temp, mode, n);
+	temp[n] = '\0';
+	if (lcd_debug_print_flag)
+		LCDPR("outputmode=%s, lcd_vmode=%s\n", mode, temp);
+
+	for (i = 0; i < count; i++) {
+		if (strcmp(temp, lcd_vmode_info[i].name) == 0) {
+			lcd_vmode = i;
+			break;
+		}
 	}
-	return 0;
+	return lcd_vmode;
+}
+
+static int lcd_outputmode_to_lcd_frame_rate(const char *mode)
+{
+	int frame_rate = 0;
+	char temp[30], *p;
+	int n, i;
+
+	p = strchr(mode, 'p');
+	if (p == NULL)
+		return 0;
+	n = p - mode + 1;
+	strncpy(temp, mode+n, (strlen(mode)-n));
+	p = strchr(temp, 'h');
+	if (p == NULL)
+		return 0;
+	*p = '\0';
+	n = (int)simple_strtoul(temp, NULL, 10);
+	if (lcd_debug_print_flag)
+		LCDPR("outputmode=%s, frame_rate=%d\n", mode, n);
+
+	for (i = 0; i < ARRAY_SIZE(lcd_std_frame_rate); i++) {
+		if (n == lcd_std_frame_rate[i]) {
+			frame_rate = n;
+			break;
+		}
+	}
+	return frame_rate;
 }
 
 static int check_lcd_output_mode(struct lcd_config_s *pconf, char *mode)
 {
-	int vmode, i;
+	int lcd_vmode, frame_rate;
 	int ret;
 
-	for (i = 0; i < ARRAY_SIZE(lcd_info); i++) {
-		if (strcmp(mode, lcd_info[i].name) == 0)
-			break;
+	if (mode == NULL)
+		return LCD_VMODE_MAX;
+
+	lcd_vmode = lcd_outputmode_to_lcd_vmode(mode);
+	if (lcd_vmode >= LCD_VMODE_MAX) {
+		LCDERR("%s: outputmode %s is not support\n", __func__, mode);
+		return LCD_VMODE_MAX;
 	}
-	vmode = i;
-	if (vmode >= LCD_OUTPUT_MODE_MAX) {
-		LCDERR("outputmode[%s] is not support\n", mode);
-		return LCD_OUTPUT_MODE_MAX;
+	frame_rate = lcd_outputmode_to_lcd_frame_rate(mode);
+	if (frame_rate == 0) {
+		LCDERR("%s: frame_rate is not support\n", __func__);
+		return LCD_VMODE_MAX;
+	} else {
+		lcd_vmode_info[lcd_vmode].frame_rate = frame_rate;
+	}
+	ret = lcd_vmode_is_mached(pconf, lcd_vmode);
+	if (ret) {
+		LCDERR("outputmode[%s] and panel_type is not match\n",
+			lcd_vmode_info[lcd_vmode].name);
+		return LCD_VMODE_MAX;
 	}
-	ret = lcd_vmode_is_mached(pconf, vmode);
-	if (ret)
-		return LCD_OUTPUT_MODE_MAX;
-
-	pconf->lcd_timing.sync_duration_num = lcd_info[vmode].sync_duration_num;
-	pconf->lcd_timing.sync_duration_den = lcd_info[vmode].sync_duration_den;
 
-	return vmode;
+	return lcd_vmode;
 }
 
 static void lcd_list_support_mode(void)
 {
-	int i;
+	int i, j;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lcd_basic_s *lcd_basic;
+	char str[30];
 
 	lcd_basic = &lcd_drv->lcd_config->lcd_basic;
-	for (i = 0; i < (ARRAY_SIZE(lcd_info) - 1); i++) {
-		if ((lcd_basic->h_active == lcd_info[i].width) &&
-		(lcd_basic->v_active == lcd_info[i].height)) {
-			printf("%s\n", lcd_info[i].name);
+	for (i = 0; i < (ARRAY_SIZE(lcd_vmode_info) - 1); i++) {
+		if ((lcd_basic->h_active == lcd_vmode_info[i].width) &&
+		(lcd_basic->v_active == lcd_vmode_info[i].height)) {
+			for (j = 0; j < ARRAY_SIZE(lcd_std_frame_rate); j++) {
+				sprintf(str, "%s%dhz", lcd_vmode_info[i].name, lcd_std_frame_rate[j]);
+				printf("%s\n", str);
+			}
+			break;
 		}
 	}
 }
@@ -176,6 +217,13 @@ static void lcd_config_load_print(struct lcd_config_s *pconf)
 	LCDPR("h_period = %d\n", pconf->lcd_basic.h_period);
 	LCDPR("v_period = %d\n", pconf->lcd_basic.v_period);
 
+	LCDPR("h_period_min = %d\n", pconf->lcd_basic.h_period_min);
+	LCDPR("h_period_max = %d\n", pconf->lcd_basic.h_period_max);
+	LCDPR("v_period_min = %d\n", pconf->lcd_basic.v_period_min);
+	LCDPR("v_period_max = %d\n", pconf->lcd_basic.v_period_max);
+	LCDPR("pclk_min = %d\n", pconf->lcd_basic.lcd_clk_min);
+	LCDPR("pclk_max = %d\n", pconf->lcd_basic.lcd_clk_max);
+
 	LCDPR("hsync_width = %d\n", pconf->lcd_timing.hsync_width);
 	LCDPR("hsync_bp = %d\n", pconf->lcd_timing.hsync_bp);
 	LCDPR("hsync_pol = %d\n", pconf->lcd_timing.hsync_pol);
@@ -207,7 +255,8 @@ static int lcd_config_load_from_dts(char *dt_addr, struct lcd_config_s *pconf)
 	int child_offset;
 	char propname[30];
 	char *propdata;
-	int i, j, temp;
+	unsigned int i, j, temp;
+	int len;
 
 	parent_offset = fdt_path_offset(dt_addr, "/lcd");
 	if (parent_offset < 0) {
@@ -261,6 +310,24 @@ static int lcd_config_load_from_dts(char *dt_addr, struct lcd_config_s *pconf)
 		pconf->lcd_basic.screen_height = be32_to_cpup((((u32*)propdata)+6));
 	}
 
+	propdata = (char *)fdt_getprop(dt_addr, child_offset, "range_setting", NULL);
+	if (propdata == NULL) {
+		LCDERR("failed to get range_setting\n");
+		pconf->lcd_basic.h_period_min = pconf->lcd_basic.h_period;
+		pconf->lcd_basic.h_period_max = pconf->lcd_basic.h_period;
+		pconf->lcd_basic.v_period_min = pconf->lcd_basic.v_period;
+		pconf->lcd_basic.v_period_max = pconf->lcd_basic.v_period;
+		pconf->lcd_basic.lcd_clk_min = 0;
+		pconf->lcd_basic.lcd_clk_max = 0;
+	} else {
+		pconf->lcd_basic.h_period_min = be32_to_cpup((u32*)propdata);
+		pconf->lcd_basic.h_period_max = be32_to_cpup((((u32*)propdata)+1));
+		pconf->lcd_basic.v_period_min = be32_to_cpup((((u32*)propdata)+2));
+		pconf->lcd_basic.v_period_max = be32_to_cpup((((u32*)propdata)+3));
+		pconf->lcd_basic.lcd_clk_min = be32_to_cpup((((u32*)propdata)+4));
+		pconf->lcd_basic.lcd_clk_max = be32_to_cpup((((u32*)propdata)+5));
+	}
+
 	propdata = (char *)fdt_getprop(dt_addr, child_offset, "lcd_timing", NULL);
 	if (propdata == NULL) {
 		LCDERR("failed to get lcd_timing\n");
@@ -297,18 +364,38 @@ static int lcd_config_load_from_dts(char *dt_addr, struct lcd_config_s *pconf)
 			pconf->lcd_control.lvds_config->pn_swap     = be32_to_cpup((((u32*)propdata)+2));
 			pconf->lcd_control.lvds_config->port_swap   = be32_to_cpup((((u32*)propdata)+3));
 		}
-		propdata = (char *)fdt_getprop(dt_addr, child_offset, "phy_attr", NULL);
+		propdata = (char *)fdt_getprop(dt_addr, child_offset, "phy_attr", &len);
 		if (propdata == NULL) {
 			if (lcd_debug_print_flag)
 				LCDPR("failed to get phy_attr\n");
 			pconf->lcd_control.lvds_config->phy_vswing = LVDS_PHY_VSWING_DFT;
 			pconf->lcd_control.lvds_config->phy_preem  = LVDS_PHY_PREEM_DFT;
+			pconf->lcd_control.lvds_config->phy_clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
+			pconf->lcd_control.lvds_config->phy_clk_preem  = LVDS_PHY_CLK_PREEM_DFT;
 		} else {
-			pconf->lcd_control.lvds_config->phy_vswing = be32_to_cpup((u32*)propdata);
-			pconf->lcd_control.lvds_config->phy_preem  = be32_to_cpup((((u32*)propdata)+1));
-			LCDPR("set phy vswing=%d, preemphasis=%d\n",
-				pconf->lcd_control.lvds_config->phy_vswing,
-				pconf->lcd_control.lvds_config->phy_preem);
+			len = len / 4;
+			if (len == 4) {
+				pconf->lcd_control.lvds_config->phy_vswing = be32_to_cpup((u32*)propdata);
+				pconf->lcd_control.lvds_config->phy_preem  = be32_to_cpup((((u32*)propdata)+1));
+				pconf->lcd_control.lvds_config->phy_clk_vswing = be32_to_cpup((((u32*)propdata)+2));
+				pconf->lcd_control.lvds_config->phy_clk_preem  = be32_to_cpup((((u32*)propdata)+3));
+				LCDPR("set phy vswing=%d, preemphasis=%d\n",
+					pconf->lcd_control.lvds_config->phy_vswing,
+					pconf->lcd_control.lvds_config->phy_preem);
+				LCDPR("set phy clk_vswing=%d, clk_preemphasis=%d\n",
+					pconf->lcd_control.lvds_config->phy_clk_vswing,
+					pconf->lcd_control.lvds_config->phy_clk_preem);
+			} else if (len == 2) {
+				pconf->lcd_control.lvds_config->phy_vswing = be32_to_cpup((u32*)propdata);
+				pconf->lcd_control.lvds_config->phy_preem  = be32_to_cpup((((u32*)propdata)+1));
+				pconf->lcd_control.lvds_config->phy_clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
+				pconf->lcd_control.lvds_config->phy_clk_preem  = LVDS_PHY_CLK_PREEM_DFT;
+				LCDPR("set phy vswing=%d, preemphasis=%d\n",
+					pconf->lcd_control.lvds_config->phy_vswing,
+					pconf->lcd_control.lvds_config->phy_preem);
+			} else {
+				LCDERR("invalid phy_attr parameters cnt: %d\n", len);
+			}
 		}
 		break;
 	case LCD_VBYONE:
@@ -388,7 +475,7 @@ static int lcd_config_load_from_dts(char *dt_addr, struct lcd_config_s *pconf)
 	propdata = (char *)fdt_getprop(dt_addr, child_offset, "backlight_index", NULL);
 	if (propdata == NULL) {
 		LCDERR("failed to get backlight_index\n");
-		pconf->backlight_index = 0;
+		pconf->backlight_index = 0xff;
 		return 0;
 	} else {
 		pconf->backlight_index = be32_to_cpup((u32*)propdata);
@@ -429,6 +516,14 @@ static int lcd_config_load_from_bsp(struct lcd_config_s *pconf)
 	pconf->lcd_basic.v_active = ext_lcd->v_active;
 	pconf->lcd_basic.h_period = ext_lcd->h_period;
 	pconf->lcd_basic.v_period = ext_lcd->v_period;
+
+	pconf->lcd_basic.h_period_min = pconf->lcd_basic.h_period;
+	pconf->lcd_basic.h_period_max = pconf->lcd_basic.h_period;
+	pconf->lcd_basic.v_period_min = pconf->lcd_basic.v_period;
+	pconf->lcd_basic.v_period_max = pconf->lcd_basic.v_period;
+	pconf->lcd_basic.lcd_clk_min = 0;
+	pconf->lcd_basic.lcd_clk_max = 0;
+
 	pconf->lcd_timing.hsync_width = ext_lcd->hsync_width;
 	pconf->lcd_timing.hsync_bp    = ext_lcd->hsync_bp;
 	pconf->lcd_timing.hsync_pol    = ext_lcd->hsync_pol;
@@ -462,8 +557,6 @@ static int lcd_config_load_from_bsp(struct lcd_config_s *pconf)
 		pconf->lcd_control.vbyone_config->color_fmt  = ext_lcd->lcd_spc_val3;
 		pconf->lcd_control.vbyone_config->phy_vswing = VX1_PHY_VSWING_DFT;
 		pconf->lcd_control.vbyone_config->phy_preem  = VX1_PHY_PREEM_DFT;
-	} else if (pconf->lcd_basic.lcd_type == LCD_TTL) {
-		LCDERR("unsupport lcd_type: %d\n", pconf->lcd_basic.lcd_type);
 	} else if (pconf->lcd_basic.lcd_type == LCD_LVDS) {
 		pconf->lcd_control.lvds_config->lvds_repack = ext_lcd->lcd_spc_val0;
 		pconf->lcd_control.lvds_config->dual_port   = ext_lcd->lcd_spc_val1;
@@ -471,6 +564,10 @@ static int lcd_config_load_from_bsp(struct lcd_config_s *pconf)
 		pconf->lcd_control.lvds_config->port_swap   = ext_lcd->lcd_spc_val3;
 		pconf->lcd_control.lvds_config->phy_vswing = LVDS_PHY_VSWING_DFT;
 		pconf->lcd_control.lvds_config->phy_preem  = LVDS_PHY_PREEM_DFT;
+		pconf->lcd_control.lvds_config->phy_clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
+		pconf->lcd_control.lvds_config->phy_clk_preem  = LVDS_PHY_CLK_PREEM_DFT;
+	} else if (pconf->lcd_basic.lcd_type == LCD_TTL) {
+		LCDERR("unsupport lcd_type: %d\n", pconf->lcd_basic.lcd_type);
 	}
 
 	i = 0;
@@ -599,10 +696,20 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 	p += LCD_UKEY_CLK_AUTO_GEN;
 	/* dummy pointer */
 	p += LCD_UKEY_PCLK;
-	p += LCD_UKEY_CUST_VAL_4;
-	p += LCD_UKEY_CUST_VAL_5;
-	p += LCD_UKEY_CUST_VAL_6;
-	p += LCD_UKEY_CUST_VAL_7;
+	pconf->lcd_basic.h_period_min = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_H_PERIOD_MIN;
+	pconf->lcd_basic.h_period_max = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_H_PERIOD_MAX;
+	pconf->lcd_basic.v_period_min = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_V_PERIOD_MIN;
+	pconf->lcd_basic.v_period_max = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_V_PERIOD_MAX;
+	pconf->lcd_basic.lcd_clk_min = (*p | ((*(p + 1)) << 8) |
+		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
+	p += LCD_UKEY_PCLK_MIN;
+	pconf->lcd_basic.lcd_clk_max = (*p | ((*(p + 1)) << 8) |
+		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
+	/* dummy pointer */
 	p += LCD_UKEY_CUST_VAL_8;
 	p += LCD_UKEY_CUST_VAL_9;
 
@@ -636,11 +743,13 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		p += LCD_UKEY_IF_ATTR_3;
 		pconf->lcd_control.lvds_config->phy_vswing = (*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_4;
-		pconf->lcd_control.lvds_config->phy_vswing = (*p | ((*(p + 1)) << 8)) & 0xff;
+		pconf->lcd_control.lvds_config->phy_preem = (*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_5;
-		/* dummy pointer */
+		pconf->lcd_control.lvds_config->phy_clk_vswing = (*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_6;
+		pconf->lcd_control.lvds_config->phy_clk_preem = (*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_7;
+		/* dummy pointer */
 		p += LCD_UKEY_IF_ATTR_8;
 		p += LCD_UKEY_IF_ATTR_9;
 	} else {
@@ -735,6 +844,9 @@ static void lcd_config_init(struct lcd_config_s *pconf)
 
 	clk = pconf->lcd_basic.h_period * pconf->lcd_basic.v_period * 60;
 	pconf->lcd_timing.lcd_clk = clk;
+	pconf->lcd_timing.lcd_clk_dft = pconf->lcd_timing.lcd_clk;
+	pconf->lcd_timing.h_period_dft = pconf->lcd_basic.h_period;
+	pconf->lcd_timing.v_period_dft = pconf->lcd_basic.v_period;
 	pconf->lcd_timing.sync_duration_num = 60;
 	pconf->lcd_timing.sync_duration_den = 1;
 
@@ -746,14 +858,14 @@ static void lcd_config_init(struct lcd_config_s *pconf)
 static int lcd_config_check(char *mode)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	int vmode;
+	int lcd_vmode;
 
-	vmode = check_lcd_output_mode(lcd_drv->lcd_config, mode);
-	if (vmode >= LCD_OUTPUT_MODE_MAX)
+	lcd_vmode = check_lcd_output_mode(lcd_drv->lcd_config, mode);
+	if (lcd_vmode >= LCD_VMODE_MAX)
 		return -1;
 
-	lcd_drv->lcd_config->lcd_timing.sync_duration_num = lcd_info[vmode].sync_duration_num;
-	lcd_drv->lcd_config->lcd_timing.sync_duration_den = lcd_info[vmode].sync_duration_den;
+	lcd_drv->lcd_config->lcd_timing.sync_duration_num = lcd_vmode_info[lcd_vmode].frame_rate;
+	lcd_drv->lcd_config->lcd_timing.sync_duration_den = 1;
 	/* update clk & timing config */
 	lcd_vmode_change(lcd_drv->lcd_config);
 	lcd_tv_config_update(lcd_drv->lcd_config);
diff --git a/drivers/display/lcd/lcd_tv/lcd_tv.h b/drivers/display/lcd/lcd_tv/lcd_tv.h
index c09ec91..8bc7ff8 100644
--- a/drivers/display/lcd/lcd_tv/lcd_tv.h
+++ b/drivers/display/lcd/lcd_tv/lcd_tv.h
@@ -25,7 +25,7 @@
 //**********************************
 #define LCD_DRV_TYPE      "tv"
 
-#define LCD_DRV_VERSION    "20160415"
+#define LCD_DRV_VERSION    "20160630"
 //**********************************
 
 extern void lcd_tv_config_update(struct lcd_config_s *pconf);
diff --git a/drivers/display/osd/osd_fb.c b/drivers/display/osd/osd_fb.c
index 1d3dae1..e6e756f 100644
--- a/drivers/display/osd/osd_fb.c
+++ b/drivers/display/osd/osd_fb.c
@@ -326,6 +326,96 @@ void *video_hw_init(void)
 	return (void *)&fb_gdev;
 }
 
+int rle8_decode(uchar *ptr, bmp_image_t *bmap_rle8, ulong width_bmp, ulong height_bmp) {
+	uchar a;
+	uchar cnt, runlen;
+	int i;
+	int decode;
+	int pixels;
+	uchar *pic;
+	int limit;
+
+	a = 0xFF;
+	decode = 1;
+	pixels = 0;
+	limit = width_bmp * height_bmp;
+	pic = (uchar *)bmap_rle8 + le32_to_cpu(bmap_rle8->header.data_offset);
+
+	while (decode) {
+		switch (pic[0]) {
+		case 0:
+			switch (pic[1]) {
+			case 0:
+				/* end of row */
+				pic += 2;
+				continue;
+			case 1:
+				/* end of bmp */
+				decode = 0;
+				break;
+			case 2:
+				/* 00 02 mode */
+				pic += 4;
+				break;
+
+			default:
+				/* 00 (03~FF) mode */
+				cnt = pic[1];
+				runlen = cnt;
+				pixels += cnt;
+				if (pixels > limit)
+				{
+					osd_loge("Error: Too much encoded pixel data, validate your bitmap\n");
+					decode = 0;
+					return -1;
+				}
+				pic += 2;
+				for (i = 0; i < cnt; i++) {
+
+					*ptr = bmap_rle8->color_table[*pic].blue;
+					ptr += 1;
+					*ptr = bmap_rle8->color_table[*pic].green;
+					ptr += 1;
+					*ptr = bmap_rle8->color_table[*pic].red;
+					ptr += 1;
+					*ptr = a;
+					ptr += 1;
+					pic += 1;
+				}
+				if (runlen & 1)
+					pic += 1;	/* 0 padding if length is odd */
+				break;
+			}
+			break;
+
+		default:
+			/* normal mode */
+			cnt = pic[0];
+			runlen = cnt;
+			pixels += cnt;
+			if (pixels > limit) {
+				osd_loge("Error: Too much encoded pixel data, validate your bitmap\n");
+				return -1;
+			}
+			pic += 1;
+			for (i = 0; i < cnt; i++) {
+
+				*ptr = bmap_rle8->color_table[*pic].blue;
+				ptr += 1;
+				*ptr = bmap_rle8->color_table[*pic].green;
+				ptr += 1;
+				*ptr = bmap_rle8->color_table[*pic].red;
+				ptr += 1;
+				*ptr = a;
+				ptr += 1;
+			}
+			pic += 1;
+			break;
+		}
+	}
+	return (0);
+}
+
 int video_display_bitmap(ulong bmp_image, int x, int y)
 {
 	vidinfo_t *info = NULL;
@@ -368,7 +458,7 @@ int video_display_bitmap(ulong bmp_image, int x, int y)
 	height = le32_to_cpu(bmp->header.height);
 	bmp_bpix = le16_to_cpu(bmp->header.bit_count);
 	colors = 1 << bmp_bpix;
-
+	uchar *buffer_rgb = NULL;
 	bpix = NBITS(info->vl_bpix);
 
 	if ((x == -1) && (y == -1)) {
@@ -383,18 +473,18 @@ int video_display_bitmap(ulong bmp_image, int x, int y)
 
 	if ((bpix != 1) && (bpix != 8) && (bpix != 16) && (bpix != 24) &&
 	    (bpix != 32)) {
-		osd_loge("%d bit/pixel mode, but BMP has %d bit/pixel\n",
+		osd_loge("%d bit/pixel mode1, but BMP has %d bit/pixel\n",
 			 bpix, bmp_bpix);
 		return 1;
 	}
 
 	/* We support displaying 8bpp BMPs on 16bpp LCDs */
-	if (bpix != bmp_bpix && (bmp_bpix != 8 || bpix != 16)) {
-		osd_loge("%d bit/pixel mode, but BMP has %d bit/pixel\n",
+	/*if (bpix != bmp_bpix && (bmp_bpix != 8 || bpix != 16)) {
+		osd_loge("%d bit/pixel mode2, but BMP has %d bit/pixel\n",
 			 bpix,
 			 le16_to_cpu(bmp->header.bit_count));
 		return 1;
-	}
+	}*/
 
 	osd_logd("Display-bmp: %d x %d  with %d colors\n",
 		 (int)width, (int)height, (int)colors);
@@ -436,25 +526,44 @@ int video_display_bitmap(ulong bmp_image, int x, int y)
 
 	osd_logd("fb=0x%p; bmap=0x%p, width=%ld, height= %ld, lcd_line_length=%d, padded_line=%d\n",
 		 fb, bmap, width, height, lcd_line_length, padded_line);
+
+	if (bmp_bpix == 8) {
+		/* decode of RLE8 */
+		buffer_rgb = (uchar *)malloc(height * width * 4 * sizeof(uchar) + 1);
+		if (buffer_rgb == NULL) {
+			printf("Error:fail to malloc the memory!");
+		}
+	}
+	uchar *ptr_rgb = buffer_rgb;
 	switch (bmp_bpix) {
 	case 8:
 		if (bpix != 16)
 			byte_width = width;
 		else
 			byte_width = width * 2;
-
+		rle8_decode(ptr_rgb, bmp, width, height);
 		for (i = 0; i < height; ++i) {
 			for (j = 0; j < width; j++) {
-				if (bpix != 16)
-					*(fb++) = *(bmap++);
+				if (bpix != 16) {
+					*(fb++) = *buffer_rgb;
+					buffer_rgb += 1;
+					*(fb++) = *buffer_rgb;
+					buffer_rgb += 1;
+					*(fb++) = *buffer_rgb;
+					buffer_rgb += 1;
+					*(fb++) = *buffer_rgb;
+					buffer_rgb += 1;
+				}
 				else {
-					*(uint16_t *)fb = cmap_base[*(bmap++)];
+					*(uint16_t *)fb = cmap_base[*buffer_rgb++];
 					fb += sizeof(uint16_t) / sizeof(*fb);
 				}
 			}
-			bmap += (width - padded_line);
-			fb   -= (byte_width + lcd_line_length);
+			buffer_rgb += (padded_line - width);
+			fb -= (byte_width * 4 + lcd_line_length);
 		}
+		buffer_rgb -= width*height*4;
+		free(buffer_rgb);
 		break;
 	case 16:
 		for (i = 0; i < height; ++i) {
@@ -496,6 +605,9 @@ int video_display_bitmap(ulong bmp_image, int x, int y)
 		osd_loge("error: gdev.bpp %d, but bmp.bpp %d\n", fb_gdev.gdfBytesPP, bmp_bpix);
 		return (-1);
 	}
+	buffer_rgb = NULL;
+	ptr_rgb = NULL;
+
 #if 0
 	flush_cache((unsigned long)info->vd_base,
 		    info->vl_col * info->vl_row * info->vl_bpix / 8);
@@ -504,7 +616,6 @@ int video_display_bitmap(ulong bmp_image, int x, int y)
 		    pheight * pwidth * info->vl_bpix / 8);
 
 #endif
-
 	return (0);
 }
 
diff --git a/drivers/display/osd/osd_hw.c b/drivers/display/osd/osd_hw.c
index 08d52ac..d5e0637 100644
--- a/drivers/display/osd/osd_hw.c
+++ b/drivers/display/osd/osd_hw.c
@@ -1600,10 +1600,11 @@ static   void  osd1_update_color_mode(void)
 		if (!osd_hw.rotate[OSD1].on_off)
 			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
 		data32 |= osd_hw.color_info[OSD1]->hw_colormat << 2;
-	if (get_cpu_id().family_id < MESON_CPU_MAJOR_ID_GXTVBB) {
-		if (osd_hw.color_info[OSD1]->color_index < COLOR_INDEX_YUV_422)
-			data32 |= 1 << 7; /* yuv enable */
-	}
+		if (get_cpu_id().family_id < MESON_CPU_MAJOR_ID_GXTVBB) {
+			if (osd_hw.color_info[OSD1]->color_index
+				< COLOR_INDEX_YUV_422)
+				data32 |= 1 << 7; /* yuv enable */
+		}
 		/* osd_blk_mode */
 		data32 |=  osd_hw.color_info[OSD1]->hw_blkmode << 8;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, data32);
@@ -1622,10 +1623,11 @@ static void osd2_update_color_mode(void)
 		if (!osd_hw.rotate[OSD2].on_off)
 			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
 		data32 |= osd_hw.color_info[OSD2]->hw_colormat << 2;
-	if (get_cpu_id().family_id != MESON_CPU_MAJOR_ID_GXTVBB) {
-		if (osd_hw.color_info[OSD2]->color_index < COLOR_INDEX_YUV_422)
-			data32 |= 1 << 7; /* yuv enable */
-	}
+		if (get_cpu_id().family_id != MESON_CPU_MAJOR_ID_GXTVBB) {
+			if (osd_hw.color_info[OSD2]->color_index
+				< COLOR_INDEX_YUV_422)
+				data32 |= 1 << 7; /* yuv enable */
+		}
 		/* osd_blk_mode */
 		data32 |=  osd_hw.color_info[OSD2]->hw_blkmode << 8;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0, data32);
@@ -2365,7 +2367,13 @@ void osd_init_hw(void)
 		osd_hw.free_scale_data[OSD2].y_end = 0;
 		osd_hw.free_scale_mode[OSD1] = 1;
 		osd_hw.free_scale_mode[OSD2] = 1;
-		osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00808000);
+		if (get_cpu_id().family_id == MESON_CPU_MAJOR_ID_GXM)
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00202000);
+		else if (get_cpu_id().family_id ==
+			MESON_CPU_MAJOR_ID_GXTVBB)
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0xff);
+		else
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00808000);
 	} else {
 		osd_hw.free_scale_mode[OSD1] = 0;
 		osd_hw.free_scale_mode[OSD2] = 0;
diff --git a/drivers/display/vout/cvbs.c b/drivers/display/vout/cvbs.c
index 73e3ce4..3913a4c 100644
--- a/drivers/display/vout/cvbs.c
+++ b/drivers/display/vout/cvbs.c
@@ -144,12 +144,23 @@ static int check_cpu_type(unsigned int cpu_type)
 	return (cvbs_read_cbus(ASSIST_HW_REV)==cpu_type);
 }
 
+static bool inline is_equal_after_meson_cpu(unsigned int id)
+{
+	return (cpu_id.family_id >= id)?1:0;
+}
+
 static bool inline is_meson_gxl_cpu(void)
 {
 	return (cpu_id.family_id == MESON_CPU_MAJOR_ID_GXL)?
 		1:0;
 }
 
+static bool inline is_meson_txl_cpu(void)
+{
+	return (cpu_id.family_id == MESON_CPU_MAJOR_ID_TXL)?
+		1:0;
+}
+
 static bool inline is_meson_gxm_cpu(void)
 {
 	return (cpu_id.family_id == MESON_CPU_MAJOR_ID_GXM)?
@@ -214,15 +225,26 @@ int cvbs_set_vdac(int status)
 	{
 	case 0:// close vdac
 		cvbs_write_hiu(HHI_VDAC_CNTL0, 0);
-		cvbs_write_hiu(HHI_VDAC_CNTL1, 8);
+		if (is_meson_txl_cpu())
+			cvbs_write_hiu(HHI_VDAC_CNTL1, 0);
+		else
+			cvbs_write_hiu(HHI_VDAC_CNTL1, 8);
 		break;
 	case 1:// from enci to vdac
 		cvbs_set_vcbus_bits(VENC_VDAC_DACSEL0, 5, 1, 0);
-		if (is_meson_gxl_cpu() || is_meson_gxm_cpu())
-			cvbs_write_hiu(HHI_VDAC_CNTL0, 0xf0001);
+		if (is_equal_after_meson_cpu(MESON_CPU_MAJOR_ID_GXL)) {
+			if (is_meson_txl_cpu())
+				cvbs_write_hiu(HHI_VDAC_CNTL0, 0xb0201);
+			else
+				cvbs_write_hiu(HHI_VDAC_CNTL0, 0xb0001);
+		}
 		else
 			cvbs_write_hiu(HHI_VDAC_CNTL0, 1);
-		cvbs_write_hiu(HHI_VDAC_CNTL1, 0);
+
+		if (is_meson_txl_cpu())
+			cvbs_write_hiu(HHI_VDAC_CNTL1, 8);
+		else
+			cvbs_write_hiu(HHI_VDAC_CNTL1, 0);
 		break;
 	case 2:// from atv to vdac
 		cvbs_set_vcbus_bits(VENC_VDAC_DACSEL0, 5, 1, 1);
@@ -444,8 +466,7 @@ static int cvbs_config_clock(void)
 		cvbs_config_hdmipll_gxb();
 	else if (check_cpu_type(MESON_CPU_MAJOR_ID_GXTVBB))
 		cvbs_config_hdmipll_gxtvbb();
-	else if (check_cpu_type(MESON_CPU_MAJOR_ID_GXL) ||
-		is_meson_gxm_cpu())
+	else if (is_equal_after_meson_cpu(MESON_CPU_MAJOR_ID_GXL))
 		cvbs_config_hdmipll_gxl();
 
 	cvbs_set_hiu_bits(HHI_VIID_CLK_CNTL, 0, VCLK2_EN, 1);
@@ -558,19 +579,20 @@ static void cvbs_performance_enhancement(int mode)
 		index = (index >= max) ? 0 : index;
 		s = tvregs_576cvbs_performance_gxtvbb[index];
 		type = 5;
-	} else if (is_meson_gxl_package_905X() ||
-		is_meson_gxm_cpu()) {
-		max = sizeof(tvregs_576cvbs_performance_905x)
-			/ sizeof(struct reg_s *);
-		index = (index >= max) ? 0 : index;
-		s = tvregs_576cvbs_performance_905x[index];
-		type = 6;
-	} else if (is_meson_gxl_package_905L()) {
-		max = sizeof(tvregs_576cvbs_performance_905l)
-			/ sizeof(struct reg_s *);
-		index = (index >= max) ? 0 : index;
-		s = tvregs_576cvbs_performance_905l[index];
-		type = 7;
+	} else if (is_equal_after_meson_cpu(MESON_CPU_MAJOR_ID_GXL)) {
+		if (is_meson_gxl_package_905L()) {
+			max = sizeof(tvregs_576cvbs_performance_905l)
+				/ sizeof(struct reg_s *);
+			index = (index >= max) ? 0 : index;
+			s = tvregs_576cvbs_performance_905l[index];
+			type = 7;
+		} else {
+			max = sizeof(tvregs_576cvbs_performance_905x)
+				/ sizeof(struct reg_s *);
+			index = (index >= max) ? 0 : index;
+			s = tvregs_576cvbs_performance_905x[index];
+			type = 6;
+		}
 	}
 
 	printf("cvbs performance type = %d, table = %d\n", type, index);
diff --git a/drivers/keymanage/key_manage.c b/drivers/keymanage/key_manage.c
index 3f4db87..88d2b32 100644
--- a/drivers/keymanage/key_manage.c
+++ b/drivers/keymanage/key_manage.c
@@ -59,8 +59,8 @@ static int km_get_user_key_format(const char* srcKeyName, int* key_type)
             ret = !strcmp(srcKeyName, "mac") || !strcmp(srcKeyName, "mac_bt") || !strcmp(srcKeyName, "mac_wifi");
             if (ret) { srcKeyType = KM_USER_KEY_TYPE_MAC; break; }
 
-            ret = !strcmp(srcKeyName, "hdcp") ;
-            if (ret) { srcKeyType = KM_USER_KEY_TYPE_SHA1; break; }
+            /*ret = !strcmp(srcKeyName, "hdcp") ;*/
+            /*if (ret) { srcKeyType = KM_USER_KEY_TYPE_SHA1; break; }*/
 
             ret = !strcmp(srcKeyName, "hdcp2") ;
             if (ret) { srcKeyType = KM_USER_KEY_TYPE_HDCP2; break; }
diff --git a/drivers/keymanage/key_manage.h b/drivers/keymanage/key_manage.h
index e7577fd..69d9145 100644
--- a/drivers/keymanage/key_manage.h
+++ b/drivers/keymanage/key_manage.h
@@ -39,6 +39,7 @@ enum key_manager_type_e{
 struct key_item_t{
     char name[KEY_UNIFY_NAME_LEN];
     char keyType[KEY_UNIFY_TYPE_LEN_MAX + 1];//mac/sha1/hdcp2/normal
+    char encType[KEY_UNIFY_TYPE_LEN_MAX + 1];//mac/sha1/hdcp2/normal
     int id;
     unsigned int dev; //key save in device //efuse,
     unsigned int datFmt;  //data format
diff --git a/drivers/keymanage/key_manage_i.h b/drivers/keymanage/key_manage_i.h
index 9bac8e6..19e9397 100644
--- a/drivers/keymanage/key_manage_i.h
+++ b/drivers/keymanage/key_manage_i.h
@@ -32,6 +32,7 @@ int keymanage_dts_parse(const void* dt_addr);
 enum key_manager_df_e keymanage_dts_get_key_fmt(const char *keyname);
 enum key_manager_dev_e keymanage_dts_get_key_device(const char *keyname);
 const char* keymanage_dts_get_key_type(const char* keyname);
+const char* keymanage_dts_get_enc_type(const char* keyname);
 char unifykey_get_efuse_version(void);
 
 int keymanage_efuse_init(const char *buf, int len);
diff --git a/drivers/keymanage/km_dts.c b/drivers/keymanage/km_dts.c
index 5b703b1..cca260d 100644
--- a/drivers/keymanage/km_dts.c
+++ b/drivers/keymanage/km_dts.c
@@ -93,6 +93,23 @@ enum key_manager_dev_e keymanage_dts_get_key_device(const char *keyname)
 	return key_manage->dev;
 }
 
+const char* keymanage_dts_get_enc_type(const char* keyname)
+{
+	struct key_item_t *key_manage;
+
+    if (!unify_key_info.key_flag) {
+		KM_ERR("/unify not parsed yet!\n");
+		return NULL;
+	}
+	key_manage = unifykey_find_item_by_name(keyname);
+	if (key_manage == NULL) {
+		KM_ERR("%s key name is not exist\n",keyname);
+		return NULL;
+	}
+
+	return key_manage->encType;
+}
+
 const char* keymanage_dts_get_key_type(const char* keyname)
 {
 	struct key_item_t *key_manage;
@@ -134,6 +151,16 @@ static int unifykey_item_dt_parse(const void* dt_addr,int nodeoffset,int id,char
 
 	temp_item = unifykey_item + id;
 
+	propdata = (char*)fdt_getprop(dt_addr, nodeoffset, "key-encrypt", NULL);
+	if (propdata) {
+		count = strlen(propdata);
+        if ( count > KEY_UNIFY_TYPE_LEN_MAX ) {
+			KM_ERR("key-encrypt [%s] too long\n", propdata);
+			return __LINE__;
+		}
+		memcpy(temp_item->encType, propdata, count);
+	}
+
 	propdata = (char*)fdt_getprop(dt_addr, nodeoffset, "key-name",NULL);
 	if (!propdata) {
 		printf("%s get key-name fail,%s:%d\n",item_path,__func__,__LINE__);
diff --git a/drivers/keymanage/km_secure_key.c b/drivers/keymanage/km_secure_key.c
index 66914fe..6806c4e 100644
--- a/drivers/keymanage/km_secure_key.c
+++ b/drivers/keymanage/km_secure_key.c
@@ -27,7 +27,9 @@ int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned i
 {
     int ret = 0;
     uint8_t origSum[SHA256_SUM_LEN];
-    const int isSecure =  ( KEY_M_SECURE_KEY == keymanage_dts_get_key_device(keyname) ) ;
+    const int isSecure =  ( KEY_M_SECURE_KEY == keymanage_dts_get_key_device(keyname) ) ? 1 : 0;
+    const int isEncrypt= strlen(keymanage_dts_get_enc_type(keyname)) ? 1 : 0;
+    const unsigned int keyAttr = ( isSecure << 0 ) | ( isEncrypt << 8 );
     ssize_t writenLen = 0;
 
     if (isSecure)
@@ -38,8 +40,10 @@ int keymanage_secukey_write(const char *keyname, const void* keydata, unsigned i
         sha256_finish(&ctx, origSum);
     }
 
+    KM_MSG("isEncrypt=%s\n", keymanage_dts_get_enc_type(keyname));
     KM_DBG("%s, keyname=%s, keydata=%p, datalen=%d, isSecure=%d\n", __func__, keyname, keydata, datalen, isSecure);
-    writenLen = amlkey_write((uint8_t*)keyname, (uint8_t*)keydata, datalen, isSecure);
+    KM_MSG("keyAttr is 0x%08X\n", keyAttr);
+    writenLen = amlkey_write((uint8_t*)keyname, (uint8_t*)keydata, datalen, keyAttr);
     if (writenLen != datalen) {
         KM_ERR("Want to write %u bytes, but only %zd Bytes\n", datalen, writenLen);
         return __LINE__;
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 4b421e9..1a95954 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -523,6 +523,30 @@ static int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 
 }
 
+u8 ext_csd_w[] = {191, 187, 185, 183, 179, 178, 177, 175,
+					173, 171, 169, 167, 165, 164, 163, 162,
+					161, 156, 155, 143, 140, 136, 134, 133,
+					132, 131, 62, 59, 56, 52, 37, 34,
+					33, 32, 31, 30, 29, 22, 17, 16, 15};
+int mmc_set_ext_csd(struct mmc *mmc, u8 index, u8 value)
+{
+	int ret = SWITCH_ERR, i;
+
+	for (i = 0; i < sizeof(ext_csd_w); i++) {
+		if (ext_csd_w[i] == index)
+			break;
+	}
+	if (i != sizeof(ext_csd_w))
+		ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, index, value);
+
+	return ret;
+}
+
+int mmc_get_ext_csd(struct mmc *mmc, u8 *ext_csd)
+{
+	return mmc_send_ext_csd(mmc, ext_csd);
+}
+
 static int mmc_change_freq(struct mmc *mmc)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
@@ -1711,10 +1735,12 @@ int mmc_set_rst_n_function(struct mmc *mmc, u8 enable)
 }
 #endif
 
-int mmc_key_read(unsigned char *buf, unsigned int size)
+int mmc_key_read(unsigned char *buf, unsigned int size, uint32_t *actual_lenth)
 {
 	ulong start, start_blk, blkcnt, ret;
 	unsigned char *temp_buf = buf;
+
+	*actual_lenth =  0x40000;/*key size is 256KB*/
 	start = EMMCKEY_RESERVE_OFFSET + MMC_RESERVED_OFFSET;
 	start_blk = (start / MMC_BLOCK_SIZE);
 	blkcnt = (size / MMC_BLOCK_SIZE);
@@ -1731,7 +1757,7 @@ int mmc_key_read(unsigned char *buf, unsigned int size)
 
 extern ulong mmc_bwrite(int dev_num, lbaint_t start,
 				lbaint_t blkcnt, const void *src);
-int mmc_key_write(unsigned char *buf, unsigned int size)
+int mmc_key_write(unsigned char *buf, unsigned int size, uint32_t *actual_lenth)
 {
 	ulong start, start_blk, blkcnt, ret;
 	unsigned char * temp_buf = buf;
diff --git a/drivers/mtd/spi/spi_flash_amlogic.c b/drivers/mtd/spi/spi_flash_amlogic.c
index f7cfa35..11354c2 100644
--- a/drivers/mtd/spi/spi_flash_amlogic.c
+++ b/drivers/mtd/spi/spi_flash_amlogic.c
@@ -787,7 +787,12 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		*P_PAD_PULL_UP_EN_REG2 = 0xffff87ff;
 		*P_PAD_PULL_UP_REG2 = 0xffff8700;
 		// deselect nand/emmc, select spi.
-		*P_PERIPHS_PIN_MUX_7 &= ~((1<<28) | (7<<2) | 1);
+		if (get_cpu_id().family_id <= MESON_CPU_MAJOR_ID_GXM) {
+			*P_PERIPHS_PIN_MUX_7 &= ~((1<<28) | (7<<2) | 1);
+		}
+		else {
+			*P_PERIPHS_PIN_MUX_7 &= ~((1<<31) | (1<<28) | (7<<20));
+		}
 		*P_PERIPHS_PIN_MUX_7 |= 0xf<<10;
 		(*((volatile unsigned *)((volatile uint32_t *)0xc1108c88)))=(0x2aaf7f);
 	}
diff --git a/drivers/nand/dev/amlnf_config.c b/drivers/nand/dev/amlnf_config.c
index b9e8cdb..e0a713e 100644
--- a/drivers/nand/dev/amlnf_config.c
+++ b/drivers/nand/dev/amlnf_config.c
@@ -187,12 +187,17 @@ int amlnand_get_partition_table(struct amlnand_chip *aml_chip)
 	/* show_partition_table(); */
 	//memcpy(amlnand_config, part_table, config_size);
 	/* do not use memcpy avoid further change */
+	aml_chip->h_cache_dev = 0;
 	for (i = 0; i < MAX_PART_NUM; i++) {
 		memcpy(amlnand_config[i].name, part_table[i].name, MAX_PART_NAME_LEN);
 		amlnand_config[i].size = part_table[i].size;
 		amlnand_config[i].offset = part_table[i].offset;
 		amlnand_config[i].mask_flags = part_table[i].mask_flags;
 
+		if (amlnand_config[i].mask_flags == STORE_CACHE) {
+			aml_chip->h_cache_dev = 1;/*have cache dev*/
+			aml_nand_msg("cache !!!");
+		}
 		if (part_table[i].size == NAND_PART_SIZE_FULL)
 			break;
 	}
diff --git a/drivers/nand/dev/amlnf_ctrl.c b/drivers/nand/dev/amlnf_ctrl.c
index 670adf0..d28838c 100644
--- a/drivers/nand/dev/amlnf_ctrl.c
+++ b/drivers/nand/dev/amlnf_ctrl.c
@@ -583,12 +583,7 @@ int aml_sys_info_init(struct amlnand_chip *aml_chip)
 	u32 buf_size = 0;
 	int ret = 0;
 
-	NAND_LINE
-	if (CONFIG_SECURE_SIZE > CONFIG_KEYSIZE)
-		buf_size = CONFIG_SECURE_SIZE;
-	else
-		buf_size = CONFIG_KEYSIZE;
-	NAND_LINE
+	buf_size = 0x40000; /*rsv item max size is 256KB*/
 	buf = aml_nand_malloc(buf_size);
 	if (!buf)
 		aml_nand_msg("aml_sys_info_init : malloc failed");
@@ -645,7 +640,7 @@ int aml_sys_info_init(struct amlnand_chip *aml_chip)
 			(u8 *)(&(aml_chip->nand_key)),
 			buf,
 			(u8 *)KEY_INFO_HEAD_MAGIC,
-			CONFIG_KEYSIZE);
+			aml_chip->keysize);
 		NAND_LINE
 		if (ret < 0) {
 			aml_nand_msg("nand save default key failed");
diff --git a/drivers/nand/dev/amlnf_dev.c b/drivers/nand/dev/amlnf_dev.c
index b0146a0..9194d52 100644
--- a/drivers/nand/dev/amlnf_dev.c
+++ b/drivers/nand/dev/amlnf_dev.c
@@ -243,6 +243,9 @@ static ssize_t nand_part_table_get(struct class *class,
 	struct dev_para *dev_paramt = NULL;
 	struct partitions *part_table = NULL;
 	int i = 0, j = 0, k = 0, m = 0, tmp_num = 0;
+	int device_num;
+
+	device_num = (aml_chip->h_cache_dev)? 3 : 2;
 
 	list_for_each_entry(phydev, &nphy_dev_list, list) {
 		if ((phydev != NULL)
@@ -267,7 +270,7 @@ static ssize_t nand_part_table_get(struct class *class,
 		tmp_num = i;
 	}
 
-	for (; i < PHY_DEV_NUM+1; i++) {
+	for (; i < device_num + 1; i++) {
 		dev_paramt = &config->dev_para[i];
 		if ((!strncmp((char *)dev_paramt->name,
 				NAND_CODE_NAME,
@@ -296,7 +299,7 @@ static ssize_t nand_part_table_get(struct class *class,
 	}
 
 	i = tmp_num;
-	for (; i < PHY_DEV_NUM+1; i++) {
+	for (; i < device_num + 1; i++) {
 		dev_paramt = &config->dev_para[i];
 		/*
 		aml_nand_msg("cache : dev_paramt name %s ",dev_paramt->name);
@@ -329,7 +332,7 @@ static ssize_t nand_part_table_get(struct class *class,
 	}
 
 	i = tmp_num;
-	for (; i < PHY_DEV_NUM+1; i++) {
+	for (; i < device_num + 1; i++) {
 		dev_paramt = &config->dev_para[i];
 		/*
 		aml_nand_msg("dev_paramt name %s ",dev_paramt->name);
diff --git a/drivers/nand/dev/amlnf_dtb.c b/drivers/nand/dev/amlnf_dtb.c
index ac5a8eb..78cff2d 100644
--- a/drivers/nand/dev/amlnf_dtb.c
+++ b/drivers/nand/dev/amlnf_dtb.c
@@ -28,24 +28,25 @@ int amlnf_dtb_save(u8 *buf, int len)
 		return -EFAULT;
 	}
 
-	if (len > CONFIG_DTB_SIZE) {
-		aml_nand_msg("%s: length too much", __func__);
-		return -EFAULT;
+	if (len > aml_chip_dtb->dtbsize) {
+		aml_nand_msg("warnning!!! %s: length too much", __func__);
+		len = aml_chip_dtb->dtbsize;
+		/*return -EFAULT;*/
 	}
-	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	dtb_buf = aml_nand_malloc(aml_chip_dtb->dtbsize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("%s: malloc failed", __func__);
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0, aml_chip_dtb->dtbsize);
 	memcpy(dtb_buf, buf, len);
 
 	ret = amlnand_save_info_by_name(aml_chip_dtb,
 		(u8 *)&(aml_chip_dtb->amlnf_dtb),
 		dtb_buf,
 		(u8 *)DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: nand dtd save failed", __func__);
 		ret = -EFAULT;
@@ -84,9 +85,10 @@ int amlnf_dtb_read(u8 *buf, int len)
 
 	aml_nand_msg("%s: ####", __func__);
 
-	if (len > CONFIG_DTB_SIZE) {
-		aml_nand_msg("%s dtd length too much", __func__);
-		return -EFAULT;
+	if (len > aml_chip_dtb->dtbsize) {
+		aml_nand_msg("warnning!!! %s dtd length too much", __func__);
+		len = aml_chip_dtb->dtbsize;
+		/*return -EFAULT;*/
 	}
 	if (aml_chip_dtb == NULL) {
 		memset(buf, 0x0, len);
@@ -100,19 +102,19 @@ int amlnf_dtb_read(u8 *buf, int len)
 		return 0;
 	}
 
-	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	dtb_buf = aml_nand_malloc(aml_chip_dtb->dtbsize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("%s: malloc failed", __func__);
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0, aml_chip_dtb->dtbsize);
 
 	ret = amlnand_read_info_by_name(aml_chip_dtb,
 		(u8 *)&(aml_chip_dtb->amlnf_dtb),
 		(u8 *)dtb_buf,
 		(u8 *)DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("dtb error,%s", __func__);
 		ret = -EFAULT;
@@ -146,20 +148,20 @@ ssize_t dtb_store(struct class *class, struct class_attribute *attr,
 	u8 *dtb_ptr = NULL;
 	aml_nand_dbg("dtb_store : #####");
 
-	dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL);
+	dtb_ptr = kzalloc(aml_chip_dtb->dtbsize, GFP_KERNEL);
 	if (dtb_ptr == NULL) {
 		aml_nand_msg("%s: malloc buf failed ", __func__);
 		return -ENOMEM;
 	}
 	/* fixme, why read back then write? */
-	ret = amlnf_dtb_read(dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_read(dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: read failed", __func__);
 		kfree(dtb_ptr);
 		return -EFAULT;
 	}
 
-	ret = amlnf_dtb_save(dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_save(dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: save failed", __func__);
 		kfree(dtb_ptr);
@@ -187,31 +189,30 @@ ssize_t dtb_read(struct file *file,
 	ssize_t read_size = 0;
 	int ret = 0;
 
-	if (*ppos == CONFIG_DTB_SIZE)
+	if (*ppos == aml_chip_dtb->dtbsize)
 		return 0;
 
-	if (*ppos >= CONFIG_DTB_SIZE) {
+	if (*ppos >= aml_chip_dtb->dtbsize) {
 		aml_nand_msg("%s:data access out of space!", __func__);
 		return -EFAULT;
 	}
 
-	/* dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL); */
-	dtb_ptr = vmalloc(CONFIG_DTB_SIZE + flash->pagesize);
+	dtb_ptr = vmalloc(aml_chip_dtb->dtbsize + flash->pagesize);
 	if (dtb_ptr == NULL) {
 		aml_nand_msg("%s: malloc buf failed ", __func__);
 		return -ENOMEM;
 	}
 
 	amlnand_get_device(aml_chip_dtb, CHIP_READING);
-	ret = amlnf_dtb_read((u8 *)dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_read((u8 *)dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: read failed:%d", __func__, ret);
 		ret = -EFAULT;
 		goto exit;
 	}
 
-	if ((*ppos + count) > CONFIG_DTB_SIZE)
-		read_size = CONFIG_DTB_SIZE - *ppos;
+	if ((*ppos + count) > aml_chip_dtb->dtbsize)
+		read_size = aml_chip_dtb->dtbsize - *ppos;
 	else
 		read_size = count;
 
@@ -233,37 +234,36 @@ ssize_t dtb_write(struct file *file,
 	struct nand_flash *flash = &aml_chip_dtb->flash;
 	int ret = 0;
 
-	if (*ppos == CONFIG_DTB_SIZE)
+	if (*ppos == aml_chip_dtb->dtbsize)
 		return 0;
 
-	if (*ppos >= CONFIG_DTB_SIZE) {
+	if (*ppos >= aml_chip_dtb->dtbsize) {
 		aml_nand_msg("%s: data access out of space!", __func__);
 		return -EFAULT;
 	}
 
-	/* dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL); */
-	dtb_ptr = vmalloc(CONFIG_DTB_SIZE + flash->pagesize);
+	dtb_ptr = vmalloc(aml_chip_dtb->dtbsize + flash->pagesize);
 	if (dtb_ptr == NULL) {
 		aml_nand_msg("%s: malloc buf failed ", __func__);
 		return -ENOMEM;
 	}
 	amlnand_get_device(aml_chip_dtb, CHIP_WRITING);
 
-	ret = amlnf_dtb_read((u8 *)dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_read((u8 *)dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: read failed", __func__);
 		ret = -EFAULT;
 		goto exit;
 	}
 
-	if ((*ppos + count) > CONFIG_DTB_SIZE)
-		write_size = CONFIG_DTB_SIZE - *ppos;
+	if ((*ppos + count) > aml_chip_dtb->dtbsize)
+		write_size = aml_chip_dtb->dtbsize - *ppos;
 	else
 		write_size = count;
 
 	ret = copy_from_user((dtb_ptr + *ppos), buf, write_size);
 
-	ret = amlnf_dtb_save(dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_save(dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: read failed", __func__);
 		ret = -EFAULT;
@@ -297,32 +297,25 @@ int amlnf_dtb_init(struct amlnand_chip *aml_chip)
 	u8 *dtb_buf = NULL;
 	aml_chip_dtb = aml_chip;
 
-	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	dtb_buf = aml_nand_malloc(aml_chip_dtb->dtbsize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("nand malloc for dtb_buf failed");
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0x0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0x0, aml_chip_dtb->dtbsize);
 	aml_nand_msg("nand dtb: probe.");
 	ret = amlnand_info_init(aml_chip,
 		(u8 *)&(aml_chip->amlnf_dtb),
 		dtb_buf,
 		(u8 *)DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret < 0) {
 		aml_nand_msg("%s failed", __func__);
 		ret = -1;
 		goto exit_err;
 	}
 
-	/*if(aml_chip->amlnf_dtb.arg_valid == 0){
-		memset(dtb_buf,0x0,CONFIG_DTB_SIZE);
-		ret = amlnf_dtb_save(dtb_buf,CONFIG_DTB_SIZE);
-		if (ret) {
-			aml_nand_msg("amlnf_dtb_save: save env failed");
-		}
-	}*/
 #ifndef AML_NAND_UBOOT
 	aml_nand_dbg("%s: register dtb cdev", __func__);
 	ret = alloc_chrdev_region(&amlnf_dtb_no, 0, 1, DTB_NAME);
@@ -396,19 +389,19 @@ int amlnf_dtb_init_partitions(struct amlnand_chip *aml_chip)
 	u8 *dtb_buf = NULL;
 	aml_chip_dtb = aml_chip;
 
-	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	dtb_buf = aml_nand_malloc(aml_chip_dtb->dtbsize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("nand malloc for dtb_buf failed");
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0x0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0x0, aml_chip_dtb->dtbsize);
 	aml_nand_msg("%s: probe. ", __func__);
 	ret = amlnand_info_init(aml_chip,
 		(u8 *)&(aml_chip->amlnf_dtb),
 		dtb_buf,
 		(u8 *)DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret < 0) {
 		aml_nand_msg("%s failed", __func__);
 		ret = -1;
@@ -452,19 +445,19 @@ int amlnf_detect_dtb_partitions(struct amlnand_chip *aml_chip)
 	struct nand_arg_info test_amlnf_dtb;
 	memset(&test_amlnf_dtb, 0, sizeof(test_amlnf_dtb));
 	dtb_erase_blk = -1;
-	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	dtb_buf = aml_nand_malloc(aml_chip_dtb->dtbsize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("nand malloc for dtb_buf failed");
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0x0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0x0, aml_chip_dtb->dtbsize);
 	test_amlnf_dtb.arg_type = aml_chip->amlnf_dtb.arg_type;
 	ret = amlnand_info_init(aml_chip,
 		(u8 *)&(test_amlnf_dtb),
 		dtb_buf,
 		(u8 *)DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (test_amlnf_dtb.arg_valid == 1) {
 		dtb_erase_blk = test_amlnf_dtb.valid_blk_addr;
 	}
@@ -485,16 +478,16 @@ int aml_nand_update_dtb(struct amlnand_chip *aml_chip, char *dtb_ptr)
 	char *dtb_buf = NULL;
 
 	if (dtb_buf == NULL) {
-		dtb_buf = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL);
+		dtb_buf = kzalloc(aml_chip_dtb->dtbsize, GFP_KERNEL);
 		malloc_flag = 1;
 		if (dtb_buf == NULL)
 			return -ENOMEM;
-		memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+		memset(dtb_buf, 0, aml_chip_dtb->dtbsize);
 		ret = amlnand_read_info_by_name(aml_chip,
 			(u8 *)&(aml_chip->amlnf_dtb),
 			(u8 *)dtb_buf,
 			(u8 *)DTD_INFO_HEAD_MAGIC,
-			CONFIG_DTB_SIZE);
+			aml_chip_dtb->dtbsize);
 		if (ret) {
 			aml_nand_msg("read dtb error,%s\n", __func__);
 			ret = -EFAULT;
@@ -507,7 +500,7 @@ int aml_nand_update_dtb(struct amlnand_chip *aml_chip, char *dtb_ptr)
 		(u8 *)&(aml_chip->amlnf_dtb),
 		(u8 *)dtb_buf,
 		(u8 *)DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret < 0)
 		aml_nand_msg("%s: update failed", __func__);
 exit:
diff --git a/drivers/nand/dev/amlnf_key.c b/drivers/nand/dev/amlnf_key.c
index 67b8f3e..72cd351 100644
--- a/drivers/nand/dev/amlnf_key.c
+++ b/drivers/nand/dev/amlnf_key.c
@@ -6,37 +6,46 @@ static struct amlnand_chip *aml_chip_key = NULL;
 /*
  * This funcion reads the u-boot keys.
  */
-int amlnf_key_read(u8 * buf, int len)
+int amlnf_key_read(u8 * buf, int len, uint32_t *actual_lenth)
 {
 	struct amlnand_chip * aml_chip = aml_chip_key;
 	struct nand_menson_key *key_ptr = NULL;
+	u32 keysize = aml_chip->keysize - sizeof(u32);
 	int error = 0;
 
+	*actual_lenth = keysize;
+
 	if (aml_chip == NULL) {
 		printk("%s(): amlnf key not ready yet!", __func__);
 		return -EFAULT;
 	}
 
-	if (len > CONFIG_KEYSIZE) {
+	if (len > keysize) {
+		/*
+		No return here! keep consistent, should memset zero
+		for the rest.
+		*/
 		printk("%s key data len too much\n",__func__);
-		return -EFAULT;
+		memset(buf + keysize, 0 , len - keysize);
+		//return -EFAULT;
 	}
-	key_ptr = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+
+	key_ptr = kzalloc(aml_chip->keysize, GFP_KERNEL);
 	if (key_ptr == NULL)
 		return -ENOMEM;
-	memset(key_ptr, 0, CONFIG_KEYSIZE);
 
 	error = amlnand_read_info_by_name(aml_chip,
 		(u8 *)&(aml_chip->nand_key),
 		(u8 *)key_ptr,
 		(u8*)KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (error) {
 		printk("%s: read key error\n",__func__);
 		error = -EFAULT;
 		goto exit;
 	}
-	memcpy(buf, key_ptr->data, len);
+
+	memcpy(buf, key_ptr->data, keysize);
 
 exit:
 	kfree(key_ptr);
@@ -46,10 +55,11 @@ exit:
 /*
  * This funcion write the keys.
  */
-int amlnf_key_write(u8 *buf, int len)
+int amlnf_key_write(u8 *buf, int len, uint32_t *actual_lenth)
 {
 	struct amlnand_chip * aml_chip = aml_chip_key;
 	struct nand_menson_key *key_ptr = NULL;
+	u32 keysize = aml_chip->keysize - sizeof(u32);
 	int error = 0;
 
 	if (aml_chip == NULL) {
@@ -57,21 +67,27 @@ int amlnf_key_write(u8 *buf, int len)
 		return -EFAULT;
 	}
 
-	if (len > CONFIG_KEYSIZE) {
+	if (len > keysize) {
+		/*
+		No return here! keep consistent, should memset zero
+		for the rest.
+		*/
 		printk("key data len too much,%s\n",__func__);
-		return -EFAULT;
+		memset(buf + keysize, 0 , len - keysize);
+		//return -EFAULT;
 	}
-	key_ptr = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+
+	key_ptr = kzalloc(aml_chip->keysize, GFP_KERNEL);
 	if (key_ptr == NULL)
 		return -ENOMEM;
-	memset(key_ptr,0,CONFIG_KEYSIZE);
-	memcpy(key_ptr->data + 0, buf, len);
+
+	memcpy(key_ptr->data + 0, buf, keysize);
 
 	error = amlnand_save_info_by_name(aml_chip,
 		(u8 *)&(aml_chip->nand_key),
 		(u8 *)key_ptr,
 		(u8 *)KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (error) {
 		printk("save key error,%s\n",__func__);
 		error = -EFAULT;
@@ -108,19 +124,19 @@ int aml_key_init(struct amlnand_chip *aml_chip)
 	/* avoid null */
 	aml_chip_key = aml_chip;
 
-	key_ptr = aml_nand_malloc(CONFIG_KEYSIZE);
+	key_ptr = aml_nand_malloc(aml_chip->keysize);
 	if (key_ptr == NULL) {
 		printk("nand malloc for key_ptr failed");
 		ret = -1;
 		goto exit_error0;
 	}
-	memset(key_ptr, 0x0, CONFIG_KEYSIZE);
+	memset(key_ptr, 0x0, aml_chip->keysize);
 	printk("%s probe.\n", __func__);
 
 	ret = amlnand_info_init(aml_chip,
 		(u8 *)&(aml_chip->nand_key),
 		(u8 *)key_ptr,(u8 *)KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (ret < 0) {
 		printk("invalid nand key\n");
 	}
@@ -140,17 +156,16 @@ int aml_nand_update_key(struct amlnand_chip * aml_chip, char *key_ptr)
 	char *key_buf = NULL;
 
 	if (key_buf == NULL) {
-
-		key_buf = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+		key_buf = kzalloc(aml_chip->keysize, GFP_KERNEL);
 		malloc_flag = 1;
 		if (key_buf == NULL)
 			return -ENOMEM;
-		memset(key_buf,0,CONFIG_KEYSIZE);
+		memset(key_buf, 0, aml_chip->keysize);
 		ret = amlnand_read_info_by_name(aml_chip,
 			(u8 *)&(aml_chip->nand_key),
 			(u8 *)key_buf,
 			(u8 *)KEY_INFO_HEAD_MAGIC,
-			CONFIG_KEYSIZE);
+			aml_chip->keysize);
 		if (ret) {
 			printk("%s: read key error\n", __func__);
 			ret = -EFAULT;
@@ -169,7 +184,7 @@ int aml_nand_update_key(struct amlnand_chip * aml_chip, char *key_ptr)
 		(u8 *)&(aml_chip->nand_key),
 		(u8 *)key_buf,
 		(u8 *)KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (ret < 0) {
 		printk("%s : save key info failed\n", __func__);
 	}
diff --git a/drivers/nand/dev/cmd_amlnf.c b/drivers/nand/dev/cmd_amlnf.c
index f1e5b5e..21e4f7d 100644
--- a/drivers/nand/dev/cmd_amlnf.c
+++ b/drivers/nand/dev/cmd_amlnf.c
@@ -40,8 +40,8 @@ extern int amlnf_dtb_erase(void);
 #endif
 
 #if (AML_CFG_KEY_RSV_EN)
-extern int amlnf_key_write(u8 *buf, int len);
-extern int amlnf_key_read(u8 * buf, int len);
+extern int amlnf_key_write(u8 *buf, int len, uint32_t *actual_lenth);
+extern int amlnf_key_read(u8 * buf, int len, uint32_t *actual_lenth);
 extern int amlnf_key_erase(void);
 #endif
 
@@ -648,6 +648,7 @@ static int do_amlnfphy(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]
 #endif
 	/* need full environments */
 #if (AML_CFG_KEY_RSV_EN)
+	uint32_t actual_lenth;
 	if ((strcmp(cmd, "key_write") == 0)
 		|| (strcmp(cmd, "key_read") == 0)) {
 		nfread_flag = 0;
@@ -665,11 +666,11 @@ static int do_amlnfphy(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]
 		//memset(devops, 0x0, sizeof(struct phydev_ops));
 
 		if (nfread_flag) {
-			ret = amlnf_key_read((u8 *)addr, (int)size);
+			ret = amlnf_key_read((u8 *)addr, (int)size, &actual_lenth);
 			if (ret < 0)
 				aml_nand_msg("nand read key failed");
 		} else {
-			ret = amlnf_key_write((u8 *)addr, (int)size);
+			ret = amlnf_key_write((u8 *)addr, (int)size, &actual_lenth);
 			if (ret < 0)
 				aml_nand_msg("nand write key failed");
 		}
diff --git a/drivers/nand/include/phynand.h b/drivers/nand/include/phynand.h
index cfb2b8b..503ae60 100644
--- a/drivers/nand/include/phynand.h
+++ b/drivers/nand/include/phynand.h
@@ -135,17 +135,14 @@ union nand_core_clk_t {
 
 #define	FBBT_COPY_NUM	1
 
-/* 512K */
-#define CONFIG_KEYSIZE		(256*1024)
-#define KEYSIZE	(CONFIG_KEYSIZE - (sizeof(u32)))
 /* 128k */
 #define CONFIG_SECURE_SIZE	(0x10000*2)
 /*fixme, arguing...*/
 #define SECURE_SIZE (CONFIG_SECURE_SIZE - (sizeof(u32)))
 
 /* 256KBytes. */
-#define CONFIG_DTB_SIZE  (256*1024U)
-#define DTB_SIZE (CONFIG_DTB_SIZE - (sizeof(u32)))
+//#define CONFIG_DTB_MAXIMUM_SIZE  (256*1024U)
+//#define DTB_SIZE (CONFIG_DTB_SIZE - (sizeof(u32)))
 
 #define FULL_BLK	0
 #define FULL_PAGE	1
@@ -762,7 +759,7 @@ struct shipped_bbt {
 
 struct nand_menson_key {
 	u32 crc;
-	u8 data[KEYSIZE];
+	u8 data[252];
 };
 
 /* typedef struct nand_menson_key meson_key; */	/* fixme, */
@@ -853,6 +850,10 @@ struct amlnand_chip {
 	void __iomem *nand_clk_reg;
 #endif /*  */
 	u8 shipped_retry_flag; /* do factory bad block detect less than 2 times*/
+
+	u32 h_cache_dev;
+	u32 keysize;
+	u32 dtbsize;
 };
 
 extern struct nand_flash flash_ids_slc[];
diff --git a/drivers/nand/phy/chipenv.c b/drivers/nand/phy/chipenv.c
index 35a9686..11ab55b 100644
--- a/drivers/nand/phy/chipenv.c
+++ b/drivers/nand/phy/chipenv.c
@@ -102,16 +102,18 @@ static int amlnand_oops_handle(struct amlnand_chip *aml_chip, int flag)
 	int  start_blk,total_blk, ret = 0;
 	int percent=0, percent_complete = -1;
 	unsigned char *buf = NULL;
-	unsigned int buf_size = MAX(CONFIG_SECURE_SIZE, CONFIG_KEYSIZE);
+	unsigned int buf_size;
 	int last_reserve_blk;
+
+	buf_size = 0x40000; /*rsv item max size is 256KB*/
 	buf = aml_nand_malloc(buf_size);
 	if (!buf) {
 	  aml_nand_msg("%s() %d: malloc failed", __FUNCTION__, __LINE__);
 	}
-	memset(buf,0x0,buf_size);
+	memset(buf, 0x0, buf_size);
 
 	/* fixme, should not exit here, 20150801 */
-	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, aml_chip->keysize);
 	if (ret < 0) {
 		aml_nand_msg("%s() %d invalid nand key\n", __FUNCTION__, __LINE__);
 		goto exit_error0;
@@ -1849,8 +1851,11 @@ get_free_blk:
 #endif
 			}
 		}
-
-		if (arg_info->arg_type == FULL_PAGE) {
+		/*
+		add 'flash->blocksize > 0x40000' here,nand flash which blocksize
+		is smaller than 256KB(slc flash) shoudn't write again.
+		*/
+		if ((arg_info->arg_type == FULL_PAGE) && (flash->blocksize > 0x40000)) {
 			if (write_page_cnt == 0) {
 				arg_info->arg_valid = 1;
 				full_page_flag = 0;
@@ -2601,46 +2606,75 @@ static void init_dev_para(struct dev_para*dev_para_ptr,struct amlnf_partition *c
 }
 static void amlnand_get_dev_num(struct amlnand_chip *aml_chip,struct amlnf_partition *config_init)
 {
-	//struct dev_para *dev_para = NULL;
-	struct dev_para*dev_para_ptr =NULL;
-	//struct amlnf_partition *partition = NULL;
-	//struct amlnf_partition * partition_ptr =NULL;
-	//int j, i,k,tmp_num=0,partiton_num=0,dev_num=0,ret=0;
-	int i,tmp_num=0;
-	int device_num =PHY_DEV_NUM;
+	struct dev_para *dev_para_ptr =NULL;
+	int i , tmp_num=0;
+	int device_num;
+
+	device_num = (aml_chip->h_cache_dev)? 3 : 2;
 
 	if (boot_device_flag == 1) {
-		memcpy((void *)(aml_chip->config_ptr->dev_para[tmp_num].name), NAND_BOOT_NAME, strlen(NAND_BOOT_NAME));
+		memcpy((void *)(aml_chip->config_ptr->dev_para[tmp_num].name),
+			NAND_BOOT_NAME, strlen(NAND_BOOT_NAME));
 		aml_chip->config_ptr->dev_para[tmp_num].nr_partitions = 0;
 		aml_chip->config_ptr->dev_para[tmp_num].option = 0;
 		tmp_num++;
-		device_num = PHY_DEV_NUM + 1;
+		device_num += 1;
 	}
 	aml_chip->config_ptr->dev_num = device_num;
 
-	for (i=0;tmp_num < device_num;tmp_num++,i++) {
+	for (i=0; tmp_num < device_num; tmp_num++, i++) {
+		int dev_flag;
+		u32 option;
 		dev_para_ptr = &(aml_chip->config_ptr->dev_para[tmp_num]);
 		if (i == 0) {
-			//printf("cache!\n");
-			memcpy((void *)(dev_para_ptr->name), NAND_CACHE_NAME, strlen(NAND_CACHE_NAME));
-			init_dev_para(dev_para_ptr,config_init,STORE_CACHE);
-			dev_para_ptr->option = NAND_DATA_OPTION;
-		}else if(i==1) {
-			//printf("code!\n");
-			memcpy((void *)(dev_para_ptr->name), NAND_CODE_NAME, strlen(NAND_CODE_NAME));
-			init_dev_para(dev_para_ptr,config_init,STORE_CODE);
-			dev_para_ptr->option = NAND_CODE_OPTION;
-		}else if(i==2) {
-			//printf("data!\n");
-			memcpy((void *)(dev_para_ptr->name), NAND_DATA_NAME, strlen(NAND_DATA_NAME));
-			init_dev_para(dev_para_ptr,config_init,STORE_DATA);
-			dev_para_ptr->option = NAND_DATA_OPTION;
-		}else {
-			aml_nand_msg("%s: something wrong %d!!", __func__, __LINE__);
+			if (aml_chip->h_cache_dev) {
+				memcpy((void *)(dev_para_ptr->name),
+					NAND_CACHE_NAME,
+					strlen(NAND_CACHE_NAME));
+				dev_flag = STORE_CACHE;
+				option = NAND_DATA_OPTION;
+			} else {
+				memcpy((void *)(dev_para_ptr->name),
+					NAND_CODE_NAME,
+					strlen(NAND_CODE_NAME));
+				dev_flag = STORE_CODE;
+				option = NAND_CODE_OPTION;
+			}
+			init_dev_para(dev_para_ptr, config_init, dev_flag);
+			dev_para_ptr->option = option;
+		} else if (i == 1) {
+			if (aml_chip->h_cache_dev) {
+				memcpy((void *)(dev_para_ptr->name),
+					NAND_CODE_NAME,
+					strlen(NAND_CODE_NAME));
+				dev_flag = STORE_CODE;
+				option = NAND_CODE_OPTION;
+			} else {
+				memcpy((void *)(dev_para_ptr->name),
+					NAND_DATA_NAME,
+					strlen(NAND_DATA_NAME));
+				dev_flag = STORE_DATA;
+				option = NAND_DATA_OPTION;
+			}
+			init_dev_para(dev_para_ptr, config_init, dev_flag);
+			dev_para_ptr->option = option;
+		} else if (i == 2) {
+			if (aml_chip->h_cache_dev) {
+				memcpy((void *)(dev_para_ptr->name),
+					NAND_DATA_NAME,
+					strlen(NAND_DATA_NAME));
+				dev_flag = STORE_DATA;
+				option = NAND_DATA_OPTION;
+				init_dev_para(dev_para_ptr,
+					config_init, dev_flag);
+				dev_para_ptr->option = option;
+			}
+		} else {
+			aml_nand_msg("%s:something wrong here",
+				__func__);
 			break;
 		}
 	}
-
 	return ;
 }
 
@@ -2655,8 +2689,12 @@ int amlnand_configs_confirm(struct amlnand_chip *aml_chip)
 	struct dev_para *dev_para_cmp = NULL;
 	unsigned char  confirm_flag=0;
 	int i, tmp_num=0,ret = 0;
-	int device_num =PHY_DEV_NUM;
+	int device_num;
+
 	ENV_NAND_LINE
+
+	device_num = (aml_chip->h_cache_dev)? 3 : 2;
+
 	ret = phrase_driver_version(config_ptr->driver_version,DRV_PHY_VERSION);
 	if (ret) {
 		aml_nand_msg("driver_version in nand  %d.%02d.%03d.%04d ",
@@ -2670,7 +2708,7 @@ int amlnand_configs_confirm(struct amlnand_chip *aml_chip)
 
 	if (boot_device_flag == 1) {
 		tmp_num++;
-		device_num = PHY_DEV_NUM + 1;
+		device_num += 1;
 	}
 	ENV_NAND_LINE
 	//check device num
@@ -2680,33 +2718,53 @@ int amlnand_configs_confirm(struct amlnand_chip *aml_chip)
 		confirm_flag = 1;
 	}
 	ENV_NAND_LINE
-	for (i=0;tmp_num < device_num;tmp_num++,i++) {
+	for (i=0; tmp_num < device_num; tmp_num++, i++) {
 		ENV_NAND_LINE
 		dev_para_cmp = &(aml_chip->config_ptr->dev_para[tmp_num]);
 		if (i == 0) {
-			ret = confirm_dev_para(dev_para_cmp,configs_init,STORE_CACHE);
+			if (aml_chip->h_cache_dev)
+				ret = confirm_dev_para(dev_para_cmp,
+					configs_init, STORE_CACHE);
+			else
+				ret = confirm_dev_para(dev_para_cmp,
+					configs_init, STORE_CODE);
 			if (ret) {
 				confirm_flag = 1;
 				break;
 			}
-		}else if(i==1) {
-			ret = confirm_dev_para(dev_para_cmp,configs_init,STORE_CODE);
+		} else if (i == 1) {
+			if (aml_chip->h_cache_dev)
+				ret = confirm_dev_para(dev_para_cmp,
+					configs_init, STORE_CODE);
+			else
+				ret = confirm_dev_para(dev_para_cmp,
+					configs_init, STORE_DATA);
 			if (ret) {
 				confirm_flag = 1;
 				break;
 			}
-		}else if(i==2) {
-			ret = confirm_dev_para(dev_para_cmp,configs_init,STORE_DATA);
-			if (ret) {
+		} else if (i == 2) {
+			if (aml_chip->h_cache_dev) {
+				ret = confirm_dev_para(dev_para_cmp,
+					configs_init, STORE_DATA);
+				if (ret) {
+					confirm_flag = 1;
+					break;
+				}
+			} else {
+				aml_nand_msg("%s %d: something wrong here!!",
+					__func__, __LINE__);
 				confirm_flag = 1;
 				break;
 			}
-		}else {
-			aml_nand_msg("%s: something wrong %d!!", __func__, __LINE__);
+		} else {
+			aml_nand_msg("%s %d: something wrong here!!",
+					__func__, __LINE__);
 			confirm_flag = 1;
 			break;
 		}
 	}
+
 	ENV_NAND_LINE
 	if (confirm_flag == 0) {
 		aml_nand_dbg("nand configs confirm all right");
@@ -3591,7 +3649,7 @@ int  shipped_bbt_invalid_ops(struct amlnand_chip *aml_chip)
 	} else {
 	/* normal boot or upgrade, no need to erase the whole chip! */
 	/* init key info here!*/
-		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+		ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, aml_chip->keysize);
 		if (ret < 0) {
 			aml_nand_msg("invalid nand key\n");
 			goto exit_error0;
@@ -3669,7 +3727,7 @@ int  shipped_bbt_invalid_ops(struct amlnand_chip *aml_chip)
 	}
 #else
 
-	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, CONFIG_KEYSIZE);
+	ret = amlnand_info_init(aml_chip, (unsigned char *)&(aml_chip->nand_key),buf,(unsigned char *)KEY_INFO_HEAD_MAGIC, aml_chip->keysize);
 	if (ret < 0) {
 	aml_nand_msg("invalid nand key\n");
 	goto exit_error0;
@@ -3971,6 +4029,18 @@ int amlnand_get_dev_configs(struct amlnand_chip *aml_chip)
 	struct read_retry_info *retry_info = &(controller->retry_info);
 	int  ret = 0;
 
+	if (flash->blocksize < 0x40000) {
+		aml_chip->keysize = flash->blocksize;
+		aml_chip->dtbsize = flash->blocksize;
+	} else {
+		/*
+		fix size key/dtb!!!
+		max key/dtb size is 256KB
+		*/
+		aml_chip->keysize = 0x40000;
+		aml_chip->dtbsize = 0x40000;
+	}
+
 	/* 1. setting config attribute.*/
 	ENV_NAND_LINE;
 	amlnand_set_config_attribute(aml_chip);
diff --git a/drivers/nand/phy/hw_controller.c b/drivers/nand/phy/hw_controller.c
index 2f564fa..791f5b6 100644
--- a/drivers/nand/phy/hw_controller.c
+++ b/drivers/nand/phy/hw_controller.c
@@ -630,20 +630,6 @@ static int controller_adjust_timing(struct hw_controller *controller)
 	/* for encrypt store */
 	if (AMLNF_READ_REG(P_AO_SEC_SD_CFG10) &  (1 << 15))
 		NFC_ENABLE_ENCRYPT(controller);
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)	{
-#if (AML_CFG_NEWOOB_EN) /* !!!we need modify later. */
-		/* fixme, debug code....*/
-		if (flash->pagesize > 4096) {
-			aml_nand_msg("new oob mode");
-			NFC_SET_OOB_MODE(controller, 3<<26);
-			controller->oob_mod = 1;	//new oob mode.
-		} else
-			controller->oob_mod = 0;
-#else
-		controller->oob_mod = 0;
-#endif
-	} else
-		controller->oob_mod = 0;
 
 	NFC_SEND_CMD(controller, 1<<31);
 	aml_nand_msg("bus_c=%d,bus_t=%d,sys=%d.%dns,T_REA=%d,T_RHOH=%d",
@@ -666,8 +652,8 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	struct nand_flash *flash = &(aml_chip->flash);
 	struct bch_desc *ecc_supports = controller->bch_desc;
 	u32 max_bch_mode = controller->max_bch;
-	u32 options_support = 0, ecc_bytes, i;
-	u8 bch_index;
+	u32 options_support = 0, ecc_bytes, ecc_page_cnt = 0, i;
+	u8 bch_index = 0;
 	u16 tmp_value;
 
 	if (controller->option & NAND_ECC_SOFT_MODE) {
@@ -678,8 +664,8 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	}
 
 	for (i = (max_bch_mode-1); i > 0; i--) {
-		ecc_bytes =
-		flash->oobsize/(flash->pagesize/ecc_supports[i].unit_size);
+		ecc_page_cnt = flash->pagesize/ecc_supports[i].unit_size;
+		ecc_bytes = flash->oobsize / ecc_page_cnt;
 		if (ecc_bytes >= ecc_supports[i].bytes +
 			ecc_supports[i].usr_mode) {
 			options_support = ecc_supports[i].mode;
@@ -688,12 +674,38 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 		}
 	}
 
+	controller->oob_mod = 0;
+#if (AML_CFG_NEWOOB_EN)
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
+		if (flash->oobsize >= (16+ecc_supports[i].bytes*ecc_page_cnt)) {
+			/* for backward compatbility 4k page mlc. The code
+			we released before like below, which means old oob
+			mode will be used when page size < 4k.
+			------------------------------------
+			if (flash->pagesize > 4096) {
+				aml_nand_msg("AML_NAND_NEW_OOB : new oob");
+				NFC_SET_OOB_MODE(3<<26);
+				controller->oob_mod = 1;
+			}else{
+				controller->oob_mod = 0;
+			}
+			------------------------------------*/
+			if ((flash->pagesize == 4096)
+				&& (flash->chipsize > 2048))
+				controller->oob_mod = 0;
+			else {
+				aml_nand_msg("new oob mode");
+				NFC_SET_OOB_MODE(controller, 3<<26);
+				controller->oob_mod = 1;
+			}
+		}
+	}
+#endif
+
 	switch (options_support) {
 	case NAND_ECC_BCH8_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_SIZE;
 		controller->ecc_bytes = NAND_BCH8_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 6;
 		controller->ecc_max = 8;
 		break;
@@ -701,8 +713,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH8_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH8_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 6;
 		controller->ecc_max = 8;
 		break;
@@ -710,8 +720,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH16_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH16_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 14;
 		controller->ecc_max = 16;
 		break;
@@ -719,8 +727,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH24_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH24_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 22;
 		controller->ecc_max = 24;
 		break;
@@ -728,8 +734,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH30_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH30_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 26;
 		controller->ecc_max = 30;
 		break;
@@ -737,8 +741,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH40_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH40_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 34;
 		controller->ecc_max = 40;
 		break;
@@ -746,8 +748,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH50_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH50_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 45;
 		controller->ecc_max = 50;
 		break;
@@ -755,8 +755,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH60_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH60_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 55;
 		controller->ecc_max = 60;
 		break;
@@ -764,8 +762,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_SHORT_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_SHORT;
 		controller->ecc_bytes = NAND_BCH60_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 55;
 		controller->ecc_max = 60;
 		break;
@@ -776,6 +772,11 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 		break;
 	}
 
+	controller->bch_mode = bch_index;
+	if (controller->oob_mod)
+		controller->user_mode = 16 / (flash->pagesize / controller->ecc_unit);
+	else
+		controller->user_mode = 2;
 	tmp_value = controller->ecc_unit + controller->ecc_bytes +
 		controller->user_mode;
 	controller->ecc_steps = (flash->pagesize+flash->oobsize)/tmp_value;
@@ -864,11 +865,9 @@ static void controller_get_user_byte(struct hw_controller *controller,
 	while (byte_num > 0) {
 		*oob_buf++ = (controller->user_buf[read_times*len] & 0xff);
 		byte_num--;
-		if (controller->user_mode == 2) {
-			*oob_buf++ =
-			((controller->user_buf[read_times*len] >> 8) & 0xff);
-			byte_num--;
-		}
+		*oob_buf++ =
+		((controller->user_buf[read_times*len] >> 8) & 0xff);
+		byte_num--;
 		read_times++;
 	}
 }
@@ -892,11 +891,9 @@ static void controller_set_user_byte(struct hw_controller *controller,
 	while (byte_num > 0) {
 		controller->user_buf[write_times*len] = *oob_buf++;
 		byte_num--;
-		if (controller->user_mode == 2) {
-			controller->user_buf[write_times*len] |=
-				(*oob_buf++ << 8);
-			byte_num--;
-		}
+		controller->user_buf[write_times*len] |=
+		(*oob_buf++ << 8);
+		byte_num--;
 		write_times++;
 	}
 }
diff --git a/drivers/nand/phy/id_table.c b/drivers/nand/phy/id_table.c
index a56d39f..6070f34 100644
--- a/drivers/nand/phy/id_table.c
+++ b/drivers/nand/phy/id_table.c
@@ -16,25 +16,35 @@
 #ifdef AML_SLC_NAND_SUPPORT
 struct nand_flash flash_ids_slc[] = {
 	/***for SLC nand***/
-	{"NAND 128MiB 3,3V 8-bit", {0, 0x79}, 512, 128, 0x4000, 0, 0, 0},
-
-	{"NAND 256MiB 3,3V 8-bit", {0, 0x71}, 512, 256, 0x4000, 0, 0, 0},
-	/*512 Megabit */
-	{"NAND 64MiB 3,3V 8-bit", {0, 0xF2}, 0,  64, 0, 0, 0, 0},
-	/* 1 Gigabit */
-	{"NAND 128MiB 3,3V 8-bit", {0, 0xF1}, 0, 128, 0, 0, 0, 0},
-	/* 2 Gigabit */
-	{"NAND 256MiB 3,3V 8-bit", {0, 0xDA}, 0, 256, 0, 0, 0, 0},
-	/* 4 Gigabit */
-	{"NAND 512MiB 3,3V 8-bit", {0, 0xDC}, 0, 512, 0, 0, 0, 0},
-	/* 8 Gigabit */
-	{"NAND 1GiB 3,3V 8-bit", {0, 0xD3}, 0, 1024, 0, 0, 0, 0},
 	{NULL,}
 };
 #endif
 
 #ifdef AML_MLC_NAND_SUPPORT
 struct nand_flash flash_ids_mlc[] = {
+/***for SLC nand***/
+	{"TOSHIBA 128MB SLC TC58BVG0S3HBAI6",
+		{NAND_MFR_TOSHIBA, 0xF1, 0x80, 0x15, 0xF2},
+		2048,
+		128,
+		0x20000,
+		64,
+		1,
+		20,
+		25,
+		0,
+		0},
+	{"TOSHIBA 256MB SLC TC58BVG0S3HBAI6",
+		{NAND_MFR_TOSHIBA, 0xDA, 0x90, 0x15, 0xF6},
+		2048,
+		256,
+		0x20000,
+		64,
+		1,
+		20,
+		25,
+		0,
+		0},
 /***for MLC nand***/
 	{"A revision NAND 2GiB H27UAG8T2A",
 		{NAND_MFR_HYNIX, 0xd5, 0x94, 0x25, 0x44, 0x41},
diff --git a/drivers/net/designware.c b/drivers/net/designware.c
index 352a1b3..1fe8a95 100644
--- a/drivers/net/designware.c
+++ b/drivers/net/designware.c
@@ -347,8 +347,7 @@ static int dw_eth_recv(struct eth_device *dev)
 	int length = 0;
 	phys_addr_t desc_start = (phys_addr_t)desc_p;
 	phys_addr_t desc_end = desc_start +
-		roundup(sizeof(*desc_p), ARCH_DMA_MINALIGN);
-
+	roundup(sizeof(*desc_p), ARCH_DMA_MINALIGN);
 	/* Invalidate entire buffer descriptor */
 	invalidate_dcache_range(desc_start, desc_end);
 
diff --git a/drivers/securestorage/securestorage.c b/drivers/securestorage/securestorage.c
index 7238cff..a0bfb4e 100644
--- a/drivers/securestorage/securestorage.c
+++ b/drivers/securestorage/securestorage.c
@@ -20,6 +20,19 @@ static uint64_t bl31_storage_ops(uint64_t function_id)
 	return function_id;
 }
 
+uint64_t bl31_storage_ops3(uint64_t function_id, uint64_t arg1, uint32_t arg2)
+{
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		__asmeq("%2", "x2")
+		"smc    #0\n"
+		: "+r" (function_id)
+		: "r"(arg1), "r"(arg2));
+
+	return function_id;
+}
+
 static uint64_t bl31_storage_write(uint8_t *keyname, uint8_t *keybuf,
 				uint32_t keylen, uint32_t keyattr)
 {
@@ -186,6 +199,9 @@ void *secure_storage_getbuffer(uint32_t *size)
 {
 	if (!storage_init_status)
 		secure_storage_init();
+	else
+		storage_share_block_size =
+			bl31_storage_ops(GET_SHARE_STORAGE_BLOCK_SIZE);
 	*size = (uint32_t)storage_share_block_size;
 	return (void *)storage_share_block_base;
 }
@@ -194,6 +210,11 @@ void secure_storage_notifier(void)
 	bl31_storage_ops(SECURITY_KEY_NOTIFY);
 }
 
+void secure_storage_notifier_ex(uint32_t storagesize, uint32_t rsvarg)
+{
+	bl31_storage_ops3(SECURITY_KEY_NOTIFY_EX, storagesize, rsvarg);
+}
+
 int32_t secure_storage_write(uint8_t *keyname, uint8_t *keybuf,
 				uint32_t keylen, uint32_t keyattr)
 {
diff --git a/drivers/storagekey/storagekey.c b/drivers/storagekey/storagekey.c
index 8f7d669..f7ce5f3 100644
--- a/drivers/storagekey/storagekey.c
+++ b/drivers/storagekey/storagekey.c
@@ -31,6 +31,7 @@
 #include <linux/types.h>
 #include <amlogic/secure_storage.h>
 #include <amlogic/storage_if.h>
+#include <amlogic/amlkey_if.h>
 #ifdef CONFIG_STORE_COMPATIBLE
 #include <partition_table.h>
 #endif
@@ -62,7 +63,7 @@ static struct storagekey_info_t storagekey_info = {
 int32_t amlkey_init(uint8_t *seed, uint32_t len)
 {
 	int32_t ret = 0;
-	uint32_t buffer_size;
+	uint32_t buffer_size, actual_size;
 
 	/* do nothing for now*/
 	printf("%s() enter!\n", __func__);
@@ -75,26 +76,31 @@ int32_t amlkey_init(uint8_t *seed, uint32_t len)
 	storagekey_info.buffer = secure_storage_getbuffer(&buffer_size);
 	if (storagekey_info.buffer == NULL) {
 		printf("%s() %d: can't get buffer from bl31!\n",
-				__func__, __LINE__);
+			__func__, __LINE__);
 		ret = -1;
 		goto _out;
 	}
-	if (buffer_size != storagekey_info.size) {
-		printf("%s() %d: warnning! %d/%d\n",
-			__func__, __LINE__, buffer_size, storagekey_info.size);
-		/* using innor size!*/
-		storagekey_info.size = buffer_size;
-	}
 
 	/* full fill key infos from storage. */
-	ret = store_key_read(storagekey_info.buffer,  storagekey_info.size);
+	ret = store_key_read(storagekey_info.buffer,
+		storagekey_info.size,
+		&actual_size);
 	if (ret) {
 		/* memset head info for bl31 */
 		memset(storagekey_info.buffer, 0, SECUESTORAGE_HEAD_SIZE);
 		ret = 0;
 		goto _out;
 	}
-	secure_storage_notifier();
+
+	storagekey_info.size = actual_size;
+	secure_storage_notifier_ex(actual_size, 0);
+
+	storagekey_info.buffer = secure_storage_getbuffer(&buffer_size);
+	if (buffer_size != actual_size) {
+		ret = -1;
+		goto _out;
+	}
+
 #ifdef CONFIG_STORE_COMPATIBLE
 	info_disprotect &= ~DISPROTECT_KEY;  //protect
 #endif
@@ -125,11 +131,7 @@ int32_t amlkey_isexsit(const uint8_t * name)
 	return (int32_t)retval;
 }
 
-/**
- * 3. query if the prgrammed key is secure
- * return secure 1, non 0;
- */
-int32_t amlkey_issecure(const uint8_t * name)
+static int32_t amlkey_get_attr(const uint8_t * name)
 {
 	int32_t ret = 0;
 	uint32_t retval;
@@ -145,10 +147,27 @@ int32_t amlkey_issecure(const uint8_t * name)
 		retval = 0;
 	}
 
-	return (int32_t)retval;
+	return (int32_t)(retval);
 }
 
 /**
+ * 3.1 query if the prgrammed key is secure. key must exsit!
+ * return secure 1, non 0;
+ */
+int32_t amlkey_issecure(const uint8_t * name)
+{
+	return (amlkey_get_attr(name)&UNIFYKEY_ATTR_SECURE_MASK);
+}
+
+/**
+ * 3.2 query if the prgrammed key is encrypt
+ * return encrypt 1, non-encrypt 0;
+ */
+int32_t amlkey_isencrypt(const uint8_t * name)
+{
+	return (amlkey_get_attr(name)&UNIFYKEY_ATTR_ENCRYPT_MASK);
+}
+/**
  * 4. actual bytes of key value
  *  return actual size.
  */
@@ -199,18 +218,21 @@ _out:
 
 /**
  * 6.write secure/non-secure key in bytes , return bytes readback actully
+ * attr: bit0, secure/non-secure;
+ *		 bit8, encrypt/non-encrypt;
  * return actual size write down.
  */
-ssize_t amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_t secure)
+ssize_t amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_t attr)
 {
 	int32_t ret = 0;
 	ssize_t retval = 0;
+	uint32_t actual_size;
 
 	if ( NULL == name ) {
 		printf("%s() %d, invalid key ", __func__, __LINE__);
 		return retval;
 	}
-	ret = secure_storage_write((uint8_t *)name, buffer, len, secure);
+	ret = secure_storage_write((uint8_t *)name, buffer, len, attr);
 	if (ret) {
 		printf("%s() %d: return %d\n", __func__, __LINE__, ret);
 		retval = 0;
@@ -219,9 +241,12 @@ ssize_t amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_
 		retval = (ssize_t)len;
 		/* write down! */
 		if (storagekey_info.buffer != NULL) {
-			ret = store_key_write(storagekey_info.buffer, storagekey_info.size);
+			ret = store_key_write(storagekey_info.buffer,
+				storagekey_info.size,
+				&actual_size);
 			if (ret) {
-				printf("%s() %d, store_key_write fail\n", __func__, __LINE__);
+				printf("%s() %d, store_key_write fail\n",
+					__func__, __LINE__);
 				retval = 0;
 			}
 		}
@@ -249,16 +274,21 @@ int32_t amlkey_hash_4_secure(const uint8_t * name, uint8_t * hash)
 int32_t amlkey_del(const uint8_t * name)
 {
 	int32_t ret = 0;
+	uint32_t actual_size;
 
 	ret = secure_storage_remove((uint8_t *)name);
 	if ((ret == 0) && (storagekey_info.buffer != NULL)) {
 		/* flush back */
-		ret = store_key_write(storagekey_info.buffer, storagekey_info.size);
+		ret = store_key_write(storagekey_info.buffer,
+			storagekey_info.size,
+			&actual_size);
 		if (ret) {
-			printf("%s() %d, store_key_write fail\n", __func__, __LINE__);
+			printf("%s() %d, store_key_write fail\n",
+				__func__, __LINE__);
 		}
 	} else {
-		printf("%s() %d, remove key fail\n", __func__, __LINE__);
+		printf("%s() %d, remove key fail\n",
+			__func__, __LINE__);
 	}
 
 	return ret;
diff --git a/drivers/usb/gadget/v2_burning/v2_common/optimus_download.c b/drivers/usb/gadget/v2_burning/v2_common/optimus_download.c
index 8d24a9c..185b00b 100644
--- a/drivers/usb/gadget/v2_burning/v2_common/optimus_download.c
+++ b/drivers/usb/gadget/v2_burning/v2_common/optimus_download.c
@@ -665,7 +665,9 @@ int optimus_storage_init(int toErase)
         DWN_WRN("dtb is not loaded yet\n");
     }
     else{
-        ret = get_partition_from_dts(dtbLoadedAddr);
+        unsigned char* dtb4FlashInit = (unsigned char*)OPTIMUS_DOWNLOAD_TRANSFER_BUF_ADDR;
+        memcpy(dtb4FlashInit, dtbLoadedAddr, _dtb_is_loaded);
+        ret = get_partition_from_dts(dtb4FlashInit);
         if (ret) {
             DWN_ERR("Failed at get_partition_from_dts\n");
             return __LINE__;
diff --git a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn.c b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn.c
index ad3cf77..dd368e4 100644
--- a/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn.c
+++ b/drivers/usb/gadget/v2_burning/v2_sdc_burn/optimus_sdc_burn.c
@@ -755,6 +755,7 @@ int do_sdc_burn(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
     }
 
     optimus_work_mode_set(OPTIMUS_WORK_MODE_SDC_UPDATE);
+    run_command("osd clear", 0);
     show_logo_to_report_burning();//indicate enter flow of burning! when 'run update'
     if (optimus_led_open(LED_TYPE_PWM)) {
         DWN_ERR("Fail to open led for burn\n");
diff --git a/drivers/vpp/aml_vpp.c b/drivers/vpp/aml_vpp.c
index 446e273..854dcae 100644
--- a/drivers/vpp/aml_vpp.c
+++ b/drivers/vpp/aml_vpp.c
@@ -901,6 +901,15 @@ void vpp_init(void)
 		vpp_reg_write(VPP_DUMMY_DATA1, 0x1020080);
 		/* osd1: rgb->yuv limit , osd2: yuv limit */
 		set_osd1_rgb2yuv(1);
+	} else if (get_cpu_id().family_id == MESON_CPU_MAJOR_ID_TXL) {
+		/* set dummy data default YUV black */
+		vpp_reg_write(VPP_DUMMY_DATA1, 0x108080);
+		/* osd1: rgb->yuv limit , osd2: yuv limit */
+		set_osd1_rgb2yuv(1);
+	#if (defined CONFIG_AML_LCD)
+		/* 709 limit to RGB */
+		vpp_set_matrix_ycbcr2rgb(2, 3);
+	#endif
 	} else {
 		/* set dummy data default YUV black */
 		vpp_reg_write(VPP_DUMMY_DATA1, 0x108080);
diff --git a/drivers/vpu/aml_vpu.c b/drivers/vpu/aml_vpu.c
index 72d5b88..67637af 100644
--- a/drivers/vpu/aml_vpu.c
+++ b/drivers/vpu/aml_vpu.c
@@ -19,6 +19,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
 
+#include <asm/cpu_id.h>
 #include <config.h>
 #include <linux/kernel.h>
 #ifdef CONFIG_OF_LIBFDT
@@ -42,10 +43,10 @@ static struct vpu_conf_s vpu_conf = {
 
 static void vpu_chip_detect(void)
 {
-#if 0
+#if 1
 	unsigned int cpu_type;
 
-	cpu_type = get_cpu_type();
+	cpu_type = get_cpu_id().family_id;
 	switch (cpu_type) {
 	case MESON_CPU_MAJOR_ID_M8:
 		vpu_chip_type = VPU_CHIP_M8;
@@ -95,10 +96,23 @@ static void vpu_chip_detect(void)
 		vpu_conf.clk_level_max = CLK_LEVEL_MAX_GXL;
 		vpu_conf.fclk_type = FCLK_TYPE_GXL;
 		break;
+	case MESON_CPU_MAJOR_ID_GXM:
+		vpu_chip_type = VPU_CHIP_GXM;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_GXM;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_GXM;
+		vpu_conf.fclk_type = FCLK_TYPE_GXM;
+		break;
+	case MESON_CPU_MAJOR_ID_TXL:
+		vpu_chip_type = VPU_CHIP_TXL;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_TXL;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_TXL;
+		vpu_conf.fclk_type = FCLK_TYPE_TXL;
+		break;
 	default:
-		vpu_chip_type = VPU_CHIP_MAX;
-		vpu_conf.clk_level_dft = 0;
-		vpu_conf.clk_level_max = 1;
+		vpu_chip_type = VPU_CHIP_GXBB;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_GXBB;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_GXBB;
+		vpu_conf.fclk_type = FCLK_TYPE_GXBB;
 	}
 #else
 	vpu_chip_type = VPU_CHIP_GXBB;
@@ -108,12 +122,12 @@ static void vpu_chip_detect(void)
 #endif
 
 #ifdef VPU_DEBUG_PRINT
-	VPUPR("vpu: detect chip type: %d\n", vpu_chip_type);
-	VPUPR("vpu: clk_level default: %d(%dHz), max: %d(%dHz)\n",
+	VPUPR("detect chip type: %d\n", vpu_chip_type);
+	VPUPR("clk_level default: %d(%dHz), max: %d(%dHz)\n",
 		vpu_conf.clk_level_dft,
 		vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level_dft][0],
 		vpu_conf.clk_level_max,
-		vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level_max][0],);
+		vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level_max][0]);
 #endif
 }
 
@@ -141,10 +155,18 @@ static unsigned int get_vpu_clk(void)
 	unsigned int fclk, clk_source;
 	unsigned int mux, div;
 
-	if (vpu_chip_type == VPU_CHIP_GXBB)
-		reg = HHI_VPU_CLK_CNTL_GX;
-	else
+	switch (vpu_chip_type) {
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
 		reg = HHI_VPU_CLK_CNTL;
+		break;
+	default:
+		reg = HHI_VPU_CLK_CNTL_GX;
+		break;
+	}
 
 	fclk = fclk_table[vpu_conf.fclk_type] * 100; /* 0.01M resolution */
 	mux = vpu_hiu_getb(reg, 9, 3);
@@ -326,10 +348,18 @@ static int set_vpu_clk(unsigned int vclk)
 		VPUPR("clk out of supported range, set to default\n");
 	}
 
-	if (vpu_chip_type == VPU_CHIP_GXBB)
-		ret = adjust_vpu_clk_gx(clk_level);
-	else
+	switch (vpu_chip_type) {
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
 		ret = adjust_vpu_clk_m8_g9(clk_level);
+		break;
+	default:
+		ret = adjust_vpu_clk_gx(clk_level);
+		break;
+	}
 
 	return ret;
 }
@@ -483,11 +513,6 @@ static void vpu_power_off_gx(void)
 static void vpu_power_on(void)
 {
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		vpu_power_on_gx();
-		break;
 	case VPU_CHIP_M8:
 	case VPU_CHIP_M8B:
 	case VPU_CHIP_M8M2:
@@ -496,6 +521,7 @@ static void vpu_power_on(void)
 		vpu_power_on_m8_g9();
 		break;
 	default:
+		vpu_power_on_gx();
 		break;
 	}
 }
@@ -503,11 +529,6 @@ static void vpu_power_on(void)
 static void vpu_power_off(void)
 {
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		vpu_power_off_gx();
-		break;
 	case VPU_CHIP_M8:
 	case VPU_CHIP_M8B:
 	case VPU_CHIP_M8M2:
@@ -516,6 +537,7 @@ static void vpu_power_off(void)
 		vpu_power_off_m8_g9();
 		break;
 	default:
+		vpu_power_off_gx();
 		break;
 	}
 }
@@ -637,18 +659,6 @@ int vpu_clk_change(int level)
 	vpu_clk = vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level][0];
 
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		reg = HHI_VPU_CLK_CNTL_GX;
-		vpu_clk_switch(reg);
-
-		if (vpu_clk >= (VPU_CLKB_MAX * 1000000))
-			div = 2;
-		else
-			div = 1;
-		vpu_hiu_setb(HHI_VPU_CLKB_CNTL_GX, (div - 1), 0, 8);
-		break;
 	case VPU_CHIP_M8:
 		reg = HHI_VPU_CLK_CNTL;
 		mux = vpu_clk_table[vpu_conf.fclk_type][vpu_conf.clk_level][1];
@@ -663,7 +673,14 @@ int vpu_clk_change(int level)
 		vpu_clk_switch(reg);
 		break;
 	default:
-		reg = HHI_VPU_CLK_CNTL;
+		reg = HHI_VPU_CLK_CNTL_GX;
+		vpu_clk_switch(reg);
+
+		if (vpu_clk >= (VPU_CLKB_MAX * 1000000))
+			div = 2;
+		else
+			div = 1;
+		vpu_hiu_setb(HHI_VPU_CLKB_CNTL_GX, (div - 1), 0, 8);
 		break;
 	}
 
@@ -677,13 +694,15 @@ void vpu_clk_get(void)
 	unsigned int reg;
 
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		reg = HHI_VPU_CLK_CNTL_GX;
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
+		reg = HHI_VPU_CLK_CNTL;
 		break;
 	default:
-		reg = HHI_VPU_CLK_CNTL;
+		reg = HHI_VPU_CLK_CNTL_GX;
 		break;
 	}
 
diff --git a/drivers/vpu/aml_vpu.h b/drivers/vpu/aml_vpu.h
index 481297c..b2dc963 100644
--- a/drivers/vpu/aml_vpu.h
+++ b/drivers/vpu/aml_vpu.h
@@ -35,6 +35,8 @@ enum vpu_chip_e {
 	VPU_CHIP_GXBB,
 	VPU_CHIP_GXTVBB,
 	VPU_CHIP_GXL,
+	VPU_CHIP_GXM,
+	VPU_CHIP_TXL,
 	VPU_CHIP_MAX,
 };
 
@@ -107,13 +109,23 @@ static unsigned int fclk_table[] = { /* unit: MHz */
 /* GXTVBB */
 /* freq max=666M, default=666M */
 #define CLK_LEVEL_DFT_GXTVBB     7
-#define CLK_LEVEL_MAX_GTVXBB     8
+#define CLK_LEVEL_MAX_GXTVBB     8
 #define FCLK_TYPE_GXTVBB         FCLK_2000M
 /* GXL */
 /* freq max=666M, default=666M */
 #define CLK_LEVEL_DFT_GXL     7
 #define CLK_LEVEL_MAX_GXL     8
 #define FCLK_TYPE_GXL         FCLK_2000M
+/* GXM */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_GXM     7
+#define CLK_LEVEL_MAX_GXM     8
+#define FCLK_TYPE_GXM         FCLK_2000M
+/* TXL */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_TXL     7
+#define CLK_LEVEL_MAX_TXL     8
+#define FCLK_TYPE_TXL         FCLK_2000M
 
 /* vpu clk setting */
 enum vpu_mux_e {
@@ -149,7 +161,7 @@ static unsigned int vpu_clk_table[2][12][3] = {/* compatible for all chip */
 		{696000000,    GPLL_CLK,     0}, /* 8 */ /* G9TV use gp1_pll */
 		{850000000,    FCLK_DIV3,    0}, /* 9 */
 	},
-	{ /* gxbb, gxtvbb, fpll=2000M */
+	{ /* gxbb, gxtvbb, gxl, txl, fpll=2000M */
 		/* frequency   clk_mux       div */
 		{100000000,    FCLK_DIV5,    3}, /* 0 */
 		{166667000,    FCLK_DIV3,    3}, /* 1 */
diff --git a/fip/gxtvbb/bl31.img b/fip/gxtvbb/bl31.img
new file mode 100644
index 0000000..e69de29
diff --git a/fip/txl/aml_encrypt_txl b/fip/txl/aml_encrypt_txl
new file mode 100644
index 0000000..e69de29
diff --git a/fip/txl/bl2.bin b/fip/txl/bl2.bin
new file mode 100644
index 0000000..e69de29
diff --git a/fip/txl/bl30.bin b/fip/txl/bl30.bin
new file mode 100644
index 0000000..e69de29
diff --git a/fip/txl/bl31.bin b/fip/txl/bl31.bin
new file mode 100644
index 0000000..e69de29
diff --git a/include/amlogic/aml_lcd_vout.h b/include/amlogic/aml_lcd_vout.h
index 043c81f..70f4a37 100644
--- a/include/amlogic/aml_lcd_vout.h
+++ b/include/amlogic/aml_lcd_vout.h
@@ -87,13 +87,14 @@ enum lcd_mode_e {
 
 enum lcd_chip_e {
 	LCD_CHIP_M6 = 0,
-	LCD_CHIP_M8,
-	LCD_CHIP_M8B,
-	LCD_CHIP_M8M2,
-	LCD_CHIP_G9TV,
-	LCD_CHIP_G9BB,
-	LCD_CHIP_GXTVBB,
-	LCD_CHIP_MAX,
+	LCD_CHIP_M8,     /* 1 */
+	LCD_CHIP_M8B,    /* 2 */
+	LCD_CHIP_M8M2,   /* 3 */
+	LCD_CHIP_G9TV,   /* 4 */
+	LCD_CHIP_G9BB,   /* 5 */
+	LCD_CHIP_GXTVBB, /* 6 */
+	LCD_CHIP_TXL,    /* 7 */
+	LCD_CHIP_MAX,    /* 8 */
 };
 
 enum lcd_type_e {
@@ -115,14 +116,26 @@ struct lcd_basic_s {
 	unsigned short v_active; /* Vertical display area */
 	unsigned short h_period; /* Horizontal total period time */
 	unsigned short v_period; /* Vertical total period time */
+	unsigned short h_period_min;
+	unsigned short h_period_max;
+	unsigned short v_period_min;
+	unsigned short v_period_max;
+	unsigned int lcd_clk_min;
+	unsigned int lcd_clk_max;
 
 	unsigned short screen_width;  /* screen physical width in "mm" unit */
 	unsigned short screen_height; /* screen physical height in "mm" unit */
 };
 
+#define LCD_CLK_FRAC_UPDATE     (1 << 0)
+#define LCD_CLK_PLL_CHANGE      (1 << 1)
 struct lcd_timing_s {
 	unsigned char clk_auto; /* clk parameters auto generation */
 	unsigned int lcd_clk;   /* pixel clock(unit: Hz) */
+	unsigned int lcd_clk_dft; /* internal used */
+	unsigned int h_period_dft; /* internal used */
+	unsigned int v_period_dft; /* internal used */
+	unsigned char clk_change; /* internal used */
 	unsigned int pll_ctrl;  /* pll settings */
 	unsigned int div_ctrl;  /* divider settings */
 	unsigned int clk_ctrl;  /* clock settings */
@@ -184,8 +197,10 @@ struct ttl_config_s {
 	unsigned int swap_ctrl; /* [1]rb swap, [0]bit swap */
 };
 
-#define LVDS_PHY_VSWING_DFT    3
-#define LVDS_PHY_PREEM_DFT     0
+#define LVDS_PHY_VSWING_DFT        3
+#define LVDS_PHY_PREEM_DFT         0
+#define LVDS_PHY_CLK_VSWING_DFT    0
+#define LVDS_PHY_CLK_PREEM_DFT     0
 struct lvds_config_s {
 	unsigned int lvds_vswing;
 	unsigned int lvds_repack;
@@ -195,6 +210,8 @@ struct lvds_config_s {
 	unsigned int port_sel;
 	unsigned int phy_vswing;
 	unsigned int phy_preem;
+	unsigned int phy_clk_vswing;
+	unsigned int phy_clk_preem;
 };
 
 #define VX1_PHY_VSWING_DFT    3
diff --git a/include/amlogic/aml_ldim.h b/include/amlogic/aml_ldim.h
index 3535ee5..3a4b7d7 100644
--- a/include/amlogic/aml_ldim.h
+++ b/include/amlogic/aml_ldim.h
@@ -21,10 +21,19 @@
 #include <amlogic/aml_lcd.h>
 #include <spi.h>
 
+enum ldim_dev_type_e {
+	LDIM_DEV_TYPE_NORMAL = 0,
+	LDIM_DEV_TYPE_SPI,
+	LDIM_DEV_TYPE_I2C,
+	LDIM_DEV_TYPE_MAX,
+};
+
 #define LDIM_SPI_INIT_ON_SIZE     300
 #define LDIM_SPI_INIT_OFF_SIZE    20
 struct ldim_dev_config_s {
 	char name[20];
+	char pinmux_name[20];
+	unsigned char type;
 	int cs_hold_delay;
 	int cs_clk_delay;
 	int en_gpio;
@@ -44,12 +53,22 @@ struct ldim_dev_config_s {
 	char gpio_name[BL_GPIO_NUM_MAX][LCD_CPU_GPIO_NAME_MAX];
 };
 
+struct ldim_spi_dev_info_s {
+	char modalias[20];
+	int mode;
+	int max_speed_hz;
+	int bus_num;
+	int chip_select;
+
+	struct spi_slave *spi;
+};
+
 /*******global API******/
 struct aml_ldim_driver_s {
 	int valid_flag;
 	int dev_index;
 	struct ldim_dev_config_s *ldev_conf;
-	unsigned short *ldim_matrix_2_spi;
+	unsigned short *ldim_matrix_buf;
 	int (*power_on)(void);
 	int (*power_off)(void);
 	int (*set_level)(unsigned int level);
@@ -58,7 +77,7 @@ struct aml_ldim_driver_s {
 	int (*device_power_on)(void);
 	int (*device_power_off)(void);
 	int (*device_bri_update)(unsigned short *buf, unsigned char len);
-	struct spi_slave *spi;
+	struct ldim_spi_dev_info_s *spi_dev;
 };
 
 extern struct aml_ldim_driver_s *aml_ldim_get_driver(void);
diff --git a/include/amlogic/amlkey_if.h b/include/amlogic/amlkey_if.h
index 12cfa34..5cac2a0 100644
--- a/include/amlogic/amlkey_if.h
+++ b/include/amlogic/amlkey_if.h
@@ -14,21 +14,32 @@
 
 #define AMLKEY_NAME_LEN_MAX     (80)
 //1.init
-	int32_t amlkey_init(uint8_t *seed, uint32_t len);	//confirm
-//2. query if the key already programmed
-	int32_t amlkey_isexsit(const uint8_t * name);	//exsit 1, non 0
-//3. query if the prgrammed key is secure
-	int32_t amlkey_issecure(const uint8_t * name);	//secure 1, non 0
+int32_t amlkey_init(uint8_t *seed, uint32_t len);
+
+//2. query if the key already programmed, exsit 1, non 0
+int32_t amlkey_isexsit(const uint8_t * name);
+
+//3. query attr, key must exsit before those functions were called.
+	//3.1 whether the prgrammed key is secure, secure 1, non 0
+int32_t amlkey_issecure(const uint8_t * name);
+	//3.2 whether the prgrammed key is encrypt, encrypt 1, non 0
+int32_t amlkey_isencrypt(const uint8_t * name);
+
 //4. actual bytes of key value
-	ssize_t amlkey_size(const uint8_t *name);	//actully size
+ssize_t amlkey_size(const uint8_t *name);
+
 //5. read non-secure key in bytes, return byets readback actully.
-	ssize_t amlkey_read(const uint8_t *name, uint8_t *buffer, uint32_t len)	;
+ssize_t amlkey_read(const uint8_t *name, uint8_t *buffer, uint32_t len)	;
 
-//6.write secure/non-secure key in bytes , return byets readback actully
-	ssize_t amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_t secure);	//
+//6.write key with attribute in bytes , return byets readback actully
+	//attr: bit0: secure/non-secure;
+	//		bit8: encrypt/non-encrypt
+#define UNIFYKEY_ATTR_SECURE_MASK	(1<<0)
+#define UNIFYKEY_ATTR_ENCRYPT_MASK	(1<<8)
+ssize_t amlkey_write(const uint8_t *name, uint8_t *buffer, uint32_t len, uint32_t attr);
 
 //7. get the hash value of programmed secure key | 32bytes length, sha256
-	int32_t amlkey_hash_4_secure(const uint8_t * name, uint8_t * hash);
+int32_t amlkey_hash_4_secure(const uint8_t * name, uint8_t * hash);
 
 #endif// #ifndef __AMLKEY_IF_H__
 
diff --git a/include/amlogic/secure_storage.h b/include/amlogic/secure_storage.h
index 288c4ef..4e6c3ee 100644
--- a/include/amlogic/secure_storage.h
+++ b/include/amlogic/secure_storage.h
@@ -29,6 +29,7 @@ int32_t secure_storage_verify(uint8_t *keyname, uint8_t *hashbuf);
 int32_t secure_storage_status(uint8_t *keyname, uint32_t *retval);
 void *secure_storage_getbuffer(uint32_t *size);
 void secure_storage_notifier(void);
+void secure_storage_notifier_ex(uint32_t storagesize, uint32_t rsvarg);
 int32_t secure_storage_list(uint8_t *listbuf, uint32_t buflen,
 				uint32_t *readlen);
 int32_t secure_storage_remove(uint8_t *keyname);
diff --git a/include/amlogic/sound.h b/include/amlogic/sound.h
new file mode 100644
index 0000000..4aceb7c
--- /dev/null
+++ b/include/amlogic/sound.h
@@ -0,0 +1,180 @@
+/*
+ * include/amlogic/sound.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _SOUND_H_
+#define _SOUND_H_
+
+#define AIU_958_BPF			0x1500
+#define AIU_958_BRST		0x1501
+#define AIU_958_LENGTH		0x1502
+#define AIU_958_PADDSIZE	0x1503
+#define AIU_958_MISC		0x1504
+#define AIU_958_FORCE_LEFT	0x1505
+#define AIU_958_DISCARD_NUM	0x1506
+#define AIU_958_DCU_FF_CTRL	0x1507
+#define AIU_958_CHSTAT_L0	0x1508
+#define AIU_958_CHSTAT_L1	0x1509
+#define AIU_958_CTRL		0x150a
+#define AIU_958_RPT			0x150b
+#define AIU_I2S_MUTE_SWAP	0x150c
+#define AIU_I2S_SOURCE_DESC	0x150d
+#define AIU_I2S_MED_CTRL	0x150e
+#define AIU_I2S_MED_THRESH	0x150f
+#define AIU_I2S_DAC_CFG		0x1510
+#define AIU_I2S_SYNC		0x1511
+#define AIU_I2S_MISC		0x1512
+#define AIU_I2S_OUT_CFG		0x1513
+#define AIU_I2S_FF_CTRL		0x1514
+#define AIU_RST_SOFT		0x1515
+#define AIU_CLK_CTRL		0x1516
+#define AIU_MIX_ADCCFG		0x1517
+#define AIU_MIX_CTRL		0x1518
+#define AIU_CLK_CTRL_MORE	0x1519
+#define AIU_958_POP			0x151a
+#define AIU_MIX_GAIN		0x151b
+#define AIU_958_SYNWORD1	0x151c
+#define AIU_958_SYNWORD2	0x151d
+#define AIU_958_SYNWORD3	0x151e
+#define AIU_958_SYNWORD1_MASK	0x151f
+#define AIU_958_SYNWORD2_MASK	0x1520
+#define AIU_958_SYNWORD3_MASK	0x1521
+#define AIU_958_FFRDOUT_THD		0x1522
+#define AIU_958_LENGTH_PER_PAUSE	0x1523
+#define AIU_958_PAUSE_NUM		0x1524
+#define AIU_958_PAUSE_PAYLOAD	0x1525
+#define AIU_958_AUTO_PAUSE		0x1526
+#define AIU_958_PAUSE_PD_LENGTH	0x1527
+#define AIU_CODEC_DAC_LRCLK_CTRL	0x1528
+#define AIU_CODEC_ADC_LRCLK_CTRL	0x1529
+#define AIU_HDMI_CLK_DATA_CTRL		0x152a
+#define AIU_CODEC_CLK_DATA_CTRL		0x152b
+#define AIU_ACODEC_CTRL			0x152c
+#define AIU_958_CHSTAT_R0		0x1530
+#define AIU_958_CHSTAT_R1		0x1531
+#define AIU_958_VALID_CTRL		0x1532
+#define AIU_AUDIO_AMP_REG0		0x153c
+#define AIU_AUDIO_AMP_REG1		0x153d
+#define AIU_AUDIO_AMP_REG2		0x153e
+#define AIU_AUDIO_AMP_REG3		0x153f
+#define AIU_AIFIFO2_CTRL		0x1540
+#define AIU_AIFIFO2_STATUS		0x1541
+#define AIU_AIFIFO2_GBIT		0x1542
+#define AIU_AIFIFO2_CLB			0x1543
+#define AIU_CRC_CTRL			0x1544
+#define AIU_CRC_STATUS			0x1545
+#define AIU_CRC_SHIFT_REG		0x1546
+#define AIU_CRC_IREG			0x1547
+#define AIU_CRC_CAL_REG1		0x1548
+#define AIU_CRC_CAL_REG0		0x1549
+#define AIU_CRC_POLY_COEF1		0x154a
+#define AIU_CRC_POLY_COEF0		0x154b
+#define AIU_CRC_BIT_SIZE1		0x154c
+#define AIU_CRC_BIT_SIZE0		0x154d
+#define AIU_CRC_BIT_CNT1		0x154e
+#define AIU_CRC_BIT_CNT0		0x154f
+#define AIU_AMCLK_GATE_HI		0x1550
+#define AIU_AMCLK_GATE_LO		0x1551
+#define AIU_AMCLK_MSR			0x1552
+#define AIU_AUDAC_CTRL0			0x1553
+#define AIU_DELTA_SIGMA0		0x1555
+#define AIU_DELTA_SIGMA1		0x1556
+#define AIU_DELTA_SIGMA2		0x1557
+#define AIU_DELTA_SIGMA3		0x1558
+#define AIU_DELTA_SIGMA4		0x1559
+#define AIU_DELTA_SIGMA5		0x155a
+#define AIU_DELTA_SIGMA6		0x155b
+#define AIU_DELTA_SIGMA7		0x155c
+#define AIU_DELTA_SIGMA_LCNTS	0x155d
+#define AIU_DELTA_SIGMA_RCNTS	0x155e
+#define AIU_MEM_I2S_START_PTR	0x1560
+#define AIU_MEM_I2S_RD_PTR		0x1561
+#define AIU_MEM_I2S_END_PTR		0x1562
+#define AIU_MEM_I2S_MASKS		0x1563
+#define AIU_MEM_I2S_CONTROL		0x1564
+#define AIU_MEM_IEC958_START_PTR	0x1565
+#define AIU_MEM_IEC958_RD_PTR		0x1566
+#define AIU_MEM_IEC958_END_PTR		0x1567
+#define AIU_MEM_IEC958_MASKS		0x1568
+#define AIU_MEM_IEC958_CONTROL		0x1569
+#define AIU_MEM_AIFIFO2_START_PTR	0x156a
+#define AIU_MEM_AIFIFO2_CURR_PTR	0x156b
+#define AIU_MEM_AIFIFO2_END_PTR		0x156c
+#define AIU_MEM_AIFIFO2_BYTES_AVAIL	0x156d
+#define AIU_MEM_AIFIFO2_CONTROL		0x156e
+#define AIU_MEM_AIFIFO2_MAN_WP		0x156f
+#define AIU_MEM_AIFIFO2_MAN_RP		0x1570
+#define AIU_MEM_AIFIFO2_LEVEL		0x1571
+#define AIU_MEM_AIFIFO2_BUF_CNTL	0x1572
+#define AIU_MEM_I2S_MAN_WP		0x1573
+#define AIU_MEM_I2S_MAN_RP		0x1574
+#define AIU_MEM_I2S_LEVEL		0x1575
+#define AIU_MEM_I2S_BUF_CNTL	0x1576
+#define AIU_MEM_I2S_BUF_WRAP_COUNT	0x1577
+#define AIU_MEM_I2S_MEM_CTL			0x1578
+#define AIU_MEM_IEC958_MEM_CTL		0x1579
+#define AIU_MEM_IEC958_WRAP_COUNT	0x157a
+#define AIU_MEM_IEC958_IRQ_LEVEL	0x157b
+#define AIU_MEM_IEC958_MAN_WP		0x157c
+#define AIU_MEM_IEC958_MAN_RP		0x157d
+#define AIU_MEM_IEC958_LEVEL		0x157e
+#define AIU_MEM_IEC958_BUF_CNTL		0x157f
+#define AIU_AIFIFO_CTRL		0x1580
+#define AIU_AIFIFO_STATUS	0x1581
+#define AIU_AIFIFO_GBIT		0x1582
+#define AIU_AIFIFO_CLB		0x1583
+#define AIU_MEM_AIFIFO_START_PTR	0x1584
+#define AIU_MEM_AIFIFO_CURR_PTR		0x1585
+#define AIU_MEM_AIFIFO_END_PTR		0x1586
+#define AIU_MEM_AIFIFO_BYTES_AVAIL	0x1587
+#define AIU_MEM_AIFIFO_CONTROL		0x1588
+#define AIU_MEM_AIFIFO_MAN_WP		0x1589
+#define AIU_MEM_AIFIFO_MAN_RP		0x158a
+#define AIU_MEM_AIFIFO_LEVEL		0x158b
+#define AIU_MEM_AIFIFO_BUF_CNTL		0x158c
+#define AIU_MEM_AIFIFO_BUF_WRAP_COUNT	0x158d
+#define AIU_MEM_AIFIFO2_BUF_WRAP_COUNT	0x158e
+#define AIU_MEM_AIFIFO_MEM_CTL		0x158f
+#define AIFIFO_TIME_STAMP_CNTL		0x1590
+#define AIFIFO_TIME_STAMP_SYNC_0	0x1591
+#define AIFIFO_TIME_STAMP_SYNC_1	0x1592
+#define AIFIFO_TIME_STAMP_0			0x1593
+#define AIFIFO_TIME_STAMP_1			0x1594
+#define AIFIFO_TIME_STAMP_2			0x1595
+#define AIFIFO_TIME_STAMP_3			0x1596
+#define AIFIFO_TIME_STAMP_LENGTH	0x1597
+#define AIFIFO2_TIME_STAMP_CNTL		0x1598
+#define AIFIFO2_TIME_STAMP_SYNC_0	0x1599
+#define AIFIFO2_TIME_STAMP_SYNC_1	0x159a
+#define AIFIFO2_TIME_STAMP_0		0x159b
+#define AIFIFO2_TIME_STAMP_1		0x159c
+#define AIFIFO2_TIME_STAMP_2		0x159d
+#define AIFIFO2_TIME_STAMP_3		0x159e
+#define AIFIFO2_TIME_STAMP_LENGTH	0x159f
+#define IEC958_TIME_STAMP_CNTL		0x15a0
+#define IEC958_TIME_STAMP_SYNC_0	0x15a1
+#define IEC958_TIME_STAMP_SYNC_1	0x15a2
+#define IEC958_TIME_STAMP_0		0x15a3
+#define IEC958_TIME_STAMP_1		0x15a4
+#define IEC958_TIME_STAMP_2		0x15a5
+#define IEC958_TIME_STAMP_3		0x15a6
+#define IEC958_TIME_STAMP_LENGTH	0x15a7
+#define AIU_MEM_AIFIFO2_MEM_CTL		0x15a8
+#define AIU_I2S_CBUS_DDR_CNTL		0x15a9
+#define AIU_I2S_CBUS_DDR_WDATA		0x15aa
+#define AIU_I2S_CBUS_DDR_ADDR		0x15ab
+
+int aml_audio_init(void);
+
+#endif /* _SOUND_H_ */
diff --git a/include/amlogic/storage_if.h b/include/amlogic/storage_if.h
index 68bc7f3..1d2b6da 100644
--- a/include/amlogic/storage_if.h
+++ b/include/amlogic/storage_if.h
@@ -66,8 +66,10 @@ int store_exit(void);
 int store_dtb_rw(void* buf, unsigned dtbSz, int isWrite);
 
 //key read/write
-int store_key_read(uint8_t * buffer,  uint32_t length);
-int store_key_write(uint8_t * buffer,  uint32_t length);
+int store_key_read(uint8_t * buffer,
+			uint32_t length, uint32_t *actual_lenth);
+int store_key_write(uint8_t * buffer,
+			uint32_t length, uint32_t *actual_lenth);
 
 #endif//ifndef __STOARGE_IF_H__
 
diff --git a/include/net.h b/include/net.h
index 18d279e..a88cf84 100644
--- a/include/net.h
+++ b/include/net.h
@@ -580,9 +580,9 @@ static inline IPaddr_t NetReadIP(void *from)
 }
 
 /* return ulong *in network byteorder* */
-static inline ulong NetReadLong(ulong *from)
+static inline ulong NetReadLong(uint *from)
 {
-	ulong l;
+	uint l;
 
 	memcpy((void *)&l, (void *)from, sizeof(l));
 	return l;
@@ -601,9 +601,9 @@ static inline void NetCopyIP(void *to, void *from)
 }
 
 /* copy ulong */
-static inline void NetCopyLong(ulong *to, ulong *from)
+static inline void NetCopyLong(uint *to, uint *from)
 {
-	memcpy((void *)to, (void *)from, sizeof(ulong));
+	memcpy((void *)to, (void *)from, sizeof(uint));
 }
 
 /**
diff --git a/net/bootp.c b/net/bootp.c
index 8106601..2e89f7b 100644
--- a/net/bootp.c
+++ b/net/bootp.c
@@ -59,7 +59,7 @@ ulong		bootp_timeout;
 
 #if defined(CONFIG_CMD_DHCP)
 static dhcp_state_t dhcp_state = INIT;
-static unsigned long dhcp_leasetime;
+static unsigned int dhcp_leasetime;
 static IPaddr_t NetDHCPServerIP;
 static void DhcpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
 			unsigned len);
@@ -125,7 +125,7 @@ static int BootpCheckPkt(uchar *pkt, unsigned dest, unsigned src, unsigned len)
 		retval = -4;
 	else if (bp->bp_hlen != HWL_ETHER)
 		retval = -5;
-	else if (!bootp_match_id(NetReadLong((ulong *)&bp->bp_id)))
+	else if (!bootp_match_id(NetReadLong((uint *)&bp->bp_id)))
 		retval = -6;
 
 	debug("Filtering pkt = %d\n", retval);
@@ -350,7 +350,7 @@ BootpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
 	BootpCopyNetParams(bp);		/* Store net parameters from reply */
 
 	/* Retrieve extended information (we must parse the vendor area) */
-	if (NetReadLong((ulong *)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
+	if (NetReadLong((uint *)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
 		BootpVendorProcess((uchar *)&bp->bp_vend[4], len);
 
 	NetSetTimeout(0, (thand_f *)0);
@@ -661,7 +661,7 @@ BootpRequest(void)
 #ifdef CONFIG_BOOTP_RANDOM_DELAY
 	ulong rand_ms;
 #endif
-	ulong BootpID;
+	uint BootpID;
 
 	bootstage_mark_name(BOOTSTAGE_ID_BOOTP_START, "bootp_start");
 #if defined(CONFIG_CMD_DHCP)
@@ -730,8 +730,11 @@ BootpRequest(void)
 		| ((ulong)NetOurEther[4] << 8)
 		| (ulong)NetOurEther[5];
 	BootpID += get_timer(0);
+
 	BootpID = htonl(BootpID);
+
 	bootp_add_id(BootpID);
+
 	NetCopyLong(&bp->bp_id, &BootpID);
 
 	/*
@@ -770,7 +773,7 @@ static void DhcpOptionsProcess(uchar *popt, struct Bootp_t *bp)
 #if defined(CONFIG_CMD_SNTP) && defined(CONFIG_BOOTP_TIMEOFFSET)
 		case 2:		/* Time offset	*/
 			to_ptr = &NetTimeOffset;
-			NetCopyLong((ulong *)to_ptr, (ulong *)(popt + 2));
+			NetCopyLong((uint *)to_ptr, (uint *)(popt + 2));
 			NetTimeOffset = ntohl(NetTimeOffset);
 			break;
 #endif
@@ -806,7 +809,7 @@ static void DhcpOptionsProcess(uchar *popt, struct Bootp_t *bp)
 			break;
 #endif
 		case 51:
-			NetCopyLong(&dhcp_leasetime, (ulong *) (popt + 2));
+			NetCopyLong(&dhcp_leasetime, (uint *) (popt + 2));
 			break;
 		case 53:	/* Ignore Message Type Option */
 			break;
@@ -860,7 +863,7 @@ static void DhcpOptionsProcess(uchar *popt, struct Bootp_t *bp)
 
 static int DhcpMessageType(unsigned char *popt)
 {
-	if (NetReadLong((ulong *)popt) != htonl(BOOTP_VENDOR_MAGIC))
+	if (NetReadLong((uint *)popt) != htonl(BOOTP_VENDOR_MAGIC))
 		return -1;
 
 	popt += 4;
@@ -970,7 +973,7 @@ DhcpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
 			debug("TRANSITIONING TO REQUESTING STATE\n");
 			dhcp_state = REQUESTING;
 
-			if (NetReadLong((ulong *)&bp->bp_vend[0]) ==
+			if (NetReadLong((uint *)&bp->bp_vend[0]) ==
 						htonl(BOOTP_VENDOR_MAGIC))
 				DhcpOptionsProcess((u8 *)&bp->bp_vend[4], bp);
 
@@ -986,7 +989,7 @@ DhcpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
 		debug("DHCP State: REQUESTING\n");
 
 		if (DhcpMessageType((u8 *)bp->bp_vend) == DHCP_ACK) {
-			if (NetReadLong((ulong *)&bp->bp_vend[0]) ==
+			if (NetReadLong((uint *)&bp->bp_vend[0]) ==
 						htonl(BOOTP_VENDOR_MAGIC))
 				DhcpOptionsProcess((u8 *)&bp->bp_vend[4], bp);
 			/* Store net params from reply */
diff --git a/net/bootp.h b/net/bootp.h
index 3b95a0a..c4b507d 100644
--- a/net/bootp.h
+++ b/net/bootp.h
@@ -38,7 +38,7 @@ struct Bootp_t {
 	uchar		bp_hlen;	/* Hardware address length	*/
 # define HWL_ETHER	6
 	uchar		bp_hops;	/* Hop count (gateway thing)	*/
-	ulong		bp_id;		/* Transaction ID		*/
+	uint		bp_id;		/* Transaction ID		*/
 	ushort		bp_secs;	/* Seconds since boot		*/
 	ushort		bp_spare1;	/* Alignment			*/
 	IPaddr_t	bp_ciaddr;	/* Client IP address		*/
