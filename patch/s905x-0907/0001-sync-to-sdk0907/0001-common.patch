diff --git a/Documentation/devicetree/bindings/arm/psci.txt b/Documentation/devicetree/bindings/arm/psci.txt
index 433afe9..e80623d 100644
--- a/Documentation/devicetree/bindings/arm/psci.txt
+++ b/Documentation/devicetree/bindings/arm/psci.txt
@@ -53,3 +53,5 @@ Example:
 		cpu_on		= <0x95c10002>;
 		migrate		= <0x95c10003>;
 	};
+
+idle-state idlestate, state
diff --git a/Documentation/sysctl/vm.txt b/Documentation/sysctl/vm.txt
index 0c17688..b62a99e 100644
--- a/Documentation/sysctl/vm.txt
+++ b/Documentation/sysctl/vm.txt
@@ -42,6 +42,8 @@ Currently, these files are in /proc/sys/vm:
 - min_slab_ratio
 - min_unmapped_ratio
 - mmap_min_addr
+- mmap_rnd_bits
+- mmap_rnd_compat_bits
 - nr_hugepages
 - nr_overcommit_hugepages
 - nr_trim_pages         (only if CONFIG_MMU=n)
@@ -469,6 +471,33 @@ against future potential kernel bugs.
 
 ==============================================================
 
+mmap_rnd_bits:
+
+This value can be used to select the number of bits to use to
+determine the random offset to the base address of vma regions
+resulting from mmap allocations on architectures which support
+tuning address space randomization.  This value will be bounded
+by the architecture's minimum and maximum supported values.
+
+This value can be changed after boot using the
+/proc/sys/vm/mmap_rnd_bits tunable
+
+==============================================================
+
+mmap_rnd_compat_bits:
+
+This value can be used to select the number of bits to use to
+determine the random offset to the base address of vma regions
+resulting from mmap allocations for applications run in
+compatibility mode on architectures which support tuning address
+space randomization.  This value will be bounded by the
+architecture's minimum and maximum supported values.
+
+This value can be changed after boot using the
+/proc/sys/vm/mmap_rnd_compat_bits tunable
+
+==============================================================
+
 nr_hugepages
 
 Change the minimum size of the hugepage pool.
diff --git a/Makefile b/Makefile
index 8f441d9..4ed49ea 100644
--- a/Makefile
+++ b/Makefile
@@ -440,11 +440,8 @@ PHONY += scripts_basic
 scripts_basic:
 	$(Q)$(MAKE) $(build)=scripts/basic
 	$(Q)rm -f .tmp_quiet_recordmcount
-# Modify begin by 22230, 2016/02/25
-# For compile error
-#$(Q)cp $(srctree)/scripts/amlogic/pre-commit $(srctree)/.git/hooks/pre-commit
-#$(Q)chmod +x $(srctree)/.git/hooks/pre-commit
-# Modify end, 2016/02/25
+	$(Q)cp $(srctree)/scripts/amlogic/pre-commit $(srctree)/.git/hooks/pre-commit
+	$(Q)chmod +x $(srctree)/.git/hooks/pre-commit
 
 # To avoid any implicit rule to kick in, define an empty command.
 scripts/basic/%: scripts_basic ;
diff --git a/arch/Kconfig b/arch/Kconfig
index 34e8b91..543a0db 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -476,6 +476,84 @@ config HAVE_IRQ_EXIT_ON_IRQ_STACK
 	  in the end of an hardirq.
 	  This spares a stack switch and improves cache usage on softirq
 	  processing.
+config ARCH_HAS_ELF_RANDOMIZE
+	bool
+	help
+	  An architecture supports choosing randomized locations for
+	  stack, mmap, brk, and ET_DYN. Defined functions:
+	  - arch_mmap_rnd()
+	  - arch_randomize_brk()
+
+config HAVE_ARCH_MMAP_RND_BITS
+	bool
+	help
+	  An arch should select this symbol if it supports setting a variable
+	  number of bits for use in establishing the base address for mmap
+	  allocations, has MMU enabled and provides values for both:
+	  - ARCH_MMAP_RND_BITS_MIN
+	  - ARCH_MMAP_RND_BITS_MAX
+
+
+config ARCH_MMAP_RND_BITS_MIN
+	int
+
+config ARCH_MMAP_RND_BITS_MAX
+	int
+
+config ARCH_MMAP_RND_BITS_DEFAULT
+	int
+
+config ARCH_MMAP_RND_BITS
+	int "Number of bits to use for ASLR of mmap base address" if EXPERT
+	range ARCH_MMAP_RND_BITS_MIN ARCH_MMAP_RND_BITS_MAX
+	default ARCH_MMAP_RND_BITS_DEFAULT if ARCH_MMAP_RND_BITS_DEFAULT
+	default ARCH_MMAP_RND_BITS_MIN
+	depends on HAVE_ARCH_MMAP_RND_BITS
+	help
+	  This value can be used to select the number of bits to use to
+	  determine the random offset to the base address of vma regions
+	  resulting from mmap allocations. This value will be bounded
+	  by the architecture's minimum and maximum supported values.
+
+	  This value can be changed after boot using the
+	  /proc/sys/vm/mmap_rnd_bits tunable
+
+config HAVE_ARCH_MMAP_RND_COMPAT_BITS
+	bool
+	help
+	  An arch should select this symbol if it supports running applications
+	  in compatibility mode, supports setting a variable number of bits for
+	  use in establishing the base address for mmap allocations, has MMU
+	  enabled and provides values for both:
+	  - ARCH_MMAP_RND_COMPAT_BITS_MIN
+	  - ARCH_MMAP_RND_COMPAT_BITS_MAX
+
+config ARCH_MMAP_RND_COMPAT_BITS_MIN
+	int
+
+config ARCH_MMAP_RND_COMPAT_BITS_MAX
+	int
+
+config ARCH_MMAP_RND_COMPAT_BITS_DEFAULT
+	int
+
+config ARCH_MMAP_RND_COMPAT_BITS
+	int "Number of bits to use for ASLR of mmap base address for compatible applications" if EXPERT
+	range ARCH_MMAP_RND_COMPAT_BITS_MIN ARCH_MMAP_RND_COMPAT_BITS_MAX
+	default ARCH_MMAP_RND_COMPAT_BITS_DEFAULT if ARCH_MMAP_RND_COMPAT_BITS_DEFAULT
+	default ARCH_MMAP_RND_COMPAT_BITS_MIN
+	depends on HAVE_ARCH_MMAP_RND_COMPAT_BITS
+	help
+	  This value can be used to select the number of bits to use to
+	  determine the random offset to the base address of vma regions
+	  resulting from mmap allocations for compatible applications This
+	  value will be bounded by the architecture's minimum and maximum
+	  supported values.
+
+	  This value can be changed after boot using the
+	  /proc/sys/vm/mmap_rnd_compat_bits tunable
+
+
 
 #
 # ABI hall of shame
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index eab1536..5a228a8 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -3,6 +3,7 @@ config ARM
 	default y
 	select ARCH_BINFMT_ELF_RANDOMIZE_PIE
 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
+	select ARCH_HAS_ELF_RANDOMIZE
 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
 	select ARCH_HAVE_CUSTOM_GPIO_H
 	select ARCH_MIGHT_HAVE_PC_PARPORT
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index d62784e..42d46a6 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -1,6 +1,7 @@
 config ARM64
 	def_bool y
 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
+	select ARCH_HAS_ELF_RANDOMIZE
 	select ARCH_USE_CMPXCHG_LOCKREF
 	select ARCH_SUPPORTS_ATOMIC_RMW
 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
@@ -34,6 +35,8 @@ config ARM64
 	select HAVE_ARCH_AUDITSYSCALL
 	select HAVE_ARCH_JUMP_LABEL
 	select HAVE_ARCH_KGDB
+	select HAVE_ARCH_MMAP_RND_BITS
+	select HAVE_ARCH_MMAP_RND_COMPAT_BITS if COMPAT
 	select HAVE_ARCH_SECCOMP_FILTER
 	select HAVE_ARCH_TRACEHOOK
 	select HAVE_C_RECORDMCOUNT
@@ -83,6 +86,33 @@ config ARCH_PHYS_ADDR_T_64BIT
 config MMU
 	def_bool y
 
+config ARCH_MMAP_RND_BITS_MIN
+       default 14 if ARM64_64K_PAGES
+       default 16 if ARM64_16K_PAGES
+       default 18
+
+# max bits determined by the following formula:
+#  VA_BITS - PAGE_SHIFT - 3
+config ARCH_MMAP_RND_BITS_MAX
+       default 19 if ARM64_VA_BITS=36
+       default 24 if ARM64_VA_BITS=39
+       default 27 if ARM64_VA_BITS=42
+       default 30 if ARM64_VA_BITS=47
+       default 29 if ARM64_VA_BITS=48 && ARM64_64K_PAGES
+       default 31 if ARM64_VA_BITS=48 && ARM64_16K_PAGES
+       default 33 if ARM64_VA_BITS=48
+       default 14 if ARM64_64K_PAGES
+       default 16 if ARM64_16K_PAGES
+       default 18
+
+config ARCH_MMAP_RND_COMPAT_BITS_MIN
+       default 7 if ARM64_64K_PAGES
+       default 9 if ARM64_16K_PAGES
+       default 11
+
+config ARCH_MMAP_RND_COMPAT_BITS_MAX
+       default 16
+
 config NO_IOPORT
 	def_bool y
 
diff --git a/arch/arm64/boot/dts/amlogic/gxbb_p200.dts b/arch/arm64/boot/dts/amlogic/gxbb_p200.dts
index cdc896e..37ce484 100644
--- a/arch/arm64/boot/dts/amlogic/gxbb_p200.dts
+++ b/arch/arm64/boot/dts/amlogic/gxbb_p200.dts
@@ -408,6 +408,33 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+        compatible = "amlogic, aml_sd_emmc";
+        dev_name = "aml_newsd.0";
+        status = "okay";
+        reg = <0x0 0xd0074000 0x0 0x2000>;
+        interrupts = <	0 218 1>;
+        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+        pinctrl-0 = <&emmc_clk_cmd_pins>;
+        pinctrl-1 = <&emmc_all_pins>;
+        emmc{
+            status = "okay";
+            pinname = "emmc";
+            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+			"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+			"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+            caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+            f_max = <200000000>;
+			tx_phase = <0>;
+            max_req_size = <0x20000>;          /**256KB*/
+//            gpio_dat3 = "BOOT_3"
+		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+    };
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -452,33 +479,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-			"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-			"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <200000000>;
-			tx_phase = <0>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-		};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -919,9 +919,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -946,6 +946,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxbb_p200_2G.dts b/arch/arm64/boot/dts/amlogic/gxbb_p200_2G.dts
index 8b694b8..4fcf4fe 100644
--- a/arch/arm64/boot/dts/amlogic/gxbb_p200_2G.dts
+++ b/arch/arm64/boot/dts/amlogic/gxbb_p200_2G.dts
@@ -381,6 +381,33 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <200000000>;
+			tx_phase = <0>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -421,33 +448,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-			"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-			"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <200000000>;
-			tx_phase = <0>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -870,9 +870,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -897,6 +897,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxbb_p200_iptv.dts b/arch/arm64/boot/dts/amlogic/gxbb_p200_iptv.dts
index ffacaab..f78a3ce 100644
--- a/arch/arm64/boot/dts/amlogic/gxbb_p200_iptv.dts
+++ b/arch/arm64/boot/dts/amlogic/gxbb_p200_iptv.dts
@@ -382,6 +382,33 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <200000000>;
+			tx_phase = <0>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -422,33 +449,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-			"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-			"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <200000000>;
-			tx_phase = <0>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -872,9 +872,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -899,6 +899,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxbb_p201.dts b/arch/arm64/boot/dts/amlogic/gxbb_p201.dts
index e76f1ff..f7f1796 100644
--- a/arch/arm64/boot/dts/amlogic/gxbb_p201.dts
+++ b/arch/arm64/boot/dts/amlogic/gxbb_p201.dts
@@ -382,6 +382,32 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <200000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -423,32 +449,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-	emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-			"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-			"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <200000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-		};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -834,9 +834,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -861,6 +861,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxbb_skt.dts b/arch/arm64/boot/dts/amlogic/gxbb_skt.dts
index f246ea1..df7fa6a 100644
--- a/arch/arm64/boot/dts/amlogic/gxbb_skt.dts
+++ b/arch/arm64/boot/dts/amlogic/gxbb_skt.dts
@@ -349,6 +349,32 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			f_min = <300000>;
+			f_max = <200000000>;
+			tx_phase = <0>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -382,33 +408,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <200000000>;
-			tx_phase = <0>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -849,9 +848,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -876,6 +875,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -1039,8 +1043,8 @@
 
 &pinmux {
 	audio_pins:audio_pin{
-		amlogic,setmask=<AO 0x78000000>;
-		amlogic,clrmask=<AO 0x50000>;
+               amlogic,setmask=<AO 0x78000000>;
+               amlogic,clrmask=<AO 0x50000>;
 		amlogic,pins = "GPIOAO_8","GPIOAO_9","GPIOAO_10","GPIOAO_11","GPIOAO_6";
 	};
 
diff --git a/arch/arm64/boot/dts/amlogic/gxl_p212_1g.dts b/arch/arm64/boot/dts/amlogic/gxl_p212_1g.dts
index 4980e26..7260c84 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_p212_1g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_p212_1g.dts
@@ -40,7 +40,7 @@
 	};
 	memory@00000000 {
 		device_type = "memory";
-		linux,usable-memory = <0x0 0x1000000 0x0 0x3f000000>;
+		linux,usable-memory = <0x0 0x100000 0x0 0x3ff00000>;
 	};
 
 	reserved-memory {
@@ -95,14 +95,14 @@
 //		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
-			compatible = "amlogic, ppmgr_memory";
-			size = <0x0 0x2000000>;
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
 		};
 
 		codec_mm_cma:linux,codec_mm_cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0xd000000>;
+			size = <0x0 0xc000000>;
 			alignment = <0x0 0x400000>;
 			linux,contiguous-region;
 		};
@@ -130,7 +130,7 @@
 	sysled {
 		compatible = "amlogic, sysled";
 		dev_name = "sysled";
-		status = "disable";
+		status = "okay";
 		led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_HIGH>;
 		led_active_low = <1>;
 	};
@@ -203,6 +203,8 @@
 						0x0 0xc8834558 0x0 0xc>;
 						interrupts = <0 8 1>;
 						phy-mode= "rmii";
+						pinctrl-names = "internal_eth_pins";
+						pinctrl-0 = <&internal_eth_pins>;
 						mc_val = <0x1800>;
 						resets = <&clock GCLK_IDX_ETHERNET>;
 						reset-names = "ethpower";
@@ -386,6 +388,31 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -424,31 +451,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -518,7 +520,7 @@
 					};
 	};*/
 	partitions: partitions{
-        parts = <12>;
+        parts = <11>;
 		part-0 = <&logo>;
 		part-1 = <&recovery>;
 		part-2 = <&rsv>;
@@ -529,8 +531,7 @@
 		part-7 = <&boot>;
 		part-8 = <&system>;
 		part-9 = <&cache>;
-		part-10 = <&ghost>;
-		part-11 = <&data>;
+		part-10 = <&data>;
 
 		logo:logo{
 			pname = "logo";
@@ -564,7 +565,7 @@
 		};
 		instaboot:instaboot{
 			pname = "instaboot";
-			size = <0x0 0x800000>;
+			size = <0x0 0x20000000>;
 			mask = <1>;
 		};
 		boot:boot
@@ -576,7 +577,7 @@
 		system:system
 		{
 			pname = "system";
-			size = <0x0 0x30000000>;
+			size = <0x0 0x40000000>;
 			mask = <1>;
 		};
 		cache:cache
@@ -585,12 +586,6 @@
 			size = <0x0 0x20000000>;
 			mask = <2>;
 		};
-		ghost:ghost
-		{
-			pname = "ghost";
-			size = <0x0 0x20000000>;
-			mask = <4>;
-		};
 		data:data
 		{
 			pname = "data";
@@ -907,9 +902,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -934,6 +929,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -977,6 +977,7 @@
 
 		mute_gpio-gpios = <&gpio GPIOH_5 0>;
 		mute_inv;
+		sleep_time = <100>;
 		hp_disable;
 		hp_paraments = <800 300 0 5 1>;
 		pinctrl-names = "aml_snd_m8";
@@ -1016,57 +1017,46 @@
 		irq_keyup = <6>;
 		irq_keydown = <7>;
 	};
-	ledlight{
-                compatible = "amlogic, ledlight";
-                dev_name = "ledlight";
-                status = "okay";
-                power_gpio_0 = <&power_gpio_0>;
-                net_gpio_0 = <&net_gpio_0>;
-                net_gpio_1 = <&net_gpio_1>;
-                ir_gpio_0 = <&ir_gpio_0>;
-
-            power_gpio_0: gpio_rg{
-                    led_name = "power_led";
-                    led_gpio = <&gpio  GPIODV_24  GPIO_ACTIVE_HIGH>;
-                    led_active = <0>;
-                    led_type = "R&G";
-            };
-			//modified by Gavin.lei ,@2015-12-31, fix bug of net led will flash when system wakes up, begin
-            net_gpio_0: gpio_r{
-                    led_name = "net_led";
-                    led_gpio = <&gpio  GPIODV_27  GPIO_ACTIVE_HIGH>;
-                    led_active = <0>;
-                    led_type = "R";
-            };
-
-            net_gpio_1: gpio_g{
-                    led_name = "net_led";
-                    led_gpio = <&gpio  GPIODV_26  GPIO_ACTIVE_HIGH>;
-                    led_active = <0>;
-                    led_type = "G";
-            };
-			//modified by Gavin.lei ,@2015-12-31, fix bug of net led will flash when system wakes up, end
-            ir_gpio_0: gpio_b{
-                    led_name = "ir_led";
-                    led_gpio = <&gpio_ao  GPIOAO_3  GPIO_ACTIVE_HIGH>;
-                    led_active = <0>;
-                    led_type = "B";
-            };
-    	};
 	aml_sensor0: aml-sensor@0 {
 		compatible = "amlogic, aml-thermal";
 		device_name = "thermal";
 		#thermal-sensor-cells = <1>;
-		cpu_dyn_coeff = <140>;
-		/* cpu_freq gpu_freq cpu_core gpu_core */
-		min_state = <1000000 400 1 2>;
-		gpu_dyn_coeff = <437>;
-	};
-	cpucore:thermal_cpu_cores {
-		#cooling-cells = <2>; /* min followed by max */
-	};
-	gpucore:thermal_gpu_cores {
-		#cooling-cells = <2>; /* min followed by max */
+		cooling_devices {
+			cpufreq_cool_cluster0 {
+				min_state = <1000000>;
+				dyn_coeff = <140>;
+				cluster_id = <0>;
+				node_name = "cpus";
+				device_type = "cpufreq";
+			};
+			cpucore_cool_cluster0 {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "cpu_core_cluster0";
+				device_type = "cpucore";
+			};
+			gpufreq_cool {
+				min_state = <400>;
+				dyn_coeff = <437>;
+				cluster_id = <0>;
+				node_name = "mali";
+				device_type = "gpufreq";
+			};
+			gpucore_cool {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "thermal_gpu_cores";
+				device_type = "gpucore";
+			};
+		};
+		cpu_cluster0:cpu_core_cluster0 {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+		gpucore:thermal_gpu_cores {
+			#cooling-cells = <2>; /* min followed by max */
+		};
 	};
 	thermal-zones {
 		soc_thermal {
@@ -1107,7 +1097,7 @@
 				};
 				cpucore_cooling_map {
 					trip = <&control>;
-					cooling-device = <&cpucore 0 3>;
+					cooling-device = <&cpu_cluster0 0 3>;
 					contribution = <1024>;
 				};
 				gpufreq_cooling_map {
diff --git a/arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts b/arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts
index 5c3f0a5..196eeeb 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts
@@ -41,7 +41,7 @@
 
 	memory@00000000 {
 		device_type = "memory";
-		linux,usable-memory = <0x0 0x1000000 0x0 0x7f000000>;
+		linux,usable-memory = <0x0 0x100000 0x0 0x7ff00000>;
 	};
 
 	reserved-memory {
@@ -79,7 +79,7 @@
 
 		ion_reserved:linux,ion-dev {
 			compatible = "amlogic, idev-mem";
-			size = <0x0 0x2000000>;
+			size = <0x0 0x3000000>;
 		};
 
 		/*  vdin0 */
@@ -96,14 +96,14 @@
 //		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
-			compatible = "amlogic, ppmgr_memory";
-			size = <0x0 0x2000000>;
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
 		};
 
 		codec_mm_cma:linux,codec_mm_cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0xd000000>;
+			size = <0x0 0xc000000>;
 			alignment = <0x0 0x400000>;
 			linux,contiguous-region;
 		};
@@ -131,7 +131,7 @@
 	sysled {
 		compatible = "amlogic, sysled";
 		dev_name = "sysled";
-		status = "disable";
+		status = "okay";
 		led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_HIGH>;
 		led_active_low = <1>;
 	};
@@ -204,6 +204,8 @@
 						0x0 0xc8834558 0x0 0xc>;
 						interrupts = <0 8 1>;
 						phy-mode= "rmii";
+						pinctrl-names = "internal_eth_pins";
+						pinctrl-0 = <&internal_eth_pins>;
 						mc_val = <0x1800>;
 						resets = <&clock GCLK_IDX_ETHERNET>;
 						reset-names = "ethpower";
@@ -387,6 +389,31 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -425,31 +452,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -519,7 +521,7 @@
 					};
 	};*/
 	partitions: partitions{
-        parts = <12>;
+        parts = <11>;
 		part-0 = <&logo>;
 		part-1 = <&recovery>;
 		part-2 = <&rsv>;
@@ -530,8 +532,7 @@
 		part-7 = <&boot>;
 		part-8 = <&system>;
 		part-9 = <&cache>;
-		part-10 = <&ghost>;
-		part-11 = <&data>;
+		part-10 = <&data>;
 
 		logo:logo{
 			pname = "logo";
@@ -565,7 +566,7 @@
 		};
 		instaboot:instaboot{
 			pname = "instaboot";
-			size = <0x0 0x800000>;
+			size = <0x0 0x20000000>;
 			mask = <1>;
 		};
 		boot:boot
@@ -577,7 +578,7 @@
 		system:system
 		{
 			pname = "system";
-			size = <0x0 0x30000000>;
+			size = <0x0 0x40000000>;
 			mask = <1>;
 		};
 		cache:cache
@@ -586,12 +587,6 @@
 			size = <0x0 0x20000000>;
 			mask = <2>;
 		};
-		ghost:ghost
-		{
-			pname = "ghost";
-			size = <0x0 0x20000000>;
-			mask = <4>;
-		};
 		data:data
 		{
 			pname = "data";
@@ -908,9 +903,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -935,6 +930,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -978,6 +978,7 @@
 
 		mute_gpio-gpios = <&gpio GPIOH_5 0>;
 		mute_inv;
+		sleep_time = <100>;
 		hp_disable;
 		hp_paraments = <800 300 0 5 1>;
 		pinctrl-names = "aml_snd_m8";
@@ -1017,43 +1018,6 @@
 		irq_keyup = <6>;
 		irq_keydown = <7>;
 	};
-	ledlight{
-                compatible = "amlogic, ledlight";
-                dev_name = "ledlight";
-                status = "okay";
-                power_gpio_0 = <&power_gpio_0>;
-                net_gpio_0 = <&net_gpio_0>;
-                net_gpio_1 = <&net_gpio_1>;
-                ir_gpio_0 = <&ir_gpio_0>;
-
-            power_gpio_0: gpio_rg{
-                    led_name = "power_led";
-                    led_gpio = <&gpio  GPIODV_24  GPIO_ACTIVE_HIGH>;
-                    led_active = <0>;
-                    led_type = "R&G";
-            };
-			//modified by Gavin.lei ,@2015-12-31, fix bug of net led will flash when system wakes up, begin
-            net_gpio_0: gpio_r{
-                    led_name = "net_led";
-                    led_gpio = <&gpio  GPIODV_27  GPIO_ACTIVE_HIGH>;
-                    led_active = <0>;
-                    led_type = "R";
-            };
-
-            net_gpio_1: gpio_g{
-                    led_name = "net_led";
-                    led_gpio = <&gpio  GPIODV_26  GPIO_ACTIVE_HIGH>;
-                    led_active = <0>;
-                    led_type = "G";
-            };
-			//modified by Gavin.lei ,@2015-12-31, fix bug of net led will flash when system wakes up, end
-            ir_gpio_0: gpio_b{
-                    led_name = "ir_led";
-                    led_gpio = <&gpio_ao  GPIOAO_3  GPIO_ACTIVE_HIGH>;
-                    led_active = <0>;
-                    led_type = "B";
-            };
-    	};
 	aml_sensor0: aml-sensor@0 {
 		compatible = "amlogic, aml-thermal";
 		device_name = "thermal";
diff --git a/arch/arm64/boot/dts/amlogic/gxl_p230_2g.dts b/arch/arm64/boot/dts/amlogic/gxl_p230_2g.dts
index 4320ab8..0b7ce9e 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_p230_2g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_p230_2g.dts
@@ -40,7 +40,7 @@
 	};
 	memory@00000000 {
 		device_type = "memory";
-		linux,usable-memory = <0x0 0x1000000 0x0 0x7f000000>;
+		linux,usable-memory = <0x0 0x100000 0x0 0x7ff00000>;
 	};
 
 	reserved-memory {
@@ -95,14 +95,14 @@
 //		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
-			compatible = "amlogic, ppmgr_memory";
-			size = <0x0 0x2000000>;
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
 		};
 
 		codec_mm_cma:linux,codec_mm_cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0xd000000>;
+			size = <0x0 0xc000000>;
 			alignment = <0x0 0x400000>;
 			linux,contiguous-region;
 		};
@@ -204,9 +204,13 @@
 			0x0 0xc8834558 0x0 0xc>;
 			interrupts = <0 8 1>;
 			phy-mode= "rgmii";
-			pinctrl-names = "eth_pins";
-			pinctrl-0 = <&eth_pins>;
+			pinctrl-names = "external_eth_pins";
+			pinctrl-0 = <&external_eth_pins>;
+			rst_pin-gpios = <&gpio GPIOZ_14 0>;
+			GPIOZ4_pin-gpios = <&gpio GPIOZ_4 0>;
+			GPIOZ5_pin-gpios = <&gpio GPIOZ_5 0>;
 			mc_val = <0x1621>;
+			cali_val = <0x20000>;
 			resets = <&clock GCLK_IDX_ETHERNET>;
 			reset-names = "ethpower";
 			interrupt-names = "macirq";
@@ -222,6 +226,8 @@
 			0x0 0xc8834558 0x0 0xc>;
 			interrupts = <0 8 1>;
 			phy-mode= "rmii";
+			pinctrl-names = "internal_eth_pins";
+			pinctrl-0 = <&internal_eth_pins>;
 			mc_val = <0x1800>;
 			resets = <&clock GCLK_IDX_ETHERNET>;
 			reset-names = "ethpower";
@@ -405,6 +411,31 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -443,31 +474,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -919,9 +925,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -946,6 +952,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -990,6 +1001,7 @@
 		mute_gpio-gpios = <&gpio GPIOH_5 0>;
 		mute_inv;
 		hp_disable;
+		sleep_time = <100>;
 		hp_paraments = <800 300 0 5 1>;
 		pinctrl-names = "aml_snd_m8";
 		pinctrl-0 = <&audio_pins>;
diff --git a/arch/arm64/boot/dts/amlogic/gxl_p231_1g.dts b/arch/arm64/boot/dts/amlogic/gxl_p231_1g.dts
index bf1cfa1..a72dcd7 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_p231_1g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_p231_1g.dts
@@ -40,7 +40,7 @@
 	};
 	memory@00000000 {
 		device_type = "memory";
-		linux,usable-memory = <0x0 0x1000000 0x0 0x3f000000>;
+		linux,usable-memory = <0x0 0x100000 0x0 0x3ff00000>;
 	};
 
 	reserved-memory {
@@ -95,14 +95,14 @@
 //		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
-			compatible = "amlogic, ppmgr_memory";
-			size = <0x0 0x2000000>;
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
 		};
 
 		codec_mm_cma:linux,codec_mm_cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0xd000000>;
+			size = <0x0 0xc000000>;
 			alignment = <0x0 0x400000>;
 			linux,contiguous-region;
 		};
@@ -203,6 +203,8 @@
 						0x0 0xc8834558 0x0 0xc>;
 						interrupts = <0 8 1>;
 						phy-mode= "rmii";
+						pinctrl-names = "internal_eth_pins";
+						pinctrl-0 = <&internal_eth_pins>;
 						mc_val = <0x1800>;
 						resets = <&clock GCLK_IDX_ETHERNET>;
 						reset-names = "ethpower";
@@ -386,6 +388,31 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -424,31 +451,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -900,9 +902,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -927,6 +929,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -971,6 +978,7 @@
 		mute_gpio-gpios = <&gpio GPIOH_5 0>;
 		mute_inv;
 		hp_disable;
+		sleep_time = <100>;
 		hp_paraments = <800 300 0 5 1>;
 		pinctrl-names = "aml_snd_m8";
 		pinctrl-0 = <&audio_pins>;
diff --git a/arch/arm64/boot/dts/amlogic/gxl_p231_2g.dts b/arch/arm64/boot/dts/amlogic/gxl_p231_2g.dts
index 9d29b66..e264453 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_p231_2g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_p231_2g.dts
@@ -40,7 +40,7 @@
 	};
 	memory@00000000 {
 		device_type = "memory";
-		linux,usable-memory = <0x0 0x1000000 0x0 0x7f000000>;
+		linux,usable-memory = <0x0 0x100000 0x0 0x7ff00000>;
 	};
 
 	reserved-memory {
@@ -95,14 +95,14 @@
 //		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
-			compatible = "amlogic, ppmgr_memory";
-			size = <0x0 0x2000000>;
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
 		};
 
 		codec_mm_cma:linux,codec_mm_cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0xd000000>;
+			size = <0x0 0xc000000>;
 			alignment = <0x0 0x400000>;
 			linux,contiguous-region;
 		};
@@ -203,6 +203,8 @@
 						0x0 0xc8834558 0x0 0xc>;
 						interrupts = <0 8 1>;
 						phy-mode= "rmii";
+						pinctrl-names = "internal_eth_pins";
+						pinctrl-0 = <&internal_eth_pins>;
 						mc_val = <0x1800>;
 						resets = <&clock GCLK_IDX_ETHERNET>;
 						reset-names = "ethpower";
@@ -386,6 +388,31 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -424,31 +451,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -900,9 +902,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -927,6 +929,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -971,6 +978,7 @@
 		mute_gpio-gpios = <&gpio GPIOH_5 0>;
 		mute_inv;
 		hp_disable;
+		sleep_time = <100>;
 		hp_paraments = <800 300 0 5 1>;
 		pinctrl-names = "aml_snd_m8";
 		pinctrl-0 = <&audio_pins>;
diff --git a/arch/arm64/boot/dts/amlogic/gxl_pxp.dts b/arch/arm64/boot/dts/amlogic/gxl_pxp.dts
index 1b70c65..2fe2b53 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_pxp.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_pxp.dts
@@ -361,6 +361,32 @@
 		irq_trigger_type = "GPIO_IRQ_HIGH";
 		power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			//caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <50000000>;
+			tx_phase = <0>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -392,32 +418,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            //caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <50000000>;
-			tx_phase = <0>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -852,9 +852,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -879,6 +879,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxl_skt.dts b/arch/arm64/boot/dts/amlogic/gxl_skt.dts
index 9986509..dd9a768 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_skt.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_skt.dts
@@ -203,6 +203,8 @@
 						0x0 0xc8834558 0x0 0xc>;
 						interrupts = <0 8 1>;
 						phy-mode= "rmii";
+						pinctrl-names = "internal_eth_pins";
+						pinctrl-0 = <&internal_eth_pins>;
 						mc_val = <0x1800>;
 						resets = <&clock GCLK_IDX_ETHERNET>;
 						reset-names = "ethpower";
@@ -382,6 +384,30 @@
 		irq_trigger_type = "GPIO_IRQ_HIGH";
 		power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -421,31 +447,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200","MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -880,9 +881,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -907,6 +908,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxm_pxp.dts b/arch/arm64/boot/dts/amlogic/gxm_pxp.dts
index 2ca9e99..f2c85cd 100644
--- a/arch/arm64/boot/dts/amlogic/gxm_pxp.dts
+++ b/arch/arm64/boot/dts/amlogic/gxm_pxp.dts
@@ -343,6 +343,32 @@
 		irq_trigger_type = "GPIO_IRQ_HIGH";
 		power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "disabled";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <200000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -374,32 +400,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "disabled";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <200000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -834,9 +834,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -861,6 +861,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxm_q200_2g.dts b/arch/arm64/boot/dts/amlogic/gxm_q200_2g.dts
index bc1b2d6..770754b 100644
--- a/arch/arm64/boot/dts/amlogic/gxm_q200_2g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxm_q200_2g.dts
@@ -40,7 +40,7 @@
 	};
 	memory@00000000 {
 		device_type = "memory";
-		linux,usable-memory = <0x0 0x1000000 0x0 0x7f000000>;
+		linux,usable-memory = <0x0 0x100000 0x0 0x7ff00000>;
 	};
 
 	reserved-memory {
@@ -96,14 +96,14 @@
 //		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
-			compatible = "amlogic, ppmgr_memory";
-			size = <0x0 0x2000000>;
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
 		};
 
 		codec_mm_cma:linux,codec_mm_cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0xd000000>;
+			size = <0x0 0xc000000>;
 			alignment = <0x0 0x400000>;
 			linux,contiguous-region;
 		};
@@ -206,9 +206,13 @@
 			0x0 0xc8834558 0x0 0xc>;
 			interrupts = <0 8 1>;
 			phy-mode= "rgmii";
-			pinctrl-names = "eth_pins";
-			pinctrl-0 = <&eth_pins>;
+			pinctrl-names = "external_eth_pins";
+			pinctrl-0 = <&external_eth_pins>;
+			rst_pin-gpios = <&gpio GPIOZ_14 0>;
+			GPIOZ4_pin-gpios = <&gpio GPIOZ_4 0>;
+			GPIOZ5_pin-gpios = <&gpio GPIOZ_5 0>;
 			mc_val = <0x1621>;
+			cali_val = <0x20000>;
 			resets = <&clock GCLK_IDX_ETHERNET>;
 			reset-names = "ethpower";
 			interrupt-names = "macirq";
@@ -224,6 +228,8 @@
 			0x0 0xc8834558 0x0 0xc>;
 			interrupts = <0 8 1>;
 			phy-mode= "rmii";
+			pinctrl-names = "internal_eth_pins";
+			pinctrl-0 = <&internal_eth_pins>;
 			mc_val = <0x1800>;
 			resets = <&clock GCLK_IDX_ETHERNET>;
 			reset-names = "ethpower";
@@ -420,6 +426,31 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -459,31 +490,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -940,9 +946,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -967,6 +973,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>; /* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxm_q201_1g.dts b/arch/arm64/boot/dts/amlogic/gxm_q201_1g.dts
index b6fb14e..d303297 100644
--- a/arch/arm64/boot/dts/amlogic/gxm_q201_1g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxm_q201_1g.dts
@@ -40,7 +40,7 @@
 	};
 	memory@00000000 {
 		device_type = "memory";
-		linux,usable-memory = <0x0 0x1000000 0x0 0x3f000000>;
+		linux,usable-memory = <0x0 0x100000 0x0 0x3ff00000>;
 	};
 
 	reserved-memory {
@@ -96,14 +96,14 @@
 //		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
-			compatible = "amlogic, ppmgr_memory";
-			size = <0x0 0x2000000>;
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
 		};
 
 		codec_mm_cma:linux,codec_mm_cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0xd000000>;
+			size = <0x0 0xc000000>;
 			alignment = <0x0 0x400000>;
 			linux,contiguous-region;
 		};
@@ -205,6 +205,8 @@
 						0x0 0xc8834558 0x0 0xc>;
 						interrupts = <0 8 1>;
 						phy-mode= "rmii";
+						pinctrl-names = "internal_eth_pins";
+						pinctrl-0 = <&internal_eth_pins>;
 						mc_val = <0x1800>;
 						resets = <&clock GCLK_IDX_ETHERNET>;
 						reset-names = "ethpower";
@@ -401,6 +403,31 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -439,31 +466,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -915,9 +917,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -942,6 +944,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxm_q201_2g.dts b/arch/arm64/boot/dts/amlogic/gxm_q201_2g.dts
index d680056..3140484 100644
--- a/arch/arm64/boot/dts/amlogic/gxm_q201_2g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxm_q201_2g.dts
@@ -40,7 +40,7 @@
 	};
 	memory@00000000 {
 		device_type = "memory";
-		linux,usable-memory = <0x0 0x1000000 0x0 0x7f000000>;
+		linux,usable-memory = <0x0 0x100000 0x0 0x7ff00000>;
 	};
 
 	reserved-memory {
@@ -96,14 +96,14 @@
 //		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
-			compatible = "amlogic, ppmgr_memory";
-			size = <0x0 0x2000000>;
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
 		};
 
 		codec_mm_cma:linux,codec_mm_cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0xd000000>;
+			size = <0x0 0xc000000>;
 			alignment = <0x0 0x400000>;
 			linux,contiguous-region;
 		};
@@ -205,6 +205,8 @@
 						0x0 0xc8834558 0x0 0xc>;
 						interrupts = <0 8 1>;
 						phy-mode= "rmii";
+						pinctrl-names = "internal_eth_pins";
+						pinctrl-0 = <&internal_eth_pins>;
 						mc_val = <0x1800>;
 						resets = <&clock GCLK_IDX_ETHERNET>;
 						reset-names = "ethpower";
@@ -401,6 +403,31 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -439,31 +466,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -915,9 +917,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -942,6 +944,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxm_skt.dts b/arch/arm64/boot/dts/amlogic/gxm_skt.dts
index bfed25d..f1f4eaf 100644
--- a/arch/arm64/boot/dts/amlogic/gxm_skt.dts
+++ b/arch/arm64/boot/dts/amlogic/gxm_skt.dts
@@ -204,6 +204,8 @@
 						0x0 0xc8834558 0x0 0xc>;
 						interrupts = <0 8 1>;
 						phy-mode= "rmii";
+						pinctrl-names = "internal_eth_pins";
+						pinctrl-0 = <&internal_eth_pins>;
 						mc_val = <0x1800>;
 						resets = <&clock GCLK_IDX_ETHERNET>;
 						reset-names = "ethpower";
@@ -396,6 +398,30 @@
 		irq_trigger_type = "GPIO_IRQ_HIGH";
 		power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
 	};
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc{
+			status = "disabled";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -436,31 +462,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
-        emmc{
-            status = "disabled";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
-					"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
-            caps2 = "MMC_CAP2_HS200","MMC_CAP2_HS400";
-			f_min = <300000>;
-            f_max = <100000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-		hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -895,9 +896,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -922,6 +923,11 @@
 		compatible = "amlogic, aml-pcm-dai";
 		pinctrl-names = "aml_audio_btpcm";
 		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxtvbb_9023_skt.dts b/arch/arm64/boot/dts/amlogic/gxtvbb_9023_skt.dts
index 53fc0a6..415a3e0 100644
--- a/arch/arm64/boot/dts/amlogic/gxtvbb_9023_skt.dts
+++ b/arch/arm64/boot/dts/amlogic/gxtvbb_9023_skt.dts
@@ -39,6 +39,12 @@
 			reg = <0x0 0x10000000 0x0 0x200000>;
 			no-map;
 		};
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
 		pstore:aml_pstore {
 			compatible = "amlogic, pstore";
 			reg = <0x0 0x07300000 0x0 0x100000>;
@@ -424,7 +430,33 @@
 		gpio_reset = <&gpio       GPIOX_20       GPIO_ACTIVE_HIGH>;
 	};
 
-
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <200000000>;
+			tx_phase = <1>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -456,33 +488,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-				"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
-				"MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
-			caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <200000000>;
-			tx_phase = <1>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -777,9 +782,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -802,6 +807,13 @@
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxtvbb_p300.dts b/arch/arm64/boot/dts/amlogic/gxtvbb_p300.dts
index 4766d9e..d5c62fe 100644
--- a/arch/arm64/boot/dts/amlogic/gxtvbb_p300.dts
+++ b/arch/arm64/boot/dts/amlogic/gxtvbb_p300.dts
@@ -39,6 +39,12 @@
 			reg = <0x0 0x10000000 0x0 0x200000>;
 			no-map;
 		};
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
 		pstore:aml_pstore {
 			compatible = "amlogic, pstore";
 			reg = <0x0 0x07300000 0x0 0x100000>;
@@ -330,11 +336,20 @@
 		compatible = "amlogic, hdmirx";
 		dev_name = "hdmirx";
 		status = "ok";
-		pinctrl-names = "hdmirx_pins";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
 		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
 		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
 		repeat = <0>;
 		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda83e000>;
+		hdmirx_data_port = <0xda83e004>;
+		hdmirx_ctrl_port = <0xda83e008>;
 		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
 			<&clock CLK_HDMIRX_CFG_CLK>,
 			<&clock CLK_HDMIRX_ACR_REF_CLK>,
@@ -348,6 +363,9 @@
 			"xtal",
 			"fclk_div5";
 		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_8       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_12      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_16      GPIO_ACTIVE_HIGH>;
  	};
 	tvafe {
 		compatible = "amlogic, tvafe";
@@ -367,15 +385,16 @@
                         4       /*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
 		>;
 	};
-	aml_avin {
+	avin_detect {
 		compatible = "amlogic, avin_detect";
 		status = "okay";
+		avin_device_num = <2>;
 		interrupts = <0 65 1
 					  0 66 1>;
 		pinctrl-names = "avin_gpio_disable_pullup";
 		pinctrl-0 = <&avin_gpio_disable_pull>;
-		avin1_pin =  <&gpio       GPIOW_4       GPIO_ACTIVE_HIGH>;
-		avin2_pin =  <&gpio       GPIOW_3       GPIO_ACTIVE_HIGH>;
+		avin_det_pin =  <&gpio       GPIOW_4       GPIO_ACTIVE_HIGH>,
+						<&gpio       GPIOW_3       GPIO_ACTIVE_HIGH>;
 		detect_interval_length = <100>;
 		set_detect_times = <5>;
 		set_fault_tolerance = <1>;
@@ -477,7 +496,33 @@
 		init_date = "2015/01/01";
 		status = "okay";
 	};
-
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <100000000>;
+			tx_phase = <1>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -510,33 +555,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-				"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
-				"MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
-			caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <100000000>;
-			tx_phase = <1>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-            hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 
 	nand{
 		compatible = "amlogic, aml_nand";
@@ -908,6 +926,7 @@
 		dev_name = "lcd";
 		mode = "tv";
 		status = "okay";
+		fr_auto_policy = <1>; /* 0=disable, 1=60/50hz, 2=60/50/48hz */
 		key_valid = <0>;
 		resets = <&clock GCLK_IDX_VCLK2_ENCL &clock GCLK_IDX_VCLK2_VENCL>;
 		reset-names = "encl","vencl";
@@ -928,8 +947,9 @@
 			model_name = "1080p-vfreq";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2060 2650 1100 1480 120000000 160000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
 			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
 			power_on_step = <0 0 1 20 /* panel power on */
@@ -944,8 +964,9 @@
 			model_name = "1080p-pclk";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2080 2720 1100 1380 133940000 156000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
 			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
 			power_on_step = <0 0 1 20 /* panel power on */
@@ -960,8 +981,9 @@
 			model_name = "1080p-hfreq";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2080 2720 1100 1380 133940000 156000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
 			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
 			power_on_step = <0 0 1 20 /* panel power on */
@@ -977,8 +999,9 @@
 			model_name = "public";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4340 4700 2200 2850 480000000 614000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
 			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
 			power_on_step = <0 0 1 50 /* panel power on */
@@ -994,8 +1017,9 @@
 			model_name = "LG_RDL550WY";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
 			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
 			power_on_step = <0 0 1 50 /* panel power on */
@@ -1011,8 +1035,9 @@
 			model_name = "INL_V580DJ2";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2790 552000000 632000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 1 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
 			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
 			power_on_step = <0 0 1 50 /* panel power on */
@@ -1028,8 +1053,9 @@
 			model_name = "BOE_HV550QU2";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 560000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 1 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
 			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
 			power_on_step = <0 0 1 20 /* panel power on */
@@ -1147,28 +1173,45 @@
 			bl_ldim_mapping = <0 1 2 3 4 5 6 7>;
 			ldim_dev_index = <0>;
 		};
+		backlight_3{
+			index = <3>;
+			bl_name = "backlight_3";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <3>; /* 0=gpio, 1=pwm, 2=pwm_combo, 3=ldim, 4=extern */
+			bl_power_attr = <0 1 0 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			bl_ldim_region_row_col = <1 1>;
+			bl_ldim_mode = <1>; /* 1=single_side(top, bottom, left or right), 2=uniform(top/bottom, left/right) */
+			ldim_dev_index = <2>;
+		};
 	};
 
 	local_diming_device {
 		compatible = "amlogic, ldim_dev";
 		dev_name = "ldim_dev";
 		status = "disabled";
-		spi_bus_num = <0>;
-		spi_chip_select = <0>;
-		spi_max_frequency = <400000>; /* unit: hz */
-		spi_mode = <0>; /* mode: 0, 1, 2, 3 */
-		pinctrl-names = "ldim_pwm";
-		pinctrl-0 = <&ldim_pwm_pins>;
+		pinctrl-names = "ldim_pwm0","ldim_pwm1";
+		pinctrl-0 = <&ldim_pwm0_pins>;
+		pinctrl-1 = <&ldim_pwm1_pins>;
 
 		ldim_dev-gpios = <&gpio GPIOX_9 GPIO_ACTIVE_HIGH
-			&gpio GPIOX_11 GPIO_ACTIVE_HIGH>;
-		ldim_dev_gpio_names = "GPIOX_9","GPIOX_11";
+			&gpio GPIOX_11 GPIO_ACTIVE_HIGH
+			&gpio GPIOY_4 GPIO_ACTIVE_HIGH>;
+		ldim_dev_gpio_names = "GPIOX_9","GPIOX_11","GPIOY_4";
 
 		ldim_dev_0 {
 			index = <0>; /* 120mA */
+			type = <1>; /* 0=normal,1=spi,2=i2c */
 			ldim_dev_name = "iw7019";
+			ldim_pwm_pinmux_sel = "ldim_pwm0";
 			ldim_pwm_port = "none"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
 			ldim_pwm_attr = <1 2 50>; /* pol, freq(Hz for pwm, v-freq mulit for pwm_vs), duty(%) */
+			spi_bus_num = <0>;
+			spi_chip_select = <0>;
+			spi_max_frequency = <400000>; /* unit: hz */
+			spi_mode = <0>; /* mode: 0, 1, 2, 3 */
 			spi_cs_delay = <10 100>; /* hold_high_delay, clk_cs_delay (unit: us) */
 
 			en_gpio_on_off = <0 1 0>; /* ldim_dev-gpios index, on_level, off_level */
@@ -1240,9 +1283,15 @@
 		};
 		ldim_dev_1 {
 			index = <1>;
+			type = <1>; /* 0=normal,1=spi,2=i2c */
 			ldim_dev_name = "iw7027";
+			ldim_pwm_pinmux_sel = "ldim_pwm0";
 			ldim_pwm_port = "PWM_VS"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
 			ldim_pwm_attr = <1 2 50>; /* pol, freq(Hz for pwm, v-freq mulit for pwm_vs), duty(%) */
+			spi_bus_num = <0>;
+			spi_chip_select = <0>;
+			spi_max_frequency = <400000>; /* unit: hz */
+			spi_mode = <0>; /* mode: 0, 1, 2, 3 */
 			spi_cs_delay = <10 10>; /* hold_high_delay, clk_cs_delay (unit: us) */
 
 			en_gpio_on_off = <0 1 0>; /* ldim_dev-gpios index, on_level, off_level */
@@ -1257,6 +1306,16 @@
 			/*   delay: unit ms */
 			init_on = <0xff 0x00 0x00 0x00>;
 		};
+		ldim_dev_2 {
+			index = <2>;
+			type = <0>; /* 0=normal,1=spi,2=i2c */
+			ldim_dev_name = "ob3350";
+			ldim_pwm_pinmux_sel = "ldim_pwm1";
+			ldim_pwm_port = "PWM_B"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			ldim_pwm_attr = <0 200 50>; /* pol, freq(Hz for pwm, v-freq mulit for pwm_vs), duty(%) */
+			dim_max_min = <100 20>; /* dim_max, dim_min */
+			en_gpio_on_off = <2 0 1>; /* ldim_dev-gpios index, on_level, off_level */
+		};
 	};
 
 	/* AUDIO MESON8 DEVICES */
@@ -1287,9 +1346,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -1312,6 +1371,13 @@
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -1660,14 +1726,20 @@
 			"GPIOZ_16","GPIOZ_19","GPIOZ_20";
 	};
 
-	ldim_pwm_pins:ldim_pwm_pin {
+	ldim_pwm0_pins:ldim_pwm0_pin {
 		amlogic,setmask = <2 0x00200000>;
 		amlogic,clrmask = <0 0x00900000
 				   1 0x00000008
 				   2 0x00180400
-                                   3 0x20000000>;
+					 3 0x20000000>;
 		amlogic,pins = "GPIOX_10";
 	};
+	ldim_pwm1_pins:ldim_pwm1_pin {
+		amlogic,setmask = <10 0x00800000>;
+		amlogic,clrmask = <10 0x0100a000>;
+		amlogic,pins = "GPIOY_13";
+	};
+
 	bl_pwm_on_pins:bl_pwm_on_pin {
 		amlogic,setmask = <10 0x00800000>;
 		amlogic,clrmask = <10 0x0100a000>;
@@ -1686,6 +1758,34 @@
                         "GPIOW_9","GPIOW_10","GPIOW_11","GPIOW_12",
                         "GPIOW_13","GPIOW_14","GPIOW_15","GPIOW_16",
                         "GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <6  0x3def780>,
+			<AO 0x3>;
+		amlogic,clrmask = <6  0x04210800>,
+			<10 0x0000001e>;
+		amlogic,pins = "GPIOW_5";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <6  0x00000800>,
+			<10  0x00000002>;
+		amlogic,clrmask = <6  0x00000600>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_7","GPIOW_8";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <6  0x00010000>,
+			<10  0x00000004>;
+		amlogic,clrmask = <6  0x0000c000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_11","GPIOW_12";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <6  0x00200000>,
+			<10  0x00000008>;
+		amlogic,clrmask = <6  0x00180000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_15","GPIOW_16";
+	};
         };
 
 	/* pwm_ao_a */
diff --git a/arch/arm64/boot/dts/amlogic/gxtvbb_p301.dts b/arch/arm64/boot/dts/amlogic/gxtvbb_p301.dts
index 7359a0e..d9920d2 100644
--- a/arch/arm64/boot/dts/amlogic/gxtvbb_p301.dts
+++ b/arch/arm64/boot/dts/amlogic/gxtvbb_p301.dts
@@ -39,6 +39,12 @@
 			reg = <0x0 0x10000000 0x0 0x200000>;
 			no-map;
 		};
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
 		pstore:aml_pstore {
 			compatible = "amlogic, pstore";
 			reg = <0x0 0x07300000 0x0 0x100000>;
@@ -367,11 +373,20 @@
 		compatible = "amlogic, hdmirx";
 		dev_name = "hdmirx";
 		status = "ok";
-		pinctrl-names = "hdmirx_pins";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
 		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
 		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
 		repeat = <0>;
 		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda83e000>;
+		hdmirx_data_port = <0xda83e004>;
+		hdmirx_ctrl_port = <0xda83e008>;
 		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
 			<&clock CLK_HDMIRX_CFG_CLK>,
 			<&clock CLK_HDMIRX_ACR_REF_CLK>,
@@ -385,6 +400,9 @@
 			"xtal",
 			"fclk_div5";
 		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_8       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_12      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_16      GPIO_ACTIVE_HIGH>;
  	};
 	tvafe {
 		compatible = "amlogic, tvafe";
@@ -404,15 +422,16 @@
                         4       /*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
 		>;
 	};
-	aml_avin {
+	avin_detect {
 		compatible = "amlogic, avin_detect";
 		status = "okay";
+		avin_device_num = <2>;
 		interrupts = <0 65 1
 					  0 66 1>;
 		pinctrl-names = "avin_gpio_disable_pullup";
 		pinctrl-0 = <&avin_gpio_disable_pull>;
-		avin1_pin =  <&gpio       GPIOW_4       GPIO_ACTIVE_HIGH>;
-		avin2_pin =  <&gpio       GPIOW_3       GPIO_ACTIVE_HIGH>;
+		avin_det_pin =  <&gpio       GPIOW_4       GPIO_ACTIVE_HIGH>,
+						<&gpio       GPIOW_3       GPIO_ACTIVE_HIGH>;
 		detect_interval_length = <100>;
 		set_detect_times = <5>;
 		set_fault_tolerance = <1>;
@@ -470,6 +489,7 @@
 		reg = <0x0 0xc8840000 0x0 0x2000>;
 		reg_23cf = <0x88188832>;/*default:0x88188832;r840 on haier:0x48188832*/
 		audio_gain_val = <1024>; /*haier need this*/
+		video_gain_val = <0x5C8808C1>;
 	};
 	amlvecm {
 		compatible = "amlogic, vecm";
@@ -514,7 +534,33 @@
 		init_date = "2015/01/01";
 		status = "okay";
 	};
-
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <100000000>;
+			tx_phase = <1>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -546,33 +592,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-				"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
-				"MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
-			caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <100000000>;
-			tx_phase = <1>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-            hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 
 	nand{
 		compatible = "amlogic, aml_nand";
@@ -942,6 +961,7 @@
 		dev_name = "lcd";
 		mode = "tv";
 		status = "okay";
+		fr_auto_policy = <1>; /* 0=disable, 1=60/50hz, 2=60/50/48hz */
 		key_valid = <0>;
 		resets = <&clock GCLK_IDX_VCLK2_ENCL &clock GCLK_IDX_VCLK2_VENCL>;
 		reset-names = "encl","vencl";
@@ -962,8 +982,9 @@
 			model_name = "1080p-vfreq";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2060 2650 1100 1480 120000000 160000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
 			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
 			power_on_step = <0 0 1 20 /* panel power on */
@@ -978,8 +999,9 @@
 			model_name = "1080p-pclk";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2080 2720 1100 1380 133940000 156000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
 			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
 			power_on_step = <0 0 1 20 /* panel power on */
@@ -994,8 +1016,9 @@
 			model_name = "1080p-hfreq";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2080 2720 1100 1380 133940000 156000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
 			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
 			power_on_step = <0 0 1 20 /* panel power on */
@@ -1011,8 +1034,9 @@
 			model_name = "public";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4340 4700 2200 2850 480000000 614000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
 			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
 			power_on_step = <0 0 1 50 /* panel power on */
@@ -1028,8 +1052,9 @@
 			model_name = "LG_RDL550WY";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
 			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
 			power_on_step = <0 0 1 50 /* panel power on */
@@ -1045,8 +1070,9 @@
 			model_name = "INL_V580DJ2";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2790 552000000 632000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 1 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
 			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
 			power_on_step = <0 0 1 50 /* panel power on */
@@ -1062,8 +1088,9 @@
 			model_name = "BOE_HV550QU2";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 560000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 1 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
-			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal, 3=auto range), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
 			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
 			power_on_step = <0 0 1 20 /* panel power on */
@@ -1204,28 +1231,45 @@
 					     1 18000 100 20>; /* pwm_method, pwm_freq, duty_max, duty_min */
 			bl_pwm_combo_power = <1 0 2 0 10 10>; /* pwm0_gpio_index, pwm0_gpio_off, pwm1_gpio_index, pwm1_gpio_off, pwm_on_delay, pwm_off_delay */
 		};
+		backlight_4{
+			index = <4>;
+			bl_name = "backlight_4";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <3>; /* 0=gpio, 1=pwm, 2=pwm_combo, 3=ldim, 4=extern */
+			bl_power_attr = <0 1 0 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			bl_ldim_region_row_col = <1 1>;
+			bl_ldim_mode = <1>; /* 1=single_side(top, bottom, left or right), 2=uniform(top/bottom, left/right) */
+			ldim_dev_index = <2>;
+		};
 	};
 
 	local_diming_device {
 		compatible = "amlogic, ldim_dev";
 		dev_name = "ldim_dev";
 		status = "disabled";
-		spi_bus_num = <0>;
-		spi_chip_select = <0>;
-		spi_max_frequency = <400000>; /* unit: hz */
-		spi_mode = <0>; /* mode: 0, 1, 2, 3 */
-		pinctrl-names = "ldim_pwm";
-		pinctrl-0 = <&ldim_pwm_pins>;
+		pinctrl-names = "ldim_pwm0","ldim_pwm1";
+		pinctrl-0 = <&ldim_pwm0_pins>;
+		pinctrl-1 = <&ldim_pwm1_pins>;
 
 		ldim_dev-gpios = <&gpio GPIOX_9 GPIO_ACTIVE_HIGH
-			&gpio GPIOX_11 GPIO_ACTIVE_HIGH>;
-		ldim_dev_gpio_names = "GPIOX_9","GPIOX_11";
+			&gpio GPIOX_11 GPIO_ACTIVE_HIGH
+			&gpio GPIOY_4 GPIO_ACTIVE_HIGH>;
+		ldim_dev_gpio_names = "GPIOX_9","GPIOX_11","GPIOY_4";
 
 		ldim_dev_0 {
 			index = <0>; /* 120mA */
+			type = <1>; /* 0=normal,1=spi,2=i2c */
 			ldim_dev_name = "iw7019";
+			ldim_pwm_pinmux_sel = "ldim_pwm0";
 			ldim_pwm_port = "none"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
 			ldim_pwm_attr = <1 2 50>; /* pol, freq(Hz for pwm, v-freq mulit for pwm_vs), duty(%) */
+			spi_bus_num = <0>;
+			spi_chip_select = <0>;
+			spi_max_frequency = <400000>; /* unit: hz */
+			spi_mode = <0>; /* mode: 0, 1, 2, 3 */
 			spi_cs_delay = <10 100>; /* hold_high_delay, clk_cs_delay (unit: us) */
 
 			en_gpio_on_off = <0 1 0>; /* ldim_dev-gpios index, on_level, off_level */
@@ -1297,9 +1341,15 @@
 		};
 		ldim_dev_1 {
 			index = <1>;
+			type = <1>; /* 0=normal,1=spi,2=i2c */
 			ldim_dev_name = "iw7027";
+			ldim_pwm_pinmux_sel = "ldim_pwm0";
 			ldim_pwm_port = "PWM_VS"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
 			ldim_pwm_attr = <1 2 50>; /* pol, freq(Hz for pwm, v-freq mulit for pwm_vs), duty(%) */
+			spi_bus_num = <0>;
+			spi_chip_select = <0>;
+			spi_max_frequency = <400000>; /* unit: hz */
+			spi_mode = <0>; /* mode: 0, 1, 2, 3 */
 			spi_cs_delay = <10 10>; /* hold_high_delay, clk_cs_delay (unit: us) */
 
 			en_gpio_on_off = <0 1 0>; /* ldim_dev-gpios index, on_level, off_level */
@@ -1314,6 +1364,16 @@
 			/*   delay: unit ms */
 			init_on = <0xff 0x00 0x00 0x00>;
 		};
+		ldim_dev_2 {
+			index = <2>;
+			type = <0>; /* 0=normal,1=spi,2=i2c */
+			ldim_dev_name = "ob3350";
+			ldim_pwm_pinmux_sel = "ldim_pwm1";
+			ldim_pwm_port = "PWM_B"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			ldim_pwm_attr = <0 200 50>; /* pol, freq(Hz for pwm, v-freq mulit for pwm_vs), duty(%) */
+			dim_max_min = <100 20>; /* dim_max, dim_min */
+			en_gpio_on_off = <2 0 1>; /* ldim_dev-gpios index, on_level, off_level */
+		};
 	};
 
 	/* AUDIO MESON8 DEVICES */
@@ -1344,9 +1404,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -1369,6 +1429,13 @@
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -1739,14 +1806,20 @@
 			"GPIOZ_16","GPIOZ_19","GPIOZ_20";
 	};
 
-	ldim_pwm_pins:ldim_pwm_pin {
+	ldim_pwm0_pins:ldim_pwm0_pin {
 		amlogic,setmask = <2 0x00200000>;
 		amlogic,clrmask = <0 0x00900000
 				   1 0x00000008
 				   2 0x00180400
-                                   3 0x20000000>;
+					 3 0x20000000>;
 		amlogic,pins = "GPIOX_10";
 	};
+	ldim_pwm1_pins:ldim_pwm1_pin {
+		amlogic,setmask = <10 0x00800000>;
+		amlogic,clrmask = <10 0x0100a000>;
+		amlogic,pins = "GPIOY_13";
+	};
+
 	bl_pwm_on_pins:bl_pwm_on_pin {
 		amlogic,setmask = <10 0x00800000>;
 		amlogic,clrmask = <10 0x0100a000>;
@@ -1782,6 +1855,34 @@
                                   <10 0x0000001e>;
                 amlogic,pins = "GPIOW_7";
 	};
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <6  0x3def780>,
+			<AO 0x3>;
+		amlogic,clrmask = <6  0x04210800>,
+			<10 0x0000001e>;
+		amlogic,pins = "GPIOW_5";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <6  0x00000800>,
+			<10  0x00000002>;
+		amlogic,clrmask = <6  0x00000600>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_7","GPIOW_8";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <6  0x00010000>,
+			<10  0x00000004>;
+		amlogic,clrmask = <6  0x0000c000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_11","GPIOW_12";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <6  0x00200000>,
+			<10  0x00000008>;
+		amlogic,clrmask = <6  0x00180000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_15","GPIOW_16";
+	};
 	u_ch1_in:u_ch1_in {
 		amlogic,clrmask = <AO 0x33>,
 						  <6  0x600>;
diff --git a/arch/arm64/boot/dts/amlogic/gxtvbb_p310.dts b/arch/arm64/boot/dts/amlogic/gxtvbb_p310.dts
index 5844d9b..0160f8f 100644
--- a/arch/arm64/boot/dts/amlogic/gxtvbb_p310.dts
+++ b/arch/arm64/boot/dts/amlogic/gxtvbb_p310.dts
@@ -22,6 +22,7 @@
 	aliases {
 		serial0 = &uart_AO;
 		serial1 = &uart_A;
+		serial2 = &uart_B;
 	};
 
 	memory@00000000 {
@@ -39,6 +40,12 @@
 			reg = <0x0 0x10000000 0x0 0x200000>;
 			no-map;
 		};
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
 		pstore:aml_pstore {
 			compatible = "amlogic, pstore";
 			reg = <0x0 0x07300000 0x0 0x100000>;
@@ -321,11 +328,20 @@
 		compatible = "amlogic, hdmirx";
 		dev_name = "hdmirx";
 		status = "ok";
-		pinctrl-names = "hdmirx_pins";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
 		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
 		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
 		repeat = <0>;
 		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda83e000>;
+		hdmirx_data_port = <0xda83e004>;
+		hdmirx_ctrl_port = <0xda83e008>;
 		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
 			<&clock CLK_HDMIRX_CFG_CLK>,
 			<&clock CLK_HDMIRX_ACR_REF_CLK>,
@@ -339,6 +355,9 @@
 			"xtal",
 			"fclk_div5";
 		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_8       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_12      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_16      GPIO_ACTIVE_HIGH>;
  	};
 	tvafe {
 		compatible = "amlogic, tvafe";
@@ -358,15 +377,16 @@
 			4	/*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
 		>;
 	};
-	aml_avin {
+	avin_detect {
 		compatible = "amlogic, avin_detect";
 		status = "okay";
+		avin_device_num = <2>;
 		interrupts = <0 65 1
 					  0 66 1>;
 		pinctrl-names = "avin_gpio_disable_pullup";
 		pinctrl-0 = <&avin_gpio_disable_pull>;
-		avin1_pin =  <&gpio       GPIOW_4       GPIO_ACTIVE_HIGH>;
-		avin2_pin =  <&gpio       GPIOW_3       GPIO_ACTIVE_HIGH>;
+		avin_det_pin =  <&gpio       GPIOW_4       GPIO_ACTIVE_HIGH>,
+						<&gpio       GPIOW_3       GPIO_ACTIVE_HIGH>;
 		detect_interval_length = <100>;
 		set_detect_times = <5>;
 		set_fault_tolerance = <1>;
@@ -423,6 +443,8 @@
 		pinctrl-0=<&atvdemod_agc>;
 		reg = <0x0 0xc8840000 0x0 0x2000>;
 		reg_23cf = <0x88188832>;/*default:0x88188832;r840 on haier:0x48188832*/
+		//audio_gain_val = <1024>; /*haier need this*/
+		video_gain_val = <0x5C8808C1>;
 	};
 	aml_local_dimming {
 		compatible = "amlogic, aml_local_dimming";
@@ -474,7 +496,33 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
-
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <100000000>;
+			tx_phase = <1>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -497,33 +545,6 @@
 	   		card_type = <3>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-				"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
-				"MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
-			caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <100000000>;
-			tx_phase = <1>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 
 	nand{
 		compatible = "amlogic, aml_nand";
@@ -822,6 +843,19 @@
 		pinctrl-0 = <&a_uart_pins>;
 	};
 
+	uart_B: serial@c11084dc {
+                compatible = "amlogic, meson-uart";
+                reg = <0x0 0xc11084dc 0x0 0x14>;
+                interrupts = <0 75 1>;
+                status = "okay";
+                clocks = <&clock CLK_XTAL>;
+                clock-names = "clk_uart";
+                fifosize = < 64 >;
+                pinctrl-names = "default";
+                pinctrl-0 = <&b_uart_pins_y>;
+                resets = <&clock GCLK_IDX_UART1>;
+        };
+
        dwc3: dwc3@c9000000 {
                compatible = "synopsys, dwc3";
                reg = <0x0 0xc9000000 0x0 0x100000>;
@@ -913,9 +947,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -938,6 +972,13 @@
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -1159,11 +1200,11 @@
 		pinctrl-0=<&a_i2c_master>;
 	};
 
-	&i2c_b {
+/*	&i2c_b {
 		status = "okay";
 		pinctrl-names="default";
 		pinctrl-0=<&b_i2c_master>;
-	};
+	};*/
 	&i2c_c {
 		status = "disabled";
 		pinctrl-names="default";
@@ -1206,6 +1247,34 @@ hdmirx_pins: hdmirx_pins {
                         "GPIOW_13","GPIOW_14","GPIOW_15","GPIOW_16",
                         "GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
         };
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <6  0x3def780>,
+			<AO 0x3>;
+		amlogic,clrmask = <6  0x04210800>,
+			<10 0x0000001e>;
+		amlogic,pins = "GPIOW_5";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <6  0x00000800>,
+			<10  0x00000002>;
+		amlogic,clrmask = <6  0x00000600>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_7","GPIOW_8";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <6  0x00010000>,
+			<10  0x00000004>;
+		amlogic,clrmask = <6  0x0000c000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_11","GPIOW_12";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <6  0x00200000>,
+			<10  0x00000008>;
+		amlogic,clrmask = <6  0x00180000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_15","GPIOW_16";
+	};
 	/*PWM-A*/
 	/*pwm_a_pins:pwm_a_pins{
 		amlogic,setmask=<10 0x200000>;
diff --git a/arch/arm64/boot/dts/amlogic/gxtvbb_p311.dts b/arch/arm64/boot/dts/amlogic/gxtvbb_p311.dts
index d191f26..ab5d449 100644
--- a/arch/arm64/boot/dts/amlogic/gxtvbb_p311.dts
+++ b/arch/arm64/boot/dts/amlogic/gxtvbb_p311.dts
@@ -40,6 +40,12 @@
 			reg = <0x0 0x10000000 0x0 0x200000>;
 			no-map;
 		};
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
 		pstore:aml_pstore {
 			compatible = "amlogic, pstore";
 			reg = <0x0 0x07300000 0x0 0x100000>;
@@ -328,11 +334,20 @@
 		compatible = "amlogic, hdmirx";
 		dev_name = "hdmirx";
 		status = "ok";
-		pinctrl-names = "hdmirx_pins";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
 		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
 		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
 		repeat = <1>;
 		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda83e000>;
+		hdmirx_data_port = <0xda83e004>;
+		hdmirx_ctrl_port = <0xda83e008>;
 		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
 			<&clock CLK_HDMIRX_CFG_CLK>,
 			<&clock CLK_HDMIRX_ACR_REF_CLK>,
@@ -346,6 +361,9 @@
 			"xtal",
 			"fclk_div5";
 		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_8       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_12      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_16      GPIO_ACTIVE_HIGH>;
  	};
 	tvafe {
 		compatible = "amlogic, tvafe";
@@ -365,15 +383,16 @@
 			4	/*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
 		>;
 	};
-	aml_avin {
+	avin_detect {
 		compatible = "amlogic, avin_detect";
 		status = "okay";
+		avin_device_num = <2>;
 		interrupts = <0 65 1
 					  0 66 1>;
 		pinctrl-names = "avin_gpio_disable_pullup";
 		pinctrl-0 = <&avin_gpio_disable_pull>;
-		avin1_pin =  <&gpio       GPIOW_4       GPIO_ACTIVE_HIGH>;
-		avin2_pin =  <&gpio       GPIOW_3       GPIO_ACTIVE_HIGH>;
+		avin_det_pin =  <&gpio       GPIOW_4       GPIO_ACTIVE_HIGH>,
+						<&gpio       GPIOW_3       GPIO_ACTIVE_HIGH>;
 		detect_interval_length = <100>;
 		set_detect_times = <5>;
 		set_fault_tolerance = <1>;
@@ -482,7 +501,33 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
-
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <100000000>;
+			tx_phase = <1>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//			gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
 	sd{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -515,34 +560,6 @@
 		};
 	};
 
-	emmc{
-		compatible = "amlogic, aml_sd_emmc";
-		dev_name = "aml_newsd.0";
-		status = "okay";
-		reg = <0x0 0xd0074000 0x0 0x2000>;
-		interrupts = <	0 218 1>;
-		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-		pinctrl-0 = <&emmc_clk_cmd_pins>;
-		pinctrl-1 = <&emmc_all_pins>;
-		emmc{
-			status = "okay";
-			pinname = "emmc";
-			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-				"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
-				"MMC_CAP_ERASE", "MMC_CAP_HW_RESET";
-				caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-			f_max = <100000000>;
-			tx_phase = <1>;
-			max_req_size = <0x20000>;          /**256KB*/
-//			gpio_dat3 = "BOOT_3"
-			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-		};
-	};
-
 	nand{
 		compatible = "amlogic, aml_nand";
 		dev_name = "nand";
@@ -946,9 +963,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -971,6 +988,13 @@
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -1231,6 +1255,34 @@
                         "GPIOW_13","GPIOW_14","GPIOW_15","GPIOW_16",
                         "GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
         };
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <6  0x3def780>,
+			<AO 0x3>;
+		amlogic,clrmask = <6  0x04210800>,
+			<10 0x0000001e>;
+		amlogic,pins = "GPIOW_5";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <6  0x00000800>,
+			<10  0x00000002>;
+		amlogic,clrmask = <6  0x00000600>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_7","GPIOW_8";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <6  0x00010000>,
+			<10  0x00000004>;
+		amlogic,clrmask = <6  0x0000c000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_11","GPIOW_12";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <6  0x00200000>,
+			<10  0x00000008>;
+		amlogic,clrmask = <6  0x00180000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_15","GPIOW_16";
+	};
 	/*PWM-A*/
 	/*pwm_a_pins:pwm_a_pins{
 		amlogic,setmask=<10 0x200000>;
diff --git a/arch/arm64/boot/dts/amlogic/gxtvbb_pxp.dts b/arch/arm64/boot/dts/amlogic/gxtvbb_pxp.dts
index 9ed3e8b..ee1d80f 100644
--- a/arch/arm64/boot/dts/amlogic/gxtvbb_pxp.dts
+++ b/arch/arm64/boot/dts/amlogic/gxtvbb_pxp.dts
@@ -39,7 +39,12 @@
 			reg = <0x0 0x10000000 0x0 0x200000>;
 			no-map;
 		};
-
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
 		/*fb_reserved:linux,meson-fb {
 			compatible = "amlogic, fb-memory";
 			size = <0x0 0x2000000>;
@@ -326,7 +331,31 @@
 		init_date = "2015/01/01";
 		status = "okay";
 	};
-
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"/*,
+				 "MMC_CAP_ERASE", "MMC_CAP_HW_RESET"*/;
+			//caps2 = "MMC_CAP2_HS200_1_8V_SDR";
+			f_min = <400000>;
+			f_max = <50000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -358,31 +387,6 @@
 	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-            		"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"/*,
-           		"MMC_CAP_ERASE", "MMC_CAP_HW_RESET"*/;
-            //caps2 = "MMC_CAP2_HS200_1_8V_SDR";
-			f_min = <400000>;
-            f_max = <50000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-		gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-	};
-    };
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -599,9 +603,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -624,6 +628,13 @@
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
diff --git a/arch/arm64/boot/dts/amlogic/gxtvbb_skt.dts b/arch/arm64/boot/dts/amlogic/gxtvbb_skt.dts
index 2338d4a..a778390 100644
--- a/arch/arm64/boot/dts/amlogic/gxtvbb_skt.dts
+++ b/arch/arm64/boot/dts/amlogic/gxtvbb_skt.dts
@@ -39,6 +39,12 @@
 			reg = <0x0 0x10000000 0x0 0x200000>;
 			no-map;
 		};
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
 		pstore:aml_pstore {
 			compatible = "amlogic, pstore";
 			reg = <0x0 0x07300000 0x0 0x100000>;
@@ -307,11 +313,20 @@
 		compatible = "amlogic, hdmirx";
 		dev_name = "hdmirx";
 		status = "ok";
-		pinctrl-names = "hdmirx_pins";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
 		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
 		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
 		repeat = <0>;
 		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda83e000>;
+		hdmirx_data_port = <0xda83e004>;
+		hdmirx_ctrl_port = <0xda83e008>;
 		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
 			<&clock CLK_HDMIRX_CFG_CLK>,
 			<&clock CLK_HDMIRX_ACR_REF_CLK>,
@@ -325,6 +340,9 @@
 			"xtal",
 			"fclk_div5";
 		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_8       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_12      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_16      GPIO_ACTIVE_HIGH>;
  	};
 
 	tvafe {
@@ -450,7 +468,32 @@
 		gpio_reset = <&gpio       GPIOX_20       GPIO_ACTIVE_HIGH>;
 	};
 
-
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <100000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//			gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
 	sd{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -483,33 +526,6 @@
 		};
 	};
 
-	emmc{
-		compatible = "amlogic, aml_sd_emmc";
-		dev_name = "aml_newsd.0";
-		status = "okay";
-		reg = <0x0 0xd0074000 0x0 0x2000>;
-		interrupts = <	0 218 1>;
-		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-		pinctrl-0 = <&emmc_clk_cmd_pins>;
-		pinctrl-1 = <&emmc_all_pins>;
-		emmc{
-			status = "okay";
-			pinname = "emmc";
-			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-			"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
-			"MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
-			caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-			f_max = <100000000>;
-			max_req_size = <0x20000>;          /**256KB*/
-//			gpio_dat3 = "BOOT_3"
-			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-		};
-	};
-
 	sdio{
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -774,6 +790,7 @@
 		dev_name = "lcd";
 		mode = "tv";
 		status = "okay";
+		fr_auto_policy = <0>;
 		key_valid = <0>;
 		resets = <&clock GCLK_IDX_VCLK2_ENCL &clock GCLK_IDX_VCLK2_VENCL>;
 		reset-names = "encl","vencl";
@@ -793,6 +810,7 @@
 			model_name = "1080p-vfreq";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2060 2650 1100 1480 120000000 160000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
 			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
@@ -807,6 +825,7 @@
 			model_name = "1080p-pclk";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2080 2720 1100 1380 133940000 156000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
 			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
@@ -821,6 +840,7 @@
 			model_name = "1080p-hfreq";
 			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2080 2720 1100 1380 133940000 156000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
 			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
@@ -836,6 +856,7 @@
 			model_name = "public";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4340 4700 2200 2850 480000000 614000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
 			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
@@ -851,6 +872,7 @@
 			model_name = "LG_RDL550WY";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
 			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
@@ -866,6 +888,7 @@
 			model_name = "INL_V580DJ2";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2790 552000000 632000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
 			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 1 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
@@ -881,6 +904,7 @@
 			model_name = "BOE_HV550QU2";
 			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
 			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 560000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
 			lcd_timing = <33 477 1 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
 			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
 			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
@@ -1021,9 +1045,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -1046,6 +1070,13 @@
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -1320,6 +1351,34 @@
 			"GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
 	};
 
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <6  0x3def780>,
+			<AO 0x3>;
+		amlogic,clrmask = <6  0x04210800>,
+			<10 0x0000001e>;
+		amlogic,pins = "GPIOW_5";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <6  0x00000800>,
+			<10  0x00000002>;
+		amlogic,clrmask = <6  0x00000600>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_7","GPIOW_8";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <6  0x00010000>,
+			<10  0x00000004>;
+		amlogic,clrmask = <6  0x0000c000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_11","GPIOW_12";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <6  0x00200000>,
+			<10  0x00000008>;
+		amlogic,clrmask = <6  0x00180000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_15","GPIOW_16";
+	};
 	/*PWM-A*/
 	/*pwm_a_pins:pwm_a_pins{
 		amlogic,setmask=<10 0x200000>;
diff --git a/arch/arm64/boot/dts/amlogic/gxtvbb_t966_skt.dts b/arch/arm64/boot/dts/amlogic/gxtvbb_t966_skt.dts
index e5179af..59e4149 100644
--- a/arch/arm64/boot/dts/amlogic/gxtvbb_t966_skt.dts
+++ b/arch/arm64/boot/dts/amlogic/gxtvbb_t966_skt.dts
@@ -39,6 +39,12 @@
 			reg = <0x0 0x10000000 0x0 0x200000>;
 			no-map;
 		};
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
 		pstore:aml_pstore {
 			compatible = "amlogic, pstore";
 			reg = <0x0 0x07300000 0x0 0x100000>;
@@ -65,7 +71,11 @@
 
 		ion_reserved:linux,ion-dev {
 			compatible = "amlogic, idev-mem";
-			size = <0x0 0x4000000>;
+			//size = <0x0 0x4000000>;
+			/* the most significant 64M memory reserved for ion */
+			//reg = <0x0 0x3c000000 0x0 0x4000000>; /* for 1G memory */
+			//reg = <0x0 0x5c000000 0x0 0x4000000>; /* for 1.5G memory*/
+			reg = <0x0 0x7c000000 0x0 0x4000000>; /* for 2G memory */
 		};
 		/*  POST PROCESS MANAGER */
 		ppmgr_reserved:linux,ppmgr {
@@ -145,11 +155,12 @@
 		interrupts = <0 3 1
 			0 89 1>;
 		interrupt-names = "viu-vsync", "rdma";
-		mem_size = <0x01800000 0x00800000>; /* fb0/fb1 memory size */
+		mem_size = <0x01851000 0x00100000>; /* fb0/fb1 memory size */
 		display_mode_default = "1080p60hz";
 		scale_mode = <1>; /** 0:VPU free scale 1:OSD free scale 2:OSD super scale */
 		display_size_default = <1920 1080 1920 3240 32>; //1920*1080*4*3 = 0x17BB000
 		/*pxp_mode = <1>; /** 0:normal mode 1:pxp mode */
+		logo_addr = "0x3d851000"; /*ion base + fb0 memory size for uboot logo osd1*/
 	};
 	ge2d {
 		compatible = "amlogic, ge2d";
@@ -293,11 +304,20 @@
 		compatible = "amlogic, hdmirx";
 		dev_name = "hdmirx";
 		status = "ok";
-		pinctrl-names = "hdmirx_pins";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
 		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
 		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
 		repeat = <0>;
 		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda83e000>;
+		hdmirx_data_port = <0xda83e004>;
+		hdmirx_ctrl_port = <0xda83e008>;
 		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
 			<&clock CLK_HDMIRX_CFG_CLK>,
 			<&clock CLK_HDMIRX_ACR_REF_CLK>,
@@ -311,6 +331,9 @@
 			"xtal",
 			"fclk_div5";
 		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_8       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_12      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_16      GPIO_ACTIVE_HIGH>;
  	};
 	tvafe {
 		compatible = "amlogic, tvafe";
@@ -404,8 +427,8 @@
 		compatible = "amlogic, vecm";
 		dev_name = "aml_vecm";
 		status = "okay";
-		gamma_en = <1>;/*1:enabel ;0:disable*/
-		wb_en = <1>;/*1:enabel ;0:disable*/
+		gamma_en = <0>;/*1:enabel ;0:disable*/
+		wb_en = <0>;/*1:enabel ;0:disable*/
 		cm_en = <1>;/*1:enabel ;0:disable*/
 	};
 
@@ -444,7 +467,32 @@
 		pinctrl-names = "wifi_32k_pins";
 		pinctrl-0 = <&wifi_32k_pins>;
 	};
-
+	emmc{
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc{
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200";
+			f_min = <300000>;
+			f_max = <200000000>;
+			max_req_size = <0x20000>;          /**256KB*/
+			//            gpio_dat3 = "BOOT_3"
+			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
     sd{
         compatible = "amlogic, aml_sd_emmc";
         dev_name = "aml_newsd.0";
@@ -478,32 +526,6 @@
 	   		card_type =	<5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
 		};
     };
-    emmc{
-        compatible = "amlogic, aml_sd_emmc";
-        dev_name = "aml_newsd.0";
-        status = "okay";
-        reg = <0x0 0xd0074000 0x0 0x2000>;
-        interrupts = <	0 218 1>;
-        pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-        pinctrl-0 = <&emmc_clk_cmd_pins>;
-        pinctrl-1 = <&emmc_all_pins>;
-        emmc{
-            status = "okay";
-            pinname = "emmc";
-            ocr_avail = <0x200080>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
-				"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_1_8V_DDR",
-				"MMC_CAP_ERASE", "MMC_CAP_HW_RESET", "MMC_CAP_CMD23";
-			caps2 = "MMC_CAP2_HS200";
-			f_min = <300000>;
-            f_max = <200000000>;
-            max_req_size = <0x20000>;          /**256KB*/
-//            gpio_dat3 = "BOOT_3"
-			gpio_dat3 = <&gpio       BOOT_3      GPIO_ACTIVE_HIGH>;
-			hw_reset =  <&gpio       BOOT_9      GPIO_ACTIVE_HIGH>;
-            card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
-		};
-    };
 	nand{
 		compatible = "amlogic, aml_nand";
 		dev_name = "nand";
@@ -781,9 +803,9 @@
 			"top_level",
 			"aoclk",
 			"aud_in";
-		clocks = <&clock CLK_MPLL0>,
+		clocks = <&clock CLK_MPLL2>,
 			<&clock CLK_AMCLK>;
-		clock-names = "mpll0", "mclk";
+		clock-names = "mpll2", "mclk";
 		compatible = "amlogic, aml-i2s-dai";
 	};
 	spdif_dai: SPDIF {
@@ -806,6 +828,13 @@
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
 	};
 	i2s_plat: i2s_platform {
 		compatible = "amlogic, aml-i2s";
@@ -1060,6 +1089,34 @@
                         "GPIOW_13","GPIOW_14","GPIOW_15","GPIOW_16",
                         "GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
         };
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <6  0x3def780>,
+			<AO 0x3>;
+		amlogic,clrmask = <6  0x04210800>,
+			<10 0x0000001e>;
+		amlogic,pins = "GPIOW_5";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <6  0x00000800>,
+			<10  0x00000002>;
+		amlogic,clrmask = <6  0x00000600>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_7","GPIOW_8";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <6  0x00010000>,
+			<10  0x00000004>;
+		amlogic,clrmask = <6  0x0000c000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_11","GPIOW_12";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <6  0x00200000>,
+			<10  0x00000008>;
+		amlogic,clrmask = <6  0x00180000>,
+			<AO 0x33>;
+		amlogic,pins = "GPIOW_15","GPIOW_16";
+	};
 	/*PWM-A*/
 	/*pwm_a_pins:pwm_a_pins{
 		amlogic,setmask=<10 0x200000>;
diff --git a/arch/arm64/boot/dts/amlogic/mesongxbb-gpu-mali450.dtsi b/arch/arm64/boot/dts/amlogic/mesongxbb-gpu-mali450.dtsi
index 80e48c3..f4307e9 100644
--- a/arch/arm64/boot/dts/amlogic/mesongxbb-gpu-mali450.dtsi
+++ b/arch/arm64/boot/dts/amlogic/mesongxbb-gpu-mali450.dtsi
@@ -57,7 +57,7 @@
 			clkp_freq = <500000000>;
 			voltage = <1150>;
 			keep_count = <5>;
-			threshold = <30 120>;
+			threshold = <30 250>;
 		  };
 
 		  clk250_cfg:clk250_cfg {
@@ -66,7 +66,8 @@
 			clkp_freq = <500000000>;
 			voltage = <1150>;
 			keep_count = <5>;
-			threshold = <80 170>;
+			threshold = <115 250>;
+			/*125 = 250*(125/250), 50= 60-10*/
 		  };
 
 		  clk285_cfg:clk285_cfg {
@@ -75,7 +76,8 @@
 			clkp_freq = <285000000>;
 			voltage = <1150>;
 			keep_count = <5>;
-			threshold = <100 190>;
+			threshold = <100 250>;
+			/*109 = 250*(125/285)*/
 		  };
 
 		  clk400_cfg:clk400_cfg {
@@ -83,8 +85,9 @@
 			clk_parent = "fclk_div5";
 			clkp_freq = <400000000>;
 			voltage = <1150>;
-			keep_count = <5>;
-			threshold = <152 207>;
+			keep_count = <3>;
+			threshold = <168 250>;
+			/*178 = 250*(285/400)*/
 		  };
 
 		  clk500_cfg:clk500_cfg {
@@ -92,8 +95,9 @@
 			clk_parent = "fclk_div4";
 			clkp_freq = <500000000>;
 			voltage = <1150>;
-			keep_count = <5>;
-			threshold = <180 220>;
+			keep_count = <2>;
+			threshold = <190 250>;
+			/*200=250*(400/500)*/
 		  };
 
 		  clk666_cfg:clk666_cfg {
@@ -101,8 +105,9 @@
 			clk_parent = "fclk_div3";
 			clkp_freq = <666000000>;
 			voltage = <1150>;
-			keep_count = <5>;
-			threshold = <210 236>;
+			keep_count = <1>;
+			threshold = <177 250>;
+			/*187.5=250*(500/666.6)*/
 		  };
 
 		  clk750_cfg:clk750_cfg {
@@ -110,8 +115,9 @@
 			clk_parent = "gp0_pll";
 			clkp_freq = <744000000>;
 			voltage = <1150>;
-			keep_count = <5>;
-			threshold = <230 255>;
+			keep_count = <1>;
+			threshold = <213 255>;
+			/*223=250*(666.0/744.0), 223+7=230*/
 		  };
 
 		  clk800_cfg:clk800_cfg {
@@ -119,7 +125,7 @@
 			clk_parent = "gp0_pll";
 			clkp_freq = <792000000>;
 			voltage = <1150>;
-			keep_count = <5>;
+			keep_count = <1>;
 			threshold = <230 255>;
 		  };
 
diff --git a/arch/arm64/boot/dts/amlogic/mesongxbb.dtsi b/arch/arm64/boot/dts/amlogic/mesongxbb.dtsi
index c0e9f94..5b56f99 100644
--- a/arch/arm64/boot/dts/amlogic/mesongxbb.dtsi
+++ b/arch/arm64/boot/dts/amlogic/mesongxbb.dtsi
@@ -47,6 +47,18 @@
 			        <GIC_PPI 11 0xff01>,
 			        <GIC_PPI 10 0xff01>;
 	};
+	timer_bc {
+		compatible = "arm, meson-bc-timer";
+		reg=   <0x0 0xc1109990 0x0 0x4 0x0 0xc1109994 0x0 0x4>;
+		timer_name = "Meson TimerF";
+		clockevent-rating=<300>;
+		clockevent-shift=<20>;
+		clockevent-features=<0x03>;
+		interrupts = <0 60 1>;
+		bit_enable=<16>;
+		bit_mode=<12>;
+		bit_resolution=<0>;
+	};
 	arm_pmu {
 		compatible = "arm,armv8-pmuv3";
 		interrupts = <0 137 4>,
diff --git a/arch/arm64/boot/dts/amlogic/mesongxl.dtsi b/arch/arm64/boot/dts/amlogic/mesongxl.dtsi
index 71c8cf7..b243af2 100644
--- a/arch/arm64/boot/dts/amlogic/mesongxl.dtsi
+++ b/arch/arm64/boot/dts/amlogic/mesongxl.dtsi
@@ -33,6 +33,7 @@
 			compatible = "arm,cortex-a53","arm,armv8";
 			reg = <0x0 0x0>;
 			enable-method = "psci";
+			/*cpu-idle-states = <&CPU_SLEEP_0>;*/
 		};
 
 		cpu1:cpu@1 {
@@ -40,12 +41,14 @@
 			compatible = "arm,cortex-a53","arm,armv8";
 			reg = <0x0 0x1>;
 			enable-method = "psci";
+			/*cpu-idle-states = <&CPU_SLEEP_0>;*/
 		};
 		cpu2:cpu@2 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a53","arm,armv8";
 			reg = <0x0 0x2>;
 			enable-method = "psci";
+			/*cpu-idle-states = <&CPU_SLEEP_0>;*/
 		};
 
 		cpu3:cpu@3 {
@@ -53,8 +56,22 @@
 			compatible = "arm,cortex-a53","arm,armv8";
 			reg = <0x0 0x3>;
 			enable-method = "psci";
+			/*cpu-idle-states = <&CPU_SLEEP_0>;*/
 		};
 
+/*
+		idle-states {
+			entry-method = "arm,psci";
+			CPU_SLEEP_0: cpu-sleep-0 {
+				compatible = "arm, idle-state";
+				arm,psci-suspend-param = <0x0010000>;
+				local-timer-stop;
+				entry-latency-us = <3000>;
+				exit-latency-us = <3000>;
+				min-residency-us = <8000>;
+			};
+		};
+*/
 	};
 
 	timer {
@@ -64,6 +81,18 @@
 			        <GIC_PPI 11 0xff01>,
 			        <GIC_PPI 10 0xff01>;
 	};
+	timer_bc {
+		compatible = "arm, meson-bc-timer";
+		reg=   <0x0 0xc1109990 0x0 0x4 0x0 0xc1109994 0x0 0x4>;
+		timer_name = "Meson TimerF";
+		clockevent-rating=<300>;
+		clockevent-shift=<20>;
+		clockevent-features=<0x23>;
+		interrupts = <0 60 1>;
+		bit_enable=<16>;
+		bit_mode=<12>;
+		bit_resolution=<0>;
+	};
 	arm_pmu {
 		compatible = "arm,armv8-pmuv3";
 		interrupts = <0 137 4>,
@@ -204,15 +233,20 @@
 			gpio-controller;
 			#gpio-cells = <2>;
 		};
-		eth_pins:eth_pins{
-                        amlogic,setmask =<4 0xfffc00>;
-                        amlogic,clrmask =<4 0x3fc>,
-                                         <3 0xfffff800>;
-                        amlogic,pins="GPIOZ_0","GPIOZ_1","GPIOZ_2","GPIOZ_3",
-                                "GPIOZ_4","GPIOZ_5","GPIOZ_6","GPIOZ_7",
-                                "GPIOZ_8","GPIOZ_9","GPIOZ_10","GPIOZ_11",
-                                "GPIOZ_12","GPIOZ_13","GPIOZ_15";
-                };
+		external_eth_pins:external_eth_pins{
+			amlogic,setmask =<4 0xfffc00>;
+			amlogic,clrmask =<4 0x3fc>,
+					 <3 0xffcff800>;
+			amlogic,pins="GPIOZ_0","GPIOZ_1","GPIOZ_2","GPIOZ_3",
+			"GPIOZ_4","GPIOZ_5","GPIOZ_6","GPIOZ_7",
+			"GPIOZ_8","GPIOZ_9","GPIOZ_10","GPIOZ_11",
+			"GPIOZ_12","GPIOZ_13";
+		};
+		internal_eth_pins:internal_eth_pins{
+			amlogic,setmask =<4 0x3000000>;
+			amlogic,clrmask =<3 0x300000>;
+			amlogic,pins="GPIOZ_14","GPIOZ_15";
+    };
 		jtag_apao_pins:jtag_apao_pin{
 			amlogic,clrmask = <6 0x7fe0000>;
 			amlogic,pins = "GPIOH_6","GPIOH_7","GPIOH_8","GPIOH_9";
@@ -620,8 +654,6 @@
 		interrupts = <0 196 1>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&remote_pins>;
-		led_status_on = <0>;
-		led_pin = <&gpio_ao  GPIOAO_3  GPIO_ACTIVE_HIGH>;
 	};
 
 	rng {
diff --git a/arch/arm64/boot/dts/amlogic/mesongxm.dtsi b/arch/arm64/boot/dts/amlogic/mesongxm.dtsi
index facfdbe..54cc6ab 100644
--- a/arch/arm64/boot/dts/amlogic/mesongxm.dtsi
+++ b/arch/arm64/boot/dts/amlogic/mesongxm.dtsi
@@ -66,6 +66,7 @@
 			enable-method = "psci";
 			clocks = <&scpi_dvfs 0>;
 			clock-names = "cpu-cluster.0";
+			/*cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;*/
 		};
 
 		CPU1:cpu@1 {
@@ -75,6 +76,7 @@
 			enable-method = "psci";
 			clocks = <&scpi_dvfs 0>;
 			clock-names = "cpu-cluster.0";
+			/*cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;*/
 		};
 		CPU2:cpu@2 {
 			device_type = "cpu";
@@ -83,6 +85,7 @@
 			enable-method = "psci";
 			clocks = <&scpi_dvfs 0>;
 			clock-names = "cpu-cluster.0";
+			/*cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;*/
 		};
 
 		CPU3:cpu@3 {
@@ -92,6 +95,7 @@
 			enable-method = "psci";
 			clocks = <&scpi_dvfs 0>;
 			clock-names = "cpu-cluster.0";
+			/*cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;*/
 		};
 
 		CPU4:cpu@100 {
@@ -101,6 +105,7 @@
 			enable-method = "psci";
 			clocks = <&scpi_dvfs 1>;
 			clock-names = "cpu-cluster.1";
+			/*cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;*/
 		};
 
 		CPU5:cpu@101 {
@@ -110,6 +115,7 @@
 			enable-method = "psci";
 			clocks = <&scpi_dvfs 1>;
 			clock-names = "cpu-cluster.1";
+			/*cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;*/
 		};
 		CPU6:cpu@102 {
 			device_type = "cpu";
@@ -118,6 +124,7 @@
 			enable-method = "psci";
 			clocks = <&scpi_dvfs 1>;
 			clock-names = "cpu-cluster.1";
+			/*cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;*/
 		};
 
 		CPU7:cpu@103 {
@@ -127,6 +134,29 @@
 			enable-method = "psci";
 			clocks = <&scpi_dvfs 1>;
 			clock-names = "cpu-cluster.1";
+			/*cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;*/
+		};
+
+		idle-states {
+			entry-method = "arm,psci";
+
+			CPU_SLEEP_0: cpu-sleep-0 {
+				/*compatible = "arm, idle-state";*/
+				arm,psci-suspend-param = <0x0010000>;
+				local-timer-stop;
+				entry-latency-us = <5000>;
+				exit-latency-us = <8000>;
+				min-residency-us = <20000>;
+			};
+
+			CLUSTER_SLEEP_0: cluster-sleep-0 {
+				/*compatible = "arm, idle-state";*/
+				arm,psci-suspend-param = <0x1010000>;
+				local-timer-stop;
+				entry-latency-us = <5000>;
+				exit-latency-us = <8000>;
+				min-residency-us = <25000>;
+			};
 		};
 	};
 
@@ -137,6 +167,18 @@
 			        <GIC_PPI 11 0xff01>,
 			        <GIC_PPI 10 0xff01>;
 	};
+	timer_bc {
+		compatible = "arm, meson-bc-timer";
+		reg=   <0x0 0xc1109990 0x0 0x4 0x0 0xc1109994 0x0 0x4>;
+		timer_name = "Meson TimerF";
+		clockevent-rating=<300>;
+		clockevent-shift=<20>;
+		clockevent-features=<0x23>;
+		interrupts = <0 60 1>;
+		bit_enable=<16>;
+		bit_mode=<12>;
+		bit_resolution=<0>;
+	};
 	arm_pmu {
 		compatible = "arm,armv8-pmuv3";
 		interrupts = <0 137 4>,
@@ -275,15 +317,20 @@
 			gpio-controller;
 			#gpio-cells = <2>;
 		};
-		eth_pins:eth_pins{
-                        amlogic,setmask =<4 0xfffc00>;
-                        amlogic,clrmask =<4 0x3fc>,
-                                         <3 0xfffff800>;
-                        amlogic,pins="GPIOZ_0","GPIOZ_1","GPIOZ_2","GPIOZ_3",
-                                "GPIOZ_4","GPIOZ_5","GPIOZ_6","GPIOZ_7",
-                                "GPIOZ_8","GPIOZ_9","GPIOZ_10","GPIOZ_11",
-                                "GPIOZ_12","GPIOZ_13","GPIOZ_15";
-                };
+		external_eth_pins:external_eth_pins{
+			amlogic,setmask =<4 0xfffc00>;
+			amlogic,clrmask =<4 0x3fc>,
+					 <3 0xffcff800>;
+			amlogic,pins="GPIOZ_0","GPIOZ_1","GPIOZ_2","GPIOZ_3",
+			"GPIOZ_4","GPIOZ_5","GPIOZ_6","GPIOZ_7",
+			"GPIOZ_8","GPIOZ_9","GPIOZ_10","GPIOZ_11",
+			"GPIOZ_12","GPIOZ_13";
+		};
+		internal_eth_pins:internal_eth_pins{
+			amlogic,setmask =<4 0x3000000>;
+			amlogic,clrmask =<3 0x300000>;
+			amlogic,pins="GPIOZ_14","GPIOZ_15";
+    };
 		jtag_apao_pins:jtag_apao_pin{
 			amlogic,clrmask = <6 0x7fe0000>;
 			amlogic,pins = "GPIOH_6","GPIOH_7","GPIOH_8","GPIOH_9";
diff --git a/arch/arm64/boot/dts/amlogic/mesongxtvbb.dtsi b/arch/arm64/boot/dts/amlogic/mesongxtvbb.dtsi
index 98d8cbb..f10b32d 100644
--- a/arch/arm64/boot/dts/amlogic/mesongxtvbb.dtsi
+++ b/arch/arm64/boot/dts/amlogic/mesongxtvbb.dtsi
@@ -49,6 +49,18 @@
 			        <GIC_PPI 10 0xff01>;
 	};
 
+	timer_bc {
+		compatible = "arm, meson-bc-timer";
+		reg=   <0x0 0xc1109990 0x0 0x4 0x0 0xc1109994 0x0 0x4>;
+		timer_name = "Meson TimerF";
+		clockevent-rating=<300>;
+		clockevent-shift=<20>;
+		clockevent-features=<0x03>;
+		interrupts = <0 60 1>;
+		bit_enable=<16>;
+		bit_mode=<12>;
+		bit_resolution=<0>;
+	};
 	arm_pmu {
 		compatible = "arm,armv8-pmuv3";
 		interrupts = <0 137 4>,
@@ -227,6 +239,12 @@
 			amlogic,pins="GPIOH_1", "GPIOH_2";
 		};
 
+		b_uart_pins_y:b_uart_y{
+			amlogic,setmask=<10 0x3000>;
+			amlogic,clrmask=<10 0x1e0c000>;
+			amlogic,pins="GPIOY_12", "GPIOY_13";
+		};
+
 		wifi_32k_pins:wifi_32k_pins{
 			amlogic,setmask=<7 0x8000000>;
 			amlogic,clrmask=<7 0x12020000>;
diff --git a/arch/arm64/boot/dts/amlogic/mesontxl-panel.dtsi b/arch/arm64/boot/dts/amlogic/mesontxl-panel.dtsi
new file mode 100644
index 0000000..03df327
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/mesontxl-panel.dtsi
@@ -0,0 +1,271 @@
+/*
+ * arch/arm64/boot/dts/amlogic/mesontxl-panel.dtsi
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/ {
+	lcd {
+		compatible = "amlogic, lcd";
+		dev_name = "lcd";
+		mode = "tv";
+		status = "okay";
+		key_valid = <0>;
+		resets = <&clock GCLK_IDX_VCLK2_ENCL &clock GCLK_IDX_VCLK2_VENCL>;
+		reset-names = "encl","vencl";
+		interrupts = <0 78 1 0 3 1>;
+		interrupt-names = "vbyone","vbyone_vsync";
+		pinctrl-names = "vbyone";
+		pinctrl-0 = <&lcd_vbyone_pins>;
+
+		/* power type:(0=cpu_gpio, 1=pmu_gpio, 2=signal, 3=extern, 0xff=ending) */
+		/* power index:(point gpios_index, or extern_index, 0xff=invalid) */
+		/* power value:(0=output low, 1=output high, 2=input) */
+		/* power delay:(unit in ms) */
+		lcd_cpu-gpios = <&gpio GPIOH_3 1 &gpio GPIOH_4 1>;
+		lcd_cpu_gpio_names = "GPIOH_3","GPIOH_4";
+
+		lvds_0{
+			model_name = "1080p-vfreq";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 20 /* signal disable */
+					0 0 0 100  /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+		lvds_1{
+			model_name = "1080p-pclk";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 20 /* signal disable */
+					0 0 0 100  /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+		lvds_2{
+			model_name = "1080p-hfreq";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 20 /* signal disable */
+					0 0 0 100  /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+
+		vbyone_0{
+			model_name = "public";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <0 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 50 /* panel power on */
+					2 0 0 200   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 50 /* signal disable */
+					0 0 0 100  /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+
+		vbyone_1{
+			model_name = "LG_RDL550WY";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 50 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 50 /* signal disable */
+					0 0 0 100  /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+
+		vbyone_2{
+			model_name = "INL_V580DJ2";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 1 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 50 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 50 /* signal disable */
+					0 0 0 100  /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+
+		vbyone_3{
+			model_name = "BOE_HV550QU2";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			lcd_timing = <33 477 1 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					0 1 0 10  /* 3d_enable=0 */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 30 /* signal disable */
+					0 1 2 0    /* 3d_enable pin reset to input */
+					0 0 0 100  /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+	}; /* end of lcd */
+
+	lcd_extern{
+		compatible = "amlogic, lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
+		key_valid = <0>;
+
+		extern_0{
+			index = <0>;
+			extern_name = "ext_default";
+			status = "disabled";
+			type = <0>; /* 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /* 7bit i2c address */
+			i2c_second_address = <0xff>; /* 7bit i2c address, 0xff for none */
+			i2c_bus = "i2c_bus_d";
+			cmd_size = <9>;
+			/* init on/off: (type, value..., delay), must match cmd_size for every group */
+			/* type: 0x00=cmd(bit[3:0]=1 for second_addr), 0x10=gpio, 0xff=ending*/
+			/* value: i2c or spi cmd, or gpio index & level, fill 0x0 for no use */
+			/* delay: unit ms */
+			init_on = <0x00 0x20 0x01 0x02 0x00 0x40 0xFF 0x00 0x00
+				0x00 0x80 0x02 0x00 0x40 0x62 0x51 0x73 0x00
+				0x00 0x61 0x06 0x00 0x00 0x00 0x00 0x00 0x00
+				0x00 0xC1 0x05 0x0F 0x00 0x08 0x70 0x00 0x00
+				0x00 0x13 0x01 0x00 0x00 0x00 0x00 0x00 0x00
+				0x00 0x3D 0x02 0x01 0x00 0x00 0x00 0x00 0x00
+				0x00 0xED 0x0D 0x01 0x00 0x00 0x00 0x00 0x00
+				0x00 0x23 0x02 0x00 0x00 0x00 0x00 0x00 0x0A
+				0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00>;
+			init_off = <0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00>;
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "i2c_T5800Q";
+			status = "disabled";
+			type = <0>; /* 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /* 7bit i2c address */
+			i2c_bus = "i2c_bus_d";
+		};
+	};
+
+	backlight {
+		compatible = "amlogic, backlight";
+		dev_name = "backlight";
+		status = "disable";
+		key_valid = <0>;
+		pinctrl-names = "pwm_on","pwm_vs_on","pwm_combo_on",
+				"pwm_combo_0_on","pwm_combo_1_on";
+		pinctrl-0 = <&bl_pwm_on_pins>;
+		pinctrl-1 = <&bl_pwm_vs_on_pins>;
+		pinctrl-2 = <&bl_pwm_combo_0_on_pins &bl_pwm_combo_1_on_pins>;
+		pinctrl-3 = <&bl_pwm_combo_0_on_pins>;
+		pinctrl-4 = <&bl_pwm_combo_1_on_pins>;
+
+		/* power index:(point gpios_index, 0xff=invalid) */
+		/* power value:(0=output low, 1=output high, 2=input) */
+		/* power delay:(unit in ms) */
+		bl-gpios = <&gpio_ao GPIOAO_4 1 &gpio GPIOZ_6 1 &gpio GPIOZ_4 1>;
+		bl_gpio_names = "GPIOAO_4","GPIOZ_6","GPIOZ_4";
+
+		backlight_0{
+			index = <0>;
+			bl_name = "backlight_pwm";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <1>; /* 1=pwm, 2=pwm_combo, 4=extern */
+			bl_power_attr = <0 0 1 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_port = "PWM_B"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_attr = <0 180 100 25>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_power = <1 0 10 10>; /* pwm_gpio_index, pwm_gpio_off, pwm_on_delay, pwm_off_delay */
+		};
+		backlight_1{
+			index = <1>;
+			bl_name = "backlight_pwm_vs";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <1>; /* 1=pwm, 2=pwm_combo, 4=extern */
+			bl_power_attr = <0 1 0 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_port = "PWM_VS"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_attr = <1 2 100 25>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_power = <1 0 10 10>; /* pwm_gpio_index, pwm_off_value, pwm_on_delay, pwm_off_delay */
+		};
+		backlight_2{
+			index = <2>;
+			bl_name = "backlight_pwm_combo";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <2>; /* 1=pwm, 2=pwm_combo, 4=extern */
+			bl_power_attr = <0 1 0 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_combo_level_mapping = <255 100 100 10>; /* level_max, level_min */
+			bl_pwm_combo_port = "PWM_B","PWM_D"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_combo_attr = <1 180 100 25
+					     1 18000 100 20>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_combo_power = <1 0 2 0 10 10>; /* pwm0_gpio_index, pwm0_gpio_off, pwm1_gpio_index, pwm1_gpio_off, pwm_on_delay, pwm_off_delay */
+		};
+	}; /* end of backlight */
+
+};/* end of / */
+
diff --git a/arch/arm64/boot/dts/amlogic/mesontxl.dtsi b/arch/arm64/boot/dts/amlogic/mesontxl.dtsi
new file mode 100644
index 0000000..9e1c3e7
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/mesontxl.dtsi
@@ -0,0 +1,607 @@
+/*
+ * arch/arm64/boot/dts/amlogic/mesontxl.dtsi
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <dt-bindings/clock/txl.h>
+#include <dt-bindings/gpio/txl.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/reset/aml_txl.h>
+#include <dt-bindings/thermal/thermal.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+#include "mesongxbb-gpu-mali450.dtsi"
+
+/ {
+	cpus:cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+		#cooling-cells = <2>; /* min followed by max */
+
+		cpu0:cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53","arm,armv8";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+		};
+
+		cpu1:cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53","arm,armv8";
+			reg = <0x0 0x1>;
+			enable-method = "psci";
+		};
+		cpu2:cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53","arm,armv8";
+			reg = <0x0 0x2>;
+			enable-method = "psci";
+		};
+
+		cpu3:cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53","arm,armv8";
+			reg = <0x0 0x3>;
+			enable-method = "psci";
+		};
+
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 0xff01>,
+			     <GIC_PPI 14 0xff01>,
+			     <GIC_PPI 11 0xff01>,
+			     <GIC_PPI 10 0xff01>;
+	};
+
+	arm_pmu {
+		compatible = "arm,armv8-pmuv3";
+		interrupts = <0 137 4>,
+			     <0 138 4>,
+			     <0 153 4>,
+			     <0 154 4>;
+	};
+
+	meson_suspend:pm {
+		compatible = "amlogic, pm";
+		device_name = "aml_pm";
+		gxbaby-suspend;
+		reg = <0x0 0xc81000a8 0x0 0x4
+		       0x0 0xc810023c 0x0 0x4>;
+	};
+
+	gic: interrupt-controller@2c001000 {
+		compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x0 0xc4301000 0 0x1000>,
+		      <0x0 0xc4302000 0 0x0100>;
+		interrupts = <GIC_PPI 9 0xf04>;
+	};
+
+	aml_restart {
+		compatible = "aml, restart";
+		sys_reset = <0x84000009>;
+		sys_poweroff = <0x84000008>;
+	};
+
+	psci {
+		compatible = "arm,psci";
+		method = "smc";
+		cpu_suspend = <0xC4000001>;
+		cpu_off = <0x84000002>;
+		cpu_on = <0xC4000003>;
+		migrate = <0xC4000005>;
+	};
+
+	secmon {
+		compatible = "amlogic, secmon";
+		memory-region = <&secmon_reserved>;
+		in_base_func = <0x82000020>;
+		out_base_func = <0x82000021>;
+	};
+
+	securitykey {
+		compatible = "aml, securitykey";
+		storage_query = <0x82000060>;
+		storage_read = <0x82000061>;
+		storage_write = <0x82000062>;
+		storage_tell = <0x82000063>;
+		storage_verify = <0x82000064>;
+		storage_status = <0x82000065>;
+		storage_list = <0x82000067>;
+		storage_remove = <0x82000068>;
+		storage_in_func = <0x82000023>;
+		storage_out_func = <0x82000024>;
+		storage_block_func = <0x82000025>;
+		storage_size_func = <0x82000027>;
+	};
+
+	cpu_iomap {
+		compatible = "amlogic, iomap";
+		#address-cells=<2>;
+		#size-cells=<2>;
+		ranges;
+		io_cbus_base {
+			reg = <0x0 0xc1100000 0x0 0x100000>;
+		};
+		io_apb_base {
+			reg = <0x0 0xd0000000 0x0 0x200000>;
+		};
+		io_aobus_base {
+			reg = <0x0 0xc8100000 0x0 0x100000>;
+		};
+	};
+
+	cpufreq-meson {
+		compatible = "amlogic, cpufreq-scpi";
+		status = "okay";
+		clocks = <&scpi_dvfs 0>;
+		clock-names = "cpu_clk";
+        };
+
+	amlogic-watchdog {
+		compatible = "amlogic, gx-wdt";
+		status = "disable";
+		default_timeout=<10>;
+		reset_watchdog_method=<1>;//0:sysfs,1:kernel
+		reset_watchdog_time=<2>;
+		shutdown_timeout=<10>;
+		firmware_timeout=<6>;
+		suspend_timeout=<6>;
+		reg = <0x0 0xc11098d0 0x0 0x10>;
+		clocks = <&clock CLK_XTAL>;
+	};
+
+	amlogic-jtag {
+		compatible = "amlogic, jtag";
+		status = "okay";
+		pinctrl-names = "jtag_apao_pins", "jtag_apee_pins";
+		pinctrl-0 = <&jtag_apao_pins>;
+		pinctrl-1 = <&jtag_apee_pins>;
+	};
+
+	clock: meson_clock {
+		compatible = "amlogic, txl-clock";
+		reg = <0x0 0xc883c000 0x0 0x1000>,   /* HIU BUS */
+		      <0x0 0xc8100000 0x0 0x1000>;   /* AOBUS */
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+		sys_max = <1536000000>;
+	};
+
+	cpu_info {
+		compatible = "amlogic, cpuinfo";
+		cpuinfo_cmd = <0x82000044>;
+	};
+
+	pinmux: pinmux {
+		compatible = "amlogic, pinmux-txl";
+		dev_name = "pinmux";
+		#pinmux-cells=<2>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		reg = <0x0 0xc1109880 0x0 0x10>;
+		ranges;
+		gpio: banks@c11080b0 {
+			reg = <0x0 0xc88344b0 0x0 0x28>,
+			      <0x0 0xc88344e8 0x0 0x14>,
+			      <0x0 0xc8834520 0x0 0x14>,
+			      <0x0 0xc8834430 0x0 0x40>;
+			reg-names = "mux", "pull", "pull-enable", "gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+		gpio_ao: ao-bank@c1108030 {
+			reg = <0x0 0xc8100014 0x0 0x8>,
+			      <0x0 0xc810002c 0x0 0x4>,
+			      <0x0 0xc8100024 0x0 0x8>;
+			reg-names = "mux", "pull", "gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		avin_gpio_disable_pull:avin_gpio_disable_pull{
+			amlogic,pins = "GPIODV_8","GPIODV_7";
+			amlogic,enable-output=<1>;
+			amlogic,pullupen=<0>;
+		};
+
+		jtag_apao_pins:jtag_apao_pin{
+			amlogic,clrmask = <AO 0x01C2C2E6>;
+			amlogic,pins = "GPIOAO_3","GPIOAO_4","GPIOAO_5","GPIOAO_7";
+		};
+		jtag_apee_pins:jtag_apee_pin{
+			amlogic,clrmask = <6 0xF000F03C>;
+			amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3";
+		};
+		hdmitx_aocec: hdmitx_aocec {
+			amlogic,setmask=<AO  0x00008000>;
+			amlogic,clrmask=<AO  0x00024000>;
+			amlogic,pins="GPIOAO_7";
+		};
+		hdmitx_eecec: hdmitx_eecec {
+			amlogic,setmask=<AO  0x00004000>;
+			amlogic,clrmask=<AO  0x00028000>;
+			amlogic,pins="GPIOAO_7";
+		};
+		remote_pins:remote_pin{
+			amlogic,setmask = <AO 0x1>;
+			amlogic,clrmask = <AO 0x200000>;
+			amlogic,pins = "GPIOAO_6";
+		};
+		uart_ao_a_pins:uart_ao_a{
+			amlogic,setmask = <AO 0x1800>;
+			amlogic,clrmask = <AO 0x6000000>;
+			amlogic,pins="GPIOAO_0", "GPIOAO_1";
+		};
+		uart_ao_a_2_pins:uart_ao_a_2{
+			amlogic,setmask = <6 0x300>;
+			amlogic,clrmask = <6 0x0C000C03>;
+			amlogic,pins="CARD_4", "CARD_5";
+		};
+		uart_ao_a_3_pins:uart_ao_a_3{
+			amlogic,setmask = <6 0xC00>;
+			amlogic,clrmask = <6 0x0C000303>;
+			amlogic,pins="CARD_4", "CARD_5";
+		};
+		uart_ao_b_pins:uart_ao_b{
+			amlogic,setmask = <AO 0x6000000>;
+			amlogic,clrmask = <AO 0x1800>;
+			amlogic,pins="GPIOAO_0", "GPIOAO_1";
+		};
+		uart_ao_b_2_pins:uart_ao_b_2{
+			amlogic,setmask = <AO 0x1800000>;
+			amlogic,clrmask = <AO 0x66>;
+			amlogic,pins="GPIOAO_4", "GPIOAO_5";
+		};
+		uart_a_pins:uart_a{
+			amlogic,setmask=<2 0x7800>;
+			amlogic,clrmask=<2 0x3C00066E>;
+			amlogic,pins="GPIODV_8", "GPIODV_9", "GPIODV_10", "GPIODV_11";
+		};
+		uart_b_pins:uart_b{
+			amlogic,setmask=<3 0x3000000>;
+			amlogic,clrmask = <4 0x60>,
+					<3 0x80200000>;
+			amlogic,pins="GPIOZ_15", "GPIOZ_16";
+		};
+		uart_c_pins:uart_c{
+			amlogic,setmask=<4 0x3000000>;
+			amlogic,clrmask=<4 0xC0000000>,
+					<3 0x218000>;
+			amlogic,pins="GPIOZ_0", "GPIOZ_1";
+		};
+		sd_clk_cmd_pins:sd_clk_cmd_pins{
+			amlogic,setmask=<6 0x0000000c>;
+			amlogic,pins = "CARD_2","CARD_3"; /* CARD_2:CLK, CARD_3:CMD */
+			amlogic,enable-output=<1>; /* 0:output, 1:input */
+			amlogic,pullup=<1>;
+			amlogic,pullupen=<1>;
+		};
+		sd_all_pins:sd_all_pins{
+			amlogic,setmask=<6 0x0000003f>;
+			amlogic,clrmask=<6 0xFC00FF00>;
+			amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+			amlogic,enable-output=<1>; /* 0:output, 1:input */
+			amlogic,pullup=<1>;
+			amlogic,pullupen=<1>;
+		};
+		sd_1bit_pins:sd_1bit_pins{
+			amlogic,setmask=<6 0x0000001c>;
+			amlogic,clrmask=<6 0x70007F03>;
+			amlogic,pins = "CARD_1","CARD_2","CARD_3";
+			amlogic,enable-output=<1>; /* 0:output, 1:input */
+			amlogic,pullup=<1>;
+			amlogic,pullupen=<1>;
+		};
+		sd_clk_cmd_uart_pins:sd_clk_cmd_uart_pins{
+			amlogic,setmask=<6 0x0000030c>;
+			amlogic,clrmask=<6 0x3C003C03>;
+			amlogic,pins = "CARD_2","CARD_3"; /* CARD_2:CLK, CARD_3:CMD */
+			amlogic,enable-output=<1>; /* 0:output, 1:input */
+			amlogic,pullup=<1>;
+			amlogic,pullupen=<1>;
+		};
+		sd_1bit_uart_pins:sd_1bit_uart_pins{
+			amlogic,setmask=<6 0x0000031c>;
+			amlogic,clrmask=<6 0x7C007C03>;
+			amlogic,pins = "CARD_1","CARD_2","CARD_3";
+			amlogic,enable-output=<1>; /* 0:output, 1:input */
+			amlogic,pullup=<1>;
+			amlogic,pullupen=<1>;
+		};
+		emmc_clk_cmd_pins:emmc_clk_cmd_pins{
+			amlogic,setmask=<7 0x60000000>;
+			amlogic,pins = "BOOT_8","BOOT_10"; /** BOOT_10:CMD, BOOT_8:CLK */
+			amlogic,enable-output=<1>; /** 0:output, 1:input */
+			amlogic,pullup=<1>;
+			amlogic,pullupen=<1>;
+		};
+		emmc_conf_pull_up:emmc_conf_pull_up{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+				       "BOOT_5","BOOT_6","BOOT_7","BOOT_8","BOOT_10";
+			amlogic,pullup=<1>;
+			amlogic,pullupen=<1>;
+		};
+		emmc_conf_pull_done:emmc_conf_pull_done{
+			amlogic,pins = "BOOT_11";
+			amlogic,pullup=<0>;
+			amlogic,pullupen=<1>;
+		};
+		emmc_all_pins:emmc_all_pins{
+			amlogic,setmask=<7 0xf0000000>;         /*sdhc c*/
+			amlogic,clrmask=<7 0x00F83C00>;
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+				       "BOOT_5","BOOT_6","BOOT_7","BOOT_8","BOOT_10","BOOT_11";
+			amlogic,enable-output=<1>; /** 0:output, 1:input */
+		};
+		atvdemod_agc: atvdemod_agc {
+			amlogic,setmask=<2  0x800000>;
+			amlogic,clrmask=<2  0x500000>;
+			amlogic,pins="GPIODV_2";
+		};
+		dtvdemod_agc: dtvdemod_agc {
+			amlogic,setmask=<2  0x400000>;
+			amlogic,clrmask=<2  0x980000>;
+			amlogic,pins="GPIODV_2";
+		};
+		i2c_a_master:i2c_a{
+			amlogic,setmask=<4 0x1800>;
+			amlogic,clrmask=<3 0x200000>;
+			amlogic,pins="GPIOZ_8","GPIOZ_9";
+		};
+		i2c_b_master:i2c_b{
+			amlogic,setmask=<2 0x03000000>;
+			amlogic,clrmask=<2 0x80000000>;
+			amlogic,pins="GPIODV_0","GPIODV_1";
+		};
+		i2c_c_master:i2c_c{
+			amlogic,setmask=<0 0x30000000>;
+			amlogic,pins="GPIOH_2","GPIOH_3";
+		};
+		i2c_d_master:i2c_d{
+			amlogic,setmask=<4 0x00300000>;
+			amlogic,clrmask=<4 0x30c00000 3 0x00006000>;
+			amlogic,pins="GPIOZ_2","GPIOZ_3";
+		};
+		lcd_vbyone_pins:lcd_vbyone_pin {
+			amlogic,setmask = <0 0xC0000000>;
+			amlogic,pins = "GPIOH_0","GPIOH_1";
+		};
+	}; /* end of pinmux */
+
+	cpu_version {
+		reg=<0x0 0xc8100220 0x0 0x4>;
+	};
+
+	meson_clk_msr {
+		compatible = "amlogic, txl_measure";
+		reg = <0x0 0xc110875c 0x0 0x4
+		       0x0 0xc1108764 0x0 0x4>;
+	};
+
+	i2c_a: i2c@c1108500 { /*I2C-A*/
+		compatible = "amlogic, meson-i2c";
+		dev_name = "i2c-A";
+		status = "disabled";
+		reg = <0x0 0xc1108500 0x0 0x20>;
+		device_id = <1>;
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_a_master>;/*p200 i2c-A multiplex with usb PWR*/
+		#address-cells = <1>;
+		#size-cells = <0>;
+		use_pio = <0>;
+		master_i2c_speed = <300000>;
+		clocks = <&clock CLK_81>;
+		clock-names = "clk_i2c";
+		resets = <&clock GCLK_IDX_I2C>;
+	};
+
+	i2c_b: i2c@c11087c0 { /*I2C-B*/
+		compatible = "amlogic, meson-i2c";
+		dev_name = "i2c-B";
+		status = "disabled";
+		reg = <0x0 0xc11087c0 0x0 0x20>;
+		device_id = <2>;
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_b_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		use_pio = <0>;
+		master_i2c_speed = <300000>;
+		clocks = <&clock CLK_81>;
+		clock-names = "clk_i2c";
+		resets = <&clock GCLK_IDX_I2C>;
+	};
+
+	i2c_c: i2c@c11087e0 { /*I2C-C*/
+		compatible = "amlogic, meson-i2c";
+		dev_name = "i2c-C";
+		status = "disabled";
+		reg = <0x0 0xc11087e0 0x0 0x20>;
+		device_id = <3>;
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		use_pio = <0>;
+		master_i2c_speed = <300000>;
+		clocks = <&clock CLK_81>;
+		clock-names = "clk_i2c";
+		resets = <&clock GCLK_IDX_I2C>;
+	};
+
+	i2c_d: i2c@c1108d20 { /*I2C-D*/
+		compatible = "amlogic, meson-i2c";
+		dev_name = "i2c-D";
+		status = "disabled";
+		reg = <0x0 0xc1108d20 0x0 0x20>;
+		device_id = <4>;
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_d_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		use_pio = <0>;
+		master_i2c_speed = <300000>;
+		clocks = <&clock CLK_81>;
+		clock-names = "clk_i2c";
+		resets = <&clock GCLK_IDX_I2C>;
+	};
+
+	efuse: efuse {
+		compatible = "amlogic, efuse";
+		read_cmd = <0x82000030>;
+		write_cmd = <0x82000031>;
+		get_max_cmd = <0x82000033>;
+		key = <&efusekey>;
+		resets = <&clock GCLK_IDX_EFUSE>;
+		reset-names = "efuse_clk";
+		status = "disabled";
+	};
+
+	efusekey:efusekey {
+		keynum = <4>;
+		key0 = <&key0>;
+		key1 = <&key1>;
+		key2 = <&key2>;
+		key3 = <&key3>;
+		key0:key0{
+			keyname = "mac";
+			offset = <0>;
+			size = <6>;
+		};
+		key1:key1{
+			keyname = "mac_bt";
+			offset = <6>;
+			size = <6>;
+		};
+		key2:key2{
+			keyname = "mac_wifi";
+			offset = <12>;
+			size = <6>;
+		};
+		key3:key3{
+			keyname = "usid";
+			offset = <18>;
+			size = <16>;
+		};
+	};
+
+	mailbox: mhu@c883c400 {
+		compatible = "amlogic, meson_mhu";
+		reg = <0x0 0xc883c400 0x0 0x4c>,   /* MHU registers */
+		      <0x0 0xc8013000 0x0 0x800>;   /* Payload area */
+		interrupts = <0 209 IRQ_TYPE_EDGE_RISING>,   /* low priority interrupt */
+			     <0 210 IRQ_TYPE_EDGE_RISING>;   /* high priority interrupt */
+		#mbox-cells = <1>;
+		mbox-names = "cpu_to_scp_low", "cpu_to_scp_high";
+		mboxes = <&mailbox 0 &mailbox 1>;
+	};
+
+	scpi_clocks {
+		compatible = "arm,scpi-clks";
+
+		scpi_dvfs: scpi_clocks@0 {
+			compatible = "arm,scpi-clk-indexed";
+			#clock-cells = <1>;
+			clock-indices = <0>;
+			clock-output-names = "vcpu";
+		};
+
+	};
+
+	meson-remote {
+		compatible = "amlogic, aml_remote";
+		dev_name = "meson-remote";
+		status = "okay";
+		remote_ao_offset = <0x580>; /* 0x400 + (0x20 + idx)<<2 -- old ; 0x400 + (0x60 +idx)<<2 --new   */
+		interrupts = <0 196 1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&remote_pins>;
+	};
+
+	rng {
+		compatible = "amlogic,meson-rng";
+		reg = <0x0 0xc8834000 0x0 0x4>;
+	};
+
+	audio_data:audio_data {
+		compatible = "amlogic, audio_data";
+		query_licence_cmd = <0x82000050>;
+		status = "disabled";
+	};
+
+	saradc: saradc {
+		compatible = "amlogic, saradc";
+		status = "okay";
+		interrupts = <0 9 1>;
+		interrupt-names = "saradc_int";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "saradc_clk";
+		resets = <&clock GCLK_IDX_SARADC>;
+		reg = <0x0 0xc1108680 0x0 0x30
+					 0x0 0xc883c3d8 0x0 0x08>;
+	};
+
+	defendkey: defendkey {
+		compatible = "amlogic, defendkey";
+		reg = <0x0 0xc8834500 0x0 0x4>; /*RAND64_ADDR0*/
+		mem_size = <0x0 0x100000>;
+		status = "disabled";
+	};
+
+	spicc:spicc {
+		compatible = "amlogic, spicc";
+		status = "disabled";
+		reg = <0x0 0xc1108d80 0x0 0x28>;
+		resets = <&clock GCLK_IDX_SPICC>;
+		clocks = <&clock CLK_81>;
+		clock-names = "spicc_clk";
+		interrupts = <0 81 1>;
+		device_id = <0>;
+	};
+
+	aml_aes {
+		 compatible = "amlogic,aes_dma";
+		 dev_name = "aml_aes_dma";
+		 interrupts = <0 188 1
+			 0 189 1>;
+		 reg = <0x0 0xc883e000 0x0 0x28>;
+	 };
+	 aml_tdes {
+		 compatible = "amlogic,des_dma,tdes_dma";
+		 dev_name = "aml_tdes_dma";
+		 interrupts = <0 188 1
+			 0 189 1>;
+		 reg = <0x0 0xc883e000 0x0 0x28>;
+	 };
+
+	 aml_sha {
+		 compatible = "amlogic,sha_dma";
+		 dev_name = "aml_sha_dma";
+		 interrupts = <0 188 1
+			 0 189 1>;
+		 reg = <0x0 0xc883e000 0x0 0x28>;
+	 };
+
+};/* end of / */
+
+&gpu{
+/*gpu max freq is 750M*/
+    tbl = <&clk125_cfg &clk285_cfg &clk400_cfg &clk500_cfg &clk666_cfg &clk750_cfg &clk750_cfg>;
+};
diff --git a/arch/arm64/boot/dts/amlogic/mesontxl_p320-panel.dtsi b/arch/arm64/boot/dts/amlogic/mesontxl_p320-panel.dtsi
new file mode 100644
index 0000000..2035df3
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/mesontxl_p320-panel.dtsi
@@ -0,0 +1,278 @@
+/*
+ * arch/arm64/boot/dts/amlogic/mesontxl_p320-panel.dtsi
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/ {
+	lcd {
+		compatible = "amlogic, lcd";
+		dev_name = "lcd";
+		mode = "tv";
+		status = "okay";
+		fr_auto_policy = <1>; /* 0=disable, 1=60/50hz, 2=60/50/48hz */
+		key_valid = <0>;
+		resets = <&clock GCLK_IDX_VCLK2_ENCL &clock GCLK_IDX_VCLK2_VENCL>;
+		reset-names = "encl","vencl";
+		interrupts = <0 78 1 0 3 1>;
+		interrupt-names = "vbyone","vbyone_vsync";
+		pinctrl-names = "vbyone";
+		pinctrl-0 = <&lcd_vbyone_pins>;
+
+		/* power type:(0=cpu_gpio, 1=pmu_gpio, 2=signal, 3=extern, 0xff=ending) */
+		/* power index:(point gpios_index, or extern_index, 0xff=invalid) */
+		/* power value:(0=output low, 1=output high, 2=input) */
+		/* power delay:(unit in ms) */
+		lcd_cpu-gpios = <&gpio GPIOH_7 1 &gpio GPIOZ_3 1
+				&gpio GPIOH_4 1 &gpio GPIOH_5 1
+				&gpio GPIOH_6 1>;
+		lcd_cpu_gpio_names = "GPIOH_7","GPIOZ_3","GPIOH_4","GPIOH_5","GPIOH_6";
+
+		lvds_0{
+			model_name = "1080p-vfreq";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2060 2650 1100 1480 120000000 160000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+		lvds_1{
+			model_name = "1080p-hfreq";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2080 2720 1100 1380 133940000 156000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+
+		vbyone_0{
+			model_name = "public_2region";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <3>;
+		};
+		vbyone_1{
+			model_name = "INL_V580DJ2";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2790 552000000 632000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 1 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <3>;
+		};
+		vbyone_2{
+			model_name = "public_2region";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <3>;
+		};
+		vbyone_3{
+			model_name = "BOE_HV550QU2";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 560000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 1 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					0 1 0 10  /* 3d_disable */
+					2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 1 2 0   /* 3d_disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <3>;
+		};
+	}; /* end of lcd */
+
+	lcd_extern{
+		compatible = "amlogic, lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
+		key_valid = <0>;
+
+		extern_0{
+			index = <0>;
+			extern_name = "ext_default";
+			status = "disabled";
+			type = <0>; /* 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /* 7bit i2c address */
+			i2c_second_address = <0xff>; /* 7bit i2c address, 0xff for none */
+			i2c_bus = "i2c_bus_d";
+			cmd_size = <9>;
+			/* init on/off: (type, value..., delay), must match cmd_size for every group */
+			/* type: 0x00=cmd(bit[3:0]=1 for second_addr), 0x10=gpio, 0xff=ending*/
+			/* value: i2c or spi cmd, or gpio index & level, fill 0x0 for no use */
+			/* delay: unit ms */
+			init_on = <0x00 0x20 0x01 0x02 0x00 0x40 0xFF 0x00 0x00
+				0x00 0x80 0x02 0x00 0x40 0x62 0x51 0x73 0x00
+				0x00 0x61 0x06 0x00 0x00 0x00 0x00 0x00 0x00
+				0x00 0xC1 0x05 0x0F 0x00 0x08 0x70 0x00 0x00
+				0x00 0x13 0x01 0x00 0x00 0x00 0x00 0x00 0x00
+				0x00 0x3D 0x02 0x01 0x00 0x00 0x00 0x00 0x00
+				0x00 0xED 0x0D 0x01 0x00 0x00 0x00 0x00 0x00
+				0x00 0x23 0x02 0x00 0x00 0x00 0x00 0x00 0x0A
+				0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00>;
+			init_off = <0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00>;
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "i2c_T5800Q";
+			status = "disabled";
+			type = <0>; /* 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /* 7bit i2c address */
+			i2c_bus = "i2c_bus_d";
+		};
+	};
+
+	backlight{
+		compatible = "amlogic, backlight";
+		dev_name = "backlight";
+		status = "okay";
+		key_valid = <0>;
+		pinctrl-names = "pwm_on","pwm_vs_on","pwm_combo_on",
+				"pwm_combo_0_on","pwm_combo_1_on";
+		pinctrl-0 = <&bl_pwm_on_pins>;
+		pinctrl-1 = <&bl_pwm_vs_on_pins>;
+		pinctrl-2 = <&bl_pwm_combo_0_on_pins &bl_pwm_combo_1_on_pins>;
+		pinctrl-3 = <&bl_pwm_combo_0_on_pins>;
+		pinctrl-4 = <&bl_pwm_combo_1_on_pins>;
+
+		/* power index:(point gpios_index, 0xff=invalid) */
+		/* power value:(0=output low, 1=output high, 2=input) */
+		/* power delay:(unit in ms) */
+		bl-gpios = <&gpio GPIOZ_2 1 &gpio GPIOZ_6 1 &gpio GPIOZ_7 1>;
+		bl_gpio_names = "GPIOZ_2","GPIOZ_6","GPIOZ_7";
+
+		backlight_0{
+			index = <0>;
+			bl_name = "backlight_pwm";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <1>; /* 1=pwm, 2=pwm_combo */
+			bl_power_attr = <0 0 1 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_port = "PWM_B"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_attr = <0 180 100 25>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_power = <1 0 10 10>; /* pwm_gpio_index, pwm_gpio_off, pwm_on_delay, pwm_off_delay */
+		};
+		backlight_1{
+			index = <1>;
+			bl_name = "backlight_pwm_vs";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <1>; /* 1=pwm, 2=pwm_combo */
+			bl_power_attr = <0 1 0 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_port = "PWM_VS"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_attr = <1 2 100 25>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_power = <1 0 10 10>; /* pwm_gpio_index, pwm_off_value, pwm_on_delay, pwm_off_delay */
+		};
+		backlight_2{
+			index = <2>;
+			bl_name = "backlight_pwm_combo";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <2>; /* 1=pwm, 2=pwm_combo */
+			bl_power_attr = <0 1 0 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_combo_level_mapping = <255 100 100 10>; /* level_max, level_min */
+			bl_pwm_combo_port = "PWM_B","PWM_C"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_combo_attr = <1 180 100 25
+					     1 18000 100 20>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_combo_power = <1 0 2 0 10 10>; /* pwm0_gpio_index, pwm0_gpio_off, pwm1_gpio_index, pwm1_gpio_off, pwm_on_delay, pwm_off_delay */
+		};
+		backlight_3{
+			index = <3>;
+			bl_name = "backlight_pwm_combo";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <2>; /* 1=pwm, 2=pwm_combo */
+			bl_power_attr = <0 1 0 410 110>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_combo_level_mapping = <255 10 0 0>; /* level_max, level_min */
+			bl_pwm_combo_port = "PWM_B","PWM_C"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_combo_attr = <1 180 100 25
+					     1 18000 90 90>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_combo_power = <1 0 2 0 10 10>; /* pwm0_gpio_index, pwm0_gpio_off, pwm1_gpio_index, pwm1_gpio_off, pwm_on_delay, pwm_off_delay */
+		};
+	};
+};/* end of / */
+
diff --git a/arch/arm64/boot/dts/amlogic/mesontxl_p321-panel.dtsi b/arch/arm64/boot/dts/amlogic/mesontxl_p321-panel.dtsi
new file mode 100644
index 0000000..b7d9a7a
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/mesontxl_p321-panel.dtsi
@@ -0,0 +1,278 @@
+/*
+ * arch/arm64/boot/dts/amlogic/mesontxl_p321-panel.dtsi
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/ {
+	lcd {
+		compatible = "amlogic, lcd";
+		dev_name = "lcd";
+		mode = "tv";
+		status = "okay";
+		fr_auto_policy = <1>; /* 0=disable, 1=60/50hz, 2=60/50/48hz */
+		key_valid = <0>;
+		resets = <&clock GCLK_IDX_VCLK2_ENCL &clock GCLK_IDX_VCLK2_VENCL>;
+		reset-names = "encl","vencl";
+		interrupts = <0 78 1 0 3 1>;
+		interrupt-names = "vbyone","vbyone_vsync";
+		pinctrl-names = "vbyone";
+		pinctrl-0 = <&lcd_vbyone_pins>;
+
+		/* power type:(0=cpu_gpio, 1=pmu_gpio, 2=signal, 3=extern, 0xff=ending) */
+		/* power index:(point gpios_index, or extern_index, 0xff=invalid) */
+		/* power value:(0=output low, 1=output high, 2=input) */
+		/* power delay:(unit in ms) */
+		lcd_cpu-gpios = <&gpio GPIOH_7 1 &gpio GPIOZ_3 1
+				&gpio GPIOH_4 1 &gpio GPIOH_5 1
+				&gpio GPIOH_6 1>;
+		lcd_cpu_gpio_names = "GPIOH_7","GPIOZ_3","GPIOH_4","GPIOH_5","GPIOH_6";
+
+		lvds_0{
+			model_name = "1080p-vfreq";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2060 2650 1100 1480 120000000 160000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+		lvds_1{
+			model_name = "1080p-hfreq";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2080 2720 1100 1380 133940000 156000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0>;
+		};
+
+		vbyone_0{
+			model_name = "public_2region";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <3>;
+		};
+		vbyone_1{
+			model_name = "INL_V580DJ2";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2790 552000000 632000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 1 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <3>;
+		};
+		vbyone_2{
+			model_name = "public_2region";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <1 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <3>;
+		};
+		vbyone_3{
+			model_name = "BOE_HV550QU2";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 560000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 1 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <0 0 1 20 /* panel power on */
+					0 1 0 10  /* 3d_disable */
+					2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0 1 2 0   /* 3d_disable */
+					0 0 0 100 /* panel power off */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <3>;
+		};
+	}; /* end of lcd */
+
+	lcd_extern{
+		compatible = "amlogic, lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
+		key_valid = <0>;
+
+		extern_0{
+			index = <0>;
+			extern_name = "ext_default";
+			status = "disabled";
+			type = <0>; /* 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /* 7bit i2c address */
+			i2c_second_address = <0xff>; /* 7bit i2c address, 0xff for none */
+			i2c_bus = "i2c_bus_d";
+			cmd_size = <9>;
+			/* init on/off: (type, value..., delay), must match cmd_size for every group */
+			/* type: 0x00=cmd(bit[3:0]=1 for second_addr), 0x10=gpio, 0xff=ending*/
+			/* value: i2c or spi cmd, or gpio index & level, fill 0x0 for no use */
+			/* delay: unit ms */
+			init_on = <0x00 0x20 0x01 0x02 0x00 0x40 0xFF 0x00 0x00
+				0x00 0x80 0x02 0x00 0x40 0x62 0x51 0x73 0x00
+				0x00 0x61 0x06 0x00 0x00 0x00 0x00 0x00 0x00
+				0x00 0xC1 0x05 0x0F 0x00 0x08 0x70 0x00 0x00
+				0x00 0x13 0x01 0x00 0x00 0x00 0x00 0x00 0x00
+				0x00 0x3D 0x02 0x01 0x00 0x00 0x00 0x00 0x00
+				0x00 0xED 0x0D 0x01 0x00 0x00 0x00 0x00 0x00
+				0x00 0x23 0x02 0x00 0x00 0x00 0x00 0x00 0x0A
+				0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00>;
+			init_off = <0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00>;
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "i2c_T5800Q";
+			status = "disabled";
+			type = <0>; /* 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /* 7bit i2c address */
+			i2c_bus = "i2c_bus_d";
+		};
+	};
+
+	backlight{
+		compatible = "amlogic, backlight";
+		dev_name = "backlight";
+		status = "okay";
+		key_valid = <0>;
+		pinctrl-names = "pwm_on","pwm_vs_on","pwm_combo_on",
+				"pwm_combo_0_on","pwm_combo_1_on";
+		pinctrl-0 = <&bl_pwm_on_pins>;
+		pinctrl-1 = <&bl_pwm_vs_on_pins>;
+		pinctrl-2 = <&bl_pwm_combo_0_on_pins &bl_pwm_combo_1_on_pins>;
+		pinctrl-3 = <&bl_pwm_combo_0_on_pins>;
+		pinctrl-4 = <&bl_pwm_combo_1_on_pins>;
+
+		/* power index:(point gpios_index, 0xff=invalid) */
+		/* power value:(0=output low, 1=output high, 2=input) */
+		/* power delay:(unit in ms) */
+		bl-gpios = <&gpio GPIOZ_2 1 &gpio GPIOZ_6 1 &gpio GPIOZ_7 1>;
+		bl_gpio_names = "GPIOZ_2","GPIOZ_6","GPIOZ_7";
+
+		backlight_0{
+			index = <0>;
+			bl_name = "backlight_pwm";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <1>; /* 1=pwm, 2=pwm_combo */
+			bl_power_attr = <0 0 1 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_port = "PWM_B"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_attr = <0 180 100 25>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_power = <1 0 10 10>; /* pwm_gpio_index, pwm_gpio_off, pwm_on_delay, pwm_off_delay */
+		};
+		backlight_1{
+			index = <1>;
+			bl_name = "backlight_pwm_vs";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <1>; /* 1=pwm, 2=pwm_combo */
+			bl_power_attr = <0 1 0 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_port = "PWM_VS"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_attr = <1 2 100 25>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_power = <1 0 10 10>; /* pwm_gpio_index, pwm_off_value, pwm_on_delay, pwm_off_delay */
+		};
+		backlight_2{
+			index = <2>;
+			bl_name = "backlight_pwm_combo";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <2>; /* 1=pwm, 2=pwm_combo */
+			bl_power_attr = <0 1 0 200 200>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_combo_level_mapping = <255 100 100 10>; /* level_max, level_min */
+			bl_pwm_combo_port = "PWM_B","PWM_C"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_combo_attr = <1 180 100 25
+					     1 18000 100 20>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_combo_power = <1 0 2 0 10 10>; /* pwm0_gpio_index, pwm0_gpio_off, pwm1_gpio_index, pwm1_gpio_off, pwm_on_delay, pwm_off_delay */
+		};
+		backlight_3{
+			index = <3>;
+			bl_name = "backlight_pwm_combo";
+			bl_level_default_uboot_kernel = <100 100>;
+			bl_level_attr = <255 10 128 102>; /* max, min, mid, mid_mapping */
+
+			bl_ctrl_method = <2>; /* 1=pwm, 2=pwm_combo */
+			bl_power_attr = <0 1 0 410 110>; /* en_gpio_index, on_value, off_value, on_delay, off_delay */
+
+			/* pwm_method: 0=negative, 1=positive */
+			/* pwm_freq: pwm_vs: 1~4(vfreq multiple), other pwm: real freq(unit: Hz) */
+			/* duty_max, duty_min: unit in % */
+			bl_pwm_combo_level_mapping = <255 10 0 0>; /* level_max, level_min */
+			bl_pwm_combo_port = "PWM_B","PWM_C"; /* PWM_A, PWM_B, PWM_C, PWM_D, PWM_VS */
+			bl_pwm_combo_attr = <1 180 100 25
+					     1 18000 90 90>; /* pwm_method, pwm_freq, duty_max, duty_min */
+			bl_pwm_combo_power = <1 0 2 0 10 10>; /* pwm0_gpio_index, pwm0_gpio_off, pwm1_gpio_index, pwm1_gpio_off, pwm_on_delay, pwm_off_delay */
+		};
+	};
+};/* end of / */
+
diff --git a/arch/arm64/boot/dts/amlogic/mesontxl_pxp-panel.dtsi b/arch/arm64/boot/dts/amlogic/mesontxl_pxp-panel.dtsi
new file mode 100644
index 0000000..ca6dcf5
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/mesontxl_pxp-panel.dtsi
@@ -0,0 +1,74 @@
+/*
+ * arch/arm64/boot/dts/amlogic/mesontxl_pxp-panel.dtsi
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/ {
+	lcd {
+		compatible = "amlogic, lcd";
+		dev_name = "lcd";
+		mode = "tv";
+		status = "okay";
+		fr_auto_policy = <1>; /* 0=disable, 1=60/50hz, 2=60/50/48hz */
+		key_valid = <0>;
+		resets = <&clock GCLK_IDX_VCLK2_ENCL &clock GCLK_IDX_VCLK2_VENCL>;
+		reset-names = "encl","vencl";
+		interrupts = <0 78 1 0 3 1>;
+		interrupt-names = "vbyone","vbyone_vsync";
+		pinctrl-names = "vbyone";
+		pinctrl-0 = <&lcd_vbyone_pins>;
+
+		/* power type:(0=cpu_gpio, 1=pmu_gpio, 2=signal, 3=extern, 0xff=ending) */
+		/* power index:(point gpios_index, or extern_index, 0xff=invalid) */
+		/* power value:(0=output low, 1=output high, 2=input) */
+		/* power delay:(unit in ms) */
+		lcd_cpu-gpios = <&gpio GPIOH_3 1 &gpio GPIOH_4 1>;
+		lcd_cpu_gpio_names = "GPIOH_3","GPIOH_4";
+
+		lvds_0{
+			model_name = "1080p-vfreq";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2060 2650 1100 1480 120000000 160000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
+			power_on_step = <2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0xff>;
+		};
+
+		vbyone_0{
+			model_name = "public";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0xff>;
+		};
+	}; /* end of lcd */
+
+};/* end of / */
+
diff --git a/arch/arm64/boot/dts/amlogic/mesontxl_skt-panel.dtsi b/arch/arm64/boot/dts/amlogic/mesontxl_skt-panel.dtsi
new file mode 100644
index 0000000..ca6dcf5
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/mesontxl_skt-panel.dtsi
@@ -0,0 +1,74 @@
+/*
+ * arch/arm64/boot/dts/amlogic/mesontxl_pxp-panel.dtsi
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/ {
+	lcd {
+		compatible = "amlogic, lcd";
+		dev_name = "lcd";
+		mode = "tv";
+		status = "okay";
+		fr_auto_policy = <1>; /* 0=disable, 1=60/50hz, 2=60/50/48hz */
+		key_valid = <0>;
+		resets = <&clock GCLK_IDX_VCLK2_ENCL &clock GCLK_IDX_VCLK2_VENCL>;
+		reset-names = "encl","vencl";
+		interrupts = <0 78 1 0 3 1>;
+		interrupt-names = "vbyone","vbyone_vsync";
+		pinctrl-names = "vbyone";
+		pinctrl-0 = <&lcd_vbyone_pins>;
+
+		/* power type:(0=cpu_gpio, 1=pmu_gpio, 2=signal, 3=extern, 0xff=ending) */
+		/* power index:(point gpios_index, or extern_index, 0xff=invalid) */
+		/* power value:(0=output low, 1=output high, 2=input) */
+		/* power delay:(unit in ms) */
+		lcd_cpu-gpios = <&gpio GPIOH_3 1 &gpio GPIOH_4 1>;
+		lcd_cpu_gpio_names = "GPIOH_3","GPIOH_4";
+
+		lvds_0{
+			model_name = "1080p-vfreq";
+			interface = "lvds"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <1920 1080 2200 1125 8 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <2060 2650 1100 1480 120000000 160000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <44 148 0 5 30 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			lvds_attr = <1 1 0 0>; /* lvds_repack, dual_port, pn_swap, port_swap */
+			phy_attr=<3 0 0 0>; /* vswing_level, preemphasis_level, lvds_clk_vswing_level, lvds_clk_preem_level */
+			power_on_step = <2 0 0 0   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0xff>;
+		};
+
+		vbyone_0{
+			model_name = "public";
+			interface = "vbyone"; /* lcd_interface(lvds, vbyone) */
+			basic_setting = <3840 2160 4400 2250 10 16 9>; /* h_active, v_active, h_period, v_period, lcd_bits, screen_widht, screen_height */
+			range_setting = <4240 4800 2200 2760 480000000 624000000>; /* h_period_min,max, v_period_min,max, pclk_min,max */
+			lcd_timing = <33 477 0 6 65 0>; /* hs_width, hs_bp, hs_pol, vs_width, vs_bp, vs_pol */
+			clk_attr = <2 0 1 0>; /* fr_adj_type(0=clock, 1=htotal, 2=vtotal), clk_ss_level, clk_auto_generate, pixel_clk(unit in Hz) */
+			vbyone_attr = <8 2 4 4>; /* lane_count, region_num, byte_mode, color_fmt */
+			phy_attr=<3 0>; /* vswing_level, preemphasis_level */
+			power_on_step = <2 0 0 10   /* signal enable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			power_off_step = <2 0 0 10 /* signal disable */
+					0xff 0 0 0>; /* type, index, value, delay */
+			backlight_index = <0xff>;
+		};
+	}; /* end of lcd */
+
+};/* end of / */
+
diff --git a/arch/arm64/boot/dts/amlogic/odroidc2.dts b/arch/arm64/boot/dts/amlogic/odroidc2.dts
index fef426f..67254b8 100644
--- a/arch/arm64/boot/dts/amlogic/odroidc2.dts
+++ b/arch/arm64/boot/dts/amlogic/odroidc2.dts
@@ -297,6 +297,36 @@
 			6: 500.0M    7: 666.7M */
 	};
 
+	emmc {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_all_pins>;
+		emmc {
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>;
+			caps = "MMC_CAP_8_BIT_DATA", "MMC_CAP_MMC_HIGHSPEED",
+					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE",
+					"MMC_CAP_1_8V_DDR", "MMC_CAP_HW_RESET",
+					"MMC_CAP_ERASE";
+			caps2 = "MMC_CAP2_HS200_1_8V_SDR", "MMC_CAP2_HS400_1_8V",
+					"MMC_CAP2_BROKEN_VOLTAGE",
+					"MMC_CAP2_BOOTPART_NOACC";
+			f_min = <400000>;
+			f_max = <100000000>;
+			tx_phase = <0>;
+			max_req_size = <0x20000>; /**256KB*/
+			gpio_dat3 = <&gpio BOOT_3 GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio BOOT_9 GPIO_ACTIVE_HIGH>;
+			card_type = <1>;
+		};
+	};
+
 	sd {
 		compatible = "amlogic, aml_sd_emmc";
 		dev_name = "aml_newsd.0";
@@ -330,36 +360,6 @@
 		};
 	};
 
-	emmc {
-		compatible = "amlogic, aml_sd_emmc";
-		dev_name = "aml_newsd.0";
-		status = "okay";
-		reg = <0x0 0xd0074000 0x0 0x2000>;
-		interrupts = <0 218 1>;
-		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
-		pinctrl-0 = <&emmc_clk_cmd_pins>;
-		pinctrl-1 = <&emmc_all_pins>;
-		emmc {
-			status = "okay";
-			pinname = "emmc";
-			ocr_avail = <0x200080>;
-			caps = "MMC_CAP_8_BIT_DATA", "MMC_CAP_MMC_HIGHSPEED",
-					"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE",
-					"MMC_CAP_1_8V_DDR", "MMC_CAP_HW_RESET",
-					"MMC_CAP_ERASE";
-			caps2 = "MMC_CAP2_HS200_1_8V_SDR", "MMC_CAP2_HS400_1_8V",
-					"MMC_CAP2_BROKEN_VOLTAGE",
-					"MMC_CAP2_BOOTPART_NOACC";
-			f_min = <400000>;
-			f_max = <100000000>;
-			tx_phase = <0>;
-			max_req_size = <0x20000>; /**256KB*/
-			gpio_dat3 = <&gpio BOOT_3 GPIO_ACTIVE_HIGH>;
-			hw_reset =  <&gpio BOOT_9 GPIO_ACTIVE_HIGH>;
-			card_type = <1>;
-		};
-	};
-
 	amhdmitx: amhdmitx{
 		compatible = "amlogic, amhdmitx";
 		dev_name = "amhdmitx";
diff --git a/arch/arm64/boot/dts/amlogic/txl_p320.dts b/arch/arm64/boot/dts/amlogic/txl_p320.dts
new file mode 100644
index 0000000..85ad1aa
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/txl_p320.dts
@@ -0,0 +1,1380 @@
+/*
+ * arch/arm64/boot/dts/amlogic/txl_320.dts
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/dts-v1/;
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/txl.h>
+#include <dt-bindings/gpio/txl.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/reset/aml_txl.h>
+
+#include "mesontxl.dtsi"
+#include "mesontxl_p320-panel.dtsi"
+
+/ {
+	model = "Amlogic";
+	compatible = "amlogic, txl";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart_AO;
+		serial1 = &uart_A;
+		serial2 = &uart_B;
+		serial3 = &uart_C;
+		serial4 = &uart_AO_B;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		linux,usable-memory = <0x0 0x1000000 0x0 0x7f000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		/* global autoconfigured region for contiguous allocations */
+		secmon_reserved:linux,secmon {
+			compatible = "amlogic, aml_secmon_memory";
+			reg = <0x0 0x10000000 0x0 0x200000>;
+			no-map;
+		};
+
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
+
+		pstore:aml_pstore {
+			compatible = "amlogic, pstore";
+			reg = <0x0 0x07300000 0x0 0x100000>;
+			no-map;
+		};
+
+		fb_reserved:linux,meson-fb {
+			compatible = "amlogic, fb-memory";
+			size = <0x0 0x2000000>;
+			no-map;
+		};
+
+		di_reserved:linux,di {
+			compatible = "amlogic, di-mem";
+			/** 10x(1920x1088x(3/2+1/5)+1088)=34M **/
+			/** 10x(1920x1088x(3/2+1/5)+1088)x3/2=51M support 12bit **/
+			/** 10x(1920x1088x(3/2+1/5)+1088)x5/4=43M support 10bit **/
+			size = <0x0 0x3300000>;
+			//no-map;
+		};
+
+		demod_reserved:linux,demod {
+			compatible = "amlogic, demod-mem";
+			size = <0x0 0x600000>; //20m
+			multi-use;
+			//no-map;
+		};
+
+		ion_reserved:linux,ion-dev {
+			compatible = "amlogic, idev-mem";
+			size = <0x0 0x2000000>;
+		};
+
+		/*  POST PROCESS MANAGER */
+		ppmgr_reserved:linux,ppmgr {
+			compatible = "amlogic, ppmgr_memory";
+			size = <0x0 0x0>;
+			multi-use;
+		};
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0xbc00000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+
+		picdec_cma_reserved:linux,picdec {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x0>;
+			alignment = <0x0 0x0>;
+			linux,contiguous-region;
+		};
+
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x4100000>;
+			alignment = <0x0 0x100000>;
+ 			//no-map;
+		};
+		/*  vdin0 CMA pool */
+		//vdin0_cma_reserved:linux,vdin0_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <4>;
+		//	reusable;
+			/* 3840x2160x2x4  =64+4 M */
+		//	size = <0x0 0x04400000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+		/*  vdin1 CMA pool */
+		vdin1_cma_reserved:linux,vdin1_cma {
+			compatible = "shared-dma-pool";
+			linux,phandle = <5>;
+			reusable;
+			/* 1920x1080x2x4  =16+4 M */
+			size = <0x0 0x01400000>;
+			alignment = <0x0 0x400000>;
+		};
+		/*  tvafe CMA pool */
+		//tvafe_cma_reserved:linux,tvafe_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <6>;
+		//	reusable;
+			/* 5 M */
+		//	size = <0x0 0x00800000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+	};
+
+	ethmac: ethernet@0xc9410000 {
+		compatible = "amlogic, gxbb-rmii-dwmac";
+		reg = <0x0 0xc9410000 0x0 0x10000
+		0x0 0xc8834540 0x0 0x8
+		0x0 0xc8834558 0x0 0xc>;
+		interrupts = <0 8 1>;
+		phy-mode= "rmii";
+		mc_val = <0x1800>;
+		resets = <&clock GCLK_IDX_ETHERNET>;
+		reset-names = "ethpower";
+		interrupt-names = "macirq";
+		clocks = <&clock CLK_81>;
+		clock-names = "ethclk81";
+		internal_phy=<1>;
+	};
+
+	sysled {
+		compatible = "amlogic, sysled";
+		dev_name = "sysled";
+		status = "disable";
+		//led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_LOW>;
+	};
+
+	avin_detect {
+		compatible = "amlogic, avin_detect";
+		status = "okay";
+		avin_device_num = <1>;
+		interrupts = <0 65 1>;
+		pinctrl-names = "avin_gpio_disable_pullup";
+		pinctrl-0 = <&avin_gpio_disable_pull>;
+		avin_det_pin =  <&gpio       GPIODV_8       GPIO_ACTIVE_HIGH>;
+		detect_interval_length = <100>;
+		set_detect_times = <5>;
+		set_fault_tolerance = <1>;
+	};
+
+	meson-vout {
+		compatible = "amlogic, meson-vout";
+		dev_name = "meson-vout";
+		status = "okay";
+	};
+
+	meson-fb {
+		compatible = "amlogic, meson-fb";
+		memory-region = <&fb_reserved>;
+		dev_name = "meson-fb";
+		status = "okay";
+		interrupts = <0 3 1
+			0 89 1>;
+		interrupt-names = "viu-vsync", "rdma";
+		mem_size = <0x01800000 0x00100000>; /* fb0/fb1 memory size */
+		display_mode_default = "1080p60hz";
+		scale_mode = <1>; /** 0:VPU free scale 1:OSD free scale 2:OSD super scale */
+		display_size_default = <1920 1080 1920 3240 32>; //1920*1080*4*3 = 0x17BB000
+		pxp_mode = <1>; /** 0:normal mode 1:pxp mode */
+	};
+
+	ge2d {
+		compatible = "amlogic, ge2d";
+		dev_name = "ge2d";
+		status = "okay";
+		interrupts = <0 150 1>;
+		interrupt-names = "ge2d";
+		clocks = <&clock CLK_VAPB_0>,
+			<&clock CLK_GE2D>;
+		clock-names = "clk_vapb_0",
+				"clk_ge2d";
+		resets = <&clock GCLK_IDX_GE2D>;
+		reset-names = "ge2d";
+	};
+
+	codec_io {
+		compatible = "amlogic, codec_io";
+		#address-cells=<2>;
+		#size-cells=<2>;
+		ranges;
+		io_cbus_base{
+			reg = <0x0 0xC1100000 0x0 0x100000>;
+		};
+		io_dos_base{
+			reg = <0x0 0xc8820000 0x0 0x10000>;
+		};
+		io_hiubus_base{
+			reg = <0x0 0xc883c000 0x0 0x2000>;
+		};
+		io_aobus_base{
+			reg = <0x0 0xc8100000 0x0 0x100000>;
+		};
+		io_vcbus_base{
+			reg = <0x0 0xd0100000 0x0 0x40000>;
+		};
+		io_dmc_base{
+			reg = <0x0 0xc8838000 0x0 0x400>;
+		};
+	};
+
+	codec_mm {
+			compatible = "amlogic, codec, mm";
+			memory-region = <&codec_mm_cma &codec_mm_reserved>;
+			dev_name = "codec_mm";
+			status = "okay";
+	};
+	ethmac: ethernet@0xc9410000 {
+			compatible = "amlogic, gxbb-rmii-dwmac";
+			reg = <0x0 0xc9410000 0x0 0x10000
+			0x0 0xc8834540 0x0 0x8
+			0x0 0xc8834558 0x0 0xc>;
+			interrupts = <0 8 1>;
+			phy-mode= "rmii";
+			mc_val = <0x1800>;
+			resets = <&clock GCLK_IDX_ETHERNET>;
+			reset-names = "ethpower";
+			interrupt-names = "macirq";
+			clocks = <&clock CLK_81>;
+			clock-names = "ethclk81";
+			internal_phy=<1>;
+	};
+	mesonstream {
+		compatible = "amlogic, codec, streambuf";
+		dev_name = "mesonstream";
+		status = "okay";
+		resets = <&clock GCLK_IDX_HIU_PARSER_TOP
+			&clock GCLK_IDX_VPU_INTR
+			&clock GCLK_IDX_DEMUX
+			&clock GCLK_IDX_DOS>;
+		reset-names = "parser_top",
+			"vpu_intr",
+			"demux",
+			"vdec";
+	};
+
+	amvideocap {
+		compatible = "amlogic, amvideocap";
+		dev_name = "amvideocap.0";
+		status = "okay";
+		max_size = <8>;//8M
+	};
+
+	ion_dev {
+		compatible = "amlogic, ion_dev";
+		memory-region = <&ion_reserved>;
+	};
+
+	vdec {
+		compatible = "amlogic, vdec";
+		dev_name = "vdec.0";
+		status = "okay";
+		interrupts = <0 3 1
+			0 23 1
+			0 32 1
+			0 43 1
+			0 44 1
+			0 45 1>;
+		interrupt-names = "vsync",
+			"demux",
+			"parser",
+			"mailbox_0",
+			"mailbox_1",
+			"mailbox_2";
+	};
+
+	picdec {
+		   compatible = "amlogic, picdec";
+		   memory-region = <&picdec_cma_reserved>;
+		   dev_name = "picdec";
+		   status = "okay";
+	};
+
+	ppmgr {
+		compatible = "amlogic, ppmgr";//to match of_device_id's compatible member
+		memory-region = <&ppmgr_reserved>;
+		dev_name = "ppmgr";
+		status = "okay";
+	};
+
+	deinterlace {
+		compatible = "amlogic, deinterlace";
+		status = "okay";
+		memory-region = <&di_reserved>;
+		interrupts = <0 46 1
+				0 6 1>;
+		interrupt-names = "de_irq",
+				"timerc";
+		buffer-size = <2960266>;
+		hw-version = <2>;
+		/* reserve-iomap = "true"; */
+		/* if enable nr10bit, set nr10bit-surpport to 1 */
+		nr10bit-surpport = <1>;
+	};
+
+	vdin0 {
+		compatible = "amlogic, vdin";
+		/*memory-region = <&vdin0_cma_reserved>;*/
+		dev_name = "vdin0";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <1>;/*1:share with codec_mm;2:cma alone*/
+		/*MByte, if 10bit disable: 64M(YUV422), if 10bit enable: 64*1.5 = 96M(YUV422)
+		*if support 4K2K-YUV444-10bit-WR:3840*2160*4*4 ~= 128M
+		*if support 4K2K-YUV422-10bit-wr:3840*2160*3*4 ~= 96M
+		*if support 4K2K-YUV422-8BIT-WR:3840*2160*2*4 ~= 64M
+		*if support 1080p-YUV422-8BIT-WR:1920*1080*2*4 ~= 16M*/
+		cma_size = <96>;
+		interrupts = <0 83 1>;
+		rdma-irq = <2>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <0>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit
+		*bit4:support yuv422 10bit full pack mode (from txl new add)*/
+		tv_bit_mode = <21>;
+	};
+	vdin1 {
+		compatible = "amlogic, vdin";
+		memory-region = <&vdin1_cma_reserved>;
+		dev_name = "vdin1";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <0>;/*1:share with codec_mm;0:cma alone*/
+		interrupts = <0 85 1>;
+		rdma-irq = <4>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <1>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit*/
+		tv_bit_mode = <1>;
+	};
+	tvafe {
+		compatible = "amlogic, tvafe";
+		/*memory-region = <&tvafe_cma_reserved>;*/
+		dev_name = "tvafe";
+		status = "ok";
+		flag_cma = <1>;/*1:share with codec_mm;0:cma alone*/
+		cma_size = <8>;/*MByte*/
+		reg = <0x0 0xc8842000 0x0 0x2000>;
+		reserve-iomap = "true";
+		tvafe_id = <0>;
+		pinctrl-names = "default";
+		tvafe_pin_mux = < /*!!particular sequence, no more and no less!!!*/
+                        3       /*// TVAFE_CVBS_IN2,  //CVBS_IN0 = 0,*/
+                        1       /*// TVAFE_CVBS_IN0,    //CVBS_IN1,*/
+                        2       /*// TVAFE_CVBS_IN1,  //CVBS_IN2*/
+                        4       /*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
+		>;
+	};
+	amlvecm {
+		compatible = "amlogic, vecm";
+		dev_name = "aml_vecm";
+		status = "okay";
+		gamma_en = <1>;/*1:enabel ;0:disable*/
+		wb_en = <1>;/*1:enabel ;0:disable*/
+		cm_en = <1>;/*1:enabel ;0:disable*/
+	};
+
+	aml_atv_demod {
+		compatible = "amlogic, aml_atv_demod";
+		dev_name = "aml_atv_demod";
+		status = "okay";
+		pinctrl-names="atvdemod_agc";
+		pinctrl-0=<&atvdemod_agc>;
+		reg = <0x0 0xc8840000 0x0 0x2000>;
+		reg_23cf = <0x88188832>;/*default:0x88188832;r840 on haier:0x48188832*/
+	};
+
+	hdmirx {
+		compatible = "amlogic, hdmirx";
+		dev_name = "hdmirx";
+		status = "ok";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
+		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
+		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
+		repeat = <0>;
+		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda846000>;
+		hdmirx_data_port = <0xda846004>;
+		hdmirx_ctrl_port = <0xda846008>;
+		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
+			<&clock CLK_HDMIRX_CFG_CLK>,
+			<&clock CLK_HDMIRX_ACR_REF_CLK>,
+			<&clock CLK_HDMIRX_AUDMEAS_CLK>,
+			<&clock CLK_XTAL>,
+			<&clock CLK_FPLL_DIV5>;
+		clock-names = "hdmirx_modet_clk",
+			"hdmirx_cfg_clk",
+			"hdmirx_acr_ref_clk",
+			"hdmirx_audmeas_clk",
+			"xtal",
+			"fclk_div5";
+		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_7       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_15      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_11      GPIO_ACTIVE_HIGH>;
+ 	};
+
+	amvenc_avc {
+		compatible = "amlogic, amvenc_avc";
+		//memory-region = <&amvenc_avc_reserved>;
+		//memory-region = <&avc_cma_reserved>;
+		dev_name = "amvenc_avc";
+		status = "okay";
+		interrupts = <0 45 1>;
+		interrupt-names = "mailbox_2";
+	};
+
+	vpu {
+		compatible = "amlogic, vpu";
+		dev_name = "vpu";
+		status = "ok";
+		clk_level = <7>;
+		/**	0: 100.0M    1: 166.7M    2: 200.0M
+			3: 250.0M    4: 333.3M    5: 400.0M
+			6: 500.0M    7: 666.7M */
+	};
+
+	bt-dev{
+		compatible = "amlogic, bt-dev";
+		dev_name = "bt-dev";
+		status = "disabled";
+		//gpio_reset = <&gpio GPIOX_18 GPIO_ACTIVE_HIGH>;
+	};
+
+	rtc{
+		compatible = "amlogic, aml_vrtc";
+		alarm_reg_addr = <0xc81000a8>;
+		timer_e_addr = <0xc1109988>;
+		init_date = "2015/01/01";
+		status = "okay";
+	};
+
+	wifi {
+		compatible = "amlogic, aml_wifi";
+		dev_name = "aml_wifi";
+		status = "disabled";
+		//interrupt_pin = <&gpio       GPIOX_7       GPIO_ACTIVE_HIGH>;
+		interrupts = <	0 68 4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		//power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
+	};
+
+	emmc {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc {
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>; /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			tx_phase = <3>;
+			max_req_size = <0x20000>; /* 256KB */
+			gpio_dat3 = <&gpio BOOT_3 GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio BOOT_9 GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
+
+	sd {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0072000 0x0 0x2000>;
+		interrupts = <	0 217 1
+				0 67 1
+				0 69 1>;
+		pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "sd_1bit_pins", "sd_clk_cmd_uart_pins", "sd_1bit_uart_pins";
+		pinctrl-0 = <&sd_clk_cmd_pins>;
+		pinctrl-1 = <&sd_all_pins>;
+		pinctrl-2 = <&sd_1bit_pins>;
+		pinctrl-3 = <&sd_clk_cmd_uart_pins>;
+		pinctrl-4 = <&sd_1bit_uart_pins>;
+		sd {
+			status = "okay";
+	   		pinname = "sd";
+	   		ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+	   		caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+	   			"MMC_CAP_SD_HIGHSPEED";
+	   			//"MMC_CAP_UHS_SDR12",
+	   			//"MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50",
+	   			//"MMC_CAP_UHS_SDR104";
+	   		f_min = <400000>;
+	   		f_max = <100000000>;
+	   		max_req_size = <0x20000>; /**128KB*/
+			gpio_dat3 = <&gpio CARD_4 GPIO_ACTIVE_HIGH>;
+			jtag_pin  = <&gpio CARD_0 GPIO_ACTIVE_HIGH>;
+			gpio_cd   = <&gpio CARD_6 GPIO_ACTIVE_HIGH>;
+	   		irq_in = <3>;
+	   		irq_out = <5>;
+	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+		};
+	};
+
+	partitions: partitions {
+		parts = <12>;
+		part-0 = <&logo>;
+		part-1 = <&recovery>;
+		part-2 = <&param>;
+		part-3 = <&tee>;
+		part-4 = <&crypt>;
+		part-5 = <&misc>;
+		part-6 = <&instaboot>;
+		part-7 = <&boot>;
+		part-8 = <&system>;
+		part-9 = <&cache>;
+		part-10 = <&cri_data>;
+		part-11 = <&data>;
+
+		logo:logo{
+			pname = "logo";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		recovery:recovery{
+			pname = "recovery";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		param:param{
+			pname = "param";
+			size = <0x0 0x8000000>;
+			mask = <2>;
+		};
+		tee:tee{
+			pname = "tee";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+		crypt:crypt{
+			pname = "crypt";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		misc:misc{
+			pname = "misc";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		instaboot:instaboot{
+			pname = "instaboot";
+			size = <0x0 0x20000000>;
+			mask = <1>;
+		};
+		boot:boot
+		{
+			pname = "boot";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		system:system
+		{
+			pname = "system";
+			size = <0x0 0x40000000>;
+			mask = <1>;
+		};
+		cache:cache
+		{
+			pname = "cache";
+			size = <0x0 0x20000000>;
+			mask = <2>;
+		};
+		cri_data:cri_data
+		{
+			pname = "cri_data";
+			size = <0x0 0x1000000>;
+			mask = <2>;
+		};
+		data:data
+		{
+			pname = "data";
+			size = <0xffffffff 0xffffffff>;
+			mask = <4>;
+		};
+	};
+
+	unifykey {
+		compatible = "amlogic, unifykey";
+		status = "ok";
+
+		unifykey-num = <14>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+		unifykey-index-3 = <&keysn_3>;
+		unifykey-index-4 = <&keysn_4>;
+		unifykey-index-5 = <&keysn_5>;
+		unifykey-index-6 = <&keysn_6>;
+		unifykey-index-7 = <&keysn_7>;
+		unifykey-index-8 = <&keysn_8>;
+		unifykey-index-9 = <&keysn_9>;
+		unifykey-index-10= <&keysn_10>;
+		unifykey-index-11 = <&keysn_11>;
+		unifykey-index-12 = <&keysn_12>;
+		unifykey-index-13 = <&keysn_13>;
+
+                keysn_0: key_0{
+			key-name = "usid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_1:key_1{
+			key-name = "mac";
+                        key-device  = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_2:key_2{
+                        key-name = "hdcp";
+			key-device = "secure";
+                        key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_3:key_3{
+			key-name = "secure_boot_set";
+			key-device = "efuse";
+			key-permit = "write";
+		};
+		keysn_4:key_4{
+			key-name = "mac_bt";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_5:key_5{
+			key-name = "mac_wifi";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_6:key_6{
+			key-name = "hdcp2_tx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_7:key_7{
+			key-name = "hdcp2_rx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_8:key_8{
+			key-name = "widevinekeybox";
+			key-device = "secure";
+			key-type = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_9:key_9{
+			key-name = "deviceid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_10:key_10{
+			key-name = "hdcp22_fw_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_11:key_11{
+			key-name = "hdcp22_rx_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_12:key_12{
+			key-name = "hdcp22_rx_fw";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_13:key_13{
+			key-name = "hdcp14_rx";
+			key-device = "normal";
+			key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+        };//End unifykey
+
+	aocec: aocec {
+		compatible = "amlogic, amlogic-aocec";
+		device_name = "aocec";
+		status = "okay";
+		vendor_name = "Amlogic"; /* Max Chars: 8     */
+		vendor_id = <0x000000>; /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+		product_desc = "TXL"; /* Max Chars: 16    */
+		cec_osd_string = "AML_TV"; /* Max Chars: 14    */
+		port_num = <3>;
+		ee_cec;
+		arc_port_mask = <0x2>;
+		interrupts = <0 56 1>;
+		interrupt-names = "hdmi_eecec";
+		pinctrl-names = "hdmitx_eecec";
+		pinctrl-0=<&hdmitx_eecec>;
+		reg = <0x0 0xc810023c 0x0 0x4
+		       0x0 0xc8100000 0x0 0x200
+		       0x0 0xda83e000 0x0 0x10
+		       0x0 0xc883c000 0x0 0x400>;
+	};
+
+	tvout {
+		compatible = "amlogic, tvout";
+		dev_name = "tvout";
+		status = "disable";
+	};
+
+	uart_AO: serial@c81004c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004c0 0x0 0x18>;
+		interrupts = <0 193 1>;
+		status = "okay";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		xtal_tick_en = <1>;
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_a_pins>;
+		support-sysrq = <0>;	/* 0 not support , 1 support */
+	};
+	uart_AO_B: serial@c81004e0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004e0 0x0 0x18>;
+		interrupts = <0 197 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_b_pins>;
+	};
+	uart_A: serial@c11084c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084c0 0x0 0x18>;
+		interrupts = <0 26 1>;
+		status = "disabled";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 128 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_a_pins>;
+		resets = <&clock GCLK_IDX_UART0>;
+	};
+	uart_B: serial@c11084dc {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084dc 0x0 0x18>;
+		interrupts = <0 75 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_b_pins>;
+		resets = <&clock GCLK_IDX_UART1>;
+	};
+	uart_C: serial@c1108700 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc1108700 0x0 0x18>;
+		interrupts = <0 93 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		resets = <&clock GCLK_IDX_UART2>;
+	};
+
+	canvas{
+		compatible = "amlogic, meson, canvas";
+		dev_name = "amlogic-canvas";
+		status = "ok";
+		reg = <0x0 0xc8838000 0x0 0x400>;
+	};
+
+	rdma{
+		compatible = "amlogic, meson, rdma";
+		dev_name = "amlogic-rdma";
+		status = "ok";
+		interrupts = <0 89 1>;
+		interrupt-names = "rdma";
+	};
+
+	dwc3: dwc3@c9000000 {
+		compatible = "synopsys, dwc3";
+		reg = <0x0 0xc9000000 0x0 0x100000>;
+		interrupts = <0 30 4>;
+		usb-phy = <&usb2_phy>, <&usb3_phy>;
+		cpu-type = "gxl";
+		clock-src = "usb3.0";
+	};
+
+	usb2_phy: usb2phy@d0078000 {
+		compatible = "amlogic, amlogic-new-usb2";
+		portnum = <4>;
+		reg = <0x0 0xd0078000 0x0 0x80>;
+	};
+
+	usb3_phy: usb3phy@d0078080 {
+		compatible = "amlogic, amlogic-new-usb3";
+		portnum = <0>;
+		reg = <0x0 0xd0078080 0x0 0x20>;
+	};
+
+	dwc2_a {
+		compatible = "amlogic,dwc2";
+		device_name = "dwc2_a";
+		reg = <0x0 0xc9100000 0x0 0x40000>;
+		status = "okay";
+		interrupts = <0 31 4>;
+		pl-periph-id = <0>; /** lm name */
+		clock-src = "usb0"; /** clock src */
+		port-id = <0>;  /** ref to mach/usb.h */
+		port-type = <2>;        /** 0: otg, 1: host, 2: slave */
+		port-speed = <0>; /** 0: default, high, 1: full */
+		port-config = <0>; /** 0: default */
+		port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+		port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+		usb-fifo = <728>;
+		cpu-type = "gxl";
+		controller-type = <1>; /** 0: normal, 1: otg+dwc3 host only, 2: otg+dwc3 device only*/
+		phy-reg = <0xd0078000>;
+		phy-reg-size = <0xa0>;
+		resets = <&clock GCLK_IDX_USB_GENERAL
+					&clock GCLK_IDX_MISC_USB1_TO_DDR
+					&clock GCLK_IDX_USB1>;
+		reset-names = "usb_general",
+						"usb1",
+						"usb1_to_ddr";
+	};
+
+	/* AUDIO MESON8 DEVICES */
+	i2s_dai: I2S {
+		#sound-dai-cells = <0>;
+		resets = <
+			&clock GCLK_IDX_AIU_AI_TOP_GLUE
+			&clock GCLK_IDX_AUD_BUF_ABD
+			&clock GCLK_IDX_AIU_I2S_OUT
+			&clock GCLK_IDX_AIU_AMCLK_MEASURE
+			&clock GCLK_IDX_AIU_AIFIFO2
+			&clock GCLK_IDX_AIU_AUD_MIXER
+			&clock GCLK_IDX_AIU_MIXER_REG
+			&clock GCLK_IDX_AIU_ADC
+			&clock GCLK_IDX_AIU_TOP_LEVEL
+			&clock GCLK_IDX_AIU_AOCLK
+			&clock GCLK_IDX_AUD_IN
+		>;
+		reset-names =
+			"top_glue",
+			"aud_buf",
+			"i2s_out",
+			"amclk_measure",
+			"aififo2",
+			"aud_mixer",
+			"mixer_reg",
+			"adc",
+			"top_level",
+			"aoclk",
+			"aud_in";
+		clocks = <&clock CLK_MPLL2>,
+			<&clock CLK_AMCLK>;
+		clock-names = "mpll2", "mclk";
+		compatible = "amlogic, aml-i2s-dai";
+	};
+	spdif_dai: SPDIF {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-dai";
+		resets = <
+			&clock GCLK_IDX_AIU_IEC958
+			&clock GCLK_IDX_AIU_ICE958_AMCLK
+		>;
+		reset-names =
+			"iec958",
+			"iec958_amclk";
+		clocks = <&clock CLK_MPLL1>,
+			<&clock CLK_I958>,
+			<&clock CLK_AMCLK>,
+			<&clock CLK_SPDIF>,
+			<&clock CLK_81>;
+		clock-names = "mpll1", "i958", "mclk", "spdif", "clk_81";
+	};
+	pcm_dai: PCM {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
+	};
+	i2s_plat: i2s_platform {
+		compatible = "amlogic, aml-i2s";
+		interrupts = <0 29 1>;
+	};
+	pcm_plat: pcm_platform {
+		compatible = "amlogic, aml-pcm";
+	};
+	spdif_codec: spdif_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-codec";
+		pinctrl-names = "aml_audio_spdif";
+		pinctrl-0 = <&audio_spdif_pins>;
+	};
+	pcm_codec: pcm_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, pcm2BT-codec";
+	};
+	/* endof AUDIO MESON8 DEVICES */
+
+	/* AUDIO board specific */
+	dummy_codec:dummy{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_dummy_codec";
+		status = "disable";
+	};
+	amlogic_codec:t9015S{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_codec_T9015S";
+		reg = <0x0 0xc8832000 0x0 0x14>;
+		status = "okay";
+	};
+	aml_g9tv_snd {
+		compatible = "aml, aml_snd_g9tv";
+		status = "okay";
+		aml-sound-card,format = "i2s";
+		aml_sound_card,name = "AML-G9TVAUDIO";
+		pinctrl-names = "aml_snd_g9tv";
+		pinctrl-0 = <&audio_pins>;
+		mute_gpio-gpios = <&gpio GPIODV_11 GPIO_ACTIVE_HIGH>;
+		sleep_time = <20>;
+		aux_dev = "tas5707";
+		cpu_list = <&cpudai0 &cpudai1 &cpudai2>;
+		codec_list = <&codec0 &codec1 &codec2>;
+		plat_list = <&i2s_plat &i2s_plat &pcm_plat>;
+		cpudai0: cpudai0 {
+			sound-dai = <&i2s_dai>;
+		};
+		cpudai1: cpudai1 {
+			sound-dai = <&spdif_dai>;
+		};
+		cpudai2: cpudai2 {
+			sound-dai = <&pcm_dai>;
+		};
+		codec0: codec0 {
+			sound-dai = <&amlogic_codec>;
+		};
+		codec1: codec1 {
+			sound-dai = <&spdif_codec>;
+		};
+		codec2: codec2 {
+			sound-dai = <&pcm_codec>;
+		};
+		aml_EQ_DRC {
+			eq_table = /bits/ 32 <
+				/*channel 1*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef0*/
+				0x0080372b 0x0301afb6 0x007e1eb3 0x0301afb6 0x007e55de /*eq_coef1*/
+				0x007f9c8d 0x0301d300 0x007e9cfe 0x0301d300 0x007e398c /*eq_coef2*/
+				0x0083d5aa 0x031dee0a 0x005e8bb8 0x031dee0a 0x00626163 /*eq_coef3*/
+				0x007e0fc8 0x0308897c 0x007a2aa0 0x0308897c 0x00783a68 /*eq_coef4*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef5*/
+				0x0078eb9b 0x0333b014 0x0066ba2a 0x0333b014 0x005fa5c5 /*eq_coef6*/
+				0x009712e4 0x037db296 0x0034b3cd 0x037db296 0x004bc6b0 /*eq_coef7*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef8*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef9*/
+				/*channel 2*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef0*/
+				0x0080372b 0x0301afb6 0x007e1eb3 0x0301afb6 0x007e55de /*eq_coef1*/
+				0x007f9c8d 0x0301d300 0x007e9cfe 0x0301d300 0x007e398c /*eq_coef2*/
+				0x0083d5aa 0x031dee0a 0x005e8bb8 0x031dee0a 0x00626163 /*eq_coef3*/
+				0x007e0fc8 0x0308897c 0x007a2aa0 0x0308897c 0x00783a68 /*eq_coef4*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef5*/
+				0x0078eb9b 0x0333b014 0x0066ba2a 0x0333b014 0x005fa5c5 /*eq_coef6*/
+				0x009712e4 0x037db296 0x0034b3cd 0x037db296 0x004bc6b0 /*eq_coef7*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef8*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef9*/
+
+			>;
+			drc_table = /bits/ 32 <
+				0x0000111c 0x0380111c /*drc_ae && drc_ae_1m*/
+				0x00081bfc 0x03881bfc /*drc_aa && drc_aa_1m*/
+				0x00001571 0x03801571 /*drc_ad && drc_ad_1m*/
+			>;
+			drc_tko_table = /bits/ 32 <
+				0x00000000 0xc4000000 0x00060000 /*offset, thd, k*/
+				0x00000000 0xf6000000 0x00028000 /*offset, thd, k*/
+			>;
+		};
+		tas5707 {
+			compatible = "amlogic, aml_tas5707_codec";
+			codec_name = "tas5707";
+			status = "okay";
+			i2c_addr = <0x1B>;
+			i2c_bus = "i2c_bus_a";
+			master_vol = <150>;
+			reset_pin = <&gpio GPIOZ_13 GPIO_ACTIVE_LOW>;
+			input_mux_reg_buf = /bits/ 8 <0x00 0x01 0x77 0x72>;/*AD mode*/
+			eq_enable = <0>;
+			drc_enable = <0>;
+			table_0 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			wall_0 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			table_1 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			wall_1 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			drc1_tko_table_0 = /bits/ 8 <
+				0xFD 0xA2 0x14 0x90 /*0x40---drc1_t*/
+				0x03 0x84 0x21 0x09 /*0x41---drc1_k*/
+				0x00 0x08 0x42 0x10 /*0x42---drc1_o*/
+			>;
+			drc1_table_0 = /bits/ 8 <
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3A---drc1_ae*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3B---drc1_aa*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3C---drc1_ad*/
+			>;
+			drc1_tko_table_1 = /bits/ 8 <
+				0xFD 0xA2 0x14 0x90 /*0x40---drc1_t*/
+				0x03 0x84 0x21 0x09 /*0x41---drc1_k*/
+				0x00 0x08 0x42 0x10 /*0x42---drc1_o*/
+			>;
+			drc1_table_1 = /bits/ 8 <
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3A---drc1_ae*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3B---drc1_aa*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3C---drc1_ad*/
+			>;
+		};
+ 	};
+	amaudio2 {
+		compatible = "amlogic, aml_amaudio2";
+		status = "okay";
+		interrupts = <0 48 1>;
+ 	};
+
+	aml_sensor0: aml-sensor@0 {
+		compatible = "amlogic, aml-thermal";
+		device_name = "thermal";
+		#thermal-sensor-cells = <1>;
+		cooling_devices {
+			cpufreq_cool_cluster0 {
+				min_state = <1000000>;
+				dyn_coeff = <140>;
+				cluster_id = <0>;
+				node_name = "cpus";
+				device_type = "cpufreq";
+			};
+			cpucore_cool_cluster0 {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "cpu_core_cluster0";
+				device_type = "cpucore";
+			};
+			gpufreq_cool {
+				min_state = <400>;
+				dyn_coeff = <437>;
+				cluster_id = <0>;
+				node_name = "mali";
+				device_type = "gpufreq";
+			};
+			gpucore_cool {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "thermal_gpu_cores";
+				device_type = "gpucore";
+			};
+		};
+		cpu_cluster0:cpu_core_cluster0 {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+		gpucore:thermal_gpu_cores {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+	};
+
+	dvb {
+		compatible = "amlogic, dvb";
+		dev_name = "dvb";
+		status = "okay";
+		/*"parallel","serial","disable"*/
+		ts2 = "parallel";
+		ts2_control = <0>;
+		ts2_invert = <0>;
+		resets = <&clock GCLK_IDX_DEMUX
+				&clock GCLK_IDX_ASYNC_FIFO
+				&clock GCLK_IDX_AHB_ARB0
+				&clock GCLK_IDX_HIU_PARSER_TOP>;
+		reset-names = "demux", "asyncfifo", "ahbarb0", "uparsertop";
+	};
+	dvbfe {
+		compatible = "amlogic, dvbfe";
+		dev_name = "dvbfe";
+		status = "okay";
+		dtv_demod0 = "AMLDEMOD";
+		fe0_dtv_demod = <0>;
+		fe0_ts = <2>;
+		fe0_dev = <0>;
+		dtv_demod0_mem = <0>;
+		dtv_demod0_spectrum = <1>;
+		memory-region = <&demod_reserved>;
+		tuner0 = "si2151_tuner";
+		tuner0_i2c_adap_id = <2>;
+		tuner0_i2c_addr = <0x60>;
+		//tuner0_reset_value = <0>;
+		//tuner0_reset_gpio =  "GPIOY_10" ;  /*GPIOX_8   76*/
+		fe0_tuner = <0>;
+		atv_demod0 = "aml_atv_demod";
+		fe0_atv_demod = <0>;
+	};
+
+	thermal-zones {
+		soc_thermal {
+			polling-delay = <1000>;
+			polling-delay-passive = <100>;
+			sustainable-power = <2150>;
+
+			thermal-sensors = <&aml_sensor0 3>;
+
+			trips {
+				switch_on: trip-point@0 {
+					temperature = <70000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				control: trip-point@1 {
+					temperature = <80000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				hot: trip-point@2 {
+					temperature = <85000>;
+					hysteresis = <5000>;
+					type = "hot";
+				};
+				critical: trip-point@3 {
+					temperature = <260000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				cpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpus 0 4>;
+					contribution = <1024>;
+				};
+				cpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpu_cluster0 0 3>;
+					contribution = <1024>;
+				};
+				gpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpu 0 4>;
+					contribution = <1024>;
+				};
+				gpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpucore 0 2>;
+					contribution = <1024>;
+				};
+			};
+		};
+	};
+
+}; /* end of / */
+
+	&i2c_a {
+		status = "okay";
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_a_master>;
+	};
+	&i2c_b {
+		status = "okay";
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_b_master>;
+	};
+
+&pinmux {
+	audio_pins:audio_pin{
+		amlogic,setmask=<4 0x00000740>;
+		amlogic,clrmask=<4 0x0000000c
+				 3 0x021c0000>;
+		amlogic,pins = "GPIOZ_10","GPIOZ_11","GPIOZ_12","GPIOZ_15";
+	};
+	audio_spdif_pins:audio_pin1{
+		amlogic,setmask=<3 0x40000000>; /*spdif_out*/
+		amlogic,clrmask=<3 0x00200000>;
+		amlogic,pins ="GPIOZ_17"; /*spdif_out*/
+	};
+
+	hdmirx_pins: hdmirx_pins {
+                amlogic,setmask = <5  0xffff0000>;
+                amlogic,clrmask = <5  0x0000ff00>;
+                amlogic,pins = "GPIOW_6","GPIOW_8",
+                        "GPIOW_10","GPIOW_12",
+                        "GPIOW_14","GPIOW_16",
+                        "GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
+        };
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <5  0xffff0000>,
+			<AO 0x1800>;
+		amlogic,clrmask = <5  0x0000ff00>;
+		amlogic,pins = "GPIOW_4";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <5  0x00003000>;
+		amlogic,clrmask = <5  0x03000000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_6";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <5  0x00000300>;
+		amlogic,clrmask = <5  0x00030000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_14";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <5  0x00000c00>;
+		amlogic,clrmask = <5  0x00300000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_10";
+	};
+};
+
+&pinmux {
+	bl_pwm_on_pins:bl_pwm_on_pin {
+		amlogic,setmask = <4 0x00010000>;
+		amlogic,clrmask = <4 0x00008000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_vs_on_pins:bl_pwm_vs_on_pin {
+		amlogic,setmask = <4 0x00008000>;
+		amlogic,clrmask = <4 0x00010000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_combo_0_on_pins:bl_pwm_combo_0_on_pin {
+		amlogic,setmask = <4 0x00010000>;
+		amlogic,clrmask = <4 0x00008000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_combo_1_on_pins:bl_pwm_combo_1_on_pin {
+		amlogic,setmask = <4 0x00004000>;
+		amlogic,clrmask = <4 0x00002000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_7";
+	};
+};
+
diff --git a/arch/arm64/boot/dts/amlogic/txl_p321.dts b/arch/arm64/boot/dts/amlogic/txl_p321.dts
new file mode 100644
index 0000000..8586446
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/txl_p321.dts
@@ -0,0 +1,1379 @@
+/*
+ * arch/arm64/boot/dts/amlogic/txl_321.dts
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/dts-v1/;
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/txl.h>
+#include <dt-bindings/gpio/txl.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/reset/aml_txl.h>
+
+#include "mesontxl.dtsi"
+#include "mesontxl_p321-panel.dtsi"
+
+/ {
+	model = "Amlogic";
+	compatible = "amlogic, txl";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart_AO;
+		serial1 = &uart_A;
+		serial2 = &uart_B;
+		serial3 = &uart_C;
+		serial4 = &uart_AO_B;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		linux,usable-memory = <0x0 0x0100000 0x0 0x3ff00000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		/* global autoconfigured region for contiguous allocations */
+		secmon_reserved:linux,secmon {
+			compatible = "amlogic, aml_secmon_memory";
+			reg = <0x0 0x10000000 0x0 0x200000>;
+			no-map;
+		};
+
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
+
+		pstore:aml_pstore {
+			compatible = "amlogic, pstore";
+			reg = <0x0 0x07300000 0x0 0x100000>;
+			no-map;
+		};
+
+		fb_reserved:linux,meson-fb {
+			compatible = "amlogic, fb-memory";
+			size = <0x0 0x2000000>;
+			no-map;
+		};
+
+		di_reserved:linux,di {
+			compatible = "amlogic, di-mem";
+			/** 10x(1920x1088x(3/2+1/5)+1088)=34M **/
+			/** 10x(1920x1088x(3/2+1/5)+1088)x3/2=51M support 12bit **/
+			/** 10x(1920x1088x(3/2+1/5)+1088)x5/4=43M support 10bit **/
+			size = <0x0 0x3300000>;
+			//no-map;
+		};
+
+		demod_reserved:linux,demod {
+			compatible = "amlogic, demod-mem";
+			size = <0x0 0x600000>; //20m
+			multi-use;
+			//no-map;
+		};
+
+		ion_reserved:linux,ion-dev {
+			compatible = "amlogic, idev-mem";
+			size = <0x0 0x2000000>;
+		};
+
+		/*  POST PROCESS MANAGER */
+		ppmgr_reserved:linux,ppmgr {
+			compatible = "amlogic, ppmgr_memory";
+			size = <0x0 0x0>;
+			multi-use;
+		};
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0xbc00000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+
+		picdec_cma_reserved:linux,picdec {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x0>;
+			alignment = <0x0 0x0>;
+			linux,contiguous-region;
+		};
+
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x4100000>;
+			alignment = <0x0 0x100000>;
+ 			//no-map;
+		};
+		/*  vdin0 CMA pool */
+		//vdin0_cma_reserved:linux,vdin0_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <4>;
+		//	reusable;
+			/* 3840x2160x2x4  =64+4 M */
+		//	size = <0x0 0x04400000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+		/*  vdin1 CMA pool */
+		vdin1_cma_reserved:linux,vdin1_cma {
+			compatible = "shared-dma-pool";
+			linux,phandle = <5>;
+			reusable;
+			/* 1920x1080x2x4  =16+4 M */
+			size = <0x0 0x01400000>;
+			alignment = <0x0 0x400000>;
+		};
+		/*  tvafe CMA pool */
+		//tvafe_cma_reserved:linux,tvafe_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <6>;
+		//	reusable;
+			/* 5 M */
+		//	size = <0x0 0x00800000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+	};
+
+	ethmac: ethernet@0xc9410000 {
+		compatible = "amlogic, gxbb-rmii-dwmac";
+		reg = <0x0 0xc9410000 0x0 0x10000
+		0x0 0xc8834540 0x0 0x8
+		0x0 0xc8834558 0x0 0xc>;
+		interrupts = <0 8 1>;
+		phy-mode= "rmii";
+		mc_val = <0x1800>;
+		resets = <&clock GCLK_IDX_ETHERNET>;
+		reset-names = "ethpower";
+		interrupt-names = "macirq";
+		clocks = <&clock CLK_81>;
+		clock-names = "ethclk81";
+		internal_phy=<1>;
+	};
+
+	sysled {
+		compatible = "amlogic, sysled";
+		dev_name = "sysled";
+		status = "disable";
+		//led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_LOW>;
+	};
+	avin_detect {
+		compatible = "amlogic, avin_detect";
+		status = "okay";
+		avin_device_num = <1>;
+		interrupts = <0 65 1>;
+		pinctrl-names = "avin_gpio_disable_pullup";
+		pinctrl-0 = <&avin_gpio_disable_pull>;
+		avin_det_pin =  <&gpio       GPIODV_8       GPIO_ACTIVE_HIGH>;
+		detect_interval_length = <100>;
+		set_detect_times = <5>;
+		set_fault_tolerance = <1>;
+	};
+
+	meson-vout {
+		compatible = "amlogic, meson-vout";
+		dev_name = "meson-vout";
+		status = "okay";
+	};
+
+	meson-fb {
+		compatible = "amlogic, meson-fb";
+		memory-region = <&fb_reserved>;
+		dev_name = "meson-fb";
+		status = "okay";
+		interrupts = <0 3 1
+			0 89 1>;
+		interrupt-names = "viu-vsync", "rdma";
+		mem_size = <0x01800000 0x00100000>; /* fb0/fb1 memory size */
+		display_mode_default = "1080p60hz";
+		scale_mode = <1>; /** 0:VPU free scale 1:OSD free scale 2:OSD super scale */
+		display_size_default = <1920 1080 1920 3240 32>; //1920*1080*4*3 = 0x17BB000
+		pxp_mode = <1>; /** 0:normal mode 1:pxp mode */
+	};
+
+	ge2d {
+		compatible = "amlogic, ge2d";
+		dev_name = "ge2d";
+		status = "okay";
+		interrupts = <0 150 1>;
+		interrupt-names = "ge2d";
+		clocks = <&clock CLK_VAPB_0>,
+			<&clock CLK_GE2D>;
+		clock-names = "clk_vapb_0",
+				"clk_ge2d";
+		resets = <&clock GCLK_IDX_GE2D>;
+		reset-names = "ge2d";
+	};
+
+	codec_io {
+		compatible = "amlogic, codec_io";
+		#address-cells=<2>;
+		#size-cells=<2>;
+		ranges;
+		io_cbus_base{
+			reg = <0x0 0xC1100000 0x0 0x100000>;
+		};
+		io_dos_base{
+			reg = <0x0 0xc8820000 0x0 0x10000>;
+		};
+		io_hiubus_base{
+			reg = <0x0 0xc883c000 0x0 0x2000>;
+		};
+		io_aobus_base{
+			reg = <0x0 0xc8100000 0x0 0x100000>;
+		};
+		io_vcbus_base{
+			reg = <0x0 0xd0100000 0x0 0x40000>;
+		};
+		io_dmc_base{
+			reg = <0x0 0xc8838000 0x0 0x400>;
+		};
+	};
+
+	codec_mm {
+			compatible = "amlogic, codec, mm";
+			memory-region = <&codec_mm_cma &codec_mm_reserved>;
+			dev_name = "codec_mm";
+			status = "okay";
+	};
+	ethmac: ethernet@0xc9410000 {
+			compatible = "amlogic, gxbb-rmii-dwmac";
+			reg = <0x0 0xc9410000 0x0 0x10000
+			0x0 0xc8834540 0x0 0x8
+			0x0 0xc8834558 0x0 0xc>;
+			interrupts = <0 8 1>;
+			phy-mode= "rmii";
+			mc_val = <0x1800>;
+			resets = <&clock GCLK_IDX_ETHERNET>;
+			reset-names = "ethpower";
+			interrupt-names = "macirq";
+			clocks = <&clock CLK_81>;
+			clock-names = "ethclk81";
+			internal_phy=<1>;
+	};
+	mesonstream {
+		compatible = "amlogic, codec, streambuf";
+		dev_name = "mesonstream";
+		status = "okay";
+		resets = <&clock GCLK_IDX_HIU_PARSER_TOP
+			&clock GCLK_IDX_VPU_INTR
+			&clock GCLK_IDX_DEMUX
+			&clock GCLK_IDX_DOS>;
+		reset-names = "parser_top",
+			"vpu_intr",
+			"demux",
+			"vdec";
+	};
+
+	amvideocap {
+		compatible = "amlogic, amvideocap";
+		dev_name = "amvideocap.0";
+		status = "okay";
+		max_size = <8>;//8M
+	};
+
+	ion_dev {
+		compatible = "amlogic, ion_dev";
+		memory-region = <&ion_reserved>;
+	};
+
+	vdec {
+		compatible = "amlogic, vdec";
+		dev_name = "vdec.0";
+		status = "okay";
+		interrupts = <0 3 1
+			0 23 1
+			0 32 1
+			0 43 1
+			0 44 1
+			0 45 1>;
+		interrupt-names = "vsync",
+			"demux",
+			"parser",
+			"mailbox_0",
+			"mailbox_1",
+			"mailbox_2";
+	};
+
+	picdec {
+		   compatible = "amlogic, picdec";
+		   memory-region = <&picdec_cma_reserved>;
+		   dev_name = "picdec";
+		   status = "okay";
+	};
+
+	ppmgr {
+		compatible = "amlogic, ppmgr";//to match of_device_id's compatible member
+		memory-region = <&ppmgr_reserved>;
+		dev_name = "ppmgr";
+		status = "okay";
+	};
+
+	deinterlace {
+		compatible = "amlogic, deinterlace";
+		status = "okay";
+		memory-region = <&di_reserved>;
+		interrupts = <0 46 1
+				0 6 1>;
+		interrupt-names = "de_irq",
+				"timerc";
+		buffer-size = <2960266>;
+		hw-version = <2>;
+		/* reserve-iomap = "true"; */
+		/* if enable nr10bit, set nr10bit-surpport to 1 */
+		nr10bit-surpport = <1>;
+	};
+
+	vdin0 {
+		compatible = "amlogic, vdin";
+		/*memory-region = <&vdin0_cma_reserved>;*/
+		dev_name = "vdin0";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <1>;/*1:share with codec_mm;2:cma alone*/
+		/*MByte, if 10bit disable: 64M(YUV422), if 10bit enable: 64*1.5 = 96M(YUV422)
+		*if support 4K2K-YUV444-10bit-WR:3840*2160*4*4 ~= 128M
+		*if support 4K2K-YUV422-10bit-wr:3840*2160*3*4 ~= 96M
+		*if support 4K2K-YUV422-8BIT-WR:3840*2160*2*4 ~= 64M
+		*if support 1080p-YUV422-8BIT-WR:1920*1080*2*4 ~= 16M*/
+		cma_size = <96>;
+		interrupts = <0 83 1>;
+		rdma-irq = <2>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <0>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit
+		*bit4:support yuv422 10bit full pack mode (from txl new add)*/
+		tv_bit_mode = <21>;
+	};
+	vdin1 {
+		compatible = "amlogic, vdin";
+		memory-region = <&vdin1_cma_reserved>;
+		dev_name = "vdin1";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <0>;/*1:share with codec_mm;0:cma alone*/
+		interrupts = <0 85 1>;
+		rdma-irq = <4>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <1>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit*/
+		tv_bit_mode = <1>;
+	};
+	tvafe {
+		compatible = "amlogic, tvafe";
+		/*memory-region = <&tvafe_cma_reserved>;*/
+		dev_name = "tvafe";
+		status = "ok";
+		flag_cma = <1>;/*1:share with codec_mm;0:cma alone*/
+		cma_size = <8>;/*MByte*/
+		reg = <0x0 0xc8842000 0x0 0x2000>;
+		reserve-iomap = "true";
+		tvafe_id = <0>;
+		pinctrl-names = "default";
+		tvafe_pin_mux = < /*!!particular sequence, no more and no less!!!*/
+                        3       /*// TVAFE_CVBS_IN2,  //CVBS_IN0 = 0,*/
+                        1       /*// TVAFE_CVBS_IN0,    //CVBS_IN1,*/
+                        2       /*// TVAFE_CVBS_IN1,  //CVBS_IN2*/
+                        4       /*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
+		>;
+	};
+	amlvecm {
+		compatible = "amlogic, vecm";
+		dev_name = "aml_vecm";
+		status = "okay";
+		gamma_en = <1>;/*1:enabel ;0:disable*/
+		wb_en = <1>;/*1:enabel ;0:disable*/
+		cm_en = <1>;/*1:enabel ;0:disable*/
+	};
+
+	aml_atv_demod {
+		compatible = "amlogic, aml_atv_demod";
+		dev_name = "aml_atv_demod";
+		status = "okay";
+		pinctrl-names="atvdemod_agc";
+		pinctrl-0=<&atvdemod_agc>;
+		reg = <0x0 0xc8840000 0x0 0x2000>;
+		reg_23cf = <0x88188832>;/*default:0x88188832;r840 on haier:0x48188832*/
+	};
+
+	hdmirx {
+		compatible = "amlogic, hdmirx";
+		dev_name = "hdmirx";
+		status = "ok";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
+		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
+		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
+		repeat = <0>;
+		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda846000>;
+		hdmirx_data_port = <0xda846004>;
+		hdmirx_ctrl_port = <0xda846008>;
+		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
+			<&clock CLK_HDMIRX_CFG_CLK>,
+			<&clock CLK_HDMIRX_ACR_REF_CLK>,
+			<&clock CLK_HDMIRX_AUDMEAS_CLK>,
+			<&clock CLK_XTAL>,
+			<&clock CLK_FPLL_DIV5>;
+		clock-names = "hdmirx_modet_clk",
+			"hdmirx_cfg_clk",
+			"hdmirx_acr_ref_clk",
+			"hdmirx_audmeas_clk",
+			"xtal",
+			"fclk_div5";
+		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_7       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_15      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_11      GPIO_ACTIVE_HIGH>;
+ 	};
+
+	amvenc_avc {
+		compatible = "amlogic, amvenc_avc";
+		//memory-region = <&amvenc_avc_reserved>;
+		//memory-region = <&avc_cma_reserved>;
+		dev_name = "amvenc_avc";
+		status = "okay";
+		interrupts = <0 45 1>;
+		interrupt-names = "mailbox_2";
+	};
+
+	vpu {
+		compatible = "amlogic, vpu";
+		dev_name = "vpu";
+		status = "ok";
+		clk_level = <7>;
+		/**	0: 100.0M    1: 166.7M    2: 200.0M
+			3: 250.0M    4: 333.3M    5: 400.0M
+			6: 500.0M    7: 666.7M */
+	};
+
+	bt-dev{
+		compatible = "amlogic, bt-dev";
+		dev_name = "bt-dev";
+		status = "disabled";
+		//gpio_reset = <&gpio GPIOX_18 GPIO_ACTIVE_HIGH>;
+	};
+
+	rtc{
+		compatible = "amlogic, aml_vrtc";
+		alarm_reg_addr = <0xc81000a8>;
+		timer_e_addr = <0xc1109988>;
+		init_date = "2015/01/01";
+		status = "okay";
+	};
+
+	wifi {
+		compatible = "amlogic, aml_wifi";
+		dev_name = "aml_wifi";
+		status = "disabled";
+		//interrupt_pin = <&gpio       GPIOX_7       GPIO_ACTIVE_HIGH>;
+		interrupts = <	0 68 4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		//power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
+	};
+
+	emmc {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc {
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>; /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			tx_phase = <3>;
+			max_req_size = <0x20000>; /* 256KB */
+			gpio_dat3 = <&gpio BOOT_3 GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio BOOT_9 GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
+
+	sd {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0072000 0x0 0x2000>;
+		interrupts = <	0 217 1
+				0 67 1
+				0 69 1>;
+		pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "sd_1bit_pins", "sd_clk_cmd_uart_pins", "sd_1bit_uart_pins";
+		pinctrl-0 = <&sd_clk_cmd_pins>;
+		pinctrl-1 = <&sd_all_pins>;
+		pinctrl-2 = <&sd_1bit_pins>;
+		pinctrl-3 = <&sd_clk_cmd_uart_pins>;
+		pinctrl-4 = <&sd_1bit_uart_pins>;
+		sd {
+			status = "okay";
+	   		pinname = "sd";
+	   		ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+	   		caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+	   			"MMC_CAP_SD_HIGHSPEED";
+	   			//"MMC_CAP_UHS_SDR12",
+	   			//"MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50",
+	   			//"MMC_CAP_UHS_SDR104";
+	   		f_min = <400000>;
+	   		f_max = <100000000>;
+	   		max_req_size = <0x20000>; /**128KB*/
+			gpio_dat3 = <&gpio CARD_4 GPIO_ACTIVE_HIGH>;
+			jtag_pin  = <&gpio CARD_0 GPIO_ACTIVE_HIGH>;
+			gpio_cd   = <&gpio CARD_6 GPIO_ACTIVE_HIGH>;
+	   		irq_in = <3>;
+	   		irq_out = <5>;
+	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+		};
+	};
+
+	partitions: partitions {
+		parts = <12>;
+		part-0 = <&logo>;
+		part-1 = <&recovery>;
+		part-2 = <&param>;
+		part-3 = <&tee>;
+		part-4 = <&crypt>;
+		part-5 = <&misc>;
+		part-6 = <&instaboot>;
+		part-7 = <&boot>;
+		part-8 = <&system>;
+		part-9 = <&cache>;
+		part-10 = <&cri_data>;
+		part-11 = <&data>;
+
+		logo:logo{
+			pname = "logo";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		recovery:recovery{
+			pname = "recovery";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		param:param{
+			pname = "param";
+			size = <0x0 0x8000000>;
+			mask = <2>;
+		};
+		tee:tee{
+			pname = "tee";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+		crypt:crypt{
+			pname = "crypt";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		misc:misc{
+			pname = "misc";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		instaboot:instaboot{
+			pname = "instaboot";
+			size = <0x0 0x20000000>;
+			mask = <1>;
+		};
+		boot:boot
+		{
+			pname = "boot";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		system:system
+		{
+			pname = "system";
+			size = <0x0 0x40000000>;
+			mask = <1>;
+		};
+		cache:cache
+		{
+			pname = "cache";
+			size = <0x0 0x20000000>;
+			mask = <2>;
+		};
+		cri_data:cri_data
+		{
+			pname = "cri_data";
+			size = <0x0 0x1000000>;
+			mask = <2>;
+		};
+		data:data
+		{
+			pname = "data";
+			size = <0xffffffff 0xffffffff>;
+			mask = <4>;
+		};
+	};
+
+	unifykey {
+		compatible = "amlogic, unifykey";
+		status = "ok";
+
+		unifykey-num = <14>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+		unifykey-index-3 = <&keysn_3>;
+		unifykey-index-4 = <&keysn_4>;
+		unifykey-index-5 = <&keysn_5>;
+		unifykey-index-6 = <&keysn_6>;
+		unifykey-index-7 = <&keysn_7>;
+		unifykey-index-8 = <&keysn_8>;
+		unifykey-index-9 = <&keysn_9>;
+		unifykey-index-10= <&keysn_10>;
+		unifykey-index-11 = <&keysn_11>;
+		unifykey-index-12 = <&keysn_12>;
+		unifykey-index-13 = <&keysn_13>;
+
+                keysn_0: key_0{
+			key-name = "usid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_1:key_1{
+			key-name = "mac";
+                        key-device  = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_2:key_2{
+                        key-name = "hdcp";
+			key-device = "secure";
+                        key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_3:key_3{
+			key-name = "secure_boot_set";
+			key-device = "efuse";
+			key-permit = "write";
+		};
+		keysn_4:key_4{
+			key-name = "mac_bt";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_5:key_5{
+			key-name = "mac_wifi";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_6:key_6{
+			key-name = "hdcp2_tx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_7:key_7{
+			key-name = "hdcp2_rx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_8:key_8{
+			key-name = "widevinekeybox";
+			key-device = "secure";
+			key-type = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_9:key_9{
+			key-name = "deviceid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_10:key_10{
+			key-name = "hdcp22_fw_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_11:key_11{
+			key-name = "hdcp22_rx_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_12:key_12{
+			key-name = "hdcp22_rx_fw";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_13:key_13{
+			key-name = "hdcp14_rx";
+			key-device = "normal";
+			key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+        };//End unifykey
+
+	aocec: aocec {
+		compatible = "amlogic, amlogic-aocec";
+		device_name = "aocec";
+		status = "okay";
+		vendor_name = "Amlogic"; /* Max Chars: 8     */
+		vendor_id = <0x000000>; /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+		product_desc = "TXL"; /* Max Chars: 16    */
+		cec_osd_string = "AML_TV"; /* Max Chars: 14    */
+		port_num = <3>;
+		ee_cec;
+		arc_port_mask = <0x2>;
+		interrupts = <0 56 1>;
+		interrupt-names = "hdmi_eecec";
+		pinctrl-names = "hdmitx_eecec";
+		pinctrl-0=<&hdmitx_eecec>;
+		reg = <0x0 0xc810023c 0x0 0x4
+		       0x0 0xc8100000 0x0 0x200
+		       0x0 0xda83e000 0x0 0x10
+		       0x0 0xc883c000 0x0 0x400>;
+	};
+
+	tvout {
+		compatible = "amlogic, tvout";
+		dev_name = "tvout";
+		status = "disable";
+	};
+
+	uart_AO: serial@c81004c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004c0 0x0 0x18>;
+		interrupts = <0 193 1>;
+		status = "okay";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		xtal_tick_en = <1>;
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_a_pins>;
+		support-sysrq = <0>;	/* 0 not support , 1 support */
+	};
+	uart_AO_B: serial@c81004e0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004e0 0x0 0x18>;
+		interrupts = <0 197 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_b_pins>;
+	};
+	uart_A: serial@c11084c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084c0 0x0 0x18>;
+		interrupts = <0 26 1>;
+		status = "disabled";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 128 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_a_pins>;
+		resets = <&clock GCLK_IDX_UART0>;
+	};
+	uart_B: serial@c11084dc {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084dc 0x0 0x18>;
+		interrupts = <0 75 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_b_pins>;
+		resets = <&clock GCLK_IDX_UART1>;
+	};
+	uart_C: serial@c1108700 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc1108700 0x0 0x18>;
+		interrupts = <0 93 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		resets = <&clock GCLK_IDX_UART2>;
+	};
+
+	canvas{
+		compatible = "amlogic, meson, canvas";
+		dev_name = "amlogic-canvas";
+		status = "ok";
+		reg = <0x0 0xc8838000 0x0 0x400>;
+	};
+
+	rdma{
+		compatible = "amlogic, meson, rdma";
+		dev_name = "amlogic-rdma";
+		status = "ok";
+		interrupts = <0 89 1>;
+		interrupt-names = "rdma";
+	};
+
+	dwc3: dwc3@c9000000 {
+		compatible = "synopsys, dwc3";
+		reg = <0x0 0xc9000000 0x0 0x100000>;
+		interrupts = <0 30 4>;
+		usb-phy = <&usb2_phy>, <&usb3_phy>;
+		cpu-type = "gxl";
+		clock-src = "usb3.0";
+	};
+
+	usb2_phy: usb2phy@d0078000 {
+		compatible = "amlogic, amlogic-new-usb2";
+		portnum = <4>;
+		reg = <0x0 0xd0078000 0x0 0x80>;
+	};
+
+	usb3_phy: usb3phy@d0078080 {
+		compatible = "amlogic, amlogic-new-usb3";
+		portnum = <0>;
+		reg = <0x0 0xd0078080 0x0 0x20>;
+	};
+
+	dwc2_a {
+		compatible = "amlogic,dwc2";
+		device_name = "dwc2_a";
+		reg = <0x0 0xc9100000 0x0 0x40000>;
+		status = "okay";
+		interrupts = <0 31 4>;
+		pl-periph-id = <0>; /** lm name */
+		clock-src = "usb0"; /** clock src */
+		port-id = <0>;  /** ref to mach/usb.h */
+		port-type = <2>;        /** 0: otg, 1: host, 2: slave */
+		port-speed = <0>; /** 0: default, high, 1: full */
+		port-config = <0>; /** 0: default */
+		port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+		port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+		usb-fifo = <728>;
+		cpu-type = "gxl";
+		controller-type = <1>; /** 0: normal, 1: otg+dwc3 host only, 2: otg+dwc3 device only*/
+		phy-reg = <0xd0078000>;
+		phy-reg-size = <0xa0>;
+		resets = <&clock GCLK_IDX_USB_GENERAL
+					&clock GCLK_IDX_MISC_USB1_TO_DDR
+					&clock GCLK_IDX_USB1>;
+		reset-names = "usb_general",
+						"usb1",
+						"usb1_to_ddr";
+	};
+
+	/* AUDIO MESON8 DEVICES */
+	i2s_dai: I2S {
+		#sound-dai-cells = <0>;
+		resets = <
+			&clock GCLK_IDX_AIU_AI_TOP_GLUE
+			&clock GCLK_IDX_AUD_BUF_ABD
+			&clock GCLK_IDX_AIU_I2S_OUT
+			&clock GCLK_IDX_AIU_AMCLK_MEASURE
+			&clock GCLK_IDX_AIU_AIFIFO2
+			&clock GCLK_IDX_AIU_AUD_MIXER
+			&clock GCLK_IDX_AIU_MIXER_REG
+			&clock GCLK_IDX_AIU_ADC
+			&clock GCLK_IDX_AIU_TOP_LEVEL
+			&clock GCLK_IDX_AIU_AOCLK
+			&clock GCLK_IDX_AUD_IN
+		>;
+		reset-names =
+			"top_glue",
+			"aud_buf",
+			"i2s_out",
+			"amclk_measure",
+			"aififo2",
+			"aud_mixer",
+			"mixer_reg",
+			"adc",
+			"top_level",
+			"aoclk",
+			"aud_in";
+		clocks = <&clock CLK_MPLL2>,
+			<&clock CLK_AMCLK>;
+		clock-names = "mpll2", "mclk";
+		compatible = "amlogic, aml-i2s-dai";
+	};
+	spdif_dai: SPDIF {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-dai";
+		resets = <
+			&clock GCLK_IDX_AIU_IEC958
+			&clock GCLK_IDX_AIU_ICE958_AMCLK
+		>;
+		reset-names =
+			"iec958",
+			"iec958_amclk";
+		clocks = <&clock CLK_MPLL1>,
+			<&clock CLK_I958>,
+			<&clock CLK_AMCLK>,
+			<&clock CLK_SPDIF>,
+			<&clock CLK_81>;
+		clock-names = "mpll1", "i958", "mclk", "spdif", "clk_81";
+	};
+	pcm_dai: PCM {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
+	};
+	i2s_plat: i2s_platform {
+		compatible = "amlogic, aml-i2s";
+		interrupts = <0 29 1>;
+	};
+	pcm_plat: pcm_platform {
+		compatible = "amlogic, aml-pcm";
+	};
+	spdif_codec: spdif_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-codec";
+		pinctrl-names = "aml_audio_spdif";
+		pinctrl-0 = <&audio_spdif_pins>;
+	};
+	pcm_codec: pcm_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, pcm2BT-codec";
+	};
+	/* endof AUDIO MESON8 DEVICES */
+
+	/* AUDIO board specific */
+	dummy_codec:dummy{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_dummy_codec";
+		status = "disable";
+	};
+	amlogic_codec:t9015S{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_codec_T9015S";
+		reg = <0x0 0xc8832000 0x0 0x14>;
+		status = "okay";
+	};
+	aml_g9tv_snd {
+		compatible = "aml, aml_snd_g9tv";
+		status = "okay";
+		aml-sound-card,format = "i2s";
+		aml_sound_card,name = "AML-G9TVAUDIO";
+		pinctrl-names = "aml_snd_g9tv";
+		pinctrl-0 = <&audio_pins>;
+		mute_gpio-gpios = <&gpio GPIODV_11 GPIO_ACTIVE_HIGH>;
+		sleep_time = <20>;
+		aux_dev = "tas5707";
+		cpu_list = <&cpudai0 &cpudai1 &cpudai2>;
+		codec_list = <&codec0 &codec1 &codec2>;
+		plat_list = <&i2s_plat &i2s_plat &pcm_plat>;
+		cpudai0: cpudai0 {
+			sound-dai = <&i2s_dai>;
+		};
+		cpudai1: cpudai1 {
+			sound-dai = <&spdif_dai>;
+		};
+		cpudai2: cpudai2 {
+			sound-dai = <&pcm_dai>;
+		};
+		codec0: codec0 {
+			sound-dai = <&amlogic_codec>;
+		};
+		codec1: codec1 {
+			sound-dai = <&spdif_codec>;
+		};
+		codec2: codec2 {
+			sound-dai = <&pcm_codec>;
+		};
+		aml_EQ_DRC {
+			eq_table = /bits/ 32 <
+				/*channel 1*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef0*/
+				0x0080372b 0x0301afb6 0x007e1eb3 0x0301afb6 0x007e55de /*eq_coef1*/
+				0x007f9c8d 0x0301d300 0x007e9cfe 0x0301d300 0x007e398c /*eq_coef2*/
+				0x0083d5aa 0x031dee0a 0x005e8bb8 0x031dee0a 0x00626163 /*eq_coef3*/
+				0x007e0fc8 0x0308897c 0x007a2aa0 0x0308897c 0x00783a68 /*eq_coef4*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef5*/
+				0x0078eb9b 0x0333b014 0x0066ba2a 0x0333b014 0x005fa5c5 /*eq_coef6*/
+				0x009712e4 0x037db296 0x0034b3cd 0x037db296 0x004bc6b0 /*eq_coef7*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef8*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef9*/
+				/*channel 2*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef0*/
+				0x0080372b 0x0301afb6 0x007e1eb3 0x0301afb6 0x007e55de /*eq_coef1*/
+				0x007f9c8d 0x0301d300 0x007e9cfe 0x0301d300 0x007e398c /*eq_coef2*/
+				0x0083d5aa 0x031dee0a 0x005e8bb8 0x031dee0a 0x00626163 /*eq_coef3*/
+				0x007e0fc8 0x0308897c 0x007a2aa0 0x0308897c 0x00783a68 /*eq_coef4*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef5*/
+				0x0078eb9b 0x0333b014 0x0066ba2a 0x0333b014 0x005fa5c5 /*eq_coef6*/
+				0x009712e4 0x037db296 0x0034b3cd 0x037db296 0x004bc6b0 /*eq_coef7*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef8*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef9*/
+			>;
+			drc_table = /bits/ 32 <
+				0x0000111c 0x0380111c /*drc_ae && drc_ae_1m*/
+				0x00081bfc 0x03881bfc /*drc_aa && drc_aa_1m*/
+				0x00001571 0x03801571 /*drc_ad && drc_ad_1m*/
+			>;
+			drc_tko_table = /bits/ 32 <
+				0x00000000 0xc4000000 0x00060000 /*offset, thd, k*/
+				0x00000000 0xf6000000 0x00028000 /*offset, thd, k*/
+			>;
+		};
+		tas5707 {
+			compatible = "amlogic, aml_tas5707_codec";
+			codec_name = "tas5707";
+			status = "okay";
+			i2c_addr = <0x1B>;
+			i2c_bus = "i2c_bus_a";
+			master_vol = <150>;
+			reset_pin = <&gpio GPIOZ_13 GPIO_ACTIVE_LOW>;
+			input_mux_reg_buf = /bits/ 8 <0x00 0x01 0x77 0x72>;/*AD mode*/
+			eq_enable = <0>;
+			drc_enable = <0>;
+			table_0 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			wall_0 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			table_1 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			wall_1 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			drc1_tko_table_0 = /bits/ 8 <
+				0xFD 0xA2 0x14 0x90 /*0x40---drc1_t*/
+				0x03 0x84 0x21 0x09 /*0x41---drc1_k*/
+				0x00 0x08 0x42 0x10 /*0x42---drc1_o*/
+			>;
+			drc1_table_0 = /bits/ 8 <
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3A---drc1_ae*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3B---drc1_aa*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3C---drc1_ad*/
+			>;
+			drc1_tko_table_1 = /bits/ 8 <
+				0xFD 0xA2 0x14 0x90 /*0x40---drc1_t*/
+				0x03 0x84 0x21 0x09 /*0x41---drc1_k*/
+				0x00 0x08 0x42 0x10 /*0x42---drc1_o*/
+			>;
+			drc1_table_1 = /bits/ 8 <
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3A---drc1_ae*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3B---drc1_aa*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3C---drc1_ad*/
+			>;
+		};
+ 	};
+	amaudio2 {
+		compatible = "amlogic, aml_amaudio2";
+		status = "okay";
+		interrupts = <0 48 1>;
+ 	};
+
+	aml_sensor0: aml-sensor@0 {
+		compatible = "amlogic, aml-thermal";
+		device_name = "thermal";
+		#thermal-sensor-cells = <1>;
+		cooling_devices {
+			cpufreq_cool_cluster0 {
+				min_state = <1000000>;
+				dyn_coeff = <140>;
+				cluster_id = <0>;
+				node_name = "cpus";
+				device_type = "cpufreq";
+			};
+			cpucore_cool_cluster0 {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "cpu_core_cluster0";
+				device_type = "cpucore";
+			};
+			gpufreq_cool {
+				min_state = <400>;
+				dyn_coeff = <437>;
+				cluster_id = <0>;
+				node_name = "mali";
+				device_type = "gpufreq";
+			};
+			gpucore_cool {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "thermal_gpu_cores";
+				device_type = "gpucore";
+			};
+		};
+		cpu_cluster0:cpu_core_cluster0 {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+		gpucore:thermal_gpu_cores {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+	};
+
+	dvb {
+		compatible = "amlogic, dvb";
+		dev_name = "dvb";
+		status = "okay";
+		/*"parallel","serial","disable"*/
+		ts2 = "parallel";
+		ts2_control = <0>;
+		ts2_invert = <0>;
+		resets = <&clock GCLK_IDX_DEMUX
+				&clock GCLK_IDX_ASYNC_FIFO
+				&clock GCLK_IDX_AHB_ARB0
+				&clock GCLK_IDX_HIU_PARSER_TOP>;
+		reset-names = "demux", "asyncfifo", "ahbarb0", "uparsertop";
+	};
+	dvbfe {
+		compatible = "amlogic, dvbfe";
+		dev_name = "dvbfe";
+		status = "okay";
+		dtv_demod0 = "AMLDEMOD";
+		fe0_dtv_demod = <0>;
+		fe0_ts = <2>;
+		fe0_dev = <0>;
+		dtv_demod0_mem = <0>;
+		dtv_demod0_spectrum = <1>;
+		memory-region = <&demod_reserved>;
+		tuner0 = "r842_tuner";
+		tuner0_i2c_adap_id = <2>;
+		tuner0_i2c_addr = <0xf6>;
+		//tuner0_reset_value = <0>;
+		//tuner0_reset_gpio =  "GPIOY_10" ;  /*GPIOX_8   76*/
+		fe0_tuner = <0>;
+		atv_demod0 = "aml_atv_demod";
+		fe0_atv_demod = <0>;
+	};
+
+	thermal-zones {
+		soc_thermal {
+			polling-delay = <1000>;
+			polling-delay-passive = <100>;
+			sustainable-power = <2150>;
+
+			thermal-sensors = <&aml_sensor0 3>;
+
+			trips {
+				switch_on: trip-point@0 {
+					temperature = <70000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				control: trip-point@1 {
+					temperature = <80000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				hot: trip-point@2 {
+					temperature = <85000>;
+					hysteresis = <5000>;
+					type = "hot";
+				};
+				critical: trip-point@3 {
+					temperature = <260000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				cpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpus 0 4>;
+					contribution = <1024>;
+				};
+				cpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpu_cluster0 0 3>;
+					contribution = <1024>;
+				};
+				gpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpu 0 4>;
+					contribution = <1024>;
+				};
+				gpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpucore 0 2>;
+					contribution = <1024>;
+				};
+			};
+		};
+	};
+
+}; /* end of / */
+
+	&i2c_a {
+		status = "okay";
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_a_master>;
+	};
+	&i2c_b {
+		status = "okay";
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_b_master>;
+	};
+
+&pinmux {
+	audio_pins:audio_pin{
+		amlogic,setmask=<4 0x00000780>;
+		amlogic,clrmask=<4 0x0000000e
+				 3 0x001c0000>;
+		amlogic,pins = "GPIOZ_10","GPIOZ_11","GPIOZ_12","GPIOZ_14";
+	};
+
+	audio_spdif_pins:audio_pin1{
+		amlogic,setmask=<3 0x40000000>; /*spdif_out*/
+		amlogic,clrmask=<3 0x00200000>;
+		amlogic,pins ="GPIOZ_17"; /*spdif_out*/
+	};
+
+	hdmirx_pins: hdmirx_pins {
+                amlogic,setmask = <5  0xffff0000>;
+                amlogic,clrmask = <5  0x0000ff00>;
+                amlogic,pins = "GPIOW_6","GPIOW_8",
+                        "GPIOW_10","GPIOW_12",
+                        "GPIOW_14","GPIOW_16",
+                        "GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
+        };
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <5  0xffff0000>,
+			<AO 0x1800>;
+		amlogic,clrmask = <5  0x0000ff00>;
+		amlogic,pins = "GPIOW_4";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <5  0x00003000>;
+		amlogic,clrmask = <5  0x03000000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_6";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <5  0x00000300>;
+		amlogic,clrmask = <5  0x00030000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_14";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <5  0x00000c00>;
+		amlogic,clrmask = <5  0x00300000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_10";
+	};
+};
+
+&pinmux {
+	bl_pwm_on_pins:bl_pwm_on_pin {
+		amlogic,setmask = <4 0x00010000>;
+		amlogic,clrmask = <4 0x00008000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_vs_on_pins:bl_pwm_vs_on_pin {
+		amlogic,setmask = <4 0x00008000>;
+		amlogic,clrmask = <4 0x00010000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_combo_0_on_pins:bl_pwm_combo_0_on_pin {
+		amlogic,setmask = <4 0x00010000>;
+		amlogic,clrmask = <4 0x00008000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_combo_1_on_pins:bl_pwm_combo_1_on_pin {
+		amlogic,setmask = <4 0x00004000>;
+		amlogic,clrmask = <4 0x00002000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_7";
+	};
+};
+
diff --git a/arch/arm64/boot/dts/amlogic/txl_p321_512m.dts b/arch/arm64/boot/dts/amlogic/txl_p321_512m.dts
new file mode 100644
index 0000000..fc5ee37
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/txl_p321_512m.dts
@@ -0,0 +1,1375 @@
+/*
+ * arch/arm64/boot/dts/amlogic/txl_321.dts
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/dts-v1/;
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/txl.h>
+#include <dt-bindings/gpio/txl.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/reset/aml_txl.h>
+
+#include "mesontxl.dtsi"
+#include "mesontxl_p321-panel.dtsi"
+
+/ {
+	model = "Amlogic";
+	compatible = "amlogic, txl";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart_AO;
+		serial1 = &uart_A;
+		serial2 = &uart_B;
+		serial3 = &uart_C;
+		serial4 = &uart_AO_B;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		linux,usable-memory = <0x0 0x0100000 0x0 0x1ff00000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		/* global autoconfigured region for contiguous allocations */
+		secmon_reserved:linux,secmon {
+			compatible = "amlogic, aml_secmon_memory";
+			reg = <0x0 0x10000000 0x0 0x200000>;
+			no-map;
+		};
+
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
+
+		pstore:aml_pstore {
+			compatible = "amlogic, pstore";
+			reg = <0x0 0x07300000 0x0 0x100000>;
+			no-map;
+		};
+
+		fb_reserved:linux,meson-fb {
+			compatible = "amlogic, fb-memory";
+			size = <0x0 0x800000>;
+			no-map;
+		};
+
+		di_reserved:linux,di {
+			compatible = "amlogic, di-mem";
+			/** 10x(1920x1088x(3/2+1/5)+1088)=34M **/
+			/** 10x(1920x1088x(3/2+1/5)+1088)x3/2=51M support 12bit **/
+			/** 10x(1920x1088x(3/2+1/5)+1088)x5/4=43M support 10bit **/
+			size = <0x0 0x2200000>;//34MB
+			//no-map;
+		};
+
+		demod_reserved:linux,demod {
+			compatible = "amlogic, demod-mem";
+			size = <0x0 0x600000>;//20m
+			multi-use;
+			//no-map;
+		};
+
+		ion_reserved:linux,ion-dev {
+			compatible = "amlogic, idev-mem";
+			size = <0x0 0x2000000>;
+		};
+
+		/*  POST PROCESS MANAGER */
+		ppmgr_reserved:linux,ppmgr {
+			compatible = "amlogic, ppmgr_memory";
+			size = <0x0 0x0>;
+			multi-use;
+		};
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x4000000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+
+		picdec_cma_reserved:linux,picdec {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x0>;
+			alignment = <0x0 0x0>;
+			linux,contiguous-region;
+		};
+
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x4100000>;
+			alignment = <0x0 0x100000>;
+ 			//no-map;
+		};
+		/*  vdin0 CMA pool */
+		//vdin0_cma_reserved:linux,vdin0_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <4>;
+		//	reusable;
+			/* 3840x2160x2x4  =64+4 M */
+		//	size = <0x0 0x04400000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+		/*  vdin1 CMA pool */
+		vdin1_cma_reserved:linux,vdin1_cma {
+			compatible = "shared-dma-pool";
+			linux,phandle = <5>;
+			reusable;
+			/* 1920x1080x2x4  =16+4 M */
+			size = <0x0 0x1000000>;//1920x1080x2x4=16M
+			alignment = <0x0 0x400000>;
+		};
+		/*  tvafe CMA pool */
+		//tvafe_cma_reserved:linux,tvafe_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <6>;
+		//	reusable;
+			/* 5 M */
+		//	size = <0x0 0x00800000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+	};
+
+	ethmac: ethernet@0xc9410000 {
+		compatible = "amlogic, gxbb-rmii-dwmac";
+		reg = <0x0 0xc9410000 0x0 0x10000
+		0x0 0xc8834540 0x0 0x8
+		0x0 0xc8834558 0x0 0xc>;
+		interrupts = <0 8 1>;
+		phy-mode= "rmii";
+		mc_val = <0x1800>;
+		resets = <&clock GCLK_IDX_ETHERNET>;
+		reset-names = "ethpower";
+		interrupt-names = "macirq";
+		clocks = <&clock CLK_81>;
+		clock-names = "ethclk81";
+		internal_phy=<1>;
+	};
+
+	sysled {
+		compatible = "amlogic, sysled";
+		dev_name = "sysled";
+		status = "disable";
+		//led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_LOW>;
+	};
+
+	avin_detect {
+		compatible = "amlogic, avin_detect";
+		status = "okay";
+		interrupts = <0 65 1
+			      0 66 1>;
+		pinctrl-names = "avin_gpio_disable_pullup";
+		pinctrl-0 = <&avin_gpio_disable_pull>;
+		avin1_pin =  <&gpio    GPIODV_8    GPIO_ACTIVE_HIGH>;
+		avin2_pin =  <&gpio    GPIODV_7    GPIO_ACTIVE_HIGH>;
+		detect_interval_length = <100>;
+		set_detect_times = <5>;
+		set_fault_tolerance = <1>;
+	};
+
+	meson-vout {
+		compatible = "amlogic, meson-vout";
+		dev_name = "meson-vout";
+		status = "okay";
+	};
+
+	meson-fb {
+		compatible = "amlogic, meson-fb";
+		memory-region = <&fb_reserved>;
+		dev_name = "meson-fb";
+		status = "okay";
+		interrupts = <0 3 1
+			0 89 1>;
+		interrupt-names = "viu-vsync", "rdma";
+		mem_size = <0x0800000 0x00100000>; /* fb0/fb1 memory size */
+		display_mode_default = "1080p60hz";
+		scale_mode = <1>; /** 0:VPU free scale 1:OSD free scale 2:OSD super scale */
+		display_size_default = <1280 720 1280 1440 32>; //1280*720*4*2 = 8MB
+		pxp_mode = <1>; /** 0:normal mode 1:pxp mode */
+	};
+
+	ge2d {
+		compatible = "amlogic, ge2d";
+		dev_name = "ge2d";
+		status = "okay";
+		interrupts = <0 150 1>;
+		interrupt-names = "ge2d";
+		clocks = <&clock CLK_VAPB_0>,
+			<&clock CLK_GE2D>;
+		clock-names = "clk_vapb_0",
+				"clk_ge2d";
+		resets = <&clock GCLK_IDX_GE2D>;
+		reset-names = "ge2d";
+	};
+
+	codec_io {
+		compatible = "amlogic, codec_io";
+		#address-cells=<2>;
+		#size-cells=<2>;
+		ranges;
+		io_cbus_base{
+			reg = <0x0 0xC1100000 0x0 0x100000>;
+		};
+		io_dos_base{
+			reg = <0x0 0xc8820000 0x0 0x10000>;
+		};
+		io_hiubus_base{
+			reg = <0x0 0xc883c000 0x0 0x2000>;
+		};
+		io_aobus_base{
+			reg = <0x0 0xc8100000 0x0 0x100000>;
+		};
+		io_vcbus_base{
+			reg = <0x0 0xd0100000 0x0 0x40000>;
+		};
+		io_dmc_base{
+			reg = <0x0 0xc8838000 0x0 0x400>;
+		};
+	};
+
+	codec_mm {
+			compatible = "amlogic, codec, mm";
+			memory-region = <&codec_mm_cma &codec_mm_reserved>;
+			dev_name = "codec_mm";
+			status = "okay";
+	};
+	ethmac: ethernet@0xc9410000 {
+			compatible = "amlogic, gxbb-rmii-dwmac";
+			reg = <0x0 0xc9410000 0x0 0x10000
+			0x0 0xc8834540 0x0 0x8
+			0x0 0xc8834558 0x0 0xc>;
+			interrupts = <0 8 1>;
+			phy-mode= "rmii";
+			mc_val = <0x1800>;
+			resets = <&clock GCLK_IDX_ETHERNET>;
+			reset-names = "ethpower";
+			interrupt-names = "macirq";
+			clocks = <&clock CLK_81>;
+			clock-names = "ethclk81";
+			internal_phy=<1>;
+	};
+	mesonstream {
+		compatible = "amlogic, codec, streambuf";
+		dev_name = "mesonstream";
+		status = "okay";
+		resets = <&clock GCLK_IDX_HIU_PARSER_TOP
+			&clock GCLK_IDX_VPU_INTR
+			&clock GCLK_IDX_DEMUX
+			&clock GCLK_IDX_DOS>;
+		reset-names = "parser_top",
+			"vpu_intr",
+			"demux",
+			"vdec";
+	};
+
+	amvideocap {
+		compatible = "amlogic, amvideocap";
+		dev_name = "amvideocap.0";
+		status = "okay";
+		max_size = <8>;//8M
+	};
+
+	ion_dev {
+		compatible = "amlogic, ion_dev";
+		memory-region = <&ion_reserved>;
+	};
+
+	vdec {
+		compatible = "amlogic, vdec";
+		dev_name = "vdec.0";
+		status = "okay";
+		interrupts = <0 3 1
+			0 23 1
+			0 32 1
+			0 43 1
+			0 44 1
+			0 45 1>;
+		interrupt-names = "vsync",
+			"demux",
+			"parser",
+			"mailbox_0",
+			"mailbox_1",
+			"mailbox_2";
+	};
+
+	picdec {
+		   compatible = "amlogic, picdec";
+		   memory-region = <&picdec_cma_reserved>;
+		   dev_name = "picdec";
+		   status = "okay";
+	};
+
+	ppmgr {
+		compatible = "amlogic, ppmgr";//to match of_device_id's compatible member
+		memory-region = <&ppmgr_reserved>;
+		dev_name = "ppmgr";
+		status = "okay";
+	};
+
+	deinterlace {
+		compatible = "amlogic, deinterlace";
+		status = "okay";
+		memory-region = <&di_reserved>;
+		interrupts = <0 46 1
+				0 6 1>;
+		interrupt-names = "de_irq",
+				"timerc";
+		buffer-size = <2960266>;
+		hw-version = <2>;
+		/* reserve-iomap = "true"; */
+		/* if enable nr10bit, set nr10bit-surpport to 1 */
+		nr10bit-surpport = <0>;
+	};
+
+	vdin0 {
+		compatible = "amlogic, vdin";
+		/*memory-region = <&vdin0_cma_reserved>;*/
+		dev_name = "vdin0";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <1>;/*1:share with codec_mm;2:cma alone*/
+		/*MByte, if 10bit disable: 64M(YUV422), if 10bit enable: 64*1.5 = 96M(YUV422)
+		*if support 4K2K-YUV444-10bit-WR:3840*2160*4*4 ~= 128M
+		*if support 4K2K-YUV422-10bit-wr:3840*2160*3*4 ~= 96M
+		*if support 4K2K-YUV422-8BIT-WR:3840*2160*2*4 ~= 64M
+		*if support 1080p-YUV422-8BIT-WR:1920*1080*2*4 ~= 16M*/
+		cma_size = <96>;
+		interrupts = <0 83 1>;
+		rdma-irq = <2>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <0>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit
+		*bit4:support yuv422 10bit full pack mode (from txl new add)*/
+		tv_bit_mode = <1>;
+	};
+	vdin1 {
+		compatible = "amlogic, vdin";
+		memory-region = <&vdin1_cma_reserved>;
+		dev_name = "vdin1";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <0>;/*1:share with codec_mm;0:cma alone*/
+		interrupts = <0 85 1>;
+		rdma-irq = <4>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <1>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit*/
+		tv_bit_mode = <1>;
+	};
+	tvafe {
+		compatible = "amlogic, tvafe";
+		/*memory-region = <&tvafe_cma_reserved>;*/
+		dev_name = "tvafe";
+		status = "ok";
+		flag_cma = <1>;/*1:share with codec_mm;0:cma alone*/
+		cma_size = <8>;/*MByte*/
+		reg = <0x0 0xc8842000 0x0 0x2000>;
+		reserve-iomap = "true";
+		tvafe_id = <0>;
+		pinctrl-names = "default";
+		tvafe_pin_mux = < /*!!particular sequence, no more and no less!!!*/
+                        3       /*// TVAFE_CVBS_IN2,  //CVBS_IN0 = 0,*/
+                        1       /*// TVAFE_CVBS_IN0,    //CVBS_IN1,*/
+                        2       /*// TVAFE_CVBS_IN1,  //CVBS_IN2*/
+                        4       /*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
+		>;
+	};
+	amlvecm {
+		compatible = "amlogic, vecm";
+		dev_name = "aml_vecm";
+		status = "okay";
+		gamma_en = <1>;/*1:enabel ;0:disable*/
+		wb_en = <1>;/*1:enabel ;0:disable*/
+		cm_en = <1>;/*1:enabel ;0:disable*/
+	};
+
+	aml_atv_demod {
+		compatible = "amlogic, aml_atv_demod";
+		dev_name = "aml_atv_demod";
+		status = "okay";
+		pinctrl-names="atvdemod_agc";
+		pinctrl-0=<&atvdemod_agc>;
+		reg = <0x0 0xc8840000 0x0 0x2000>;
+		reg_23cf = <0x88188832>;/*default:0x88188832;r840 on haier:0x48188832*/
+	};
+
+	hdmirx {
+		compatible = "amlogic, hdmirx";
+		dev_name = "hdmirx";
+		status = "ok";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
+		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
+		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <7>;
+		repeat = <0>;
+		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda846000>;
+		hdmirx_data_port = <0xda846004>;
+		hdmirx_ctrl_port = <0xda846008>;
+		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
+			<&clock CLK_HDMIRX_CFG_CLK>,
+			<&clock CLK_HDMIRX_ACR_REF_CLK>,
+			<&clock CLK_HDMIRX_AUDMEAS_CLK>,
+			<&clock CLK_XTAL>,
+			<&clock CLK_FPLL_DIV5>;
+		clock-names = "hdmirx_modet_clk",
+			"hdmirx_cfg_clk",
+			"hdmirx_acr_ref_clk",
+			"hdmirx_audmeas_clk",
+			"xtal",
+			"fclk_div5";
+		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_7       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_15      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_11      GPIO_ACTIVE_HIGH>;
+ 	};
+
+	amvenc_avc {
+		compatible = "amlogic, amvenc_avc";
+		//memory-region = <&amvenc_avc_reserved>;
+		//memory-region = <&avc_cma_reserved>;
+		dev_name = "amvenc_avc";
+		status = "okay";
+		interrupts = <0 45 1>;
+		interrupt-names = "mailbox_2";
+	};
+
+	vpu {
+		compatible = "amlogic, vpu";
+		dev_name = "vpu";
+		status = "ok";
+		clk_level = <4>;
+		/**	0: 100.0M    1: 166.7M    2: 200.0M
+			3: 250.0M    4: 333.3M    5: 400.0M
+			6: 500.0M    7: 666.7M */
+	};
+
+	bt-dev{
+		compatible = "amlogic, bt-dev";
+		dev_name = "bt-dev";
+		status = "disabled";
+		//gpio_reset = <&gpio GPIOX_18 GPIO_ACTIVE_HIGH>;
+	};
+
+	rtc{
+		compatible = "amlogic, aml_vrtc";
+		alarm_reg_addr = <0xc81000a8>;
+		timer_e_addr = <0xc1109988>;
+		init_date = "2015/01/01";
+		status = "okay";
+	};
+
+	wifi {
+		compatible = "amlogic, aml_wifi";
+		dev_name = "aml_wifi";
+		status = "disabled";
+		//interrupt_pin = <&gpio       GPIOX_7       GPIO_ACTIVE_HIGH>;
+		interrupts = <	0 68 4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		//power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
+	};
+
+	emmc {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc {
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>; /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				 "MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				 "MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			tx_phase = <3>;
+			max_req_size = <0x20000>; /* 256KB */
+			gpio_dat3 = <&gpio BOOT_3 GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio BOOT_9 GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
+
+	sd {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0072000 0x0 0x2000>;
+		interrupts = <	0 217 1
+				0 67 1
+				0 69 1>;
+		pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "sd_1bit_pins", "sd_clk_cmd_uart_pins", "sd_1bit_uart_pins";
+		pinctrl-0 = <&sd_clk_cmd_pins>;
+		pinctrl-1 = <&sd_all_pins>;
+		pinctrl-2 = <&sd_1bit_pins>;
+		pinctrl-3 = <&sd_clk_cmd_uart_pins>;
+		pinctrl-4 = <&sd_1bit_uart_pins>;
+		sd {
+			status = "okay";
+	   		pinname = "sd";
+	   		ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+	   		caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+	   			"MMC_CAP_SD_HIGHSPEED";
+	   			//"MMC_CAP_UHS_SDR12",
+	   			//"MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50",
+	   			//"MMC_CAP_UHS_SDR104";
+	   		f_min = <400000>;
+	   		f_max = <100000000>;
+	   		max_req_size = <0x20000>; /**128KB*/
+			gpio_dat3 = <&gpio CARD_4 GPIO_ACTIVE_HIGH>;
+			jtag_pin  = <&gpio CARD_0 GPIO_ACTIVE_HIGH>;
+			gpio_cd   = <&gpio CARD_6 GPIO_ACTIVE_HIGH>;
+	   		irq_in = <3>;
+	   		irq_out = <5>;
+	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+		};
+	};
+
+	partitions: partitions {
+		parts = <12>;
+		part-0 = <&logo>;
+		part-1 = <&recovery>;
+		part-2 = <&param>;
+		part-3 = <&tee>;
+		part-4 = <&crypt>;
+		part-5 = <&misc>;
+		part-6 = <&instaboot>;
+		part-7 = <&boot>;
+		part-8 = <&system>;
+		part-9 = <&cache>;
+		part-10 = <&cri_data>;
+		part-11 = <&data>;
+
+		logo:logo{
+			pname = "logo";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		recovery:recovery{
+			pname = "recovery";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		param:param{
+			pname = "param";
+			size = <0x0 0x8000000>;
+			mask = <2>;
+		};
+		tee:tee{
+			pname = "tee";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+		crypt:crypt{
+			pname = "crypt";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		misc:misc{
+			pname = "misc";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		instaboot:instaboot{
+			pname = "instaboot";
+			size = <0x0 0x20000000>;
+			mask = <1>;
+		};
+		boot:boot
+		{
+			pname = "boot";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		system:system
+		{
+			pname = "system";
+			size = <0x0 0x40000000>;
+			mask = <1>;
+		};
+		cache:cache
+		{
+			pname = "cache";
+			size = <0x0 0x20000000>;
+			mask = <2>;
+		};
+		cri_data:cri_data
+		{
+			pname = "cri_data";
+			size = <0x0 0x1000000>;
+			mask = <2>;
+		};
+		data:data
+		{
+			pname = "data";
+			size = <0xffffffff 0xffffffff>;
+			mask = <4>;
+		};
+	};
+
+	unifykey {
+		compatible = "amlogic, unifykey";
+		status = "ok";
+
+		unifykey-num = <14>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+		unifykey-index-3 = <&keysn_3>;
+		unifykey-index-4 = <&keysn_4>;
+		unifykey-index-5 = <&keysn_5>;
+		unifykey-index-6 = <&keysn_6>;
+		unifykey-index-7 = <&keysn_7>;
+		unifykey-index-8 = <&keysn_8>;
+		unifykey-index-9 = <&keysn_9>;
+		unifykey-index-10= <&keysn_10>;
+		unifykey-index-11 = <&keysn_11>;
+		unifykey-index-12 = <&keysn_12>;
+		unifykey-index-13 = <&keysn_13>;
+
+                keysn_0: key_0{
+			key-name = "usid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_1:key_1{
+			key-name = "mac";
+                        key-device  = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_2:key_2{
+                        key-name = "hdcp";
+			key-device = "secure";
+                        key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_3:key_3{
+			key-name = "secure_boot_set";
+			key-device = "efuse";
+			key-permit = "write";
+		};
+		keysn_4:key_4{
+			key-name = "mac_bt";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_5:key_5{
+			key-name = "mac_wifi";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_6:key_6{
+			key-name = "hdcp2_tx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_7:key_7{
+			key-name = "hdcp2_rx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_8:key_8{
+			key-name = "widevinekeybox";
+			key-device = "secure";
+			key-type = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_9:key_9{
+			key-name = "deviceid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_10:key_10{
+			key-name = "hdcp22_fw_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_11:key_11{
+			key-name = "hdcp22_rx_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_12:key_12{
+			key-name = "hdcp22_rx_fw";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_13:key_13{
+			key-name = "hdcp14_rx";
+			key-device = "normal";
+			key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+        };//End unifykey
+
+	aocec: aocec {
+		compatible = "amlogic, amlogic-aocec";
+		device_name = "aocec";
+		status = "okay";
+		vendor_name = "Amlogic"; /* Max Chars: 8     */
+		vendor_id = <0x000000>; /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+		product_desc = "TXL"; /* Max Chars: 16    */
+		cec_osd_string = "AML_TV"; /* Max Chars: 14    */
+		port_num = <3>;
+		ee_cec;
+		arc_port_mask = <0x2>;
+		interrupts = <0 56 1>;
+		interrupt-names = "hdmi_eecec";
+		pinctrl-names = "hdmitx_eecec";
+		pinctrl-0=<&hdmitx_eecec>;
+		reg = <0x0 0xc810023c 0x0 0x4
+		       0x0 0xc8100000 0x0 0x200
+		       0x0 0xda83e000 0x0 0x10
+		       0x0 0xc883c000 0x0 0x400>;
+	};
+
+	tvout {
+		compatible = "amlogic, tvout";
+		dev_name = "tvout";
+		status = "disable";
+	};
+
+	uart_AO: serial@c81004c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004c0 0x0 0x18>;
+		interrupts = <0 193 1>;
+		status = "okay";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		xtal_tick_en = <1>;
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_a_pins>;
+		support-sysrq = <0>;	/* 0 not support , 1 support */
+	};
+	uart_AO_B: serial@c81004e0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004e0 0x0 0x18>;
+		interrupts = <0 197 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_b_pins>;
+	};
+	uart_A: serial@c11084c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084c0 0x0 0x18>;
+		interrupts = <0 26 1>;
+		status = "disabled";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 128 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_a_pins>;
+		resets = <&clock GCLK_IDX_UART0>;
+	};
+	uart_B: serial@c11084dc {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084dc 0x0 0x18>;
+		interrupts = <0 75 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_b_pins>;
+		resets = <&clock GCLK_IDX_UART1>;
+	};
+	uart_C: serial@c1108700 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc1108700 0x0 0x18>;
+		interrupts = <0 93 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		resets = <&clock GCLK_IDX_UART2>;
+	};
+
+	canvas{
+		compatible = "amlogic, meson, canvas";
+		dev_name = "amlogic-canvas";
+		status = "ok";
+		reg = <0x0 0xc8838000 0x0 0x400>;
+	};
+
+	rdma{
+		compatible = "amlogic, meson, rdma";
+		dev_name = "amlogic-rdma";
+		status = "ok";
+		interrupts = <0 89 1>;
+		interrupt-names = "rdma";
+	};
+
+	dwc3: dwc3@c9000000 {
+		compatible = "synopsys, dwc3";
+		reg = <0x0 0xc9000000 0x0 0x100000>;
+		interrupts = <0 30 4>;
+		usb-phy = <&usb2_phy>, <&usb3_phy>;
+		cpu-type = "gxl";
+		clock-src = "usb3.0";
+	};
+
+	usb2_phy: usb2phy@d0078000 {
+		compatible = "amlogic, amlogic-new-usb2";
+		portnum = <4>;
+		reg = <0x0 0xd0078000 0x0 0x80>;
+	};
+
+	usb3_phy: usb3phy@d0078080 {
+		compatible = "amlogic, amlogic-new-usb3";
+		portnum = <0>;
+		reg = <0x0 0xd0078080 0x0 0x20>;
+	};
+
+	dwc2_a {
+		compatible = "amlogic,dwc2";
+		device_name = "dwc2_a";
+		reg = <0x0 0xc9100000 0x0 0x40000>;
+		status = "okay";
+		interrupts = <0 31 4>;
+		pl-periph-id = <0>; /** lm name */
+		clock-src = "usb0"; /** clock src */
+		port-id = <0>;  /** ref to mach/usb.h */
+		port-type = <2>;        /** 0: otg, 1: host, 2: slave */
+		port-speed = <0>; /** 0: default, high, 1: full */
+		port-config = <0>; /** 0: default */
+		port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+		port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+		usb-fifo = <728>;
+		cpu-type = "gxl";
+		controller-type = <1>; /** 0: normal, 1: otg+dwc3 host only, 2: otg+dwc3 device only*/
+		phy-reg = <0xd0078000>;
+		phy-reg-size = <0xa0>;
+		resets = <&clock GCLK_IDX_USB_GENERAL
+					&clock GCLK_IDX_MISC_USB1_TO_DDR
+					&clock GCLK_IDX_USB1>;
+		reset-names = "usb_general",
+						"usb1",
+						"usb1_to_ddr";
+	};
+
+	/* AUDIO MESON8 DEVICES */
+	i2s_dai: I2S {
+		#sound-dai-cells = <0>;
+		resets = <
+			&clock GCLK_IDX_AIU_AI_TOP_GLUE
+			&clock GCLK_IDX_AUD_BUF_ABD
+			&clock GCLK_IDX_AIU_I2S_OUT
+			&clock GCLK_IDX_AIU_AMCLK_MEASURE
+			&clock GCLK_IDX_AIU_AIFIFO2
+			&clock GCLK_IDX_AIU_AUD_MIXER
+			&clock GCLK_IDX_AIU_MIXER_REG
+			&clock GCLK_IDX_AIU_ADC
+			&clock GCLK_IDX_AIU_TOP_LEVEL
+			&clock GCLK_IDX_AIU_AOCLK
+			&clock GCLK_IDX_AUD_IN
+		>;
+		reset-names =
+			"top_glue",
+			"aud_buf",
+			"i2s_out",
+			"amclk_measure",
+			"aififo2",
+			"aud_mixer",
+			"mixer_reg",
+			"adc",
+			"top_level",
+			"aoclk",
+			"aud_in";
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_AMCLK>;
+		clock-names = "mpll0", "mclk";
+		compatible = "amlogic, aml-i2s-dai";
+	};
+	spdif_dai: SPDIF {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-dai";
+		resets = <
+			&clock GCLK_IDX_AIU_IEC958
+			&clock GCLK_IDX_AIU_ICE958_AMCLK
+		>;
+		reset-names =
+			"iec958",
+			"iec958_amclk";
+		clocks = <&clock CLK_MPLL1>,
+			<&clock CLK_I958>,
+			<&clock CLK_AMCLK>,
+			<&clock CLK_SPDIF>,
+			<&clock CLK_81>;
+		clock-names = "mpll1", "i958", "mclk", "spdif", "clk_81";
+	};
+	pcm_dai: PCM {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+	};
+	i2s_plat: i2s_platform {
+		compatible = "amlogic, aml-i2s";
+		interrupts = <0 29 1>;
+	};
+	pcm_plat: pcm_platform {
+		compatible = "amlogic, aml-pcm";
+	};
+	spdif_codec: spdif_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-codec";
+		pinctrl-names = "aml_audio_spdif";
+		pinctrl-0 = <&audio_spdif_pins>;
+	};
+	pcm_codec: pcm_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, pcm2BT-codec";
+	};
+	/* endof AUDIO MESON8 DEVICES */
+
+	/* AUDIO board specific */
+	dummy_codec:dummy{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_dummy_codec";
+		status = "disable";
+	};
+	amlogic_codec:t9015S{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_codec_T9015S";
+		reg = <0x0 0xc8832000 0x0 0x14>;
+		status = "okay";
+	};
+	aml_g9tv_snd {
+		compatible = "aml, aml_snd_g9tv";
+		status = "okay";
+		aml-sound-card,format = "i2s";
+		aml_sound_card,name = "AML-G9TVAUDIO";
+		pinctrl-names = "aml_snd_g9tv";
+		pinctrl-0 = <&audio_pins>;
+		mute_gpio-gpios = <&gpio GPIODV_11 GPIO_ACTIVE_HIGH>;
+		sleep_time = <20>;
+		aux_dev = "tas5707";
+		cpu_list = <&cpudai0 &cpudai1 &cpudai2>;
+		codec_list = <&codec0 &codec1 &codec2>;
+		plat_list = <&i2s_plat &i2s_plat &pcm_plat>;
+		cpudai0: cpudai0 {
+			sound-dai = <&i2s_dai>;
+		};
+		cpudai1: cpudai1 {
+			sound-dai = <&spdif_dai>;
+		};
+		cpudai2: cpudai2 {
+			sound-dai = <&pcm_dai>;
+		};
+		codec0: codec0 {
+			sound-dai = <&amlogic_codec>;
+		};
+		codec1: codec1 {
+			sound-dai = <&spdif_codec>;
+		};
+		codec2: codec2 {
+			sound-dai = <&pcm_codec>;
+		};
+		aml_EQ_DRC {
+			eq_table = /bits/ 32 <
+				/*channel 1*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef0*/
+				0x0080372b 0x0301afb6 0x007e1eb3 0x0301afb6 0x007e55de /*eq_coef1*/
+				0x007f9c8d 0x0301d300 0x007e9cfe 0x0301d300 0x007e398c /*eq_coef2*/
+				0x0083d5aa 0x031dee0a 0x005e8bb8 0x031dee0a 0x00626163 /*eq_coef3*/
+				0x007e0fc8 0x0308897c 0x007a2aa0 0x0308897c 0x00783a68 /*eq_coef4*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef5*/
+				0x0078eb9b 0x0333b014 0x0066ba2a 0x0333b014 0x005fa5c5 /*eq_coef6*/
+				0x009712e4 0x037db296 0x0034b3cd 0x037db296 0x004bc6b0 /*eq_coef7*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef8*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef9*/
+				/*channel 2*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef0*/
+				0x0080372b 0x0301afb6 0x007e1eb3 0x0301afb6 0x007e55de /*eq_coef1*/
+				0x007f9c8d 0x0301d300 0x007e9cfe 0x0301d300 0x007e398c /*eq_coef2*/
+				0x0083d5aa 0x031dee0a 0x005e8bb8 0x031dee0a 0x00626163 /*eq_coef3*/
+				0x007e0fc8 0x0308897c 0x007a2aa0 0x0308897c 0x00783a68 /*eq_coef4*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef5*/
+				0x0078eb9b 0x0333b014 0x0066ba2a 0x0333b014 0x005fa5c5 /*eq_coef6*/
+				0x009712e4 0x037db296 0x0034b3cd 0x037db296 0x004bc6b0 /*eq_coef7*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef8*/
+				0x00800000 0x00000000 0x00000000 0x00000000 0x00000000 /*eq_coef9*/
+			>;
+			drc_table = /bits/ 32 <
+				0x800000 0x00 /*drc_ae && drc_ae_1m*/
+				0x800000 0x00 /*drc_aa && drc_aa_1m*/
+				0x800000 0x00 /*drc_ad && drc_ad_1m*/
+			>;
+			drc_tko_table = /bits/ 32 <
+				0x0 0xbf000000 0x40000 /*offset, thd, k*/
+				0x0 0x0 0x40000 /*offset, thd, k*/
+			>;
+		};
+		tas5707 {
+			compatible = "amlogic, aml_tas5707_codec";
+			codec_name = "tas5707";
+			status = "okay";
+			i2c_addr = <0x1B>;
+			i2c_bus = "i2c_bus_a";
+			master_vol = <150>;
+			reset_pin = <&gpio GPIOZ_13 GPIO_ACTIVE_LOW>;
+			input_mux_reg_buf = /bits/ 8 <0x00 0x01 0x77 0x72>;/*AD mode*/
+			eq_enable = <0>;
+			drc_enable = <0>;
+			table_0 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			wall_0 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			table_1 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			wall_1 = /bits/ 8 <
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x29---ch1_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2A---ch1_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2B---ch1_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2C---ch1_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x30---ch2_bq[0]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x31---ch2_bq[1]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x32---ch2_bq[2]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x33---ch2_bq[3]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+			>;
+			drc1_tko_table_0 = /bits/ 8 <
+				0xFD 0xA2 0x14 0x90 /*0x40---drc1_t*/
+				0x03 0x84 0x21 0x09 /*0x41---drc1_k*/
+				0x00 0x08 0x42 0x10 /*0x42---drc1_o*/
+			>;
+			drc1_table_0 = /bits/ 8 <
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3A---drc1_ae*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3B---drc1_aa*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3C---drc1_ad*/
+			>;
+			drc1_tko_table_1 = /bits/ 8 <
+				0xFD 0xA2 0x14 0x90 /*0x40---drc1_t*/
+				0x03 0x84 0x21 0x09 /*0x41---drc1_k*/
+				0x00 0x08 0x42 0x10 /*0x42---drc1_o*/
+			>;
+			drc1_table_1 = /bits/ 8 <
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3A---drc1_ae*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3B---drc1_aa*/
+				0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x00 /*0x3C---drc1_ad*/
+			>;
+		};
+ 	};
+	amaudio2 {
+		compatible = "amlogic, aml_amaudio2";
+		status = "okay";
+		interrupts = <0 48 1>;
+ 	};
+
+	aml_sensor0: aml-sensor@0 {
+		compatible = "amlogic, aml-thermal";
+		device_name = "thermal";
+		#thermal-sensor-cells = <1>;
+		cooling_devices {
+			cpufreq_cool_cluster0 {
+				min_state = <1000000>;
+				dyn_coeff = <140>;
+				cluster_id = <0>;
+				node_name = "cpus";
+				device_type = "cpufreq";
+			};
+			cpucore_cool_cluster0 {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "cpu_core_cluster0";
+				device_type = "cpucore";
+			};
+			gpufreq_cool {
+				min_state = <400>;
+				dyn_coeff = <437>;
+				cluster_id = <0>;
+				node_name = "mali";
+				device_type = "gpufreq";
+			};
+			gpucore_cool {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "thermal_gpu_cores";
+				device_type = "gpucore";
+			};
+		};
+		cpu_cluster0:cpu_core_cluster0 {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+		gpucore:thermal_gpu_cores {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+	};
+
+	dvb {
+		compatible = "amlogic, dvb";
+		dev_name = "dvb";
+		status = "okay";
+		/*"parallel","serial","disable"*/
+		ts2 = "parallel";
+		ts2_control = <0>;
+		ts2_invert = <0>;
+		resets = <&clock GCLK_IDX_DEMUX
+				&clock GCLK_IDX_ASYNC_FIFO
+				&clock GCLK_IDX_AHB_ARB0
+				&clock GCLK_IDX_HIU_PARSER_TOP>;
+		reset-names = "demux", "asyncfifo", "ahbarb0", "uparsertop";
+	};
+	dvbfe {
+		compatible = "amlogic, dvbfe";
+		dev_name = "dvbfe";
+		status = "okay";
+		dtv_demod0 = "AMLDEMOD";
+		fe0_dtv_demod = <0>;
+		fe0_ts = <2>;
+		fe0_dev = <0>;
+		dtv_demod0_mem = <0>;
+		dtv_demod0_spectrum = <1>;
+		memory-region = <&demod_reserved>;
+		tuner0 = "r842_tuner";
+		tuner0_i2c_adap_id = <2>;
+		tuner0_i2c_addr = <0xf6>;
+		//tuner0_reset_value = <0>;
+		//tuner0_reset_gpio =  "GPIOY_10" ;  /*GPIOX_8   76*/
+		fe0_tuner = <0>;
+		atv_demod0 = "aml_atv_demod";
+		fe0_atv_demod = <0>;
+	};
+
+	thermal-zones {
+		soc_thermal {
+			polling-delay = <1000>;
+			polling-delay-passive = <100>;
+			sustainable-power = <2150>;
+
+			thermal-sensors = <&aml_sensor0 3>;
+
+			trips {
+				switch_on: trip-point@0 {
+					temperature = <70000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				control: trip-point@1 {
+					temperature = <80000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				hot: trip-point@2 {
+					temperature = <85000>;
+					hysteresis = <5000>;
+					type = "hot";
+				};
+				critical: trip-point@3 {
+					temperature = <260000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				cpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpus 0 4>;
+					contribution = <1024>;
+				};
+				cpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpu_cluster0 0 3>;
+					contribution = <1024>;
+				};
+				gpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpu 0 4>;
+					contribution = <1024>;
+				};
+				gpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpucore 0 2>;
+					contribution = <1024>;
+				};
+			};
+		};
+	};
+
+}; /* end of / */
+
+	&i2c_a {
+		status = "okay";
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_a_master>;
+	};
+	&i2c_b {
+		status = "okay";
+		pinctrl-names="default";
+		pinctrl-0=<&i2c_b_master>;
+	};
+
+&pinmux {
+	audio_pins:audio_pin{
+		amlogic,setmask=<4 0x00000780>;
+		amlogic,clrmask=<4 0x0000000e
+				 3 0x001c0000>;
+		amlogic,pins = "GPIOZ_10","GPIOZ_11","GPIOZ_12","GPIOZ_14";
+	};
+
+	audio_spdif_pins:audio_pin1{
+		amlogic,setmask=<3 0x40000000>; /*spdif_out*/
+		amlogic,clrmask=<3 0x00200000>;
+		amlogic,pins ="GPIOZ_17"; /*spdif_out*/
+	};
+
+	hdmirx_pins: hdmirx_pins {
+                amlogic,setmask = <5  0xffff0000>;
+                amlogic,clrmask = <5  0x0000ff00>;
+                amlogic,pins = "GPIOW_6","GPIOW_8",
+                        "GPIOW_10","GPIOW_12",
+                        "GPIOW_14","GPIOW_16",
+                        "GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
+        };
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <5  0xffff0000>,
+			<AO 0x1800>;
+		amlogic,clrmask = <5  0x0000ff00>;
+		amlogic,pins = "GPIOW_4";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <5  0x00003000>;
+		amlogic,clrmask = <5  0x03000000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_6";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <5  0x00000300>;
+		amlogic,clrmask = <5  0x00030000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_14";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <5  0x00000c00>;
+		amlogic,clrmask = <5  0x00300000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_10";
+	};
+};
+
+&pinmux {
+	bl_pwm_on_pins:bl_pwm_on_pin {
+		amlogic,setmask = <4 0x00010000>;
+		amlogic,clrmask = <4 0x00008000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_vs_on_pins:bl_pwm_vs_on_pin {
+		amlogic,setmask = <4 0x00008000>;
+		amlogic,clrmask = <4 0x00010000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_combo_0_on_pins:bl_pwm_combo_0_on_pin {
+		amlogic,setmask = <4 0x00010000>;
+		amlogic,clrmask = <4 0x00008000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_6";
+	};
+	bl_pwm_combo_1_on_pins:bl_pwm_combo_1_on_pin {
+		amlogic,setmask = <4 0x00004000>;
+		amlogic,clrmask = <4 0x00002000 3 0x00200000>;
+		amlogic,pins = "GPIOZ_7";
+	};
+};
+
diff --git a/arch/arm64/boot/dts/amlogic/txl_pxp.dts b/arch/arm64/boot/dts/amlogic/txl_pxp.dts
new file mode 100644
index 0000000..f2e16fa
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/txl_pxp.dts
@@ -0,0 +1,1026 @@
+/*
+ * arch/arm64/boot/dts/amlogic/txl_pxp.dts
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/dts-v1/;
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/txl.h>
+#include <dt-bindings/gpio/txl.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/reset/aml_txl.h>
+
+#include "mesontxl.dtsi"
+#include "mesontxl_pxp-panel.dtsi"
+
+/ {
+	model = "Amlogic";
+	compatible = "amlogic, txl";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart_AO;
+		serial1 = &uart_A;
+		serial2 = &uart_B;
+		serial3 = &uart_C;
+		serial4 = &uart_AO_B;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		linux,usable-memory = <0x0 0x1000000 0x0 0x7f000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		/* global autoconfigured region for contiguous allocations */
+		secmon_reserved:linux,secmon {
+			compatible = "amlogic, aml_secmon_memory";
+			reg = <0x0 0x10000000 0x0 0x200000>;
+			no-map;
+		};
+
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
+
+		pstore:aml_pstore {
+			compatible = "amlogic, pstore";
+			reg = <0x0 0x07300000 0x0 0x100000>;
+			no-map;
+		};
+
+		fb_reserved:linux,meson-fb {
+			compatible = "amlogic, fb-memory";
+			size = <0x0 0x2000000>;
+			no-map;
+		};
+
+		di_reserved:linux,di {
+			compatible = "amlogic, di-mem";
+			/** 10x(1920x1088x(3/2+1/5)+1088)x5/4=43M 10bit **/
+			/** 10x(1920x1088x(3/2+1/5)+1088)x3/2=51M 12bit **/
+			size = <0x0 0x2b00000>;
+			//no-map;
+		};
+
+		ion_reserved:linux,ion-dev {
+			compatible = "amlogic, idev-mem";
+			size = <0x0 0x2000000>;
+		};
+
+		/*  POST PROCESS MANAGER */
+		ppmgr_reserved:linux,ppmgr {
+			compatible = "amlogic, ppmgr_memory";
+			size = <0x0 0x0>;
+			multi-use;
+		};
+
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0xbc00000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+
+		picdec_cma_reserved:linux,picdec {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x0>;
+			alignment = <0x0 0x0>;
+			linux,contiguous-region;
+		};
+
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x4100000>;
+			alignment = <0x0 0x100000>;
+ 			//no-map;
+		};
+		/*  vdin0 CMA pool */
+		//vdin0_cma_reserved:linux,vdin0_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <4>;
+		//	reusable;
+			/* 3840x2160x2x4  =64+4 M */
+		//	size = <0x0 0x04400000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+		/*  vdin1 CMA pool */
+		vdin1_cma_reserved:linux,vdin1_cma {
+			compatible = "shared-dma-pool";
+			linux,phandle = <5>;
+			reusable;
+			/* 1920x1080x2x4  =16+4 M */
+			size = <0x0 0x01400000>;
+			alignment = <0x0 0x400000>;
+		};
+		/*  tvafe CMA pool */
+		//tvafe_cma_reserved:linux,tvafe_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <6>;
+		//	reusable;
+			/* 5 M */
+		//	size = <0x0 0x00800000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+	};
+
+	sysled {
+		compatible = "amlogic, sysled";
+		dev_name = "sysled";
+		status = "disable";
+		//led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_LOW>;
+	};
+
+	meson-vout {
+		compatible = "amlogic, meson-vout";
+		dev_name = "meson-vout";
+		status = "okay";
+	};
+
+	meson-fb {
+		compatible = "amlogic, meson-fb";
+		memory-region = <&fb_reserved>;
+		dev_name = "meson-fb";
+		status = "okay";
+		interrupts = <0 3 1
+			0 89 1>;
+		interrupt-names = "viu-vsync", "rdma";
+		mem_size = <0x01800000 0x00100000>; /* fb0/fb1 memory size */
+		display_mode_default = "1080p60hz";
+		scale_mode = <1>; /** 0:VPU free scale 1:OSD free scale 2:OSD super scale */
+		display_size_default = <1920 1080 1920 3240 32>; //1920*1080*4*3 = 0x17BB000
+		pxp_mode = <1>; /** 0:normal mode 1:pxp mode */
+	};
+
+	ge2d {
+		compatible = "amlogic, ge2d";
+		dev_name = "ge2d";
+		status = "okay";
+		interrupts = <0 150 1>;
+		interrupt-names = "ge2d";
+		clocks = <&clock CLK_VAPB_0>,
+			<&clock CLK_GE2D>;
+		clock-names = "clk_vapb_0",
+				"clk_ge2d";
+		resets = <&clock GCLK_IDX_GE2D>;
+		reset-names = "ge2d";
+	};
+
+	codec_io {
+		compatible = "amlogic, codec_io";
+		#address-cells=<2>;
+		#size-cells=<2>;
+		ranges;
+		io_cbus_base{
+			reg = <0x0 0xC1100000 0x0 0x100000>;
+		};
+		io_dos_base{
+			reg = <0x0 0xc8820000 0x0 0x10000>;
+		};
+		io_hiubus_base{
+			reg = <0x0 0xc883c000 0x0 0x2000>;
+		};
+		io_aobus_base{
+			reg = <0x0 0xc8100000 0x0 0x100000>;
+		};
+		io_vcbus_base{
+			reg = <0x0 0xd0100000 0x0 0x40000>;
+		};
+		io_dmc_base{
+			reg = <0x0 0xc8838000 0x0 0x400>;
+		};
+	};
+
+	codec_mm {
+			compatible = "amlogic, codec, mm";
+			memory-region = <&codec_mm_cma &codec_mm_reserved>;
+			dev_name = "codec_mm";
+			status = "okay";
+	};
+
+	mesonstream {
+		compatible = "amlogic, codec, streambuf";
+		dev_name = "mesonstream";
+		status = "okay";
+		resets = <&clock GCLK_IDX_HIU_PARSER_TOP
+			&clock GCLK_IDX_VPU_INTR
+			&clock GCLK_IDX_DEMUX
+			&clock GCLK_IDX_DOS>;
+		reset-names = "parser_top",
+			"vpu_intr",
+			"demux",
+			"vdec";
+	};
+
+	amvideocap {
+		compatible = "amlogic, amvideocap";
+		dev_name = "amvideocap.0";
+		status = "okay";
+		max_size = <8>;//8M
+	};
+
+	ion_dev {
+		compatible = "amlogic, ion_dev";
+		memory-region = <&ion_reserved>;
+	};
+
+	vdec {
+		compatible = "amlogic, vdec";
+		dev_name = "vdec.0";
+		status = "okay";
+		interrupts = <0 3 1
+			0 23 1
+			0 32 1
+			0 43 1
+			0 44 1
+			0 45 1>;
+		interrupt-names = "vsync",
+			"demux",
+			"parser",
+			"mailbox_0",
+			"mailbox_1",
+			"mailbox_2";
+	};
+
+	picdec {
+		   compatible = "amlogic, picdec";
+		   memory-region = <&picdec_cma_reserved>;
+		   dev_name = "picdec";
+		   status = "okay";
+	};
+
+	ppmgr {
+		compatible = "amlogic, ppmgr";//to match of_device_id's compatible member
+		memory-region = <&ppmgr_reserved>;
+		dev_name = "ppmgr";
+		status = "okay";
+	};
+
+	deinterlace {
+		compatible = "amlogic, deinterlace";
+		status = "okay";
+		memory-region = <&di_reserved>;
+		interrupts = <0 46 1
+				0 6 1>;
+		interrupt-names = "de_irq",
+				"timerc";
+		buffer-size = <2960266>;
+		hw-version = <2>;
+		/* if enable nr10bit, set nr10bit-surpport to 1 */
+		nr10bit-surpport = <1>;
+	};
+
+	vdin0 {
+		compatible = "amlogic, vdin";
+		/*memory-region = <&vdin0_cma_reserved>;*/
+		dev_name = "vdin0";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <1>;/*1:share with codec_mm;2:cma alone*/
+		/*MByte, if 10bit disable: 64M(YUV422), if 10bit enable: 64*1.5 = 96M(YUV422)
+		*if support 4K2K-YUV444-10bit-WR:3840*2160*4*4 ~= 128M
+		*if support 4K2K-YUV422-10bit-wr:3840*2160*3*4 ~= 96M
+		*if support 4K2K-YUV422-8BIT-WR:3840*2160*2*4 ~= 64M
+		*if support 1080p-YUV422-8BIT-WR:1920*1080*2*4 ~= 16M*/
+		cma_size = <96>;
+		interrupts = <0 83 1>;
+		rdma-irq = <2>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <0>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit
+		*bit4:support yuv422 10bit full pack mode (from txl new add)*/
+		tv_bit_mode = <21>;
+	};
+	vdin1 {
+		compatible = "amlogic, vdin";
+		memory-region = <&vdin1_cma_reserved>;
+		dev_name = "vdin1";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <0>;/*1:share with codec_mm;0:cma alone*/
+		interrupts = <0 85 1>;
+		rdma-irq = <4>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <1>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit*/
+		tv_bit_mode = <1>;
+	};
+	tvafe {
+		compatible = "amlogic, tvafe";
+		/*memory-region = <&tvafe_cma_reserved>;*/
+		dev_name = "tvafe";
+		status = "ok";
+		flag_cma = <1>;/*1:share with codec_mm;0:cma alone*/
+		cma_size = <8>;/*MByte*/
+		reg = <0x0 0xc8842000 0x0 0x2000>;
+		reserve-iomap = "true";
+		tvafe_id = <0>;
+		pinctrl-names = "default";
+		tvafe_pin_mux = < /*!!particular sequence, no more and no less!!!*/
+                        3       /*// TVAFE_CVBS_IN2,  //CVBS_IN0 = 0,*/
+                        1       /*// TVAFE_CVBS_IN0,    //CVBS_IN1,*/
+                        2       /*// TVAFE_CVBS_IN1,  //CVBS_IN2*/
+                        4       /*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
+		>;
+	};
+	amlvecm {
+		compatible = "amlogic, vecm";
+		dev_name = "aml_vecm";
+		status = "disable";
+		gamma_en = <1>;/*1:enabel ;0:disable*/
+		wb_en = <1>;/*1:enabel ;0:disable*/
+		cm_en = <1>;/*1:enabel ;0:disable*/
+	};
+
+	amvenc_avc {
+		compatible = "amlogic, amvenc_avc";
+		//memory-region = <&amvenc_avc_reserved>;
+		//memory-region = <&avc_cma_reserved>;
+		dev_name = "amvenc_avc";
+		status = "okay";
+		interrupts = <0 45 1>;
+		interrupt-names = "mailbox_2";
+	};
+
+	vpu {
+		compatible = "amlogic, vpu";
+		dev_name = "vpu";
+		status = "ok";
+		clk_level = <7>;
+		/**	0: 100.0M    1: 166.7M    2: 200.0M
+			3: 250.0M    4: 333.3M    5: 400.0M
+			6: 500.0M    7: 666.7M */
+	};
+
+	bt-dev{
+		compatible = "amlogic, bt-dev";
+		dev_name = "bt-dev";
+		status = "disabled";
+		//gpio_reset = <&gpio GPIOX_18 GPIO_ACTIVE_HIGH>;
+	};
+
+	rtc{
+		compatible = "amlogic, aml_vrtc";
+		alarm_reg_addr = <0xc81000a8>;
+		timer_e_addr = <0xc1109988>;
+		init_date = "2015/01/01";
+		status = "okay";
+	};
+
+	wifi {
+		compatible = "amlogic, aml_wifi";
+		dev_name = "aml_wifi";
+		status = "disabled";
+		//interrupt_pin = <&gpio       GPIOX_7       GPIO_ACTIVE_HIGH>;
+		interrupts = <	0 68 4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		//power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
+	};
+
+	emmc {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc {
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>; /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			/*caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";*/
+			f_min = <300000>;
+			f_max = <50000000>;
+			max_req_size = <0x20000>; /* 256KB */
+			gpio_dat3 = <&gpio BOOT_3 GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio BOOT_9 GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
+
+	sd {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0072000 0x0 0x2000>;
+		interrupts = <	0 217 1
+				0 67 1
+				0 69 1>;
+		pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins";
+		pinctrl-0 = <&sd_clk_cmd_pins>;
+		pinctrl-1 = <&sd_all_pins>;
+		sd {
+			status = "okay";
+	   		pinname = "sd";
+	   		ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+	   		caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+	   			"MMC_CAP_SD_HIGHSPEED","MMC_CAP_NONREMOVABLE";
+	   			//"MMC_CAP_UHS_SDR12",
+	   			//"MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50",
+	   			//"MMC_CAP_UHS_SDR104";
+	   		f_min = <400000>;
+	   		f_max = <100000000>;
+	   		max_req_size = <0x20000>; /**128KB*/
+			gpio_dat3 = <&gpio CARD_4 GPIO_ACTIVE_HIGH>;
+			jtag_pin  = <&gpio CARD_0 GPIO_ACTIVE_HIGH>;
+			gpio_cd   = <&gpio CARD_6 GPIO_ACTIVE_HIGH>;
+	   		//irq_in = <3>;
+	   		//irq_out = <5>;
+	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+		};
+	};
+
+	partitions: partitions {
+		parts = <12>;
+		part-0 = <&logo>;
+		part-1 = <&recovery>;
+		part-2 = <&param>;
+		part-3 = <&tee>;
+		part-4 = <&crypt>;
+		part-5 = <&misc>;
+		part-6 = <&instaboot>;
+		part-7 = <&boot>;
+		part-8 = <&system>;
+		part-9 = <&cache>;
+		part-10 = <&cri_data>;
+		part-11 = <&data>;
+
+		logo:logo{
+			pname = "logo";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		recovery:recovery{
+			pname = "recovery";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		param:param{
+			pname = "param";
+			size = <0x0 0x8000000>;
+			mask = <2>;
+		};
+		tee:tee{
+			pname = "tee";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+		crypt:crypt{
+			pname = "crypt";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		misc:misc{
+			pname = "misc";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		instaboot:instaboot{
+			pname = "instaboot";
+			size = <0x0 0x20000000>;
+			mask = <1>;
+		};
+		boot:boot
+		{
+			pname = "boot";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		system:system
+		{
+			pname = "system";
+			size = <0x0 0x40000000>;
+			mask = <1>;
+		};
+		cache:cache
+		{
+			pname = "cache";
+			size = <0x0 0x20000000>;
+			mask = <2>;
+		};
+		cri_data:cri_data
+		{
+			pname = "cri_data";
+			size = <0x0 0x1000000>;
+			mask = <2>;
+		};
+		data:data
+		{
+			pname = "data";
+			size = <0xffffffff 0xffffffff>;
+			mask = <4>;
+		};
+	};
+
+	unifykey {
+		compatible = "amlogic, unifykey";
+		status = "ok";
+
+		unifykey-num = <11>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+		unifykey-index-3 = <&keysn_3>;
+		unifykey-index-4 = <&keysn_4>;
+		unifykey-index-5 = <&keysn_5>;
+		unifykey-index-6 = <&keysn_6>;
+		unifykey-index-7 = <&keysn_7>;
+		unifykey-index-8 = <&keysn_8>;
+		unifykey-index-9 = <&keysn_9>;
+		unifykey-index-10= <&keysn_10>;
+
+                keysn_0: key_0{
+			key-name = "usid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_1:key_1{
+			key-name = "mac";
+                        key-device  = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_2:key_2{
+                        key-name = "hdcp";
+			key-device = "secure";
+                        key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_3:key_3{
+			key-name = "secure_boot_set";
+			key-device = "efuse";
+			key-permit = "write";
+		};
+		keysn_4:key_4{
+			key-name = "mac_bt";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_5:key_5{
+			key-name = "mac_wifi";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_6:key_6{
+			key-name = "hdcp2_tx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_7:key_7{
+			key-name = "hdcp2_rx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_8:key_8{
+			key-name = "widevinekeybox";
+			key-device = "secure";
+			key-type = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_9:key_9{
+			key-name = "deviceid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_10:key_10{
+			key-name = "hdcp22_fw_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+        };//End unifykey
+
+	aocec: aocec {
+		compatible = "amlogic, amlogic-aocec";
+		device_name = "aocec";
+		status = "disabled";
+		vendor_name = "Amlogic"; /* Max Chars: 8     */
+		vendor_id = <0x000000>; /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+		product_desc = "GXBB Mbox"; /* Max Chars: 16    */
+		cec_osd_string = "MBox"; /* Max Chars: 14    */
+		port_num = <1>;
+		arc_port_mask = <0x0>;
+		interrupts = <0 199 1>;
+		interrupt-names = "hdmi_aocec";
+		reg = <0x0 0xc810023c 0x0 0x4
+		       0x0 0xc8100000 0x0 0x200>;
+	};
+
+	tvout {
+		compatible = "amlogic, tvout";
+		dev_name = "tvout";
+		status = "disable";
+	};
+
+	uart_AO: serial@c81004c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004c0 0x0 0x18>;
+		interrupts = <0 193 1>;
+		status = "okay";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		xtal_tick_en = <1>;
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_a_pins>;
+		support-sysrq = <0>;	/* 0 not support , 1 support */
+	};
+	uart_AO_B: serial@c81004e0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004e0 0x0 0x18>;
+		interrupts = <0 197 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_b_pins>;
+	};
+	uart_A: serial@c11084c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084c0 0x0 0x18>;
+		interrupts = <0 26 1>;
+		status = "disabled";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 128 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_a_pins>;
+		resets = <&clock GCLK_IDX_UART0>;
+	};
+	uart_B: serial@c11084dc {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084dc 0x0 0x18>;
+		interrupts = <0 75 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_b_pins>;
+		resets = <&clock GCLK_IDX_UART1>;
+	};
+	uart_C: serial@c1108700 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc1108700 0x0 0x18>;
+		interrupts = <0 93 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		resets = <&clock GCLK_IDX_UART2>;
+	};
+
+	canvas{
+		compatible = "amlogic, meson, canvas";
+		dev_name = "amlogic-canvas";
+		status = "ok";
+		reg = <0x0 0xc8838000 0x0 0x400>;
+	};
+
+	rdma{
+		compatible = "amlogic, meson, rdma";
+		dev_name = "amlogic-rdma";
+		status = "ok";
+		interrupts = <0 89 1>;
+		interrupt-names = "rdma";
+	};
+
+	dwc3: dwc3@c9000000 {
+		compatible = "synopsys, gxl-dwc3";
+		reg = <0x0 0xc9000000 0x0 0x100000>;
+		interrupts = <0 30 4>;
+		usb-phy = <&usb2_phy>, <&usb3_phy>;
+		cpu-type = "gxl";
+		clock-src = "usb3.0";
+		status = "disable";
+	};
+
+	usb2_phy: usb2phy@d0078000 {
+		compatible = "amlogic, aml-gxl-usb2";
+		portnum = <4>;
+		reg = <0x0 0xd0078000 0x0 0x80>;
+		status = "disable";
+	};
+
+	usb3_phy: usb3phy@d0078080 {
+		compatible = "amlogic, aml-gxl-usb3";
+		portnum = <1>;
+		reg = <0x0 0xd0078080 0x0 0x20>;
+		interrupts = <0 16 4>;
+		status = "disable";
+	};
+
+	dwc2_a {
+		compatible = "amlogic, gxl_dwc2";
+		device_name = "dwc2_a";
+		reg = <0x0 0xc9100000 0x0 0x40000>;
+		interrupts = <0 31 4>;
+		status = "disable";
+		pl-periph-id = <0>; /** lm name */
+		clock-src = "usb0"; /** clock src */
+		port-id = <0>;  /** ref to mach/usb.h */
+		port-type = <2>;        /** 0: otg, 1: host, 2: slave */
+		port-speed = <0>; /** 0: default, high, 1: full */
+		port-config = <0>; /** 0: default */
+		port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+		port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+		usb-fifo = <512>;
+		cpu-type = "gxl";
+		controller-type = <1>; /** 0: normal, 1: otg+dwc3*/
+		phy-reg = <0xd0078000>;
+		phy-reg-size = <0xa0>;
+		resets = <&clock GCLK_IDX_USB_GENERAL
+					&clock GCLK_IDX_MISC_USB1_TO_DDR
+					&clock GCLK_IDX_USB1>;
+		reset-names = "usb_general",
+						"usb1",
+						"usb1_to_ddr";
+	};
+
+	/* AUDIO MESON8 DEVICES */
+	i2s_dai: I2S {
+		#sound-dai-cells = <0>;
+		resets = <
+			&clock GCLK_IDX_AIU_AI_TOP_GLUE
+			&clock GCLK_IDX_AUD_BUF_ABD
+			&clock GCLK_IDX_AIU_I2S_OUT
+			&clock GCLK_IDX_AIU_AMCLK_MEASURE
+			&clock GCLK_IDX_AIU_AIFIFO2
+			&clock GCLK_IDX_AIU_AUD_MIXER
+			&clock GCLK_IDX_AIU_MIXER_REG
+			&clock GCLK_IDX_AIU_ADC
+			&clock GCLK_IDX_AIU_TOP_LEVEL
+			&clock GCLK_IDX_AIU_AOCLK
+			&clock GCLK_IDX_AUD_IN
+		>;
+		reset-names =
+			"top_glue",
+			"aud_buf",
+			"i2s_out",
+			"amclk_measure",
+			"aififo2",
+			"aud_mixer",
+			"mixer_reg",
+			"adc",
+			"top_level",
+			"aoclk",
+			"aud_in";
+		clocks = <&clock CLK_MPLL2>,
+			<&clock CLK_AMCLK>;
+		clock-names = "mpll2", "mclk";
+		compatible = "amlogic, aml-i2s-dai";
+	};
+	spdif_dai: SPDIF {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-dai";
+		resets = <
+			&clock GCLK_IDX_AIU_IEC958
+			&clock GCLK_IDX_AIU_ICE958_AMCLK
+		>;
+		reset-names =
+			"iec958",
+			"iec958_amclk";
+		clocks = <&clock CLK_MPLL1>,
+			<&clock CLK_I958>,
+			<&clock CLK_AMCLK>,
+			<&clock CLK_SPDIF>,
+			<&clock CLK_81>;
+		clock-names = "mpll1", "i958", "mclk", "spdif", "clk_81";
+	};
+	pcm_dai: PCM {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
+	};
+	i2s_plat: i2s_platform {
+		compatible = "amlogic, aml-i2s";
+		interrupts = <0 29 1>;
+	};
+	pcm_plat: pcm_platform {
+		compatible = "amlogic, aml-pcm";
+	};
+	spdif_codec: spdif_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-codec";
+		pinctrl-names = "aml_audio_spdif";
+		pinctrl-0 = <&audio_spdif_pins>;
+	};
+	pcm_codec: pcm_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, pcm2BT-codec";
+	};
+	/* endof AUDIO MESON8 DEVICES */
+
+	/* AUDIO board specific */
+	dummy_codec:dummy{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_dummy_codec";
+		status = "disable";
+	};
+	amlogic_codec:t9015S{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_codec_T9015S";
+		reg = <0x0 0xc8832000 0x0 0x14>;
+		status = "okay";
+	};
+	aml_g9tv_snd {
+		compatible = "aml, aml_snd_g9tv";
+		status = "okay";
+		aml-sound-card,format = "i2s";
+		aml_sound_card,name = "AML-G9TVAUDIO";
+		pinctrl-names = "aml_snd_g9tv";
+		pinctrl-0 = <&audio_pins>;
+		mute_gpio-gpios = <&gpio GPIODV_11 GPIO_ACTIVE_HIGH>;
+		aux_dev = "tas5707";
+		cpu_list = <&cpudai0 &cpudai1 &cpudai2>;
+		codec_list = <&codec0 &codec1 &codec2>;
+		plat_list = <&i2s_plat &i2s_plat &pcm_plat>;
+		cpudai0: cpudai0 {
+			sound-dai = <&i2s_dai>;
+		};
+		cpudai1: cpudai1 {
+			sound-dai = <&spdif_dai>;
+		};
+		cpudai2: cpudai2 {
+			sound-dai = <&pcm_dai>;
+		};
+		codec0: codec0 {
+			sound-dai = <&amlogic_codec>;
+		};
+		codec1: codec1 {
+			sound-dai = <&spdif_codec>;
+		};
+		codec2: codec2 {
+			sound-dai = <&pcm_codec>;
+		};
+ 	};
+	amaudio2 {
+		compatible = "amlogic, aml_amaudio2";
+		status = "okay";
+		interrupts = <0 48 1>;
+ 	};
+
+	aml_sensor0: aml-sensor@0 {
+		compatible = "amlogic, aml-thermal";
+		device_name = "thermal";
+		#thermal-sensor-cells = <1>;
+		cooling_devices {
+			cpufreq_cool_cluster0 {
+				min_state = <1000000>;
+				dyn_coeff = <140>;
+				cluster_id = <0>;
+				node_name = "cpus";
+				device_type = "cpufreq";
+			};
+			cpucore_cool_cluster0 {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "cpu_core_cluster0";
+				device_type = "cpucore";
+			};
+			gpufreq_cool {
+				min_state = <400>;
+				dyn_coeff = <437>;
+				cluster_id = <0>;
+				node_name = "mali";
+				device_type = "gpufreq";
+			};
+			gpucore_cool {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "thermal_gpu_cores";
+				device_type = "gpucore";
+			};
+		};
+		cpu_cluster0:cpu_core_cluster0 {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+		gpucore:thermal_gpu_cores {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+	};
+
+	thermal-zones {
+		soc_thermal {
+			polling-delay = <1000>;
+			polling-delay-passive = <100>;
+			sustainable-power = <2150>;
+
+			thermal-sensors = <&aml_sensor0 3>;
+
+			trips {
+				switch_on: trip-point@0 {
+					temperature = <70000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				control: trip-point@1 {
+					temperature = <80000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				hot: trip-point@2 {
+					temperature = <85000>;
+					hysteresis = <5000>;
+					type = "hot";
+				};
+				critical: trip-point@3 {
+					temperature = <260000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				cpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpus 0 4>;
+					contribution = <1024>;
+				};
+				cpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpu_cluster0 0 3>;
+					contribution = <1024>;
+				};
+				gpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpu 0 4>;
+					contribution = <1024>;
+				};
+				gpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpucore 0 2>;
+					contribution = <1024>;
+				};
+			};
+		};
+	};
+
+}; /* end of / */
+
+&pinmux {
+	audio_pins:audio_pin{
+		amlogic,setmask=<4 0x00000780>;
+		amlogic,clrmask=<4 0x0000000e
+				 3 0x001c0000>;
+		amlogic,pins = "GPIOZ_10","GPIOZ_11","GPIOZ_12","GPIOZ_14";
+	};
+
+	audio_spdif_pins:audio_pin1{
+		amlogic,setmask=<3 0x40000000>; /*spdif_out*/
+		amlogic,clrmask=<3 0x00200000>;
+		amlogic,pins ="GPIOZ_17"; /*spdif_out*/
+	};
+
+};
+
diff --git a/arch/arm64/boot/dts/amlogic/txl_skt.dts b/arch/arm64/boot/dts/amlogic/txl_skt.dts
new file mode 100644
index 0000000..239405a
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/txl_skt.dts
@@ -0,0 +1,1174 @@
+/*
+ * arch/arm64/boot/dts/amlogic/txl_skt.dts
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/dts-v1/;
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/txl.h>
+#include <dt-bindings/gpio/txl.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/reset/aml_txl.h>
+
+#include "mesontxl.dtsi"
+#include "mesontxl_skt-panel.dtsi"
+
+/ {
+	model = "Amlogic";
+	compatible = "amlogic, txl";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart_AO;
+		serial1 = &uart_A;
+		serial2 = &uart_B;
+		serial3 = &uart_C;
+		serial4 = &uart_AO_B;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		linux,usable-memory = <0x0 0x1000000 0x0 0x3f000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		/* global autoconfigured region for contiguous allocations */
+		secmon_reserved:linux,secmon {
+			compatible = "amlogic, aml_secmon_memory";
+			reg = <0x0 0x10000000 0x0 0x200000>;
+			no-map;
+		};
+
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
+
+		pstore:aml_pstore {
+			compatible = "amlogic, pstore";
+			reg = <0x0 0x07300000 0x0 0x100000>;
+			no-map;
+		};
+
+		fb_reserved:linux,meson-fb {
+			compatible = "amlogic, fb-memory";
+			size = <0x0 0x2000000>;
+			no-map;
+		};
+
+		di_reserved:linux,di {
+			compatible = "amlogic, di-mem";
+			/** 10x(1920x1088x(3/2+1/5)+1088)x5/4=43M 10bit **/
+			/** 10x(1920x1088x(3/2+1/5)+1088)x3/2=51M 12bit **/
+			size = <0x0 0x2b00000>;
+			//no-map;
+		};
+
+		demod_reserved:linux,demod {
+			compatible = "amlogic, demod-mem";
+			size = <0x0 0x600000>; //20m
+			multi-use;
+			//no-map;
+		};
+
+		ion_reserved:linux,ion-dev {
+			compatible = "amlogic, idev-mem";
+			size = <0x0 0x2000000>;
+		};
+
+		/*  POST PROCESS MANAGER */
+		ppmgr_reserved:linux,ppmgr {
+			compatible = "amlogic, ppmgr_memory";
+			size = <0x0 0x0>;
+			multi-use;
+		};
+
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0xbc00000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+
+		picdec_cma_reserved:linux,picdec {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x0>;
+			alignment = <0x0 0x0>;
+			linux,contiguous-region;
+		};
+
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x4100000>;
+			alignment = <0x0 0x100000>;
+ 			//no-map;
+		};
+		/*  vdin0 CMA pool */
+		//vdin0_cma_reserved:linux,vdin0_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <4>;
+		//	reusable;
+			/* 3840x2160x2x4  =64+4 M */
+		//	size = <0x0 0x04400000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+		/*  vdin1 CMA pool */
+		vdin1_cma_reserved:linux,vdin1_cma {
+			compatible = "shared-dma-pool";
+			linux,phandle = <5>;
+			reusable;
+			/* 1920x1080x2x4  =16+4 M */
+			size = <0x0 0x01400000>;
+			alignment = <0x0 0x400000>;
+		};
+		/*  tvafe CMA pool */
+		//tvafe_cma_reserved:linux,tvafe_cma {
+		//	compatible = "shared-dma-pool";
+		//	linux,phandle = <6>;
+		//	reusable;
+			/* 5 M */
+		//	size = <0x0 0x00800000>;
+		//	alignment = <0x0 0x400000>;
+		//};
+	};
+
+	sysled {
+		compatible = "amlogic, sysled";
+		dev_name = "sysled";
+		status = "disable";
+		//led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_LOW>;
+	};
+
+	meson-vout {
+		compatible = "amlogic, meson-vout";
+		dev_name = "meson-vout";
+		status = "okay";
+	};
+
+	meson-fb {
+		compatible = "amlogic, meson-fb";
+		memory-region = <&fb_reserved>;
+		dev_name = "meson-fb";
+		status = "okay";
+		interrupts = <0 3 1
+			0 89 1>;
+		interrupt-names = "viu-vsync", "rdma";
+		mem_size = <0x01800000 0x00100000>; /* fb0/fb1 memory size */
+		display_mode_default = "1080p60hz";
+		scale_mode = <1>; /** 0:VPU free scale 1:OSD free scale 2:OSD super scale */
+		display_size_default = <1920 1080 1920 3240 32>; //1920*1080*4*3 = 0x17BB000
+		pxp_mode = <1>; /** 0:normal mode 1:pxp mode */
+	};
+
+	ge2d {
+		compatible = "amlogic, ge2d";
+		dev_name = "ge2d";
+		status = "okay";
+		interrupts = <0 150 1>;
+		interrupt-names = "ge2d";
+		clocks = <&clock CLK_VAPB_0>,
+			<&clock CLK_GE2D>;
+		clock-names = "clk_vapb_0",
+				"clk_ge2d";
+		resets = <&clock GCLK_IDX_GE2D>;
+		reset-names = "ge2d";
+	};
+
+	codec_io {
+		compatible = "amlogic, codec_io";
+		#address-cells=<2>;
+		#size-cells=<2>;
+		ranges;
+		io_cbus_base{
+			reg = <0x0 0xC1100000 0x0 0x100000>;
+		};
+		io_dos_base{
+			reg = <0x0 0xc8820000 0x0 0x10000>;
+		};
+		io_hiubus_base{
+			reg = <0x0 0xc883c000 0x0 0x2000>;
+		};
+		io_aobus_base{
+			reg = <0x0 0xc8100000 0x0 0x100000>;
+		};
+		io_vcbus_base{
+			reg = <0x0 0xd0100000 0x0 0x40000>;
+		};
+		io_dmc_base{
+			reg = <0x0 0xc8838000 0x0 0x400>;
+		};
+	};
+
+	codec_mm {
+			compatible = "amlogic, codec, mm";
+			memory-region = <&codec_mm_cma &codec_mm_reserved>;
+			dev_name = "codec_mm";
+			status = "okay";
+	};
+	ethmac: ethernet@0xc9410000 {
+			compatible = "amlogic, gxbb-rmii-dwmac";
+			reg = <0x0 0xc9410000 0x0 0x10000
+			0x0 0xc8834540 0x0 0x8
+			0x0 0xc8834558 0x0 0xc>;
+			interrupts = <0 8 1>;
+			phy-mode= "rmii";
+			mc_val = <0x1800>;
+			resets = <&clock GCLK_IDX_ETHERNET>;
+			reset-names = "ethpower";
+			interrupt-names = "macirq";
+			clocks = <&clock CLK_81>;
+			clock-names = "ethclk81";
+			internal_phy=<1>;
+	};
+	mesonstream {
+		compatible = "amlogic, codec, streambuf";
+		dev_name = "mesonstream";
+		status = "okay";
+		resets = <&clock GCLK_IDX_HIU_PARSER_TOP
+			&clock GCLK_IDX_VPU_INTR
+			&clock GCLK_IDX_DEMUX
+			&clock GCLK_IDX_DOS>;
+		reset-names = "parser_top",
+			"vpu_intr",
+			"demux",
+			"vdec";
+	};
+
+	amvideocap {
+		compatible = "amlogic, amvideocap";
+		dev_name = "amvideocap.0";
+		status = "okay";
+		max_size = <8>;//8M
+	};
+
+	ion_dev {
+		compatible = "amlogic, ion_dev";
+		memory-region = <&ion_reserved>;
+	};
+
+	vdec {
+		compatible = "amlogic, vdec";
+		dev_name = "vdec.0";
+		status = "okay";
+		interrupts = <0 3 1
+			0 23 1
+			0 32 1
+			0 43 1
+			0 44 1
+			0 45 1>;
+		interrupt-names = "vsync",
+			"demux",
+			"parser",
+			"mailbox_0",
+			"mailbox_1",
+			"mailbox_2";
+	};
+
+	picdec {
+		   compatible = "amlogic, picdec";
+		   memory-region = <&picdec_cma_reserved>;
+		   dev_name = "picdec";
+		   status = "okay";
+	};
+
+	ppmgr {
+		compatible = "amlogic, ppmgr";//to match of_device_id's compatible member
+		memory-region = <&ppmgr_reserved>;
+		dev_name = "ppmgr";
+		status = "okay";
+	};
+
+	deinterlace {
+		compatible = "amlogic, deinterlace";
+		status = "okay";
+		memory-region = <&di_reserved>;
+		interrupts = <0 46 1
+				0 6 1>;
+		interrupt-names = "de_irq",
+				"timerc";
+		buffer-size = <2960266>;
+		hw-version = <2>;
+		/* if enable nr10bit, set nr10bit-surpport to 1 */
+		nr10bit-surpport = <1>;
+	};
+
+	vdin0 {
+		compatible = "amlogic, vdin";
+		/*memory-region = <&vdin0_cma_reserved>;*/
+		dev_name = "vdin0";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <1>;/*1:share with codec_mm;2:cma alone*/
+		/*MByte, if 10bit disable: 64M(YUV422), if 10bit enable: 64*1.5 = 96M(YUV422)
+		*if support 4K2K-YUV444-10bit-WR:3840*2160*4*4 ~= 128M
+		*if support 4K2K-YUV422-10bit-wr:3840*2160*3*4 ~= 96M
+		*if support 4K2K-YUV422-8BIT-WR:3840*2160*2*4 ~= 64M
+		*if support 1080p-YUV422-8BIT-WR:1920*1080*2*4 ~= 16M*/
+		cma_size = <96>;
+		interrupts = <0 83 1>;
+		rdma-irq = <2>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <0>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit
+		*bit4:support yuv422 10bit full pack mode (from txl new add)*/
+		tv_bit_mode = <21>;
+	};
+	vdin1 {
+		compatible = "amlogic, vdin";
+		memory-region = <&vdin1_cma_reserved>;
+		dev_name = "vdin1";
+		status = "ok";
+		reserve-iomap = "true";
+		flag_cma = <0>;/*1:share with codec_mm;0:cma alone*/
+		interrupts = <0 85 1>;
+		rdma-irq = <4>;
+		clocks = <&clock CLK_FPLL_DIV5>,
+			<&clock CLK_VDIN_MEAS_CLK>;
+		clock-names = "fclk_div5", "cts_vdin_meas_clk";
+		vdin_id = <1>;
+		/*vdin write mem color depth support:
+		*bit0:support 8bit
+		*bit1:support 9bit
+		*bit2:support 10bit
+		*bit3:support 12bit*/
+		tv_bit_mode = <1>;
+	};
+	tvafe {
+		compatible = "amlogic, tvafe";
+		/*memory-region = <&tvafe_cma_reserved>;*/
+		dev_name = "tvafe";
+		status = "ok";
+		flag_cma = <1>;/*1:share with codec_mm;0:cma alone*/
+		cma_size = <8>;/*MByte*/
+		reg = <0x0 0xc8842000 0x0 0x2000>;
+		reserve-iomap = "true";
+		tvafe_id = <0>;
+		pinctrl-names = "default";
+		tvafe_pin_mux = < /*!!particular sequence, no more and no less!!!*/
+                        3       /*// TVAFE_CVBS_IN2,  //CVBS_IN0 = 0,*/
+                        1       /*// TVAFE_CVBS_IN0,    //CVBS_IN1,*/
+                        2       /*// TVAFE_CVBS_IN1,  //CVBS_IN2*/
+                        4       /*// TVAFE_CVBS_IN3,    //CVBS_IN3,*/
+		>;
+	};
+	amlvecm {
+		compatible = "amlogic, vecm";
+		dev_name = "aml_vecm";
+		status = "okay";
+		gamma_en = <1>;/*1:enabel ;0:disable*/
+		wb_en = <1>;/*1:enabel ;0:disable*/
+		cm_en = <1>;/*1:enabel ;0:disable*/
+	};
+
+	hdmirx {
+		compatible = "amlogic, hdmirx";
+		dev_name = "hdmirx";
+		status = "ok";
+		pinctrl-names = "hdmirx_pins","hu_det_none",
+				"hu_det_uart0","hu_det_uart1","hu_det_uart2";
+		pinctrl-0 = <&hdmirx_pins>;
+		pinctrl-1 = <&hu_det_none>;
+		pinctrl-2 = <&hdmirx_pins &cha_uart_in>;
+		pinctrl-3 = <&hdmirx_pins &chb_uart_in>;
+		pinctrl-4 = <&hdmirx_pins &chc_uart_in>;
+		rx_port_maps = <0x3120>;
+		hdmiuart_share_cfg = <0>;
+		repeat = <0>;
+		interrupts = <0 56 1>;
+		hdmirx_addr_port = <0xda846000>;
+		hdmirx_data_port = <0xda846004>;
+		hdmirx_ctrl_port = <0xda846008>;
+		clocks = <&clock CLK_HDMIRX_MODET_CLK>,
+			<&clock CLK_HDMIRX_CFG_CLK>,
+			<&clock CLK_HDMIRX_ACR_REF_CLK>,
+			<&clock CLK_HDMIRX_AUDMEAS_CLK>,
+			<&clock CLK_XTAL>,
+			<&clock CLK_FPLL_DIV5>;
+		clock-names = "hdmirx_modet_clk",
+			"hdmirx_cfg_clk",
+			"hdmirx_acr_ref_clk",
+			"hdmirx_audmeas_clk",
+			"xtal",
+			"fclk_div5";
+		hdmirx_id = <0>;
+		uart_scl_a_pin =  <&gpio       GPIOW_7       GPIO_ACTIVE_HIGH>;
+		uart_scl_b_pin =  <&gpio       GPIOW_15      GPIO_ACTIVE_HIGH>;
+		uart_scl_c_pin =  <&gpio       GPIOW_11      GPIO_ACTIVE_HIGH>;
+ 	};
+
+	amvenc_avc {
+		compatible = "amlogic, amvenc_avc";
+		//memory-region = <&amvenc_avc_reserved>;
+		//memory-region = <&avc_cma_reserved>;
+		dev_name = "amvenc_avc";
+		status = "okay";
+		interrupts = <0 45 1>;
+		interrupt-names = "mailbox_2";
+	};
+
+	vpu {
+		compatible = "amlogic, vpu";
+		dev_name = "vpu";
+		status = "ok";
+		clk_level = <7>;
+		/**	0: 100.0M    1: 166.7M    2: 200.0M
+			3: 250.0M    4: 333.3M    5: 400.0M
+			6: 500.0M    7: 666.7M */
+	};
+
+	bt-dev{
+		compatible = "amlogic, bt-dev";
+		dev_name = "bt-dev";
+		status = "disabled";
+		//gpio_reset = <&gpio GPIOX_18 GPIO_ACTIVE_HIGH>;
+	};
+
+	rtc{
+		compatible = "amlogic, aml_vrtc";
+		alarm_reg_addr = <0xc81000a8>;
+		timer_e_addr = <0xc1109988>;
+		init_date = "2015/01/01";
+		status = "okay";
+	};
+
+	wifi {
+		compatible = "amlogic, aml_wifi";
+		dev_name = "aml_wifi";
+		status = "disabled";
+		//interrupt_pin = <&gpio       GPIOX_7       GPIO_ACTIVE_HIGH>;
+		interrupts = <	0 68 4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		//power_on_pin = <&gpio       GPIOX_6       GPIO_ACTIVE_HIGH>;
+	};
+
+	emmc {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0074000 0x0 0x2000>;
+		interrupts = <	0 218 1>;
+		pinctrl-names = "emmc_clk_cmd_pins", "emmc_all_pins";
+		pinctrl-0 = <&emmc_clk_cmd_pins>;
+		pinctrl-1 = <&emmc_conf_pull_up &emmc_conf_pull_done &emmc_all_pins>;
+		emmc {
+			status = "okay";
+			pinname = "emmc";
+			ocr_avail = <0x200080>; /**VDD voltage 3.3 ~ 3.4 */
+			caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+				"MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_1_8V_DDR",
+				"MMC_CAP_HW_RESET", "MMC_CAP_ERASE", "MMC_CAP_CMD23";
+			caps2 = "MMC_CAP2_HS200", "MMC_CAP2_HS400";
+			f_min = <300000>;
+			f_max = <100000000>;
+			tx_phase = <3>;
+			max_req_size = <0x20000>; /* 256KB */
+			gpio_dat3 = <&gpio BOOT_3 GPIO_ACTIVE_HIGH>;
+			hw_reset =  <&gpio BOOT_9 GPIO_ACTIVE_HIGH>;
+			card_type = <1>; /* 1:mmc card(include eMMC), 2:sd card(include tSD), */
+		};
+	};
+
+	sd {
+		compatible = "amlogic, aml_sd_emmc";
+		dev_name = "aml_newsd.0";
+		status = "okay";
+		reg = <0x0 0xd0072000 0x0 0x2000>;
+		interrupts = <	0 217 1
+				0 67 1
+				0 69 1>;
+		pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "sd_1bit_pins", "sd_clk_cmd_uart_pins", "sd_1bit_uart_pins";
+		pinctrl-0 = <&sd_clk_cmd_pins>;
+		pinctrl-1 = <&sd_all_pins>;
+		pinctrl-2 = <&sd_1bit_pins>;
+		pinctrl-3 = <&sd_clk_cmd_uart_pins>;
+		pinctrl-4 = <&sd_1bit_uart_pins>;
+		sd {
+			status = "okay";
+	   		pinname = "sd";
+	   		ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+	   		caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED",
+	   			"MMC_CAP_SD_HIGHSPEED";
+	   			//"MMC_CAP_UHS_SDR12",
+	   			//"MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50",
+	   			//"MMC_CAP_UHS_SDR104";
+	   		f_min = <400000>;
+	   		f_max = <100000000>;
+	   		max_req_size = <0x20000>; /**128KB*/
+			gpio_dat3 = <&gpio CARD_4 GPIO_ACTIVE_HIGH>;
+			jtag_pin  = <&gpio CARD_0 GPIO_ACTIVE_HIGH>;
+			gpio_cd   = <&gpio CARD_6 GPIO_ACTIVE_HIGH>;
+	   		irq_in = <3>;
+	   		irq_out = <5>;
+	   		card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+		};
+	};
+
+	partitions: partitions {
+		parts = <12>;
+		part-0 = <&logo>;
+		part-1 = <&recovery>;
+		part-2 = <&param>;
+		part-3 = <&tee>;
+		part-4 = <&crypt>;
+		part-5 = <&misc>;
+		part-6 = <&instaboot>;
+		part-7 = <&boot>;
+		part-8 = <&system>;
+		part-9 = <&cache>;
+		part-10 = <&cri_data>;
+		part-11 = <&data>;
+
+		logo:logo{
+			pname = "logo";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		recovery:recovery{
+			pname = "recovery";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		param:param{
+			pname = "param";
+			size = <0x0 0x8000000>;
+			mask = <2>;
+		};
+		tee:tee{
+			pname = "tee";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+		crypt:crypt{
+			pname = "crypt";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		misc:misc{
+			pname = "misc";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		instaboot:instaboot{
+			pname = "instaboot";
+			size = <0x0 0x20000000>;
+			mask = <1>;
+		};
+		boot:boot
+		{
+			pname = "boot";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+		system:system
+		{
+			pname = "system";
+			size = <0x0 0x40000000>;
+			mask = <1>;
+		};
+		cache:cache
+		{
+			pname = "cache";
+			size = <0x0 0x20000000>;
+			mask = <2>;
+		};
+		cri_data:cri_data
+		{
+			pname = "cri_data";
+			size = <0x0 0x1000000>;
+			mask = <2>;
+		};
+		data:data
+		{
+			pname = "data";
+			size = <0xffffffff 0xffffffff>;
+			mask = <4>;
+		};
+	};
+
+	unifykey {
+		compatible = "amlogic, unifykey";
+		status = "ok";
+
+		unifykey-num = <14>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+		unifykey-index-3 = <&keysn_3>;
+		unifykey-index-4 = <&keysn_4>;
+		unifykey-index-5 = <&keysn_5>;
+		unifykey-index-6 = <&keysn_6>;
+		unifykey-index-7 = <&keysn_7>;
+		unifykey-index-8 = <&keysn_8>;
+		unifykey-index-9 = <&keysn_9>;
+		unifykey-index-10= <&keysn_10>;
+		unifykey-index-11 = <&keysn_11>;
+		unifykey-index-12 = <&keysn_12>;
+		unifykey-index-13 = <&keysn_13>;
+
+                keysn_0: key_0{
+			key-name = "usid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_1:key_1{
+			key-name = "mac";
+                        key-device  = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_2:key_2{
+                        key-name = "hdcp";
+			key-device = "secure";
+                        key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_3:key_3{
+			key-name = "secure_boot_set";
+			key-device = "efuse";
+			key-permit = "write";
+		};
+		keysn_4:key_4{
+			key-name = "mac_bt";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_5:key_5{
+			key-name = "mac_wifi";
+			key-device = "normal";
+			key-permit = "read","write","del";
+                        key-type  = "mac";
+		};
+		keysn_6:key_6{
+			key-name = "hdcp2_tx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_7:key_7{
+			key-name = "hdcp2_rx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_8:key_8{
+			key-name = "widevinekeybox";
+			key-device = "secure";
+			key-type = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_9:key_9{
+			key-name = "deviceid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_10:key_10{
+			key-name = "hdcp22_fw_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_11:key_11{
+			key-name = "hdcp22_rx_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_12:key_12{
+			key-name = "hdcp22_rx_fw";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_13:key_13{
+			key-name = "hdcp14_rx";
+			key-device = "normal";
+			key-type  = "sha1";
+			key-permit = "read","write","del";
+		};
+        };//End unifykey
+
+	aocec: aocec {
+		compatible = "amlogic, amlogic-aocec";
+		device_name = "aocec";
+		status = "okay";
+		vendor_name = "Amlogic"; /* Max Chars: 8     */
+		vendor_id = <0x000000>; /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+		product_desc = "TXL"; /* Max Chars: 16    */
+		cec_osd_string = "AML_TV"; /* Max Chars: 14    */
+		port_num = <3>;
+		ee_cec;
+		arc_port_mask = <0x2>;
+		interrupts = <0 56 1>;
+		interrupt-names = "hdmi_eecec";
+		pinctrl-names = "hdmitx_eecec";
+		pinctrl-0=<&hdmitx_eecec>;
+		reg = <0x0 0xc810023c 0x0 0x4
+		       0x0 0xc8100000 0x0 0x200
+		       0x0 0xda83e000 0x0 0x10
+		       0x0 0xc883c000 0x0 0x400>;
+	};
+
+	tvout {
+		compatible = "amlogic, tvout";
+		dev_name = "tvout";
+		status = "disable";
+	};
+
+	uart_AO: serial@c81004c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004c0 0x0 0x18>;
+		interrupts = <0 193 1>;
+		status = "okay";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		xtal_tick_en = <1>;
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_a_pins>;
+		support-sysrq = <0>;	/* 0 not support , 1 support */
+	};
+	uart_AO_B: serial@c81004e0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc81004e0 0x0 0x18>;
+		interrupts = <0 197 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_ao_b_pins>;
+	};
+	uart_A: serial@c11084c0 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084c0 0x0 0x18>;
+		interrupts = <0 26 1>;
+		status = "disabled";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 128 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_a_pins>;
+		resets = <&clock GCLK_IDX_UART0>;
+	};
+	uart_B: serial@c11084dc {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc11084dc 0x0 0x18>;
+		interrupts = <0 75 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart_b_pins>;
+		resets = <&clock GCLK_IDX_UART1>;
+	};
+	uart_C: serial@c1108700 {
+		compatible = "amlogic, meson-uart";
+		reg = <0x0 0xc1108700 0x0 0x18>;
+		interrupts = <0 93 1>;
+		status = "disable";
+		clocks = <&clock CLK_XTAL>;
+		clock-names = "clk_uart";
+		fifosize = < 64 >;
+		resets = <&clock GCLK_IDX_UART2>;
+	};
+
+	canvas{
+		compatible = "amlogic, meson, canvas";
+		dev_name = "amlogic-canvas";
+		status = "ok";
+		reg = <0x0 0xc8838000 0x0 0x400>;
+	};
+
+	rdma{
+		compatible = "amlogic, meson, rdma";
+		dev_name = "amlogic-rdma";
+		status = "ok";
+		interrupts = <0 89 1>;
+		interrupt-names = "rdma";
+	};
+
+	dwc3: dwc3@c9000000 {
+		compatible = "synopsys, dwc3";
+		reg = <0x0 0xc9000000 0x0 0x100000>;
+		interrupts = <0 30 4>;
+		usb-phy = <&usb2_phy>, <&usb3_phy>;
+		cpu-type = "gxl";
+		clock-src = "usb3.0";
+	};
+
+	usb2_phy: usb2phy@d0078000 {
+		compatible = "amlogic, amlogic-new-usb2";
+		portnum = <4>;
+		reg = <0x0 0xd0078000 0x0 0x80>;
+	};
+
+	usb3_phy: usb3phy@d0078080 {
+		compatible = "amlogic, amlogic-new-usb3";
+		portnum = <0>;
+		reg = <0x0 0xd0078080 0x0 0x20>;
+	};
+
+	dwc2_a {
+		compatible = "amlogic,dwc2";
+		device_name = "dwc2_a";
+		reg = <0x0 0xc9100000 0x0 0x40000>;
+		status = "okay";
+		interrupts = <0 31 4>;
+		pl-periph-id = <0>; /** lm name */
+		clock-src = "usb0"; /** clock src */
+		port-id = <0>;  /** ref to mach/usb.h */
+		port-type = <2>;        /** 0: otg, 1: host, 2: slave */
+		port-speed = <0>; /** 0: default, high, 1: full */
+		port-config = <0>; /** 0: default */
+		port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+		port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+		usb-fifo = <728>;
+		cpu-type = "gxl";
+		controller-type = <1>; /** 0: normal, 1: otg+dwc3 host only, 2: otg+dwc3 device only*/
+		phy-reg = <0xd0078000>;
+		phy-reg-size = <0xa0>;
+		resets = <&clock GCLK_IDX_USB_GENERAL
+					&clock GCLK_IDX_MISC_USB1_TO_DDR
+					&clock GCLK_IDX_USB1>;
+		reset-names = "usb_general",
+						"usb1",
+						"usb1_to_ddr";
+	};
+
+	/* AUDIO MESON8 DEVICES */
+	i2s_dai: I2S {
+		#sound-dai-cells = <0>;
+		resets = <
+			&clock GCLK_IDX_AIU_AI_TOP_GLUE
+			&clock GCLK_IDX_AUD_BUF_ABD
+			&clock GCLK_IDX_AIU_I2S_OUT
+			&clock GCLK_IDX_AIU_AMCLK_MEASURE
+			&clock GCLK_IDX_AIU_AIFIFO2
+			&clock GCLK_IDX_AIU_AUD_MIXER
+			&clock GCLK_IDX_AIU_MIXER_REG
+			&clock GCLK_IDX_AIU_ADC
+			&clock GCLK_IDX_AIU_TOP_LEVEL
+			&clock GCLK_IDX_AIU_AOCLK
+			&clock GCLK_IDX_AUD_IN
+		>;
+		reset-names =
+			"top_glue",
+			"aud_buf",
+			"i2s_out",
+			"amclk_measure",
+			"aififo2",
+			"aud_mixer",
+			"mixer_reg",
+			"adc",
+			"top_level",
+			"aoclk",
+			"aud_in";
+		clocks = <&clock CLK_MPLL2>,
+			<&clock CLK_AMCLK>;
+		clock-names = "mpll2", "mclk";
+		compatible = "amlogic, aml-i2s-dai";
+	};
+	spdif_dai: SPDIF {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-dai";
+		resets = <
+			&clock GCLK_IDX_AIU_IEC958
+			&clock GCLK_IDX_AIU_ICE958_AMCLK
+		>;
+		reset-names =
+			"iec958",
+			"iec958_amclk";
+		clocks = <&clock CLK_MPLL1>,
+			<&clock CLK_I958>,
+			<&clock CLK_AMCLK>,
+			<&clock CLK_SPDIF>,
+			<&clock CLK_81>;
+		clock-names = "mpll1", "i958", "mclk", "spdif", "clk_81";
+	};
+	pcm_dai: PCM {
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-pcm-dai";
+		pinctrl-names = "aml_audio_btpcm";
+		pinctrl-0 = <&audio_btpcm_pins>;
+		clocks = <&clock CLK_MPLL0>,
+			<&clock CLK_PCM_MCLK>,
+			<&clock CLK_PCM_SCLK>;
+		clock-names = "mpll0", "pcm_mclk", "pcm_sclk";
+		pcm_mode = <1>;	/* 0=slave mode, 1=master mode */
+	};
+	i2s_plat: i2s_platform {
+		compatible = "amlogic, aml-i2s";
+		interrupts = <0 29 1>;
+	};
+	pcm_plat: pcm_platform {
+		compatible = "amlogic, aml-pcm";
+	};
+	spdif_codec: spdif_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-codec";
+		pinctrl-names = "aml_audio_spdif";
+		pinctrl-0 = <&audio_spdif_pins>;
+	};
+	pcm_codec: pcm_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, pcm2BT-codec";
+	};
+	/* endof AUDIO MESON8 DEVICES */
+
+	/* AUDIO board specific */
+	dummy_codec:dummy{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_dummy_codec";
+		status = "disable";
+	};
+	amlogic_codec:t9015S{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_codec_T9015S";
+		reg = <0x0 0xc8832000 0x0 0x14>;
+		status = "okay";
+	};
+	aml_g9tv_snd {
+		compatible = "aml, aml_snd_g9tv";
+		status = "okay";
+		aml-sound-card,format = "i2s";
+		aml_sound_card,name = "AML-G9TVAUDIO";
+		pinctrl-names = "aml_snd_g9tv";
+		pinctrl-0 = <&audio_pins>;
+		mute_gpio-gpios = <&gpio GPIODV_11 GPIO_ACTIVE_HIGH>;
+		aux_dev = "tas5707";
+		cpu_list = <&cpudai0 &cpudai1 &cpudai2>;
+		codec_list = <&codec0 &codec1 &codec2>;
+		plat_list = <&i2s_plat &i2s_plat &pcm_plat>;
+		cpudai0: cpudai0 {
+			sound-dai = <&i2s_dai>;
+		};
+		cpudai1: cpudai1 {
+			sound-dai = <&spdif_dai>;
+		};
+		cpudai2: cpudai2 {
+			sound-dai = <&pcm_dai>;
+		};
+		codec0: codec0 {
+			sound-dai = <&amlogic_codec>;
+		};
+		codec1: codec1 {
+			sound-dai = <&spdif_codec>;
+		};
+		codec2: codec2 {
+			sound-dai = <&pcm_codec>;
+		};
+ 	};
+	amaudio2 {
+		compatible = "amlogic, aml_amaudio2";
+		status = "okay";
+		interrupts = <0 48 1>;
+ 	};
+
+	aml_sensor0: aml-sensor@0 {
+		compatible = "amlogic, aml-thermal";
+		device_name = "thermal";
+		#thermal-sensor-cells = <1>;
+		cooling_devices {
+			cpufreq_cool_cluster0 {
+				min_state = <1000000>;
+				dyn_coeff = <140>;
+				cluster_id = <0>;
+				node_name = "cpus";
+				device_type = "cpufreq";
+			};
+			cpucore_cool_cluster0 {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "cpu_core_cluster0";
+				device_type = "cpucore";
+			};
+			gpufreq_cool {
+				min_state = <400>;
+				dyn_coeff = <437>;
+				cluster_id = <0>;
+				node_name = "mali";
+				device_type = "gpufreq";
+			};
+			gpucore_cool {
+				min_state = <1>;
+				dyn_coeff = <0>;
+				cluster_id = <0>;
+				node_name = "thermal_gpu_cores";
+				device_type = "gpucore";
+			};
+		};
+		cpu_cluster0:cpu_core_cluster0 {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+		gpucore:thermal_gpu_cores {
+			#cooling-cells = <2>; /* min followed by max */
+		};
+	};
+
+	dvb {
+		compatible = "amlogic, dvb";
+		dev_name = "dvb";
+		status = "okay";
+		/*"parallel","serial","disable"*/
+		ts2 = "parallel";
+		ts2_control = <0>;
+		ts2_invert = <0>;
+		resets = <&clock GCLK_IDX_DEMUX
+				&clock GCLK_IDX_ASYNC_FIFO
+				&clock GCLK_IDX_AHB_ARB0
+				&clock GCLK_IDX_HIU_PARSER_TOP>;
+		reset-names = "demux", "asyncfifo", "ahbarb0", "uparsertop";
+	};
+	dvbfe {
+		compatible = "amlogic, dvbfe";
+		dev_name = "dvbfe";
+		status = "okay";
+		dtv_demod0 = "AMLDEMOD";
+		fe0_dtv_demod = <0>;
+		fe0_ts = <2>;
+		fe0_dev = <0>;
+		dtv_demod0_mem = <0>;
+		dtv_demod0_spectrum = <1>;
+		memory-region = <&demod_reserved>;
+		tuner0 = "mxl661_tuner";
+		tuner0_i2c_adap_id = <2>;
+		tuner0_i2c_addr = <0x60>;
+		//tuner0_reset_value = <0>;
+		//tuner0_reset_gpio =  "GPIOY_10" ;  /*GPIOX_8   76*/
+		fe0_tuner = <0>;
+		atv_demod0 = "aml_atv_demod";
+		fe0_atv_demod = <0>;
+	};
+
+	thermal-zones {
+		soc_thermal {
+			polling-delay = <1000>;
+			polling-delay-passive = <100>;
+			sustainable-power = <2150>;
+
+			thermal-sensors = <&aml_sensor0 3>;
+
+			trips {
+				switch_on: trip-point@0 {
+					temperature = <70000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				control: trip-point@1 {
+					temperature = <80000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+				hot: trip-point@2 {
+					temperature = <85000>;
+					hysteresis = <5000>;
+					type = "hot";
+				};
+				critical: trip-point@3 {
+					temperature = <260000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				cpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpus 0 4>;
+					contribution = <1024>;
+				};
+				cpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&cpu_cluster0 0 3>;
+					contribution = <1024>;
+				};
+				gpufreq_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpu 0 4>;
+					contribution = <1024>;
+				};
+				gpucore_cooling_map {
+					trip = <&control>;
+					cooling-device = <&gpucore 0 2>;
+					contribution = <1024>;
+				};
+			};
+		};
+	};
+
+}; /* end of / */
+
+&pinmux {
+	audio_pins:audio_pin{
+		amlogic,setmask=<4 0x00000780>;
+		amlogic,clrmask=<4 0x0000000e
+				 3 0x001c0000>;
+		amlogic,pins = "GPIOZ_10","GPIOZ_11","GPIOZ_12","GPIOZ_14";
+	};
+
+	audio_spdif_pins:audio_pin1{
+		amlogic,setmask=<3 0x40000000>; /*spdif_out*/
+		amlogic,clrmask=<3 0x00200000>;
+		amlogic,pins ="GPIOZ_17"; /*spdif_out*/
+	};
+
+	hdmirx_pins: hdmirx_pins {
+                amlogic,setmask = <5  0xffff0000>;
+                amlogic,clrmask = <5  0x0000ff00>;
+                amlogic,pins = "GPIOW_6","GPIOW_8",
+                        "GPIOW_10","GPIOW_12",
+                        "GPIOW_14","GPIOW_16",
+                        "GPIOW_17","GPIOW_18","GPIOW_19","GPIOW_20";
+        };
+	hu_det_none: hu_det_none {
+		amlogic,setmask = <5  0xffff0000>,
+			<AO 0x1800>;
+		amlogic,clrmask = <5  0x0000ff00>;
+		amlogic,pins = "GPIOW_4";
+	};
+	cha_uart_in: cha_uart_in {
+		amlogic,setmask = <5  0x00003000>;
+		amlogic,clrmask = <5  0x03000000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_6";
+	};
+	chb_uart_in: chb_uart_in {
+		amlogic,setmask = <5  0x00000300>;
+		amlogic,clrmask = <5  0x00030000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_14";
+	};
+	chc_uart_in: chc_uart_in {
+		amlogic,setmask = <5  0x00000c00>;
+		amlogic,clrmask = <5  0x00300000>,
+			<AO 0x06001800>;
+		amlogic,pins = "GPIOW_10";
+	};
+};
+
diff --git a/arch/arm64/configs/meson64_defconfig b/arch/arm64/configs/meson64_defconfig
index b27bf39..281b94f 100644
--- a/arch/arm64/configs/meson64_defconfig
+++ b/arch/arm64/configs/meson64_defconfig
@@ -48,6 +48,9 @@ CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
 CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
 CONFIG_ARM_BIG_LITTLE_CPUFREQ=y
 CONFIG_ARM_SCPI_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_GOV_LADDER is not set
+CONFIG_ARM64_CPUIDLE=y
 CONFIG_NET=y
 CONFIG_PACKET=y
 CONFIG_PACKET_DIAG=y
@@ -180,6 +183,8 @@ CONFIG_BT_HCIUART_H4=y
 CONFIG_CFG80211=y
 CONFIG_MAC80211=y
 CONFIG_RFKILL=y
+CONFIG_MESON_TIMER=y
+CONFIG_MESON_BC_TIMER=y
 CONFIG_AM_UART=y
 CONFIG_PRINTK_NOBLOCK_MODE=y
 CONFIG_AML_CPU_VERSION=y
@@ -226,6 +231,7 @@ CONFIG_AMLOGIC_SECURITY_KEY=y
 CONFIG_VSYNC_RDMA=y
 CONFIG_AM_VIDEO=y
 CONFIG_GE2D_KEEP_FRAME=y
+CONFIG_AM_JPEGDEC=y
 CONFIG_AM_ENCODER=y
 CONFIG_AM_JPEG_ENCODER=y
 CONFIG_AM_PIC_DEC=y
@@ -395,6 +401,7 @@ CONFIG_LOGO=y
 CONFIG_SND_USB_AUDIO=y
 CONFIG_SND_AML_M8_SOC=y
 CONFIG_SND_AML_M8=y
+CONFIG_SND_AML_SPLIT_MODE=y
 CONFIG_HID_DIA_REMOTE=y
 CONFIG_UHID=y
 CONFIG_USB_HIDDEV=y
@@ -451,6 +458,7 @@ CONFIG_EXT3_FS_SECURITY=y
 CONFIG_EXT4_FS=y
 CONFIG_EXT4_FS_POSIX_ACL=y
 CONFIG_EXT4_FS_SECURITY=y
+CONFIG_NTFS_FS=y
 CONFIG_FANOTIFY=y
 CONFIG_QUOTA=y
 CONFIG_QFMT_V2=y
@@ -514,4 +522,3 @@ CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
 CONFIG_CRC_T10DIF=y
 CONFIG_CRC7=y
-CONFIG_AMLOGIC_LEDLIGHT=y
diff --git a/arch/arm64/include/asm/cpu_ops.h b/arch/arm64/include/asm/cpu_ops.h
index 1524130..d9e23c2 100644
--- a/arch/arm64/include/asm/cpu_ops.h
+++ b/arch/arm64/include/asm/cpu_ops.h
@@ -28,6 +28,8 @@ struct device_node;
  *		enable-method property.
  * @cpu_init:	Reads any data necessary for a specific enable-method from the
  *		devicetree, for a given cpu node and proposed logical id.
+ * @cpu_init_idle: Reads any data necessary to initialize CPU idle states from
+ *		devicetree, for a given cpu node and proposed logical id.
  * @cpu_prepare: Early one-time preparation step for a cpu. If there is a
  *		mechanism for doing so, tests whether it is possible to boot
  *		the given CPU.
@@ -46,6 +48,7 @@ struct device_node;
 struct cpu_operations {
 	const char	*name;
 	int		(*cpu_init)(struct device_node *, unsigned int);
+	int	(*cpu_init_idle)(struct device_node *, unsigned int);
 	int		(*cpu_prepare)(unsigned int);
 	int		(*cpu_boot)(unsigned int);
 	void		(*cpu_postboot)(void);
diff --git a/arch/arm64/include/asm/cpuidle.h b/arch/arm64/include/asm/cpuidle.h
new file mode 100644
index 0000000..b52a993
--- /dev/null
+++ b/arch/arm64/include/asm/cpuidle.h
@@ -0,0 +1,13 @@
+#ifndef __ASM_CPUIDLE_H
+#define __ASM_CPUIDLE_H
+
+#ifdef CONFIG_CPU_IDLE
+extern int cpu_init_idle(unsigned int cpu);
+#else
+static inline int cpu_init_idle(unsigned int cpu)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
+#endif
diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
index 68c746e..73e472f 100644
--- a/arch/arm64/kernel/Makefile
+++ b/arch/arm64/kernel/Makefile
@@ -31,6 +31,7 @@ arm64-obj-$(CONFIG_ARM_CPU_SUSPEND)	+= sleep.o suspend.o
 arm64-obj-$(CONFIG_JUMP_LABEL)		+= jump_label.o
 arm64-obj-$(CONFIG_JUMP_LABEL)		+= jump_label.o
 arm64-obj-$(CONFIG_KGDB)		+= kgdb.o
+arm64-obj-$(CONFIG_CPU_IDLE)		+= cpuidle.o
 
 arm64-obj-$(CONFIG_INSTABOOT)		+= hibernate.o
 
diff --git a/arch/arm64/kernel/cpuidle.c b/arch/arm64/kernel/cpuidle.c
new file mode 100644
index 0000000..19d17f5
--- /dev/null
+++ b/arch/arm64/kernel/cpuidle.c
@@ -0,0 +1,31 @@
+/*
+ * ARM64 CPU idle arch support
+ *
+ * Copyright (C) 2014 ARM Ltd.
+ * Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+#include <asm/cpuidle.h>
+#include <asm/cpu_ops.h>
+
+int cpu_init_idle(unsigned int cpu)
+{
+	int ret = -EOPNOTSUPP;
+	struct device_node *cpu_node = of_cpu_device_node_get(cpu);
+
+	if (!cpu_node)
+		return -ENODEV;
+
+	if (cpu_ops[cpu] && cpu_ops[cpu]->cpu_init_idle)
+		ret = cpu_ops[cpu]->cpu_init_idle(cpu_node, cpu);
+
+	of_node_put(cpu_node);
+	return ret;
+}
diff --git a/arch/arm64/kernel/psci.c b/arch/arm64/kernel/psci.c
index a9599be..36efb6c 100644
--- a/arch/arm64/kernel/psci.c
+++ b/arch/arm64/kernel/psci.c
@@ -18,6 +18,7 @@
 #include <linux/init.h>
 #include <linux/of.h>
 #include <linux/smp.h>
+#include <linux/slab.h>
 
 #include <asm/compiler.h>
 #include <asm/cpu_ops.h>
@@ -25,6 +26,7 @@
 #include <asm/psci.h>
 #include <asm/smp_plat.h>
 #include <asm/suspend.h>
+#include <asm/system_misc.h>
 
 #define PSCI_POWER_STATE_TYPE_STANDBY		0
 #define PSCI_POWER_STATE_TYPE_POWER_DOWN	1
@@ -55,6 +57,9 @@ enum psci_function {
 	PSCI_FN_MAX,
 };
 
+static DEFINE_PER_CPU_READ_MOSTLY(struct psci_power_state *,
+				psci_power_state);
+
 static u32 psci_function_id[PSCI_FN_MAX];
 
 #define PSCI_RET_SUCCESS		0
@@ -95,6 +100,17 @@ static u32 psci_power_state_pack(struct psci_power_state state)
 			<< PSCI_POWER_STATE_AFFL_SHIFT);
 }
 
+static void psci_power_state_unpack(u32 power_state,
+					struct psci_power_state *state)
+{
+	state->id = ((power_state >> PSCI_POWER_STATE_ID_SHIFT)
+						& PSCI_POWER_STATE_ID_MASK);
+	state->type = ((power_state >> PSCI_POWER_STATE_TYPE_SHIFT)
+						& PSCI_POWER_STATE_TYPE_MASK);
+	state->affinity_level = ((power_state >> PSCI_POWER_STATE_AFFL_SHIFT)
+						& PSCI_POWER_STATE_AFFL_MASK);
+}
+
 static int psci_cpu_suspend(struct psci_power_state state,
 			    unsigned long entry_point)
 {
@@ -138,6 +154,63 @@ static int psci_migrate(unsigned long cpuid)
 	return psci_to_linux_errno(err);
 }
 
+static int __maybe_unused cpu_psci_cpu_init_idle(struct device_node *cpu_node,
+						 unsigned int cpu)
+{
+	int i, ret, count = 0;
+	struct psci_power_state *psci_states;
+	struct device_node *state_node;
+
+	/*
+	 * If the PSCI cpu_suspend function hook has not been initialized
+	 * idle states must not be enabled, so bail out
+	 */
+	if (!psci_ops.cpu_suspend)
+		return -EOPNOTSUPP;
+
+	/* Count idle states */
+	while ((state_node = of_parse_phandle(cpu_node, "cpu-idle-states",
+					      count))) {
+		count++;
+		of_node_put(state_node);
+	}
+
+	if (!count)
+		return -ENODEV;
+
+	psci_states = kcalloc(count, sizeof(*psci_states), GFP_KERNEL);
+	if (!psci_states)
+		return -ENOMEM;
+
+	for (i = 0; i < count; i++) {
+		u32 psci_power_state;
+
+		state_node = of_parse_phandle(cpu_node, "cpu-idle-states", i);
+
+		ret = of_property_read_u32(state_node,
+					   "arm,psci-suspend-param",
+					   &psci_power_state);
+		if (ret) {
+			pr_warn(" * %s missing arm,psci-suspend-param property\n",
+				state_node->full_name);
+			of_node_put(state_node);
+			goto free_mem;
+		}
+
+		of_node_put(state_node);
+		pr_debug("psci-power-state %#x index %d\n", psci_power_state,
+							    i);
+		psci_power_state_unpack(psci_power_state, &psci_states[i]);
+	}
+	/* Idle states parsed correctly, initialize per-cpu pointer */
+	per_cpu(psci_power_state, cpu) = psci_states;
+	return 0;
+
+free_mem:
+	kfree(psci_states);
+	return ret;
+}
+
 static const struct of_device_id psci_of_match[] __initconst = {
 	{ .compatible = "arm,psci",	},
 	{},
@@ -250,15 +323,20 @@ static void cpu_psci_cpu_die(unsigned int cpu)
 #endif
 static int psci_suspend_finisher(unsigned long index)
 {
-	/* struct psci_power_state *state =
-	 * __this_cpu_read(psci_power_state); */
-	struct psci_power_state  state = {
+	 struct psci_power_state *state =
+		__this_cpu_read(psci_power_state);
+
+	struct psci_power_state  state_no_idle = {
 		.id = 0,
 		.type = 1,
 		.affinity_level = 0,
 	};
 
-	return psci_ops.cpu_suspend(state,
+	if (!state)
+		return psci_ops.cpu_suspend(state_no_idle,
+				    virt_to_phys(cpu_resume));
+	else
+		return psci_ops.cpu_suspend(state[index - 1],
 				    virt_to_phys(cpu_resume));
 }
 
@@ -284,6 +362,9 @@ static int __maybe_unused cpu_psci_cpu_suspend(unsigned long index)
 
 const struct cpu_operations cpu_psci_ops = {
 	.name		= "psci",
+#ifdef CONFIG_CPU_IDLE
+	.cpu_init_idle	= cpu_psci_cpu_init_idle,
+#endif
 	.cpu_init	= cpu_psci_cpu_init,
 	.cpu_prepare	= cpu_psci_cpu_prepare,
 	.cpu_boot	= cpu_psci_cpu_boot,
diff --git a/arch/arm64/mm/mmap.c b/arch/arm64/mm/mmap.c
index 8ed6cb1..3f05bb8 100644
--- a/arch/arm64/mm/mmap.c
+++ b/arch/arm64/mm/mmap.c
@@ -59,10 +59,16 @@ static unsigned long mmap_rnd(void)
 {
 	unsigned long rnd = 0;
 
-	if (current->flags & PF_RANDOMIZE)
-		rnd = (long)get_random_int() & (STACK_RND_MASK >> 1);
+#ifdef CONFIG_COMPAT
+	if (test_thread_flag(TIF_32BIT))
+		rnd = (unsigned long)get_random_int()
+			&((1 << mmap_rnd_compat_bits) - 1);
+	else
+#endif
+		rnd = (unsigned long)get_random_int()
+			& ((1 << mmap_rnd_bits) - 1);
 
-	return rnd << (PAGE_SHIFT + 1);
+	return rnd << PAGE_SHIFT;
 }
 
 static unsigned long mmap_base(void)
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index 5584d97..e50fc5e 100644
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -47,8 +47,6 @@ source "drivers/amlogic/display/Kconfig"
 
 source "drivers/amlogic/led/Kconfig"
 
-source "drivers/amlogic/ledlight/Kconfig"
-
 source "drivers/amlogic/canvas/Kconfig"
 
 source "drivers/amlogic/clk/Kconfig"
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 18910ee..fd9e0f9 100644
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -60,7 +60,6 @@ obj-$(CONFIG_AML_DISPLAY)	+= display/
 
 obj-$(CONFIG_AMLOGIC_LED)	+= led/
 
-obj-$(CONFIG_AMLOGIC_LEDLIGHT) += ledlight/
 obj-$(CONFIG_AML_CANVAS)	+= canvas/
 
 obj-$(CONFIG_AM_VIDEO)		+= amports/
diff --git a/drivers/amlogic/amaudio/amaudio.c b/drivers/amlogic/amaudio/amaudio.c
index a70a46d..11569ca 100644
--- a/drivers/amlogic/amaudio/amaudio.c
+++ b/drivers/amlogic/amaudio/amaudio.c
@@ -287,9 +287,9 @@ static ssize_t output_enable_show(struct class *class,
 	unsigned iec958_size =
 	    aml_read_cbus(AIU_MEM_IEC958_END_PTR) -
 	    aml_read_cbus(AIU_MEM_IEC958_START_PTR);
-	iec958_size += 64;
+	/* normal spdif buffer MUST NOT less than 512 bytes */
 	return sprintf(buf, "%d\n", (if_audio_out_enable() ||
-			 (if_958_audio_out_enable() && iec958_size > 128)));
+			(if_958_audio_out_enable() && iec958_size > 512)));
 }
 
 
@@ -326,7 +326,7 @@ static ssize_t record_type_show(struct class *class,
 	}
 }
 
-static unsigned int dtsm6_stream_type;
+static int dtsm6_stream_type = -1;
 static unsigned int dtsm6_apre_cnt;
 static unsigned int dtsm6_apre_sel;
 static unsigned int dtsm6_apre_assets_sel;
@@ -369,7 +369,7 @@ static ssize_t store_debug(struct class *class, struct class_attribute *attr,
 		if (kstrtoint(buf + 19, 10, &dtsm6_mulasset_hint))
 			return -EINVAL;
 	} else if (strncmp(buf, "dtsm6_clear_info", 16) == 0) {
-		dtsm6_stream_type = 0;
+		dtsm6_stream_type = -1;
 		dtsm6_apre_cnt = 0;
 		dtsm6_apre_sel = 0;
 		dtsm6_apre_assets_sel = 0;
diff --git a/drivers/amlogic/amaudio2/amaudio2.c b/drivers/amlogic/amaudio2/amaudio2.c
index 62b74c0..950a664 100644
--- a/drivers/amlogic/amaudio2/amaudio2.c
+++ b/drivers/amlogic/amaudio2/amaudio2.c
@@ -314,13 +314,23 @@ static unsigned get_i2s_out_ptr(void)
 void cover_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
-	int i, j;
+	int i;
 	int samp;
 
 	short *des_left = (short *)(des->addr + a);
 	short *des_right = des_left + 16;
 	short *src_buf = (short *)(src->addr + b);
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	for (i = 0; i < count; i += 2) {
+		samp = ((*src_buf++) * direct_left_gain) >> 8;
+		*des_left++ = (short)samp;
+		samp = ((*src_buf++) * direct_right_gain) >> 8;
+		*des_right++ = (short)samp;
+	}
+#else
+	int j;
+
 	for (i = 0; i < count; i += 64) {
 		for (j = 0; j < 16; j++) {
 			samp = ((*src_buf++) * direct_left_gain) >> 8;
@@ -331,18 +341,32 @@ void cover_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 		des_left += 16;
 		des_right += 16;
 	}
+#endif
 }
 
 void direct_mix_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
-	int i, j;
+	int i;
 	int samp;
 
 	short *des_left = (short *)(des->addr + a);
 	short *des_right = des_left + 16;
 	short *src_buf = (short *)(src->addr + b);
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	for (i = 0; i < count; i += 2) {
+		samp = ((*des_left) * music_gain +
+			(*src_buf++) * direct_left_gain) >> 8;
+		*des_left++ = clip16(samp);
+
+		samp = ((*des_right) * music_gain +
+			(*src_buf++) * direct_right_gain) >> 8;
+		*des_right++ = clip16(samp);
+	}
+#else
+	int j;
+
 	for (i = 0; i < count; i += 64) {
 		for (j = 0; j < 16; j++) {
 			samp = ((*des_left) * music_gain +
@@ -356,12 +380,13 @@ void direct_mix_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 		des_left += 16;
 		des_right += 16;
 	}
+#endif
 }
 
 void inter_mix_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
-	int i, j;
+	int i;
 	short sampL, sampR;
 	int samp, sampLR;
 
@@ -369,6 +394,24 @@ void inter_mix_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 	short *des_right = des_left + 16;
 	short *src_buf = (short *)(src->addr + b);
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	for (i = 0; i < count; i += 2) {
+		sampL = *src_buf++;
+		sampR = *src_buf++;
+		/* Here has risk to distortion.
+		* Linein signals are always weak,
+		* so add them direct. */
+		sampLR = (sampL * direct_left_gain +
+		sampR * direct_right_gain) >> 1;
+		samp = ((*des_left) * music_gain + sampLR) >> 8;
+		*des_left++ = clip16(samp);
+
+		samp = ((*des_right) * music_gain + sampLR) >> 8;
+		*des_right++ = clip16(samp);
+	}
+#else
+	int j;
+
 	for (i = 0; i < count; i += 64) {
 		for (j = 0; j < 16; j++) {
 			sampL = *src_buf++;
@@ -387,21 +430,58 @@ void inter_mix_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 		des_left += 16;
 		des_right += 16;
 	}
+#endif
 }
 
 void cover_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
-	int i, j;
-	int32_t *lf = (int32_t *)(des->addr + a);
-	int32_t *cf = lf + 8;
-	int32_t *rf = cf + 8;
-	int32_t *ls = rf + 8;
-	int32_t *rs = ls + 8;
-	int32_t *lef = rs + 8;
-	int32_t *sbl = lef + 8;
-	int32_t *sbr = sbl + 8;
+	int i;
+	int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+	int32_t *to = (int32_t *)(des->addr + a);
 	int32_t *tfrom = (int32_t *)(src->addr + b);
+
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	lf = to;
+	cf = to + 1;
+	rf = to + 2;
+	ls = to + 3;
+	rs = to + 4;
+	lef = to + 5;
+	sbl = to + 6;
+	sbr = to + 7;
+
+	for (i = 0; i < count; i += 32) {
+		*lf++ = (int32_t)(((long)(*tfrom++) * direct_left_gain) >> 8);
+		*cf++ = (int32_t)(((long)(*tfrom++) * direct_right_gain) >> 8);
+		*rf++ = (int32_t)(((long)(*tfrom++) * direct_left_gain) >> 8);
+		*ls++ = (int32_t)(((long)(*tfrom++) * direct_right_gain) >> 8);
+		*rs++ = (int32_t)(((long)(*tfrom++) * direct_left_gain) >> 8);
+		*lef++ = (int32_t)(((long)(*tfrom++) * direct_right_gain) >> 8);
+		*sbl++ = (int32_t)(((long)(*tfrom++) * direct_left_gain) >> 8);
+		*sbr++ = (int32_t)(((long)(*tfrom++) * direct_right_gain) >> 8);
+
+		lf += 7;
+		cf += 7;
+		rf += 7;
+		ls += 7;
+		rs += 7;
+		lef += 7;
+		sbl += 7;
+		sbr += 7;
+	}
+#else
+	int j;
+
+	lf = to;
+	cf = to + 1 * 8;
+	rf = to + 2 * 8;
+	ls = to + 3 * 8;
+	rs = to + 4 * 8;
+	lef = to + 5 * 8;
+	sbl = to + 6 * 8;
+	sbr = to + 7 * 8;
+
 	for (j = 0; j < count; j += 256) {
 		for (i = 0; i < 8; i++) {
 			*lf++ = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
@@ -422,22 +502,75 @@ void cover_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 		sbl += 56;
 		sbr += 56;
 	}
+#endif
 }
 
 void direct_mix_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
-	int i, j;
-	int32_t *lf = (int32_t *)(des->addr + a);
-	int32_t *cf = lf + 8;
-	int32_t *rf = cf + 8;
-	int32_t *ls = rf + 8;
-	int32_t *rs = ls + 8;
-	int32_t *lef = rs + 8;
-	int32_t *sbl = lef + 8;
-	int32_t *sbr = sbl + 8;
+	int i;
+	int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+	int32_t *to = (int32_t *)(des->addr + a);
 	int32_t *tfrom = (int32_t *)(src->addr + b);
 	int32_t samp;
+
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	lf = to;
+	cf = to + 1;
+	rf = to + 2;
+	ls = to + 3;
+	rs = to + 4;
+	lef = to + 5;
+	sbl = to + 6;
+	sbr = to + 7;
+
+	for (i = 0; i < count; i += 32) {
+		samp = *lf;
+		*lf++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_left_gain)) >> 8);
+		samp = *cf;
+		*cf++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_right_gain)) >> 8);
+		samp = *rf;
+		*rf++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_left_gain)) >> 8);
+		samp = *ls;
+		*ls++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_right_gain)) >> 8);
+		samp = *rs;
+		*rs++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_left_gain)) >> 8);
+		samp = *lef;
+		*lef++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_right_gain)) >> 8);
+		samp = *sbl;
+		*sbl++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_left_gain)) >> 8);
+		samp = *sbr;
+		*sbr++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_right_gain)) >> 8);
+
+		lf += 7;
+		cf += 7;
+		rf += 7;
+		ls += 7;
+		rs += 7;
+		lef += 7;
+		sbl += 7;
+		sbr += 7;
+	}
+#else
+	int j;
+
+	lf = to;
+	cf = to + 1 * 8;
+	rf = to + 2 * 8;
+	ls = to + 3 * 8;
+	rs = to + 4 * 8;
+	lef = to + 5 * 8;
+	sbl = to + 6 * 8;
+	sbr = to + 7 * 8;
+
 	for (j = 0; j < count; j += 256) {
 		for (i = 0; i < 8; i++) {
 			samp = *lf;
@@ -474,22 +607,83 @@ void direct_mix_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 		sbl += 56;
 		sbr += 56;
 	}
+#endif
 }
 
 void inter_mix_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
-	int i, j;
-	int32_t *lf = (int32_t *)(des->addr + a);
-	int32_t *cf = lf + 8;
-	int32_t *rf = cf + 8;
-	int32_t *ls = rf + 8;
-	int32_t *rs = ls + 8;
-	int32_t *lef = rs + 8;
-	int32_t *sbl = lef + 8;
-	int32_t *sbr = sbl + 8;
+	int i;
+	int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+	int32_t *to = (int32_t *)(des->addr + a);
 	int32_t *tfrom = (int32_t *)(src->addr + b);
 	int32_t samp, sampLR, sampL, sampR;
+
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	lf = to;
+	cf = to + 1;
+	rf = to + 2;
+	ls = to + 3;
+	rs = to + 4;
+	lef = to + 5;
+	sbl = to + 6;
+	sbr = to + 7;
+
+	for (i = 0; i < count; i += 32) {
+		sampL = (int32_t)((long)((*tfrom++) * direct_left_gain) >> 8);
+		sampR = (int32_t)((long)((*tfrom++) * direct_right_gain) >> 8);
+		sampLR = (sampL + sampR) >> 1;
+
+		samp = *lf;
+		*lf++ = (int32_t)((long)samp * music_gain + sampLR);
+		samp = *cf;
+		*cf++ = (int32_t)((long)samp * music_gain + sampLR);
+
+		sampL = (int32_t)((long)((*tfrom++) * direct_left_gain) >> 8);
+		sampR = (int32_t)((long)((*tfrom++) * direct_right_gain) >> 8);
+		sampLR = (sampL + sampR) >> 1;
+		samp = *rf;
+		*rf++ = (int32_t)((long)samp * music_gain + sampLR);
+		samp = *ls;
+		*ls++ = (int32_t)((long)samp * music_gain + sampLR);
+
+		sampL = (int32_t)((long)((*tfrom++) * direct_left_gain) >> 8);
+		sampR = (int32_t)((long)((*tfrom++) * direct_right_gain) >> 8);
+		sampLR = (sampL + sampR) >> 1;
+		samp = *rs;
+		*rs++ = (int32_t)((long)samp * music_gain + sampLR);
+		samp = *lef;
+		*lef++ = (int32_t)((long)samp * music_gain + sampLR);
+
+		sampL = (int32_t)((long)((*tfrom++) * direct_left_gain) >> 8);
+		sampR = (int32_t)((long)((*tfrom++) * direct_right_gain) >> 8);
+		sampLR = (sampL + sampR) >> 1;
+		samp = *sbl;
+		*sbl++ = (int32_t)((long)samp * music_gain + sampLR);
+		samp = *sbr;
+		*sbr++ = (int32_t)((long)samp * music_gain + sampLR);
+
+		lf += 7;
+		cf += 7;
+		rf += 7;
+		ls += 7;
+		rs += 7;
+		lef += 7;
+		sbl += 7;
+		sbr += 7;
+	}
+#else
+	int j;
+
+	lf = to;
+	cf = to + 1 * 8;
+	rf = to + 2 * 8;
+	ls = to + 3 * 8;
+	rs = to + 4 * 8;
+	lef = to + 5 * 8;
+	sbl = to + 6 * 8;
+	sbr = to + 7 * 8;
+
 	for (j = 0; j < count; j += 256) {
 		for (i = 0; i < 8; i++) {
 			sampL = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
@@ -534,6 +728,7 @@ void inter_mix_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 		sbl += 56;
 		sbr += 56;
 	}
+#endif
 }
 
 static void i2s_copy(struct amaudio_t *amaudio)
diff --git a/drivers/amlogic/amlnf/dev/amlnf_ctrl.c b/drivers/amlogic/amlnf/dev/amlnf_ctrl.c
index f9d8e83..773105f 100644
--- a/drivers/amlogic/amlnf/dev/amlnf_ctrl.c
+++ b/drivers/amlogic/amlnf/dev/amlnf_ctrl.c
@@ -582,11 +582,7 @@ int aml_sys_info_init(struct amlnand_chip *aml_chip)
 	unsigned int buf_size = 0;
 	int ret = 0;
 
-	if (CONFIG_SECURE_SIZE > CONFIG_KEYSIZE)
-		buf_size = CONFIG_SECURE_SIZE;
-	else
-		buf_size = CONFIG_KEYSIZE;
-
+	buf_size = max_t(u32, CONFIG_SECURE_SIZE, CONFIG_KEY_MAX_SIZE);
 	buf = aml_nand_malloc(buf_size);
 	if (!buf)
 		aml_nand_msg("aml_sys_info_init : malloc failed");
@@ -636,7 +632,7 @@ int aml_sys_info_init(struct amlnand_chip *aml_chip)
 			(unsigned char *)(&(aml_chip->nand_key)),
 			buf,
 			KEY_INFO_HEAD_MAGIC,
-			CONFIG_KEYSIZE);
+			aml_chip->keysize);
 		if (ret < 0) {
 			aml_nand_msg("nand save default key failed");
 			goto exit_error;
diff --git a/drivers/amlogic/amlnf/dev/amlnf_dtb.c b/drivers/amlogic/amlnf/dev/amlnf_dtb.c
index 8db673a..392c81f 100644
--- a/drivers/amlogic/amlnf/dev/amlnf_dtb.c
+++ b/drivers/amlogic/amlnf/dev/amlnf_dtb.c
@@ -38,25 +38,26 @@ int amlnf_dtb_save(unsigned char *buf, int len)
 
 	aml_nand_msg("%s", __func__);
 
-	if (len > CONFIG_DTB_SIZE) {
-		aml_nand_msg("%s dtb data len too much", __func__);
-		return -EFAULT;
+	if (len > aml_chip_dtb->dtbsize) {
+		aml_nand_msg("warnning!!! %s dtb data len too much", __func__);
+		len = aml_chip_dtb->dtbsize;
+		/*return -EFAULT;*/
 	}
 
-	dtb_buf = vmalloc(CONFIG_DTB_SIZE + flash->pagesize);
+	dtb_buf = vmalloc(aml_chip_dtb->dtbsize + flash->pagesize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("%s malloc failed", __func__);
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0, aml_chip_dtb->dtbsize);
 	memcpy(dtb_buf, buf, len);
 
 	ret = amlnand_save_info_by_name(aml_chip_dtb,
 		(unsigned char *)&(aml_chip_dtb->amlnf_dtb),
 		dtb_buf,
 		DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: save dtb error", __func__);
 		ret = -EFAULT;
@@ -79,9 +80,10 @@ int amlnf_dtb_read(unsigned char *buf, int len)
 
 	aml_nand_msg("%s", __func__);
 
-	if (len > CONFIG_DTB_SIZE) {
-		aml_nand_msg("%s dtb data len too much", __func__);
-		return -EFAULT;
+	if (len > aml_chip_dtb->dtbsize) {
+		aml_nand_msg("warnning!!! %s dtb data len too much", __func__);
+		len = aml_chip_dtb->dtbsize;
+		/*return -EFAULT;*/
 	}
 
 	if (aml_chip_dtb->amlnf_dtb.arg_valid == 0) {
@@ -90,20 +92,19 @@ int amlnf_dtb_read(unsigned char *buf, int len)
 		return 0;
 	}
 
-	/* dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE); */
-	dtb_buf = vmalloc(CONFIG_DTB_SIZE + flash->pagesize);
+	dtb_buf = vmalloc(aml_chip_dtb->dtbsize + flash->pagesize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("%s malloc failed", __func__);
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0, aml_chip_dtb->dtbsize);
 
 	ret = amlnand_read_info_by_name(aml_chip_dtb,
 		(unsigned char *)&(aml_chip_dtb->amlnf_dtb),
 		(unsigned char *)dtb_buf,
 		DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s read dtb error", __func__);
 		ret = -EFAULT;
@@ -135,20 +136,20 @@ ssize_t dtb_store(struct class *class, struct class_attribute *attr,
 	unsigned char *dtb_ptr = NULL;
 	aml_nand_dbg("%s", __func__);
 
-	dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL);
+	dtb_ptr = kzalloc(aml_chip_dtb->dtbsize, GFP_KERNEL);
 	if (dtb_ptr == NULL) {
 		aml_nand_msg("%s: malloc buf failed", __func__);
 		return -ENOMEM;
 	}
 
-	ret = amlnf_dtb_read(dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_read(dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: read failed", __func__);
 		kfree(dtb_ptr);
 		return -EFAULT;
 	}
 
-	ret = amlnf_dtb_save(dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_save(dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: save failed", __func__);
 		kfree(dtb_ptr);
@@ -176,31 +177,30 @@ ssize_t dtb_read(struct file *file,
 	ssize_t read_size = 0;
 	int ret = 0;
 
-	if (*ppos == CONFIG_DTB_SIZE)
+	if (*ppos == aml_chip_dtb->dtbsize)
 		return 0;
 
-	if (*ppos >= CONFIG_DTB_SIZE) {
+	if (*ppos >= aml_chip_dtb->dtbsize) {
 		aml_nand_msg("%s: out of space!", __func__);
 		return -EFAULT;
 	}
 
-	/* dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL); */
-	dtb_ptr = vmalloc(CONFIG_DTB_SIZE + flash->pagesize);
+	dtb_ptr = vmalloc(aml_chip_dtb->dtbsize + flash->pagesize);
 	if (dtb_ptr == NULL) {
 		aml_nand_msg("%s: malloc buf failed", __func__);
 		return -ENOMEM;
 	}
 
 	amlnand_get_device(aml_chip_dtb, CHIP_READING);
-	ret = amlnf_dtb_read((unsigned char *)dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_read((unsigned char *)dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: read failed:%d", __func__, ret);
 		ret = -EFAULT;
 		goto exit;
 	}
 
-	if ((*ppos + count) > CONFIG_DTB_SIZE)
-		read_size = CONFIG_DTB_SIZE - *ppos;
+	if ((*ppos + count) > aml_chip_dtb->dtbsize)
+		read_size = aml_chip_dtb->dtbsize - *ppos;
 	else
 		read_size = count;
 
@@ -221,37 +221,36 @@ ssize_t dtb_write(struct file *file,
 	struct nand_flash *flash = &aml_chip_dtb->flash;
 	int ret = 0;
 
-	if (*ppos == CONFIG_DTB_SIZE)
+	if (*ppos == aml_chip_dtb->dtbsize)
 		return 0;
 
-	if (*ppos >= CONFIG_DTB_SIZE) {
+	if (*ppos >= aml_chip_dtb->dtbsize) {
 		aml_nand_msg("%s: out of space!", __func__);
 		return -EFAULT;
 	}
 
-	/* dtb_ptr = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL); */
-	dtb_ptr = vmalloc(CONFIG_DTB_SIZE + flash->pagesize);
+	dtb_ptr = vmalloc(aml_chip_dtb->dtbsize + flash->pagesize);
 	if (dtb_ptr == NULL) {
 		aml_nand_msg("%s: malloc buf failed", __func__);
 		return -ENOMEM;
 	}
 	amlnand_get_device(aml_chip_dtb, CHIP_WRITING);
 
-	ret = amlnf_dtb_read((unsigned char *)dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_read((unsigned char *)dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: read failed", __func__);
 		ret = -EFAULT;
 		goto exit;
 	}
 
-	if ((*ppos + count) > CONFIG_DTB_SIZE)
-		write_size = CONFIG_DTB_SIZE - *ppos;
+	if ((*ppos + count) > aml_chip_dtb->dtbsize)
+		write_size = aml_chip_dtb->dtbsize - *ppos;
 	else
 		write_size = count;
 
 	ret = copy_from_user((dtb_ptr + *ppos), buf, write_size);
 
-	ret = amlnf_dtb_save(dtb_ptr, CONFIG_DTB_SIZE);
+	ret = amlnf_dtb_save(dtb_ptr, aml_chip_dtb->dtbsize);
 	if (ret) {
 		aml_nand_msg("%s: read failed", __func__);
 		ret = -EFAULT;
@@ -284,19 +283,19 @@ int amlnf_dtb_init(struct amlnand_chip *aml_chip)
 	unsigned char *dtb_buf = NULL;
 	aml_chip_dtb = aml_chip;
 
-	dtb_buf = aml_nand_malloc(CONFIG_DTB_SIZE);
+	dtb_buf = aml_nand_malloc(aml_chip_dtb->dtbsize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("%s: malloc failed", __func__);
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0x0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0x0, aml_chip_dtb->dtbsize);
 
 	ret = amlnand_info_init(aml_chip,
 		(unsigned char *)&(aml_chip->amlnf_dtb),
 		dtb_buf,
 		DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret < 0) {
 		aml_nand_msg("%s init failed\n", __func__);
 		/*
@@ -305,13 +304,6 @@ int amlnf_dtb_init(struct amlnand_chip *aml_chip)
 		*/
 	}
 
-	/*if(aml_chip->amlnf_dtb.arg_valid == 0){
-		memset(dtb_buf,0x0,CONFIG_DTB_SIZE);
-		ret = amlnf_dtb_save(dtb_buf,CONFIG_DTB_SIZE);
-		if(ret){
-			aml_nand_msg("amlnf_dtb_save: save env failed");
-		}
-	}*/
 	aml_nand_dbg("%s: register dtb chardev", __func__);
 	ret = alloc_chrdev_region(&amlnf_dtb_no, 0, 1, DTB_NAME);
 	if (ret < 0) {
@@ -381,19 +373,19 @@ int amlnf_dtb_reinit(struct amlnand_chip *aml_chip)
 	unsigned char *dtb_buf = NULL;
 	aml_chip_dtb = aml_chip;
 
-	dtb_buf = vmalloc(CONFIG_DTB_SIZE);
+	dtb_buf = vmalloc(aml_chip_dtb->dtbsize);
 	if (dtb_buf == NULL) {
 		aml_nand_msg("%s: malloc failed", __func__);
 		ret = -1;
 		goto exit_err;
 	}
-	memset(dtb_buf, 0x0, CONFIG_DTB_SIZE);
+	memset(dtb_buf, 0x0, aml_chip_dtb->dtbsize);
 	amlnand_get_device(aml_chip, CHIP_READING);
 	ret = amlnand_info_init(aml_chip,
 		(unsigned char *)&(aml_chip->amlnf_dtb),
 		dtb_buf,
 		DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret < 0)
 		aml_nand_msg("%s init failed\n", __func__);
 	amlnand_release_device(aml_chip);
@@ -410,16 +402,16 @@ int aml_nand_update_dtb(struct amlnand_chip *aml_chip, char *dtb_ptr)
 	char *dtb_buf = NULL;
 
 	if (dtb_buf == NULL) {
-		dtb_buf = kzalloc(CONFIG_DTB_SIZE, GFP_KERNEL);
+		dtb_buf = kzalloc(aml_chip_dtb->dtbsize, GFP_KERNEL);
 		malloc_flag = 1;
 		if (dtb_buf == NULL)
 			return -ENOMEM;
-		memset(dtb_buf, 0, CONFIG_DTB_SIZE);
+		memset(dtb_buf, 0, aml_chip_dtb->dtbsize);
 		ret = amlnand_read_info_by_name(aml_chip,
 			(unsigned char *)&(aml_chip->amlnf_dtb),
 			dtb_buf,
 			DTD_INFO_HEAD_MAGIC,
-			CONFIG_DTB_SIZE);
+			aml_chip_dtb->dtbsize);
 		if (ret) {
 			aml_nand_msg("read dtb error,%s\n", __func__);
 			ret = -EFAULT;
@@ -432,7 +424,7 @@ int aml_nand_update_dtb(struct amlnand_chip *aml_chip, char *dtb_ptr)
 		(unsigned char *)&(aml_chip->amlnf_dtb),
 		dtb_buf,
 		DTD_INFO_HEAD_MAGIC,
-		CONFIG_DTB_SIZE);
+		aml_chip_dtb->dtbsize);
 	if (ret < 0)
 		aml_nand_msg("%s: update failed", __func__);
 exit:
diff --git a/drivers/amlogic/amlnf/dev/nandkey.c b/drivers/amlogic/amlnf/dev/nandkey.c
index feb28cf..e71ec39 100644
--- a/drivers/amlogic/amlnf/dev/nandkey.c
+++ b/drivers/amlogic/amlnf/dev/nandkey.c
@@ -44,16 +44,16 @@ int aml_nand_update_key(struct amlnand_chip *aml_chip, char *key_ptr)
 	char *key_buf = NULL;
 
 	if (key_buf == NULL) {
-		key_buf = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+		key_buf = kzalloc(aml_chip->keysize, GFP_KERNEL);
 		malloc_flag = 1;
 		if (key_buf == NULL)
 			return -ENOMEM;
-		memset(key_buf, 0, CONFIG_KEYSIZE);
+		memset(key_buf, 0, aml_chip->keysize);
 		ret = amlnand_read_info_by_name(aml_chip,
 			(unsigned char *)&(aml_chip->nand_key),
 			key_buf,
 			KEY_INFO_HEAD_MAGIC,
-			CONFIG_KEYSIZE);
+			aml_chip->keysize);
 		if (ret) {
 			aml_nand_msg("read key error,%s\n", __func__);
 			ret = -EFAULT;
@@ -74,7 +74,7 @@ int aml_nand_update_key(struct amlnand_chip *aml_chip, char *key_ptr)
 		(unsigned char *)&(aml_chip->nand_key),
 		key_buf,
 		KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (ret < 0)
 		aml_nand_msg("aml_nand_update_key : save key info failed");
 
@@ -100,35 +100,41 @@ static int32_t nand_key_read(struct aml_keybox_provider_s *provider,
 	struct amlnand_chip *aml_chip = provider->priv;
 */
 int32_t nand_key_read(uint8_t *buf,
-		uint32_t len)
+		uint32_t len, uint32_t *actual_lenth)
 {
 	struct nand_menson_key *key_ptr = NULL;
-	int error = 0;
 	struct amlnand_chip *aml_chip = aml_chip_key;
+	u32 keysize = aml_chip->keysize - sizeof(u32);
+	int error = 0;
+
+	*actual_lenth = keysize;
 
-	if (len > CONFIG_KEYSIZE) {
+	if (len > keysize) {
+		/*
+		No return here! keep consistent, should memset zero
+		for the rest.
+		*/
 		aml_nand_msg("key data len too much,%s", __func__);
-		return -EFAULT;
+		memset(buf + keysize, 0 , len - keysize);
 	}
 
-	key_ptr = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+	key_ptr = kzalloc(aml_chip->keysize, GFP_KERNEL);
 	if (key_ptr == NULL)
 		return -ENOMEM;
 
 	amlnand_get_device(aml_chip, CHIP_READING);
-	memset(key_ptr, 0, CONFIG_KEYSIZE);
 	error = amlnand_read_info_by_name(aml_chip,
 		(unsigned char *)&(aml_chip->nand_key),
 		(unsigned char *)key_ptr,
 		KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (error) {
 		aml_nand_msg("read key error,%s", __func__);
 		error = -EFAULT;
 		goto exit;
 	}
 
-	memcpy(buf, key_ptr->data, len);
+	memcpy(buf, key_ptr->data, keysize);
 exit:
 	amlnand_release_device(aml_chip);
 	kfree(key_ptr);
@@ -145,30 +151,34 @@ static int32_t nand_key_write(struct aml_keybox_provider_s *provider,
 */
 
 int32_t nand_key_write(uint8_t *buf,
-		uint32_t len)
+		uint32_t len, uint32_t *actual_lenth)
 {
 	struct nand_menson_key *key_ptr = NULL;
-	int error = 0;
 	struct amlnand_chip *aml_chip = aml_chip_key;
+	u32 keysize = aml_chip->keysize - sizeof(u32);
+	int error = 0;
 
-	if (len > CONFIG_KEYSIZE) {
+	if (len > keysize) {
+		/*
+		No return here! keep consistent, should memset zero
+		for the rest.
+		*/
 		aml_nand_msg("key data len too much,%s", __func__);
-		return -EFAULT;
+		memset(buf + keysize, 0 , len - keysize);
 	}
 
-	key_ptr = kzalloc(CONFIG_KEYSIZE, GFP_KERNEL);
+	key_ptr = kzalloc(aml_chip->keysize, GFP_KERNEL);
 	if (key_ptr == NULL)
 		return -ENOMEM;
 
-	memset(key_ptr, 0, CONFIG_KEYSIZE);
-	memcpy(key_ptr->data + 0, buf, len);
+	memcpy(key_ptr->data + 0, buf, keysize);
 	amlnand_get_device(aml_chip, CHIP_WRITING);
 
 	error = amlnand_save_info_by_name(aml_chip,
 		(unsigned char *) &(aml_chip->nand_key),
 		(unsigned char *)key_ptr,
 		KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (error) {
 		aml_nand_msg("save key error,%s", __func__);
 		error = -EFAULT;
@@ -196,20 +206,20 @@ int aml_key_init(struct amlnand_chip *aml_chip)
 /*
 	struct aml_keybox_provider_s *provider;
 */
-	key_ptr = aml_nand_malloc(CONFIG_KEYSIZE);
+	key_ptr = aml_nand_malloc(aml_chip->keysize);
 	if (key_ptr == NULL) {
 		aml_nand_msg("nand malloc for key_ptr failed");
 		ret = -1;
 		goto exit_error0;
 	}
-	memset(key_ptr, 0x0, CONFIG_KEYSIZE);
+	memset(key_ptr, 0x0, aml_chip->keysize);
 	aml_nand_dbg("nand key: nand_key_probe. ");
 
 	ret = amlnand_info_init(aml_chip,
 		(unsigned char *)&(aml_chip->nand_key),
 		(unsigned char *)key_ptr,
 		KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (ret < 0)
 		aml_nand_msg("invalid nand key\n");
 
@@ -243,13 +253,13 @@ int aml_key_reinit(struct amlnand_chip *aml_chip)
 	int ret = 0;
 	struct nand_menson_key *key_ptr = NULL;
 
-	key_ptr = vmalloc(CONFIG_KEYSIZE);
+	key_ptr = vmalloc(aml_chip->keysize);
 	if (key_ptr == NULL) {
 		aml_nand_msg("nand malloc for key_ptr failed");
 		ret = -1;
 		goto exit_error0;
 	}
-	memset(key_ptr, 0x0, CONFIG_KEYSIZE);
+	memset(key_ptr, 0x0, aml_chip->keysize);
 	aml_nand_dbg("nand key: nand_key_probe. ");
 
 	amlnand_get_device(aml_chip, CHIP_READING);
@@ -257,7 +267,7 @@ int aml_key_reinit(struct amlnand_chip *aml_chip)
 		(unsigned char *)&(aml_chip->nand_key),
 		(unsigned char *)key_ptr,
 		KEY_INFO_HEAD_MAGIC,
-		CONFIG_KEYSIZE);
+		aml_chip->keysize);
 	if (ret < 0)
 		aml_nand_msg("invalid nand key\n");
 	amlnand_release_device(aml_chip);
diff --git a/drivers/amlogic/amlnf/include/phynand.h b/drivers/amlogic/amlnf/include/phynand.h
index 24cedf0..fea079c 100644
--- a/drivers/amlogic/amlnf/include/phynand.h
+++ b/drivers/amlogic/amlnf/include/phynand.h
@@ -151,14 +151,10 @@ union nand_core_clk_t {
 
 #define	FBBT_COPY_NUM	1
 
-#define CONFIG_KEYSIZE		(256*1024)
-#define KEYSIZE	(CONFIG_KEYSIZE - (sizeof(uint)))
-
 #define CONFIG_SECURE_SIZE	(0x10000*2) /* 128k */
 #define SECURE_SIZE (CONFIG_SECURE_SIZE - 2*(sizeof(uint)))
-/* fixme, max dtd size is 256KBytes. */
-#define CONFIG_DTB_SIZE  (256*1024U)
-#define DTB_SIZE (CONFIG_DTB_SIZE - (sizeof(uint)))
+
+#define CONFIG_KEY_MAX_SIZE	0x40000
 
 #define FULL_BLK	0
 #define FULL_PAGE	1
@@ -772,7 +768,7 @@ struct shipped_bbt {
 
 struct nand_menson_key {
 	uint crc;
-	unsigned char data[KEYSIZE];
+	unsigned char data[252];
 };
 
 struct secure_t {
@@ -857,6 +853,9 @@ struct amlnand_chip {
 
 	void __iomem *reg_base;
 	void __iomem *nand_clk_reg;
+
+	u32 keysize;
+	u32 dtbsize;
 };
 
 extern struct nand_flash flash_ids_slc[];
diff --git a/drivers/amlogic/amlnf/phy/chipenv.c b/drivers/amlogic/amlnf/phy/chipenv.c
index 9ad2fa7..6cd3ad0 100644
--- a/drivers/amlogic/amlnf/phy/chipenv.c
+++ b/drivers/amlogic/amlnf/phy/chipenv.c
@@ -1475,7 +1475,8 @@ get_free_blk:
 			}
 		}
 
-		if (arg_info->arg_type == FULL_PAGE) {
+		if ((arg_info->arg_type == FULL_PAGE)
+			&& (flash->blocksize > CONFIG_KEY_MAX_SIZE)) {
 			if (write_page_cnt == 0) {
 				arg_info->arg_valid = 1;
 				full_page_flag = 0;
@@ -2630,6 +2631,14 @@ void amlnand_set_config_attribute(struct amlnand_chip *aml_chip)
 int amlnand_get_dev_configs(struct amlnand_chip *aml_chip)
 {
 	int  ret = 0, i;
+	unsigned int use_min_size;
+	struct nand_flash *flash = &aml_chip->flash;
+
+	use_min_size = min_t(u32, CONFIG_KEY_MAX_SIZE, flash->blocksize);
+	aml_chip->keysize = use_min_size;
+	aml_chip->dtbsize = use_min_size;
+
+	aml_nand_dbg("key size is : 0x%0x", use_min_size);
 
 	ret = amlnand_config_buf_malloc(aml_chip);
 	if (ret < 0) {
diff --git a/drivers/amlogic/amlnf/phy/hw_controller.c b/drivers/amlogic/amlnf/phy/hw_controller.c
index feeefcf..a055c52 100644
--- a/drivers/amlogic/amlnf/phy/hw_controller.c
+++ b/drivers/amlogic/amlnf/phy/hw_controller.c
@@ -621,21 +621,6 @@ static int controller_adjust_timing(struct hw_controller *controller)
 
 	NFC_SET_CFG(controller , 0);
 	NFC_SET_TIMING_ASYC(controller, bus_timing, (bus_cycle - 1));
-
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)	{
-#if (AML_CFG_NEWOOB_EN) /* !!!we need modify later. */
-		if (flash->pagesize > 4096) {
-			aml_nand_msg("AML_NAND_NEW_OOB : new oob");
-			NFC_SET_OOB_MODE(controller, 3<<26);
-			controller->oob_mod = 1;
-		} else
-			controller->oob_mod = 0;
-#else
-		controller->oob_mod = 0;
-#endif
-	} else
-		controller->oob_mod = 0;
-
 	NFC_SEND_CMD(controller, 1<<31);
 	aml_nand_msg("bus_c=%d,bus_t=%d,sys=%d.%dns,T_REA=%d,T_RHOH=%d",
 		bus_cycle,
@@ -657,8 +642,8 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	struct nand_flash *flash = &(aml_chip->flash);
 	struct bch_desc *ecc_supports = controller->bch_desc;
 	unsigned int max_bch_mode = controller->max_bch;
-	unsigned int options_support = 0, ecc_bytes, i;
-	unsigned char bch_index;
+	unsigned int options_support = 0, ecc_bytes, ecc_page_cnt = 0, i;
+	unsigned char bch_index = 0;
 	unsigned short tmp_value;
 
 	if (controller->option & NAND_ECC_SOFT_MODE) {
@@ -669,8 +654,8 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	}
 
 	for (i = (max_bch_mode-1); i > 0; i--) {
-		ecc_bytes =
-		flash->oobsize/(flash->pagesize/ecc_supports[i].unit_size);
+		ecc_page_cnt = flash->pagesize/ecc_supports[i].unit_size;
+		ecc_bytes = flash->oobsize / ecc_page_cnt;
 		if (ecc_bytes >= ecc_supports[i].bytes +
 			ecc_supports[i].usr_mode) {
 			options_support = ecc_supports[i].mode;
@@ -679,12 +664,38 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 		}
 	}
 
+	controller->oob_mod = 0;
+#if (AML_CFG_NEWOOB_EN)
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
+		if (flash->oobsize >= (16+ecc_supports[i].bytes*ecc_page_cnt)) {
+			/* for backward compatbility 4k page mlc. The code
+			we released before like below, which means old oob
+			mode will be used when page size < 4k.
+			------------------------------------
+			if(flash->pagesize > 4096){
+				aml_nand_msg("AML_NAND_NEW_OOB : new oob");
+				NFC_SET_OOB_MODE(3<<26);
+				controller->oob_mod = 1;
+			}else{
+				controller->oob_mod = 0;
+			}
+			------------------------------------*/
+			if ((flash->pagesize == 4096)
+				&& (flash->chipsize > 2048))
+				controller->oob_mod = 0;
+			else {
+				aml_nand_msg("new oob mode");
+				NFC_SET_OOB_MODE(controller, 3<<26);
+				controller->oob_mod = 1;
+			}
+		}
+	}
+#endif
+
 	switch (options_support) {
 	case NAND_ECC_BCH8_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_SIZE;
 		controller->ecc_bytes = NAND_BCH8_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 6;
 		controller->ecc_max = 8;
 		break;
@@ -692,8 +703,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH8_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH8_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 6;
 		controller->ecc_max = 8;
 		break;
@@ -701,8 +710,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH16_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH16_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 14;
 		controller->ecc_max = 16;
 		break;
@@ -710,8 +717,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH24_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH24_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 22;
 		controller->ecc_max = 24;
 		break;
@@ -719,8 +724,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH30_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH30_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 26;
 		controller->ecc_max = 30;
 		break;
@@ -728,8 +731,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH40_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH40_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 34;
 		controller->ecc_max = 40;
 		break;
@@ -737,8 +738,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH50_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH50_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 45;
 		controller->ecc_max = 50;
 		break;
@@ -746,8 +745,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_BCH60_1K_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_1KSIZE;
 		controller->ecc_bytes = NAND_BCH60_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 55;
 		controller->ecc_max = 60;
 		break;
@@ -755,8 +752,6 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 	case NAND_ECC_SHORT_MODE:
 		controller->ecc_unit = NAND_ECC_UNIT_SHORT;
 		controller->ecc_bytes = NAND_BCH60_1K_ECC_SIZE;
-		controller->bch_mode = bch_index;
-		controller->user_mode = 2;
 		controller->ecc_cnt_limit = 55;
 		controller->ecc_max = 60;
 		break;
@@ -767,6 +762,13 @@ static int controller_ecc_confirm(struct hw_controller *controller)
 		break;
 	}
 
+	controller->bch_mode = bch_index;
+	if (controller->oob_mod)
+		controller->user_mode =
+			16 / (flash->pagesize / controller->ecc_unit);
+	else
+		controller->user_mode = 2;
+
 	tmp_value = controller->ecc_unit + controller->ecc_bytes +
 		controller->user_mode;
 	controller->ecc_steps = (flash->pagesize+flash->oobsize)/tmp_value;
@@ -855,11 +857,9 @@ static void controller_get_user_byte(struct hw_controller *controller,
 	while (byte_num > 0) {
 		*oob_buf++ = (controller->user_buf[read_times*len] & 0xff);
 		byte_num--;
-		if (controller->user_mode == 2) {
-			*oob_buf++ =
-			((controller->user_buf[read_times*len] >> 8) & 0xff);
-			byte_num--;
-		}
+		*oob_buf++ =
+		((controller->user_buf[read_times*len] >> 8) & 0xff);
+		byte_num--;
 		read_times++;
 	}
 }
@@ -881,11 +881,9 @@ static void controller_set_user_byte(struct hw_controller *controller,
 	while (byte_num > 0) {
 		controller->user_buf[write_times*len] = *oob_buf++;
 		byte_num--;
-		if (controller->user_mode == 2) {
-			controller->user_buf[write_times*len] |=
-				(*oob_buf++ << 8);
-			byte_num--;
-		}
+		controller->user_buf[write_times*len] |=
+			(*oob_buf++ << 8);
+		byte_num--;
 		write_times++;
 	}
 }
diff --git a/drivers/amlogic/amlnf/phy/id_table.c b/drivers/amlogic/amlnf/phy/id_table.c
index e7df64e..bebc782 100644
--- a/drivers/amlogic/amlnf/phy/id_table.c
+++ b/drivers/amlogic/amlnf/phy/id_table.c
@@ -20,26 +20,35 @@
 
 #ifdef AML_SLC_NAND_SUPPORT
 struct nand_flash flash_ids_slc[] = {
-	/***for SLC nand***/
-	{"NAND 128MiB 3,3V 8-bit", {0, 0x79}, 512, 128, 0x4000, 0, 0, 0},
-
-	{"NAND 256MiB 3,3V 8-bit", {0, 0x71}, 512, 256, 0x4000, 0, 0, 0},
-	/*512 Megabit */
-	{"NAND 64MiB 3,3V 8-bit", {0, 0xF2}, 0,  64, 0, 0, 0, 0},
-	/* 1 Gigabit */
-	{"NAND 128MiB 3,3V 8-bit", {0, 0xF1}, 0, 128, 0, 0, 0, 0},
-	/* 2 Gigabit */
-	{"NAND 256MiB 3,3V 8-bit", {0, 0xDA}, 0, 256, 0, 0, 0, 0},
-	/* 4 Gigabit */
-	{"NAND 512MiB 3,3V 8-bit", {0, 0xDC}, 0, 512, 0, 0, 0, 0},
-	/* 8 Gigabit */
-	{"NAND 1GiB 3,3V 8-bit", {0, 0xD3}, 0, 1024, 0, 0, 0, 0},
 	{NULL,}
 };
 #endif
 
 #ifdef AML_MLC_NAND_SUPPORT
 struct nand_flash flash_ids_mlc[] = {
+/***for SLC nand***/
+	{"TOSHIBA 128MB SLC TC58BVG0S3HBAI6",
+		{NAND_MFR_TOSHIBA, 0xF1, 0x80, 0x15, 0xF2},
+		2048,
+		128,
+		0x20000,
+		64,
+		1,
+		20,
+		25,
+		0,
+		0},
+	{"TOSHIBA 256MB SLC TC58BVG0S3HBAI6",
+		{NAND_MFR_TOSHIBA, 0xDA, 0x90, 0x15, 0xF6},
+		2048,
+		256,
+		0x20000,
+		64,
+		1,
+		20,
+		25,
+		0,
+		0},
 /***for MLC nand***/
 	{"A revision NAND 2GiB H27UAG8T2A",
 		{NAND_MFR_HYNIX, 0xd5, 0x94, 0x25, 0x44, 0x41},
diff --git a/drivers/amlogic/amports/amstream.c b/drivers/amlogic/amports/amstream.c
index 72090b9..985549c 100644
--- a/drivers/amlogic/amports/amstream.c
+++ b/drivers/amlogic/amports/amstream.c
@@ -1078,7 +1078,6 @@ static ssize_t amstream_sub_write(struct file *file, const char *buf,
 		if (r < 0)
 			return r;
 	}
-	pr_err("amstream_sub_write\n");
 	r = esparser_write(file, pbuf, buf, count);
 	if (r < 0)
 		return r;
diff --git a/drivers/amlogic/amports/arch/chips.c b/drivers/amlogic/amports/arch/chips.c
index 5e76319..14a66c4 100644
--- a/drivers/amlogic/amports/arch/chips.c
+++ b/drivers/amlogic/amports/arch/chips.c
@@ -45,7 +45,7 @@
 #define MESON_CPU_MAJOR_ID_GXTVBB		0x20
 #define MESON_CPU_MAJOR_ID_GXL		0x21
 #define MESON_CPU_MAJOR_ID_GXM		0x22
-
+#define MESON_CPU_MAJOR_ID_TXL		0x23
 */
 struct type_name {
 
@@ -66,6 +66,7 @@ static const struct type_name cpu_type_name[] = {
 	{MESON_CPU_MAJOR_ID_GXTVBB, "gxtvbb"},
 	{MESON_CPU_MAJOR_ID_GXL, "gxl"},
 	{MESON_CPU_MAJOR_ID_GXM, "gxm"},
+	{MESON_CPU_MAJOR_ID_TXL, "txl"},
 	{0, NULL},
 };
 
diff --git a/drivers/amlogic/amports/arch/clkgx.c b/drivers/amlogic/amports/arch/clkgx.c
index 0990635..d88cd1f 100644
--- a/drivers/amlogic/amports/arch/clkgx.c
+++ b/drivers/amlogic/amports/arch/clkgx.c
@@ -315,8 +315,8 @@ static  struct clk_set_setting clks_for_formats[] = {
 			{0, 0}, {0, 0}, {0, 0},}
 	},
 	{/*VFORMAT_HEVC*/
-		{{1280*720*30, 100}, {1920*1080*30, 100}, {1920*1080*60, 166},
-		{4096*2048*30, 333}, {4096*2048*60, 630}, {INT_MAX, 630},}
+		{{1280*720*30, 100}, {1920*1080*60, 600}, {4096*2048*25, 630},
+		{4096*2048*30, 630}, {4096*2048*60, 630}, {INT_MAX, 630},}
 	},
 	{/*VFORMAT_H264_ENC*/
 		{{1280*720*30, 0}, {INT_MAX, 0},
@@ -342,14 +342,12 @@ static int vdec_clock_init(void)
 {
 	gp_pll_user_vdec = gp_pll_user_register("vdec", 0,
 		gp_pll_user_cb_vdec);
-	if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXL
-		|| get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
 		is_gp0_div2 = false;
 	else
 		is_gp0_div2 = true;
 
-	if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXL
-		|| get_cpu_type() == MESON_CPU_MAJOR_ID_GXM) {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
 		pr_info("used fix clk for vdec clk source!\n");
 		update_vdec_clk_config_settings(1);
 	}
@@ -399,8 +397,6 @@ static int vdec_clock_set(int clk)
 		else
 			clk = clock_real_clk[VDEC_1];
 	}
-	if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXL && clk >= 500)
-		clk = 667;
 	vdec_get_clk_source(clk, &source, &div, &rclk);
 	update_clk_with_clk_configs(clk, &source, &div, &rclk);
 
@@ -606,6 +602,7 @@ static int vdec_clock_get(enum vdec_type_e core)
 	MESON_CPU_MAJOR_ID_GXTVBB,\
 	MESON_CPU_MAJOR_ID_GXL,\
 	MESON_CPU_MAJOR_ID_GXM,\
+	MESON_CPU_MAJOR_ID_TXL,\
 	0}
 #include "clk.h"
 ARCH_VDEC_CLK_INIT();
diff --git a/drivers/amlogic/amports/arch/register_ops_m8.c b/drivers/amlogic/amports/arch/register_ops_m8.c
index a258323..e37cb0d 100644
--- a/drivers/amlogic/amports/arch/register_ops_m8.c
+++ b/drivers/amlogic/amports/arch/register_ops_m8.c
@@ -26,12 +26,14 @@
 	MESON_CPU_MAJOR_ID_GXTVBB, \
 	MESON_CPU_MAJOR_ID_GXL, \
 	MESON_CPU_MAJOR_ID_GXM, \
+	MESON_CPU_MAJOR_ID_TXL, \
 			0}
 #define REGISTER_FOR_GXCPU {\
 	MESON_CPU_MAJOR_ID_GXBB, \
 	MESON_CPU_MAJOR_ID_GXTVBB, \
 	MESON_CPU_MAJOR_ID_GXL, \
 	MESON_CPU_MAJOR_ID_GXM, \
+	MESON_CPU_MAJOR_ID_TXL, \
 			0}
 int codec_apb_read(unsigned int reg)
 {
diff --git a/drivers/amlogic/amports/arch/regs/di_regs.h b/drivers/amlogic/amports/arch/regs/di_regs.h
index e8ba7ff..c3e95bc 100644
--- a/drivers/amlogic/amports/arch/regs/di_regs.h
+++ b/drivers/amlogic/amports/arch/regs/di_regs.h
@@ -277,7 +277,7 @@
 
 #define VD1_IF0_GEN_REG3 0x1aa7
 #define DI_IF1_GEN_REG3  0x20a7
-
+#define DI_IF2_GEN_REG3  0x2022
 #endif
 
 
diff --git a/drivers/amlogic/amports/arch/regs/dos_regs.h b/drivers/amlogic/amports/arch/regs/dos_regs.h
index dca95e7..21f395b 100644
--- a/drivers/amlogic/amports/arch/regs/dos_regs.h
+++ b/drivers/amlogic/amports/arch/regs/dos_regs.h
@@ -38,8 +38,23 @@
 #define MC_OM_MB_XY 0x090f
 #define PSCALE_RST 0x0910
 #define PSCALE_CTRL 0x0911
+#define PSCALE_PICI_W 0x912
+#define PSCALE_PICI_H 0x913
+#define PSCALE_PICO_W 0x914
+#define PSCALE_PICO_H 0x915
 #define PSCALE_BMEM_ADDR 0x091f
 #define PSCALE_BMEM_DAT 0x0920
+
+#define PSCALE_RBUF_START_BLKX 0x925
+#define PSCALE_RBUF_START_BLKY 0x926
+#define PSCALE_PICO_SHIFT_XY 0x928
+#define PSCALE_CTRL1 0x929
+#define PSCALE_SRCKEY_CTRL0 0x92a
+#define PSCALE_SRCKEY_CTRL1 0x92b
+#define PSCALE_CANVAS_RD_ADDR 0x92c
+#define PSCALE_CANVAS_WR_ADDR 0x92d
+
+
 /**/
 #define MC_MPORT_CTRL 0x0940
 #define MC_MPORT_DAT 0x0941
diff --git a/drivers/amlogic/amports/arch/regs/hcodec_regs.h b/drivers/amlogic/amports/arch/regs/hcodec_regs.h
index a40d73e..6fd0853 100644
--- a/drivers/amlogic/amports/arch/regs/hcodec_regs.h
+++ b/drivers/amlogic/amports/arch/regs/hcodec_regs.h
@@ -702,5 +702,11 @@
 /* add from GXL */
 #define HCODEC_V4_FORCE_SKIP_CFG 0x1f7b
 
+/* add from TXL */
+#define HCODEC_V5_MB_DIFF_SUM 0x1f7c
+#define HCODEC_V5_SMALL_DIFF_CNT 0x1f7d
+#define HCODEC_V5_SIMPLE_MB_CTL 0x1f7e
+#define HCODEC_V5_SIMPLE_MB_DQUANT 0x1f7f
+#define HCODEC_V5_SIMPLE_MB_ME_WEIGHT 0x1f80
 #endif
 
diff --git a/drivers/amlogic/amports/arch/ucode/avs/txl_avs_linux.h b/drivers/amlogic/amports/arch/ucode/avs/txl_avs_linux.h
new file mode 100644
index 0000000..3a12097
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/avs/txl_avs_linux.h
@@ -0,0 +1,540 @@
+/*
+ * drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+static const u32 MicroCode[] __initconst = {
+	0x6807801, 0x6800000, 0xd000001, 0x7400040, 0xc014780,
+	0x0000000, 0x0000000, 0x0000000, 0x80c0002, 0x6932000,
+	0x9800580, 0x60c1e00, 0x6bfdac0, 0x7c017c0, 0x6030400,
+	0x0400000, 0xc0159c0, 0x0000000, 0x0000000, 0x0000000,
+	0x0000000, 0xc7ffec0, 0x0000000, 0x0000000, 0x0000000,
+	0x0000000, 0x0000000, 0x0000000, 0x0000000, 0x0000000,
+	0x0000000, 0x0000000, 0xcc00000, 0x0400000, 0xcc00000,
+	0x0400000, 0xc780540, 0x64c0007, 0xc796240, 0x0000000,
+	0xc796c40, 0x0000000, 0xcc00000, 0x0400000, 0xcc00000,
+	0x0400000, 0xc796ac0, 0x0000000, 0xcc00000, 0x0400000,
+	0x6800009, 0x7c01fc9, 0x7c00409, 0x0800000, 0x78017c9,
+	0xc7ffe40, 0x6030409, 0x6bfd9c9, 0x6030409, 0x0400000,
+	0xa2d8047, 0x7801509, 0xaa14009, 0xa608049, 0xc78f800,
+	0xa608089, 0xc78ecc0, 0xa23c807, 0xc786200, 0x0000000,
+	0x649d008, 0xaa0c008, 0x809c701, 0xc780000, 0xc01a540,
+	0x80c0a00, 0xc01a880, 0x0000000, 0xc01bb40, 0x0000000,
+	0xc792fc0, 0x0000000, 0xbecd007, 0x78043c8, 0xaa0c008,
+	0xa208207, 0xc792e40, 0x78003c7, 0xa6fc007, 0x78043c7,
+	0xa63c007, 0x64c2907, 0xbe2c407, 0x7800007, 0xa62c007,
+	0x0000000, 0x64c2907, 0x91c11c7, 0xa61c047, 0x0000000,
+	0x64c0607, 0x900f1c7, 0xae0c047, 0xc792a00, 0x0000000,
+	0xcb8002c, 0x0000000, 0x68fdfca, 0x64e0408, 0x2808288,
+	0x2c08748, 0x60e0408, 0x60c071e, 0x64c0324, 0x64c0325,
+	0x64c2728, 0x9210268, 0x7800007, 0xa618007, 0x7801c08,
+	0x6c00008, 0x60c0208, 0x80c0200, 0x6bfffc9, 0x60c0320,
+	0x60c0321, 0x7801c48, 0x9610209, 0x60c2708, 0x7801847,
+	0xa6fc007, 0x7800147, 0x7c01b87, 0x6800347, 0x7c00147,
+	0x60c2507, 0x80c2602, 0x80c260f, 0x80c2603, 0x4c001c7,
+	0x9807207, 0x60c2107, 0x7801907, 0xaa14007, 0x6a01008,
+	0xaa0c047, 0x6a22008, 0x6a40008, 0x6c00108, 0x60e0508,
+	0x7801b08, 0x6801809, 0x9502248, 0x60c2109, 0x80c260e,
+	0x6800088, 0x7c01947, 0xba0c087, 0x40011c7, 0x6800007,
+	0x7c01907, 0x7800007, 0x7c01b47, 0x7801b87, 0x7c01bc7,
+	0x7c01848, 0x8030580, 0x7801d47, 0xaa1472f, 0x40011c7,
+	0x78016c8, 0xa20c048, 0x0000000, 0x7c01d47, 0x683ffc8,
+	0x64c2307, 0x93041c7, 0xaa0c008, 0xa6f4007, 0x4401208,
+	0x7801c8d, 0xba13fcd, 0x6800008, 0xc781100, 0x7c01c88,
+	0x6808008, 0xba1070d, 0x400024d, 0x441c249, 0x680c008,
+	0x5403289, 0x200a24a, 0x2008288, 0x7400228, 0x4001208,
+	0x92102e4, 0x740020b, 0x4001208, 0x7400224, 0x4001208,
+	0x7400225, 0x4001208, 0x92102e5, 0x740020b, 0x4001208,
+	0x7400226, 0x4001208, 0x92102e6, 0x740020b, 0x4001208,
+	0x7400227, 0x4001208, 0x92102e7, 0x740020b, 0x7800988,
+	0xac07bc8, 0x780000a, 0xaa3872f, 0x40002ca, 0x78016ca,
+	0xc7802c0, 0x942f28b, 0xa61000a, 0xaa1472f, 0x78016ca,
+	0xa20c04a, 0xa6146c9, 0x400128d, 0xb60c70d, 0x680000a,
+	0x680070a, 0x7c01c8a, 0xb013bc8, 0xaa0800a, 0xa64470a,
+	0x7801cca, 0xa20c04a, 0x6a0800b, 0x6a0c00b, 0x6b80009,
+	0x7801d0c, 0x540928c, 0x200a24a, 0x6c0748a, 0x200ac0a,
+	0x603510a, 0x6803f0a, 0x603520a, 0x603500b, 0xc01b5c0,
+	0x0000000, 0x7800007, 0x40011c7, 0x7c00007, 0x9c1d39d,
+	0x7800988, 0xb405207, 0x40011c7, 0xb833207, 0xc780c80,
+	0x981d1dd, 0x6800007, 0x7c00007, 0x981d39d, 0x9c1d3dd,
+	0x9c1d1dd, 0x78016c8, 0x4001208, 0x7801dc9, 0xb828248,
+	0x7c016c8, 0x7801847, 0xa6fc007, 0x0000000, 0x6430507,
+	0xa2f0107, 0x6a00007, 0x60c3d07, 0x7800147, 0xaa24007,
+	0x6803fcb, 0x7801a88, 0x64e0c09, 0x9010249, 0xb804248,
+	0xaa0c00b, 0xc7ffec0, 0x44012cb, 0x7804147, 0xaa280c7,
+	0x7800347, 0x7801dc8, 0xb407207, 0xc01c7c0, 0x7c00348,
+	0x6800048, 0x7c00308, 0xc789740, 0x7c00388, 0x6800008,
+	0x7c00308, 0x7c00388, 0xc78f840, 0x64c0007, 0xb60c709,
+	0x6808008, 0x680c008, 0xc780400, 0x6800007, 0x7800007,
+	0x9508787, 0x78016c9, 0x9408789, 0x7800989, 0xb009bc9,
+	0x6808008, 0xaad0007, 0x7801c89, 0x40011c9, 0xba10707,
+	0xb6c0e07, 0x680c008, 0x441c1c7, 0x5403247, 0x20091c9,
+	0x2008248, 0x7000209, 0x7c01c49, 0x4001208, 0x7000209,
+	0x4001208, 0x7000220, 0x9610809, 0x4001208, 0x7000221,
+	0x4001208, 0x7000209, 0x9610849, 0x4001208, 0x7000222,
+	0x4001208, 0x7000209, 0x9610889, 0x4001208, 0x7000223,
+	0x4001208, 0x7000209, 0x96108c9, 0xc7fb580, 0x0000000,
+	0x68fdfca, 0x64e0408, 0x2808288, 0x2c08748, 0x60e0408,
+	0x60c071e, 0x64c0324, 0x64c0325, 0x64c0326, 0x64c0327,
+	0x64c2728, 0x60c071e, 0x9210268, 0x7800007, 0xa638007,
+	0x7801c08, 0x6c00008, 0x60c0208, 0x6800008, 0x6c00008,
+	0x60c0208, 0x6800008, 0x6c00008, 0x60c0208, 0x6800008,
+	0x6c00008, 0x60c0208, 0x6bfffc9, 0x60c0320, 0x60c0321,
+	0x60c0322, 0x60c0323, 0x7801c48, 0x9610209, 0x60c2708,
+	0x7804287, 0x54031c7, 0x4c301c7, 0x7801f8a, 0x95011ca,
+	0x60c2507, 0x780184a, 0xa6fc00a, 0x7800147, 0x7c01b87,
+	0x64c2307, 0x9304207, 0xa6f8008, 0x90a1207, 0x90241c7,
+	0x95211c8, 0x64c0609, 0x9010249, 0xaa10009, 0x0000000,
+	0x6800007, 0x6800008, 0x7c00147, 0xaa60347, 0x60c2507,
+	0xaa60287, 0xaa18048, 0xa60c007, 0xc780200, 0x0000000,
+	0x80c2605, 0x80c2606, 0x80c2607, 0x80c2602, 0x80c260f,
+	0x80c2603, 0x7801ac8, 0xaa100c8, 0x6800089, 0xc7fb8c0,
+	0x7c01ac9, 0x780184b, 0xa6fc00b, 0x0000000, 0x7c01b08,
+	0xc7fb740, 0x7c01ac9, 0x80c2602, 0x80c260f, 0x80c2603,
+	0x7801ac8, 0xaa48088, 0x68000c9, 0x7800008, 0xaa0c008,
+	0xc7fb4c0, 0x7c01ac9, 0x6803fcb, 0x7801a88, 0x64e0c09,
+	0x9010249, 0xb804248, 0xaa0c00b, 0xc7ffec0, 0x44012cb,
+	0x6800088, 0x68000c9, 0x680180b, 0x60c210b, 0x780184b,
+	0xa6fc00b, 0x0000000, 0x7c01b08, 0xc7fb040, 0x7c01ac9,
+	0xa279007, 0x0000000, 0x649d00a, 0xaa0c00a, 0x809c701,
+	0xc780000, 0xc014340, 0x80c0a00, 0xc014680, 0x0000000,
+	0xc015480, 0x0000000, 0x64c000a, 0x9c0a18a, 0x980a20a,
+	0x980a00a, 0x60c000a, 0x80c2300, 0x64c1e08, 0x9c081c8,
+	0x9808008, 0x60c1e08, 0x98081c8, 0x9c08008, 0x60c1e08,
+	0x64c080a, 0x980a34a, 0x60c080a, 0xc014840, 0x0000000,
+	0x64c1a07, 0xaa10007, 0x6800008, 0xc78c880, 0x0000000,
+	0x64c1e0a, 0x980a60a, 0x60c1e0a, 0x6809009, 0x60c0809,
+	0x64c1e0a, 0x980a74a, 0x980a7ca, 0x60c1e0a, 0xfc08280,
+	0xaa3ec0a, 0x649c108, 0xaa2c008, 0xaa12cca, 0xaa1ad8a,
+	0xae22bca, 0xc78a5c0, 0x6800007, 0xc780980, 0x7c00387,
+	0x6800007, 0xc781ec0, 0x7c00387, 0xc78c240, 0x0000000,
+	0xfc08280, 0x7c0400a, 0x609c40a, 0xfc08280, 0xfc01280,
+	0x500128a, 0x7c0404a, 0xfc0e1c0, 0x7c04087, 0x609c107,
+	0xfc0e1c0, 0x7c040c7, 0x609c207, 0xfc021c0, 0xfc031c0,
+	0xfc041c0, 0x609c007, 0xfc041c0, 0x609c307, 0xfc091c0,
+	0xfc091c0, 0xfc011c0, 0xfc0c1c0, 0xfc011c0, 0x7c04107,
+	0xfc011c0, 0xfc091c0, 0xfc091c0, 0xfc031c0, 0xc78ba80,
+	0x0000000, 0x6800007, 0x7c01f87, 0x7804007, 0xa611207,
+	0xfc101c0, 0xfc011c0, 0xfc071c0, 0xfc011c0, 0xaa10007,
+	0x0000000, 0xfc0c1c0, 0xfc0c1c0, 0xfc011c0, 0x7802047,
+	0x7c02007, 0x7802087, 0x7c02047, 0xfc081c0, 0x7c02087,
+	0x7804107, 0xaa10007, 0xc016b00, 0x80c2301, 0x7c01f47,
+	0xfc011c0, 0x7802088, 0x95c1207, 0x7c02088, 0x50011c7,
+	0x7c01807, 0xaa30007, 0x68000c8, 0xfc011c0, 0xa624007,
+	0x68000c8, 0xfc011c0, 0x7c04187, 0xa60c007, 0x6800048,
+	0x6800088, 0xc780140, 0x7c04148, 0x7c04148, 0xfc011c0,
+	0x7c04187, 0xfc011c0, 0x7c041c7, 0xfc011c0, 0x7c04207,
+	0xfc061c0, 0x7c04247, 0x6800087, 0x7c00087, 0x6800808,
+	0x60c2108, 0x7801807, 0xaa18007, 0x6800008, 0x7804147,
+	0xaa0c0c7, 0x0000000, 0xfc01200, 0x7c04288, 0xfc041c0,
+	0xfc011c0, 0x7c042c7, 0xa648007, 0x6800008, 0xfc011c0,
+	0xaa34007, 0x6800009, 0xc015e80, 0x80c2301, 0xc015f00,
+	0x0000000, 0x7c04307, 0xc015d40, 0x80c2301, 0xc015dc0,
+	0x0000000, 0xc780100, 0x7c04347, 0x7c04308, 0x7c04349,
+	0x6800007, 0x7c00107, 0xc782a00, 0x680001a, 0x7804007,
+	0xa611207, 0xfc101c0, 0xfc011c0, 0xfc071c0, 0xfc021c0,
+	0xa60c047, 0xc780180, 0x680005a, 0xfc081c0, 0x7c020c7,
+	0xc780240, 0x680009a, 0x7802047, 0x7c02007, 0x7802087,
+	0x7c02047, 0xfc081c0, 0x7c02087, 0x7c020c7, 0x7804107,
+	0xaa10007, 0xc0154c0, 0x80c2301, 0x7c01f47, 0xfc011c0,
+	0x78020c8, 0x95c1207, 0xaa0c09a, 0x7c020c8, 0x7c02088,
+	0x50011c7, 0x7c01807, 0xaa34007, 0x68000c8, 0xfc011c0,
+	0xa628007, 0x68000c8, 0xfc011c0, 0xfc011c0, 0x7c04187,
+	0xa60c007, 0x6800048, 0x6800088, 0xc780140, 0x7c04148,
+	0x7c04148, 0xfc011c0, 0x7c04187, 0xfc011c0, 0x7c041c7,
+	0xfc011c0, 0x7c04207, 0xfc061c0, 0x7c04247, 0x78020c7,
+	0x48ff207, 0x7c01f08, 0x91c11c7, 0xaa5c007, 0x7802007,
+	0x91c1207, 0xa610008, 0x48ff1c7, 0x54011c7, 0x48ff1c7,
+	0x7c01e47, 0x7802047, 0x91c1207, 0xa610008, 0x48ff1c7,
+	0x54011c7, 0x48ff1c7, 0x7c01e87, 0x7802087, 0x91c1207,
+	0xa610008, 0x48ff1c7, 0x54011c7, 0x48ff1c7, 0xc780b40,
+	0x7c01ec7, 0x7802007, 0x91c1207, 0xaa2c008, 0x48ff1c7,
+	0x58011c7, 0x7801f08, 0xb4031c8, 0x6804009, 0x2008248,
+	0x24091c8, 0xba0e009, 0xc7fff80, 0x40801c7, 0x7c01e47,
+	0x7802047, 0x91c1207, 0xaa2c008, 0x48ff1c7, 0x58011c7,
+	0x7801f08, 0xb4031c8, 0x6804009, 0x2008248, 0x24091c8,
+	0xba0e009, 0xc7fff80, 0x40801c7, 0x7c01e87, 0x7802087,
+	0x91c1207, 0xaa2c008, 0x48ff1c7, 0x58011c7, 0x7801f08,
+	0xb0031c8, 0x6804009, 0x2408248, 0x2409207, 0xba0e009,
+	0xc7fff80, 0x44801c7, 0x48ff1c7, 0x7c01ec7, 0xa61409a,
+	0x7804147, 0xa60c0c7, 0xc780240, 0x6800808, 0xfc011c0,
+	0x7c00087, 0xa6f0007, 0x6800808, 0x6800047, 0x9505207,
+	0x9605207, 0x60c2108, 0xfc011c0, 0xfc011c0, 0x7c01f87,
+	0xfc021c0, 0xfc011c0, 0x7c04287, 0xfc011c0, 0x7c042c7,
+	0xa648007, 0x6800008, 0xfc011c0, 0xaa34007, 0x6800009,
+	0xc013480, 0x80c2301, 0xc013500, 0x0000000, 0x7c04307,
+	0xc013340, 0x80c2301, 0xc0133c0, 0x0000000, 0xc780100,
+	0x7c04347, 0x7c04308, 0x7c04349, 0x6800007, 0x7c00107,
+	0x7804007, 0xaa25207, 0x0000000, 0x6802007, 0x6c02007,
+	0x60e1907, 0x60e1a07, 0x60e1b07, 0xc781640, 0x0000000,
+	0xfc011c0, 0x64e1c09, 0x97e1247, 0xaa20047, 0x60e1c09,
+	0x6802007, 0x6c02007, 0x60e1907, 0x60e1a07, 0xc781200,
+	0x60e1b07, 0xfc011c0, 0xfc011c0, 0x6800009, 0x7c01009,
+	0xa630007, 0x7c01049, 0xc012a00, 0x80c2301, 0xc012a80,
+	0x0000000, 0x7c01007, 0xc0128c0, 0x80c2301, 0xc012940,
+	0x0000000, 0x7c01047, 0xfc021c0, 0xfc02200, 0x64e1c09,
+	0x9602248, 0x7801008, 0x9405248, 0x7801048, 0x9505248,
+	0x60e1c09, 0xaa30047, 0x6802008, 0x7c01088, 0x6801888,
+	0x7c010c8, 0x6801a88, 0x7c01108, 0x6801d08, 0x7c01148,
+	0x7c01188, 0xc7802c0, 0x6802008, 0x68021c8, 0x7c01088,
+	0x68023c8, 0x7c010c8, 0x7c01108, 0x6802808, 0x7c01148,
+	0x7c01188, 0x6803548, 0x7c011c8, 0xaa2c007, 0x6801089,
+	0xc011f40, 0x80c2301, 0xc011fc0, 0x0000000, 0x7000248,
+	0x20081c8, 0x7400248, 0xbae51c9, 0x4001249, 0x7801088,
+	0x78010c9, 0x9609209, 0x60e1908, 0x7801108, 0x7801149,
+	0x9609209, 0x60e1a08, 0x7801188, 0x78011c9, 0x9609209,
+	0x60e1b08, 0xfc011c0, 0x7c043c7, 0xaa0c007, 0x6800007,
+	0x687ffc7, 0x7c01c07, 0x64c510a, 0x64c4607, 0x7801308,
+	0x5410208, 0x78012c9, 0x2008248, 0x5802208, 0xe000288,
+	0x0000000, 0x0000000, 0x0000000, 0xf000200, 0xf010280,
+	0x970820a, 0x5402208, 0x20081c8, 0x64c430a, 0x2408288,
+	0x64c400a, 0x2408288, 0x7c01348, 0x5810208, 0x7c01388,
+	0xc013100, 0x0000000, 0x680001e, 0x7c0001e, 0x7c016de,
+	0x981d39e, 0x981d3dd, 0x9c1d1dd, 0x7804087, 0x400f1c7,
+	0x58041c7, 0x60c0907, 0x7c00987, 0x4401247, 0x7c00609,
+	0x9708789, 0x5404287, 0x78040c8, 0x400f208, 0x5804208,
+	0x5404248, 0x4401249, 0x5402249, 0x7c009c8, 0x7804149,
+	0xaa0c0c9, 0x4000248, 0x5801249, 0x7c01dc9, 0x4401248,
+	0x9608789, 0x4000248, 0x9610247, 0x6095209, 0x5404208,
+	0x780408a, 0x400f28a, 0x580428a, 0x540428a, 0x78040c8,
+	0x400f208, 0x5804208, 0x5404208, 0x961020a, 0x6090808,
+	0xc005bc0, 0x7c013da, 0x6a00007, 0x60c3d07, 0x64c3d08,
+	0x9161208, 0xa6f8008, 0x6800008, 0x6c06c08, 0xaa1009a,
+	0x2008c08, 0xc780400, 0x60c3808, 0x5803208, 0x7804147,
+	0xaa200c7, 0x6800109, 0xaa18047, 0x6800009, 0x7801f87,
+	0xaa0c007, 0x68000c9, 0x6800009, 0x97a3209, 0x60c3908,
+	0x6bfffc8, 0x60c3808, 0xc00be80, 0x0000000, 0xc00c1c0,
+	0x0000000, 0xc00cfc0, 0x0000000, 0x69898c8, 0x6d81848,
+	0x6800707, 0xd000007, 0x60c2208, 0x7800387, 0xaa10007,
+	0x6800007, 0xc7f0fc0, 0x7c00387, 0x649c909, 0xaa10009,
+	0x6800087, 0xc7f0e80, 0x7c01507, 0x7801487, 0xa608007,
+	0xc780900, 0x44011c7, 0xaa0c087, 0x7801549, 0x78015c9,
+	0xae7c0c9, 0x40301c9, 0x70001c7, 0x54101c7, 0x4034209,
+	0x7000208, 0x94101c8, 0x609cb07, 0x40381c9, 0x70001c7,
+	0x7800fc8, 0x20081c8, 0x609ca08, 0x7c00fd9, 0x40941c9,
+	0x70001c7, 0x54101c7, 0x4090209, 0x7000208, 0x94101c8,
+	0x609cc07, 0x4029209, 0x4001249, 0x7000208, 0x9464248,
+	0x7801808, 0x94e1248, 0x609c909, 0x8007401, 0x6800009,
+	0x7c01489, 0x6800009, 0x7c01509, 0x78014c7, 0x2c07247,
+	0x4000295, 0xa238047, 0x6800008, 0x4000296, 0xa22c087,
+	0x6800048, 0x4000297, 0xa220107, 0x6800088, 0x4000298,
+	0xa214207, 0x68000c8, 0x6800047, 0xc7f0040, 0x7c01507,
+	0x7801607, 0x90041c7, 0xa8051c8, 0xaa2001a, 0x7801607,
+	0x90841c7, 0xa4051c8, 0x6800047, 0x3407207, 0xc7ff980,
+	0x2c091c9, 0x7801347, 0x4090248, 0x7400247, 0x7801387,
+	0x4004249, 0x7400247, 0x7804187, 0x54031c7, 0x2c07687,
+	0x4029248, 0x7400247, 0x40301c8, 0x7800f49, 0x74001c9,
+	0x40341c8, 0x7800f09, 0xa60c05a, 0x74001c9, 0x40006c8,
+	0xa62009a, 0x40381c8, 0x74001d9, 0x7000709, 0xaa1c009,
+	0x4401249, 0xc780140, 0x7400709, 0x7800f89, 0x74001c9,
+	0x4000707, 0x7c00f99, 0x6800047, 0x3407207, 0x78014c9,
+	0x2c091c9, 0x7c014c9, 0x609b20a, 0x609b00a, 0x609b10a,
+	0x68000c9, 0x400125a, 0x7c01489, 0xa60809a, 0xc780340,
+	0x7801587, 0x7c015c7, 0x7c01588, 0x4000185, 0x4000144,
+	0x7801609, 0x5404249, 0x9404248, 0x7c01609, 0x400010a,
+	0xc7800c0, 0x0000000, 0x7c01548, 0x649c108, 0xaa2c008,
+	0x7800187, 0xb61c087, 0x6800048, 0xaa1c09a, 0xaa0801a,
+	0xaa14007, 0x40011c7, 0x7c00187, 0xc780180, 0x7c001c8,
+	0x6800008, 0x7c001c8, 0xc782280, 0x0000000, 0xaa0c01a,
+	0x6801aec, 0x68057ac, 0xc004a80, 0x0000000, 0xc008b80,
+	0x0000000, 0xc015c40, 0x0000000, 0xc004ec0, 0x0000000,
+	0xc781f40, 0x0000000, 0xc781ec0, 0x0000000, 0x78001c7,
+	0xaaf4007, 0x0000000, 0x400024a, 0x7800107, 0xb4031c9,
+	0xc781cc0, 0x0000000, 0x7c00109, 0x78040c7, 0x682bc08,
+	0xb004207, 0x0000000, 0xfc031c0, 0x94e3247, 0x7c00349,
+	0x7804148, 0xaa200c8, 0x7801dc8, 0xb806209, 0x0000000,
+	0x7800307, 0xa608007, 0xc781880, 0x2409209, 0x78016c8,
+	0xa805209, 0x7c016c9, 0x680001e, 0x7c0001e, 0x9408789,
+	0x981d39d, 0x981d3dd, 0x9c1d1dd, 0xc003f00, 0x0000000,
+	0xc008000, 0x0000000, 0xc0150c0, 0x0000000, 0xc004340,
+	0x0000000, 0x7804208, 0xa610008, 0x7804247, 0xfc01200,
+	0xfc061c0, 0x7c00207, 0x94e11c8, 0x60c0a07, 0xa61001a,
+	0x6800007, 0xc7808c0, 0x7c01e07, 0xfc011c0, 0x7c01e07,
+	0x8094200, 0xa60c007, 0xc780740, 0x0000000, 0x6815448,
+	0x6094208, 0x680c008, 0x6094008, 0x7800087, 0xaa18087,
+	0x6800047, 0x7804147, 0xaa0c0c7, 0x6800087, 0x6800107,
+	0xfc08200, 0xfc08240, 0x9509248, 0x6094109, 0xfc01200,
+	0xfc08200, 0xfc08240, 0x9509248, 0x6094109, 0x6094109,
+	0xfc01200, 0xaed4047, 0x44011c7, 0xfc01200, 0x7c00048,
+	0x8094000, 0x78043c7, 0xa60c007, 0xc780540, 0x0000000,
+	0xfc071c0, 0x80c2940, 0x7800207, 0x7804208, 0x94e11c8,
+	0x9807187, 0x98073c7, 0x60c0a07, 0x9c073c7, 0x9807387,
+	0x60c0a07, 0xc0097c0, 0x80c0600, 0x64c0a07, 0x91c21c7,
+	0xa6f8007, 0x0000000, 0xc780100, 0x0000000, 0xc0095c0,
+	0x80c0600, 0x7801e07, 0xaa14007, 0x7800048, 0x94211c8,
+	0x5001208, 0x94411c8, 0x60c1807, 0xcb8002c, 0x0000000,
+	0x64c0007, 0xa2fc047, 0x0000000, 0x64c3a07, 0x90061c7,
+	0xaaec647, 0x0000000, 0x80c0a00, 0x80c2300, 0x64c1e07,
+	0x9807547, 0x60c1e07, 0x80c2800, 0x64c1e07, 0x9c07747,
+	0x60c1e07, 0x80c0002, 0xc7ec480, 0x0000000, 0x649c015,
+	0x649c116, 0x649c217, 0x649c318, 0x809c000, 0x809c100,
+	0x809c200, 0x809c300, 0x6804004, 0x6814105, 0x6824206,
+	0xc000a40, 0x0000000, 0x8002501, 0x8002605, 0x8002708,
+	0x800290d, 0x8002815, 0x8002c14, 0x6800000, 0x7c01c00,
+	0xcc00000, 0x0000000, 0x6800007, 0x7c01907, 0x7c01987,
+	0x7c019c7, 0x7800607, 0x40011c7, 0x7c01887, 0x6800047,
+	0x60e0c07, 0x7c01a87, 0x7c018c7, 0x68003c7, 0x7c00147,
+	0x6805c07, 0x60c2107, 0x80c2170, 0x6800087, 0x7c01ac7,
+	0x680001f, 0x7804148, 0x5406208, 0x940321a, 0x7800387,
+	0x9461207, 0x60c0408, 0x6868008, 0x7c01a48, 0xcc00000,
+	0x0000000, 0x649cf30, 0x64c4002, 0x64c4203, 0x2403083,
+	0x40080c3, 0x7c012c3, 0x58100c3, 0x7c01303, 0x6800019,
+	0x7c01499, 0x7c014d9, 0x7c01519, 0x64c0919, 0x680001a,
+	0x7c0019a, 0x7c001da, 0x68000c2, 0x7c04142, 0x6803fc2,
+	0x7c01542, 0x7c01582, 0x7c015c2, 0x7c01602, 0x60c0919,
+	0x60c1a19, 0x6932002, 0x60c1e02, 0x6800002, 0x60c0c02,
+	0x6c04042, 0x60c0d02, 0xcc00000, 0x0000000, 0x649c803,
+	0xaa14003, 0x78014c2, 0x28020c2, 0x7c014c2, 0x809c800,
+	0x7801502, 0xaa0c002, 0x6800102, 0x6030502, 0x64c0003,
+	0xa2100c3, 0x6800002, 0xc7809c0, 0x0000000, 0x64c3a03,
+	0x90060c3, 0xa60cac3, 0xc780880, 0x0000000, 0x7804143,
+	0xaa080c3, 0xc780780, 0x64c4403, 0x91210c3, 0xaa6c003,
+	0x68fffc3, 0x7801fc2, 0x4001082, 0xb8190c2, 0x7c01fc2,
+	0x6800002, 0x7c01fc2, 0x7800402, 0x4001082, 0xb8130c2,
+	0x7c00402, 0x64c0003, 0x9803203, 0x9803183, 0x9803003,
+	0x60c0003, 0x6800002, 0x64c1803, 0x95860c2, 0x9803483,
+	0x60c1803, 0x9c03483, 0x60c1803, 0x6800103, 0x6030503,
+	0x6800002, 0x7c01fc2, 0x7c00402, 0xcc00000, 0x0000000,
+	0x64c442e, 0x9121bae, 0xaaf802e, 0xc7e9f80, 0x0000000,
+	0xc004ac0, 0x0000000, 0x6818109, 0x6c34749, 0x6090709,
+	0x6490b09, 0x9809009, 0x98090c9, 0x6090b09, 0x9c09009,
+	0x9c090c9, 0x962225a, 0x6090b09, 0x6800009, 0x6c07489,
+	0x2009c09, 0x6094409, 0x6880009, 0x6c07489, 0x2009c09,
+	0x6094509, 0xcc00000, 0x0000000, 0x7804149, 0xa60c0c9,
+	0xcc00000, 0x0000000, 0x6490707, 0x9807087, 0x98070c7,
+	0x6090707, 0x6495107, 0x98073c7, 0xcc00000, 0x6095107,
+	0xcc00000, 0x0400000, 0x64e1210, 0x91e1410, 0xbef0050,
+	0x0000000, 0x649d910, 0x900c410, 0xaef8190, 0x7801850,
+	0xaa3c090, 0xc7821c0, 0x6800011, 0x6c04011, 0x60e1211,
+	0x78016d1, 0xa20c051, 0x680001f, 0x688001f, 0x6c0749f,
+	0x201fc1f, 0x6800010, 0x7c01b10, 0xc7813c0, 0x6800110,
+	0x7801b11, 0xaa08091, 0xc780f00, 0x7801892, 0xaebc092,
+	0xaa3c72f, 0x7801b50, 0x5406410, 0x78016d1, 0x5801451,
+	0xbe0c051, 0x6800011, 0x6880011, 0x6c07491, 0x2011c11,
+	0x2010450, 0x4440410, 0x60e1310, 0xc780340, 0x40c07d0,
+	0x5405410, 0x78016d1, 0xbe0c051, 0x6800011, 0x6880011,
+	0x6c07491, 0x2011c11, 0x2010450, 0x4420410, 0x60e1310,
+	0x40607d0, 0x7801952, 0xaa14012, 0x6a2c211, 0xaa0c052,
+	0x6a2c011, 0x6a2c111, 0x6c04011, 0x60e1211, 0x6800010,
+	0x7c01b10, 0x6800110, 0xc7816c0, 0x7c01850, 0x7801991,
+	0x6800192, 0x2411491, 0x2411491, 0x2411491, 0x7801a50,
+	0x5409410, 0x2010450, 0x5403450, 0x2011c11, 0x60e1311,
+	0x7801952, 0xaa34012, 0x6a44211, 0xaa2c052, 0x6a44011,
+	0xc780240, 0x6a44111, 0xa63c0d1, 0x7801a90, 0x64e0c12,
+	0x9010492, 0xb8ea490, 0xcc00000, 0x0400000, 0x6c0c011,
+	0x60e1211, 0x680001f, 0x6800010, 0x7c01b10, 0x6800150,
+	0xc780e80, 0x7c01850, 0x78018d1, 0xaa1c011, 0x4401451,
+	0x7c018d1, 0x7801891, 0x4401451, 0xc780b00, 0x7c01891,
+	0x78019d1, 0x7c01a11, 0x7801a50, 0x5409410, 0x2010450,
+	0x6800192, 0x2011491, 0x7c019d1, 0x5403450, 0x2011c11,
+	0x60e1311, 0x7801952, 0xaa14012, 0x6a16211, 0xaa0c052,
+	0x6a16011, 0x6a16111, 0x7801bd2, 0xaa28012, 0x7801a90,
+	0x64e0c12, 0x9010492, 0xb804490, 0x7801a12, 0xc7fde80,
+	0x7c019d2, 0x4001410, 0x7c01a90, 0x7c01d91, 0x6c00011,
+	0x60e1211, 0x6800050, 0xc780400, 0x7c01850, 0xba30110,
+	0xc7ff540, 0xa6f8050, 0x7801891, 0xaa74011, 0x4401451,
+	0xb26c051, 0x7c01891, 0x7801ad0, 0xaa0c0d0, 0x0000000,
+	0x80c2170, 0x6800010, 0x7c01850, 0xcc00000, 0x0400000,
+	0xaa0c010, 0x688001f, 0x680001f, 0x6c0749f, 0xc780a40,
+	0x201fc1f, 0xaa0c72f, 0x90a841f, 0x90c741f, 0x7800992,
+	0xb823490, 0xa8f5490, 0x91a141f, 0xaa20010, 0x688001f,
+	0xc780180, 0x680001f, 0xaa7001f, 0x7801991, 0xc7ffcc0,
+	0x0000000, 0x6c0749f, 0x201fc1f, 0x7801a50, 0x5409410,
+	0x6800192, 0x2411491, 0x2010450, 0x5403450, 0x2011c11,
+	0x60e1311, 0x7801d90, 0x9004450, 0xaa14011, 0x6a14210,
+	0xaa0c111, 0x6a14010, 0x6a14110, 0x6c08010, 0x60e0d1f,
+	0xaa0c72f, 0x40207df, 0x40207df, 0xc7ff4c0, 0x60e1210,
+	0x7801a50, 0x5409410, 0x2010450, 0x6800192, 0x2011491,
+	0x7c01991, 0x5403450, 0x2011c11, 0x60e1311, 0x7801d90,
+	0xa61801f, 0x9c101d0, 0x60e1210, 0x68000d0, 0xc7ff0c0,
+	0x7c01850, 0x6c08010, 0x60e0d1f, 0xaae872f, 0x40207df,
+	0xc7ffe00, 0x40207df, 0xc000d00, 0x0000000, 0x8095007,
+	0x8095000, 0x7804347, 0x7804308, 0x94a51c8, 0x78042c8,
+	0x95411c8, 0x6096e07, 0xaa0c008, 0x6800088, 0x6800048,
+	0x60c3108, 0x6800048, 0x780098a, 0x68002c9, 0xb00324a,
+	0x0000000, 0x6800008, 0x6498e0a, 0x97c1288, 0x6098e0a,
+	0x6497f08, 0x68000ca, 0x970220a, 0x6097f08, 0x6820988,
+	0x6c00208, 0x968221a, 0x780098a, 0xb20c2ca, 0x68004ca,
+	0x6800c0a, 0x970620a, 0xcc00000, 0x6095108, 0x683ffc8,
+	0x6490909, 0xa210049, 0xaa0c008, 0xc7fff40, 0x4401208,
+	0x6490b09, 0x9809009, 0x98090c9, 0x6090b09, 0x9c09009,
+	0x9c090c9, 0x6090b09, 0xcc00000, 0x0000000, 0x683ffc9,
+	0x649bb08, 0x920c208, 0x649530a, 0x900128a, 0x2008288,
+	0xaa10008, 0xaa0c009, 0xc7ffe40, 0x4401249, 0xcc00000,
+	0x0000000, 0x64e1209, 0x91e1249, 0xbef8049, 0x64e0009,
+	0x64e0e0b, 0x64e0c0c, 0x83f0040, 0x83f0000, 0x680020d,
+	0xd00000d, 0x0000000, 0x60e0009, 0x60e0e0b, 0xcc00000,
+	0x60e0c0c, 0xc07fc40, 0x0000000, 0x6490b09, 0x9809009,
+	0x9809089, 0x6090b09, 0x9c09009, 0x9c09089, 0x6090b09,
+	0x8095007, 0x8095000, 0xc000500, 0x0000000, 0x6800007,
+	0x7c00307, 0x6800007, 0x7c01907, 0x7c01987, 0x7c019c7,
+	0x7800607, 0x40011c7, 0x7c01887, 0x6800047, 0x60e0c07,
+	0x7c01a87, 0x7c018c7, 0x68003c7, 0x7c00147, 0x6800007,
+	0xcc00000, 0x7c01847, 0x683ffc9, 0x6498f0a, 0xaa0c009,
+	0xa6f800a, 0x4401249, 0x64c3d0a, 0x580a28a, 0xbef80ca,
+	0x0000000, 0x6498e0a, 0x980a00a, 0x6800fc9, 0x9706289,
+	0x6098e0a, 0x6800009, 0x9706289, 0x9c0a00a, 0xcc00000,
+	0x6098e0a, 0x64c3a08, 0x9006208, 0x64c0809, 0x64c090a,
+	0x64c1e0b, 0x64c380c, 0x6800407, 0x63f0007, 0x6800007,
+	0x63f0007, 0x0000000, 0x0000000, 0x0000000, 0x0000000,
+	0x60c0809, 0x60c090a, 0x60c1e0b, 0x60c380c, 0xc07ef00,
+	0x0000000, 0x6800009, 0x60c0c09, 0x6c04049, 0x60c0d09,
+	0x64c1809, 0x9586248, 0x9809489, 0x60c1809, 0x9c09489,
+	0x60c1809, 0xcc00000, 0x80c0a01, 0x680072f, 0x6bfffcb,
+	0x6800024, 0x7801c20, 0x6800021, 0x6800025, 0x6800022,
+	0x6800026, 0x6800023, 0x6800027, 0x680800a, 0x680070e,
+	0x740028b, 0x400128a, 0x74002a4, 0x400128a, 0x74002a0,
+	0x400128a, 0x74002a1, 0x400128a, 0x74002a5, 0x400128a,
+	0x74002a2, 0x400128a, 0x74002a6, 0x400128a, 0x74002a3,
+	0x400128a, 0x74002a7, 0xd07fbce, 0x400128a, 0x7c01c4b,
+	0x96102cb, 0x80c0700, 0x60c270b, 0x9610824, 0x60c0220,
+	0x9610865, 0xaa1801a, 0x60c0221, 0x96108a6, 0x60c0222,
+	0x96108e7, 0x60c0223, 0x780098e, 0xb009bce, 0x6b80007,
+	0x6c07487, 0x2007c07, 0x6035107, 0x6803f07, 0x6035207,
+	0x6a08007, 0x6035007, 0x7800007, 0xa60c007, 0x6803fc7,
+	0x7c01c87, 0x6800007, 0x7c01d47, 0xac0bbce, 0x7801c87,
+	0xb613fc7, 0xba0c707, 0x441c1c7, 0x7c01c87, 0x6435007,
+	0x580f1c7, 0xbef8047, 0xcc00000, 0x0000000, 0x6435007,
+	0x580f1c7, 0xbef8047, 0x0000000, 0x6435307, 0x900c1c7,
+	0xa6f8007, 0x0000000, 0x6b80007, 0x6c07487, 0x2007c07,
+	0x6035107, 0x6803f07, 0x6035207, 0x6b0c007, 0x6035007,
+	0x54011ef, 0xac051ce, 0x6800087, 0x7c01cc7, 0xc7ff880,
+	0x7c01d07, 0x6b90008, 0x6c07488, 0x2008c08, 0x540126f,
+	0x2009bc9, 0x680008a, 0x7c01cca, 0x68000ca, 0x6435007,
+	0x580f1c7, 0xbef8047, 0x6803f07, 0x6035108, 0x6035207,
+	0x6a08007, 0x6035007, 0xac0324e, 0xc7ff3c0, 0x7c01d0a,
+	0x6808007, 0x20081c8, 0x2009bc9, 0xc7ffc80, 0x400128a,
+	0x400130c, 0x480f30c, 0x7c01d0c, 0x980b38b, 0x7801ccc,
+	0x540928c, 0x200a24a, 0x400130c, 0x480f30c, 0x7c01ccc,
+	0x643500c, 0x580f30c, 0x6c0748a, 0xbef404c, 0x200ac0a,
+	0x643530c, 0x900c30c, 0xa6f800c, 0x0000000, 0x603510a,
+	0x6803f0a, 0x603520a, 0xc7fedc0, 0x603500b, 0x64c2307,
+	0xbefc047, 0xcc00000, 0x64c2007, 0x40011c7, 0x6800008,
+	0xa20c047, 0x58011c7, 0x24071c8, 0xcc00000, 0x0000000,
+	0x2409247, 0x48ff249, 0x5401249, 0x2407207, 0x48ff1c7,
+	0x54011c7, 0x680000a, 0x680000b, 0x6800048, 0xb8041c8,
+	0x54012cb, 0x980b04b, 0x24081c8, 0x5401208, 0xb2ec20a,
+	0x400128a, 0x58012cb, 0xe0002c9, 0x0000000, 0x0000000,
+	0xcc00000, 0xf000240, 0x2409247, 0x6807fca, 0x2809289,
+	0x2407207, 0x6807fca, 0x2807287, 0x680000a, 0x680000b,
+	0x6800048, 0xb8041c8, 0x54012cb, 0x980b04b, 0x24081c8,
+	0x5401208, 0xb2ec20a, 0x400128a, 0x58012cb, 0xe0002c9,
+	0x0000000, 0x0000000, 0xcc00000, 0xf000240, 0x24091c9,
+	0x6807fca, 0x2809289, 0x24071c8, 0x6807fca, 0x2807287,
+	0x680000a, 0x680000b, 0x6800048, 0xb8041c8, 0x54012cb,
+	0x980b04b, 0x24081c8, 0x5401208, 0xb2ec20a, 0x400128a,
+	0x58012cb, 0xe0002c9, 0x0000000, 0x0000000, 0xcc00000,
+	0xf000240, 0x2407207, 0x6807fca, 0x2807287, 0x680000a,
+	0x680000b, 0x6800048, 0xb8041c8, 0x54012cb, 0x980b04b,
+	0x24081c8, 0x5401208, 0xb2ec34a, 0x400128a, 0xcc00000,
+	0x580124b, 0x7804187, 0xa60c007, 0x6800088, 0x6800048,
+	0x7c04148, 0xa60c01a, 0x68057ac, 0x680005a, 0xcc00000,
+	0x0000000, 0x24091c9, 0x6807fc8, 0x2809209, 0x680000a,
+	0x680000b, 0x6800048, 0xb8041c8, 0x54012cb, 0x980b04b,
+	0x24081c8, 0x5401208, 0xb2ec20a, 0x400128a, 0x58012cb,
+	0xe0002c9, 0x0000000, 0x0000000, 0xcc00000, 0xf000240,
+	0xaa1409a, 0xaa0801a, 0xc784cc0, 0xcc00000, 0x0000000,
+	0x7801ec7, 0x7801e88, 0x2407207, 0x48ff1c7, 0x54011c7,
+	0x7c00447, 0x7801f07, 0x7801e88, 0x2407207, 0x48ff1c7,
+	0x54011c7, 0x7c00487, 0x7804149, 0xaa140c9, 0x7800389,
+	0xa60c009, 0x0000000, 0x44011c7, 0xc07f580, 0x7800449,
+	0x6800f88, 0x9646248, 0x60c3009, 0x7800487, 0x7804149,
+	0xaa280c9, 0x7800389, 0xaa0c009, 0x0000000, 0x40011c7,
+	0xc07f280, 0x7800449, 0x6800fc8, 0x9646248, 0x60c3009,
+	0x7804147, 0xaa080c7, 0xc780bc0, 0x7801e88, 0x5401208,
+	0x7801ec7, 0xc07e980, 0x54011c7, 0x6800c08, 0x9646248,
+	0x60c3009, 0x7801e48, 0x5401208, 0x7801ec7, 0xc07e780,
+	0x54011c7, 0x6800c48, 0x9646248, 0x60c3009, 0x7801f07,
+	0x7801e88, 0x2407207, 0x48ff1c7, 0x5401247, 0x7801ec7,
+	0x7801f08, 0x2407207, 0x48ff1c7, 0x54011c7, 0x9529247,
+	0x6800d08, 0x9646248, 0x60c3009, 0x7801f07, 0x7801e88,
+	0xc07d1c0, 0x7801e89, 0x6800808, 0x9646248, 0x60c3009,
+	0x7801ec7, 0x7801f08, 0xc07d000, 0x7801f09, 0x6800888,
+	0x9646248, 0x60c3009, 0xcc00000, 0x0000000, 0x7801f8c,
+	0xaa0c00c, 0x780038c, 0x680000c, 0xa61c00c, 0x7801ec7,
+	0x54011c7, 0x7801e88, 0x5401208, 0xc780180, 0x4001208,
+	0x7801ec7, 0x54011c7, 0x40011c7, 0x4401207, 0xc07db00,
+	0x0000000, 0x6800c08, 0x9646248, 0xa60c00c, 0x0000000,
+	0x98093c9, 0x60c3009, 0xa61800c, 0x7801ec7, 0x54011c7,
+	0x7801e88, 0xc780200, 0x5401208, 0x7801ec7, 0x54011c7,
+	0x40011c7, 0x7801e88, 0x5401208, 0x4001208, 0xc07d600,
+	0x0000000, 0x6800c48, 0x9646248, 0xaa0c00c, 0x0000000,
+	0x98093c9, 0x60c3009, 0xa61c00c, 0x7801ec7, 0x54011c7,
+	0x7801e48, 0x5401208, 0xc7801c0, 0x4001208, 0x7801ec7,
+	0x54011c7, 0x40011c7, 0x7801e88, 0x5401208, 0xc07d100,
+	0x0000000, 0x6800c88, 0x9646248, 0x60c3009, 0xa61800c,
+	0x7801ec7, 0x54011c7, 0x7801e48, 0xc780200, 0x5401208,
+	0x7801ec7, 0x54011c7, 0x40011c7, 0x7801e48, 0x5401208,
+	0x4001208, 0xc07ccc0, 0x0000000, 0x6800cc8, 0x9646248,
+	0x60c3009, 0x780038c, 0x7801f07, 0xaa0c00c, 0x54011c7,
+	0x40011c7, 0x7801e88, 0x5401208, 0x2407207, 0x6807fca,
+	0x2809287, 0x7801ec7, 0xaa1800c, 0x54011c7, 0x7801f88,
+	0xa60c008, 0x0000000, 0x40011c7, 0x7801f08, 0xaa0c00c,
+	0x5401208, 0x4001208, 0x2407207, 0x2807287, 0x9529247,
+	0x6800d08, 0x9646248, 0x60c3009, 0x7801f07, 0xaa0c00c,
+	0x54011c7, 0x40011c7, 0x7801e88, 0x5401208, 0x4001208,
+	0x2407207, 0x6807fca, 0x2809287, 0x7801ec7, 0xaa1800c,
+	0x54011c7, 0x7801f88, 0xa60c008, 0x0000000, 0x40011c7,
+	0x7801f08, 0xaa0c00c, 0x5401208, 0x4001208, 0x2407207,
+	0x2807287, 0x9529247, 0x6800d48, 0x9646248, 0x60c3009,
+	0xaa0c00c, 0x680000c, 0x680004c, 0x7801f07, 0x54011c7,
+	0x2007307, 0x7801e88, 0x5401208, 0x4001208, 0xc07b0c0,
+	0x4000248, 0x6800808, 0x9646248, 0x60c3009, 0x7801f07,
+	0x54011c7, 0x2007307, 0x7801e88, 0x5401208, 0xc07ae40,
+	0x4001248, 0x6800848, 0x9646248, 0x60c3009, 0x7801f07,
+	0x54011c7, 0x2007307, 0x7801ec8, 0x5401208, 0xc07b140,
+	0x4000248, 0x6800888, 0x9646248, 0x60c3009, 0x7801f07,
+	0x54011c7, 0x2007307, 0x7801ec8, 0x5401208, 0x4001208,
+	0xc07ae80, 0x4401248, 0x68008c8, 0x9646248, 0x60c3009,
+	0x7801f07, 0x54011c7, 0x2007307, 0x7801e88, 0x5401208,
+	0x4001208, 0xc07a640, 0x4401248, 0x6800908, 0x9646248,
+	0x60c3009, 0x7801f07, 0x54011c7, 0x2007307, 0x7801e88,
+	0x5401208, 0xc07a3c0, 0x4000248, 0x6800948, 0x9646248,
+	0x60c3009, 0x7801f07, 0x54011c7, 0x2007307, 0x7801ec8,
+	0x5401208, 0xc07a6c0, 0x4001248, 0x6800988, 0x9646248,
+	0x60c3009, 0x7801f07, 0x54011c7, 0x2007307, 0x7801ec8,
+	0x5401208, 0x4001208, 0xc07a400, 0x4400248, 0x68009c8,
+	0x9646248, 0x60c3009, 0xcc00000, 0x0000000, 0x7804147,
+	0xaa080c7, 0xc7807c0, 0x7801f07, 0x7801e88, 0xc079600,
+	0x7801e89, 0x6800808, 0x9646248, 0x60c3009, 0x7801ec7,
+	0x7801e48, 0xc079440, 0x7801e89, 0x6800848, 0x9646248,
+	0x60c3009, 0x7801ec7, 0x7801e88, 0xc079280, 0x7801e49,
+	0x6800908, 0x9646248, 0x60c3009, 0x7801ec7, 0x7801e48,
+	0xc0790c0, 0x7801e49, 0x6800948, 0x9646248, 0x60c3009,
+	0xcc00000, 0x0000000, 0x780038c, 0xaa0800c, 0xc780880,
+	0x680080d, 0x7801f07, 0x54011c7, 0x900230d, 0x7801e88,
+	0x5401208, 0xaa2004c, 0xaa1c00c, 0x4001208, 0x7801e48,
+	0x5401208, 0xaa0c0cc, 0x0000000, 0x4001208, 0x904230d,
+	0x7801e89, 0x5401249, 0xaa2004c, 0xaa1c00c, 0x4001249,
+	0x7801e49, 0x5401249, 0xaa0c0cc, 0x0000000, 0x4001249,
+	0xc078d80, 0x0000000, 0x964624d, 0x60c3009, 0xba90bcd,
+	0x400134d, 0xcc00000, 0x0000000, 0x680080d, 0x7801f07,
+	0x54011c7, 0x40011c7, 0x900230d, 0x7801f08, 0xaa2800c,
+	0x5401208, 0x7801e88, 0x5401208, 0xaa1808c, 0xaa1404c,
+	0x4001208, 0x7801e48, 0x5401208, 0x4001208, 0x904230d,
+	0x7801f09, 0xaa2800c, 0x5401249, 0x7801e89, 0x5401249,
+	0xaa1808c, 0xaa1404c, 0x4001249, 0x7801e49, 0x5401249,
+	0x4001249, 0xc078480, 0x0000000, 0x964624d, 0x60c3009,
+	0xba84bcd, 0x400134d, 0xcc00000, 0x0000000, 0x7804147,
+	0xa6140c7, 0x6099004, 0x6099105, 0xc780240, 0x6099206,
+	0x6099004, 0x6099104, 0x6099205, 0x6099305, 0x6099406,
+	0xc780080, 0x6099506, 0xaa3c09a, 0xaa0805a, 0xcc00000,
+	0x7804147, 0x698d908, 0xaa1c0c7, 0x6d85888, 0x688d108,
+	0xaa10087, 0x6c85088, 0x6910948, 0x6d088c8, 0x80c2400,
+	0xcc00000, 0x60c2208, 0x7804147, 0x698d908, 0xaa100c7,
+	0x6d85888, 0x6800008, 0x6d088c8, 0x80c2400, 0x60c2208,
+	0x7804147, 0x69898c8, 0xaa100c7, 0x6d81848, 0x6800008,
+	0x6c85008, 0x80c2408, 0xcc00000, 0x60c2208, 0x0000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/avs/txl_avs_linux_debug.h b/drivers/amlogic/amports/arch/ucode/avs/txl_avs_linux_debug.h
new file mode 100644
index 0000000..9aea2f6
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/avs/txl_avs_linux_debug.h
@@ -0,0 +1,546 @@
+/*
+ * drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux_debug.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+static const u32 MicroCode[] __initconst = {
+	0x6807801, 0x6800000, 0xd000001, 0x7400040, 0xc014c00,
+	0x0000000, 0x0000000, 0x0000000, 0x80c0002, 0x6932000,
+	0x9800580, 0x60c1e00, 0x6bfdac0, 0x7c017c0, 0x6030400,
+	0x0400000, 0xc015e40, 0x0000000, 0x0000000, 0x0000000,
+	0x0000000, 0xc7ffec0, 0x0000000, 0x0000000, 0x0000000,
+	0x0000000, 0x0000000, 0x0000000, 0x0000000, 0x0000000,
+	0x0000000, 0x0000000, 0xcc00000, 0x0400000, 0xcc00000,
+	0x0400000, 0xc780540, 0x64c0007, 0xc796780, 0x0000000,
+	0xc797180, 0x0000000, 0xcc00000, 0x0400000, 0xcc00000,
+	0x0400000, 0xc797000, 0x0000000, 0xcc00000, 0x0400000,
+	0x6800009, 0x7c01fc9, 0x7c00409, 0x0800000, 0x78017c9,
+	0xc7ffe40, 0x6030409, 0x6bfd9c9, 0x6030409, 0x0400000,
+	0xa2d8047, 0x7801509, 0xaa14009, 0xa608049, 0xc78fb00,
+	0xa608089, 0xc78efc0, 0xa23c807, 0xc786380, 0x0000000,
+	0x649d008, 0xaa0c008, 0x809c701, 0xc780000, 0xc01aa80,
+	0x80c0a00, 0xc01adc0, 0x0000000, 0xc01c080, 0x0000000,
+	0xc793440, 0x0000000, 0xbecd007, 0x78043c8, 0xaa0c008,
+	0xa208207, 0xc7932c0, 0x78003c7, 0xa6fc007, 0x78043c7,
+	0xa648007, 0x64c2907, 0xbe2c407, 0x7800007, 0xa638007,
+	0x0000000, 0x64c2907, 0x91c11c7, 0xa628047, 0x0000000,
+	0x64c0607, 0x900f1c7, 0xae18047, 0x68025f1, 0xc027640,
+	0x78025f2, 0xc792dc0, 0x0000000, 0xcb8002c, 0x0000000,
+	0x68fdfca, 0x64e0408, 0x2808288, 0x2c08748, 0x60e0408,
+	0x60c071e, 0x64c0324, 0x64c0325, 0x64c2728, 0x9210268,
+	0x7800007, 0xa618007, 0x7801c08, 0x6c00008, 0x60c0208,
+	0x80c0200, 0x6bfffc9, 0x60c0320, 0x60c0321, 0x7801c48,
+	0x9610209, 0x60c2708, 0x7801847, 0xa6fc007, 0x7800147,
+	0x7c01b87, 0x6800347, 0x7c00147, 0x60c2507, 0x80c2602,
+	0x80c260f, 0x80c2603, 0x4c001c7, 0x9807207, 0x60c2107,
+	0x7801907, 0xaa14007, 0x6a01008, 0xaa0c047, 0x6a22008,
+	0x6a40008, 0x6c00108, 0x60e0508, 0x7801b08, 0x6801809,
+	0x9502248, 0x60c2109, 0x80c260e, 0x6800088, 0x7c01947,
+	0xba0c087, 0x40011c7, 0x6800007, 0x7c01907, 0x7800007,
+	0x7c01b47, 0x7801b87, 0x7c01bc7, 0x7c01848, 0x8030580,
+	0x7801d47, 0xaa1472f, 0x40011c7, 0x78016c8, 0xa20c048,
+	0x0000000, 0x7c01d47, 0x683ffc8, 0x64c2307, 0x93041c7,
+	0xaa0c008, 0xa6f4007, 0x4401208, 0x7801c8d, 0xba13fcd,
+	0x6800008, 0xc781100, 0x7c01c88, 0x6808008, 0xba1070d,
+	0x400024d, 0x441c249, 0x680c008, 0x5403289, 0x200a24a,
+	0x2008288, 0x7400228, 0x4001208, 0x92102e4, 0x740020b,
+	0x4001208, 0x7400224, 0x4001208, 0x7400225, 0x4001208,
+	0x92102e5, 0x740020b, 0x4001208, 0x7400226, 0x4001208,
+	0x92102e6, 0x740020b, 0x4001208, 0x7400227, 0x4001208,
+	0x92102e7, 0x740020b, 0x7800988, 0xac07bc8, 0x780000a,
+	0xaa3872f, 0x40002ca, 0x78016ca, 0xc7802c0, 0x942f28b,
+	0xa61000a, 0xaa1472f, 0x78016ca, 0xa20c04a, 0xa6146c9,
+	0x400128d, 0xb60c70d, 0x680000a, 0x680070a, 0x7c01c8a,
+	0xb013bc8, 0xaa0800a, 0xa64470a, 0x7801cca, 0xa20c04a,
+	0x6a0800b, 0x6a0c00b, 0x6b80009, 0x7801d0c, 0x540928c,
+	0x200a24a, 0x6c0748a, 0x200ac0a, 0x603510a, 0x6803f0a,
+	0x603520a, 0x603500b, 0xc01ba40, 0x0000000, 0x7800007,
+	0x40011c7, 0x7c00007, 0x9c1d39d, 0x7800988, 0xb405207,
+	0x40011c7, 0xb836207, 0xc780d40, 0x981d1dd, 0x6800007,
+	0x7c00007, 0x981d39d, 0x9c1d3dd, 0x9c1d1dd, 0x78016c8,
+	0x4001208, 0x68000b1, 0xc024c40, 0x4000c88, 0x7801dc9,
+	0xb828248, 0x7c016c8, 0x7801847, 0xa6fc007, 0x0000000,
+	0x6430507, 0xa2f0107, 0x6a00007, 0x60c3d07, 0x7800147,
+	0xaa24007, 0x6803fcb, 0x7801a88, 0x64e0c09, 0x9010249,
+	0xb804248, 0xaa0c00b, 0xc7ffec0, 0x44012cb, 0x7804147,
+	0xaa280c7, 0x7800347, 0x7801dc8, 0xb407207, 0xc01cb80,
+	0x7c00348, 0x6800048, 0x7c00308, 0xc7898c0, 0x7c00388,
+	0x6800008, 0x7c00308, 0x7c00388, 0xc78fb40, 0x64c0007,
+	0xb60c709, 0x6808008, 0x680c008, 0xc780400, 0x6800007,
+	0x7800007, 0x9508787, 0x78016c9, 0x9408789, 0x7800989,
+	0xb009bc9, 0x6808008, 0xaad0007, 0x7801c89, 0x40011c9,
+	0xba10707, 0xb6c0e07, 0x680c008, 0x441c1c7, 0x5403247,
+	0x20091c9, 0x2008248, 0x7000209, 0x7c01c49, 0x4001208,
+	0x7000209, 0x4001208, 0x7000220, 0x9610809, 0x4001208,
+	0x7000221, 0x4001208, 0x7000209, 0x9610849, 0x4001208,
+	0x7000222, 0x4001208, 0x7000209, 0x9610889, 0x4001208,
+	0x7000223, 0x4001208, 0x7000209, 0x96108c9, 0xc7fb400,
+	0x0000000, 0x68fdfca, 0x64e0408, 0x2808288, 0x2c08748,
+	0x60e0408, 0x60c071e, 0x64c0324, 0x64c0325, 0x64c0326,
+	0x64c0327, 0x64c2728, 0x60c071e, 0x9210268, 0x7800007,
+	0xa638007, 0x7801c08, 0x6c00008, 0x60c0208, 0x6800008,
+	0x6c00008, 0x60c0208, 0x6800008, 0x6c00008, 0x60c0208,
+	0x6800008, 0x6c00008, 0x60c0208, 0x6bfffc9, 0x60c0320,
+	0x60c0321, 0x60c0322, 0x60c0323, 0x7801c48, 0x9610209,
+	0x60c2708, 0x7804287, 0x54031c7, 0x4c301c7, 0x7801f8a,
+	0x95011ca, 0x60c2507, 0x780184a, 0xa6fc00a, 0x7800147,
+	0x7c01b87, 0x64c2307, 0x9304207, 0xa6f8008, 0x90a1207,
+	0x90241c7, 0x95211c8, 0x64c0609, 0x9010249, 0xaa10009,
+	0x0000000, 0x6800007, 0x6800008, 0x7c00147, 0xaa60347,
+	0x60c2507, 0xaa60287, 0xaa18048, 0xa60c007, 0xc780200,
+	0x0000000, 0x80c2605, 0x80c2606, 0x80c2607, 0x80c2602,
+	0x80c260f, 0x80c2603, 0x7801ac8, 0xaa100c8, 0x6800089,
+	0xc7fb800, 0x7c01ac9, 0x780184b, 0xa6fc00b, 0x0000000,
+	0x7c01b08, 0xc7fb680, 0x7c01ac9, 0x80c2602, 0x80c260f,
+	0x80c2603, 0x7801ac8, 0xaa48088, 0x68000c9, 0x7800008,
+	0xaa0c008, 0xc7fb400, 0x7c01ac9, 0x6803fcb, 0x7801a88,
+	0x64e0c09, 0x9010249, 0xb804248, 0xaa0c00b, 0xc7ffec0,
+	0x44012cb, 0x6800088, 0x68000c9, 0x680180b, 0x60c210b,
+	0x780184b, 0xa6fc00b, 0x0000000, 0x7c01b08, 0xc7faf80,
+	0x7c01ac9, 0xa279007, 0x0000000, 0x649d00a, 0xaa0c00a,
+	0x809c701, 0xc780000, 0xc014700, 0x80c0a00, 0xc014a40,
+	0x0000000, 0xc015840, 0x0000000, 0x64c000a, 0x9c0a18a,
+	0x980a20a, 0x980a00a, 0x60c000a, 0x80c2300, 0x64c1e08,
+	0x9c081c8, 0x9808008, 0x60c1e08, 0x98081c8, 0x9c08008,
+	0x60c1e08, 0x64c080a, 0x980a34a, 0x60c080a, 0xc014c00,
+	0x0000000, 0x64c1a07, 0xaa10007, 0x6800008, 0xc78cb80,
+	0x0000000, 0x64c1e0a, 0x980a60a, 0x60c1e0a, 0x6809009,
+	0x60c0809, 0x64c1e0a, 0x980a74a, 0x980a7ca, 0x60c1e0a,
+	0xfc08280, 0x6800071, 0xc021040, 0x4000c8a, 0xaa3ec0a,
+	0x649c108, 0xaa2c008, 0xaa12cca, 0xaa1ad8a, 0xae22bca,
+	0xc78a800, 0x6800007, 0xc780980, 0x7c00387, 0x6800007,
+	0xc781ec0, 0x7c00387, 0xc78c480, 0x0000000, 0xfc08280,
+	0x7c0400a, 0x609c40a, 0xfc08280, 0xfc01280, 0x500128a,
+	0x7c0404a, 0xfc0e1c0, 0x7c04087, 0x609c107, 0xfc0e1c0,
+	0x7c040c7, 0x609c207, 0xfc021c0, 0xfc031c0, 0xfc041c0,
+	0x609c007, 0xfc041c0, 0x609c307, 0xfc091c0, 0xfc091c0,
+	0xfc011c0, 0xfc0c1c0, 0xfc011c0, 0x7c04107, 0xfc011c0,
+	0xfc091c0, 0xfc091c0, 0xfc031c0, 0xc78bcc0, 0x0000000,
+	0x6800007, 0x7c01f87, 0x7804007, 0xa611207, 0xfc101c0,
+	0xfc011c0, 0xfc071c0, 0xfc011c0, 0xaa10007, 0x0000000,
+	0xfc0c1c0, 0xfc0c1c0, 0xfc011c0, 0x7802047, 0x7c02007,
+	0x7802087, 0x7c02047, 0xfc081c0, 0x7c02087, 0x7804107,
+	0xaa10007, 0xc016e00, 0x80c2301, 0x7c01f47, 0xfc011c0,
+	0x7802088, 0x95c1207, 0x7c02088, 0x50011c7, 0x7c01807,
+	0xaa30007, 0x68000c8, 0xfc011c0, 0xa624007, 0x68000c8,
+	0xfc011c0, 0x7c04187, 0xa60c007, 0x6800048, 0x6800088,
+	0xc780140, 0x7c04148, 0x7c04148, 0xfc011c0, 0x7c04187,
+	0xfc011c0, 0x7c041c7, 0xfc011c0, 0x7c04207, 0xfc061c0,
+	0x7c04247, 0x6800087, 0x7c00087, 0x6800808, 0x60c2108,
+	0x7801807, 0xaa18007, 0x6800008, 0x7804147, 0xaa0c0c7,
+	0x0000000, 0xfc01200, 0x7c04288, 0xfc041c0, 0xfc011c0,
+	0x7c042c7, 0xa648007, 0x6800008, 0xfc011c0, 0xaa34007,
+	0x6800009, 0xc016180, 0x80c2301, 0xc016200, 0x0000000,
+	0x7c04307, 0xc016040, 0x80c2301, 0xc0160c0, 0x0000000,
+	0xc780100, 0x7c04347, 0x7c04308, 0x7c04349, 0x6800007,
+	0x7c00107, 0xc782ac0, 0x680001a, 0x7804007, 0xa611207,
+	0xfc101c0, 0xfc011c0, 0xfc071c0, 0xfc021c0, 0xa60c047,
+	0xc780180, 0x680005a, 0xfc081c0, 0x7c020c7, 0xc780240,
+	0x680009a, 0x7802047, 0x7c02007, 0x7802087, 0x7c02047,
+	0xfc081c0, 0x7c02087, 0x7c020c7, 0x6800271, 0xc01e900,
+	0x4000c9a, 0x7804107, 0xaa10007, 0xc015700, 0x80c2301,
+	0x7c01f47, 0xfc011c0, 0x78020c8, 0x95c1207, 0xaa0c09a,
+	0x7c020c8, 0x7c02088, 0x50011c7, 0x7c01807, 0xaa34007,
+	0x68000c8, 0xfc011c0, 0xa628007, 0x68000c8, 0xfc011c0,
+	0xfc011c0, 0x7c04187, 0xa60c007, 0x6800048, 0x6800088,
+	0xc780140, 0x7c04148, 0x7c04148, 0xfc011c0, 0x7c04187,
+	0xfc011c0, 0x7c041c7, 0xfc011c0, 0x7c04207, 0xfc061c0,
+	0x7c04247, 0x78020c7, 0x48ff207, 0x7c01f08, 0x91c11c7,
+	0xaa5c007, 0x7802007, 0x91c1207, 0xa610008, 0x48ff1c7,
+	0x54011c7, 0x48ff1c7, 0x7c01e47, 0x7802047, 0x91c1207,
+	0xa610008, 0x48ff1c7, 0x54011c7, 0x48ff1c7, 0x7c01e87,
+	0x7802087, 0x91c1207, 0xa610008, 0x48ff1c7, 0x54011c7,
+	0x48ff1c7, 0xc780b40, 0x7c01ec7, 0x7802007, 0x91c1207,
+	0xaa2c008, 0x48ff1c7, 0x58011c7, 0x7801f08, 0xb4031c8,
+	0x6804009, 0x2008248, 0x24091c8, 0xba0e009, 0xc7fff80,
+	0x40801c7, 0x7c01e47, 0x7802047, 0x91c1207, 0xaa2c008,
+	0x48ff1c7, 0x58011c7, 0x7801f08, 0xb4031c8, 0x6804009,
+	0x2008248, 0x24091c8, 0xba0e009, 0xc7fff80, 0x40801c7,
+	0x7c01e87, 0x7802087, 0x91c1207, 0xaa2c008, 0x48ff1c7,
+	0x58011c7, 0x7801f08, 0xb0031c8, 0x6804009, 0x2408248,
+	0x2409207, 0xba0e009, 0xc7fff80, 0x44801c7, 0x48ff1c7,
+	0x7c01ec7, 0xa61409a, 0x7804147, 0xa60c0c7, 0xc780240,
+	0x6800808, 0xfc011c0, 0x7c00087, 0xa6f0007, 0x6800808,
+	0x6800047, 0x9505207, 0x9605207, 0x60c2108, 0xfc011c0,
+	0xfc011c0, 0x7c01f87, 0xfc021c0, 0xfc011c0, 0x7c04287,
+	0xfc011c0, 0x7c042c7, 0xa648007, 0x6800008, 0xfc011c0,
+	0xaa34007, 0x6800009, 0xc0136c0, 0x80c2301, 0xc013740,
+	0x0000000, 0x7c04307, 0xc013580, 0x80c2301, 0xc013600,
+	0x0000000, 0xc780100, 0x7c04347, 0x7c04308, 0x7c04349,
+	0x6800007, 0x7c00107, 0x7804007, 0xaa25207, 0x0000000,
+	0x6802007, 0x6c02007, 0x60e1907, 0x60e1a07, 0x60e1b07,
+	0xc781640, 0x0000000, 0xfc011c0, 0x64e1c09, 0x97e1247,
+	0xaa20047, 0x60e1c09, 0x6802007, 0x6c02007, 0x60e1907,
+	0x60e1a07, 0xc781200, 0x60e1b07, 0xfc011c0, 0xfc011c0,
+	0x6800009, 0x7c01009, 0xa630007, 0x7c01049, 0xc012c40,
+	0x80c2301, 0xc012cc0, 0x0000000, 0x7c01007, 0xc012b00,
+	0x80c2301, 0xc012b80, 0x0000000, 0x7c01047, 0xfc021c0,
+	0xfc02200, 0x64e1c09, 0x9602248, 0x7801008, 0x9405248,
+	0x7801048, 0x9505248, 0x60e1c09, 0xaa30047, 0x6802008,
+	0x7c01088, 0x6801888, 0x7c010c8, 0x6801a88, 0x7c01108,
+	0x6801d08, 0x7c01148, 0x7c01188, 0xc7802c0, 0x6802008,
+	0x68021c8, 0x7c01088, 0x68023c8, 0x7c010c8, 0x7c01108,
+	0x6802808, 0x7c01148, 0x7c01188, 0x6803548, 0x7c011c8,
+	0xaa2c007, 0x6801089, 0xc012180, 0x80c2301, 0xc012200,
+	0x0000000, 0x7000248, 0x20081c8, 0x7400248, 0xbae51c9,
+	0x4001249, 0x7801088, 0x78010c9, 0x9609209, 0x60e1908,
+	0x7801108, 0x7801149, 0x9609209, 0x60e1a08, 0x7801188,
+	0x78011c9, 0x9609209, 0x60e1b08, 0xfc011c0, 0x7c043c7,
+	0xaa0c007, 0x6800007, 0x687ffc7, 0x7c01c07, 0x64c510a,
+	0x64c4607, 0x7801308, 0x5410208, 0x78012c9, 0x2008248,
+	0x5802208, 0xe000288, 0x0000000, 0x0000000, 0x0000000,
+	0xf000200, 0xf010280, 0x970820a, 0x5402208, 0x20081c8,
+	0x64c430a, 0x2408288, 0x64c400a, 0x2408288, 0x7c01348,
+	0x5810208, 0x7c01388, 0xc013340, 0x0000000, 0x680001e,
+	0x7c0001e, 0x7c016de, 0x981d39e, 0x981d3dd, 0x9c1d1dd,
+	0x7804087, 0x400f1c7, 0x58041c7, 0x60c0907, 0x7c00987,
+	0x4401247, 0x7c00609, 0x9708789, 0x5404287, 0x78040c8,
+	0x400f208, 0x5804208, 0x5404248, 0x4401249, 0x5402249,
+	0x7c009c8, 0x7804149, 0xaa0c0c9, 0x4000248, 0x5801249,
+	0x7c01dc9, 0x4401248, 0x9608789, 0x4000248, 0x9610247,
+	0x6095209, 0x5404208, 0x780408a, 0x400f28a, 0x580428a,
+	0x540428a, 0x78040c8, 0x400f208, 0x5804208, 0x5404208,
+	0x961020a, 0x6090808, 0xc005d40, 0x7c013da, 0x6a00007,
+	0x60c3d07, 0x64c3d08, 0x9161208, 0xa6f8008, 0x6800008,
+	0x6c06c08, 0xaa1009a, 0x2008c08, 0xc780400, 0x60c3808,
+	0x5803208, 0x7804147, 0xaa200c7, 0x6800109, 0xaa18047,
+	0x6800009, 0x7801f87, 0xaa0c007, 0x68000c9, 0x6800009,
+	0x97a3209, 0x60c3908, 0x6bfffc8, 0x60c3808, 0xc00c0c0,
+	0x0000000, 0xc00c400, 0x0000000, 0xc00d200, 0x0000000,
+	0x69898c8, 0x6d81848, 0x6800707, 0xd000007, 0x60c2208,
+	0x7800387, 0xaa10007, 0x6800007, 0xc7f0cc0, 0x7c00387,
+	0x649c909, 0xaa10009, 0x6800087, 0xc7f0b80, 0x7c01507,
+	0x7801487, 0xa608007, 0xc780900, 0x44011c7, 0xaa0c087,
+	0x7801549, 0x78015c9, 0xae7c0c9, 0x40301c9, 0x70001c7,
+	0x54101c7, 0x4034209, 0x7000208, 0x94101c8, 0x609cb07,
+	0x40381c9, 0x70001c7, 0x7800fc8, 0x20081c8, 0x609ca08,
+	0x7c00fd9, 0x40941c9, 0x70001c7, 0x54101c7, 0x4090209,
+	0x7000208, 0x94101c8, 0x609cc07, 0x4029209, 0x4001249,
+	0x7000208, 0x9464248, 0x7801808, 0x94e1248, 0x609c909,
+	0x8007401, 0x6800009, 0x7c01489, 0x6800009, 0x7c01509,
+	0x78014c7, 0x2c07247, 0x4000295, 0xa238047, 0x6800008,
+	0x4000296, 0xa22c087, 0x6800048, 0x4000297, 0xa220107,
+	0x6800088, 0x4000298, 0xa214207, 0x68000c8, 0x6800047,
+	0xc7efd40, 0x7c01507, 0x7801607, 0x90041c7, 0xa8051c8,
+	0xaa2001a, 0x7801607, 0x90841c7, 0xa4051c8, 0x6800047,
+	0x3407207, 0xc7ff980, 0x2c091c9, 0x7801347, 0x4090248,
+	0x7400247, 0x7801387, 0x4004249, 0x7400247, 0x7804187,
+	0x54031c7, 0x2c07687, 0x4029248, 0x7400247, 0x40301c8,
+	0x7800f49, 0x74001c9, 0x40341c8, 0x7800f09, 0xa60c05a,
+	0x74001c9, 0x40006c8, 0xa62009a, 0x40381c8, 0x74001d9,
+	0x7000709, 0xaa1c009, 0x4401249, 0xc780140, 0x7400709,
+	0x7800f89, 0x74001c9, 0x4000707, 0x7c00f99, 0x6800231,
+	0xc0175c0, 0x4000c88, 0x6800047, 0x3407207, 0x78014c9,
+	0x2c091c9, 0x7c014c9, 0x609b20a, 0x609b00a, 0x609b10a,
+	0x68000c9, 0x400125a, 0x7c01489, 0xa60809a, 0xc780340,
+	0x7801587, 0x7c015c7, 0x7c01588, 0x4000185, 0x4000144,
+	0x7801609, 0x5404249, 0x9404248, 0x7c01609, 0x400010a,
+	0xc7800c0, 0x0000000, 0x7c01548, 0x649c108, 0xaa2c008,
+	0x7800187, 0xb61c087, 0x6800048, 0xaa1c09a, 0xaa0801a,
+	0xaa14007, 0x40011c7, 0x7c00187, 0xc780180, 0x7c001c8,
+	0x6800008, 0x7c001c8, 0xc782340, 0x0000000, 0x6800131,
+	0xc016a80, 0x4000c9a, 0xaa0c01a, 0x6801bac, 0x680592c,
+	0xc004b40, 0x0000000, 0xc008c40, 0x0000000, 0xc015d00,
+	0x0000000, 0xc004f80, 0x0000000, 0xc781f40, 0x0000000,
+	0xc781ec0, 0x0000000, 0x78001c7, 0xaaf4007, 0x0000000,
+	0x400024a, 0x7800107, 0xb4031c9, 0xc781cc0, 0x0000000,
+	0x7c00109, 0x78040c7, 0x682bc08, 0xb004207, 0x0000000,
+	0xfc031c0, 0x94e3247, 0x7c00349, 0x7804148, 0xaa200c8,
+	0x7801dc8, 0xb806209, 0x0000000, 0x7800307, 0xa608007,
+	0xc781880, 0x2409209, 0x78016c8, 0xa805209, 0x7c016c9,
+	0x680001e, 0x7c0001e, 0x9408789, 0x981d39d, 0x981d3dd,
+	0x9c1d1dd, 0xc003fc0, 0x0000000, 0xc0080c0, 0x0000000,
+	0xc015180, 0x0000000, 0xc004400, 0x0000000, 0x7804208,
+	0xa610008, 0x7804247, 0xfc01200, 0xfc061c0, 0x7c00207,
+	0x94e11c8, 0x60c0a07, 0xa61001a, 0x6800007, 0xc7808c0,
+	0x7c01e07, 0xfc011c0, 0x7c01e07, 0x8094200, 0xa60c007,
+	0xc780740, 0x0000000, 0x6815448, 0x6094208, 0x680c008,
+	0x6094008, 0x7800087, 0xaa18087, 0x6800047, 0x7804147,
+	0xaa0c0c7, 0x6800087, 0x6800107, 0xfc08200, 0xfc08240,
+	0x9509248, 0x6094109, 0xfc01200, 0xfc08200, 0xfc08240,
+	0x9509248, 0x6094109, 0x6094109, 0xfc01200, 0xaed4047,
+	0x44011c7, 0xfc01200, 0x7c00048, 0x8094000, 0x78043c7,
+	0xa60c007, 0xc780540, 0x0000000, 0xfc071c0, 0x80c2940,
+	0x7800207, 0x7804208, 0x94e11c8, 0x9807187, 0x98073c7,
+	0x60c0a07, 0x9c073c7, 0x9807387, 0x60c0a07, 0xc009880,
+	0x80c0600, 0x64c0a07, 0x91c21c7, 0xa6f8007, 0x0000000,
+	0xc780100, 0x0000000, 0xc009680, 0x80c0600, 0x7801e07,
+	0xaa14007, 0x7800048, 0x94211c8, 0x5001208, 0x94411c8,
+	0x60c1807, 0xcb8002c, 0x0000000, 0x64c0007, 0xa2fc047,
+	0x0000000, 0x64c3a07, 0x90061c7, 0xaaec647, 0x0000000,
+	0x80c0a00, 0x80c2300, 0x64c1e07, 0x9807547, 0x60c1e07,
+	0x80c2800, 0x64c1e07, 0x9c07747, 0x60c1e07, 0x80c0002,
+	0xc7ec000, 0x0000000, 0x649c015, 0x649c116, 0x649c217,
+	0x649c318, 0x809c000, 0x809c100, 0x809c200, 0x809c300,
+	0x6804004, 0x6814105, 0x6824206, 0xc000a40, 0x0000000,
+	0x8002501, 0x8002605, 0x8002708, 0x800290d, 0x8002815,
+	0x8002c14, 0x6800000, 0x7c01c00, 0xcc00000, 0x0000000,
+	0x6800007, 0x7c01907, 0x7c01987, 0x7c019c7, 0x7800607,
+	0x40011c7, 0x7c01887, 0x6800047, 0x60e0c07, 0x7c01a87,
+	0x7c018c7, 0x68003c7, 0x7c00147, 0x6805c07, 0x60c2107,
+	0x80c2170, 0x6800087, 0x7c01ac7, 0x680001f, 0x7804148,
+	0x5406208, 0x940321a, 0x7800387, 0x9461207, 0x60c0408,
+	0x6868008, 0x7c01a48, 0xcc00000, 0x0000000, 0x649cf30,
+	0x64c4002, 0x64c4203, 0x2403083, 0x40080c3, 0x7c012c3,
+	0x58100c3, 0x7c01303, 0x6800019, 0x7c01499, 0x7c014d9,
+	0x7c01519, 0x64c0919, 0x680001a, 0x7c0019a, 0x7c001da,
+	0x68000c2, 0x7c04142, 0x6803fc2, 0x7c01542, 0x7c01582,
+	0x7c015c2, 0x7c01602, 0x60c0919, 0x60c1a19, 0x6932002,
+	0x60c1e02, 0x6800002, 0x60c0c02, 0x6c04042, 0x60c0d02,
+	0xcc00000, 0x0000000, 0x649c803, 0xaa14003, 0x78014c2,
+	0x28020c2, 0x7c014c2, 0x809c800, 0x7801502, 0xaa0c002,
+	0x6800102, 0x6030502, 0x64c0003, 0xa2100c3, 0x6800002,
+	0xc780a80, 0x0000000, 0x64c3a03, 0x90060c3, 0xa60cac3,
+	0xc780940, 0x0000000, 0x7804143, 0xaa080c3, 0xc780840,
+	0x64c4403, 0x91210c3, 0xaa78003, 0x68fffc3, 0x7801fc2,
+	0x4001082, 0xb81c0c2, 0x7c01fc2, 0x6800002, 0x7c01fc2,
+	0x7800402, 0x4001082, 0xb8160c2, 0x7c00402, 0x64c0003,
+	0x9803203, 0x9803183, 0x9803003, 0x60c0003, 0x6802671,
+	0xc012340, 0x7802672, 0x6800002, 0x64c1803, 0x95860c2,
+	0x9803483, 0x60c1803, 0x9c03483, 0x60c1803, 0x6800103,
+	0x6030503, 0x6800002, 0x7c01fc2, 0x7c00402, 0xcc00000,
+	0x0000000, 0x64c442e, 0x9121bae, 0xaaf802e, 0xc7e9a40,
+	0x0000000, 0xc004ac0, 0x0000000, 0x6818109, 0x6c34749,
+	0x6090709, 0x6490b09, 0x9809009, 0x98090c9, 0x6090b09,
+	0x9c09009, 0x9c090c9, 0x962225a, 0x6090b09, 0x6800009,
+	0x6c07489, 0x2009c09, 0x6094409, 0x6880009, 0x6c07489,
+	0x2009c09, 0x6094509, 0xcc00000, 0x0000000, 0x7804149,
+	0xa60c0c9, 0xcc00000, 0x0000000, 0x6490707, 0x9807087,
+	0x98070c7, 0x6090707, 0x6495107, 0x98073c7, 0xcc00000,
+	0x6095107, 0xcc00000, 0x0400000, 0x64e1210, 0x91e1410,
+	0xbef0050, 0x0000000, 0x649d910, 0x900c410, 0xaef8190,
+	0x7801850, 0xaa3c090, 0xc7821c0, 0x6800011, 0x6c04011,
+	0x60e1211, 0x78016d1, 0xa20c051, 0x680001f, 0x688001f,
+	0x6c0749f, 0x201fc1f, 0x6800010, 0x7c01b10, 0xc7813c0,
+	0x6800110, 0x7801b11, 0xaa08091, 0xc780f00, 0x7801892,
+	0xaebc092, 0xaa3c72f, 0x7801b50, 0x5406410, 0x78016d1,
+	0x5801451, 0xbe0c051, 0x6800011, 0x6880011, 0x6c07491,
+	0x2011c11, 0x2010450, 0x4440410, 0x60e1310, 0xc780340,
+	0x40c07d0, 0x5405410, 0x78016d1, 0xbe0c051, 0x6800011,
+	0x6880011, 0x6c07491, 0x2011c11, 0x2010450, 0x4420410,
+	0x60e1310, 0x40607d0, 0x7801952, 0xaa14012, 0x6a2c211,
+	0xaa0c052, 0x6a2c011, 0x6a2c111, 0x6c04011, 0x60e1211,
+	0x6800010, 0x7c01b10, 0x6800110, 0xc7816c0, 0x7c01850,
+	0x7801991, 0x6800192, 0x2411491, 0x2411491, 0x2411491,
+	0x7801a50, 0x5409410, 0x2010450, 0x5403450, 0x2011c11,
+	0x60e1311, 0x7801952, 0xaa34012, 0x6a44211, 0xaa2c052,
+	0x6a44011, 0xc780240, 0x6a44111, 0xa63c0d1, 0x7801a90,
+	0x64e0c12, 0x9010492, 0xb8ea490, 0xcc00000, 0x0400000,
+	0x6c0c011, 0x60e1211, 0x680001f, 0x6800010, 0x7c01b10,
+	0x6800150, 0xc780e80, 0x7c01850, 0x78018d1, 0xaa1c011,
+	0x4401451, 0x7c018d1, 0x7801891, 0x4401451, 0xc780b00,
+	0x7c01891, 0x78019d1, 0x7c01a11, 0x7801a50, 0x5409410,
+	0x2010450, 0x6800192, 0x2011491, 0x7c019d1, 0x5403450,
+	0x2011c11, 0x60e1311, 0x7801952, 0xaa14012, 0x6a16211,
+	0xaa0c052, 0x6a16011, 0x6a16111, 0x7801bd2, 0xaa28012,
+	0x7801a90, 0x64e0c12, 0x9010492, 0xb804490, 0x7801a12,
+	0xc7fde80, 0x7c019d2, 0x4001410, 0x7c01a90, 0x7c01d91,
+	0x6c00011, 0x60e1211, 0x6800050, 0xc780400, 0x7c01850,
+	0xba30110, 0xc7ff540, 0xa6f8050, 0x7801891, 0xaa74011,
+	0x4401451, 0xb26c051, 0x7c01891, 0x7801ad0, 0xaa0c0d0,
+	0x0000000, 0x80c2170, 0x6800010, 0x7c01850, 0xcc00000,
+	0x0400000, 0xaa0c010, 0x688001f, 0x680001f, 0x6c0749f,
+	0xc780a40, 0x201fc1f, 0xaa0c72f, 0x90a841f, 0x90c741f,
+	0x7800992, 0xb823490, 0xa8f5490, 0x91a141f, 0xaa20010,
+	0x688001f, 0xc780180, 0x680001f, 0xaa7001f, 0x7801991,
+	0xc7ffcc0, 0x0000000, 0x6c0749f, 0x201fc1f, 0x7801a50,
+	0x5409410, 0x6800192, 0x2411491, 0x2010450, 0x5403450,
+	0x2011c11, 0x60e1311, 0x7801d90, 0x9004450, 0xaa14011,
+	0x6a14210, 0xaa0c111, 0x6a14010, 0x6a14110, 0x6c08010,
+	0x60e0d1f, 0xaa0c72f, 0x40207df, 0x40207df, 0xc7ff4c0,
+	0x60e1210, 0x7801a50, 0x5409410, 0x2010450, 0x6800192,
+	0x2011491, 0x7c01991, 0x5403450, 0x2011c11, 0x60e1311,
+	0x7801d90, 0xa61801f, 0x9c101d0, 0x60e1210, 0x68000d0,
+	0xc7ff0c0, 0x7c01850, 0x6c08010, 0x60e0d1f, 0xaae872f,
+	0x40207df, 0xc7ffe00, 0x40207df, 0xc000d00, 0x0000000,
+	0x8095007, 0x8095000, 0x7804347, 0x7804308, 0x94a51c8,
+	0x78042c8, 0x95411c8, 0x6096e07, 0xaa0c008, 0x6800088,
+	0x6800048, 0x60c3108, 0x6800048, 0x780098a, 0x68002c9,
+	0xb00324a, 0x0000000, 0x6800008, 0x6498e0a, 0x97c1288,
+	0x6098e0a, 0x6497f08, 0x68000ca, 0x970220a, 0x6097f08,
+	0x6820988, 0x6c00208, 0x968221a, 0x780098a, 0xb20c2ca,
+	0x68004ca, 0x6800c0a, 0x970620a, 0xcc00000, 0x6095108,
+	0x683ffc8, 0x6490909, 0xa210049, 0xaa0c008, 0xc7fff40,
+	0x4401208, 0x6490b09, 0x9809009, 0x98090c9, 0x6090b09,
+	0x9c09009, 0x9c090c9, 0x6090b09, 0xcc00000, 0x0000000,
+	0x683ffc9, 0x649bb08, 0x920c208, 0x649530a, 0x900128a,
+	0x2008288, 0xaa10008, 0xaa0c009, 0xc7ffe40, 0x4401249,
+	0xcc00000, 0x0000000, 0x64e1209, 0x91e1249, 0xbef8049,
+	0x64e0009, 0x64e0e0b, 0x64e0c0c, 0x83f0040, 0x83f0000,
+	0x680020d, 0xd00000d, 0x0000000, 0x60e0009, 0x60e0e0b,
+	0xcc00000, 0x60e0c0c, 0xc07fc40, 0x0000000, 0x6490b09,
+	0x9809009, 0x9809089, 0x6090b09, 0x9c09009, 0x9c09089,
+	0x6090b09, 0x8095007, 0x8095000, 0xc000500, 0x0000000,
+	0x6800007, 0x7c00307, 0x6800007, 0x7c01907, 0x7c01987,
+	0x7c019c7, 0x7800607, 0x40011c7, 0x7c01887, 0x6800047,
+	0x60e0c07, 0x7c01a87, 0x7c018c7, 0x68003c7, 0x7c00147,
+	0x6800007, 0xcc00000, 0x7c01847, 0x683ffc9, 0x6498f0a,
+	0xaa0c009, 0xa6f800a, 0x4401249, 0x64c3d0a, 0x580a28a,
+	0xbef80ca, 0x0000000, 0x6498e0a, 0x980a00a, 0x6800fc9,
+	0x9706289, 0x6098e0a, 0x6800009, 0x9706289, 0x9c0a00a,
+	0xcc00000, 0x6098e0a, 0x64c3a08, 0x9006208, 0x64c0809,
+	0x64c090a, 0x64c1e0b, 0x64c380c, 0x6800407, 0x63f0007,
+	0x6800007, 0x63f0007, 0x0000000, 0x0000000, 0x0000000,
+	0x0000000, 0x60c0809, 0x60c090a, 0x60c1e0b, 0x60c380c,
+	0xc07ef00, 0x0000000, 0x6800009, 0x60c0c09, 0x6c04049,
+	0x60c0d09, 0x64c1809, 0x9586248, 0x9809489, 0x60c1809,
+	0x9c09489, 0x60c1809, 0xcc00000, 0x80c0a01, 0x680072f,
+	0x6bfffcb, 0x6800024, 0x7801c20, 0x6800021, 0x6800025,
+	0x6800022, 0x6800026, 0x6800023, 0x6800027, 0x680800a,
+	0x680070e, 0x740028b, 0x400128a, 0x74002a4, 0x400128a,
+	0x74002a0, 0x400128a, 0x74002a1, 0x400128a, 0x74002a5,
+	0x400128a, 0x74002a2, 0x400128a, 0x74002a6, 0x400128a,
+	0x74002a3, 0x400128a, 0x74002a7, 0xd07fbce, 0x400128a,
+	0x7c01c4b, 0x96102cb, 0x80c0700, 0x60c270b, 0x9610824,
+	0x60c0220, 0x9610865, 0xaa1801a, 0x60c0221, 0x96108a6,
+	0x60c0222, 0x96108e7, 0x60c0223, 0x780098e, 0xb009bce,
+	0x6b80007, 0x6c07487, 0x2007c07, 0x6035107, 0x6803f07,
+	0x6035207, 0x6a08007, 0x6035007, 0x7800007, 0xa60c007,
+	0x6803fc7, 0x7c01c87, 0x6800007, 0x7c01d47, 0xac0bbce,
+	0x7801c87, 0xb613fc7, 0xba0c707, 0x441c1c7, 0x7c01c87,
+	0x6435007, 0x580f1c7, 0xbef8047, 0xcc00000, 0x0000000,
+	0x6435007, 0x580f1c7, 0xbef8047, 0x0000000, 0x6435307,
+	0x900c1c7, 0xa6f8007, 0x0000000, 0x6b80007, 0x6c07487,
+	0x2007c07, 0x6035107, 0x6803f07, 0x6035207, 0x6b0c007,
+	0x6035007, 0x54011ef, 0xac051ce, 0x6800087, 0x7c01cc7,
+	0xc7ff880, 0x7c01d07, 0x6b90008, 0x6c07488, 0x2008c08,
+	0x540126f, 0x2009bc9, 0x680008a, 0x7c01cca, 0x68000ca,
+	0x6435007, 0x580f1c7, 0xbef8047, 0x6803f07, 0x6035108,
+	0x6035207, 0x6a08007, 0x6035007, 0xac0324e, 0xc7ff3c0,
+	0x7c01d0a, 0x6808007, 0x20081c8, 0x2009bc9, 0xc7ffc80,
+	0x400128a, 0x400130c, 0x480f30c, 0x7c01d0c, 0x980b38b,
+	0x7801ccc, 0x540928c, 0x200a24a, 0x400130c, 0x480f30c,
+	0x7c01ccc, 0x643500c, 0x580f30c, 0x6c0748a, 0xbef404c,
+	0x200ac0a, 0x643530c, 0x900c30c, 0xa6f800c, 0x0000000,
+	0x603510a, 0x6803f0a, 0x603520a, 0xc7fedc0, 0x603500b,
+	0x64c2307, 0xbefc047, 0xcc00000, 0x64c2007, 0x40011c7,
+	0x6800008, 0xa20c047, 0x58011c7, 0x24071c8, 0xcc00000,
+	0x0000000, 0x2409247, 0x48ff249, 0x5401249, 0x2407207,
+	0x48ff1c7, 0x54011c7, 0x680000a, 0x680000b, 0x6800048,
+	0xb8041c8, 0x54012cb, 0x980b04b, 0x24081c8, 0x5401208,
+	0xb2ec20a, 0x400128a, 0x58012cb, 0xe0002c9, 0x0000000,
+	0x0000000, 0xcc00000, 0xf000240, 0x2409247, 0x6807fca,
+	0x2809289, 0x2407207, 0x6807fca, 0x2807287, 0x680000a,
+	0x680000b, 0x6800048, 0xb8041c8, 0x54012cb, 0x980b04b,
+	0x24081c8, 0x5401208, 0xb2ec20a, 0x400128a, 0x58012cb,
+	0xe0002c9, 0x0000000, 0x0000000, 0xcc00000, 0xf000240,
+	0x24091c9, 0x6807fca, 0x2809289, 0x24071c8, 0x6807fca,
+	0x2807287, 0x680000a, 0x680000b, 0x6800048, 0xb8041c8,
+	0x54012cb, 0x980b04b, 0x24081c8, 0x5401208, 0xb2ec20a,
+	0x400128a, 0x58012cb, 0xe0002c9, 0x0000000, 0x0000000,
+	0xcc00000, 0xf000240, 0x2407207, 0x6807fca, 0x2807287,
+	0x680000a, 0x680000b, 0x6800048, 0xb8041c8, 0x54012cb,
+	0x980b04b, 0x24081c8, 0x5401208, 0xb2ec34a, 0x400128a,
+	0xcc00000, 0x580124b, 0x7804187, 0xa60c007, 0x6800088,
+	0x6800048, 0x7c04148, 0xa60c01a, 0x680592c, 0x680005a,
+	0xcc00000, 0x0000000, 0x24091c9, 0x6807fc8, 0x2809209,
+	0x680000a, 0x680000b, 0x6800048, 0xb8041c8, 0x54012cb,
+	0x980b04b, 0x24081c8, 0x5401208, 0xb2ec20a, 0x400128a,
+	0x58012cb, 0xe0002c9, 0x0000000, 0x0000000, 0xcc00000,
+	0xf000240, 0xaa1409a, 0xaa0801a, 0xc784cc0, 0xcc00000,
+	0x0000000, 0x7801ec7, 0x7801e88, 0x2407207, 0x48ff1c7,
+	0x54011c7, 0x7c00447, 0x7801f07, 0x7801e88, 0x2407207,
+	0x48ff1c7, 0x54011c7, 0x7c00487, 0x7804149, 0xaa140c9,
+	0x7800389, 0xa60c009, 0x0000000, 0x44011c7, 0xc07f580,
+	0x7800449, 0x6800f88, 0x9646248, 0x60c3009, 0x7800487,
+	0x7804149, 0xaa280c9, 0x7800389, 0xaa0c009, 0x0000000,
+	0x40011c7, 0xc07f280, 0x7800449, 0x6800fc8, 0x9646248,
+	0x60c3009, 0x7804147, 0xaa080c7, 0xc780bc0, 0x7801e88,
+	0x5401208, 0x7801ec7, 0xc07e980, 0x54011c7, 0x6800c08,
+	0x9646248, 0x60c3009, 0x7801e48, 0x5401208, 0x7801ec7,
+	0xc07e780, 0x54011c7, 0x6800c48, 0x9646248, 0x60c3009,
+	0x7801f07, 0x7801e88, 0x2407207, 0x48ff1c7, 0x5401247,
+	0x7801ec7, 0x7801f08, 0x2407207, 0x48ff1c7, 0x54011c7,
+	0x9529247, 0x6800d08, 0x9646248, 0x60c3009, 0x7801f07,
+	0x7801e88, 0xc07d1c0, 0x7801e89, 0x6800808, 0x9646248,
+	0x60c3009, 0x7801ec7, 0x7801f08, 0xc07d000, 0x7801f09,
+	0x6800888, 0x9646248, 0x60c3009, 0xcc00000, 0x0000000,
+	0x7801f8c, 0xaa0c00c, 0x780038c, 0x680000c, 0xa61c00c,
+	0x7801ec7, 0x54011c7, 0x7801e88, 0x5401208, 0xc780180,
+	0x4001208, 0x7801ec7, 0x54011c7, 0x40011c7, 0x4401207,
+	0xc07db00, 0x0000000, 0x6800c08, 0x9646248, 0xa60c00c,
+	0x0000000, 0x98093c9, 0x60c3009, 0xa61800c, 0x7801ec7,
+	0x54011c7, 0x7801e88, 0xc780200, 0x5401208, 0x7801ec7,
+	0x54011c7, 0x40011c7, 0x7801e88, 0x5401208, 0x4001208,
+	0xc07d600, 0x0000000, 0x6800c48, 0x9646248, 0xaa0c00c,
+	0x0000000, 0x98093c9, 0x60c3009, 0xa61c00c, 0x7801ec7,
+	0x54011c7, 0x7801e48, 0x5401208, 0xc7801c0, 0x4001208,
+	0x7801ec7, 0x54011c7, 0x40011c7, 0x7801e88, 0x5401208,
+	0xc07d100, 0x0000000, 0x6800c88, 0x9646248, 0x60c3009,
+	0xa61800c, 0x7801ec7, 0x54011c7, 0x7801e48, 0xc780200,
+	0x5401208, 0x7801ec7, 0x54011c7, 0x40011c7, 0x7801e48,
+	0x5401208, 0x4001208, 0xc07ccc0, 0x0000000, 0x6800cc8,
+	0x9646248, 0x60c3009, 0x780038c, 0x7801f07, 0xaa0c00c,
+	0x54011c7, 0x40011c7, 0x7801e88, 0x5401208, 0x2407207,
+	0x6807fca, 0x2809287, 0x7801ec7, 0xaa1800c, 0x54011c7,
+	0x7801f88, 0xa60c008, 0x0000000, 0x40011c7, 0x7801f08,
+	0xaa0c00c, 0x5401208, 0x4001208, 0x2407207, 0x2807287,
+	0x9529247, 0x6800d08, 0x9646248, 0x60c3009, 0x7801f07,
+	0xaa0c00c, 0x54011c7, 0x40011c7, 0x7801e88, 0x5401208,
+	0x4001208, 0x2407207, 0x6807fca, 0x2809287, 0x7801ec7,
+	0xaa1800c, 0x54011c7, 0x7801f88, 0xa60c008, 0x0000000,
+	0x40011c7, 0x7801f08, 0xaa0c00c, 0x5401208, 0x4001208,
+	0x2407207, 0x2807287, 0x9529247, 0x6800d48, 0x9646248,
+	0x60c3009, 0xaa0c00c, 0x680000c, 0x680004c, 0x7801f07,
+	0x54011c7, 0x2007307, 0x7801e88, 0x5401208, 0x4001208,
+	0xc07b0c0, 0x4000248, 0x6800808, 0x9646248, 0x60c3009,
+	0x7801f07, 0x54011c7, 0x2007307, 0x7801e88, 0x5401208,
+	0xc07ae40, 0x4001248, 0x6800848, 0x9646248, 0x60c3009,
+	0x7801f07, 0x54011c7, 0x2007307, 0x7801ec8, 0x5401208,
+	0xc07b140, 0x4000248, 0x6800888, 0x9646248, 0x60c3009,
+	0x7801f07, 0x54011c7, 0x2007307, 0x7801ec8, 0x5401208,
+	0x4001208, 0xc07ae80, 0x4401248, 0x68008c8, 0x9646248,
+	0x60c3009, 0x7801f07, 0x54011c7, 0x2007307, 0x7801e88,
+	0x5401208, 0x4001208, 0xc07a640, 0x4401248, 0x6800908,
+	0x9646248, 0x60c3009, 0x7801f07, 0x54011c7, 0x2007307,
+	0x7801e88, 0x5401208, 0xc07a3c0, 0x4000248, 0x6800948,
+	0x9646248, 0x60c3009, 0x7801f07, 0x54011c7, 0x2007307,
+	0x7801ec8, 0x5401208, 0xc07a6c0, 0x4001248, 0x6800988,
+	0x9646248, 0x60c3009, 0x7801f07, 0x54011c7, 0x2007307,
+	0x7801ec8, 0x5401208, 0x4001208, 0xc07a400, 0x4400248,
+	0x68009c8, 0x9646248, 0x60c3009, 0xcc00000, 0x0000000,
+	0x7804147, 0xaa080c7, 0xc7807c0, 0x7801f07, 0x7801e88,
+	0xc079600, 0x7801e89, 0x6800808, 0x9646248, 0x60c3009,
+	0x7801ec7, 0x7801e48, 0xc079440, 0x7801e89, 0x6800848,
+	0x9646248, 0x60c3009, 0x7801ec7, 0x7801e88, 0xc079280,
+	0x7801e49, 0x6800908, 0x9646248, 0x60c3009, 0x7801ec7,
+	0x7801e48, 0xc0790c0, 0x7801e49, 0x6800948, 0x9646248,
+	0x60c3009, 0xcc00000, 0x0000000, 0x780038c, 0xaa0800c,
+	0xc780880, 0x680080d, 0x7801f07, 0x54011c7, 0x900230d,
+	0x7801e88, 0x5401208, 0xaa2004c, 0xaa1c00c, 0x4001208,
+	0x7801e48, 0x5401208, 0xaa0c0cc, 0x0000000, 0x4001208,
+	0x904230d, 0x7801e89, 0x5401249, 0xaa2004c, 0xaa1c00c,
+	0x4001249, 0x7801e49, 0x5401249, 0xaa0c0cc, 0x0000000,
+	0x4001249, 0xc078d80, 0x0000000, 0x964624d, 0x60c3009,
+	0xba90bcd, 0x400134d, 0xcc00000, 0x0000000, 0x680080d,
+	0x7801f07, 0x54011c7, 0x40011c7, 0x900230d, 0x7801f08,
+	0xaa2800c, 0x5401208, 0x7801e88, 0x5401208, 0xaa1808c,
+	0xaa1404c, 0x4001208, 0x7801e48, 0x5401208, 0x4001208,
+	0x904230d, 0x7801f09, 0xaa2800c, 0x5401249, 0x7801e89,
+	0x5401249, 0xaa1808c, 0xaa1404c, 0x4001249, 0x7801e49,
+	0x5401249, 0x4001249, 0xc078480, 0x0000000, 0x964624d,
+	0x60c3009, 0xba84bcd, 0x400134d, 0xcc00000, 0x0000000,
+	0x7804147, 0xa6140c7, 0x6099004, 0x6099105, 0xc780240,
+	0x6099206, 0x6099004, 0x6099104, 0x6099205, 0x6099305,
+	0x6099406, 0xc780080, 0x6099506, 0xaa3c09a, 0xaa0805a,
+	0xcc00000, 0x7804147, 0x698d908, 0xaa1c0c7, 0x6d85888,
+	0x688d108, 0xaa10087, 0x6c85088, 0x6910948, 0x6d088c8,
+	0x80c2400, 0xcc00000, 0x60c2208, 0x7804147, 0x698d908,
+	0xaa100c7, 0x6d85888, 0x6800008, 0x6d088c8, 0x80c2400,
+	0x60c2208, 0x7804147, 0x69898c8, 0xaa100c7, 0x6d81848,
+	0x6800008, 0x6c85008, 0x80c2408, 0xcc00000, 0x60c2208,
+	0x609cd32, 0x609ce31, 0x8007401, 0x649ce31, 0xa6fc031,
+	0x0000000, 0xcc00000, 0x0000000, 0x0000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/avs/vavs_mc.c b/drivers/amlogic/amports/arch/ucode/avs/vavs_mc.c
index bb9d61b..46a0fc9 100644
--- a/drivers/amlogic/amports/arch/ucode/avs/vavs_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/avs/vavs_mc.c
@@ -27,6 +27,14 @@
 #define MicroCode vavs_mc_old
 #include "avs_linux_old.h"
 
+#undef MicroCode
+#define MicroCode txl_vavs_mc
+#include "txl_avs_linux.h"
+#undef MicroCode
+#define MicroCode txl_vavs_mc_debug
+#include "txl_avs_linux_debug.h"
+
+
 #define FOR_VFORMAT VFORMAT_AVS
 
 #define REG_FIRMWARE_ALL()\
@@ -34,6 +42,8 @@
 		DEF_FIRMWARE(vavs_mc);\
 		DEF_FIRMWARE(vavs_mc_debug);\
 		DEF_FIRMWARE(vavs_mc_old);\
+		DEF_FIRMWARE(txl_vavs_mc);\
+		DEF_FIRMWARE(txl_vavs_mc_debug);\
 	} while (0)
 
 INIT_DEF_FIRMWARE();
diff --git a/drivers/amlogic/amports/arch/ucode/firmware_def.h b/drivers/amlogic/amports/arch/ucode/firmware_def.h
index 52931e5..498b9d0 100644
--- a/drivers/amlogic/amports/arch/ucode/firmware_def.h
+++ b/drivers/amlogic/amports/arch/ucode/firmware_def.h
@@ -25,6 +25,7 @@
 		MESON_CPU_MAJOR_ID_GXTVBB,\
 		MESON_CPU_MAJOR_ID_GXL,\
 		MESON_CPU_MAJOR_ID_GXM,\
+		MESON_CPU_MAJOR_ID_TXL,\
 		0}
 
 #endif
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264c_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264c_linux.h
new file mode 100644
index 0000000..cf44e22
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264c_linux.h
@@ -0,0 +1,822 @@
+static const u32 MicroCode[] __initconst = {
+	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x064c0800,
+	0x09800300, 0x00000000, 0x060c0800, 0x0649d019, 0x0c006140,
+	0x0649c134, 0x06880000, 0x060c2900, 0x080c0002, 0x06bfda80,
+	0x07c02d40, 0x06030400, 0x00400000, 0x0c007d00, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
+	0x00000000, 0x06431e35, 0x0befc075, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0c780500, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0c780d40, 0x064c0007, 0x0cc00000, 0x00400000,
+	0x0c787d40, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c787bc0, 0x00000000, 0x0c787980, 0x00000000,
+	0x0cc00000, 0x00400000, 0x0aa44133, 0x0aa0c033, 0x0c7fff00,
+	0x0680001b, 0x0649cf1c, 0x0bee405c, 0x064c431c, 0x0ae0ffdc,
+	0x0c7ffd80, 0x0680001b, 0x064c411c, 0x0968c71c, 0x0a40bc9c,
+	0x04000c9c, 0x0b60c19b, 0x0c7ffbc0, 0x040016db, 0x0809c006,
+	0x08007401, 0x06bfffb3, 0x06030433, 0x0c7ffa40, 0x06800133,
+	0x0649c91c, 0x0400171c, 0x0609c91c, 0x0c7ff900, 0x0680001b,
+	0x07801949, 0x0a212009, 0x09c091c9, 0x0c7a8780, 0x07c01949,
+	0x00800000, 0x07802d49, 0x0c7ff6c0, 0x06030409, 0x06bf9b89,
+	0x06030409, 0x00400000, 0x064c4309, 0x05801249, 0x0baf9809,
+	0x00000000, 0x0a2c0047, 0x07802bc9, 0x0aa14009, 0x0a608049,
+	0x0c7a08c0, 0x0a6080c9, 0x0c79f700, 0x0a208807, 0x0c782680,
+	0x0be15007, 0x0a208207, 0x0c7845c0, 0x0cb8001a, 0x00000000,
+	0x0c000280, 0x00000000, 0x06bfffca, 0x07903c08, 0x0a402288,
+	0x0c784580, 0x0be08207, 0x0c7ffdc0, 0x0c784300, 0x00000000,
+	0x0649cd09, 0x04001249, 0x0609cd09, 0x0c000780, 0x064c380e,
+	0x064c0809, 0x064c090b, 0x0680040a, 0x063f000a, 0x0680000a,
+	0x063f000a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x060c0809, 0x060c090b, 0x0688000a, 0x060c290a, 0x0c0005c0,
+	0x00000000, 0x0680000a, 0x060c0c0a, 0x06c0404a, 0x060c0d0a,
+	0x080c0101, 0x0684044a, 0x060c2e0a, 0x060c380e, 0x0c001780,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0aa18009,
+	0x0649470a, 0x0910828a, 0x07802cc8, 0x0a4fc20a, 0x04401249,
+	0x0cc00000, 0x00000000, 0x0c00a580, 0x00000000, 0x06490b09,
+	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
+	0x06090b09, 0x08095007, 0x08095000, 0x0683ffc9, 0x06498f0a,
+	0x0aa0c009, 0x0a6f800a, 0x04401249, 0x064c3d0a, 0x0580a28a,
+	0x0bef80ca, 0x00000000, 0x06498e0a, 0x0980a00a, 0x068007c9,
+	0x09706289, 0x06098e0a, 0x06800009, 0x09706289, 0x09c0a00a,
+	0x0cc00000, 0x06098e0a, 0x0200ad0a, 0x0603510a, 0x06035209,
+	0x0603500b, 0x0643500c, 0x0580f30c, 0x0bef804c, 0x00000000,
+	0x0643530c, 0x0900c30c, 0x0a6f800c, 0x00000000, 0x0cc00000,
+	0x0240ad0a, 0x0200a64a, 0x0603410a, 0x06810009, 0x06034209,
+	0x06a2000b, 0x06c001cb, 0x0603400b, 0x0643400c, 0x0580f30c,
+	0x0bef804c, 0x0cc00000, 0x00000000, 0x08032100, 0x0200a64a,
+	0x0603410a, 0x06810009, 0x06034209, 0x06a3000b, 0x06c001cb,
+	0x0603400b, 0x0643400c, 0x0580f30c, 0x0bef804c, 0x06840008,
+	0x063f0008, 0x06800008, 0x063f0008, 0x08002a09, 0x08002b17,
+	0x06830008, 0x06032608, 0x08032261, 0x06800048, 0x06c00088,
+	0x06032108, 0x0cc00000, 0x00000000, 0x0680004a, 0x060e0c0a,
+	0x07c026ca, 0x07c0250a, 0x068003ca, 0x07c0280a, 0x06805c0a,
+	0x060c210a, 0x080c2170, 0x0680008a, 0x07c02a4a, 0x06800018,
+	0x0680000a, 0x0cc00000, 0x07c0248a, 0x0a25d007, 0x0680004a,
+	0x0c07e540, 0x07c01e4a, 0x064c000a, 0x09c0a18a, 0x0980a20a,
+	0x0980a00a, 0x060c000a, 0x064c2908, 0x09c08348, 0x09808208,
+	0x060c2908, 0x09808348, 0x09c08208, 0x060c2908, 0x064c080a,
+	0x0980a34a, 0x060c080a, 0x0c07e340, 0x00000000, 0x0c07f700,
+	0x00000000, 0x080c0600, 0x0fc081c0, 0x0649cf0a, 0x0a21500a,
+	0x0a611e47, 0x0be0c40a, 0x0c780dc0, 0x00000000, 0x090a2207,
+	0x07c02048, 0x0481f1c7, 0x07c02007, 0x0aa38147, 0x0aa34047,
+	0x0a60c187, 0x0c781040, 0x0681d88d, 0x0a60c1c7, 0x0c780f80,
+	0x0682000d, 0x0a60c207, 0x0c780ec0, 0x0682744d, 0x0a608247,
+	0x0c780740, 0x0c781400, 0x0c78f240, 0x00000000, 0x064c4408,
+	0x09101208, 0x0aaf8048, 0x064c5109, 0x064c460a, 0x07801a48,
+	0x05410208, 0x07801a0b, 0x020082c8, 0x0580a208, 0x06031f08,
+	0x06033f09, 0x0c07b640, 0x08031e15, 0x06431f08, 0x06433f09,
+	0x09708209, 0x0540a208, 0x02008288, 0x064c4309, 0x02408248,
+	0x064c4009, 0x02408248, 0x0cc00000, 0x0440a208, 0x0c07f9c0,
+	0x00000000, 0x07c00bc8, 0x05810208, 0x07c00c08, 0x06800048,
+	0x0c780b80, 0x07c00c48, 0x0c07f7c0, 0x00000000, 0x07800909,
+	0x0780094a, 0x0961024a, 0x0609c209, 0x0680a149, 0x02008248,
+	0x07c00908, 0x05810208, 0x07c00948, 0x07807188, 0x0609c108,
+	0x0809c00a, 0x08007401, 0x0649c008, 0x0a6fc008, 0x0c7806c0,
+	0x00000000, 0x07803bc8, 0x090821c8, 0x0aa18047, 0x06800047,
+	0x09482207, 0x0680000a, 0x0c07d7c0, 0x06c0000a, 0x0cb8000d,
+	0x07c03bc8, 0x064c2907, 0x0be14407, 0x064c2307, 0x0bef4047,
+	0x0cc00000, 0x064c2007, 0x0cc00000, 0x06800007, 0x040011c7,
+	0x06800008, 0x0a20c047, 0x058011c7, 0x024071c8, 0x0cc00000,
+	0x00000000, 0x064c0007, 0x0a2fc047, 0x00000000, 0x064c3a07,
+	0x090061c7, 0x0aaec647, 0x00000000, 0x080c0a01, 0x080c2800,
+	0x080c0002, 0x0c7fb100, 0x00000000, 0x0684000a, 0x0c07cfc0,
+	0x06c0000a, 0x069fffc2, 0x07c03b42, 0x07c03b82, 0x07c03c42,
+	0x07c00a02, 0x07c00a42, 0x07c00a82, 0x07c03c82, 0x07c01742,
+	0x07c017c2, 0x068003c2, 0x07c02fc2, 0x064c1e02, 0x098025c2,
+	0x060c1e02, 0x064c1e02, 0x09802702, 0x060c1e02, 0x0680c002,
+	0x06094002, 0x06803003, 0x06804002, 0x0d000003, 0x06094102,
+	0x06800002, 0x06094002, 0x0c000680, 0x00000000, 0x064c1e02,
+	0x098025c2, 0x060c1e02, 0x08002501, 0x08002609, 0x08002708,
+	0x0800290d, 0x08002d15, 0x08002c14, 0x0649b802, 0x06800fc3,
+	0x09508083, 0x0609b802, 0x08002609, 0x08002b17, 0x06830002,
+	0x06032602, 0x08032261, 0x06800042, 0x06c00082, 0x06032102,
+	0x06800032, 0x0cc00000, 0x0680001b, 0x06800203, 0x07c03bc3,
+	0x06800712, 0x06800033, 0x07c02bf3, 0x07c01933, 0x07c01973,
+	0x07c01df3, 0x07c01e33, 0x0649c203, 0x0a654003, 0x06800803,
+	0x068f000a, 0x06c0470a, 0x06810002, 0x06800049, 0x06a02bcb,
+	0x0c07ba80, 0x00000000, 0x0d07ff83, 0x0200a08a, 0x06804003,
+	0x06af000a, 0x06c0470a, 0x06808002, 0x06800049, 0x06a02bcb,
+	0x0c07b800, 0x00000000, 0x0d07ff83, 0x0200a08a, 0x064e1203,
+	0x091e10c3, 0x0bef8043, 0x064c0903, 0x06803002, 0x063f0002,
+	0x06800002, 0x063f0002, 0x06803fc2, 0x060c0903, 0x06800002,
+	0x060c0c02, 0x06c04042, 0x060c0d02, 0x080c0101, 0x06840442,
+	0x060c2e02, 0x06bfffc2, 0x07c00ac2, 0x064c4010, 0x064c4211,
+	0x02411411, 0x04008451, 0x07c01a11, 0x05810451, 0x07c01a51,
+	0x064c1e02, 0x09802702, 0x060c1e02, 0x064e0e02, 0x09802242,
+	0x060e0e02, 0x0cc00000, 0x00000000, 0x07802bc2, 0x0aa0c002,
+	0x06800102, 0x06030502, 0x0b60c11b, 0x0cc00000, 0x00000000,
+	0x00800000, 0x00000000, 0x0c079a40, 0x00000000, 0x080c0a01,
+	0x080c2800, 0x080c0002, 0x0cc00000, 0x00400000, 0x064c441c,
+	0x0910171c, 0x0a6f801c, 0x0c7f8640, 0x00000000, 0x0cc00000,
+	0x00400000, 0x064e1214, 0x091e1514, 0x0bef0054, 0x078029d5,
+	0x0649d914, 0x0900c514, 0x0acfe554, 0x07802494, 0x0aa50094,
+	0x0aa08194, 0x0c782d00, 0x0c7824c0, 0x07802715, 0x06800015,
+	0x06c04015, 0x07802857, 0x097c1557, 0x060e1215, 0x07802d15,
+	0x0a20c055, 0x06800018, 0x06900018, 0x06c046d8, 0x02018d18,
+	0x06800014, 0x07c02a94, 0x0c782540, 0x06800114, 0x07802a95,
+	0x0aa08095, 0x0c781340, 0x078024d6, 0x0aeb4096, 0x07802857,
+	0x0aa4c712, 0x07802ad4, 0x05406514, 0x07802d15, 0x05801555,
+	0x0be0c055, 0x06800015, 0x06900015, 0x06c046d5, 0x02015d15,
+	0x02014554, 0x04440514, 0x060e1314, 0x0aa44017, 0x040c0614,
+	0x06805c16, 0x060c2116, 0x0c780340, 0x04040618, 0x05405514,
+	0x07802d15, 0x0be0c055, 0x06800015, 0x06900015, 0x06c046d5,
+	0x02015d15, 0x02014554, 0x04420514, 0x060e1314, 0x04060614,
+	0x07802596, 0x0aa14016, 0x06a2c215, 0x0aa0c056, 0x06a2c015,
+	0x06a2c115, 0x0aa10017, 0x06c04015, 0x068003d4, 0x09506554,
+	0x097c1557, 0x060e1215, 0x064e0e14, 0x098142d4, 0x060e0e14,
+	0x06800014, 0x07c02a94, 0x06800114, 0x0c781ec0, 0x07c02494,
+	0x078025d5, 0x078029d6, 0x0e000595, 0x05401516, 0x07802857,
+	0x0aa0c017, 0x02014594, 0x02014594, 0x0f000540, 0x02415515,
+	0x07802694, 0x05409514, 0x02014554, 0x05403554, 0x02015d15,
+	0x060e1315, 0x07802596, 0x0aa34016, 0x06a44215, 0x0aa2c056,
+	0x06a44015, 0x0c780240, 0x06a44115, 0x0a6580d5, 0x078026d4,
+	0x064e0c16, 0x09010596, 0x0b8e5594, 0x0cc00000, 0x00400000,
+	0x0aa10017, 0x06c0c015, 0x068005d4, 0x09506554, 0x097c1557,
+	0x060e1215, 0x064e0e14, 0x098142d4, 0x060e0e14, 0x06800018,
+	0x06800014, 0x07c02a94, 0x06800154, 0x0c781380, 0x07c02494,
+	0x07802515, 0x0aa1c015, 0x04401555, 0x07c02515, 0x078024d5,
+	0x04401555, 0x0c780f80, 0x07c024d5, 0x07802615, 0x078029d6,
+	0x0e000595, 0x07c02655, 0x04001515, 0x07c02614, 0x0f000540,
+	0x07802694, 0x05409514, 0x02014554, 0x05403554, 0x02015d15,
+	0x060e1315, 0x07802596, 0x0aa14016, 0x06b16215, 0x0aa0c056,
+	0x06b16015, 0x06b16115, 0x07803056, 0x0aa2c016, 0x078026d4,
+	0x064e0c16, 0x09010596, 0x0b805594, 0x07c02715, 0x06800194,
+	0x0c7fd680, 0x07c02494, 0x04001514, 0x07c026d4, 0x07c02715,
+	0x06c00015, 0x060e1215, 0x06800054, 0x0c780840, 0x07c02494,
+	0x0ba74114, 0x07802855, 0x0a608015, 0x0c7ff400, 0x078026d5,
+	0x04001555, 0x07c026d5, 0x0aa0c114, 0x06800015, 0x080c2170,
+	0x0c7804c0, 0x07c02855, 0x064e0e14, 0x09814314, 0x0cc00000,
+	0x060e0e14, 0x0a6c0054, 0x078024d5, 0x0a608015, 0x0c780900,
+	0x04401555, 0x0b2f8055, 0x07c024d5, 0x0c07fd40, 0x00000000,
+	0x07802a54, 0x0aa0c0d4, 0x00000000, 0x080c2170, 0x06800014,
+	0x07c02494, 0x0cc00000, 0x00400000, 0x091c1518, 0x0aa0c014,
+	0x06900018, 0x06800018, 0x06c046d8, 0x0c780bc0, 0x02018d18,
+	0x0aa0c712, 0x090a8518, 0x090c7518, 0x07802c56, 0x0b829594,
+	0x0a8f4594, 0x0f000540, 0x064e0e14, 0x098142d4, 0x060e0e14,
+	0x091c1518, 0x0aa28014, 0x06900018, 0x0c780200, 0x06800018,
+	0x078025d5, 0x078029d6, 0x0aa70018, 0x0e000595, 0x0c7ffb40,
+	0x00000000, 0x06c046d8, 0x02018d18, 0x07802694, 0x05409514,
+	0x078029d6, 0x02415595, 0x02014554, 0x05403554, 0x02015d15,
+	0x060e1315, 0x07802714, 0x09004554, 0x0aa14015, 0x06a14214,
+	0x0aa0c115, 0x06a14014, 0x06a14114, 0x06c08014, 0x060e0d18,
+	0x0aa0c712, 0x04020618, 0x04020618, 0x0c7ff300, 0x060e1214,
+	0x07802694, 0x05409514, 0x0f000540, 0x02014554, 0x078025d5,
+	0x04001555, 0x07c025d5, 0x05403554, 0x02015d15, 0x060e1315,
+	0x07802714, 0x0a618018, 0x09c141d4, 0x060e1214, 0x068000d4,
+	0x0c7feec0, 0x07c02494, 0x06c08014, 0x09c14394, 0x060e0d18,
+	0x0aae4712, 0x04020618, 0x0c7ffdc0, 0x04020618, 0x0683ffca,
+	0x0a61000a, 0x0440128a, 0x0c780140, 0x080e1200, 0x064e1209,
+	0x091e1249, 0x0bee8049, 0x064e0009, 0x064e030a, 0x064e0e0b,
+	0x064e0c0c, 0x083f0040, 0x083f0000, 0x064c180d, 0x0980d20d,
+	0x060c180d, 0x09c0d20d, 0x060c180d, 0x0680020d, 0x0d00000d,
+	0x00000000, 0x060e0009, 0x060e030a, 0x060e0e0b, 0x0cc00000,
+	0x060e0c0c, 0x0c000cc0, 0x00000000, 0x06810109, 0x06c34749,
+	0x06090709, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
+	0x09c09009, 0x09c09089, 0x06090b09, 0x06800009, 0x06c046c9,
+	0x02009d09, 0x06094409, 0x06900009, 0x06c046c9, 0x02009d09,
+	0x06094509, 0x0cc00000, 0x00000000, 0x0c000e00, 0x00000000,
+	0x06497f08, 0x068000c7, 0x09702207, 0x09808688, 0x06097f08,
+	0x06498e08, 0x09c080c8, 0x06098e08, 0x07802c47, 0x0b20c187,
+	0x00000000, 0x098080c8, 0x09c08788, 0x06098e08, 0x06820888,
+	0x06c00208, 0x068001c9, 0x07802c47, 0x0b20c407, 0x06800447,
+	0x06800c07, 0x09706207, 0x09808648, 0x06095108, 0x06095009,
+	0x0cc00000, 0x08095000, 0x0683ffc8, 0x06490909, 0x0a210049,
+	0x0aa0c008, 0x0c7fff40, 0x04401208, 0x0683ffc8, 0x06490909,
+	0x09343249, 0x0a2241c9, 0x0aa20008, 0x06490b09, 0x098090c9,
+	0x06090b09, 0x09c090c9, 0x06090b09, 0x0c7ffdc0, 0x04401208,
+	0x06490b09, 0x09809009, 0x09809089, 0x06090b09, 0x09c09009,
+	0x09c09089, 0x06090b09, 0x0cc00000, 0x00000000, 0x0683ffc9,
+	0x0649bb08, 0x0920c208, 0x06495307, 0x090011c7, 0x020081c8,
+	0x0aa10008, 0x0aa0c009, 0x0c7ffe40, 0x04401249, 0x0cc00000,
+	0x00000000, 0x04000289, 0x02408289, 0x0b64a008, 0x00000000,
+	0x0c077080, 0x080c2301, 0x02408289, 0x0b60d008, 0x00000000,
+	0x07400247, 0x0aa280c7, 0x04001249, 0x0c076e80, 0x080c2301,
+	0x02408289, 0x0b60d008, 0x00000000, 0x07400247, 0x0c7ffbc0,
+	0x04001249, 0x068000c7, 0x0404028a, 0x07400287, 0x0cc00000,
+	0x00000000, 0x0680000a, 0x04001249, 0x0fc011c0, 0x0aa20047,
+	0x0680004b, 0x06494207, 0x090841c7, 0x0340b1cb, 0x054082cb,
+	0x0c780340, 0x0609410b, 0x0c076880, 0x080c2301, 0x0c076a00,
+	0x00000000, 0x040002c7, 0x0c076740, 0x080c2301, 0x0c0768c0,
+	0x00000000, 0x095091cb, 0x06094107, 0x0fc011c0, 0x0aa24047,
+	0x0680004b, 0x06494207, 0x091041c7, 0x0340b1cb, 0x054082cb,
+	0x0609410b, 0x0c780600, 0x0609410b, 0x0c076340, 0x080c2301,
+	0x0c0764c0, 0x00000000, 0x040002c7, 0x0c076200, 0x080c2301,
+	0x0c076380, 0x00000000, 0x095091cb, 0x06094107, 0x0c076080,
+	0x080c2301, 0x0c076200, 0x00000000, 0x040002c7, 0x0c075f40,
+	0x080c2301, 0x0c0760c0, 0x00000000, 0x095091cb, 0x06094107,
+	0x0400128a, 0x0b8cb24a, 0x0cc00000, 0x00000000, 0x0649c707,
+	0x0aa28007, 0x044011c7, 0x0809c700, 0x06804008, 0x054031c7,
+	0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8, 0x074001c8,
+	0x0649c807, 0x0aa28007, 0x044011c7, 0x0809c800, 0x06804008,
+	0x054031c7, 0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8,
+	0x074001c8, 0x0cc00000, 0x00000000, 0x0200d308, 0x0440134d,
+	0x0700034d, 0x0540234d, 0x0200d349, 0x0700034e, 0x0400040e,
+	0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d, 0x09408390,
+	0x09508390, 0x09608390, 0x09708390, 0x06800210, 0x0d000010,
+	0x060c220e, 0x0cc00000, 0x00000000, 0x0649cd09, 0x06800047,
+	0x054101c7, 0x020091c9, 0x0609cd09, 0x069fffc7, 0x07c03b47,
+	0x07c03b87, 0x07c03c47, 0x07c00a07, 0x07c00a47, 0x07c00a87,
+	0x07c03c87, 0x07c01747, 0x06800207, 0x0c7f51c0, 0x07c03bc7,
+	0x07803c0a, 0x0a60c00a, 0x0c780c80, 0x0680004a, 0x07802dca,
+	0x0aa0800a, 0x0c780b80, 0x0649cf07, 0x0a2180c7, 0x07803c07,
+	0x0aa0c007, 0x0680004a, 0x0680000a, 0x0c7809c0, 0x07807347,
+	0x07801f48, 0x0a803207, 0x0c7808c0, 0x0680004a, 0x07802407,
+	0x07801f08, 0x0a803207, 0x0c780780, 0x0680004a, 0x07802047,
+	0x07802e08, 0x02009207, 0x0aa18009, 0x0a803247, 0x0a802248,
+	0x0c7800c0, 0x0c780540, 0x0680004a, 0x07802007, 0x07802e48,
+	0x0a803207, 0x0c780400, 0x0680004a, 0x0a618147, 0x07801f87,
+	0x07801fc8, 0x0a803207, 0x0c780280, 0x0680004a, 0x07802147,
+	0x0aa1c087, 0x07801807, 0x0a4033c7, 0x07801847, 0x0a803407,
+	0x0c780080, 0x0680004a, 0x0cc00000, 0x07c02dca, 0x06490908,
+	0x0581f208, 0x0a6f8008, 0x00000000, 0x06490708, 0x09808648,
+	0x09c08488, 0x06090708, 0x068400c8, 0x096e820b, 0x097e120a,
+	0x07802407, 0x040011c7, 0x048031c7, 0x09542207, 0x0580124a,
+	0x06094809, 0x06094908, 0x06800008, 0x098092c8, 0x07801987,
+	0x09405247, 0x058051c7, 0x040011c7, 0x097c2207, 0x06094809,
+	0x06094908, 0x0c07be00, 0x00000000, 0x06490708, 0x09c08648,
+	0x09808488, 0x06090708, 0x0cc00000, 0x00000000, 0x0649cf07,
+	0x06800048, 0x0a2100c7, 0x07c01e48, 0x0cc00000, 0x00000000,
+	0x07801988, 0x0aa0c008, 0x0a210807, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0c07b900, 0x00000000, 0x0c07b140, 0x00000000,
+	0x0680001b, 0x0780294e, 0x0a61038e, 0x07802c4e, 0x0c780380,
+	0x0980b00b, 0x0ae6011b, 0x0c07f180, 0x00000000, 0x0400128a,
+	0x0b80438a, 0x00000000, 0x0680000a, 0x040012cb, 0x0b8f834b,
+	0x0b8f730a, 0x0c780380, 0x00000000, 0x0ae3011b, 0x0c07ee80,
+	0x044012cb, 0x0c07ee00, 0x040012cb, 0x0400128a, 0x0b80438a,
+	0x00000000, 0x0680000a, 0x040022cb, 0x0b8f634b, 0x0b8f530a,
+	0x0cc00000, 0x0680001b, 0x07803c07, 0x07802e88, 0x0a402207,
+	0x0c7809c0, 0x07c02e87, 0x07802c49, 0x0780294a, 0x0a60c30a,
+	0x07802c8a, 0x0540128a, 0x06800008, 0x0b80a247, 0x095084c7,
+	0x02407247, 0x0b8fd288, 0x04001208, 0x0649cd07, 0x040011c7,
+	0x0609cd07, 0x0cc00000, 0x06800047, 0x0aa0c007, 0x06800049,
+	0x07c02d89, 0x0aa0c712, 0x07c02cc7, 0x05401208, 0x094084c8,
+	0x07c02d08, 0x0780188a, 0x078018cb, 0x07802ccc, 0x07802d0d,
+	0x0c07ebc0, 0x06800009, 0x07802cc7, 0x0aa18007, 0x044011c7,
+	0x0ba0c707, 0x0c7fffc0, 0x0441c1c7, 0x07c02b07, 0x07802cc7,
+	0x07c01887, 0x07802d07, 0x07c018c7, 0x0cc00000, 0x06800007,
+	0x0c780380, 0x06800087, 0x0c780300, 0x06800147, 0x0c780280,
+	0x06800187, 0x0c071dc0, 0x080c2301, 0x07c03c07, 0x0c071d00,
+	0x080c2301, 0x0aad41c7, 0x0aad8007, 0x0aadc047, 0x07c01ec7,
+	0x07803bc8, 0x09061248, 0x07c02dc9, 0x0a250208, 0x07803c08,
+	0x0aa08008, 0x0c7f1dc0, 0x0649cf09, 0x0a20c0c9, 0x0aa2c087,
+	0x0c7f1cc0, 0x07802008, 0x0aa20148, 0x07801c48, 0x0a614008,
+	0x0aa08087, 0x0c7f1b40, 0x06800048, 0x07c01c48, 0x07c01c08,
+	0x0649c909, 0x04001249, 0x0609c909, 0x06800009, 0x07c01d89,
+	0x0c079a00, 0x00000000, 0x0c07a040, 0x00000000, 0x0c071440,
+	0x080c2301, 0x07803b8d, 0x0a806347, 0x07803bc8, 0x06800049,
+	0x07c02dc9, 0x0c780080, 0x07c03b87, 0x09082248, 0x0aa1c049,
+	0x0680000a, 0x0c06e800, 0x06c0000a, 0x06800049, 0x09482209,
+	0x07c03bc8, 0x06af000a, 0x06c0470a, 0x054091c7, 0x0200a1ca,
+	0x06804009, 0x06b0c00b, 0x0c06e1c0, 0x00000000, 0x0780c007,
+	0x06905348, 0x0a803207, 0x0c7f1100, 0x07c03b8d, 0x0780c047,
+	0x09105207, 0x07803b4e, 0x0a803388, 0x0c7802c0, 0x07c03b48,
+	0x07803bc7, 0x0be20047, 0x068c000a, 0x06c0470a, 0x06808009,
+	0x06b0400b, 0x0c06dd00, 0x00000000, 0x0c780900, 0x068f000a,
+	0x06c0470a, 0x07803b48, 0x0540a1c8, 0x0200a1ca, 0x06806009,
+	0x06b0400b, 0x0c06da80, 0x00000000, 0x07804007, 0x06905348,
+	0x0a805207, 0x00000000, 0x07c03b8d, 0x0c7f0940, 0x07c03b4e,
+	0x0680000a, 0x0c00f000, 0x00000000, 0x0c016900, 0x00000000,
+	0x07803bc7, 0x0be34107, 0x068c000a, 0x06c0470a, 0x06804009,
+	0x06b0400b, 0x0c06d580, 0x00000000, 0x068cc00a, 0x06c0470a,
+	0x06802009, 0x06b0a00b, 0x0c06d400, 0x00000000, 0x0c012f40,
+	0x00000000, 0x07803bc7, 0x0be34107, 0x068d000a, 0x06c0470a,
+	0x06804009, 0x06b0c00b, 0x0c06d180, 0x00000000, 0x0c780180,
+	0x068c000a, 0x06c0470a, 0x0680c009, 0x0c06d000, 0x06b0400b,
+	0x078020c8, 0x0f8001c8, 0x0649cf0a, 0x0be5808a, 0x07803bca,
+	0x0be5020a, 0x0780200a, 0x0aa4814a, 0x07801f4a, 0x0a810287,
+	0x0400128a, 0x06800049, 0x03409209, 0x04401249, 0x0280a289,
+	0x0a80a287, 0x0780394a, 0x0a62000a, 0x07801eca, 0x0a61008a,
+	0x0680004a, 0x0c780100, 0x07c00b8a, 0x0680004a, 0x07c00b4a,
+	0x07c01f47, 0x07802107, 0x0a61c007, 0x068000c9, 0x0fc011c0,
+	0x0aa10007, 0x00000000, 0x0fc011c0, 0x04001247, 0x07c01f09,
+	0x07802007, 0x0a614147, 0x00000000, 0x0c06f2c0, 0x080c2301,
+	0x07c01f87, 0x07802147, 0x0a65c007, 0x07802187, 0x0f8001c7,
+	0x07807388, 0x07c01808, 0x07c07387, 0x078074c7, 0x07c01847,
+	0x06800007, 0x07c074c7, 0x07c07507, 0x078021c7, 0x0aa2c007,
+	0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06edc0, 0x080c2301,
+	0x0c06ef40, 0x00000000, 0x07c074c7, 0x058101c7, 0x07c07507,
+	0x0780738f, 0x078074d0, 0x07802147, 0x06800048, 0x0a422207,
+	0x07807547, 0x07c01807, 0x078075c7, 0x07c01847, 0x06800007,
+	0x07c07547, 0x07c07587, 0x07c075c7, 0x07c07607, 0x07803a87,
+	0x0aa54047, 0x00000000, 0x0c06e7c0, 0x080c2301, 0x0c06e940,
+	0x00000000, 0x07c07547, 0x058101c7, 0x07c07587, 0x078021c7,
+	0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06e4c0,
+	0x080c2301, 0x0c06e640, 0x00000000, 0x07c075c7, 0x058101c7,
+	0x07c07607, 0x0780754f, 0x078075d0, 0x0c079500, 0x00000000,
+	0x07802dc7, 0x0a608007, 0x0c782180, 0x07801e87, 0x069fffc8,
+	0x0b803207, 0x040011c7, 0x06800147, 0x07c01e87, 0x07802d07,
+	0x078023c8, 0x0b802207, 0x0c780200, 0x0780188a, 0x078018cb,
+	0x0680000c, 0x078023cd, 0x06800049, 0x0c07a640, 0x07c01e49,
+	0x07801d08, 0x0649cf09, 0x0aa28008, 0x07803c0a, 0x0aa0800a,
+	0x0c781bc0, 0x04401208, 0x07c01d08, 0x0aa08008, 0x0c781ac0,
+	0x09c09089, 0x0609cf09, 0x0a22c309, 0x0780204a, 0x0a62400a,
+	0x07802e0a, 0x0aa1c00a, 0x07801f0a, 0x0aa0c0ca, 0x0680004a,
+	0x0680008a, 0x0c7817c0, 0x07c01d0a, 0x0680000a, 0x07c01d0a,
+	0x0688000a, 0x0c06b040, 0x06c0000a, 0x07803bc7, 0x0be54107,
+	0x068001ca, 0x06031e0a, 0x0680001b, 0x0649ce09, 0x0aa10009,
+	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee4049,
+	0x00000000, 0x0649cf07, 0x0a2200c7, 0x07801d87, 0x0aa18007,
+	0x07801ec7, 0x0aa10087, 0x06800207, 0x0c7ed4c0, 0x07c03bc7,
+	0x06800013, 0x07c02cd3, 0x07c02d13, 0x07c02e93, 0x07c01893,
+	0x07c018d3, 0x06803fc7, 0x07c02b07, 0x06800007, 0x07c02547,
+	0x07c025c7, 0x07c02607, 0x07802c07, 0x040011c7, 0x07c024c7,
+	0x06800047, 0x060e0c07, 0x07c026c7, 0x07c02507, 0x068003c7,
+	0x07c02807, 0x06805c07, 0x060c2107, 0x080c2170, 0x06800087,
+	0x07c02a47, 0x06800018, 0x07801ec7, 0x0a61c087, 0x06800007,
+	0x07800b48, 0x0aa1c008, 0x06800088, 0x0c780140, 0x07c00b48,
+	0x07800b47, 0x07801e48, 0x02c07207, 0x07c01e47, 0x068003c7,
+	0x07c02fc7, 0x06800407, 0x060c2407, 0x06800007, 0x07807048,
+	0x06804009, 0x05403287, 0x0200a289, 0x0400128a, 0x0700028b,
+	0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a, 0x0700028c,
+	0x096102cc, 0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a,
+	0x0700028c, 0x096102cc, 0x060c220b, 0x040011c7, 0x0b8ee207,
+	0x00000000, 0x07801d07, 0x0aa08007, 0x0c7ec340, 0x06800007,
+	0x07c01947, 0x06a00007, 0x060c3d07, 0x07802dc7, 0x0a618007,
+	0x00000000, 0x0c079240, 0x00000000, 0x0aa08007, 0x0c7ec080,
+	0x07802047, 0x07c02e07, 0x07802007, 0x07c02e47, 0x07801ec7,
+	0x07c02087, 0x07801f47, 0x07c07347, 0x07801f07, 0x07c02407,
+	0x07801f87, 0x07c01fc7, 0x0780248a, 0x0a6fc00a, 0x00000000,
+	0x0c0730c0, 0x00000000, 0x07802dc7, 0x0aa10007, 0x00000000,
+	0x0c0728c0, 0x00000000, 0x0c073480, 0x00000000, 0x07802087,
+	0x06840009, 0x0682629a, 0x0aa1c087, 0x06800008, 0x0682305a,
+	0x0aa10147, 0x06800048, 0x06800088, 0x06840009, 0x07c02788,
+	0x07c02689, 0x06800007, 0x07c02a87, 0x07802c8a, 0x07802107,
+	0x0a630007, 0x07802409, 0x0aa280c9, 0x0540128a, 0x0580128a,
+	0x06490707, 0x09807087, 0x098070c7, 0x06090707, 0x06495107,
+	0x098073c7, 0x06095107, 0x07c023ca, 0x07802947, 0x094421c9,
+	0x07c02947, 0x0a648387, 0x068000c9, 0x06495107, 0x094041c9,
+	0x06800009, 0x097821c9, 0x06095107, 0x06490707, 0x09807447,
+	0x06090707, 0x06498e07, 0x09807787, 0x09c070c7, 0x06098e07,
+	0x07802087, 0x0aa0c087, 0x0682519a, 0x068214da, 0x07803bc8,
+	0x090821c8, 0x0aa18087, 0x06800087, 0x09482207, 0x0690000a,
+	0x0c067f40, 0x06c0000a, 0x0c784b40, 0x07c03bc8, 0x07802dc7,
+	0x0aa18007, 0x00000000, 0x0c077b80, 0x00000000, 0x0aa08007,
+	0x0c7ea9c0, 0x06800007, 0x07803bc8, 0x09082208, 0x0aa10008,
+	0x0684000a, 0x0c067b40, 0x06c0000a, 0x07c03bc7, 0x07802d87,
+	0x0aa34007, 0x07802c47, 0x0b22c2c7, 0x07802cc7, 0x0a614007,
+	0x06495108, 0x09c08608, 0x0c7800c0, 0x07c02d87, 0x09808608,
+	0x06095108, 0x08095017, 0x08095000, 0x0c784380, 0x00000000,
+	0x0540928c, 0x0200a24a, 0x06c046ca, 0x0200ad0a, 0x0400130c,
+	0x0481f30c, 0x07c02b4c, 0x0643500c, 0x0580f30c, 0x0bef804c,
+	0x00000000, 0x0643530c, 0x0900c30c, 0x0a6f800c, 0x00000000,
+	0x0603510a, 0x06803f0a, 0x0603520a, 0x0c792a40, 0x0603500b,
+	0x0cc00000, 0x00000000, 0x07802cc9, 0x07c02ac9, 0x07802889,
+	0x07c03049, 0x07802809, 0x0aa08009, 0x0cc00000, 0x064e0e09,
+	0x09809309, 0x098092c9, 0x0cc00000, 0x060e0e09, 0x06435007,
+	0x0580f1c7, 0x0bef8047, 0x0aa14712, 0x06800007, 0x07802d07,
+	0x050011c7, 0x048011c7, 0x0b60c709, 0x06808008, 0x0680c008,
+	0x0c78eb80, 0x00000000, 0x0c7806c0, 0x07802807, 0x0aaf8387,
+	0x00000000, 0x07802947, 0x0aaec387, 0x064e0407, 0x091c2207,
+	0x0a24c0c8, 0x080c3e07, 0x064c3f07, 0x064c3f09, 0x09004249,
+	0x0581b1c7, 0x0a234047, 0x090241c7, 0x0a210088, 0x0aa20289,
+	0x0aa1c309, 0x0be18087, 0x0a21c048, 0x0aa102c9, 0x0aa0c309,
+	0x0be08047, 0x0c7800c0, 0x06800049, 0x07c01e49, 0x0cc00000,
+	0x00000000, 0x07800dc8, 0x0aa0c048, 0x0c780780, 0x00000000,
+	0x06800008, 0x07c00dc8, 0x07800d89, 0x07801f08, 0x09610248,
+	0x0609d509, 0x0aa18048, 0x0aa20088, 0x00000000, 0x0680774a,
+	0x0c780180, 0x00000000, 0x068077ca, 0x0c7800c0, 0x00000000,
+	0x0680784a, 0x07000288, 0x0400128a, 0x07000289, 0x09610209,
+	0x0609d608, 0x0649d308, 0x098083c8, 0x0609d308, 0x08007401,
+	0x0649d308, 0x0a6fc008, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0680000c, 0x0680002a, 0x064c2907, 0x0a20c407, 0x0c7e8700,
+	0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0200c1cc, 0x064c2907,
+	0x0a20c407, 0x0c7e8540, 0x00000000, 0x0fc081c0, 0x0aaeffc7,
+	0x0202a1ea, 0x0aa5400c, 0x0aa1418c, 0x0462d1cc, 0x0c500880,
+	0x0a61004c, 0x0c780e80, 0x06800047, 0x07c01c47, 0x064c0007,
+	0x0be14207, 0x064c2907, 0x0be0c407, 0x0d07ff2a, 0x0fc081c0,
+	0x064c0007, 0x0be10207, 0x064c2907, 0x0be08407, 0x0c7ff780,
+	0x0c7e7f40, 0x00000000, 0x0c067b00, 0x080c2301, 0x064c232b,
+	0x05810aeb, 0x048ffaeb, 0x068f000a, 0x06c0470a, 0x0540a1c7,
+	0x0200a1ca, 0x06804009, 0x0c064bc0, 0x06b0400b, 0x07804007,
+	0x06905348, 0x0a80f207, 0x0c7e7b00, 0x0c067700, 0x080c2301,
+	0x064c232b, 0x05810aeb, 0x048ffaeb, 0x0fc011c0, 0x0aa14047,
+	0x04001aeb, 0x0fc071c0, 0x04007aeb, 0x07c017c7, 0x0c780140,
+	0x00000000, 0x0680004a, 0x0c005ec0, 0x00000000, 0x048071eb,
+	0x0580322b, 0x0aa14007, 0x06800209, 0x04001208, 0x024071c9,
+	0x0f8001c7, 0x0262a22a, 0x0c57f440, 0x0c7ff280, 0x0680002b,
+	0x07803d0d, 0x0a22830d, 0x07802f87, 0x09005207, 0x04001208,
+	0x0c00cf00, 0x0202b22b, 0x090a5207, 0x04001208, 0x0c00ce00,
+	0x0202b22b, 0x0a21440d, 0x00000000, 0x0fc041c0, 0x07c02fc7,
+	0x04004aeb, 0x0c7ff940, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x07802787, 0x07802408,
+	0x094c21c8, 0x060c0407, 0x080c0a01, 0x07802347, 0x0a610007,
+	0x07802387, 0x0c780b00, 0x060c0a07, 0x0fc071c0, 0x080c2940,
+	0x07802387, 0x09807187, 0x098073c7, 0x060c0a07, 0x09c073c7,
+	0x09807387, 0x0c00b600, 0x060c0a07, 0x07802788, 0x064c0a07,
+	0x091c21c7, 0x0a6f8007, 0x07802a21, 0x06c00021, 0x06800022,
+	0x06c00022, 0x06800023, 0x06c00023, 0x06800024, 0x06c00024,
+	0x06bfffe5, 0x0a628008, 0x07802947, 0x06800309, 0x0aa18387,
+	0x07c029c9, 0x06800189, 0x07c029c9, 0x0c785980, 0x060c0713,
+	0x0c784ac0, 0x06800309, 0x0aa18387, 0x07c029c9, 0x06800189,
+	0x07c029c9, 0x0c7825c0, 0x060c0713, 0x0c780bc0, 0x00000000,
+	0x0c00ad80, 0x080c0600, 0x07802a21, 0x06c00021, 0x06800022,
+	0x06c00022, 0x06800023, 0x06c00023, 0x06800024, 0x06c00024,
+	0x06bfffe5, 0x07802788, 0x0a628008, 0x07802947, 0x06800309,
+	0x0aa18387, 0x07c029c9, 0x06800189, 0x07c029c9, 0x0c7851c0,
+	0x060c0713, 0x0c784300, 0x06800309, 0x0aa18387, 0x07c029c9,
+	0x06800189, 0x07c029c9, 0x0c781e00, 0x060c0713, 0x0c780400,
+	0x00000000, 0x064c0321, 0x064c0322, 0x064c0323, 0x064c0324,
+	0x064c2725, 0x0a224053, 0x07802447, 0x07c02987, 0x0400099d,
+	0x040009de, 0x04000a1f, 0x04000a60, 0x0c781400, 0x060c0713,
+	0x0683ffc7, 0x044011c7, 0x0aa0c007, 0x0780248a, 0x0a6f400a,
+	0x068000ca, 0x07802747, 0x09510287, 0x07802cc7, 0x09708287,
+	0x06031e0a, 0x0aa08007, 0x0c780b00, 0x080c0700, 0x07802a08,
+	0x06c00008, 0x060c0208, 0x06800008, 0x06c00008, 0x060c0208,
+	0x06800008, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06bfffc9, 0x060c0326, 0x060c0327, 0x060c0328,
+	0x060c0329, 0x07802988, 0x09610209, 0x060c2708, 0x080c0701,
+	0x07802a08, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x060c031d, 0x060c031e, 0x060c031f,
+	0x060c0320, 0x0780244a, 0x09610289, 0x060c270a, 0x0c780580,
+	0x060c0713, 0x064c2709, 0x09210249, 0x060c0326, 0x060c0327,
+	0x060c0328, 0x060c0329, 0x07802988, 0x09610209, 0x060c2708,
+	0x080c0701, 0x064c2709, 0x09210249, 0x060c031d, 0x060c031e,
+	0x060c031f, 0x060c0320, 0x07802448, 0x09610209, 0x060c2708,
+	0x060c0713, 0x06431e09, 0x0befc049, 0x07802307, 0x09021247,
+	0x094411c9, 0x04c301c7, 0x0c780f00, 0x060c2507, 0x0683ffc8,
+	0x080c3e01, 0x064c3f07, 0x093e11c7, 0x0aaf4007, 0x064c2307,
+	0x09304247, 0x0aa0c009, 0x0aee4008, 0x04401208, 0x0cc00000,
+	0x00000000, 0x064c0321, 0x064c0322, 0x064c0323, 0x064c0324,
+	0x064c2725, 0x060c0713, 0x09210265, 0x07802cc7, 0x0a638007,
+	0x07802a08, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x06bfffc9, 0x060c031d, 0x060c031e,
+	0x060c031f, 0x060c0320, 0x07802448, 0x09610209, 0x060c2708,
+	0x07802307, 0x09021247, 0x094411c9, 0x04c301c7, 0x060c2507,
+	0x0683ffc9, 0x0780248a, 0x0aa1000a, 0x0aa0c0ca, 0x0a6f4009,
+	0x04401249, 0x068000ca, 0x07802749, 0x09510289, 0x07802cc9,
+	0x09708289, 0x06031e0a, 0x07802807, 0x0c07f140, 0x07c02887,
+	0x0b608008, 0x0c7ddec0, 0x090a1207, 0x090241c7, 0x095211c8,
+	0x0780194b, 0x0aa0c00b, 0x07c02807, 0x0c781040, 0x0aa64247,
+	0x060c2507, 0x0aa64287, 0x0aa58347, 0x0aa1c048, 0x0aa58387,
+	0x0a60c007, 0x0c7801c0, 0x00000000, 0x080c2605, 0x080c2606,
+	0x080c2602, 0x080c260f, 0x080c2603, 0x07802a48, 0x0aa100c8,
+	0x06800089, 0x0c782b80, 0x07c02a49, 0x0780248b, 0x0a6fc00b,
+	0x00000000, 0x07c02a88, 0x0c782a00, 0x07c02a49, 0x080c2602,
+	0x080c260f, 0x080c2603, 0x07802a48, 0x0aa50088, 0x068000c9,
+	0x07802cc8, 0x0aa0c008, 0x0c782780, 0x07c02a49, 0x0aa08712,
+	0x0bef4053, 0x0683ffcb, 0x078026c8, 0x064e0c09, 0x09010249,
+	0x0b804248, 0x0aa0c00b, 0x0c7ffec0, 0x044012cb, 0x06800088,
+	0x068000c9, 0x0680180b, 0x060c210b, 0x0683ffcc, 0x0aa2c00c,
+	0x064e110b, 0x091012cb, 0x0a6f400b, 0x0440130c, 0x064e110b,
+	0x091012cb, 0x0a6e400b, 0x0780248b, 0x0a6dc00b, 0x00000000,
+	0x07c02a88, 0x0c782040, 0x07c02a49, 0x06800007, 0x07c02807,
+	0x060c2507, 0x06431e07, 0x0befc047, 0x068fdfc8, 0x06fcffc8,
+	0x064e0407, 0x02807207, 0x0c7ff140, 0x060e0407, 0x064c0321,
+	0x064c0322, 0x064c2725, 0x0a230053, 0x07802447, 0x07c02987,
+	0x0400099d, 0x040009de, 0x060c0713, 0x07802307, 0x09021247,
+	0x094411c9, 0x04c301c7, 0x0c781640, 0x060c2507, 0x07802cc7,
+	0x0a658007, 0x080c0700, 0x07802a08, 0x06c00008, 0x060c0208,
+	0x080c0200, 0x06bfffc9, 0x060c0326, 0x060c0327, 0x0780298a,
+	0x09610289, 0x060c270a, 0x080c0701, 0x060c0208, 0x080c0200,
+	0x060c031d, 0x060c031e, 0x0780244a, 0x09610289, 0x060c270a,
+	0x0c780480, 0x060c0713, 0x064c2709, 0x09210249, 0x060c0326,
+	0x060c0327, 0x07802988, 0x09610209, 0x060c2708, 0x080c0701,
+	0x064c2709, 0x09210249, 0x060c031d, 0x060c031e, 0x07802448,
+	0x09610209, 0x060c2708, 0x060c0713, 0x07802307, 0x09021247,
+	0x094411c9, 0x04c301c7, 0x060c2507, 0x0780248a, 0x0a6fc00a,
+	0x068000ca, 0x07802749, 0x09510289, 0x07802cc9, 0x09708289,
+	0x0c780900, 0x06031e0a, 0x064c0321, 0x064c0322, 0x064c2725,
+	0x060c0713, 0x09210265, 0x07802cc7, 0x0a618007, 0x07802a08,
+	0x06c00008, 0x060c0208, 0x080c0200, 0x06bfffc9, 0x060c031d,
+	0x060c031e, 0x07802448, 0x09610209, 0x060c2708, 0x07802307,
+	0x09021247, 0x094411c9, 0x04c301c7, 0x060c2507, 0x0683ffc9,
+	0x04401249, 0x0aa10009, 0x0780248a, 0x0aa080ca, 0x0a6f000a,
+	0x068000ca, 0x07802749, 0x09510289, 0x07802cc9, 0x09708289,
+	0x06031e0a, 0x07802807, 0x0c07c200, 0x07c02887, 0x090241c7,
+	0x0b614008, 0x07c02807, 0x06bfffc8, 0x0c7daec0, 0x07c03c08,
+	0x0aa10287, 0x060c2507, 0x080c2602, 0x080c260f, 0x080c2603,
+	0x04c001c7, 0x09807207, 0x060c2107, 0x07802547, 0x0aa14007,
+	0x06a01008, 0x0aa0c047, 0x06a22008, 0x06a40008, 0x06431e09,
+	0x0befc049, 0x06c00108, 0x07802949, 0x0a670389, 0x0a26c053,
+	0x0c075140, 0x00000000, 0x0780288a, 0x0aa1c00a, 0x07802a8a,
+	0x00800000, 0x078026c9, 0x04001249, 0x07c026c9, 0x00400000,
+	0x0b61408a, 0x00000000, 0x080c2170, 0x0c780700, 0x080c260e,
+	0x0683ffca, 0x0440128a, 0x0aa0c00a, 0x07802489, 0x0a6f4009,
+	0x078026c9, 0x04401249, 0x0c008080, 0x07c026c9, 0x0c780440,
+	0x08030580, 0x060e0508, 0x07802a88, 0x06801809, 0x09502248,
+	0x060c2109, 0x080c260e, 0x07c02587, 0x0ba0c087, 0x040011c7,
+	0x06800007, 0x0c074740, 0x07c02547, 0x06800088, 0x07c02488,
+	0x08030580, 0x0c074c80, 0x00000000, 0x07802747, 0x0aa14712,
+	0x040011c7, 0x07802d08, 0x0a20c048, 0x00000000, 0x07c02747,
+	0x0c07ae80, 0x07802b0d, 0x0b608008, 0x0c7fed00, 0x0ba13fcd,
+	0x06800008, 0x0c781780, 0x07c02b08, 0x06808008, 0x0ba1070d,
+	0x0400024d, 0x0441c249, 0x0680c008, 0x05403289, 0x0200a24a,
+	0x02008288, 0x07400225, 0x04001208, 0x092102e1, 0x0740020b,
+	0x04001208, 0x07400221, 0x04001208, 0x07400222, 0x04001208,
+	0x092102e2, 0x0740020b, 0x04001208, 0x07400223, 0x04001208,
+	0x092102e3, 0x0740020b, 0x04001208, 0x07400224, 0x04001208,
+	0x092102e4, 0x0740020b, 0x07802c48, 0x0ac07488, 0x07802cca,
+	0x0aa38712, 0x040002ca, 0x07802d0a, 0x0c7802c0, 0x0942f28b,
+	0x0a61000a, 0x0aa14712, 0x07802d0a, 0x0a20c04a, 0x0a6146c9,
+	0x0400128d, 0x0b60c70d, 0x0680000a, 0x0680070a, 0x07c02b0a,
+	0x0b02d488, 0x0aa0800a, 0x0a67c70a, 0x07802b4a, 0x0a20c04a,
+	0x06a0800b, 0x06a0c00b, 0x06b00009, 0x07802b8c, 0x0540928c,
+	0x0200a24a, 0x06c046ca, 0x0200ad0a, 0x06435009, 0x0580f249,
+	0x0bef8049, 0x00000000, 0x0603510a, 0x06803f0a, 0x0603520a,
+	0x0603500b, 0x0400130c, 0x0481f30c, 0x07c02b8c, 0x07802b4c,
+	0x07802c47, 0x07802ccb, 0x024072c7, 0x0b20c0c7, 0x00000000,
+	0x068000c7, 0x095c2307, 0x07c02b4c, 0x07802b4c, 0x091c22cc,
+	0x0aa2800b, 0x044012cb, 0x095c230b, 0x0a61c00b, 0x07c02b4c,
+	0x0a20c04c, 0x06b0800b, 0x06b0c00b, 0x0c0725c0, 0x06b00009,
+	0x0680001b, 0x07802947, 0x0aa5c387, 0x07802cc7, 0x040011c7,
+	0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88, 0x07802c48,
+	0x0b828207, 0x06800007, 0x07c02cc7, 0x07802d08, 0x04001208,
+	0x078023c9, 0x0b822248, 0x07c02d08, 0x07802487, 0x0a6fc007,
+	0x00000000, 0x06430507, 0x0a2f0107, 0x0c7dc300, 0x064c0007,
+	0x07802d08, 0x0be10048, 0x040011c8, 0x0c780580, 0x07c02d07,
+	0x044011c8, 0x07c02d07, 0x07802cc7, 0x040011c7, 0x07c02cc7,
+	0x07802e88, 0x04001208, 0x07c02e88, 0x07802c48, 0x0b80b207,
+	0x06800007, 0x07c02cc7, 0x07802d08, 0x04002208, 0x078023c9,
+	0x0b805248, 0x07c02d08, 0x06800007, 0x0c7ff880, 0x07c02e87,
+	0x064c3b07, 0x0920c1c7, 0x0b218a07, 0x0680004a, 0x07c01e4a,
+	0x07c01d8a, 0x0680204a, 0x07c0194a, 0x07802cc7, 0x095084c7,
+	0x07802d09, 0x094084c9, 0x07801909, 0x0aa14009, 0x04401249,
+	0x0a60c009, 0x07c01909, 0x0c7ef500, 0x07802c49, 0x0b014489,
+	0x06808008, 0x0a628712, 0x0c780840, 0x00000000, 0x07802d0a,
+	0x0a20c04a, 0x0500128a, 0x040011c7, 0x054011c7, 0x0c780840,
+	0x094011ca, 0x040011c7, 0x0a410247, 0x07802b09, 0x07802d07,
+	0x0a25c047, 0x040021c9, 0x0c7f1a00, 0x06800007, 0x0aa5c712,
+	0x07802d0a, 0x0a2bc04a, 0x04001287, 0x0a4ed24a, 0x0c780480,
+	0x06800007, 0x0c7f15c0, 0x00000000, 0x0a628047, 0x040021c9,
+	0x07802d07, 0x0be1c047, 0x040021c9, 0x0c7f1600, 0x06800047,
+	0x0aadc007, 0x07802b09, 0x040011c9, 0x0ba10707, 0x0b6cce07,
+	0x0680c008, 0x0441c1c7, 0x05403247, 0x020091c9, 0x02008248,
+	0x07000209, 0x07c02449, 0x04001208, 0x07000209, 0x04001208,
+	0x0700021d, 0x09610749, 0x04001208, 0x0700021e, 0x04001208,
+	0x07000209, 0x09610789, 0x04001208, 0x0700021f, 0x04001208,
+	0x07000209, 0x096107c9, 0x04001208, 0x07000220, 0x04001208,
+	0x07000209, 0x09610809, 0x0c7d5a00, 0x00000000, 0x07802dc7,
+	0x0aa18007, 0x07802087, 0x0a614087, 0x00000000, 0x08098002,
+	0x080980f0, 0x0c780a40, 0x080c2400, 0x064c2207, 0x09305207,
+	0x093a2287, 0x09205247, 0x092a22c7, 0x054022cb, 0x02c0a2ca,
+	0x09105347, 0x091a22c7, 0x054042cb, 0x02c0a2ca, 0x09005387,
+	0x090a22c7, 0x054062cb, 0x02c0a2ca, 0x07802087, 0x0a63c187,
+	0x080c2408, 0x064c2207, 0x048032ca, 0x0aa340cb, 0x00000000,
+	0x0480f28a, 0x09305347, 0x093a22c7, 0x054042cb, 0x02c0a2ca,
+	0x09205387, 0x092a22c7, 0x054062cb, 0x02c0a2ca, 0x0c780240,
+	0x00000000, 0x0480328a, 0x09305247, 0x093a22c7, 0x054022cb,
+	0x0c7800c0, 0x02c0a2ca, 0x0c780580, 0x05418208, 0x0609b308,
+	0x0649b308, 0x05418249, 0x0609b309, 0x0649b309, 0x0541834d,
+	0x0609b30d, 0x0649b30d, 0x0541838e, 0x0609b30e, 0x0649b30e,
+	0x08098002, 0x06bfffcb, 0x054102cb, 0x06bfffcc, 0x02c0c2cc,
+	0x0609820c, 0x048032ca, 0x0a6480cb, 0x0c780080, 0x0c780640,
+	0x054102c8, 0x058102cb, 0x05410308, 0x02c0c2cc, 0x0609810c,
+	0x054042ca, 0x0609800b, 0x0a811248, 0x00000000, 0x054102c9,
+	0x058102cb, 0x05410309, 0x02c0c2cc, 0x0c7802c0, 0x0609820c,
+	0x054102c8, 0x058102cb, 0x05410309, 0x02c0c2cc, 0x0609810c,
+	0x054042ca, 0x04c042cb, 0x0c7800c0, 0x0609800b, 0x0c780340,
+	0x048032ca, 0x054182cb, 0x02c0b20b, 0x0483030a, 0x0541430c,
+	0x02c0c34c, 0x0a80630b, 0x054102cd, 0x058102cb, 0x0541030e,
+	0x02c0c2cc, 0x0609820c, 0x0780294b, 0x0a60c38b, 0x06800712,
+	0x05801492, 0x06bfffcb, 0x06800021, 0x07802a1d, 0x0680001e,
+	0x06800022, 0x0680001f, 0x06800023, 0x06800020, 0x06800024,
+	0x0400099d, 0x040009de, 0x04000a1f, 0x04000a60, 0x0680800a,
+	0x0680070e, 0x0740028b, 0x0400128a, 0x074002a1, 0x0400128a,
+	0x0740029d, 0x0400128a, 0x0740029e, 0x0400128a, 0x074002a2,
+	0x0400128a, 0x0740029f, 0x0400128a, 0x074002a3, 0x0400128a,
+	0x074002a0, 0x0400128a, 0x074002a4, 0x0d07fbce, 0x0400128a,
+	0x07c0244b, 0x07c0298b, 0x096102cb, 0x080c0700, 0x060c270b,
+	0x09610761, 0x060c021d, 0x096107a2, 0x0780278e, 0x0aa1800e,
+	0x060c021e, 0x096107e3, 0x060c021f, 0x09610824, 0x060c0220,
+	0x080c0701, 0x060c270b, 0x060c021d, 0x0aa1000e, 0x060c021e,
+	0x060c021f, 0x060c0220, 0x07802c4e, 0x0b00948e, 0x06b00007,
+	0x06c046c7, 0x02007d07, 0x06035107, 0x06803f07, 0x06035207,
+	0x06a08007, 0x06035007, 0x07802cc7, 0x0aa24007, 0x06803fc7,
+	0x07802947, 0x0aa1c387, 0x07802cc7, 0x044011c7, 0x0ba0c707,
+	0x0c7fffc0, 0x0441c1c7, 0x07c02b07, 0x06800007, 0x07c02747,
+	0x0ac0b48e, 0x07802b07, 0x0b613fc7, 0x0ba0c707, 0x0441c1c7,
+	0x07c02b07, 0x06435007, 0x0580f1c7, 0x0bef8047, 0x0cc00000,
+	0x00000000, 0x06435007, 0x0580f1c7, 0x0bef8047, 0x00000000,
+	0x06435307, 0x0900c1c7, 0x0a6f8007, 0x06b00007, 0x06c046c7,
+	0x02007d07, 0x06035107, 0x06803f07, 0x06035207, 0x06b0c007,
+	0x06035007, 0x054011d2, 0x0ac051ce, 0x06800087, 0x07c02b47,
+	0x0c7ff8c0, 0x07c02b87, 0x06b10008, 0x06c046c8, 0x02008d08,
+	0x05401252, 0x02009489, 0x0680008a, 0x07c02b4a, 0x068000ca,
+	0x06435007, 0x0580f1c7, 0x0bef8047, 0x06803f07, 0x06035108,
+	0x06035207, 0x06a08007, 0x06035007, 0x0ac0324e, 0x0c7ff400,
+	0x07c02b8a, 0x06808007, 0x020081c8, 0x02009489, 0x0c7ffc80,
+	0x0400128a, 0x0780254b, 0x0a60c00b, 0x044011cb, 0x06800087,
+	0x0aa14007, 0x06a01008, 0x0aa0c047, 0x06a22008, 0x06a40008,
+	0x06c00108, 0x060e0508, 0x07c02587, 0x07802a88, 0x06801809,
+	0x09502248, 0x060c2109, 0x080c260e, 0x06800049, 0x07c02849,
+	0x07802cc9, 0x07c02ac9, 0x07802889, 0x07c03049, 0x06800088,
+	0x0cc00000, 0x07c02488, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x06bfff40, 0x06032400,
+	0x00400000, 0x0c780000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0c780080, 0x06431e07, 0x09027207, 0x0a668048,
+	0x068fdfca, 0x06fcffca, 0x064e0408, 0x02808288, 0x09110287,
+	0x064c0909, 0x0ac0924a, 0x0b80324a, 0x0c7801c0, 0x09808688,
+	0x0400128a, 0x098083c8, 0x0a40324a, 0x0440128a, 0x098086c8,
+	0x0aa1000a, 0x09308287, 0x0a60c00a, 0x0400128a, 0x09808388,
+	0x0b80324a, 0x00000000, 0x098081c8, 0x0c780500, 0x060e0408,
+	0x0a614248, 0x00000000, 0x0c009240, 0x00000000, 0x0c780380,
+	0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860, 0x00000000,
+	0x00000000, 0x0f000800, 0x06031f20, 0x0f010840, 0x0c780100,
+	0x06033f21, 0x0c780080, 0x00000000, 0x08031e00, 0x0cc00000,
+	0x00400000, 0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0680f60c,
+	0x0780704b, 0x0680000a, 0x06800009, 0x06800008, 0x0780776f,
+	0x07807780, 0x09610bc0, 0x0780736e, 0x078020c0, 0x06800041,
+	0x0342d001, 0x07807300, 0x06800081, 0x0b831040, 0x05403c4a,
+	0x02031c4f, 0x04001c71, 0x07000c44, 0x06800c00, 0x0bc25004,
+	0x09042004, 0x068000c1, 0x0a422040, 0x09101004, 0x04001c31,
+	0x02030030, 0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00,
+	0x09610b00, 0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000,
+	0x0242bb6b, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
+	0x068000c0, 0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b,
+	0x0581002b, 0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d,
+	0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a,
+	0x04001208, 0x0400128a, 0x0b8d52ca, 0x02000209, 0x07c070c9,
+	0x0cc00000, 0x07c07100, 0x0aa14040, 0x06800047, 0x06800006,
+	0x0c780100, 0x00000000, 0x06800007, 0x06800046, 0x05403c4a,
+	0x02031c4f, 0x04001c71, 0x07000c44, 0x09101004, 0x04001c31,
+	0x02030030, 0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00,
+	0x09610b00, 0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000,
+	0x0242bb6b, 0x0be60404, 0x0a25c104, 0x0202a209, 0x05402c2a,
+	0x02030c0e, 0x07400c0a, 0x06800040, 0x04001c30, 0x07400c00,
+	0x0540102b, 0x020001c0, 0x04001c30, 0x07400c00, 0x05810000,
+	0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a,
+	0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208,
+	0x0be60804, 0x0a25c204, 0x0202a209, 0x05402c2a, 0x02030c0e,
+	0x07400c0a, 0x06800080, 0x04001c30, 0x07400c00, 0x0540102b,
+	0x02000180, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
+	0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249,
+	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a,
+	0x0b8be2ca, 0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100,
+	0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0780704b, 0x0680000a,
+	0x07807109, 0x07807300, 0x0ba6c080, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x09082004, 0x0a6440c0, 0x04006c71,
+	0x07000c6b, 0x05402c09, 0x02030c0e, 0x07400c0a, 0x068001c0,
+	0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b,
+	0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09, 0x04001249,
+	0x0400128a, 0x0b8e92ca, 0x0cc00000, 0x07c07149, 0x0aa14040,
+	0x06800047, 0x06800006, 0x0c780100, 0x00000000, 0x06800007,
+	0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x04006c71, 0x07000c6b, 0x0a244404, 0x05402c09, 0x02030c0e,
+	0x07400c0a, 0x06800140, 0x04001c30, 0x07400c00, 0x0540102b,
+	0x020001c0, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
+	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0a244804,
+	0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800180, 0x04001c30,
+	0x07400c00, 0x0540102b, 0x02000180, 0x04001c30, 0x07400c00,
+	0x05810000, 0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09,
+	0x04001249, 0x0400128a, 0x0b8d72ca, 0x0cc00000, 0x07c07149,
+	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008,
+	0x0240a24a, 0x0200e28e, 0x0a60c009, 0x0cc00000, 0x00000000,
+	0x070003c0, 0x07400380, 0x040013cf, 0x0400138e, 0x04001208,
+	0x0b8fb248, 0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e,
+	0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a, 0x0200f24f,
+	0x0a60c00a, 0x0cc00000, 0x00000000, 0x07000380, 0x074003c0,
+	0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb288, 0x0cc00000,
+	0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a, 0x07807149,
+	0x0200f28f, 0x0200e28e, 0x0a40324a, 0x0cc00000, 0x00000000,
+	0x070003c0, 0x07400380, 0x040013cf, 0x0400138e, 0x0400128a,
+	0x0b8fb24a, 0x0cc00000, 0x00000000, 0x0b60808e, 0x0c780e00,
+	0x0680a00c, 0x0680400b, 0x0680000a, 0x0a83438a, 0x0400124a,
+	0x0202f28f, 0x07000bee, 0x0540222e, 0x0200820c, 0x04002208,
+	0x0700022d, 0x04001208, 0x07000200, 0x09610b40, 0x0a814389,
+	0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c, 0x04002208,
+	0x0700022a, 0x04001208, 0x07000200, 0x09610a80, 0x0a60c00d,
+	0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e,
+	0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ffb40, 0x07807300,
+	0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208,
+	0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c,
+	0x0200820c, 0x04002208, 0x07000207, 0x0be10047, 0x00000000,
+	0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a, 0x0c7ff340,
+	0x0cc00000, 0x00000000, 0x0b60808e, 0x0c781680, 0x0680a00c,
+	0x0680400b, 0x0680000a, 0x0a85638a, 0x0400124a, 0x0202f28f,
+	0x07000bee, 0x0540222e, 0x0200820c, 0x07000207, 0x04001208,
+	0x07000206, 0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5,
+	0x00000000, 0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7,
+	0x02007c47, 0x02007c47, 0x0c780100, 0x00000000, 0x02007147,
+	0x02007147, 0x070001ed, 0x040011c7, 0x070001c0, 0x09610b40,
+	0x0a825389, 0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c,
+	0x07000207, 0x04001208, 0x07000206, 0x054031c7, 0x020071cb,
+	0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4,
+	0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100,
+	0x00000000, 0x02007147, 0x02007147, 0x070001ea, 0x040011c7,
+	0x070001c0, 0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0,
+	0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a,
+	0x04001249, 0x0c7ff700, 0x07807300, 0x0b644080, 0x0a24004a,
+	0x0540222e, 0x0200820c, 0x04002208, 0x07000207, 0x0a22c047,
+	0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208,
+	0x07000207, 0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac,
+	0x07400bee, 0x0400128a, 0x0c7feac0, 0x0cc00000, 0x00000000,
+	0x0400120a, 0x0200720f, 0x070001c9, 0x05402189, 0x0200618c,
+	0x04002186, 0x07000185, 0x09001005, 0x0a4092c0, 0x04401c47,
+	0x07000c40, 0x074001c0, 0x04401208, 0x0acfc288, 0x040001f1,
+	0x0cc00000, 0x074001c9, 0x04001208, 0x0b8ef388, 0x0cc00000,
+	0x00000000, 0x0780710e, 0x0440134e, 0x0680a00c, 0x0680000a,
+	0x0b60808e, 0x0c7804c0, 0x0200928f, 0x07000248, 0x054021c8,
+	0x020071cc, 0x040021c7, 0x070001c6, 0x0be1804a, 0x0be24046,
+	0x00000000, 0x0c07f700, 0x0680004b, 0x0c780140, 0x0a210046,
+	0x00000000, 0x0c07f5c0, 0x0680000b, 0x0400128a, 0x0b8ef34a,
+	0x0cc00000, 0x00000000, 0x06800008, 0x0700040a, 0x0200720f,
+	0x070001c9, 0x05402189, 0x020061af, 0x04001186, 0x07000185,
+	0x09041005, 0x0a418a80, 0x04001186, 0x07000185, 0x04001186,
+	0x07000180, 0x09610140, 0x0a412305, 0x0a80e348, 0x0ac07348,
+	0x00000000, 0x0200734f, 0x0a80a34a, 0x0400128a, 0x0440120a,
+	0x0200720f, 0x04401c47, 0x07000c40, 0x074001c0, 0x04401208,
+	0x0acfc348, 0x040001f1, 0x074001c9, 0x0cc00000, 0x0740040a,
+	0x04001208, 0x0b8e0288, 0x0cc00000, 0x00000000, 0x0680a02f,
+	0x078020c0, 0x06800041, 0x0342e001, 0x0780736d, 0x07807300,
+	0x0b614080, 0x00000000, 0x05401bae, 0x05401b6d, 0x04001b6d,
+	0x0242cbad, 0x04000aed, 0x0680000d, 0x0680002a, 0x07000380,
+	0x0400138e, 0x0aa10000, 0x0aa30040, 0x0aa50080, 0x0c780680,
+	0x07000380, 0x0400138e, 0x04001000, 0x0242b02b, 0x0b411b2b,
+	0x0400032b, 0x0202bbab, 0x0c780380, 0x0400032b, 0x07000380,
+	0x0400138e, 0x04001000, 0x0202b02b, 0x0b808b6b, 0x0400032b,
+	0x0242bbab, 0x0c780140, 0x0400032b, 0x0680006a, 0x0700038c,
+	0x0400138e, 0x0c07ec40, 0x00000000, 0x0c7ff880, 0x0400134d,
+	0x0cc00000, 0x00000000, 0x0c077280, 0x00000000, 0x0c079600,
+	0x00000000, 0x07802080, 0x0aa64180, 0x00000000, 0x0c07ae80,
+	0x00000000, 0x07807140, 0x07c07240, 0x0680ec0f, 0x0780710e,
+	0x0680004d, 0x0c07b580, 0x00000000, 0x0680ec0f, 0x0780714e,
+	0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07b380,
+	0x00000000, 0x0680ec0f, 0x0680c00e, 0x0c07ed80, 0x06807250,
+	0x0cc00000, 0x00000000, 0x0680ec0f, 0x078070ce, 0x0680004d,
+	0x0c07bf80, 0x00000000, 0x0680f60f, 0x0780710e, 0x078070c0,
+	0x0240e00e, 0x0680000d, 0x0c07bdc0, 0x00000000, 0x0680ec0f,
+	0x0780714e, 0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d,
+	0x0c07ad00, 0x00000000, 0x0c07a3c0, 0x00000000, 0x0c079ec0,
+	0x00000000, 0x0c07a740, 0x00000000, 0x07807140, 0x07c07240,
+	0x07c07280, 0x07807300, 0x0b618080, 0x00000000, 0x0c07d4c0,
+	0x0680ec0f, 0x0c07d440, 0x0680f60f, 0x078070c0, 0x07807101,
+	0x07807170, 0x0ba280b0, 0x0aa0c000, 0x0a802040, 0x0c7801c0,
+	0x0680f60f, 0x0400138f, 0x070003c0, 0x07000381, 0x07400380,
+	0x074003c1, 0x0680ec0f, 0x0680c00e, 0x0c07dfc0, 0x06807250,
+	0x0680f60f, 0x0680d08e, 0x0c07dec0, 0x06807290, 0x0cc00000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264data_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264data_linux.h
new file mode 100644
index 0000000..8512490
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264data_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x07802787, 0x07802408, 0x094c21c8, 0x060c0407, 0x080c0a01,
+	0x07802347, 0x0a610007, 0x07802387, 0x0c780b00, 0x060c0a07,
+	0x0fc071c0, 0x080c2940, 0x07802387, 0x09807187, 0x098073c7,
+	0x060c0a07, 0x09c073c7, 0x09807387, 0x0c00b600, 0x060c0a07,
+	0x07802788, 0x064c0a07, 0x091c21c7, 0x0a6f8007, 0x07802a21,
+	0x06c00021, 0x06800022, 0x06c00022, 0x06800023, 0x06c00023,
+	0x06800024, 0x06c00024, 0x06bfffe5, 0x0a628008, 0x07802947,
+	0x06800309, 0x0aa18387, 0x07c029c9, 0x06800189, 0x07c029c9,
+	0x0c785980, 0x060c0713, 0x0c784ac0, 0x06800309, 0x0aa18387,
+	0x07c029c9, 0x06800189, 0x07c029c9, 0x0c7825c0, 0x060c0713,
+	0x0c780bc0, 0x00000000, 0x0c00ad80, 0x080c0600, 0x07802a21,
+	0x06c00021, 0x06800022, 0x06c00022, 0x06800023, 0x06c00023,
+	0x06800024, 0x06c00024, 0x06bfffe5, 0x07802788, 0x0a628008,
+	0x07802947, 0x06800309, 0x0aa18387, 0x07c029c9, 0x06800189,
+	0x07c029c9, 0x0c7851c0, 0x060c0713, 0x0c784300, 0x06800309,
+	0x0aa18387, 0x07c029c9, 0x06800189, 0x07c029c9, 0x0c781e00,
+	0x060c0713, 0x0c780400, 0x00000000, 0x064c0321, 0x064c0322,
+	0x064c0323, 0x064c0324, 0x064c2725, 0x0a224053, 0x07802447,
+	0x07c02987, 0x0400099d, 0x040009de, 0x04000a1f, 0x04000a60,
+	0x0c781400, 0x060c0713, 0x0683ffc7, 0x044011c7, 0x0aa0c007,
+	0x0780248a, 0x0a6f400a, 0x068000ca, 0x07802747, 0x09510287,
+	0x07802cc7, 0x09708287, 0x06031e0a, 0x0aa08007, 0x0c780b00,
+	0x080c0700, 0x07802a08, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x06800008, 0x06c00008, 0x060c0208,
+	0x06800008, 0x06c00008, 0x060c0208, 0x06bfffc9, 0x060c0326,
+	0x060c0327, 0x060c0328, 0x060c0329, 0x07802988, 0x09610209,
+	0x060c2708, 0x080c0701, 0x07802a08, 0x06c00008, 0x060c0208,
+	0x06800008, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x060c031d,
+	0x060c031e, 0x060c031f, 0x060c0320, 0x0780244a, 0x09610289,
+	0x060c270a, 0x0c780580, 0x060c0713, 0x064c2709, 0x09210249,
+	0x060c0326, 0x060c0327, 0x060c0328, 0x060c0329, 0x07802988,
+	0x09610209, 0x060c2708, 0x080c0701, 0x064c2709, 0x09210249,
+	0x060c031d, 0x060c031e, 0x060c031f, 0x060c0320, 0x07802448,
+	0x09610209, 0x060c2708, 0x060c0713, 0x06431e09, 0x0befc049,
+	0x07802307, 0x09021247, 0x094411c9, 0x04c301c7, 0x0c780f00,
+	0x060c2507, 0x0683ffc8, 0x080c3e01, 0x064c3f07, 0x093e11c7,
+	0x0aaf4007, 0x064c2307, 0x09304247, 0x0aa0c009, 0x0aee4008,
+	0x04401208, 0x0cc00000, 0x00000000, 0x064c0321, 0x064c0322,
+	0x064c0323, 0x064c0324, 0x064c2725, 0x060c0713, 0x09210265,
+	0x07802cc7, 0x0a638007, 0x07802a08, 0x06c00008, 0x060c0208,
+	0x06800008, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x06bfffc9,
+	0x060c031d, 0x060c031e, 0x060c031f, 0x060c0320, 0x07802448,
+	0x09610209, 0x060c2708, 0x07802307, 0x09021247, 0x094411c9,
+	0x04c301c7, 0x060c2507, 0x0683ffc9, 0x0780248a, 0x0aa1000a,
+	0x0aa0c0ca, 0x0a6f4009, 0x04401249, 0x068000ca, 0x07802749,
+	0x09510289, 0x07802cc9, 0x09708289, 0x06031e0a, 0x07802807,
+	0x0c07f140, 0x07c02887, 0x0b608008, 0x0c7ddec0, 0x090a1207,
+	0x090241c7, 0x095211c8, 0x0780194b, 0x0aa0c00b, 0x07c02807,
+	0x0c781040, 0x0aa64247, 0x060c2507, 0x0aa64287, 0x0aa58347,
+	0x0aa1c048, 0x0aa58387, 0x0a60c007, 0x0c7801c0, 0x00000000,
+	0x080c2605, 0x080c2606, 0x080c2602, 0x080c260f, 0x080c2603,
+	0x07802a48, 0x0aa100c8, 0x06800089, 0x0c782b80, 0x07c02a49,
+	0x0780248b, 0x0a6fc00b, 0x00000000, 0x07c02a88, 0x0c782a00,
+	0x07c02a49, 0x080c2602, 0x080c260f, 0x080c2603, 0x07802a48,
+	0x0aa50088, 0x068000c9, 0x07802cc8, 0x0aa0c008, 0x0c782780,
+	0x07c02a49, 0x0aa08712, 0x0bef4053, 0x0683ffcb, 0x078026c8,
+	0x064e0c09, 0x09010249, 0x0b804248, 0x0aa0c00b, 0x0c7ffec0,
+	0x044012cb, 0x06800088, 0x068000c9, 0x0680180b, 0x060c210b,
+	0x0683ffcc, 0x0aa2c00c, 0x064e110b, 0x091012cb, 0x0a6f400b,
+	0x0440130c, 0x064e110b, 0x091012cb, 0x0a6e400b, 0x0780248b,
+	0x0a6dc00b, 0x00000000, 0x07c02a88, 0x0c782040, 0x07c02a49,
+	0x06800007, 0x07c02807, 0x060c2507, 0x06431e07, 0x0befc047,
+	0x068fdfc8, 0x06fcffc8, 0x064e0407, 0x02807207, 0x0c7ff140,
+	0x060e0407, 0x064c0321, 0x064c0322, 0x064c2725, 0x0a230053,
+	0x07802447, 0x07c02987, 0x0400099d, 0x040009de, 0x060c0713,
+	0x07802307, 0x09021247, 0x094411c9, 0x04c301c7, 0x0c781640,
+	0x060c2507, 0x07802cc7, 0x0a658007, 0x080c0700, 0x07802a08,
+	0x06c00008, 0x060c0208, 0x080c0200, 0x06bfffc9, 0x060c0326,
+	0x060c0327, 0x0780298a, 0x09610289, 0x060c270a, 0x080c0701,
+	0x060c0208, 0x080c0200, 0x060c031d, 0x060c031e, 0x0780244a,
+	0x09610289, 0x060c270a, 0x0c780480, 0x060c0713, 0x064c2709,
+	0x09210249, 0x060c0326, 0x060c0327, 0x07802988, 0x09610209,
+	0x060c2708, 0x080c0701, 0x064c2709, 0x09210249, 0x060c031d,
+	0x060c031e, 0x07802448, 0x09610209, 0x060c2708, 0x060c0713,
+	0x07802307, 0x09021247, 0x094411c9, 0x04c301c7, 0x060c2507,
+	0x0780248a, 0x0a6fc00a, 0x068000ca, 0x07802749, 0x09510289,
+	0x07802cc9, 0x09708289, 0x0c780900, 0x06031e0a, 0x064c0321,
+	0x064c0322, 0x064c2725, 0x060c0713, 0x09210265, 0x07802cc7,
+	0x0a618007, 0x07802a08, 0x06c00008, 0x060c0208, 0x080c0200,
+	0x06bfffc9, 0x060c031d, 0x060c031e, 0x07802448, 0x09610209,
+	0x060c2708, 0x07802307, 0x09021247, 0x094411c9, 0x04c301c7,
+	0x060c2507, 0x0683ffc9, 0x04401249, 0x0aa10009, 0x0780248a,
+	0x0aa080ca, 0x0a6f000a, 0x068000ca, 0x07802749, 0x09510289,
+	0x07802cc9, 0x09708289, 0x06031e0a, 0x07802807, 0x0c07c200,
+	0x07c02887, 0x090241c7, 0x0b614008, 0x07c02807, 0x06bfffc8,
+	0x0c7daec0, 0x07c03c08, 0x0aa10287, 0x060c2507, 0x080c2602,
+	0x080c260f, 0x080c2603, 0x04c001c7, 0x09807207, 0x060c2107,
+	0x07802547, 0x0aa14007, 0x06a01008, 0x0aa0c047, 0x06a22008,
+	0x06a40008, 0x06431e09, 0x0befc049, 0x06c00108, 0x07802949,
+	0x0a670389, 0x0a26c053, 0x0c075140, 0x00000000, 0x0780288a,
+	0x0aa1c00a, 0x07802a8a, 0x00800000, 0x078026c9, 0x04001249,
+	0x07c026c9, 0x00400000, 0x0b61408a, 0x00000000, 0x080c2170,
+	0x0c780700, 0x080c260e, 0x0683ffca, 0x0440128a, 0x0aa0c00a,
+	0x07802489, 0x0a6f4009, 0x078026c9, 0x04401249, 0x0c008080,
+	0x07c026c9, 0x0c780440, 0x08030580, 0x060e0508, 0x07802a88,
+	0x06801809, 0x09502248, 0x060c2109, 0x080c260e, 0x07c02587,
+	0x0ba0c087, 0x040011c7, 0x06800007, 0x0c074740, 0x07c02547,
+	0x06800088, 0x07c02488, 0x08030580, 0x0c074c80, 0x00000000,
+	0x07802747, 0x0aa14712, 0x040011c7, 0x07802d08, 0x0a20c048,
+	0x00000000, 0x07c02747, 0x0c07ae80, 0x07802b0d, 0x0b608008,
+	0x0c7fed00, 0x0ba13fcd, 0x06800008, 0x0c781780, 0x07c02b08,
+	0x06808008, 0x0ba1070d, 0x0400024d, 0x0441c249, 0x0680c008,
+	0x05403289, 0x0200a24a, 0x02008288, 0x07400225, 0x04001208,
+	0x092102e1, 0x0740020b, 0x04001208, 0x07400221, 0x04001208,
+	0x07400222, 0x04001208, 0x092102e2, 0x0740020b, 0x04001208,
+	0x07400223, 0x04001208, 0x092102e3, 0x0740020b, 0x04001208,
+	0x07400224, 0x04001208, 0x092102e4, 0x0740020b, 0x07802c48,
+	0x0ac07488, 0x07802cca, 0x0aa38712, 0x040002ca, 0x07802d0a,
+	0x0c7802c0, 0x0942f28b, 0x0a61000a, 0x0aa14712, 0x07802d0a,
+	0x0a20c04a, 0x0a6146c9, 0x0400128d, 0x0b60c70d, 0x0680000a,
+	0x0680070a, 0x07c02b0a, 0x0b02d488, 0x0aa0800a, 0x0a67c70a,
+	0x07802b4a, 0x0a20c04a, 0x06a0800b, 0x06a0c00b, 0x06b00009,
+	0x07802b8c, 0x0540928c, 0x0200a24a, 0x06c046ca, 0x0200ad0a,
+	0x06435009, 0x0580f249, 0x0bef8049, 0x00000000, 0x0603510a,
+	0x06803f0a, 0x0603520a, 0x0603500b, 0x0400130c, 0x0481f30c,
+	0x07c02b8c, 0x07802b4c, 0x07802c47, 0x07802ccb, 0x024072c7,
+	0x0b20c0c7, 0x00000000, 0x068000c7, 0x095c2307, 0x07c02b4c,
+	0x07802b4c, 0x091c22cc, 0x0aa2800b, 0x044012cb, 0x095c230b,
+	0x0a61c00b, 0x07c02b4c, 0x0a20c04c, 0x06b0800b, 0x06b0c00b,
+	0x0c0725c0, 0x06b00009, 0x0680001b, 0x07802947, 0x0aa5c387,
+	0x07802cc7, 0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208,
+	0x07c02e88, 0x07802c48, 0x0b828207, 0x06800007, 0x07c02cc7,
+	0x07802d08, 0x04001208, 0x078023c9, 0x0b822248, 0x07c02d08,
+	0x07802487, 0x0a6fc007, 0x00000000, 0x06430507, 0x0a2f0107,
+	0x0c7dc300, 0x064c0007, 0x07802d08, 0x0be10048, 0x040011c8,
+	0x0c780580, 0x07c02d07, 0x044011c8, 0x07c02d07, 0x07802cc7,
+	0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88,
+	0x07802c48, 0x0b80b207, 0x06800007, 0x07c02cc7, 0x07802d08,
+	0x04002208, 0x078023c9, 0x0b805248, 0x07c02d08, 0x06800007,
+	0x0c7ff880, 0x07c02e87, 0x064c3b07, 0x0920c1c7, 0x0b218a07,
+	0x0680004a, 0x07c01e4a, 0x07c01d8a, 0x0680204a, 0x07c0194a,
+	0x07802cc7, 0x095084c7, 0x07802d09, 0x094084c9, 0x07801909,
+	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef500,
+	0x07802c49, 0x0b014489, 0x06808008, 0x0a628712, 0x0c780840,
+	0x00000000, 0x07802d0a, 0x0a20c04a, 0x0500128a, 0x040011c7,
+	0x054011c7, 0x0c780840, 0x094011ca, 0x040011c7, 0x0a410247,
+	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1a00,
+	0x06800007, 0x0aa5c712, 0x07802d0a, 0x0a2bc04a, 0x04001287,
+	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f15c0, 0x00000000,
+	0x0a628047, 0x040021c9, 0x07802d07, 0x0be1c047, 0x040021c9,
+	0x0c7f1600, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
+	0x0ba10707, 0x0b6cce07, 0x0680c008, 0x0441c1c7, 0x05403247,
+	0x020091c9, 0x02008248, 0x07000209, 0x07c02449, 0x04001208,
+	0x07000209, 0x04001208, 0x0700021d, 0x09610749, 0x04001208,
+	0x0700021e, 0x04001208, 0x07000209, 0x09610789, 0x04001208,
+	0x0700021f, 0x04001208, 0x07000209, 0x096107c9, 0x04001208,
+	0x07000220, 0x04001208, 0x07000209, 0x09610809, 0x0c7d5a00,
+	0x00000000, 0x07802dc7, 0x0aa18007, 0x07802087, 0x0a614087,
+	0x00000000, 0x08098002, 0x080980f0, 0x0c780a40, 0x080c2400,
+	0x064c2207, 0x09305207, 0x093a2287, 0x09205247, 0x092a22c7,
+	0x054022cb, 0x02c0a2ca, 0x09105347, 0x091a22c7, 0x054042cb,
+	0x02c0a2ca, 0x09005387, 0x090a22c7, 0x054062cb, 0x02c0a2ca,
+	0x07802087, 0x0a63c187, 0x080c2408, 0x064c2207, 0x048032ca,
+	0x0aa340cb, 0x00000000, 0x0480f28a, 0x09305347, 0x093a22c7,
+	0x054042cb, 0x02c0a2ca, 0x09205387, 0x092a22c7, 0x054062cb,
+	0x02c0a2ca, 0x0c780240, 0x00000000, 0x0480328a, 0x09305247,
+	0x093a22c7, 0x054022cb, 0x0c7800c0, 0x02c0a2ca, 0x0c780580,
+	0x05418208, 0x0609b308, 0x0649b308, 0x05418249, 0x0609b309,
+	0x0649b309, 0x0541834d, 0x0609b30d, 0x0649b30d, 0x0541838e,
+	0x0609b30e, 0x0649b30e, 0x08098002, 0x06bfffcb, 0x054102cb,
+	0x06bfffcc, 0x02c0c2cc, 0x0609820c, 0x048032ca, 0x0a6480cb,
+	0x0c780080, 0x0c780640, 0x054102c8, 0x058102cb, 0x05410308,
+	0x02c0c2cc, 0x0609810c, 0x054042ca, 0x0609800b, 0x0a811248,
+	0x00000000, 0x054102c9, 0x058102cb, 0x05410309, 0x02c0c2cc,
+	0x0c7802c0, 0x0609820c, 0x054102c8, 0x058102cb, 0x05410309,
+	0x02c0c2cc, 0x0609810c, 0x054042ca, 0x04c042cb, 0x0c7800c0,
+	0x0609800b, 0x0c780340, 0x048032ca, 0x054182cb, 0x02c0b20b,
+	0x0483030a, 0x0541430c, 0x02c0c34c, 0x0a80630b, 0x054102cd,
+	0x058102cb, 0x0541030e, 0x02c0c2cc, 0x0609820c, 0x0780294b,
+	0x0a60c38b, 0x06800712, 0x05801492, 0x06bfffcb, 0x06800021,
+	0x07802a1d, 0x0680001e, 0x06800022, 0x0680001f, 0x06800023,
+	0x06800020, 0x06800024, 0x0400099d, 0x040009de, 0x04000a1f,
+	0x04000a60, 0x0680800a, 0x0680070e, 0x0740028b, 0x0400128a,
+	0x074002a1, 0x0400128a, 0x0740029d, 0x0400128a, 0x0740029e,
+	0x0400128a, 0x074002a2, 0x0400128a, 0x0740029f, 0x0400128a,
+	0x074002a3, 0x0400128a, 0x074002a0, 0x0400128a, 0x074002a4,
+	0x0d07fbce, 0x0400128a, 0x07c0244b, 0x07c0298b, 0x096102cb,
+	0x080c0700, 0x060c270b, 0x09610761, 0x060c021d, 0x096107a2,
+	0x0780278e, 0x0aa1800e, 0x060c021e, 0x096107e3, 0x060c021f,
+	0x09610824, 0x060c0220, 0x080c0701, 0x060c270b, 0x060c021d,
+	0x0aa1000e, 0x060c021e, 0x060c021f, 0x060c0220, 0x07802c4e,
+	0x0b00948e, 0x06b00007, 0x06c046c7, 0x02007d07, 0x06035107,
+	0x06803f07, 0x06035207, 0x06a08007, 0x06035007, 0x07802cc7,
+	0x0aa24007, 0x06803fc7, 0x07802947, 0x0aa1c387, 0x07802cc7,
+	0x044011c7, 0x0ba0c707, 0x0c7fffc0, 0x0441c1c7, 0x07c02b07,
+	0x06800007, 0x07c02747, 0x0ac0b48e, 0x07802b07, 0x0b613fc7,
+	0x0ba0c707, 0x0441c1c7, 0x07c02b07, 0x06435007, 0x0580f1c7,
+	0x0bef8047, 0x0cc00000, 0x00000000, 0x06435007, 0x0580f1c7,
+	0x0bef8047, 0x00000000, 0x06435307, 0x0900c1c7, 0x0a6f8007,
+	0x06b00007, 0x06c046c7, 0x02007d07, 0x06035107, 0x06803f07,
+	0x06035207, 0x06b0c007, 0x06035007, 0x054011d2, 0x0ac051ce,
+	0x06800087, 0x07c02b47, 0x0c7ff8c0, 0x07c02b87, 0x06b10008,
+	0x06c046c8, 0x02008d08, 0x05401252, 0x02009489, 0x0680008a,
+	0x07c02b4a, 0x068000ca, 0x06435007, 0x0580f1c7, 0x0bef8047,
+	0x06803f07, 0x06035108, 0x06035207, 0x06a08007, 0x06035007,
+	0x0ac0324e, 0x0c7ff400, 0x07c02b8a, 0x06808007, 0x020081c8,
+	0x02009489, 0x0c7ffc80, 0x0400128a, 0x0780254b, 0x0a60c00b,
+	0x044011cb, 0x06800087, 0x0aa14007, 0x06a01008, 0x0aa0c047,
+	0x06a22008, 0x06a40008, 0x06c00108, 0x060e0508, 0x07c02587,
+	0x07802a88, 0x06801809, 0x09502248, 0x060c2109, 0x080c260e,
+	0x06800049, 0x07c02849, 0x07802cc9, 0x07c02ac9, 0x07802889,
+	0x07c03049, 0x06800088, 0x0cc00000, 0x07c02488, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264header_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264header_linux.h
new file mode 100644
index 0000000..33051d5
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264header_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x06804011, 0x06905347, 0x07400447, 0x04002451, 0x0fc101c0,
+	0x09108247, 0x0a60e509, 0x0c7e5ec0, 0x00000000, 0x07400447,
+	0x04001451, 0x0fc08280, 0x07c00d0a, 0x0c065980, 0x080c2301,
+	0x0b2087c7, 0x0c7e5c80, 0x04000407, 0x09505287, 0x0740044a,
+	0x04001451, 0x0ba59909, 0x0c065740, 0x080c2301, 0x05001387,
+	0x07803ccd, 0x09502347, 0x07c03ccd, 0x0c0655c0, 0x080c2301,
+	0x0c065540, 0x080c2301, 0x0fc011c0, 0x0fc01340, 0x0942134e,
+	0x0740044d, 0x04001451, 0x0aa1800d, 0x0680000e, 0x068001c7,
+	0x07c01d47, 0x0c009bc0, 0x06800009, 0x0c065200, 0x080c2301,
+	0x04004247, 0x07400449, 0x04001451, 0x0c0650c0, 0x080c2301,
+	0x07400447, 0x04001451, 0x06800088, 0x0a835207, 0x06800008,
+	0x0a82e207, 0x00000000, 0x0fc011c0, 0x07400447, 0x04001451,
+	0x0c064dc0, 0x080c2301, 0x0c064f40, 0x00000000, 0x07400447,
+	0x04001451, 0x058101c7, 0x07400447, 0x04001451, 0x0c064b80,
+	0x080c2301, 0x0c064d00, 0x00000000, 0x07400447, 0x04001451,
+	0x058101c7, 0x07400447, 0x04001451, 0x0c064940, 0x080c2301,
+	0x0aa68007, 0x0aa12007, 0x05807207, 0x0aa08008, 0x0c7e4b80,
+	0x07400447, 0x04001451, 0x04000287, 0x06808009, 0x0c064680,
+	0x080c2301, 0x0c064800, 0x00000000, 0x07400247, 0x04001249,
+	0x058101c7, 0x07400247, 0x0d07fe0a, 0x04001249, 0x0c7801c0,
+	0x00000000, 0x0c064380, 0x080c2301, 0x040041c7, 0x07400447,
+	0x04001451, 0x0c064240, 0x080c2301, 0x04000247, 0x0fc011c0,
+	0x09501247, 0x07400449, 0x04001451, 0x0c064080, 0x080c2301,
+	0x04000347, 0x0c063fc0, 0x080c2301, 0x04000387, 0x0c780700,
+	0x00000000, 0x06031f0d, 0x06033f0e, 0x0c05e7c0, 0x08031e15,
+	0x06431f07, 0x06a40008, 0x0b014207, 0x06804009, 0x0b00b24d,
+	0x00000000, 0x0649cf09, 0x0a208089, 0x0c7e3f40, 0x00000000,
+	0x0809c007, 0x0609c10d, 0x08007401, 0x0c780000, 0x00800000,
+	0x0400034e, 0x0b21a40d, 0x0649cf09, 0x0a208089, 0x0c7e3c80,
+	0x0c7ffdc0, 0x0809c008, 0x0400124d, 0x07400449, 0x04001451,
+	0x0400124e, 0x07400449, 0x04001451, 0x0fc011c0, 0x0a610007,
+	0x00000000, 0x0fc01200, 0x094211c8, 0x0fc01200, 0x094411c8,
+	0x07400447, 0x04001451, 0x0fc011c0, 0x0aa20007, 0x06800108,
+	0x0c063380, 0x080c2301, 0x07400447, 0x0d07ff48, 0x04001451,
+	0x0c780140, 0x06800007, 0x07400447, 0x0d07ffc8, 0x04001451,
+	0x06804048, 0x07400211, 0x0fc01200, 0x0a60c008, 0x0c7817c0,
+	0x07400448, 0x0fc011c0, 0x09421207, 0x07400448, 0x0aa30007,
+	0x04001451, 0x0fc081c0, 0x07400447, 0x0a623fc7, 0x04001451,
+	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0, 0x07400447,
+	0x04001451, 0x0fc011c0, 0x0aa0c007, 0x00000000, 0x0fc011c0,
+	0x0fc011c0, 0x0aa38007, 0x00000000, 0x0680000e, 0x0fc051c0,
+	0x09405387, 0x0540838e, 0x0980e34e, 0x0a21c047, 0x00000000,
+	0x0fc101c0, 0x07c00987, 0x0fc081c0, 0x09408387, 0x07c009ce,
+	0x0fc011c0, 0x0aa14007, 0x0c062680, 0x080c2301, 0x0c062600,
+	0x080c2301, 0x0fc011c0, 0x07400447, 0x04001451, 0x0aa40007,
+	0x07c00687, 0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0,
+	0x07400447, 0x04001451, 0x0fc101c0, 0x07400447, 0x04001451,
+	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc011c0, 0x07c00687,
+	0x0680000e, 0x0fc011c0, 0x0aa18007, 0x09401387, 0x0c008140,
+	0x00000000, 0x090aa207, 0x07c02f88, 0x0fc011c0, 0x0aa1c007,
+	0x09421387, 0x0c007f80, 0x00000000, 0x0be0c04e, 0x090aa207,
+	0x07c02f88, 0x0a20c0ce, 0x00000000, 0x0fc011c0, 0x0fc011c0,
+	0x09441387, 0x0fc011c0, 0x09461387, 0x0740044e, 0x04001451,
+	0x0aa24007, 0x06800188, 0x0fc011c0, 0x0c0619c0, 0x080c2301,
+	0x0d07ff88, 0x00000000, 0x07400447, 0x04001451, 0x07803b47,
+	0x0a404407, 0x07803bc7, 0x09807007, 0x07c03bc7, 0x068f000a,
+	0x06c0470a, 0x0540a1d0, 0x0200a1ca, 0x06806009, 0x0c05e900,
+	0x06a0400b, 0x0c7e1900, 0x00000000, 0x0aa1000a, 0x06804047,
+	0x0c782180, 0x070001d1, 0x06804091, 0x07000447, 0x04001451,
+	0x07c039c7, 0x09108247, 0x07000448, 0x04001451, 0x090081c8,
+	0x07c03a07, 0x064c2908, 0x09c080c8, 0x060c2908, 0x0b60d909,
+	0x0c780680, 0x080e0000, 0x0700044d, 0x04001451, 0x064c2908,
+	0x090211cd, 0x09461207, 0x060c2908, 0x0aa3000d, 0x0680000e,
+	0x06800009, 0x06c00049, 0x060e0209, 0x068001c7, 0x07c01d47,
+	0x0c006300, 0x06800009, 0x06800009, 0x06c00049, 0x060e0209,
+	0x064e0007, 0x096e91cd, 0x060e0007, 0x064e0307, 0x095081ce,
+	0x060e0307, 0x07000449, 0x04001451, 0x07c020c9, 0x07000447,
+	0x04001451, 0x07c02147, 0x06800088, 0x0a819207, 0x06800008,
+	0x0a814207, 0x07000447, 0x04001451, 0x07c03a87, 0x07000447,
+	0x04001451, 0x07c03807, 0x07000447, 0x04001451, 0x07c03847,
+	0x07000447, 0x04001451, 0x07c03887, 0x07000447, 0x04001451,
+	0x07c038c7, 0x07000447, 0x04001451, 0x07c03987, 0x0c780100,
+	0x07000447, 0x04001451, 0x07c02187, 0x07000449, 0x04001451,
+	0x090081c9, 0x07c03907, 0x091011c9, 0x07c03947, 0x07000447,
+	0x04001451, 0x060c0907, 0x07c02c47, 0x04401247, 0x07c02c09,
+	0x07000449, 0x04001451, 0x07c02c89, 0x0700044d, 0x04001451,
+	0x090011cd, 0x0a60c007, 0x07c02107, 0x05401249, 0x04000289,
+	0x07802c48, 0x09610288, 0x0609520a, 0x05404289, 0x0968c288,
+	0x0609080a, 0x06031f08, 0x06033f09, 0x0c05a440, 0x08031e15,
+	0x06431f08, 0x0a610007, 0x07c03a48, 0x0902120d, 0x094211c8,
+	0x07c02947, 0x090411cd, 0x0aa10007, 0x054011c7, 0x07802108,
+	0x094411c8, 0x07c02307, 0x06800087, 0x07802108, 0x02408207,
+	0x07000447, 0x04001451, 0x07000449, 0x04001451, 0x09508247,
+	0x05401249, 0x07c01a89, 0x07000447, 0x04001451, 0x07000449,
+	0x04001451, 0x09508247, 0x03409209, 0x07c01ac9, 0x07000447,
+	0x04001451, 0x0be0c047, 0x0c780900, 0x05801347, 0x05801347,
+	0x0a22c04d, 0x07000447, 0x04001451, 0x07c03d47, 0x0a61ffc7,
+	0x07000447, 0x04001451, 0x07c03d87, 0x07000447, 0x04001451,
+	0x07c03dc7, 0x07000447, 0x04001451, 0x0a238047, 0x09421347,
+	0x07000447, 0x04001451, 0x07c03e47, 0x07000447, 0x04001451,
+	0x07c03e07, 0x07000447, 0x04001451, 0x07c03ec7, 0x07000447,
+	0x04001451, 0x07c03e87, 0x07000447, 0x04001451, 0x09444347,
+	0x0a20c207, 0x07000447, 0x07c01b87, 0x0cc00000, 0x07c03d0d,
+	0x0680c011, 0x06905347, 0x07400447, 0x04001451, 0x0c05e780,
+	0x080c2301, 0x0b20bfc7, 0x0c7dea80, 0x04000407, 0x04000247,
+	0x0c05e600, 0x080c2301, 0x09505247, 0x0fc011c0, 0x095a1247,
+	0x0fc011c0, 0x095c1247, 0x07400449, 0x04001451, 0x0c05e3c0,
+	0x080c2301, 0x0aa0c007, 0x0c7de6c0, 0x00000000, 0x0c05e280,
+	0x080c2301, 0x04000207, 0x0c05e1c0, 0x080c2301, 0x094a5207,
+	0x0fc011c0, 0x09541207, 0x0fc021c0, 0x09562207, 0x07400448,
+	0x04001451, 0x0c05df80, 0x080c2301, 0x04000247, 0x0c05dec0,
+	0x080c2301, 0x09508247, 0x07400449, 0x04001451, 0x0c05dd80,
+	0x080c2301, 0x04000247, 0x0fc011c0, 0x09501247, 0x0fc011c0,
+	0x09521247, 0x0fc011c0, 0x09541247, 0x07400449, 0x064c2907,
+	0x091c21c7, 0x0a60c0c7, 0x0c780580, 0x04001451, 0x098092c9,
+	0x07400449, 0x04001451, 0x0fc011c0, 0x06800149, 0x05401347,
+	0x02009349, 0x07c01d49, 0x0fc01340, 0x094211cd, 0x07400447,
+	0x04001451, 0x0aa1000d, 0x0680000e, 0x0c001f80, 0x06800009,
+	0x0c05d5c0, 0x080c2301, 0x07400447, 0x04001451, 0x07803b87,
+	0x0a404407, 0x07803bc7, 0x09807047, 0x07c03bc7, 0x06af000a,
+	0x06c0470a, 0x054091d0, 0x0200a1ca, 0x06804009, 0x06a0c00b,
+	0x0c05a540, 0x00000000, 0x0c7dd540, 0x00000000, 0x0680c051,
+	0x07000449, 0x04001451, 0x091a11c9, 0x07c02347, 0x0aa0c007,
+	0x06800007, 0x0687ffc7, 0x07c02a07, 0x091c11c9, 0x07c021c7,
+	0x06800808, 0x07000449, 0x04001451, 0x090051c9, 0x07c03ac7,
+	0x09505207, 0x090a51c9, 0x07c03b07, 0x09605207, 0x07802947,
+	0x096a2207, 0x060c2108, 0x091411c9, 0x07c028c7, 0x091621c9,
+	0x07c02907, 0x07000449, 0x04001451, 0x090081c9, 0x0c05cb80,
+	0x00000000, 0x07c02247, 0x091081c9, 0x0c05ca80, 0x00000000,
+	0x07000449, 0x04001451, 0x090081c9, 0x0c05c940, 0x00000000,
+	0x06801008, 0x09505207, 0x060c2108, 0x06801408, 0x09505207,
+	0x060c2108, 0x091011c9, 0x07c02287, 0x091211c9, 0x064e0e08,
+	0x09401207, 0x060e0e08, 0x091411c9, 0x07c02207, 0x0580b1c9,
+	0x0be18047, 0x06800007, 0x07802308, 0x09c08008, 0x0cc00000,
+	0x07c02308, 0x07000449, 0x04001451, 0x090011c9, 0x0680014d,
+	0x05401387, 0x0200d38d, 0x07c01d4d, 0x07802308, 0x09401207,
+	0x07c02308, 0x09021349, 0x0aa2800d, 0x0680000e, 0x06801c09,
+	0x06c00049, 0x060e0209, 0x0c0013c0, 0x06800009, 0x06800009,
+	0x06c00049, 0x060e0209, 0x064e0007, 0x095c91cd, 0x060e0007,
+	0x064e0307, 0x094081ce, 0x060e0307, 0x07000447, 0x04001451,
+	0x0c05bc40, 0x00000000, 0x06801408, 0x09505207, 0x0cc00000,
+	0x060c2108, 0x0ba0c189, 0x0680020c, 0x0680080c, 0x07801d47,
+	0x0b8041c9, 0x04001249, 0x0cc00000, 0x00000000, 0x0540134d,
+	0x0540138e, 0x0fc01200, 0x07400448, 0x04001451, 0x09401348,
+	0x0aac8008, 0x0680020a, 0x0680020b, 0x0ba0c189, 0x068003cc,
+	0x06800fcc, 0x0aa4400b, 0x00000000, 0x0c05b340, 0x080c2301,
+	0x07400447, 0x04001451, 0x0c05b440, 0x00000000, 0x02007287,
+	0x048ff2c7, 0x0a61800b, 0x0aa0cfcc, 0x0b614189, 0x0a6103cc,
+	0x0c7ff780, 0x0980e00e, 0x0400028b, 0x054083cf, 0x0be0c04c,
+	0x094083ca, 0x06c0000f, 0x0aeac00c, 0x0440130c, 0x07801d47,
+	0x0b8031c9, 0x0cc00000, 0x00000000, 0x0c7ff640, 0x04001249,
+	0x0ba0c189, 0x0680020c, 0x0680080c, 0x064e020a, 0x0200a30a,
+	0x06c0004a, 0x060e020a, 0x0ba101c9, 0x04001249, 0x0cc00000,
+	0x00000000, 0x0540134d, 0x0540138e, 0x07801d48, 0x0ac04209,
+	0x06800008, 0x07000448, 0x04001451, 0x09401348, 0x0aab4008,
+	0x0680020a, 0x0680020b, 0x0ba0c189, 0x068003cc, 0x06800fcc,
+	0x0aa3400b, 0x07000447, 0x0c05a7c0, 0x04001451, 0x02007287,
+	0x048ff2c7, 0x0a61800b, 0x0aa0cfcc, 0x0b614189, 0x0a6103cc,
+	0x0c7ff740, 0x0980e00e, 0x0400028b, 0x054083cf, 0x0be1004c,
+	0x094083ca, 0x06c0000f, 0x060e020f, 0x0aeb800c, 0x0440130c,
+	0x0ba0c1c9, 0x0cc00000, 0x00000000, 0x0c7ff6c0, 0x04001249,
+	0x0b210408, 0x00000000, 0x0fc10240, 0x04410208, 0x0cc00000,
+	0x0f800208, 0x0c059e80, 0x080c2301, 0x04001347, 0x0fc081c0,
+	0x0c059d80, 0x080c2301, 0x0c059d00, 0x080c2301, 0x0d07ff0d,
+	0x0fc011c0, 0x0fc051c0, 0x0cc00000, 0x0fc0f1c0, 0x07803c47,
+	0x07803c88, 0x0780174b, 0x07800a4d, 0x07800a8e, 0x07802c49,
+	0x07803a4a, 0x0780390c, 0x07803e8f, 0x07803ed0, 0x07803e11,
+	0x0a409247, 0x0a408288, 0x0a40730b, 0x0a4063cd, 0x0a40540e,
+	0x00000000, 0x07800a07, 0x0a402447, 0x0c7825c0, 0x06800007,
+	0x07c07087, 0x07803bc7, 0x09807087, 0x07c03bc7, 0x069fffc7,
+	0x07c03c49, 0x07c03c8a, 0x07c0174c, 0x07c00a4f, 0x07c00a90,
+	0x07c00a11, 0x0a83f207, 0x0688000a, 0x0c056c80, 0x06c0000a,
+	0x068c000a, 0x06c0470a, 0x06804009, 0x0c0564c0, 0x06b0400b,
+	0x0680044a, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
+	0x0809ce00, 0x08007401, 0x06431e0a, 0x0bee804a, 0x00000000,
+	0x07803a47, 0x0a634047, 0x07807187, 0x06804089, 0x054031c7,
+	0x020091c9, 0x07000247, 0x091011c7, 0x020091c9, 0x0740024a,
+	0x04001249, 0x06801fca, 0x0740024a, 0x07c0178a, 0x07807047,
+	0x07c07187, 0x068003ca, 0x06031e0a, 0x0649ce09, 0x0aa10009,
+	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049,
+	0x00000000, 0x0649ce09, 0x0a6dc009, 0x00000000, 0x0c062a80,
+	0x00000000, 0x0649c007, 0x0bef7fc7, 0x07803a47, 0x0a60c047,
+	0x0c780000, 0x00800000, 0x068000c7, 0x0609c007, 0x08007401,
+	0x0c0627c0, 0x0680001b, 0x0649c007, 0x0bef7fc7, 0x07802c47,
+	0x07803a48, 0x095101c8, 0x07803908, 0x097071c8, 0x07802308,
+	0x09021208, 0x097e11c8, 0x0609c107, 0x07803d07, 0x07802108,
+	0x095e11c8, 0x07800688, 0x094c11c8, 0x07803cc8, 0x09102208,
+	0x095a21c8, 0x07803d48, 0x096101c8, 0x0609c207, 0x07803d87,
+	0x07803dc8, 0x096101c8, 0x0609c307, 0x07803e07, 0x07803e48,
+	0x096101c8, 0x0609c407, 0x07803e87, 0x07803ec8, 0x096101c8,
+	0x0609c507, 0x07801ac7, 0x07801a88, 0x096101c8, 0x0609c607,
+	0x07800d07, 0x0609ca07, 0x078009c7, 0x07800988, 0x09610207,
+	0x0609d108, 0x06800047, 0x0609c007, 0x08007401, 0x06800007,
+	0x06800008, 0x06804009, 0x04001249, 0x07400248, 0x040011c7,
+	0x0baf8607, 0x04008249, 0x0680001b, 0x0649c008, 0x0befbfc8,
+	0x091081c8, 0x07c03187, 0x092081c8, 0x07c07047, 0x093081c8,
+	0x07803cc8, 0x09408207, 0x07c03cc8, 0x06800007, 0x07c071c7,
+	0x07c07207, 0x0649c107, 0x07c078c7, 0x058101c7, 0x07c07907,
+	0x0649c407, 0x07c07947, 0x058101c7, 0x07c07987, 0x07803cc8,
+	0x09008208, 0x07802307, 0x090211c7, 0x054011c7, 0x034081c8,
+	0x07803907, 0x07803189, 0x0b004247, 0x00000000, 0x040001c9,
+	0x07c03907, 0x0b803207, 0x044011c8, 0x07c03907, 0x0cc00000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264list_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264list_linux.h
new file mode 100644
index 0000000..80d76d3
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264list_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x06bfff40, 0x06032400, 0x00400000, 0x0c780000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0cc00000, 0x00400000, 0x0c780080,
+	0x06431e07, 0x09027207, 0x0a668048, 0x068fdfca, 0x06fcffca,
+	0x064e0408, 0x02808288, 0x09110287, 0x064c0909, 0x0ac0924a,
+	0x0b80324a, 0x0c7801c0, 0x09808688, 0x0400128a, 0x098083c8,
+	0x0a40324a, 0x0440128a, 0x098086c8, 0x0aa1000a, 0x09308287,
+	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
+	0x098081c8, 0x0c780500, 0x060e0408, 0x0a614248, 0x00000000,
+	0x0c009240, 0x00000000, 0x0c780380, 0x0a62c288, 0x06431f20,
+	0x06433f21, 0x0e000860, 0x00000000, 0x00000000, 0x0f000800,
+	0x06031f20, 0x0f010840, 0x0c780100, 0x06033f21, 0x0c780080,
+	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0680400f,
+	0x0680a00e, 0x0680ec0d, 0x0680f60c, 0x0780704b, 0x0680000a,
+	0x06800009, 0x06800008, 0x0780776f, 0x07807780, 0x09610bc0,
+	0x0780736e, 0x078020c0, 0x06800041, 0x0342d001, 0x07807300,
+	0x06800081, 0x0b831040, 0x05403c4a, 0x02031c4f, 0x04001c71,
+	0x07000c44, 0x06800c00, 0x0bc25004, 0x09042004, 0x068000c1,
+	0x0a422040, 0x09101004, 0x04001c31, 0x02030030, 0x02030030,
+	0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71,
+	0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b, 0x0202a209,
+	0x05402c2a, 0x02030c0e, 0x07400c0a, 0x068000c0, 0x04001c30,
+	0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30,
+	0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249,
+	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a,
+	0x0b8d52ca, 0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100,
+	0x0aa14040, 0x06800047, 0x06800006, 0x0c780100, 0x00000000,
+	0x06800007, 0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71,
+	0x07000c44, 0x09101004, 0x04001c31, 0x02030030, 0x02030030,
+	0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71,
+	0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b, 0x0be60404,
+	0x0a25c104, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
+	0x06800040, 0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0,
+	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100,
+	0x0203020c, 0x07400c2a, 0x04001208, 0x0be60804, 0x0a25c204,
+	0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800080,
+	0x04001c30, 0x07400c00, 0x0540102b, 0x02000180, 0x04001c30,
+	0x07400c00, 0x05810000, 0x04001c30, 0x07400c00, 0x0ac05bec,
+	0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c,
+	0x07400c2a, 0x04001208, 0x0400128a, 0x0b8be2ca, 0x02000209,
+	0x07c070c9, 0x0cc00000, 0x07c07100, 0x0680400f, 0x0680a00e,
+	0x0680ec0d, 0x0780704b, 0x0680000a, 0x07807109, 0x07807300,
+	0x0ba6c080, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x09082004, 0x0a6440c0, 0x04006c71, 0x07000c6b, 0x05402c09,
+	0x02030c0e, 0x07400c0a, 0x068001c0, 0x04001c30, 0x07400c00,
+	0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00,
+	0x0203024d, 0x07400c09, 0x04001249, 0x0400128a, 0x0b8e92ca,
+	0x0cc00000, 0x07c07149, 0x0aa14040, 0x06800047, 0x06800006,
+	0x0c780100, 0x00000000, 0x06800007, 0x06800046, 0x05403c4a,
+	0x02031c4f, 0x04001c71, 0x07000c44, 0x04006c71, 0x07000c6b,
+	0x0a244404, 0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800140,
+	0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30,
+	0x07400c00, 0x05810000, 0x04001c30, 0x07400c00, 0x0203024d,
+	0x07400c09, 0x04001249, 0x0a244804, 0x05402c09, 0x02030c0e,
+	0x07400c0a, 0x06800180, 0x04001c30, 0x07400c00, 0x0540102b,
+	0x02000180, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
+	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0400128a,
+	0x0b8d72ca, 0x0cc00000, 0x07c07149, 0x0680ec0f, 0x0680f60e,
+	0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a, 0x0200e28e,
+	0x0a60c009, 0x0cc00000, 0x00000000, 0x070003c0, 0x07400380,
+	0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb248, 0x0cc00000,
+	0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9,
+	0x06800008, 0x0240a24a, 0x0200f24f, 0x0a60c00a, 0x0cc00000,
+	0x00000000, 0x07000380, 0x074003c0, 0x040013cf, 0x0400138e,
+	0x04001208, 0x0b8fb288, 0x0cc00000, 0x00000000, 0x0680ec0f,
+	0x0680f60e, 0x0780710a, 0x07807149, 0x0200f28f, 0x0200e28e,
+	0x0a40324a, 0x0cc00000, 0x00000000, 0x070003c0, 0x07400380,
+	0x040013cf, 0x0400138e, 0x0400128a, 0x0b8fb24a, 0x0cc00000,
+	0x00000000, 0x0b60808e, 0x0c780e00, 0x0680a00c, 0x0680400b,
+	0x0680000a, 0x0a83438a, 0x0400124a, 0x0202f28f, 0x07000bee,
+	0x0540222e, 0x0200820c, 0x04002208, 0x0700022d, 0x04001208,
+	0x07000200, 0x09610b40, 0x0a814389, 0x0202c24f, 0x07000b2b,
+	0x0540222b, 0x0200820c, 0x04002208, 0x0700022a, 0x04001208,
+	0x07000200, 0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0,
+	0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a,
+	0x04001249, 0x0c7ffb40, 0x07807300, 0x0b644080, 0x0a24004a,
+	0x0540222e, 0x0200820c, 0x04002208, 0x07000207, 0x0a22c047,
+	0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208,
+	0x07000207, 0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac,
+	0x07400bee, 0x0400128a, 0x0c7ff340, 0x0cc00000, 0x00000000,
+	0x0b60808e, 0x0c781680, 0x0680a00c, 0x0680400b, 0x0680000a,
+	0x0a85638a, 0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e,
+	0x0200820c, 0x07000207, 0x04001208, 0x07000206, 0x054031c7,
+	0x020071cb, 0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7,
+	0x070001c4, 0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47,
+	0x0c780100, 0x00000000, 0x02007147, 0x02007147, 0x070001ed,
+	0x040011c7, 0x070001c0, 0x09610b40, 0x0a825389, 0x0202c24f,
+	0x07000b2b, 0x0540222b, 0x0200820c, 0x07000207, 0x04001208,
+	0x07000206, 0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5,
+	0x00000000, 0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7,
+	0x02007c47, 0x02007c47, 0x0c780100, 0x00000000, 0x02007147,
+	0x02007147, 0x070001ea, 0x040011c7, 0x070001c0, 0x09610a80,
+	0x0a60c00d, 0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000,
+	0x07400b2e, 0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ff700,
+	0x07807300, 0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c,
+	0x04002208, 0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c,
+	0x0540222c, 0x0200820c, 0x04002208, 0x07000207, 0x0be10047,
+	0x00000000, 0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a,
+	0x0c7feac0, 0x0cc00000, 0x00000000, 0x0400120a, 0x0200720f,
+	0x070001c9, 0x05402189, 0x0200618c, 0x04002186, 0x07000185,
+	0x09001005, 0x0a4092c0, 0x04401c47, 0x07000c40, 0x074001c0,
+	0x04401208, 0x0acfc288, 0x040001f1, 0x0cc00000, 0x074001c9,
+	0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000, 0x0780710e,
+	0x0440134e, 0x0680a00c, 0x0680000a, 0x0b60808e, 0x0c7804c0,
+	0x0200928f, 0x07000248, 0x054021c8, 0x020071cc, 0x040021c7,
+	0x070001c6, 0x0be1804a, 0x0be24046, 0x00000000, 0x0c07f700,
+	0x0680004b, 0x0c780140, 0x0a210046, 0x00000000, 0x0c07f5c0,
+	0x0680000b, 0x0400128a, 0x0b8ef34a, 0x0cc00000, 0x00000000,
+	0x06800008, 0x0700040a, 0x0200720f, 0x070001c9, 0x05402189,
+	0x020061af, 0x04001186, 0x07000185, 0x09041005, 0x0a418a80,
+	0x04001186, 0x07000185, 0x04001186, 0x07000180, 0x09610140,
+	0x0a412305, 0x0a80e348, 0x0ac07348, 0x00000000, 0x0200734f,
+	0x0a80a34a, 0x0400128a, 0x0440120a, 0x0200720f, 0x04401c47,
+	0x07000c40, 0x074001c0, 0x04401208, 0x0acfc348, 0x040001f1,
+	0x074001c9, 0x0cc00000, 0x0740040a, 0x04001208, 0x0b8e0288,
+	0x0cc00000, 0x00000000, 0x0680a02f, 0x078020c0, 0x06800041,
+	0x0342e001, 0x0780736d, 0x07807300, 0x0b614080, 0x00000000,
+	0x05401bae, 0x05401b6d, 0x04001b6d, 0x0242cbad, 0x04000aed,
+	0x0680000d, 0x0680002a, 0x07000380, 0x0400138e, 0x0aa10000,
+	0x0aa30040, 0x0aa50080, 0x0c780680, 0x07000380, 0x0400138e,
+	0x04001000, 0x0242b02b, 0x0b411b2b, 0x0400032b, 0x0202bbab,
+	0x0c780380, 0x0400032b, 0x07000380, 0x0400138e, 0x04001000,
+	0x0202b02b, 0x0b808b6b, 0x0400032b, 0x0242bbab, 0x0c780140,
+	0x0400032b, 0x0680006a, 0x0700038c, 0x0400138e, 0x0c07ec40,
+	0x00000000, 0x0c7ff880, 0x0400134d, 0x0cc00000, 0x00000000,
+	0x0c077280, 0x00000000, 0x0c079600, 0x00000000, 0x07802080,
+	0x0aa64180, 0x00000000, 0x0c07ae80, 0x00000000, 0x07807140,
+	0x07c07240, 0x0680ec0f, 0x0780710e, 0x0680004d, 0x0c07b580,
+	0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100, 0x0200f00f,
+	0x0240e00e, 0x0680000d, 0x0c07b380, 0x00000000, 0x0680ec0f,
+	0x0680c00e, 0x0c07ed80, 0x06807250, 0x0cc00000, 0x00000000,
+	0x0680ec0f, 0x078070ce, 0x0680004d, 0x0c07bf80, 0x00000000,
+	0x0680f60f, 0x0780710e, 0x078070c0, 0x0240e00e, 0x0680000d,
+	0x0c07bdc0, 0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100,
+	0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07ad00, 0x00000000,
+	0x0c07a3c0, 0x00000000, 0x0c079ec0, 0x00000000, 0x0c07a740,
+	0x00000000, 0x07807140, 0x07c07240, 0x07c07280, 0x07807300,
+	0x0b618080, 0x00000000, 0x0c07d4c0, 0x0680ec0f, 0x0c07d440,
+	0x0680f60f, 0x078070c0, 0x07807101, 0x07807170, 0x0ba280b0,
+	0x0aa0c000, 0x0a802040, 0x0c7801c0, 0x0680f60f, 0x0400138f,
+	0x070003c0, 0x07000381, 0x07400380, 0x074003c1, 0x0680ec0f,
+	0x0680c00e, 0x0c07dfc0, 0x06807250, 0x0680f60f, 0x0680d08e,
+	0x0c07dec0, 0x06807290, 0x0cc00000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264mmc_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264mmc_linux.h
new file mode 100644
index 0000000..9fb6d49
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264mmc_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x06bfff40, 0x06032400, 0x00400000, 0x0c780000, 0x00000000,
+	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d600, 0x00000000,
+	0x0c780540, 0x0a614148, 0x00000000, 0x0c003cc0, 0x00000000,
+	0x0c780400, 0x0a614188, 0x00000000, 0x0c006c40, 0x00000000,
+	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007800, 0x00000000,
+	0x0c780180, 0x0a628208, 0x00000000, 0x0c000ec0, 0x00000000,
+	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0c7ff8c0,
+	0x06431e07, 0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860,
+	0x00000000, 0x00000000, 0x0f000800, 0x06031f20, 0x0f010840,
+	0x0c7ffc80, 0x06033f21, 0x0aa18000, 0x07800af1, 0x04001c71,
+	0x09010c71, 0x0a610031, 0x00000000, 0x07c00ac0, 0x07c00b00,
+	0x0cc00000, 0x00000000, 0x078077c5, 0x04002c4e, 0x07400c45,
+	0x07807800, 0x04003c4e, 0x07400c40, 0x0cc00000, 0x09610140,
+	0x07807846, 0x04004c4e, 0x07400c46, 0x07807880, 0x04005c4e,
+	0x07400c40, 0x0cc00000, 0x09610180, 0x0680400f, 0x0780704e,
+	0x040013cf, 0x06800000, 0x07c07080, 0x07c071c0, 0x07c07200,
+	0x070003c1, 0x0940b040, 0x074003c1, 0x0d07ff4e, 0x040083cf,
+	0x0cc00000, 0x00000000, 0x0649c900, 0x05808000, 0x05408000,
+	0x0609c900, 0x078031d0, 0x0680400f, 0x0780718e, 0x0540338e,
+	0x0200e38f, 0x04001c4e, 0x07000c4d, 0x078072c0, 0x090a1040,
+	0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b, 0x0aa7c04b,
+	0x0c780c40, 0x00000000, 0x0980d00d, 0x0c07f340, 0x0944134c,
+	0x0c07f040, 0x04000005, 0x0a22008d, 0x09481350, 0x04004c4e,
+	0x07000c46, 0x04005c4e, 0x07000c40, 0x0c780e00, 0x09610180,
+	0x0c07f240, 0x0980d28d, 0x07000380, 0x09c00300, 0x07400380,
+	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
+	0x06800040, 0x078071c0, 0x04001000, 0x0c780a40, 0x07c071c0,
+	0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e940, 0x04000006,
+	0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45, 0x04003c4e,
+	0x07000c40, 0x0c780700, 0x09610140, 0x0c07e940, 0x0980d28d,
+	0x07000380, 0x09800300, 0x0c7ff940, 0x07400380, 0x0980d00d,
+	0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e6c0, 0x09481350,
+	0x0c07e3c0, 0x04000005, 0x0c07e7c0, 0x094a1350, 0x0980d28d,
+	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
+	0x06800040, 0x078071c0, 0x04001000, 0x07c071c0, 0x04006c4e,
+	0x07807340, 0x07400c40, 0x04007c4e, 0x07400c51, 0x094c234b,
+	0x05801010, 0x05409000, 0x02c0d00d, 0x07801e40, 0x07000381,
+	0x09501040, 0x0400100e, 0x07000000, 0x0be100c0, 0x00000000,
+	0x07802080, 0x09523040, 0x07400381, 0x07802fc0, 0x09584340,
+	0x0900200d, 0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340,
+	0x09c0d20d, 0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d,
+	0x0980d20d, 0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0,
+	0x0900200d, 0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002080,
+	0x0780718d, 0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000,
+	0x0609ce00, 0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040,
+	0x07c01d80, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
+	0x078020c0, 0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb,
+	0x06800008, 0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70,
+	0x0a230330, 0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301,
+	0x00000000, 0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000,
+	0x04000281, 0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000,
+	0x00000000, 0x0780720d, 0x0780390c, 0x0b82230d, 0x0c07f840,
+	0x00000000, 0x0400024a, 0x0aa7bfcb, 0x0680400f, 0x05403c4b,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x06800000, 0x09404c00,
+	0x07400c70, 0x07807200, 0x04401000, 0x07c07200, 0x04401071,
+	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
+	0x03000040, 0x07c07080, 0x06810000, 0x0bc09030, 0x078071c0,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be11000, 0x0be0c080,
+	0x0c07f080, 0x0a8e3289, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0780704e, 0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030,
+	0x04001c71, 0x09101030, 0x02031031, 0x02031031, 0x07000c41,
+	0x04001c71, 0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c,
+	0x00000000, 0x04000301, 0x04000348, 0x04001208, 0x0b8ec388,
+	0x0cc00000, 0x00000000, 0x0649c701, 0x0aa24001, 0x04401041,
+	0x0809c700, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
+	0x09c302f0, 0x07400070, 0x0649c801, 0x0aa24001, 0x04401041,
+	0x0809c800, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
+	0x09c302f0, 0x07400070, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x05403c4d, 0x02031c4f, 0x04001c71, 0x07000c40, 0x06800081,
+	0x09542001, 0x07400c40, 0x04401c31, 0x07000c04, 0x0c7800c0,
+	0x05808044, 0x0be20041, 0x07801c01, 0x0aa10001, 0x0a216004,
+	0x06800001, 0x07c01c01, 0x05809040, 0x0a218041, 0x06800001,
+	0x09523001, 0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f440,
+	0x00000000, 0x0649c001, 0x0bef7fc1, 0x09101044, 0x0a60c00b,
+	0x05409041, 0x0809d100, 0x09123c04, 0x0540210b, 0x03430130,
+	0x0649d104, 0x02c04c04, 0x0609d104, 0x0940504d, 0x09184c00,
+	0x0aa583f0, 0x068001c4, 0x0aa50030, 0x06800004, 0x0b648170,
+	0x04404130, 0x0649cf04, 0x0be24084, 0x0b6380f0, 0x04002130,
+	0x0aa30070, 0x06800144, 0x0b6280b0, 0x06800184, 0x0c780200,
+	0x068001c4, 0x04401131, 0x07000104, 0x0580c104, 0x0a20c044,
+	0x06800144, 0x06800184, 0x094a3044, 0x07802130, 0x0aa0c030,
+	0x00000000, 0x09801201, 0x090c2c00, 0x0a60c0b0, 0x00000000,
+	0x09801201, 0x04401c71, 0x07000c70, 0x090a2c30, 0x09542070,
+	0x078017f0, 0x09583070, 0x07c00b0c, 0x05810c0c, 0x07c00af0,
+	0x06803230, 0x02030370, 0x07000c30, 0x09610070, 0x06800030,
+	0x02030370, 0x07000c04, 0x0aa0c00b, 0x0aa1404b, 0x00000000,
+	0x0609ca04, 0x0c7801c0, 0x0609c101, 0x0649ca30, 0x09610c04,
+	0x0609ca30, 0x0c780080, 0x0609c201, 0x0649cf01, 0x0be09001,
+	0x0be100c0, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
+	0x00000000, 0x0680000b, 0x07803d0d, 0x0a21880d, 0x0780318c,
+	0x07801b8d, 0x0b00334c, 0x00000000, 0x07801b8c, 0x078071cd,
+	0x0649cf00, 0x0be0d000, 0x0b01730d, 0x0c7800c0, 0x0680004c,
+	0x0b80d30d, 0x00000000, 0x0c07d4c0, 0x00000000, 0x0a613fcd,
+	0x0c079cc0, 0x00000000, 0x0c780180, 0x0c07dfc0, 0x00000000,
+	0x040012cb, 0x0aa0808b, 0x0c7ff9c0, 0x0aa1400b, 0x06800080,
+	0x0950800b, 0x0609c000, 0x0609ce00, 0x0cc00000, 0x00000000,
+	0x0649cf0c, 0x0bee208c, 0x078071cc, 0x0bad808c, 0x0c07cf40,
+	0x00000000, 0x0aacffcd, 0x07800b00, 0x07800af0, 0x09610030,
+	0x04002000, 0x07802ff0, 0x0a60c030, 0x0b8e700c, 0x0c7ffac0,
+	0x0b0e500c, 0x0c7ffa40, 0x00000000, 0x0680000b, 0x078071cd,
+	0x0aa3c00d, 0x0c07cb00, 0x00000000, 0x0a613fcd, 0x0c079300,
+	0x00000000, 0x0c780240, 0x07807180, 0x0a807340, 0x00000000,
+	0x0c07d540, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc40,
+	0x0aa1c00b, 0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00,
+	0x0c7ffac0, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0780704e, 0x06800008, 0x06800007, 0x07807186, 0x078072c0,
+	0x0a225800, 0x07c07087, 0x05403c46, 0x02031c4f, 0x07000c70,
+	0x09005c30, 0x06800041, 0x03401c01, 0x07c07081, 0x05403c48,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x0a23c0f0, 0x0a406188,
+	0x06800000, 0x09444c00, 0x07400c70, 0x0c780280, 0x06800047,
+	0x06800000, 0x09406c00, 0x07400c70, 0x06810000, 0x0bc04030,
+	0x078071c0, 0x04401000, 0x07c071c0, 0x04001208, 0x0b8ec388,
+	0x0cc00000, 0x07c07207, 0x0680400f, 0x0780704e, 0x06800008,
+	0x06800007, 0x07807186, 0x05403c48, 0x02031c4f, 0x04001c71,
+	0x07000c70, 0x06810000, 0x0a007030, 0x0a805188, 0x00000000,
+	0x09c302b0, 0x0c7800c0, 0x07400c70, 0x06800047, 0x04001208,
+	0x0b8f3388, 0x0cc00000, 0x07c071c7, 0x0400138e, 0x0780734d,
+	0x0240e38d, 0x07807300, 0x0b610080, 0x00000000, 0x0200e34e,
+	0x0400138e, 0x06800008, 0x07807109, 0x0680a00a, 0x0a403209,
+	0x0cc00000, 0x00000000, 0x05402108, 0x0200410a, 0x04002c44,
+	0x07000c40, 0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380,
+	0x07000105, 0x06804031, 0x05403005, 0x02006031, 0x04001186,
+	0x07000187, 0x04001c44, 0x07000c70, 0x09002030, 0x0aa14040,
+	0x0aa18080, 0x06800000, 0x0c780180, 0x094421c0, 0x0c780100,
+	0x09c07087, 0x0c780080, 0x09c070c7, 0x0be4c307, 0x06800000,
+	0x094021c0, 0x07807200, 0x04401000, 0x07c07200, 0x04401046,
+	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
+	0x03000040, 0x07c07080, 0x06810000, 0x0bc04007, 0x078071c0,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x07400187,
+	0x0be0d000, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
+	0x07807108, 0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000,
+	0x00000000, 0x05402108, 0x0200410a, 0x04002c44, 0x07000c40,
+	0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x04001c44, 0x07000c70, 0x09002030, 0x0aa14040, 0x0aa1c080,
+	0x06800000, 0x0c780200, 0x094441c0, 0x09c07087, 0x0c780140,
+	0x09c07107, 0x09c070c7, 0x0c780080, 0x09c07147, 0x0be4c307,
+	0x06800000, 0x094021c0, 0x07807200, 0x04401000, 0x07c07200,
+	0x04401046, 0x07000040, 0x09005000, 0x06800041, 0x03401001,
+	0x07807080, 0x03000040, 0x07c07080, 0x06810000, 0x0bc04007,
+	0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000, 0x07400187,
+	0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000, 0x0680000d,
+	0x07807300, 0x0b60c080, 0x00000000, 0x0680004d, 0x07807108,
+	0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000,
+	0x05402108, 0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71,
+	0x07000c41, 0x09610001, 0x03800340, 0x0a41c380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x0a24c307, 0x06800000, 0x094061c0, 0x07807200, 0x04401000,
+	0x07c07200, 0x04401046, 0x07000040, 0x09005000, 0x06800041,
+	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
+	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
+	0x07400187, 0x04001208, 0x0b8db248, 0x0cc00000, 0x00000000,
+	0x0400134d, 0x0780734c, 0x0240d34c, 0x07807300, 0x0b610080,
+	0x00000000, 0x0200d30d, 0x0400134d, 0x06800008, 0x07807109,
+	0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000, 0x05402108,
+	0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71, 0x07000c41,
+	0x09610001, 0x0a417340, 0x07000105, 0x06804031, 0x05403005,
+	0x02006031, 0x04001186, 0x07000187, 0x04001c44, 0x07000c70,
+	0x09002030, 0x0aa14040, 0x0aa18080, 0x068000c0, 0x0c780180,
+	0x094821c0, 0x0c780100, 0x09807107, 0x0c780080, 0x09807147,
+	0x04006c46, 0x07400c4e, 0x0cc00000, 0x07400187, 0x04001208,
+	0x0b8e1248, 0x0cc00000, 0x00000000, 0x0440138e, 0x0680000d,
+	0x07807300, 0x0b60c080, 0x00000000, 0x0680004d, 0x07807108,
+	0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000,
+	0x05402108, 0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71,
+	0x07000c41, 0x09610001, 0x03800340, 0x0b01b380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x0a250307, 0x06800000, 0x094061c0, 0x07807200, 0x04401000,
+	0x07c07200, 0x04401046, 0x07000040, 0x09005000, 0x06800041,
+	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
+	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x07400187,
+	0x04001208, 0x0b8dc248, 0x0cc00000, 0x00000000, 0x06800010,
+	0x078020b1, 0x0a62c0b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
+	0x0aa1c031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x07c01e50,
+	0x0c07a300, 0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1,
+	0x09005031, 0x0a638140, 0x06800011, 0x0c07a780, 0x00000000,
+	0x0780e100, 0x0be18080, 0x09001400, 0x0c079fc0, 0x00000000,
+	0x0c781800, 0x00000000, 0x0c07aec0, 0x00000000, 0x0c781700,
+	0x06800000, 0x090a2071, 0x0780e130, 0x0a858001, 0x0a857030,
+	0x0680e10f, 0x070003c0, 0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0,
+	0x0aa68100, 0x00000000, 0x04605040, 0x0c500740, 0x00000000,
+	0x04606040, 0x0c5010c0, 0x0c781280, 0x04001c4f, 0x0c07ae80,
+	0x07000c4e, 0x0c7ffc40, 0x040023cf, 0x04001c4f, 0x0c07be00,
+	0x07000c4e, 0x0c7ffb00, 0x040023cf, 0x04002c4f, 0x0c07cb80,
+	0x07000c4e, 0x04001c4f, 0x0c07d780, 0x07000c4d, 0x0c7ff900,
+	0x040033cf, 0x04001c4f, 0x07000c4e, 0x0c07e200, 0x00000000,
+	0x0c7ff780, 0x040023cf, 0x0c079a00, 0x00000000, 0x0c079300,
+	0x00000000, 0x06800007, 0x07807331, 0x0b250071, 0x07807770,
+	0x07807780, 0x09610c00, 0x07807841, 0x07807880, 0x09610040,
+	0x02401c01, 0x07c07841, 0x05810001, 0x07c07880, 0x078077c1,
+	0x07807800, 0x09610040, 0x02401c01, 0x07c077c1, 0x05810001,
+	0x07c07800, 0x0c7801c0, 0x07c07441, 0x07c07447, 0x07c077c7,
+	0x07c07807, 0x07c07847, 0x07c07887, 0x07c07347, 0x07c07487,
+	0x07c07647, 0x07c07687, 0x07c076c7, 0x07c07707, 0x07c07747,
+	0x07c07787, 0x0c7fed40, 0x040013cf, 0x04001c4f, 0x07000c4e,
+	0x0c07bd80, 0x00000000, 0x06800050, 0x0400044e, 0x0c7feb40,
+	0x040023cf, 0x0680400f, 0x0780718e, 0x0540338e, 0x0200e38f,
+	0x04001c4e, 0x07000c40, 0x0a2140c0, 0x0c071d80, 0x07c031d0,
+	0x0cc00000, 0x00000000, 0x078072f1, 0x09005031, 0x090a2071,
+	0x0aa10140, 0x0aa0c001, 0x0c074580, 0x00000000, 0x0649cf00,
+	0x0a219000, 0x0c071a40, 0x07c031d0, 0x0c0774c0, 0x00000000,
+	0x0c780140, 0x0c077400, 0x00000000, 0x0c071880, 0x07c031d0,
+	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264slice_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264slice_linux.h
new file mode 100644
index 0000000..7c936f3
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264slice_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x07802007, 0x07802048, 0x094a21c8, 0x07c072c7, 0x07802407,
+	0x044011c7, 0x07802948, 0x02808207, 0x09021208, 0x02007207,
+	0x07c07307, 0x07802dc7, 0x0aa08047, 0x0c782e00, 0x07802007,
+	0x0a608147, 0x0c781a00, 0x07801c47, 0x0aa0c007, 0x0c781940,
+	0x00000000, 0x0649cf07, 0x0a2080c7, 0x0c781840, 0x07803940,
+	0x0a608000, 0x0c781780, 0x0780736a, 0x078074b1, 0x0a85bab1,
+	0x078072eb, 0x0780732c, 0x0780e12d, 0x0780756e, 0x07807580,
+	0x09610b80, 0x078075ef, 0x07807600, 0x09610bc0, 0x06800090,
+	0x07c031d0, 0x06801840, 0x07c072c0, 0x06800080, 0x07c07300,
+	0x06800000, 0x07c0e100, 0x07c07540, 0x07c07580, 0x07c075c0,
+	0x07c07600, 0x078074b1, 0x04001c71, 0x078020c0, 0x06800041,
+	0x0340f001, 0x044013cf, 0x028313f1, 0x0a834ab1, 0x07c07371,
+	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a780,
+	0x00000000, 0x068000f3, 0x0c008880, 0x07c02bf3, 0x07807187,
+	0x07807048, 0x0a403207, 0x0c7e0200, 0x00000000, 0x06800033,
+	0x07c02bf3, 0x068002c0, 0x06031e00, 0x00000000, 0x06431e00,
+	0x0befc040, 0x00000000, 0x0649cf00, 0x0a20d000, 0x06800340,
+	0x06800440, 0x06031e00, 0x0649ce00, 0x0aa10009, 0x00000000,
+	0x0809ce00, 0x08007401, 0x06431e00, 0x0bee8040, 0x00000000,
+	0x0649cf00, 0x0a20d000, 0x06800440, 0x06800340, 0x06031e00,
+	0x0649ce00, 0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401,
+	0x06431e00, 0x0bee8040, 0x00000000, 0x0c7ff1c0, 0x00000000,
+	0x07c0736a, 0x07c072eb, 0x07c0732c, 0x07c0e12d, 0x07c0756e,
+	0x0581002e, 0x07c07580, 0x07c075ef, 0x0581002f, 0x07c07600,
+	0x0c009980, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
+	0x09610209, 0x060c3208, 0x078077c8, 0x07807809, 0x09610209,
+	0x060c3208, 0x07807848, 0x07807889, 0x09610209, 0x060c3208,
+	0x06800073, 0x0c007740, 0x07c02bf3, 0x07807187, 0x07807048,
+	0x0a403207, 0x0c7df0c0, 0x00000000, 0x06800033, 0x07c02bf3,
+	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c07aac0,
+	0x00000000, 0x07800c48, 0x0aa1c008, 0x07800bc8, 0x07800c09,
+	0x09610209, 0x06800009, 0x0c780100, 0x07c00c49, 0x0c062580,
+	0x00000000, 0x0649cf09, 0x0be29009, 0x07800cc9, 0x0a620009,
+	0x06800049, 0x07c00cc9, 0x0809c009, 0x0609c108, 0x08007401,
+	0x0649c009, 0x0a6fc009, 0x07c03088, 0x05810208, 0x07c030c8,
+	0x06803208, 0x07803089, 0x020081c8, 0x07400209, 0x06800008,
+	0x078030c9, 0x020081c8, 0x07400209, 0x06800009, 0x07c03089,
+	0x07c030c9, 0x054181c7, 0x0609b307, 0x068c000a, 0x0c060740,
+	0x06c0000a, 0x0649b307, 0x054081c7, 0x058081c7, 0x0609b207,
+	0x0609b007, 0x0609b107, 0x06800007, 0x07c01c47, 0x078072c7,
+	0x0be09807, 0x0c780840, 0x06bfffc9, 0x06803008, 0x07802307,
+	0x090211c7, 0x054011c7, 0x038081c8, 0x07807307, 0x0a60c087,
+	0x06800007, 0x06800047, 0x038081c8, 0x07803c07, 0x06031f07,
+	0x06033f08, 0x0c05d080, 0x08031e15, 0x078079c9, 0x07807a0a,
+	0x0961024a, 0x06431f07, 0x02009247, 0x078078c7, 0x07807908,
+	0x096101c8, 0x0b8071c9, 0x07807947, 0x07807988, 0x096101c8,
+	0x0b4031c9, 0x0c7800c0, 0x00000000, 0x06bfffc9, 0x064c3d08,
+	0x09161208, 0x0a6f8008, 0x00000000, 0x060c3809, 0x07802207,
+	0x0aa10007, 0x00000000, 0x0c062040, 0x080c2301, 0x07803ac7,
+	0x07c073c7, 0x07803b07, 0x07c07407, 0x07802087, 0x0aa10187,
+	0x06800148, 0x0a83c207, 0x0c781700, 0x00000000, 0x0fc011c0,
+	0x06800808, 0x096e1207, 0x078073c7, 0x09505207, 0x0fc011c0,
+	0x0aa24007, 0x07807407, 0x0c061b40, 0x080c2301, 0x07c073c7,
+	0x09505207, 0x0c061a40, 0x080c2301, 0x07c07407, 0x09605207,
+	0x07802947, 0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007,
+	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c06a5c0, 0x0680c009,
+	0x068000c7, 0x07c0d087, 0x0fc011c0, 0x0aa10007, 0x00000000,
+	0x0c06a400, 0x0680d089, 0x07802907, 0x0a60c087, 0x06800008,
+	0x06815408, 0x09402207, 0x0a644047, 0x06094208, 0x0c061340,
+	0x080c2301, 0x09484207, 0x0c061280, 0x080c2301, 0x09504207,
+	0x06094208, 0x0680c007, 0x06094007, 0x0c06a5c0, 0x078073c9,
+	0x0680d807, 0x06094007, 0x0c06a4c0, 0x07807409, 0x0c7808c0,
+	0x00000000, 0x0fc011c0, 0x06800808, 0x0aa14007, 0x078073c7,
+	0x0c060e00, 0x080c2301, 0x07c073c7, 0x09505207, 0x07802947,
+	0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007, 0x0fc011c0,
+	0x0aa10007, 0x00000000, 0x0c069980, 0x0680c009, 0x078028c7,
+	0x04000207, 0x0aa34007, 0x06094208, 0x0c060980, 0x080c2301,
+	0x09484207, 0x0c0608c0, 0x080c2301, 0x09504207, 0x06094208,
+	0x0680c007, 0x06094007, 0x0c069c00, 0x078073c9, 0x06494007,
+	0x09c07247, 0x06094007, 0x07802047, 0x0aa7c007, 0x07802007,
+	0x06800148, 0x0a82a207, 0x00000000, 0x06800007, 0x07c0e107,
+	0x0fc011c0, 0x0aa5c007, 0x0680e109, 0x04000289, 0x02407289,
+	0x0b610a47, 0x06800007, 0x0c060240, 0x080c2301, 0x0aa3c007,
+	0x07400247, 0x0aae4147, 0x04001249, 0x04000207, 0x0c060080,
+	0x080c2301, 0x07400247, 0x0a6cc0c8, 0x04001249, 0x0c05ff40,
+	0x080c2301, 0x07400247, 0x0c7ffb80, 0x04001249, 0x0649cf07,
+	0x0a20c0c7, 0x06800007, 0x07c0e107, 0x07802347, 0x0aa2c007,
+	0x07802087, 0x0aa24087, 0x06800c08, 0x0c05fbc0, 0x080c2301,
+	0x09402207, 0x0c780100, 0x060c2108, 0x0fc021c0, 0x07c0e107,
+	0x068004ca, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
+	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049, 0x00000000,
+	0x07801e87, 0x0a608047, 0x0c782a40, 0x0680a009, 0x0680400a,
+	0x0680ec08, 0x080c2400, 0x0c069f00, 0x078070cc, 0x080c2400,
+	0x0680000b, 0x0780724c, 0x078073cd, 0x0400134d, 0x0b80334c,
+	0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d, 0x0540234d,
+	0x0200d349, 0x0700034e, 0x05408410, 0x02010390, 0x054033ce,
+	0x0200f3ca, 0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f,
+	0x07c01e4f, 0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d,
+	0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210, 0x0a60c00b,
+	0x00000000, 0x07c01990, 0x040012cb, 0x0b8e630b, 0x0a2240cc,
+	0x090022cc, 0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410,
+	0x0d07ffcc, 0x0940840b, 0x060c2210, 0x07802087, 0x06800188,
+	0x0a802207, 0x0c781cc0, 0x0680f608, 0x080c2408, 0x0c069200,
+	0x0780728c, 0x080c2408, 0x0680000b, 0x0780740d, 0x0400134d,
+	0x0b80334c, 0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d,
+	0x0540234d, 0x0200d349, 0x0700034e, 0x05408410, 0x02010390,
+	0x0400134d, 0x0700034d, 0x0900234d, 0x054033ce, 0x0200f3ca,
+	0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f, 0x07c01e4f,
+	0x046002cb, 0x0c481140, 0x07803a47, 0x0540338e, 0x0200e38a,
+	0x0700038f, 0x090053cf, 0x06031f07, 0x06033f0f, 0x0c0589c0,
+	0x08031e15, 0x0780732b, 0x0a60c0ab, 0x0680002c, 0x0680006c,
+	0x06431f07, 0x07803c0f, 0x054013cf, 0x0380fb0f, 0x020073c7,
+	0x0680180f, 0x06031f07, 0x06033f0f, 0x0c058640, 0x08031e15,
+	0x06431f07, 0x06433f0f, 0x097081cf, 0x0780230f, 0x090213cf,
+	0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7, 0x0780790f,
+	0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce, 0x070003cf,
+	0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce, 0x070003ec,
+	0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce, 0x070003ed,
+	0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e, 0x078077af,
+	0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac, 0x0b403b6e,
+	0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180, 0x09807747,
+	0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb, 0x060c3907,
+	0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210,
+	0x040012cb, 0x0b8a330b, 0x0a2240cc, 0x090022cc, 0x0680010c,
+	0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc, 0x0940840b,
+	0x060c2210, 0x0780208a, 0x0a60c08a, 0x0680000a, 0x07c01e4a,
+	0x068c000a, 0x06c0470a, 0x0680c009, 0x0c059e40, 0x06a0400b,
+	0x0c05ca80, 0x080c2301, 0x0c05cc00, 0x00000000, 0x0401a1c7,
+	0x07802248, 0x02007207, 0x07c02387, 0x07802287, 0x0aa40007,
+	0x06800009, 0x0c05c7c0, 0x080c2301, 0x0aa30047, 0x09402247,
+	0x0c05c6c0, 0x080c2301, 0x0c05c840, 0x00000000, 0x094c4247,
+	0x0c05c580, 0x080c2301, 0x0c05c700, 0x00000000, 0x09444247,
+	0x060c3109, 0x0c7f1c80, 0x00000000, 0x0c0666c0, 0x00000000,
+	0x0680400f, 0x0780704e, 0x0780734d, 0x0780730c, 0x078072c0,
+	0x090a1040, 0x090c1c00, 0x02c0bc01, 0x07807188, 0x0aa0c00c,
+	0x0aa3c04c, 0x0c780900, 0x05403c48, 0x020313f1, 0x04001c71,
+	0x07000c40, 0x09061040, 0x04005c71, 0x07000c70, 0x0be4c040,
+	0x0a248080, 0x0a4112c1, 0x0a410370, 0x0cc00000, 0x0680004a,
+	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x09041040,
+	0x04005c71, 0x07000c70, 0x0be18080, 0x0a214040, 0x0a4042c1,
+	0x0a403370, 0x0cc00000, 0x0680004a, 0x04803000, 0x0aa20000,
+	0x0aa1c0c0, 0x00000000, 0x04405c71, 0x07000c40, 0x09800000,
+	0x09800040, 0x07400c40, 0x06800008, 0x06830007, 0x05403c48,
+	0x020313f1, 0x04001c71, 0x07000c40, 0x0be180c0, 0x0bc051c0,
+	0x06800000, 0x07400c40, 0x0c780140, 0x07c07188, 0x04001208,
+	0x0b8f5388, 0x0c780d40, 0x07807780, 0x0580f000, 0x0a20c040,
+	0x06800001, 0x09801181, 0x07802000, 0x0a60c140, 0x04401c31,
+	0x09801141, 0x07801c40, 0x094e1040, 0x07400c01, 0x0aa7400b,
+	0x06801801, 0x07802300, 0x09021000, 0x05401000, 0x03801001,
+	0x07803cca, 0x0900828a, 0x0340a00a, 0x078078c5, 0x07807900,
+	0x09610140, 0x07803a40, 0x06031f00, 0x06033f01, 0x0c055680,
+	0x08031e15, 0x06800046, 0x07807087, 0x06431f04, 0x06800009,
+	0x03400246, 0x0bc0f1c0, 0x04401071, 0x07000070, 0x09405c09,
+	0x07400070, 0x02c07007, 0x07c07087, 0x0649c900, 0x09c007c0,
+	0x0609c900, 0x07c079c5, 0x05810145, 0x07c07a05, 0x0cc00000,
+	0x0680000a, 0x02005105, 0x04001249, 0x0b8ee289, 0x0649c900,
+	0x098007c0, 0x0609c900, 0x0cc00000, 0x07c0718e, 0x07802171,
+	0x04600031, 0x0c480b40, 0x07802180, 0x06800041, 0x0340f001,
+	0x0580138f, 0x078072c0, 0x09005000, 0x0a614140, 0x06800000,
+	0x07c07640, 0x07c07680, 0x07c07440, 0x0780764d, 0x07807680,
+	0x09610340, 0x0780734c, 0x0780744b, 0x078073b1, 0x0b4052f1,
+	0x02400c4b, 0x0b807380, 0x0c780180, 0x0200d3cd, 0x024002f1,
+	0x0b003380, 0x0c780080, 0x0240d3cd, 0x040002f1, 0x078072c0,
+	0x090a2000, 0x0aa14000, 0x0581000d, 0x07c0764d, 0x07c07680,
+	0x07c0744b, 0x07807331, 0x0b6100b1, 0x020052cd, 0x0c781d80,
+	0x04000185, 0x078074c0, 0x07807501, 0x09610001, 0x0c781c40,
+	0x02006005, 0x078020c0, 0x06800041, 0x0340f001, 0x078072c0,
+	0x09005000, 0x0a61c140, 0x06800000, 0x07c07480, 0x07c076c0,
+	0x07c07700, 0x07c07540, 0x07c07580, 0x0780748e, 0x078076cd,
+	0x07807700, 0x09610340, 0x0780734c, 0x0b40338c, 0x00000000,
+	0x0200d3cd, 0x04602031, 0x0c501200, 0x0780398b, 0x0460000b,
+	0x0c500a80, 0x0680000a, 0x06800009, 0x0200830d, 0x078072c0,
+	0x090a2000, 0x0a610000, 0x0aa0c008, 0x00000000, 0x04401208,
+	0x04000c4b, 0x06808030, 0x07000c00, 0x04001c30, 0x07000c01,
+	0x09610001, 0x04001c30, 0x0d07fef1, 0x02009009, 0x0a608008,
+	0x0c780580, 0x04401208, 0x06800007, 0x0b8052c8, 0x00000000,
+	0x040011c7, 0x0c7fff40, 0x024082c8, 0x06031f07, 0x06033f09,
+	0x0c0535c0, 0x08031e15, 0x04001c48, 0x06808030, 0x06431f0a,
+	0x07000c00, 0x04001c30, 0x07000c01, 0x09610001, 0x04001c30,
+	0x0d07fef1, 0x0200a00a, 0x078072c0, 0x090a2000, 0x0a614000,
+	0x07803800, 0x07803841, 0x09610001, 0x0200a00a, 0x07807545,
+	0x07807580, 0x09610140, 0x0200514a, 0x07807331, 0x0a60c031,
+	0x0c780740, 0x04000185, 0x07803886, 0x078038c0, 0x09610180,
+	0x02006185, 0x0b60c0b1, 0x0c780580, 0x04000146, 0x078075c0,
+	0x07807601, 0x09610001, 0x0c780440, 0x02006006, 0x078072c0,
+	0x09005000, 0x0a610140, 0x06800005, 0x0c7802c0, 0x06800006,
+	0x0200b30d, 0x054012cb, 0x078072c0, 0x090a2000, 0x0a60c000,
+	0x00000000, 0x044012cb, 0x0400014b, 0x0400018b, 0x07c076cd,
+	0x0581000d, 0x07c07700, 0x0b803185, 0x04000105, 0x04000106,
+	0x07c07744, 0x05810004, 0x07c07780, 0x07c077c5, 0x05810005,
+	0x07c07800, 0x07c07846, 0x05810006, 0x07c07880, 0x0cc00000,
+	0x07c0748c, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264c_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264c_linux.h
index 4a7c916..94dc746 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264c_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264c_linux.h
@@ -2,13 +2,13 @@ static const u32 MicroCode[] __initconst = {
 	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x064c0800,
 	0x09800300, 0x00000000, 0x060c0800, 0x0649d019, 0x0c006140,
 	0x0649c134, 0x06880000, 0x060c2900, 0x080c0002, 0x06bfda80,
-	0x07c02d40, 0x06030400, 0x00400000, 0x0c007b00, 0x00000000,
+	0x07c02d40, 0x06030400, 0x00400000, 0x0c007b80, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
 	0x00000000, 0x06431e35, 0x0befc075, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0c780500, 0x00000000, 0x0cc00000,
 	0x00400000, 0x0c780d40, 0x064c0007, 0x0cc00000, 0x00400000,
-	0x0c787b40, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c7879c0, 0x00000000, 0x0c787780, 0x00000000,
+	0x0c787bc0, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c787a40, 0x00000000, 0x0c787800, 0x00000000,
 	0x0cc00000, 0x00400000, 0x0aa44133, 0x0aa0c033, 0x0c7fff00,
 	0x0680001b, 0x0649cf1c, 0x0bee405c, 0x064c431c, 0x0ae0ffdc,
 	0x0c7ffd80, 0x0680001b, 0x064c411c, 0x0968c71c, 0x0a40bc9c,
@@ -31,7 +31,7 @@ static const u32 MicroCode[] __initconst = {
 	0x080c0101, 0x0684044a, 0x060c2e0a, 0x060c380e, 0x0c001780,
 	0x00000000, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0aa18009,
 	0x0649470a, 0x0910828a, 0x07802cc8, 0x0a4fc20a, 0x04401249,
-	0x0cc00000, 0x00000000, 0x0c00a380, 0x00000000, 0x06490b09,
+	0x0cc00000, 0x00000000, 0x0c00a400, 0x00000000, 0x06490b09,
 	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
 	0x06090b09, 0x08095007, 0x08095000, 0x0683ffc9, 0x06498f0a,
 	0x0aa0c009, 0x0a6f800a, 0x04401249, 0x064c3d0a, 0x0580a28a,
@@ -56,11 +56,11 @@ static const u32 MicroCode[] __initconst = {
 	0x060c2908, 0x09808348, 0x09c08208, 0x060c2908, 0x064c080a,
 	0x0980a34a, 0x060c080a, 0x0c07e340, 0x00000000, 0x0c07f700,
 	0x00000000, 0x080c0600, 0x0fc081c0, 0x0649cf0a, 0x0a21500a,
-	0x0a611e47, 0x0a20c80a, 0x0c780dc0, 0x00000000, 0x090a2207,
+	0x0a611e47, 0x0be0c40a, 0x0c780dc0, 0x00000000, 0x090a2207,
 	0x07c02048, 0x0481f1c7, 0x07c02007, 0x0aa38147, 0x0aa34047,
-	0x0a60c187, 0x0c781040, 0x0681d80d, 0x0a60c1c7, 0x0c780f80,
+	0x0a60c187, 0x0c781040, 0x0681d70d, 0x0a60c1c7, 0x0c780f80,
 	0x0682000d, 0x0a60c207, 0x0c780ec0, 0x0682744d, 0x0a608247,
-	0x0c780740, 0x0c781400, 0x0c78f040, 0x00000000, 0x064c4408,
+	0x0c780740, 0x0c781400, 0x0c78f0c0, 0x00000000, 0x064c4408,
 	0x09101208, 0x0aaf8048, 0x064c5109, 0x064c460a, 0x07801a48,
 	0x05410208, 0x07801a0b, 0x020082c8, 0x0580a208, 0x06031f08,
 	0x06033f09, 0x0c07b640, 0x08031e15, 0x06431f08, 0x06433f09,
@@ -98,304 +98,304 @@ static const u32 MicroCode[] __initconst = {
 	0x0bef8043, 0x064c0903, 0x06803002, 0x063f0002, 0x06800002,
 	0x063f0002, 0x06803fc2, 0x060c0903, 0x06800002, 0x060c0c02,
 	0x06c04042, 0x060c0d02, 0x080c0101, 0x06840442, 0x060c2e02,
-	0x064c4010, 0x064c4211, 0x02411411, 0x04008451, 0x07c01a11,
-	0x05810451, 0x07c01a51, 0x064c1e02, 0x09802702, 0x060c1e02,
-	0x064e0e02, 0x09802242, 0x060e0e02, 0x0cc00000, 0x00000000,
-	0x07802bc2, 0x0aa0c002, 0x06800102, 0x06030502, 0x0b60c11b,
-	0x0cc00000, 0x00000000, 0x00800000, 0x00000000, 0x0c079c40,
-	0x00000000, 0x080c0a01, 0x080c2800, 0x080c0002, 0x0cc00000,
-	0x00400000, 0x064c441c, 0x0910171c, 0x0a6f801c, 0x0c7f8840,
-	0x00000000, 0x0cc00000, 0x00400000, 0x064e1214, 0x091e1514,
-	0x0bef0054, 0x078029d5, 0x0649d914, 0x0900c514, 0x0acfe554,
-	0x07802494, 0x0aa50094, 0x0aa08194, 0x0c782d00, 0x0c7824c0,
-	0x07802715, 0x06800015, 0x06c04015, 0x07802857, 0x097c1557,
-	0x060e1215, 0x07802d15, 0x0a20c055, 0x06800018, 0x06900018,
-	0x06c046d8, 0x02018d18, 0x06800014, 0x07c02a94, 0x0c782540,
-	0x06800114, 0x07802a95, 0x0aa08095, 0x0c781340, 0x078024d6,
-	0x0aeb4096, 0x07802857, 0x0aa4c712, 0x07802ad4, 0x05406514,
-	0x07802d15, 0x05801555, 0x0be0c055, 0x06800015, 0x06900015,
-	0x06c046d5, 0x02015d15, 0x02014554, 0x04440514, 0x060e1314,
-	0x0aa44017, 0x040c0614, 0x06805c16, 0x060c2116, 0x0c780340,
-	0x04040618, 0x05405514, 0x07802d15, 0x0be0c055, 0x06800015,
-	0x06900015, 0x06c046d5, 0x02015d15, 0x02014554, 0x04420514,
-	0x060e1314, 0x04060614, 0x07802596, 0x0aa14016, 0x06a2c215,
-	0x0aa0c056, 0x06a2c015, 0x06a2c115, 0x0aa10017, 0x06c04015,
-	0x068003d4, 0x09506554, 0x097c1557, 0x060e1215, 0x064e0e14,
-	0x098142d4, 0x060e0e14, 0x06800014, 0x07c02a94, 0x06800114,
-	0x0c781ec0, 0x07c02494, 0x078025d5, 0x078029d6, 0x0e000595,
-	0x05401516, 0x07802857, 0x0aa0c017, 0x02014594, 0x02014594,
-	0x0f000540, 0x02415515, 0x07802694, 0x05409514, 0x02014554,
-	0x05403554, 0x02015d15, 0x060e1315, 0x07802596, 0x0aa34016,
-	0x06a44215, 0x0aa2c056, 0x06a44015, 0x0c780240, 0x06a44115,
-	0x0a6580d5, 0x078026d4, 0x064e0c16, 0x09010596, 0x0b8e5594,
-	0x0cc00000, 0x00400000, 0x0aa10017, 0x06c0c015, 0x068005d4,
-	0x09506554, 0x097c1557, 0x060e1215, 0x064e0e14, 0x098142d4,
-	0x060e0e14, 0x06800018, 0x06800014, 0x07c02a94, 0x06800154,
-	0x0c781380, 0x07c02494, 0x07802515, 0x0aa1c015, 0x04401555,
-	0x07c02515, 0x078024d5, 0x04401555, 0x0c780f80, 0x07c024d5,
-	0x07802615, 0x078029d6, 0x0e000595, 0x07c02655, 0x04001515,
-	0x07c02614, 0x0f000540, 0x07802694, 0x05409514, 0x02014554,
-	0x05403554, 0x02015d15, 0x060e1315, 0x07802596, 0x0aa14016,
-	0x06b16215, 0x0aa0c056, 0x06b16015, 0x06b16115, 0x07803056,
-	0x0aa2c016, 0x078026d4, 0x064e0c16, 0x09010596, 0x0b805594,
-	0x07c02715, 0x06800194, 0x0c7fd680, 0x07c02494, 0x04001514,
-	0x07c026d4, 0x07c02715, 0x06c00015, 0x060e1215, 0x06800054,
-	0x0c780840, 0x07c02494, 0x0ba74114, 0x07802855, 0x0a608015,
-	0x0c7ff400, 0x078026d5, 0x04001555, 0x07c026d5, 0x0aa0c114,
-	0x06800015, 0x080c2170, 0x0c7804c0, 0x07c02855, 0x064e0e14,
-	0x09814314, 0x0cc00000, 0x060e0e14, 0x0a6c0054, 0x078024d5,
-	0x0a608015, 0x0c780900, 0x04401555, 0x0b2f8055, 0x07c024d5,
-	0x0c07fd40, 0x00000000, 0x07802a54, 0x0aa0c0d4, 0x00000000,
-	0x080c2170, 0x06800014, 0x07c02494, 0x0cc00000, 0x00400000,
-	0x091c1518, 0x0aa0c014, 0x06900018, 0x06800018, 0x06c046d8,
-	0x0c780bc0, 0x02018d18, 0x0aa0c712, 0x090a8518, 0x090c7518,
-	0x07802c56, 0x0b829594, 0x0a8f4594, 0x0f000540, 0x064e0e14,
-	0x098142d4, 0x060e0e14, 0x091c1518, 0x0aa28014, 0x06900018,
-	0x0c780200, 0x06800018, 0x078025d5, 0x078029d6, 0x0aa70018,
-	0x0e000595, 0x0c7ffb40, 0x00000000, 0x06c046d8, 0x02018d18,
-	0x07802694, 0x05409514, 0x078029d6, 0x02415595, 0x02014554,
-	0x05403554, 0x02015d15, 0x060e1315, 0x07802714, 0x09004554,
-	0x0aa14015, 0x06a14214, 0x0aa0c115, 0x06a14014, 0x06a14114,
-	0x06c08014, 0x060e0d18, 0x0aa0c712, 0x04020618, 0x04020618,
-	0x0c7ff300, 0x060e1214, 0x07802694, 0x05409514, 0x0f000540,
-	0x02014554, 0x078025d5, 0x04001555, 0x07c025d5, 0x05403554,
-	0x02015d15, 0x060e1315, 0x07802714, 0x0a618018, 0x09c141d4,
-	0x060e1214, 0x068000d4, 0x0c7feec0, 0x07c02494, 0x06c08014,
-	0x09c14394, 0x060e0d18, 0x0aae4712, 0x04020618, 0x0c7ffdc0,
-	0x04020618, 0x0683ffca, 0x0a61000a, 0x0440128a, 0x0c780140,
-	0x080e1200, 0x064e1209, 0x091e1249, 0x0bee8049, 0x064e0009,
-	0x064e030a, 0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000,
-	0x064c180d, 0x0980d20d, 0x060c180d, 0x09c0d20d, 0x060c180d,
-	0x0680020d, 0x0d00000d, 0x00000000, 0x060e0009, 0x060e030a,
-	0x060e0e0b, 0x0cc00000, 0x060e0c0c, 0x0c000cc0, 0x00000000,
-	0x06810109, 0x06c34749, 0x06090709, 0x06490b09, 0x09809009,
-	0x09809089, 0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09,
-	0x06800009, 0x06c046c9, 0x02009d09, 0x06094409, 0x06900009,
-	0x06c046c9, 0x02009d09, 0x06094509, 0x0cc00000, 0x00000000,
-	0x0c000e00, 0x00000000, 0x06497f08, 0x068000c7, 0x09702207,
-	0x09808688, 0x06097f08, 0x06498e08, 0x09c080c8, 0x06098e08,
-	0x07802c47, 0x0b20c187, 0x00000000, 0x098080c8, 0x09c08788,
-	0x06098e08, 0x06820888, 0x06c00208, 0x068001c9, 0x07802c47,
-	0x0b20c407, 0x06800447, 0x06800c07, 0x09706207, 0x09808648,
-	0x06095108, 0x06095009, 0x0cc00000, 0x08095000, 0x0683ffc8,
-	0x06490909, 0x0a210049, 0x0aa0c008, 0x0c7fff40, 0x04401208,
-	0x0683ffc8, 0x06490909, 0x09343249, 0x0a2241c9, 0x0aa20008,
-	0x06490b09, 0x098090c9, 0x06090b09, 0x09c090c9, 0x06090b09,
-	0x0c7ffdc0, 0x04401208, 0x06490b09, 0x09809009, 0x09809089,
-	0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09, 0x0cc00000,
-	0x00000000, 0x0683ffc9, 0x0649bb08, 0x0920c208, 0x06495307,
-	0x090011c7, 0x020081c8, 0x0aa10008, 0x0aa0c009, 0x0c7ffe40,
-	0x04401249, 0x0cc00000, 0x00000000, 0x04000289, 0x02408289,
-	0x0b64a008, 0x00000000, 0x0c077280, 0x080c2301, 0x02408289,
-	0x0b60d008, 0x00000000, 0x07400247, 0x0aa280c7, 0x04001249,
-	0x0c077080, 0x080c2301, 0x02408289, 0x0b60d008, 0x00000000,
-	0x07400247, 0x0c7ffbc0, 0x04001249, 0x068000c7, 0x0404028a,
-	0x07400287, 0x0cc00000, 0x00000000, 0x0680000a, 0x04001249,
-	0x0fc011c0, 0x0aa20047, 0x0680004b, 0x06494207, 0x090841c7,
-	0x0340b1cb, 0x054082cb, 0x0c780340, 0x0609410b, 0x0c076a80,
-	0x080c2301, 0x0c076c00, 0x00000000, 0x040002c7, 0x0c076940,
-	0x080c2301, 0x0c076ac0, 0x00000000, 0x095091cb, 0x06094107,
-	0x0fc011c0, 0x0aa24047, 0x0680004b, 0x06494207, 0x091041c7,
-	0x0340b1cb, 0x054082cb, 0x0609410b, 0x0c780600, 0x0609410b,
-	0x0c076540, 0x080c2301, 0x0c0766c0, 0x00000000, 0x040002c7,
-	0x0c076400, 0x080c2301, 0x0c076580, 0x00000000, 0x095091cb,
-	0x06094107, 0x0c076280, 0x080c2301, 0x0c076400, 0x00000000,
-	0x040002c7, 0x0c076140, 0x080c2301, 0x0c0762c0, 0x00000000,
-	0x095091cb, 0x06094107, 0x0400128a, 0x0b8cb24a, 0x0cc00000,
-	0x00000000, 0x0649c707, 0x0aa28007, 0x044011c7, 0x0809c700,
-	0x06804008, 0x054031c7, 0x02007207, 0x040011c7, 0x070001c8,
-	0x09c082c8, 0x074001c8, 0x0649c807, 0x0aa28007, 0x044011c7,
-	0x0809c800, 0x06804008, 0x054031c7, 0x02007207, 0x040011c7,
-	0x070001c8, 0x09c082c8, 0x074001c8, 0x0cc00000, 0x00000000,
-	0x0200d308, 0x0440134d, 0x0700034d, 0x0540234d, 0x0200d349,
-	0x0700034e, 0x0400040e, 0x0400134d, 0x0700034d, 0x0900234d,
-	0x094a240d, 0x09408390, 0x09508390, 0x09608390, 0x09708390,
-	0x06800210, 0x0d000010, 0x060c220e, 0x0cc00000, 0x00000000,
-	0x0649cd09, 0x06800047, 0x054101c7, 0x020091c9, 0x0609cd09,
-	0x069fffc7, 0x07c03b47, 0x07c03b87, 0x07c03c47, 0x07c00a07,
-	0x07c00a47, 0x07c00a87, 0x07c03c87, 0x07c01747, 0x06800207,
-	0x0c7f53c0, 0x07c03bc7, 0x07803c0a, 0x0a60c00a, 0x0c780c80,
-	0x0680004a, 0x07802dca, 0x0aa0800a, 0x0c780b80, 0x0649cf07,
-	0x0a2180c7, 0x07803c07, 0x0aa0c007, 0x0680004a, 0x0680000a,
-	0x0c7809c0, 0x07807347, 0x07801f48, 0x0a803207, 0x0c7808c0,
-	0x0680004a, 0x07802407, 0x07801f08, 0x0a803207, 0x0c780780,
-	0x0680004a, 0x07802047, 0x07802e08, 0x02009207, 0x0aa18009,
-	0x0a803247, 0x0a802248, 0x0c7800c0, 0x0c780540, 0x0680004a,
-	0x07802007, 0x07802e48, 0x0a803207, 0x0c780400, 0x0680004a,
-	0x0a618147, 0x07801f87, 0x07801fc8, 0x0a803207, 0x0c780280,
-	0x0680004a, 0x07802147, 0x0aa1c087, 0x07801807, 0x0a4033c7,
-	0x07801847, 0x0a803407, 0x0c780080, 0x0680004a, 0x0cc00000,
-	0x07c02dca, 0x06490908, 0x0581f208, 0x0a6f8008, 0x00000000,
-	0x06490708, 0x09808648, 0x09c08488, 0x06090708, 0x068400c8,
-	0x096e820b, 0x097e120a, 0x07802407, 0x040011c7, 0x048031c7,
-	0x09542207, 0x0580124a, 0x06094809, 0x06094908, 0x06800008,
-	0x098092c8, 0x07801987, 0x09405247, 0x058051c7, 0x040011c7,
-	0x097c2207, 0x06094809, 0x06094908, 0x0c07be00, 0x00000000,
-	0x06490708, 0x09c08648, 0x09808488, 0x06090708, 0x0cc00000,
-	0x00000000, 0x0649cf07, 0x06800048, 0x0a2100c7, 0x07c01e48,
-	0x0cc00000, 0x00000000, 0x07801988, 0x0aa0c008, 0x0a210807,
-	0x00000000, 0x0cc00000, 0x00000000, 0x0c07b900, 0x00000000,
-	0x0c07b140, 0x00000000, 0x0680001b, 0x0780294e, 0x0a61038e,
-	0x07802c4e, 0x0c780380, 0x0980b00b, 0x0ae6011b, 0x0c07f180,
-	0x00000000, 0x0400128a, 0x0b80438a, 0x00000000, 0x0680000a,
-	0x040012cb, 0x0b8f834b, 0x0b8f730a, 0x0c780380, 0x00000000,
-	0x0ae3011b, 0x0c07ee80, 0x044012cb, 0x0c07ee00, 0x040012cb,
-	0x0400128a, 0x0b80438a, 0x00000000, 0x0680000a, 0x040022cb,
-	0x0b8f634b, 0x0b8f530a, 0x0cc00000, 0x0680001b, 0x07803c07,
-	0x07802e88, 0x0a402207, 0x0c7809c0, 0x07c02e87, 0x07802c49,
-	0x0780294a, 0x0a60c30a, 0x07802c8a, 0x0540128a, 0x06800008,
-	0x0b80a247, 0x095084c7, 0x02407247, 0x0b8fd288, 0x04001208,
-	0x0649cd07, 0x040011c7, 0x0609cd07, 0x0cc00000, 0x06800047,
-	0x0aa0c007, 0x06800049, 0x07c02d89, 0x0aa0c712, 0x07c02cc7,
-	0x05401208, 0x094084c8, 0x07c02d08, 0x0780188a, 0x078018cb,
-	0x07802ccc, 0x07802d0d, 0x0c07ebc0, 0x06800009, 0x07802cc7,
-	0x0aa18007, 0x044011c7, 0x0ba0c707, 0x0c7fffc0, 0x0441c1c7,
-	0x07c02b07, 0x07802cc7, 0x07c01887, 0x07802d07, 0x07c018c7,
-	0x0cc00000, 0x06800007, 0x0c780380, 0x06800087, 0x0c780300,
-	0x06800147, 0x0c780280, 0x06800187, 0x0c071fc0, 0x080c2301,
-	0x07c03c07, 0x0c071f00, 0x080c2301, 0x0aad41c7, 0x0aad8007,
-	0x0aadc047, 0x07c01ec7, 0x07803bc8, 0x09061248, 0x07c02dc9,
-	0x0a250208, 0x07803c08, 0x0aa08008, 0x0c7f1fc0, 0x0649cf09,
-	0x0a20c0c9, 0x0aa2c087, 0x0c7f1ec0, 0x07802008, 0x0aa20148,
-	0x07801c48, 0x0a614008, 0x0aa08087, 0x0c7f1d40, 0x06800048,
-	0x07c01c48, 0x07c01c08, 0x0649c909, 0x04001249, 0x0609c909,
-	0x06800009, 0x07c01d89, 0x0c079a00, 0x00000000, 0x0c07a040,
-	0x00000000, 0x0c071640, 0x080c2301, 0x07803b8d, 0x0a806347,
-	0x07803bc8, 0x06800049, 0x07c02dc9, 0x0c780080, 0x07c03b87,
-	0x09082248, 0x0aa1c049, 0x0680000a, 0x0c06ea00, 0x06c0000a,
-	0x06800049, 0x09482209, 0x07c03bc8, 0x06af000a, 0x06c0470a,
-	0x054091c7, 0x0200a1ca, 0x06804009, 0x06b0c00b, 0x0c06e3c0,
-	0x00000000, 0x0780c007, 0x06905348, 0x0a803207, 0x0c7f1300,
-	0x07c03b8d, 0x0780c047, 0x09105207, 0x07803b4e, 0x0a803388,
-	0x0c7802c0, 0x07c03b48, 0x07803bc7, 0x0be20047, 0x068c000a,
-	0x06c0470a, 0x06808009, 0x06b0400b, 0x0c06df00, 0x00000000,
-	0x0c780900, 0x068f000a, 0x06c0470a, 0x07803b48, 0x0540a1c8,
-	0x0200a1ca, 0x06806009, 0x06b0400b, 0x0c06dc80, 0x00000000,
-	0x07804007, 0x06905348, 0x0a805207, 0x00000000, 0x07c03b8d,
-	0x0c7f0b40, 0x07c03b4e, 0x0680000a, 0x0c00f200, 0x00000000,
-	0x0c016b00, 0x00000000, 0x07803bc7, 0x0be34107, 0x068c000a,
-	0x06c0470a, 0x06804009, 0x06b0400b, 0x0c06d780, 0x00000000,
-	0x068cc00a, 0x06c0470a, 0x06802009, 0x06b0a00b, 0x0c06d600,
-	0x00000000, 0x0c013140, 0x00000000, 0x07803bc7, 0x0be34107,
-	0x068d000a, 0x06c0470a, 0x06804009, 0x06b0c00b, 0x0c06d380,
-	0x00000000, 0x0c780180, 0x068c000a, 0x06c0470a, 0x0680c009,
-	0x0c06d200, 0x06b0400b, 0x078020c8, 0x0f8001c8, 0x0649cf0a,
-	0x0be6808a, 0x07803bca, 0x0be6020a, 0x0780200a, 0x0aa5814a,
-	0x07801f4a, 0x0a814287, 0x0400128a, 0x06800049, 0x03409209,
-	0x04401249, 0x0280a289, 0x0a80e287, 0x0780394a, 0x0a63000a,
-	0x0649cf0a, 0x0be0d00a, 0x0c7fa580, 0x00000000, 0x07801eca,
-	0x0a61008a, 0x0680004a, 0x0c780100, 0x07c00b8a, 0x0680004a,
-	0x07c00b4a, 0x07c01f47, 0x07802107, 0x0a61c007, 0x068000c9,
-	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0fc011c0, 0x04001247,
-	0x07c01f09, 0x07802007, 0x0a614147, 0x00000000, 0x0c06f3c0,
-	0x080c2301, 0x07c01f87, 0x07802147, 0x0a65c007, 0x07802187,
-	0x0f8001c7, 0x07807388, 0x07c01808, 0x07c07387, 0x078074c7,
-	0x07c01847, 0x06800007, 0x07c074c7, 0x07c07507, 0x078021c7,
-	0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06eec0,
-	0x080c2301, 0x0c06f040, 0x00000000, 0x07c074c7, 0x058101c7,
-	0x07c07507, 0x0780738f, 0x078074d0, 0x07802147, 0x06800048,
-	0x0a422207, 0x07807547, 0x07c01807, 0x078075c7, 0x07c01847,
-	0x06800007, 0x07c07547, 0x07c07587, 0x07c075c7, 0x07c07607,
-	0x07803a87, 0x0aa54047, 0x00000000, 0x0c06e8c0, 0x080c2301,
-	0x0c06ea40, 0x00000000, 0x07c07547, 0x058101c7, 0x07c07587,
-	0x078021c7, 0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000,
-	0x0c06e5c0, 0x080c2301, 0x0c06e740, 0x00000000, 0x07c075c7,
-	0x058101c7, 0x07c07607, 0x0780754f, 0x078075d0, 0x0c079400,
-	0x00000000, 0x07802dc7, 0x0a608007, 0x0c782200, 0x07801e87,
-	0x069fffc8, 0x0b803207, 0x040011c7, 0x06800147, 0x07c01e87,
-	0x07802d07, 0x078023c8, 0x0b802207, 0x0c780200, 0x0780188a,
-	0x078018cb, 0x0680000c, 0x078023cd, 0x06800049, 0x0c07a540,
-	0x07c01e49, 0x07801d08, 0x0649cf09, 0x0aa28008, 0x07803c0a,
-	0x0aa0800a, 0x0c781c40, 0x04401208, 0x07c01d08, 0x0aa08008,
-	0x0c781b40, 0x09c09089, 0x0609cf09, 0x0a22c309, 0x0780204a,
-	0x0a62400a, 0x07802e0a, 0x0aa1c00a, 0x07801f0a, 0x0aa0c0ca,
-	0x0680004a, 0x0680008a, 0x0c781840, 0x07c01d0a, 0x0680000a,
-	0x07c01d0a, 0x0688000a, 0x0c06b140, 0x06c0000a, 0x07803bc7,
-	0x0be54107, 0x068001ca, 0x06031e0a, 0x0680001b, 0x0649ce09,
-	0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401, 0x06431e09,
-	0x0bee4049, 0x00000000, 0x0649cf07, 0x0a2200c7, 0x07801d87,
-	0x0aa18007, 0x07801ec7, 0x0aa10087, 0x06800207, 0x0c7ed5c0,
-	0x07c03bc7, 0x06800013, 0x07c02cd3, 0x07c02d13, 0x07c02e93,
-	0x07c01893, 0x07c018d3, 0x06803fc7, 0x07c02b07, 0x06800007,
-	0x07c02547, 0x07c025c7, 0x07c02607, 0x07802c07, 0x040011c7,
-	0x07c024c7, 0x06800047, 0x060e0c07, 0x07c026c7, 0x07c02507,
-	0x068003c7, 0x07c02807, 0x06805c07, 0x060c2107, 0x080c2170,
-	0x06800087, 0x07c02a47, 0x06800018, 0x0649cf07, 0x0be1d007,
-	0x00000000, 0x07801ec7, 0x0aa28187, 0x06800007, 0x0c780200,
-	0x07c01e47, 0x07801ec7, 0x0a60c087, 0x06800007, 0x07c00b47,
-	0x07800b47, 0x07c01e47, 0x068003c7, 0x07c02fc7, 0x06800407,
-	0x060c2407, 0x06800007, 0x07807048, 0x06804009, 0x05403287,
-	0x0200a289, 0x0400128a, 0x0700028b, 0x060c220b, 0x0400128a,
-	0x0700028b, 0x0400128a, 0x0700028c, 0x096102cc, 0x060c220b,
+	0x06bfffc2, 0x07c00ac2, 0x064c4010, 0x064c4211, 0x02411411,
+	0x04008451, 0x07c01a11, 0x05810451, 0x07c01a51, 0x064c1e02,
+	0x09802702, 0x060c1e02, 0x064e0e02, 0x09802242, 0x060e0e02,
+	0x0cc00000, 0x00000000, 0x07802bc2, 0x0aa0c002, 0x06800102,
+	0x06030502, 0x0b60c11b, 0x0cc00000, 0x00000000, 0x00800000,
+	0x00000000, 0x0c079bc0, 0x00000000, 0x080c0a01, 0x080c2800,
+	0x080c0002, 0x0cc00000, 0x00400000, 0x064c441c, 0x0910171c,
+	0x0a6f801c, 0x0c7f87c0, 0x00000000, 0x0cc00000, 0x00400000,
+	0x064e1214, 0x091e1514, 0x0bef0054, 0x078029d5, 0x0649d914,
+	0x0900c514, 0x0acfe554, 0x07802494, 0x0aa50094, 0x0aa08194,
+	0x0c782d00, 0x0c7824c0, 0x07802715, 0x06800015, 0x06c04015,
+	0x07802857, 0x097c1557, 0x060e1215, 0x07802d15, 0x0a20c055,
+	0x06800018, 0x06900018, 0x06c046d8, 0x02018d18, 0x06800014,
+	0x07c02a94, 0x0c782540, 0x06800114, 0x07802a95, 0x0aa08095,
+	0x0c781340, 0x078024d6, 0x0aeb4096, 0x07802857, 0x0aa4c712,
+	0x07802ad4, 0x05406514, 0x07802d15, 0x05801555, 0x0be0c055,
+	0x06800015, 0x06900015, 0x06c046d5, 0x02015d15, 0x02014554,
+	0x04440514, 0x060e1314, 0x0aa44017, 0x040c0614, 0x06805c16,
+	0x060c2116, 0x0c780340, 0x04040618, 0x05405514, 0x07802d15,
+	0x0be0c055, 0x06800015, 0x06900015, 0x06c046d5, 0x02015d15,
+	0x02014554, 0x04420514, 0x060e1314, 0x04060614, 0x07802596,
+	0x0aa14016, 0x06a2c215, 0x0aa0c056, 0x06a2c015, 0x06a2c115,
+	0x0aa10017, 0x06c04015, 0x068003d4, 0x09506554, 0x097c1557,
+	0x060e1215, 0x064e0e14, 0x098142d4, 0x060e0e14, 0x06800014,
+	0x07c02a94, 0x06800114, 0x0c781ec0, 0x07c02494, 0x078025d5,
+	0x078029d6, 0x0e000595, 0x05401516, 0x07802857, 0x0aa0c017,
+	0x02014594, 0x02014594, 0x0f000540, 0x02415515, 0x07802694,
+	0x05409514, 0x02014554, 0x05403554, 0x02015d15, 0x060e1315,
+	0x07802596, 0x0aa34016, 0x06a44215, 0x0aa2c056, 0x06a44015,
+	0x0c780240, 0x06a44115, 0x0a6580d5, 0x078026d4, 0x064e0c16,
+	0x09010596, 0x0b8e5594, 0x0cc00000, 0x00400000, 0x0aa10017,
+	0x06c0c015, 0x068005d4, 0x09506554, 0x097c1557, 0x060e1215,
+	0x064e0e14, 0x098142d4, 0x060e0e14, 0x06800018, 0x06800014,
+	0x07c02a94, 0x06800154, 0x0c781380, 0x07c02494, 0x07802515,
+	0x0aa1c015, 0x04401555, 0x07c02515, 0x078024d5, 0x04401555,
+	0x0c780f80, 0x07c024d5, 0x07802615, 0x078029d6, 0x0e000595,
+	0x07c02655, 0x04001515, 0x07c02614, 0x0f000540, 0x07802694,
+	0x05409514, 0x02014554, 0x05403554, 0x02015d15, 0x060e1315,
+	0x07802596, 0x0aa14016, 0x06b16215, 0x0aa0c056, 0x06b16015,
+	0x06b16115, 0x07803056, 0x0aa2c016, 0x078026d4, 0x064e0c16,
+	0x09010596, 0x0b805594, 0x07c02715, 0x06800194, 0x0c7fd680,
+	0x07c02494, 0x04001514, 0x07c026d4, 0x07c02715, 0x06c00015,
+	0x060e1215, 0x06800054, 0x0c780840, 0x07c02494, 0x0ba74114,
+	0x07802855, 0x0a608015, 0x0c7ff400, 0x078026d5, 0x04001555,
+	0x07c026d5, 0x0aa0c114, 0x06800015, 0x080c2170, 0x0c7804c0,
+	0x07c02855, 0x064e0e14, 0x09814314, 0x0cc00000, 0x060e0e14,
+	0x0a6c0054, 0x078024d5, 0x0a608015, 0x0c780900, 0x04401555,
+	0x0b2f8055, 0x07c024d5, 0x0c07fd40, 0x00000000, 0x07802a54,
+	0x0aa0c0d4, 0x00000000, 0x080c2170, 0x06800014, 0x07c02494,
+	0x0cc00000, 0x00400000, 0x091c1518, 0x0aa0c014, 0x06900018,
+	0x06800018, 0x06c046d8, 0x0c780bc0, 0x02018d18, 0x0aa0c712,
+	0x090a8518, 0x090c7518, 0x07802c56, 0x0b829594, 0x0a8f4594,
+	0x0f000540, 0x064e0e14, 0x098142d4, 0x060e0e14, 0x091c1518,
+	0x0aa28014, 0x06900018, 0x0c780200, 0x06800018, 0x078025d5,
+	0x078029d6, 0x0aa70018, 0x0e000595, 0x0c7ffb40, 0x00000000,
+	0x06c046d8, 0x02018d18, 0x07802694, 0x05409514, 0x078029d6,
+	0x02415595, 0x02014554, 0x05403554, 0x02015d15, 0x060e1315,
+	0x07802714, 0x09004554, 0x0aa14015, 0x06a14214, 0x0aa0c115,
+	0x06a14014, 0x06a14114, 0x06c08014, 0x060e0d18, 0x0aa0c712,
+	0x04020618, 0x04020618, 0x0c7ff300, 0x060e1214, 0x07802694,
+	0x05409514, 0x0f000540, 0x02014554, 0x078025d5, 0x04001555,
+	0x07c025d5, 0x05403554, 0x02015d15, 0x060e1315, 0x07802714,
+	0x0a618018, 0x09c141d4, 0x060e1214, 0x068000d4, 0x0c7feec0,
+	0x07c02494, 0x06c08014, 0x09c14394, 0x060e0d18, 0x0aae4712,
+	0x04020618, 0x0c7ffdc0, 0x04020618, 0x0683ffca, 0x0a61000a,
+	0x0440128a, 0x0c780140, 0x080e1200, 0x064e1209, 0x091e1249,
+	0x0bee8049, 0x064e0009, 0x064e030a, 0x064e0e0b, 0x064e0c0c,
+	0x083f0040, 0x083f0000, 0x064c180d, 0x0980d20d, 0x060c180d,
+	0x09c0d20d, 0x060c180d, 0x0680020d, 0x0d00000d, 0x00000000,
+	0x060e0009, 0x060e030a, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
+	0x0c000cc0, 0x00000000, 0x06810109, 0x06c34749, 0x06090709,
+	0x06490b09, 0x09809009, 0x09809089, 0x06090b09, 0x09c09009,
+	0x09c09089, 0x06090b09, 0x06800009, 0x06c046c9, 0x02009d09,
+	0x06094409, 0x06900009, 0x06c046c9, 0x02009d09, 0x06094509,
+	0x0cc00000, 0x00000000, 0x0c000e00, 0x00000000, 0x06497f08,
+	0x068000c7, 0x09702207, 0x09808688, 0x06097f08, 0x06498e08,
+	0x09c080c8, 0x06098e08, 0x07802c47, 0x0b20c187, 0x00000000,
+	0x098080c8, 0x09c08788, 0x06098e08, 0x06820888, 0x06c00208,
+	0x068001c9, 0x07802c47, 0x0b20c407, 0x06800447, 0x06800c07,
+	0x09706207, 0x09808648, 0x06095108, 0x06095009, 0x0cc00000,
+	0x08095000, 0x0683ffc8, 0x06490909, 0x0a210049, 0x0aa0c008,
+	0x0c7fff40, 0x04401208, 0x0683ffc8, 0x06490909, 0x09343249,
+	0x0a2241c9, 0x0aa20008, 0x06490b09, 0x098090c9, 0x06090b09,
+	0x09c090c9, 0x06090b09, 0x0c7ffdc0, 0x04401208, 0x06490b09,
+	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
+	0x06090b09, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0649bb08,
+	0x0920c208, 0x06495307, 0x090011c7, 0x020081c8, 0x0aa10008,
+	0x0aa0c009, 0x0c7ffe40, 0x04401249, 0x0cc00000, 0x00000000,
+	0x04000289, 0x02408289, 0x0b64a008, 0x00000000, 0x0c077200,
+	0x080c2301, 0x02408289, 0x0b60d008, 0x00000000, 0x07400247,
+	0x0aa280c7, 0x04001249, 0x0c077000, 0x080c2301, 0x02408289,
+	0x0b60d008, 0x00000000, 0x07400247, 0x0c7ffbc0, 0x04001249,
+	0x068000c7, 0x0404028a, 0x07400287, 0x0cc00000, 0x00000000,
+	0x0680000a, 0x04001249, 0x0fc011c0, 0x0aa20047, 0x0680004b,
+	0x06494207, 0x090841c7, 0x0340b1cb, 0x054082cb, 0x0c780340,
+	0x0609410b, 0x0c076a00, 0x080c2301, 0x0c076b80, 0x00000000,
+	0x040002c7, 0x0c0768c0, 0x080c2301, 0x0c076a40, 0x00000000,
+	0x095091cb, 0x06094107, 0x0fc011c0, 0x0aa24047, 0x0680004b,
+	0x06494207, 0x091041c7, 0x0340b1cb, 0x054082cb, 0x0609410b,
+	0x0c780600, 0x0609410b, 0x0c0764c0, 0x080c2301, 0x0c076640,
+	0x00000000, 0x040002c7, 0x0c076380, 0x080c2301, 0x0c076500,
+	0x00000000, 0x095091cb, 0x06094107, 0x0c076200, 0x080c2301,
+	0x0c076380, 0x00000000, 0x040002c7, 0x0c0760c0, 0x080c2301,
+	0x0c076240, 0x00000000, 0x095091cb, 0x06094107, 0x0400128a,
+	0x0b8cb24a, 0x0cc00000, 0x00000000, 0x0649c707, 0x0aa28007,
+	0x044011c7, 0x0809c700, 0x06804008, 0x054031c7, 0x02007207,
+	0x040011c7, 0x070001c8, 0x09c082c8, 0x074001c8, 0x0649c807,
+	0x0aa28007, 0x044011c7, 0x0809c800, 0x06804008, 0x054031c7,
+	0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8, 0x074001c8,
+	0x0cc00000, 0x00000000, 0x0200d308, 0x0440134d, 0x0700034d,
+	0x0540234d, 0x0200d349, 0x0700034e, 0x0400040e, 0x0400134d,
+	0x0700034d, 0x0900234d, 0x094a240d, 0x09408390, 0x09508390,
+	0x09608390, 0x09708390, 0x06800210, 0x0d000010, 0x060c220e,
+	0x0cc00000, 0x00000000, 0x0649cd09, 0x06800047, 0x054101c7,
+	0x020091c9, 0x0609cd09, 0x069fffc7, 0x07c03b47, 0x07c03b87,
+	0x07c03c47, 0x07c00a07, 0x07c00a47, 0x07c00a87, 0x07c03c87,
+	0x07c01747, 0x06800207, 0x0c7f5340, 0x07c03bc7, 0x07803c0a,
+	0x0a60c00a, 0x0c780c80, 0x0680004a, 0x07802dca, 0x0aa0800a,
+	0x0c780b80, 0x0649cf07, 0x0a2180c7, 0x07803c07, 0x0aa0c007,
+	0x0680004a, 0x0680000a, 0x0c7809c0, 0x07807347, 0x07801f48,
+	0x0a803207, 0x0c7808c0, 0x0680004a, 0x07802407, 0x07801f08,
+	0x0a803207, 0x0c780780, 0x0680004a, 0x07802047, 0x07802e08,
+	0x02009207, 0x0aa18009, 0x0a803247, 0x0a802248, 0x0c7800c0,
+	0x0c780540, 0x0680004a, 0x07802007, 0x07802e48, 0x0a803207,
+	0x0c780400, 0x0680004a, 0x0a618147, 0x07801f87, 0x07801fc8,
+	0x0a803207, 0x0c780280, 0x0680004a, 0x07802147, 0x0aa1c087,
+	0x07801807, 0x0a4033c7, 0x07801847, 0x0a803407, 0x0c780080,
+	0x0680004a, 0x0cc00000, 0x07c02dca, 0x06490908, 0x0581f208,
+	0x0a6f8008, 0x00000000, 0x06490708, 0x09808648, 0x09c08488,
+	0x06090708, 0x068400c8, 0x096e820b, 0x097e120a, 0x07802407,
+	0x040011c7, 0x048031c7, 0x09542207, 0x0580124a, 0x06094809,
+	0x06094908, 0x06800008, 0x098092c8, 0x07801987, 0x09405247,
+	0x058051c7, 0x040011c7, 0x097c2207, 0x06094809, 0x06094908,
+	0x0c07be00, 0x00000000, 0x06490708, 0x09c08648, 0x09808488,
+	0x06090708, 0x0cc00000, 0x00000000, 0x0649cf07, 0x06800048,
+	0x0a2100c7, 0x07c01e48, 0x0cc00000, 0x00000000, 0x07801988,
+	0x0aa0c008, 0x0a210807, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0c07b900, 0x00000000, 0x0c07b140, 0x00000000, 0x0680001b,
+	0x0780294e, 0x0a61038e, 0x07802c4e, 0x0c780380, 0x0980b00b,
+	0x0ae6011b, 0x0c07f180, 0x00000000, 0x0400128a, 0x0b80438a,
+	0x00000000, 0x0680000a, 0x040012cb, 0x0b8f834b, 0x0b8f730a,
+	0x0c780380, 0x00000000, 0x0ae3011b, 0x0c07ee80, 0x044012cb,
+	0x0c07ee00, 0x040012cb, 0x0400128a, 0x0b80438a, 0x00000000,
+	0x0680000a, 0x040022cb, 0x0b8f634b, 0x0b8f530a, 0x0cc00000,
+	0x0680001b, 0x07803c07, 0x07802e88, 0x0a402207, 0x0c7809c0,
+	0x07c02e87, 0x07802c49, 0x0780294a, 0x0a60c30a, 0x07802c8a,
+	0x0540128a, 0x06800008, 0x0b80a247, 0x095084c7, 0x02407247,
+	0x0b8fd288, 0x04001208, 0x0649cd07, 0x040011c7, 0x0609cd07,
+	0x0cc00000, 0x06800047, 0x0aa0c007, 0x06800049, 0x07c02d89,
+	0x0aa0c712, 0x07c02cc7, 0x05401208, 0x094084c8, 0x07c02d08,
+	0x0780188a, 0x078018cb, 0x07802ccc, 0x07802d0d, 0x0c07ebc0,
+	0x06800009, 0x07802cc7, 0x0aa18007, 0x044011c7, 0x0ba0c707,
+	0x0c7fffc0, 0x0441c1c7, 0x07c02b07, 0x07802cc7, 0x07c01887,
+	0x07802d07, 0x07c018c7, 0x0cc00000, 0x06800007, 0x0c780380,
+	0x06800087, 0x0c780300, 0x06800147, 0x0c780280, 0x06800187,
+	0x0c071f40, 0x080c2301, 0x07c03c07, 0x0c071e80, 0x080c2301,
+	0x0aad41c7, 0x0aad8007, 0x0aadc047, 0x07c01ec7, 0x07803bc8,
+	0x09061248, 0x07c02dc9, 0x0a250208, 0x07803c08, 0x0aa08008,
+	0x0c7f1f40, 0x0649cf09, 0x0a20c0c9, 0x0aa2c087, 0x0c7f1e40,
+	0x07802008, 0x0aa20148, 0x07801c48, 0x0a614008, 0x0aa08087,
+	0x0c7f1cc0, 0x06800048, 0x07c01c48, 0x07c01c08, 0x0649c909,
+	0x04001249, 0x0609c909, 0x06800009, 0x07c01d89, 0x0c079a00,
+	0x00000000, 0x0c07a040, 0x00000000, 0x0c0715c0, 0x080c2301,
+	0x07803b8d, 0x0a806347, 0x07803bc8, 0x06800049, 0x07c02dc9,
+	0x0c780080, 0x07c03b87, 0x09082248, 0x0aa1c049, 0x0680000a,
+	0x0c06e980, 0x06c0000a, 0x06800049, 0x09482209, 0x07c03bc8,
+	0x06af000a, 0x06c0470a, 0x054091c7, 0x0200a1ca, 0x06804009,
+	0x06b0c00b, 0x0c06e340, 0x00000000, 0x0780c007, 0x06905348,
+	0x0a803207, 0x0c7f1280, 0x07c03b8d, 0x0780c047, 0x09105207,
+	0x07803b4e, 0x0a803388, 0x0c7802c0, 0x07c03b48, 0x07803bc7,
+	0x0be20047, 0x068c000a, 0x06c0470a, 0x06808009, 0x06b0400b,
+	0x0c06de80, 0x00000000, 0x0c780900, 0x068f000a, 0x06c0470a,
+	0x07803b48, 0x0540a1c8, 0x0200a1ca, 0x06806009, 0x06b0400b,
+	0x0c06dc00, 0x00000000, 0x07804007, 0x06905348, 0x0a805207,
+	0x00000000, 0x07c03b8d, 0x0c7f0ac0, 0x07c03b4e, 0x0680000a,
+	0x0c00f180, 0x00000000, 0x0c016a80, 0x00000000, 0x07803bc7,
+	0x0be34107, 0x068c000a, 0x06c0470a, 0x06804009, 0x06b0400b,
+	0x0c06d700, 0x00000000, 0x068cc00a, 0x06c0470a, 0x06802009,
+	0x06b0a00b, 0x0c06d580, 0x00000000, 0x0c0130c0, 0x00000000,
+	0x07803bc7, 0x0be34107, 0x068d000a, 0x06c0470a, 0x06804009,
+	0x06b0c00b, 0x0c06d300, 0x00000000, 0x0c780180, 0x068c000a,
+	0x06c0470a, 0x0680c009, 0x0c06d180, 0x06b0400b, 0x078020c8,
+	0x0f8001c8, 0x0649cf0a, 0x0be5808a, 0x07803bca, 0x0be5020a,
+	0x0780200a, 0x0aa4814a, 0x07801f4a, 0x0a810287, 0x0400128a,
+	0x06800049, 0x03409209, 0x04401249, 0x0280a289, 0x0a80a287,
+	0x0780394a, 0x0a62000a, 0x07801eca, 0x0a61008a, 0x0680004a,
+	0x0c780100, 0x07c00b8a, 0x0680004a, 0x07c00b4a, 0x07c01f47,
+	0x07802107, 0x0a61c007, 0x068000c9, 0x0fc011c0, 0x0aa10007,
+	0x00000000, 0x0fc011c0, 0x04001247, 0x07c01f09, 0x07802007,
+	0x0a614147, 0x00000000, 0x0c06f440, 0x080c2301, 0x07c01f87,
+	0x07802147, 0x0a65c007, 0x07802187, 0x0f8001c7, 0x07807388,
+	0x07c01808, 0x07c07387, 0x078074c7, 0x07c01847, 0x06800007,
+	0x07c074c7, 0x07c07507, 0x078021c7, 0x0aa2c007, 0x07801f07,
+	0x0a6240c7, 0x00000000, 0x0c06ef40, 0x080c2301, 0x0c06f0c0,
+	0x00000000, 0x07c074c7, 0x058101c7, 0x07c07507, 0x0780738f,
+	0x078074d0, 0x07802147, 0x06800048, 0x0a422207, 0x07807547,
+	0x07c01807, 0x078075c7, 0x07c01847, 0x06800007, 0x07c07547,
+	0x07c07587, 0x07c075c7, 0x07c07607, 0x07803a87, 0x0aa54047,
+	0x00000000, 0x0c06e940, 0x080c2301, 0x0c06eac0, 0x00000000,
+	0x07c07547, 0x058101c7, 0x07c07587, 0x078021c7, 0x0aa2c007,
+	0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06e640, 0x080c2301,
+	0x0c06e7c0, 0x00000000, 0x07c075c7, 0x058101c7, 0x07c07607,
+	0x0780754f, 0x078075d0, 0x0c079500, 0x00000000, 0x07802dc7,
+	0x0a608007, 0x0c782180, 0x07801e87, 0x069fffc8, 0x0b803207,
+	0x040011c7, 0x06800147, 0x07c01e87, 0x07802d07, 0x078023c8,
+	0x0b802207, 0x0c780200, 0x0780188a, 0x078018cb, 0x0680000c,
+	0x078023cd, 0x06800049, 0x0c07a640, 0x07c01e49, 0x07801d08,
+	0x0649cf09, 0x0aa28008, 0x07803c0a, 0x0aa0800a, 0x0c781bc0,
+	0x04401208, 0x07c01d08, 0x0aa08008, 0x0c781ac0, 0x09c09089,
+	0x0609cf09, 0x0a22c309, 0x0780204a, 0x0a62400a, 0x07802e0a,
+	0x0aa1c00a, 0x07801f0a, 0x0aa0c0ca, 0x0680004a, 0x0680008a,
+	0x0c7817c0, 0x07c01d0a, 0x0680000a, 0x07c01d0a, 0x0688000a,
+	0x0c06b1c0, 0x06c0000a, 0x07803bc7, 0x0be54107, 0x068001ca,
+	0x06031e0a, 0x0680001b, 0x0649ce09, 0x0aa10009, 0x00000000,
+	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee4049, 0x00000000,
+	0x0649cf07, 0x0a2200c7, 0x07801d87, 0x0aa18007, 0x07801ec7,
+	0x0aa10087, 0x06800207, 0x0c7ed640, 0x07c03bc7, 0x06800013,
+	0x07c02cd3, 0x07c02d13, 0x07c02e93, 0x07c01893, 0x07c018d3,
+	0x06803fc7, 0x07c02b07, 0x06800007, 0x07c02547, 0x07c025c7,
+	0x07c02607, 0x07802c07, 0x040011c7, 0x07c024c7, 0x06800047,
+	0x060e0c07, 0x07c026c7, 0x07c02507, 0x068003c7, 0x07c02807,
+	0x06805c07, 0x060c2107, 0x080c2170, 0x06800087, 0x07c02a47,
+	0x06800018, 0x07801ec7, 0x0a61c087, 0x06800007, 0x07800b48,
+	0x0aa1c008, 0x06800088, 0x0c780140, 0x07c00b48, 0x07800b47,
+	0x07801e48, 0x02c07207, 0x07c01e47, 0x068003c7, 0x07c02fc7,
+	0x06800407, 0x060c2407, 0x06800007, 0x07807048, 0x06804009,
+	0x05403287, 0x0200a289, 0x0400128a, 0x0700028b, 0x060c220b,
 	0x0400128a, 0x0700028b, 0x0400128a, 0x0700028c, 0x096102cc,
-	0x060c220b, 0x040011c7, 0x0b8ee207, 0x00000000, 0x07801d07,
-	0x0aa08007, 0x0c7ec3c0, 0x06800007, 0x07c01947, 0x06a00007,
-	0x060c3d07, 0x07802dc7, 0x0a618007, 0x00000000, 0x0c0790c0,
-	0x00000000, 0x0aa08007, 0x0c7ec100, 0x07802047, 0x07c02e07,
-	0x07802007, 0x07c02e47, 0x07801ec7, 0x07c02087, 0x07801f47,
-	0x07c07347, 0x07801f07, 0x07c02407, 0x07801f87, 0x07c01fc7,
-	0x0780248a, 0x0a6fc00a, 0x00000000, 0x0c072f40, 0x00000000,
-	0x07802dc7, 0x0aa10007, 0x00000000, 0x0c072740, 0x00000000,
-	0x0c073300, 0x00000000, 0x07802087, 0x06840009, 0x0682629a,
-	0x0aa1c087, 0x06800008, 0x0682305a, 0x0aa10147, 0x06800048,
-	0x06800088, 0x06840009, 0x07c02788, 0x07c02689, 0x06800007,
-	0x07c02a87, 0x07802c8a, 0x07802107, 0x0a630007, 0x07802409,
-	0x0aa280c9, 0x0540128a, 0x0580128a, 0x06490707, 0x09807087,
-	0x098070c7, 0x06090707, 0x06495107, 0x098073c7, 0x06095107,
-	0x07c023ca, 0x07802947, 0x094421c9, 0x07c02947, 0x0a648387,
-	0x068000c9, 0x06495107, 0x094041c9, 0x06800009, 0x097821c9,
-	0x06095107, 0x06490707, 0x09807447, 0x06090707, 0x06498e07,
-	0x09807787, 0x09c070c7, 0x06098e07, 0x07802087, 0x0aa0c087,
-	0x0682519a, 0x068214da, 0x07803bc8, 0x090821c8, 0x0aa18087,
-	0x06800087, 0x09482207, 0x0690000a, 0x0c067fc0, 0x06c0000a,
-	0x0c784bc0, 0x07c03bc8, 0x07802dc7, 0x0aa18007, 0x00000000,
-	0x0c077a00, 0x00000000, 0x0aa08007, 0x0c7eaa40, 0x06800007,
-	0x07803bc8, 0x09082208, 0x0aa10008, 0x0684000a, 0x0c067bc0,
-	0x06c0000a, 0x07c03bc7, 0x07802d87, 0x0aa34007, 0x07802c47,
-	0x0b22c2c7, 0x07802cc7, 0x0a614007, 0x06495108, 0x09c08608,
-	0x0c7800c0, 0x07c02d87, 0x09808608, 0x06095108, 0x08095017,
-	0x08095000, 0x0c784400, 0x00000000, 0x0540928c, 0x0200a24a,
-	0x06c046ca, 0x0200ad0a, 0x0400130c, 0x0481f30c, 0x07c02b4c,
-	0x0643500c, 0x0580f30c, 0x0bef804c, 0x00000000, 0x0643530c,
-	0x0900c30c, 0x0a6f800c, 0x00000000, 0x0603510a, 0x06803f0a,
-	0x0603520a, 0x0c792ac0, 0x0603500b, 0x0cc00000, 0x00000000,
-	0x07802cc9, 0x07c02ac9, 0x07802889, 0x07c03049, 0x07802809,
-	0x0aa08009, 0x0cc00000, 0x064e0e09, 0x09809309, 0x098092c9,
-	0x0cc00000, 0x060e0e09, 0x06435007, 0x0580f1c7, 0x0bef8047,
-	0x0aa14712, 0x06800007, 0x07802d07, 0x050011c7, 0x048011c7,
-	0x0b60c709, 0x06808008, 0x0680c008, 0x0c78ec00, 0x00000000,
-	0x0c7806c0, 0x07802807, 0x0aaf8387, 0x00000000, 0x07802947,
-	0x0aaec387, 0x064e0407, 0x091c2207, 0x0a24c0c8, 0x080c3e07,
-	0x064c3f07, 0x064c3f09, 0x09004249, 0x0581b1c7, 0x0a234047,
-	0x090241c7, 0x0a210088, 0x0aa20289, 0x0aa1c309, 0x0be18087,
-	0x0a21c048, 0x0aa102c9, 0x0aa0c309, 0x0be08047, 0x0c7800c0,
-	0x06800049, 0x07c01e49, 0x0cc00000, 0x00000000, 0x07800dc8,
-	0x0aa0c048, 0x0c780780, 0x00000000, 0x06800008, 0x07c00dc8,
-	0x07800d89, 0x07801f08, 0x09610248, 0x0609d509, 0x0aa18048,
-	0x0aa20088, 0x00000000, 0x0680774a, 0x0c780180, 0x00000000,
-	0x068077ca, 0x0c7800c0, 0x00000000, 0x0680784a, 0x07000288,
-	0x0400128a, 0x07000289, 0x09610209, 0x0609d608, 0x0649d308,
-	0x098083c8, 0x0609d308, 0x08007401, 0x0649d308, 0x0a6fc008,
-	0x00000000, 0x0cc00000, 0x00000000, 0x0680000c, 0x0680002a,
-	0x064c2907, 0x0a20c407, 0x0c7e8780, 0x00000000, 0x0fc081c0,
-	0x0aaeffc7, 0x0200c1cc, 0x064c2907, 0x0a20c407, 0x0c7e85c0,
-	0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0202a1ea, 0x0aa5400c,
-	0x0aa1418c, 0x0462d1cc, 0x0c500880, 0x0a61004c, 0x0c780e80,
-	0x06800047, 0x07c01c47, 0x064c0007, 0x0be14207, 0x064c2907,
-	0x0be0c407, 0x0d07ff2a, 0x0fc081c0, 0x064c0007, 0x0be10207,
-	0x064c2907, 0x0be08407, 0x0c7ff780, 0x0c7e7fc0, 0x00000000,
-	0x0c067b80, 0x080c2301, 0x064c232b, 0x05810aeb, 0x048ffaeb,
-	0x068f000a, 0x06c0470a, 0x0540a1c7, 0x0200a1ca, 0x06804009,
-	0x0c064c40, 0x06b0400b, 0x07804007, 0x06905348, 0x0a80f207,
-	0x0c7e7b80, 0x0c067780, 0x080c2301, 0x064c232b, 0x05810aeb,
-	0x048ffaeb, 0x0fc011c0, 0x0aa14047, 0x04001aeb, 0x0fc071c0,
-	0x04007aeb, 0x07c017c7, 0x0c780140, 0x00000000, 0x0680004a,
-	0x0c005f40, 0x00000000, 0x048071eb, 0x0580322b, 0x0aa14007,
-	0x06800209, 0x04001208, 0x024071c9, 0x0f8001c7, 0x0262a22a,
-	0x0c57f440, 0x0c7ff280, 0x0680002b, 0x07803d0d, 0x0a22830d,
-	0x07802f87, 0x09005207, 0x04001208, 0x0c00cf80, 0x0202b22b,
-	0x090a5207, 0x04001208, 0x0c00ce80, 0x0202b22b, 0x0a21440d,
-	0x00000000, 0x0fc041c0, 0x07c02fc7, 0x04004aeb, 0x0c7ff940,
+	0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a, 0x0700028c,
+	0x096102cc, 0x060c220b, 0x040011c7, 0x0b8ee207, 0x00000000,
+	0x07801d07, 0x0aa08007, 0x0c7ec4c0, 0x06800007, 0x07c01947,
+	0x06a00007, 0x060c3d07, 0x07802dc7, 0x0a618007, 0x00000000,
+	0x0c079240, 0x00000000, 0x0aa08007, 0x0c7ec200, 0x07802047,
+	0x07c02e07, 0x07802007, 0x07c02e47, 0x07801ec7, 0x07c02087,
+	0x07801f47, 0x07c07347, 0x07801f07, 0x07c02407, 0x07801f87,
+	0x07c01fc7, 0x0780248a, 0x0a6fc00a, 0x00000000, 0x0c0730c0,
+	0x00000000, 0x07802dc7, 0x0aa10007, 0x00000000, 0x0c0728c0,
+	0x00000000, 0x0c073480, 0x00000000, 0x07802087, 0x06840009,
+	0x0682629a, 0x0aa1c087, 0x06800008, 0x0682305a, 0x0aa10147,
+	0x06800048, 0x06800088, 0x06840009, 0x07c02788, 0x07c02689,
+	0x06800007, 0x07c02a87, 0x07802c8a, 0x07802107, 0x0a630007,
+	0x07802409, 0x0aa280c9, 0x0540128a, 0x0580128a, 0x06490707,
+	0x09807087, 0x098070c7, 0x06090707, 0x06495107, 0x098073c7,
+	0x06095107, 0x07c023ca, 0x07802947, 0x094421c9, 0x07c02947,
+	0x0a648387, 0x068000c9, 0x06495107, 0x094041c9, 0x06800009,
+	0x097821c9, 0x06095107, 0x06490707, 0x09807447, 0x06090707,
+	0x06498e07, 0x09807787, 0x09c070c7, 0x06098e07, 0x07802087,
+	0x0aa0c087, 0x0682519a, 0x068214da, 0x07803bc8, 0x090821c8,
+	0x0aa18087, 0x06800087, 0x09482207, 0x0690000a, 0x0c0680c0,
+	0x06c0000a, 0x0c784cc0, 0x07c03bc8, 0x07802dc7, 0x0aa18007,
+	0x00000000, 0x0c077b80, 0x00000000, 0x0aa08007, 0x0c7eab40,
+	0x06800007, 0x07803bc8, 0x09082208, 0x0aa10008, 0x0684000a,
+	0x0c067cc0, 0x06c0000a, 0x07c03bc7, 0x07802d87, 0x0aa34007,
+	0x07802c47, 0x0b22c2c7, 0x07802cc7, 0x0a614007, 0x06495108,
+	0x09c08608, 0x0c7800c0, 0x07c02d87, 0x09808608, 0x06095108,
+	0x08095017, 0x08095000, 0x0c784500, 0x00000000, 0x0540928c,
+	0x0200a24a, 0x06c046ca, 0x0200ad0a, 0x0400130c, 0x0481f30c,
+	0x07c02b4c, 0x0643500c, 0x0580f30c, 0x0bef804c, 0x00000000,
+	0x0643530c, 0x0900c30c, 0x0a6f800c, 0x00000000, 0x0603510a,
+	0x06803f0a, 0x0603520a, 0x0c792bc0, 0x0603500b, 0x0cc00000,
+	0x00000000, 0x07802cc9, 0x07c02ac9, 0x07802889, 0x07c03049,
+	0x07802809, 0x0aa08009, 0x0cc00000, 0x064e0e09, 0x09809309,
+	0x098092c9, 0x0cc00000, 0x060e0e09, 0x06435007, 0x0580f1c7,
+	0x0bef8047, 0x0aa14712, 0x06800007, 0x07802d07, 0x050011c7,
+	0x048011c7, 0x0b60c709, 0x06808008, 0x0680c008, 0x0c78ed00,
+	0x00000000, 0x0c7806c0, 0x07802807, 0x0aaf8387, 0x00000000,
+	0x07802947, 0x0aaec387, 0x064e0407, 0x091c2207, 0x0a24c0c8,
+	0x080c3e07, 0x064c3f07, 0x064c3f09, 0x09004249, 0x0581b1c7,
+	0x0a234047, 0x090241c7, 0x0a210088, 0x0aa20289, 0x0aa1c309,
+	0x0be18087, 0x0a21c048, 0x0aa102c9, 0x0aa0c309, 0x0be08047,
+	0x0c7800c0, 0x06800049, 0x07c01e49, 0x0cc00000, 0x00000000,
+	0x07800dc8, 0x0aa0c048, 0x0c780780, 0x00000000, 0x06800008,
+	0x07c00dc8, 0x07800d89, 0x07801f08, 0x09610248, 0x0609d509,
+	0x0aa18048, 0x0aa20088, 0x00000000, 0x0680774a, 0x0c780180,
+	0x00000000, 0x068077ca, 0x0c7800c0, 0x00000000, 0x0680784a,
+	0x07000288, 0x0400128a, 0x07000289, 0x09610209, 0x0609d608,
+	0x0649d308, 0x098083c8, 0x0609d308, 0x08007401, 0x0649d308,
+	0x0a6fc008, 0x00000000, 0x0cc00000, 0x00000000, 0x0680000c,
+	0x0680002a, 0x064c2907, 0x0a20c407, 0x0c7e8880, 0x00000000,
+	0x0fc081c0, 0x0aaeffc7, 0x0200c1cc, 0x064c2907, 0x0a20c407,
+	0x0c7e86c0, 0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0202a1ea,
+	0x0aa5400c, 0x0aa1418c, 0x0462d1cc, 0x0c500880, 0x0a61004c,
+	0x0c780e80, 0x06800047, 0x07c01c47, 0x064c0007, 0x0be14207,
+	0x064c2907, 0x0be0c407, 0x0d07ff2a, 0x0fc081c0, 0x064c0007,
+	0x0be10207, 0x064c2907, 0x0be08407, 0x0c7ff780, 0x0c7e80c0,
+	0x00000000, 0x0c067c80, 0x080c2301, 0x064c232b, 0x05810aeb,
+	0x048ffaeb, 0x068f000a, 0x06c0470a, 0x0540a1c7, 0x0200a1ca,
+	0x06804009, 0x0c064d40, 0x06b0400b, 0x07804007, 0x06905348,
+	0x0a80f207, 0x0c7e7c80, 0x0c067880, 0x080c2301, 0x064c232b,
+	0x05810aeb, 0x048ffaeb, 0x0fc011c0, 0x0aa14047, 0x04001aeb,
+	0x0fc071c0, 0x04007aeb, 0x07c017c7, 0x0c780140, 0x00000000,
+	0x0680004a, 0x0c006040, 0x00000000, 0x048071eb, 0x0580322b,
+	0x0aa14007, 0x06800209, 0x04001208, 0x024071c9, 0x0f8001c7,
+	0x0262a22a, 0x0c57f440, 0x0c7ff280, 0x0680002b, 0x07803d0d,
+	0x0a22830d, 0x07802f87, 0x09005207, 0x04001208, 0x0c00d080,
+	0x0202b22b, 0x090a5207, 0x04001208, 0x0c00cf80, 0x0202b22b,
+	0x0a21440d, 0x00000000, 0x0fc041c0, 0x07c02fc7, 0x04004aeb,
+	0x0c7ff940, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -500,15 +500,15 @@ static const u32 MicroCode[] __initconst = {
 	0x04c001c7, 0x09807207, 0x060c2107, 0x07802547, 0x0aa14007,
 	0x06a01008, 0x0aa0c047, 0x06a22008, 0x06a40008, 0x06431e09,
 	0x0befc049, 0x06c00108, 0x07802949, 0x0a670389, 0x0a26c053,
-	0x0c0750c0, 0x00000000, 0x0780288a, 0x0aa1c00a, 0x07802a8a,
+	0x0c074fc0, 0x00000000, 0x0780288a, 0x0aa1c00a, 0x07802a8a,
 	0x00800000, 0x078026c9, 0x04001249, 0x07c026c9, 0x00400000,
 	0x0b61408a, 0x00000000, 0x080c2170, 0x0c780700, 0x080c260e,
 	0x0683ffca, 0x0440128a, 0x0aa0c00a, 0x07802489, 0x0a6f4009,
 	0x078026c9, 0x04401249, 0x0c008080, 0x07c026c9, 0x0c780440,
 	0x08030580, 0x060e0508, 0x07802a88, 0x06801809, 0x09502248,
 	0x060c2109, 0x080c260e, 0x07c02587, 0x0ba0c087, 0x040011c7,
-	0x06800007, 0x0c0746c0, 0x07c02547, 0x06800088, 0x07c02488,
-	0x08030580, 0x0c074c00, 0x00000000, 0x07802747, 0x0aa14712,
+	0x06800007, 0x0c0745c0, 0x07c02547, 0x06800088, 0x07c02488,
+	0x08030580, 0x0c074b00, 0x00000000, 0x07802747, 0x0aa14712,
 	0x040011c7, 0x07802d08, 0x0a20c048, 0x00000000, 0x07c02747,
 	0x0c07ae80, 0x07802b0d, 0x0b608008, 0x0c7fed00, 0x0ba13fcd,
 	0x06800008, 0x0c781780, 0x07c02b08, 0x06808008, 0x0ba1070d,
@@ -529,7 +529,7 @@ static const u32 MicroCode[] __initconst = {
 	0x07802c47, 0x07802ccb, 0x024072c7, 0x0b20c0c7, 0x00000000,
 	0x068000c7, 0x095c2307, 0x07c02b4c, 0x07802b4c, 0x091c22cc,
 	0x0aa2800b, 0x044012cb, 0x095c230b, 0x0a61c00b, 0x07c02b4c,
-	0x0a20c04c, 0x06b0800b, 0x06b0c00b, 0x0c072540, 0x06b00009,
+	0x0a20c04c, 0x06b0800b, 0x06b0c00b, 0x0c072440, 0x06b00009,
 	0x0680001b, 0x07802947, 0x0aa5c387, 0x07802cc7, 0x040011c7,
 	0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88, 0x07802c48,
 	0x0b828207, 0x06800007, 0x07c02cc7, 0x07802d08, 0x04001208,
@@ -543,14 +543,14 @@ static const u32 MicroCode[] __initconst = {
 	0x064c3b07, 0x0920c1c7, 0x0b218a07, 0x0680004a, 0x07c01e4a,
 	0x07c01d8a, 0x0680204a, 0x07c0194a, 0x07802cc7, 0x095084c7,
 	0x07802d09, 0x094084c9, 0x07801909, 0x0aa14009, 0x04401249,
-	0x0a60c009, 0x07c01909, 0x0c7ef480, 0x07802c49, 0x0b014489,
+	0x0a60c009, 0x07c01909, 0x0c7ef380, 0x07802c49, 0x0b014489,
 	0x06808008, 0x0a628712, 0x0c780840, 0x00000000, 0x07802d0a,
 	0x0a20c04a, 0x0500128a, 0x040011c7, 0x054011c7, 0x0c780840,
 	0x094011ca, 0x040011c7, 0x0a410247, 0x07802b09, 0x07802d07,
-	0x0a25c047, 0x040021c9, 0x0c7f1980, 0x06800007, 0x0aa5c712,
+	0x0a25c047, 0x040021c9, 0x0c7f1880, 0x06800007, 0x0aa5c712,
 	0x07802d0a, 0x0a2bc04a, 0x04001287, 0x0a4ed24a, 0x0c780480,
-	0x06800007, 0x0c7f1540, 0x00000000, 0x0a628047, 0x040021c9,
-	0x07802d07, 0x0be1c047, 0x040021c9, 0x0c7f1580, 0x06800047,
+	0x06800007, 0x0c7f1440, 0x00000000, 0x0a628047, 0x040021c9,
+	0x07802d07, 0x0be1c047, 0x040021c9, 0x0c7f1480, 0x06800047,
 	0x0aadc007, 0x07802b09, 0x040011c9, 0x0ba10707, 0x0b6cce07,
 	0x0680c008, 0x0441c1c7, 0x05403247, 0x020091c9, 0x02008248,
 	0x07000209, 0x07c02449, 0x04001208, 0x07000209, 0x04001208,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264data_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264data_linux.h
index 8cf9825..8c7d2bb 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264data_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264data_linux.h
@@ -90,15 +90,15 @@ static const u32 MicroCode[] __initconst = {
 	0x080c260f, 0x080c2603, 0x04c001c7, 0x09807207, 0x060c2107,
 	0x07802547, 0x0aa14007, 0x06a01008, 0x0aa0c047, 0x06a22008,
 	0x06a40008, 0x06431e09, 0x0befc049, 0x06c00108, 0x07802949,
-	0x0a670389, 0x0a26c053, 0x0c0750c0, 0x00000000, 0x0780288a,
+	0x0a670389, 0x0a26c053, 0x0c074fc0, 0x00000000, 0x0780288a,
 	0x0aa1c00a, 0x07802a8a, 0x00800000, 0x078026c9, 0x04001249,
 	0x07c026c9, 0x00400000, 0x0b61408a, 0x00000000, 0x080c2170,
 	0x0c780700, 0x080c260e, 0x0683ffca, 0x0440128a, 0x0aa0c00a,
 	0x07802489, 0x0a6f4009, 0x078026c9, 0x04401249, 0x0c008080,
 	0x07c026c9, 0x0c780440, 0x08030580, 0x060e0508, 0x07802a88,
 	0x06801809, 0x09502248, 0x060c2109, 0x080c260e, 0x07c02587,
-	0x0ba0c087, 0x040011c7, 0x06800007, 0x0c0746c0, 0x07c02547,
-	0x06800088, 0x07c02488, 0x08030580, 0x0c074c00, 0x00000000,
+	0x0ba0c087, 0x040011c7, 0x06800007, 0x0c0745c0, 0x07c02547,
+	0x06800088, 0x07c02488, 0x08030580, 0x0c074b00, 0x00000000,
 	0x07802747, 0x0aa14712, 0x040011c7, 0x07802d08, 0x0a20c048,
 	0x00000000, 0x07c02747, 0x0c07ae80, 0x07802b0d, 0x0b608008,
 	0x0c7fed00, 0x0ba13fcd, 0x06800008, 0x0c781780, 0x07c02b08,
@@ -120,7 +120,7 @@ static const u32 MicroCode[] __initconst = {
 	0x0b20c0c7, 0x00000000, 0x068000c7, 0x095c2307, 0x07c02b4c,
 	0x07802b4c, 0x091c22cc, 0x0aa2800b, 0x044012cb, 0x095c230b,
 	0x0a61c00b, 0x07c02b4c, 0x0a20c04c, 0x06b0800b, 0x06b0c00b,
-	0x0c072540, 0x06b00009, 0x0680001b, 0x07802947, 0x0aa5c387,
+	0x0c072440, 0x06b00009, 0x0680001b, 0x07802947, 0x0aa5c387,
 	0x07802cc7, 0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208,
 	0x07c02e88, 0x07802c48, 0x0b828207, 0x06800007, 0x07c02cc7,
 	0x07802d08, 0x04001208, 0x078023c9, 0x0b822248, 0x07c02d08,
@@ -133,15 +133,15 @@ static const u32 MicroCode[] __initconst = {
 	0x0c7ff880, 0x07c02e87, 0x064c3b07, 0x0920c1c7, 0x0b218a07,
 	0x0680004a, 0x07c01e4a, 0x07c01d8a, 0x0680204a, 0x07c0194a,
 	0x07802cc7, 0x095084c7, 0x07802d09, 0x094084c9, 0x07801909,
-	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef480,
+	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef380,
 	0x07802c49, 0x0b014489, 0x06808008, 0x0a628712, 0x0c780840,
 	0x00000000, 0x07802d0a, 0x0a20c04a, 0x0500128a, 0x040011c7,
 	0x054011c7, 0x0c780840, 0x094011ca, 0x040011c7, 0x0a410247,
-	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1980,
+	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1880,
 	0x06800007, 0x0aa5c712, 0x07802d0a, 0x0a2bc04a, 0x04001287,
-	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f1540, 0x00000000,
+	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f1440, 0x00000000,
 	0x0a628047, 0x040021c9, 0x07802d07, 0x0be1c047, 0x040021c9,
-	0x0c7f1580, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
+	0x0c7f1480, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
 	0x0ba10707, 0x0b6cce07, 0x0680c008, 0x0441c1c7, 0x05403247,
 	0x020091c9, 0x02008248, 0x07000209, 0x07c02449, 0x04001208,
 	0x07000209, 0x04001208, 0x0700021d, 0x09610749, 0x04001208,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264header_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264header_linux.h
index 6d85f29..666a09f 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264header_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264header_linux.h
@@ -169,10 +169,10 @@ static const u32 MicroCode[] __initconst = {
 	0x04001249, 0x06801fca, 0x0740024a, 0x07c0178a, 0x07807047,
 	0x07c07187, 0x068003ca, 0x06031e0a, 0x0649ce09, 0x0aa10009,
 	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049,
-	0x00000000, 0x0649ce09, 0x0a6dc009, 0x00000000, 0x0c062880,
+	0x00000000, 0x0649ce09, 0x0a6dc009, 0x00000000, 0x0c062900,
 	0x00000000, 0x0649c007, 0x0bef7fc7, 0x07803a47, 0x0a60c047,
 	0x0c780000, 0x00800000, 0x068000c7, 0x0609c007, 0x08007401,
-	0x0c0625c0, 0x0680001b, 0x0649c007, 0x0bef7fc7, 0x07802c47,
+	0x0c062640, 0x0680001b, 0x0649c007, 0x0bef7fc7, 0x07802c47,
 	0x07803a48, 0x095101c8, 0x07803908, 0x097071c8, 0x07802308,
 	0x09021208, 0x097e11c8, 0x0609c107, 0x07803d07, 0x07802108,
 	0x095e11c8, 0x07800688, 0x094c11c8, 0x07803cc8, 0x09102208,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264mmc_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264mmc_linux.h
index f99eeb4..9fb6d49 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264mmc_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264mmc_linux.h
@@ -1,14 +1,16 @@
 static const u32 MicroCode[] __initconst = {
 	0x06bfff40, 0x06032400, 0x00400000, 0x0c780000, 0x00000000,
-	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d840, 0x00000000,
-	0x0c780540, 0x0a614148, 0x00000000, 0x0c0038c0, 0x00000000,
-	0x0c780400, 0x0a614188, 0x00000000, 0x0c006c80, 0x00000000,
-	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c0079c0, 0x00000000,
-	0x0c780180, 0x0a628208, 0x00000000, 0x0c000c40, 0x00000000,
+	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d600, 0x00000000,
+	0x0c780540, 0x0a614148, 0x00000000, 0x0c003cc0, 0x00000000,
+	0x0c780400, 0x0a614188, 0x00000000, 0x0c006c40, 0x00000000,
+	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007800, 0x00000000,
+	0x0c780180, 0x0a628208, 0x00000000, 0x0c000ec0, 0x00000000,
 	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0c7ff8c0,
 	0x06431e07, 0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860,
 	0x00000000, 0x00000000, 0x0f000800, 0x06031f20, 0x0f010840,
-	0x0c7ffc80, 0x06033f21, 0x078077c5, 0x04002c4e, 0x07400c45,
+	0x0c7ffc80, 0x06033f21, 0x0aa18000, 0x07800af1, 0x04001c71,
+	0x09010c71, 0x0a610031, 0x00000000, 0x07c00ac0, 0x07c00b00,
+	0x0cc00000, 0x00000000, 0x078077c5, 0x04002c4e, 0x07400c45,
 	0x07807800, 0x04003c4e, 0x07400c40, 0x0cc00000, 0x09610140,
 	0x07807846, 0x04004c4e, 0x07400c46, 0x07807880, 0x04005c4e,
 	0x07400c40, 0x0cc00000, 0x09610180, 0x0680400f, 0x0780704e,
@@ -17,59 +19,60 @@ static const u32 MicroCode[] __initconst = {
 	0x0cc00000, 0x00000000, 0x0649c900, 0x05808000, 0x05408000,
 	0x0609c900, 0x078031d0, 0x0680400f, 0x0780718e, 0x0540338e,
 	0x0200e38f, 0x04001c4e, 0x07000c4d, 0x078072c0, 0x090a1040,
-	0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b, 0x0aa7404b,
-	0x0c780b40, 0x00000000, 0x0980d00d, 0x0c07f340, 0x0944134c,
-	0x0a22008d, 0x09481350, 0x04004c4e, 0x07000c46, 0x04005c4e,
-	0x07000c40, 0x0c780d00, 0x09610180, 0x0c07f2c0, 0x0980d28d,
-	0x07000380, 0x09c00300, 0x07400380, 0x07807200, 0x02000300,
-	0x07c07200, 0x0649cf00, 0x0be11000, 0x06800040, 0x078071c0,
-	0x04001000, 0x0c780940, 0x07c071c0, 0x0980d04d, 0x0c07eec0,
-	0x0946134c, 0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45,
-	0x04003c4e, 0x07000c40, 0x0c780680, 0x09610140, 0x0c07ea40,
-	0x0980d28d, 0x07000380, 0x09800300, 0x0c7ff9c0, 0x07400380,
-	0x0980d00d, 0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e7c0,
-	0x09481350, 0x0c07e940, 0x094a1350, 0x0980d28d, 0x07807200,
-	0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000, 0x06800040,
-	0x078071c0, 0x04001000, 0x07c071c0, 0x04006c4e, 0x07807340,
-	0x07400c40, 0x04007c4e, 0x07400c51, 0x094c234b, 0x05801010,
-	0x05409000, 0x02c0d00d, 0x07801e40, 0x07000381, 0x09501040,
-	0x0400100e, 0x07000000, 0x0be100c0, 0x00000000, 0x07802080,
-	0x09523040, 0x07400381, 0x07802fc0, 0x09584340, 0x0900200d,
-	0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340, 0x09c0d20d,
-	0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d, 0x0980d20d,
-	0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0, 0x0900200d,
-	0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002080, 0x0780718d,
-	0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000, 0x0609ce00,
-	0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040, 0x07c01d80,
-	0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e, 0x078020c0,
-	0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb, 0x06800008,
-	0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70, 0x0a230330,
-	0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301, 0x00000000,
-	0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000, 0x04000281,
-	0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000,
-	0x0780720d, 0x0780390c, 0x0b82230d, 0x0c07f840, 0x00000000,
-	0x0400024a, 0x0aa7bfcb, 0x0680400f, 0x05403c4b, 0x02031c4f,
-	0x04001c71, 0x07000c70, 0x06800000, 0x09404c00, 0x07400c70,
-	0x07807200, 0x04401000, 0x07c07200, 0x04401071, 0x07000040,
-	0x09005000, 0x06800041, 0x03401001, 0x07807080, 0x03000040,
-	0x07c07080, 0x06810000, 0x0bc09030, 0x078071c0, 0x04401000,
-	0x07c071c0, 0x0649cf00, 0x0be11000, 0x0be0c080, 0x0c07f080,
-	0x0a8e3289, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
-	0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48, 0x02031c4f,
-	0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030, 0x04001c71,
-	0x09101030, 0x02031031, 0x02031031, 0x07000c41, 0x04001c71,
-	0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c, 0x00000000,
-	0x04000301, 0x04000348, 0x04001208, 0x0b8ec388, 0x0cc00000,
-	0x00000000, 0x0649c701, 0x0aa24001, 0x04401041, 0x0809c700,
-	0x05403041, 0x020013c1, 0x04001041, 0x07000070, 0x09c302f0,
-	0x07400070, 0x0649c801, 0x0aa24001, 0x04401041, 0x0809c800,
-	0x05403041, 0x020013c1, 0x04001041, 0x07000070, 0x09c302f0,
-	0x07400070, 0x0cc00000, 0x00000000, 0x0680400f, 0x05403c4d,
-	0x02031c4f, 0x04001c71, 0x07000c40, 0x06800081, 0x09542001,
-	0x07400c40, 0x04401c31, 0x07000c04, 0x0649cf30, 0x0a20c830,
+	0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b, 0x0aa7c04b,
+	0x0c780c40, 0x00000000, 0x0980d00d, 0x0c07f340, 0x0944134c,
+	0x0c07f040, 0x04000005, 0x0a22008d, 0x09481350, 0x04004c4e,
+	0x07000c46, 0x04005c4e, 0x07000c40, 0x0c780e00, 0x09610180,
+	0x0c07f240, 0x0980d28d, 0x07000380, 0x09c00300, 0x07400380,
+	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
+	0x06800040, 0x078071c0, 0x04001000, 0x0c780a40, 0x07c071c0,
+	0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e940, 0x04000006,
+	0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45, 0x04003c4e,
+	0x07000c40, 0x0c780700, 0x09610140, 0x0c07e940, 0x0980d28d,
+	0x07000380, 0x09800300, 0x0c7ff940, 0x07400380, 0x0980d00d,
+	0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e6c0, 0x09481350,
+	0x0c07e3c0, 0x04000005, 0x0c07e7c0, 0x094a1350, 0x0980d28d,
+	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
+	0x06800040, 0x078071c0, 0x04001000, 0x07c071c0, 0x04006c4e,
+	0x07807340, 0x07400c40, 0x04007c4e, 0x07400c51, 0x094c234b,
+	0x05801010, 0x05409000, 0x02c0d00d, 0x07801e40, 0x07000381,
+	0x09501040, 0x0400100e, 0x07000000, 0x0be100c0, 0x00000000,
+	0x07802080, 0x09523040, 0x07400381, 0x07802fc0, 0x09584340,
+	0x0900200d, 0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340,
+	0x09c0d20d, 0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d,
+	0x0980d20d, 0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0,
+	0x0900200d, 0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002080,
+	0x0780718d, 0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000,
+	0x0609ce00, 0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040,
+	0x07c01d80, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
+	0x078020c0, 0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb,
+	0x06800008, 0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70,
+	0x0a230330, 0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301,
+	0x00000000, 0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000,
+	0x04000281, 0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000,
+	0x00000000, 0x0780720d, 0x0780390c, 0x0b82230d, 0x0c07f840,
+	0x00000000, 0x0400024a, 0x0aa7bfcb, 0x0680400f, 0x05403c4b,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x06800000, 0x09404c00,
+	0x07400c70, 0x07807200, 0x04401000, 0x07c07200, 0x04401071,
+	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
+	0x03000040, 0x07c07080, 0x06810000, 0x0bc09030, 0x078071c0,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be11000, 0x0be0c080,
+	0x0c07f080, 0x0a8e3289, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0780704e, 0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030,
+	0x04001c71, 0x09101030, 0x02031031, 0x02031031, 0x07000c41,
+	0x04001c71, 0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c,
+	0x00000000, 0x04000301, 0x04000348, 0x04001208, 0x0b8ec388,
+	0x0cc00000, 0x00000000, 0x0649c701, 0x0aa24001, 0x04401041,
+	0x0809c700, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
+	0x09c302f0, 0x07400070, 0x0649c801, 0x0aa24001, 0x04401041,
+	0x0809c800, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
+	0x09c302f0, 0x07400070, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x05403c4d, 0x02031c4f, 0x04001c71, 0x07000c40, 0x06800081,
+	0x09542001, 0x07400c40, 0x04401c31, 0x07000c04, 0x0c7800c0,
 	0x05808044, 0x0be20041, 0x07801c01, 0x0aa10001, 0x0a216004,
 	0x06800001, 0x07c01c01, 0x05809040, 0x0a218041, 0x06800001,
-	0x09523001, 0x07400c40, 0x0c781700, 0x044012cb, 0x0c07f400,
+	0x09523001, 0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f440,
 	0x00000000, 0x0649c001, 0x0bef7fc1, 0x09101044, 0x0a60c00b,
 	0x05409041, 0x0809d100, 0x09123c04, 0x0540210b, 0x03430130,
 	0x0649d104, 0x02c04c04, 0x0609d104, 0x0940504d, 0x09184c00,
@@ -80,128 +83,125 @@ static const u32 MicroCode[] __initconst = {
 	0x06800144, 0x06800184, 0x094a3044, 0x07802130, 0x0aa0c030,
 	0x00000000, 0x09801201, 0x090c2c00, 0x0a60c0b0, 0x00000000,
 	0x09801201, 0x04401c71, 0x07000c70, 0x090a2c30, 0x09542070,
-	0x078017f0, 0x09583070, 0x06803230, 0x02030370, 0x07000c30,
-	0x09610070, 0x06800030, 0x02030370, 0x07000c04, 0x0aa1c00b,
-	0x0aa2404b, 0x0aa3408b, 0x0aa3c0cb, 0x0aa4c10b, 0x0aa5414b,
-	0x00000000, 0x0609ca04, 0x0c780580, 0x0609c101, 0x0649ca30,
-	0x09610c04, 0x0609ca30, 0x0c780440, 0x0609c201, 0x0609cb04,
-	0x0c780380, 0x0609c301, 0x0649cb30, 0x09610c04, 0x0609cb30,
-	0x0c780240, 0x0609c401, 0x0609cc04, 0x0c780180, 0x0609c501,
-	0x0649cc30, 0x09610c04, 0x0609cc30, 0x0609c601, 0x0649cf01,
-	0x0be09001, 0x0be100c0, 0x078071c0, 0x04401000, 0x07c071c0,
-	0x0cc00000, 0x00000000, 0x0680000b, 0x07803d0d, 0x0a21880d,
-	0x0780318c, 0x07801b8d, 0x0b00334c, 0x00000000, 0x07801b8c,
-	0x078071cd, 0x0649cf00, 0x0be0d000, 0x0b01d30d, 0x0c7800c0,
-	0x0680004c, 0x0b81330d, 0x00000000, 0x0c07d080, 0x00000000,
-	0x0a617fcd, 0x0c079a00, 0x00000000, 0x0c780300, 0x00000000,
-	0x07800b00, 0x0400004c, 0x09401040, 0x07c00b01, 0x05810041,
-	0x0c07da00, 0x07c00ac1, 0x040012cb, 0x0aa0818b, 0x0c7ff840,
-	0x0aa1400b, 0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00,
-	0x0cc00000, 0x00000000, 0x07800b0c, 0x0bee004c, 0x07802fcc,
-	0x0aa0c00c, 0x0780210c, 0x0a6d004c, 0x078071cc, 0x0bac808c,
-	0x0c07c880, 0x00000000, 0x0aabffcd, 0x07800b00, 0x07800af0,
-	0x09610030, 0x04002000, 0x0b0e000c, 0x0c7ffa40, 0x00000000,
-	0x0680000b, 0x078071cd, 0x0aa4400d, 0x0c07c540, 0x00000000,
-	0x0a61bfcd, 0x00000000, 0x0c078e80, 0x00000000, 0x0c780280,
-	0x00000000, 0x07807180, 0x0a807340, 0x00000000, 0x0c07cf00,
-	0x00000000, 0x040012cb, 0x0aa0818b, 0x0c7ffbc0, 0x0aa1c00b,
-	0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00, 0x0c7ffa40,
-	0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
-	0x06800008, 0x06800007, 0x07807186, 0x078072c0, 0x0a225800,
-	0x07c07087, 0x05403c46, 0x02031c4f, 0x07000c70, 0x09005c30,
-	0x06800041, 0x03401c01, 0x07c07081, 0x05403c48, 0x02031c4f,
-	0x04001c71, 0x07000c70, 0x0a23c0f0, 0x0a406188, 0x06800000,
-	0x09444c00, 0x07400c70, 0x0c780280, 0x06800047, 0x06800000,
-	0x09406c00, 0x07400c70, 0x06810000, 0x0bc04030, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x04001208, 0x0b8ec388, 0x0cc00000,
-	0x07c07207, 0x0680400f, 0x0780704e, 0x06800008, 0x06800007,
-	0x07807186, 0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70,
-	0x06810000, 0x0a007030, 0x0a805188, 0x00000000, 0x09c302b0,
-	0x0c7800c0, 0x07400c70, 0x06800047, 0x04001208, 0x0b8f3388,
-	0x0cc00000, 0x07c071c7, 0x0400138e, 0x0780734d, 0x0240e38d,
-	0x07807300, 0x0b610080, 0x00000000, 0x0200e34e, 0x0400138e,
-	0x06800008, 0x07807109, 0x0680a00a, 0x0a403209, 0x0cc00000,
-	0x00000000, 0x05402108, 0x0200410a, 0x04002c44, 0x07000c40,
-	0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380, 0x07000105,
-	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
-	0x04001c44, 0x07000c70, 0x09002030, 0x0aa14040, 0x0aa18080,
-	0x06800000, 0x0c780180, 0x094421c0, 0x0c780100, 0x09c07087,
-	0x0c780080, 0x09c070c7, 0x0be4c307, 0x06800000, 0x094021c0,
-	0x07807200, 0x04401000, 0x07c07200, 0x04401046, 0x07000040,
-	0x09005000, 0x06800041, 0x03401001, 0x07807080, 0x03000040,
-	0x07c07080, 0x06810000, 0x0bc04007, 0x078071c0, 0x04401000,
-	0x07c071c0, 0x0649cf00, 0x0be14080, 0x07400187, 0x0be0d000,
-	0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000, 0x07807108,
-	0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000,
-	0x05402108, 0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71,
-	0x07000c41, 0x09610001, 0x0a42a380, 0x07000105, 0x06804031,
-	0x05403005, 0x02006031, 0x04001186, 0x07000187, 0x04001c44,
-	0x07000c70, 0x09002030, 0x0aa14040, 0x0aa1c080, 0x06800000,
-	0x0c780200, 0x094441c0, 0x09c07087, 0x0c780140, 0x09c07107,
-	0x09c070c7, 0x0c780080, 0x09c07147, 0x0be4c307, 0x06800000,
+	0x078017f0, 0x09583070, 0x07c00b0c, 0x05810c0c, 0x07c00af0,
+	0x06803230, 0x02030370, 0x07000c30, 0x09610070, 0x06800030,
+	0x02030370, 0x07000c04, 0x0aa0c00b, 0x0aa1404b, 0x00000000,
+	0x0609ca04, 0x0c7801c0, 0x0609c101, 0x0649ca30, 0x09610c04,
+	0x0609ca30, 0x0c780080, 0x0609c201, 0x0649cf01, 0x0be09001,
+	0x0be100c0, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
+	0x00000000, 0x0680000b, 0x07803d0d, 0x0a21880d, 0x0780318c,
+	0x07801b8d, 0x0b00334c, 0x00000000, 0x07801b8c, 0x078071cd,
+	0x0649cf00, 0x0be0d000, 0x0b01730d, 0x0c7800c0, 0x0680004c,
+	0x0b80d30d, 0x00000000, 0x0c07d4c0, 0x00000000, 0x0a613fcd,
+	0x0c079cc0, 0x00000000, 0x0c780180, 0x0c07dfc0, 0x00000000,
+	0x040012cb, 0x0aa0808b, 0x0c7ff9c0, 0x0aa1400b, 0x06800080,
+	0x0950800b, 0x0609c000, 0x0609ce00, 0x0cc00000, 0x00000000,
+	0x0649cf0c, 0x0bee208c, 0x078071cc, 0x0bad808c, 0x0c07cf40,
+	0x00000000, 0x0aacffcd, 0x07800b00, 0x07800af0, 0x09610030,
+	0x04002000, 0x07802ff0, 0x0a60c030, 0x0b8e700c, 0x0c7ffac0,
+	0x0b0e500c, 0x0c7ffa40, 0x00000000, 0x0680000b, 0x078071cd,
+	0x0aa3c00d, 0x0c07cb00, 0x00000000, 0x0a613fcd, 0x0c079300,
+	0x00000000, 0x0c780240, 0x07807180, 0x0a807340, 0x00000000,
+	0x0c07d540, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc40,
+	0x0aa1c00b, 0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00,
+	0x0c7ffac0, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0780704e, 0x06800008, 0x06800007, 0x07807186, 0x078072c0,
+	0x0a225800, 0x07c07087, 0x05403c46, 0x02031c4f, 0x07000c70,
+	0x09005c30, 0x06800041, 0x03401c01, 0x07c07081, 0x05403c48,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x0a23c0f0, 0x0a406188,
+	0x06800000, 0x09444c00, 0x07400c70, 0x0c780280, 0x06800047,
+	0x06800000, 0x09406c00, 0x07400c70, 0x06810000, 0x0bc04030,
+	0x078071c0, 0x04401000, 0x07c071c0, 0x04001208, 0x0b8ec388,
+	0x0cc00000, 0x07c07207, 0x0680400f, 0x0780704e, 0x06800008,
+	0x06800007, 0x07807186, 0x05403c48, 0x02031c4f, 0x04001c71,
+	0x07000c70, 0x06810000, 0x0a007030, 0x0a805188, 0x00000000,
+	0x09c302b0, 0x0c7800c0, 0x07400c70, 0x06800047, 0x04001208,
+	0x0b8f3388, 0x0cc00000, 0x07c071c7, 0x0400138e, 0x0780734d,
+	0x0240e38d, 0x07807300, 0x0b610080, 0x00000000, 0x0200e34e,
+	0x0400138e, 0x06800008, 0x07807109, 0x0680a00a, 0x0a403209,
+	0x0cc00000, 0x00000000, 0x05402108, 0x0200410a, 0x04002c44,
+	0x07000c40, 0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380,
+	0x07000105, 0x06804031, 0x05403005, 0x02006031, 0x04001186,
+	0x07000187, 0x04001c44, 0x07000c70, 0x09002030, 0x0aa14040,
+	0x0aa18080, 0x06800000, 0x0c780180, 0x094421c0, 0x0c780100,
+	0x09c07087, 0x0c780080, 0x09c070c7, 0x0be4c307, 0x06800000,
 	0x094021c0, 0x07807200, 0x04401000, 0x07c07200, 0x04401046,
 	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
 	0x03000040, 0x07c07080, 0x06810000, 0x0bc04007, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x0cc00000, 0x07400187, 0x04001208,
-	0x0b8ce248, 0x0cc00000, 0x00000000, 0x0680000d, 0x07807300,
-	0x0b60c080, 0x00000000, 0x0680004d, 0x07807108, 0x07807149,
-	0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000, 0x05402108,
-	0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71, 0x07000c41,
-	0x09610001, 0x03800340, 0x0a41c380, 0x07000105, 0x06804031,
-	0x05403005, 0x02006031, 0x04001186, 0x07000187, 0x0a24c307,
-	0x06800000, 0x094061c0, 0x07807200, 0x04401000, 0x07c07200,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x07400187,
+	0x0be0d000, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
+	0x07807108, 0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000,
+	0x00000000, 0x05402108, 0x0200410a, 0x04002c44, 0x07000c40,
+	0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x04001c44, 0x07000c70, 0x09002030, 0x0aa14040, 0x0aa1c080,
+	0x06800000, 0x0c780200, 0x094441c0, 0x09c07087, 0x0c780140,
+	0x09c07107, 0x09c070c7, 0x0c780080, 0x09c07147, 0x0be4c307,
+	0x06800000, 0x094021c0, 0x07807200, 0x04401000, 0x07c07200,
 	0x04401046, 0x07000040, 0x09005000, 0x06800041, 0x03401001,
 	0x07807080, 0x03000040, 0x07c07080, 0x06810000, 0x0bc04007,
 	0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000, 0x07400187,
-	0x04001208, 0x0b8db248, 0x0cc00000, 0x00000000, 0x0400134d,
-	0x0780734c, 0x0240d34c, 0x07807300, 0x0b610080, 0x00000000,
-	0x0200d30d, 0x0400134d, 0x06800008, 0x07807109, 0x0680a00a,
-	0x0a403209, 0x0cc00000, 0x00000000, 0x05402108, 0x0200410a,
-	0x04002c44, 0x07000c40, 0x04001c71, 0x07000c41, 0x09610001,
-	0x0a417340, 0x07000105, 0x06804031, 0x05403005, 0x02006031,
-	0x04001186, 0x07000187, 0x04001c44, 0x07000c70, 0x09002030,
-	0x0aa14040, 0x0aa18080, 0x068000c0, 0x0c780180, 0x094821c0,
-	0x0c780100, 0x09807107, 0x0c780080, 0x09807147, 0x04006c46,
-	0x07400c4e, 0x0cc00000, 0x07400187, 0x04001208, 0x0b8e1248,
-	0x0cc00000, 0x00000000, 0x0440138e, 0x0680000d, 0x07807300,
-	0x0b60c080, 0x00000000, 0x0680004d, 0x07807108, 0x07807149,
+	0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000, 0x0680000d,
+	0x07807300, 0x0b60c080, 0x00000000, 0x0680004d, 0x07807108,
+	0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000,
+	0x05402108, 0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71,
+	0x07000c41, 0x09610001, 0x03800340, 0x0a41c380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x0a24c307, 0x06800000, 0x094061c0, 0x07807200, 0x04401000,
+	0x07c07200, 0x04401046, 0x07000040, 0x09005000, 0x06800041,
+	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
+	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
+	0x07400187, 0x04001208, 0x0b8db248, 0x0cc00000, 0x00000000,
+	0x0400134d, 0x0780734c, 0x0240d34c, 0x07807300, 0x0b610080,
+	0x00000000, 0x0200d30d, 0x0400134d, 0x06800008, 0x07807109,
 	0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000, 0x05402108,
 	0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71, 0x07000c41,
-	0x09610001, 0x03800340, 0x0b01b380, 0x07000105, 0x06804031,
-	0x05403005, 0x02006031, 0x04001186, 0x07000187, 0x0a250307,
-	0x06800000, 0x094061c0, 0x07807200, 0x04401000, 0x07c07200,
-	0x04401046, 0x07000040, 0x09005000, 0x06800041, 0x03401001,
-	0x07807080, 0x03000040, 0x07c07080, 0x06810000, 0x0bc04007,
-	0x078071c0, 0x04401000, 0x07c071c0, 0x07400187, 0x04001208,
-	0x0b8dc248, 0x0cc00000, 0x00000000, 0x06800010, 0x078020b1,
-	0x0a6240b1, 0x0649cf31, 0x0a21d031, 0x07800bb1, 0x0aa14031,
-	0x0c07aa80, 0x07c00b90, 0x0c07a300, 0x00000000, 0x0649cf31,
-	0x0be100b1, 0x078072f1, 0x09005031, 0x0a638140, 0x06800011,
-	0x0c07a800, 0x00000000, 0x0780e100, 0x0be18080, 0x09001400,
-	0x0c079fc0, 0x00000000, 0x0c781800, 0x00000000, 0x0c07af40,
-	0x00000000, 0x0c781700, 0x06800000, 0x090a2071, 0x0780e130,
-	0x0a858001, 0x0a857030, 0x0680e10f, 0x070003c0, 0x0aa2c040,
-	0x0aa3c080, 0x0aa4c0c0, 0x0aa68100, 0x00000000, 0x04605040,
-	0x0c500740, 0x00000000, 0x04606040, 0x0c5010c0, 0x0c781280,
-	0x04001c4f, 0x0c07af00, 0x07000c4e, 0x0c7ffc40, 0x040023cf,
-	0x04001c4f, 0x0c07be80, 0x07000c4e, 0x0c7ffb00, 0x040023cf,
-	0x04002c4f, 0x0c07cc00, 0x07000c4e, 0x04001c4f, 0x0c07d800,
-	0x07000c4d, 0x0c7ff900, 0x040033cf, 0x04001c4f, 0x07000c4e,
-	0x0c07e280, 0x00000000, 0x0c7ff780, 0x040023cf, 0x0c079a80,
-	0x00000000, 0x0c079300, 0x00000000, 0x06800007, 0x07807331,
-	0x0b250071, 0x07807770, 0x07807780, 0x09610c00, 0x07807841,
-	0x07807880, 0x09610040, 0x02401c01, 0x07c07841, 0x05810001,
-	0x07c07880, 0x078077c1, 0x07807800, 0x09610040, 0x02401c01,
-	0x07c077c1, 0x05810001, 0x07c07800, 0x0c7801c0, 0x07c07441,
-	0x07c07447, 0x07c077c7, 0x07c07807, 0x07c07847, 0x07c07887,
-	0x07c07347, 0x07c07487, 0x07c07647, 0x07c07687, 0x07c076c7,
-	0x07c07707, 0x07c07747, 0x07c07787, 0x0c7fed40, 0x040013cf,
-	0x04001c4f, 0x07000c4e, 0x0c07be00, 0x00000000, 0x06800050,
-	0x0400044e, 0x0c7feb40, 0x040023cf, 0x0680400f, 0x0780718e,
-	0x0540338e, 0x0200e38f, 0x04001c4e, 0x07000c40, 0x0a2140c0,
-	0x0c071940, 0x07c031d0, 0x0cc00000, 0x00000000, 0x078072f1,
-	0x09005031, 0x090a2071, 0x0aa10140, 0x0aa0c001, 0x0c073fc0,
-	0x00000000, 0x0649cf00, 0x0a219000, 0x0c071600, 0x07c031d0,
-	0x0c077340, 0x00000000, 0x0c780140, 0x0c077280, 0x00000000,
-	0x0c071440, 0x07c031d0, 0x0cc00000, 0x00000000
+	0x09610001, 0x0a417340, 0x07000105, 0x06804031, 0x05403005,
+	0x02006031, 0x04001186, 0x07000187, 0x04001c44, 0x07000c70,
+	0x09002030, 0x0aa14040, 0x0aa18080, 0x068000c0, 0x0c780180,
+	0x094821c0, 0x0c780100, 0x09807107, 0x0c780080, 0x09807147,
+	0x04006c46, 0x07400c4e, 0x0cc00000, 0x07400187, 0x04001208,
+	0x0b8e1248, 0x0cc00000, 0x00000000, 0x0440138e, 0x0680000d,
+	0x07807300, 0x0b60c080, 0x00000000, 0x0680004d, 0x07807108,
+	0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000,
+	0x05402108, 0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71,
+	0x07000c41, 0x09610001, 0x03800340, 0x0b01b380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x0a250307, 0x06800000, 0x094061c0, 0x07807200, 0x04401000,
+	0x07c07200, 0x04401046, 0x07000040, 0x09005000, 0x06800041,
+	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
+	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x07400187,
+	0x04001208, 0x0b8dc248, 0x0cc00000, 0x00000000, 0x06800010,
+	0x078020b1, 0x0a62c0b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
+	0x0aa1c031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x07c01e50,
+	0x0c07a300, 0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1,
+	0x09005031, 0x0a638140, 0x06800011, 0x0c07a780, 0x00000000,
+	0x0780e100, 0x0be18080, 0x09001400, 0x0c079fc0, 0x00000000,
+	0x0c781800, 0x00000000, 0x0c07aec0, 0x00000000, 0x0c781700,
+	0x06800000, 0x090a2071, 0x0780e130, 0x0a858001, 0x0a857030,
+	0x0680e10f, 0x070003c0, 0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0,
+	0x0aa68100, 0x00000000, 0x04605040, 0x0c500740, 0x00000000,
+	0x04606040, 0x0c5010c0, 0x0c781280, 0x04001c4f, 0x0c07ae80,
+	0x07000c4e, 0x0c7ffc40, 0x040023cf, 0x04001c4f, 0x0c07be00,
+	0x07000c4e, 0x0c7ffb00, 0x040023cf, 0x04002c4f, 0x0c07cb80,
+	0x07000c4e, 0x04001c4f, 0x0c07d780, 0x07000c4d, 0x0c7ff900,
+	0x040033cf, 0x04001c4f, 0x07000c4e, 0x0c07e200, 0x00000000,
+	0x0c7ff780, 0x040023cf, 0x0c079a00, 0x00000000, 0x0c079300,
+	0x00000000, 0x06800007, 0x07807331, 0x0b250071, 0x07807770,
+	0x07807780, 0x09610c00, 0x07807841, 0x07807880, 0x09610040,
+	0x02401c01, 0x07c07841, 0x05810001, 0x07c07880, 0x078077c1,
+	0x07807800, 0x09610040, 0x02401c01, 0x07c077c1, 0x05810001,
+	0x07c07800, 0x0c7801c0, 0x07c07441, 0x07c07447, 0x07c077c7,
+	0x07c07807, 0x07c07847, 0x07c07887, 0x07c07347, 0x07c07487,
+	0x07c07647, 0x07c07687, 0x07c076c7, 0x07c07707, 0x07c07747,
+	0x07c07787, 0x0c7fed40, 0x040013cf, 0x04001c4f, 0x07000c4e,
+	0x0c07bd80, 0x00000000, 0x06800050, 0x0400044e, 0x0c7feb40,
+	0x040023cf, 0x0680400f, 0x0780718e, 0x0540338e, 0x0200e38f,
+	0x04001c4e, 0x07000c40, 0x0a2140c0, 0x0c071d80, 0x07c031d0,
+	0x0cc00000, 0x00000000, 0x078072f1, 0x09005031, 0x090a2071,
+	0x0aa10140, 0x0aa0c001, 0x0c074580, 0x00000000, 0x0649cf00,
+	0x0a219000, 0x0c071a40, 0x07c031d0, 0x0c0774c0, 0x00000000,
+	0x0c780140, 0x0c077400, 0x00000000, 0x0c071880, 0x07c031d0,
+	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264slice_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264slice_linux.h
index d486253..62e2a6c 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264slice_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264slice_linux.h
@@ -11,8 +11,8 @@ static const u32 MicroCode[] __initconst = {
 	0x06800000, 0x07c0e100, 0x07c07540, 0x07c07580, 0x07c075c0,
 	0x07c07600, 0x078074b1, 0x04001c71, 0x078020c0, 0x06800041,
 	0x0340f001, 0x044013cf, 0x028313f1, 0x0a834ab1, 0x07c07371,
-	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a980,
-	0x00000000, 0x068000f3, 0x0c008a80, 0x07c02bf3, 0x07807187,
+	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a780,
+	0x00000000, 0x068000f3, 0x0c008880, 0x07c02bf3, 0x07807187,
 	0x07807048, 0x0a403207, 0x0c7e0200, 0x00000000, 0x06800033,
 	0x07c02bf3, 0x068002c0, 0x06031e00, 0x00000000, 0x06431e00,
 	0x0befc040, 0x00000000, 0x0649cf00, 0x0a20d000, 0x06800340,
@@ -23,12 +23,12 @@ static const u32 MicroCode[] __initconst = {
 	0x06431e00, 0x0bee8040, 0x00000000, 0x0c7ff1c0, 0x00000000,
 	0x07c0736a, 0x07c072eb, 0x07c0732c, 0x07c0e12d, 0x07c0756e,
 	0x0581002e, 0x07c07580, 0x07c075ef, 0x0581002f, 0x07c07600,
-	0x0c009b80, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
+	0x0c009980, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
 	0x09610209, 0x060c3208, 0x078077c8, 0x07807809, 0x09610209,
 	0x060c3208, 0x07807848, 0x07807889, 0x09610209, 0x060c3208,
-	0x06800073, 0x0c007940, 0x07c02bf3, 0x07807187, 0x07807048,
+	0x06800073, 0x0c007740, 0x07c02bf3, 0x07807187, 0x07807048,
 	0x0a403207, 0x0c7df0c0, 0x00000000, 0x06800033, 0x07c02bf3,
-	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c07aa40,
+	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c07a940,
 	0x00000000, 0x07800c48, 0x0aa1c008, 0x07800bc8, 0x07800c09,
 	0x09610209, 0x06800009, 0x0c780100, 0x07c00c49, 0x0c062580,
 	0x00000000, 0x0649cf09, 0x0be29009, 0x07800cc9, 0x0a620009,
@@ -54,20 +54,20 @@ static const u32 MicroCode[] __initconst = {
 	0x0aa24007, 0x07807407, 0x0c061b40, 0x080c2301, 0x07c073c7,
 	0x09505207, 0x0c061a40, 0x080c2301, 0x07c07407, 0x09605207,
 	0x07802947, 0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007,
-	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c06a3c0, 0x0680c009,
+	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c06a440, 0x0680c009,
 	0x068000c7, 0x07c0d087, 0x0fc011c0, 0x0aa10007, 0x00000000,
-	0x0c06a200, 0x0680d089, 0x07802907, 0x0a60c087, 0x06800008,
+	0x0c06a280, 0x0680d089, 0x07802907, 0x0a60c087, 0x06800008,
 	0x06815408, 0x09402207, 0x0a644047, 0x06094208, 0x0c061340,
 	0x080c2301, 0x09484207, 0x0c061280, 0x080c2301, 0x09504207,
-	0x06094208, 0x0680c007, 0x06094007, 0x0c06a3c0, 0x078073c9,
-	0x0680d807, 0x06094007, 0x0c06a2c0, 0x07807409, 0x0c7808c0,
+	0x06094208, 0x0680c007, 0x06094007, 0x0c06a440, 0x078073c9,
+	0x0680d807, 0x06094007, 0x0c06a340, 0x07807409, 0x0c7808c0,
 	0x00000000, 0x0fc011c0, 0x06800808, 0x0aa14007, 0x078073c7,
 	0x0c060e00, 0x080c2301, 0x07c073c7, 0x09505207, 0x07802947,
 	0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007, 0x0fc011c0,
-	0x0aa10007, 0x00000000, 0x0c069780, 0x0680c009, 0x078028c7,
+	0x0aa10007, 0x00000000, 0x0c069800, 0x0680c009, 0x078028c7,
 	0x04000207, 0x0aa34007, 0x06094208, 0x0c060980, 0x080c2301,
 	0x09484207, 0x0c0608c0, 0x080c2301, 0x09504207, 0x06094208,
-	0x0680c007, 0x06094007, 0x0c069a00, 0x078073c9, 0x06494007,
+	0x0680c007, 0x06094007, 0x0c069a80, 0x078073c9, 0x06494007,
 	0x09c07247, 0x06094007, 0x07802047, 0x0aa7c007, 0x07802007,
 	0x06800148, 0x0a82a207, 0x00000000, 0x06800007, 0x07c0e107,
 	0x0fc011c0, 0x0aa5c007, 0x0680e109, 0x04000289, 0x02407289,
@@ -80,85 +80,83 @@ static const u32 MicroCode[] __initconst = {
 	0x09402207, 0x0c780100, 0x060c2108, 0x0fc021c0, 0x07c0e107,
 	0x068004ca, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
 	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049, 0x00000000,
-	0x07801e87, 0x0a608047, 0x0c782bc0, 0x0680a009, 0x0680400a,
-	0x0680ec08, 0x080c2400, 0x0c069d00, 0x078070cc, 0x080c2400,
+	0x07801e87, 0x0a608047, 0x0c782a40, 0x0680a009, 0x0680400a,
+	0x0680ec08, 0x080c2400, 0x0c069d80, 0x078070cc, 0x080c2400,
 	0x0680000b, 0x0780724c, 0x078073cd, 0x0400134d, 0x0b80334c,
 	0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d, 0x0540234d,
-	0x0200d349, 0x0700034e, 0x05408410, 0x02010390, 0x0649cf07,
-	0x0a225007, 0x00000000, 0x054033ce, 0x0200f3ca, 0x070003cf,
-	0x091013cf, 0x0aa0c00f, 0x0680004f, 0x07c01e4f, 0x0400134d,
-	0x0700034d, 0x0900234d, 0x094a240d, 0x040013cb, 0x0be0c0cf,
-	0x00000000, 0x060c2210, 0x0a60c00b, 0x00000000, 0x07c01990,
-	0x040012cb, 0x0b8e330b, 0x0a2240cc, 0x090022cc, 0x0680010c,
-	0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc, 0x0940840b,
-	0x060c2210, 0x07802087, 0x06800188, 0x0a802207, 0x0c781d80,
-	0x0680f608, 0x080c2408, 0x0c068f40, 0x0780728c, 0x080c2408,
-	0x0680000b, 0x0780740d, 0x0400134d, 0x0b80334c, 0x00000000,
-	0x0400030d, 0x0200d2c8, 0x0700034d, 0x0540234d, 0x0200d349,
-	0x0700034e, 0x05408410, 0x02010390, 0x0400134d, 0x0700034d,
-	0x0900234d, 0x0649cf07, 0x0a225007, 0x00000000, 0x054033ce,
+	0x0200d349, 0x0700034e, 0x05408410, 0x02010390, 0x054033ce,
 	0x0200f3ca, 0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f,
-	0x07c01e4f, 0x046002cb, 0x0c481140, 0x07803a47, 0x0540338e,
-	0x0200e38a, 0x0700038f, 0x090053cf, 0x06031f07, 0x06033f0f,
-	0x0c058840, 0x08031e15, 0x0780732b, 0x0a60c0ab, 0x0680002c,
-	0x0680006c, 0x06431f07, 0x07803c0f, 0x054013cf, 0x0380fb0f,
-	0x020073c7, 0x0680180f, 0x06031f07, 0x06033f0f, 0x0c0584c0,
-	0x08031e15, 0x06431f07, 0x06433f0f, 0x097081cf, 0x0780230f,
-	0x090213cf, 0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7,
-	0x0780790f, 0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce,
-	0x070003cf, 0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce,
-	0x070003ec, 0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce,
-	0x070003ed, 0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e,
-	0x078077af, 0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac,
-	0x0b403b6e, 0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180,
-	0x09807747, 0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb,
-	0x060c3907, 0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000,
-	0x060c2210, 0x040012cb, 0x0b8a030b, 0x0a2240cc, 0x090022cc,
-	0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc,
-	0x0940840b, 0x060c2210, 0x0649cf0a, 0x0a21500a, 0x0780208a,
-	0x0a60c08a, 0x0680000a, 0x07c01e4a, 0x068c000a, 0x06c0470a,
-	0x0680c009, 0x0c059c40, 0x06a0400b, 0x0c05c880, 0x080c2301,
-	0x0c05ca00, 0x00000000, 0x0401a1c7, 0x07802248, 0x02007207,
-	0x07c02387, 0x07802287, 0x0aa40007, 0x06800009, 0x0c05c5c0,
-	0x080c2301, 0x0aa30047, 0x09402247, 0x0c05c4c0, 0x080c2301,
-	0x0c05c640, 0x00000000, 0x094c4247, 0x0c05c380, 0x080c2301,
-	0x0c05c500, 0x00000000, 0x09444247, 0x060c3109, 0x0c7f1a00,
-	0x00000000, 0x0c0662c0, 0x00000000, 0x0680400f, 0x0780704e,
-	0x0780734d, 0x0780730c, 0x078072c0, 0x090a1040, 0x090c1c00,
-	0x02c0bc01, 0x07807188, 0x0aa0c00c, 0x0aa3c04c, 0x0c780900,
-	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x09061040,
-	0x04005c71, 0x07000c70, 0x0be4c040, 0x0a248080, 0x0a4112c1,
-	0x0a410370, 0x0cc00000, 0x0680004a, 0x05403c48, 0x020313f1,
-	0x04001c71, 0x07000c40, 0x09041040, 0x04005c71, 0x07000c70,
-	0x0be18080, 0x0a214040, 0x0a4042c1, 0x0a403370, 0x0cc00000,
-	0x0680004a, 0x04803000, 0x0aa20000, 0x0aa1c0c0, 0x00000000,
-	0x04405c71, 0x07000c40, 0x09800000, 0x09800040, 0x07400c40,
-	0x06800008, 0x06830007, 0x05403c48, 0x020313f1, 0x04001c71,
-	0x07000c40, 0x0be180c0, 0x0bc051c0, 0x06800000, 0x07400c40,
-	0x0c780140, 0x07c07188, 0x04001208, 0x0b8f5388, 0x0c780d40,
-	0x07807780, 0x0580f000, 0x0a20c040, 0x06800001, 0x09801181,
-	0x07802000, 0x0a60c140, 0x04401c31, 0x09801141, 0x07801c40,
-	0x094e1040, 0x07400c01, 0x0aa7400b, 0x06801801, 0x07802300,
-	0x09021000, 0x05401000, 0x03801001, 0x07803cca, 0x0900828a,
-	0x0340a00a, 0x078078c5, 0x07807900, 0x09610140, 0x07803a40,
-	0x06031f00, 0x06033f01, 0x0c055480, 0x08031e15, 0x06800046,
-	0x07807087, 0x06431f04, 0x06800009, 0x03400246, 0x0bc0f1c0,
-	0x04401071, 0x07000070, 0x09405c09, 0x07400070, 0x02c07007,
-	0x07c07087, 0x0649c900, 0x09c007c0, 0x0609c900, 0x07c079c5,
-	0x05810145, 0x07c07a05, 0x0cc00000, 0x0680000a, 0x02005105,
-	0x04001249, 0x0b8ee289, 0x0649c900, 0x098007c0, 0x0609c900,
-	0x0cc00000, 0x07c0718e, 0x07802171, 0x04600031, 0x0c480b80,
-	0x07802180, 0x06800041, 0x0340f001, 0x0580138f, 0x078072c0,
-	0x09005000, 0x0a618140, 0x06800000, 0x07c00b00, 0x07c07640,
-	0x07c07680, 0x07c07440, 0x0780764d, 0x07807680, 0x09610340,
-	0x0780734c, 0x0780744b, 0x078073b1, 0x0b4052f1, 0x02400c4b,
-	0x0b807380, 0x0c780180, 0x0200d3cd, 0x024002f1, 0x0b003380,
-	0x0c780080, 0x0240d3cd, 0x040002f1, 0x078072c0, 0x090a2000,
-	0x0aa14000, 0x0581000d, 0x07c0764d, 0x07c07680, 0x07c0744b,
-	0x07807331, 0x0b6100b1, 0x020052cd, 0x0c781e00, 0x04000185,
-	0x078074c0, 0x07807501, 0x09610001, 0x0c781cc0, 0x02006005,
-	0x078020c0, 0x06800041, 0x0340f001, 0x078072c0, 0x09005000,
-	0x0a620140, 0x06800000, 0x07c00b00, 0x07c07480, 0x07c076c0,
+	0x07c01e4f, 0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d,
+	0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210, 0x0a60c00b,
+	0x00000000, 0x07c01990, 0x040012cb, 0x0b8e630b, 0x0a2240cc,
+	0x090022cc, 0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410,
+	0x0d07ffcc, 0x0940840b, 0x060c2210, 0x07802087, 0x06800188,
+	0x0a802207, 0x0c781cc0, 0x0680f608, 0x080c2408, 0x0c069080,
+	0x0780728c, 0x080c2408, 0x0680000b, 0x0780740d, 0x0400134d,
+	0x0b80334c, 0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d,
+	0x0540234d, 0x0200d349, 0x0700034e, 0x05408410, 0x02010390,
+	0x0400134d, 0x0700034d, 0x0900234d, 0x054033ce, 0x0200f3ca,
+	0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f, 0x07c01e4f,
+	0x046002cb, 0x0c481140, 0x07803a47, 0x0540338e, 0x0200e38a,
+	0x0700038f, 0x090053cf, 0x06031f07, 0x06033f0f, 0x0c0589c0,
+	0x08031e15, 0x0780732b, 0x0a60c0ab, 0x0680002c, 0x0680006c,
+	0x06431f07, 0x07803c0f, 0x054013cf, 0x0380fb0f, 0x020073c7,
+	0x0680180f, 0x06031f07, 0x06033f0f, 0x0c058640, 0x08031e15,
+	0x06431f07, 0x06433f0f, 0x097081cf, 0x0780230f, 0x090213cf,
+	0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7, 0x0780790f,
+	0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce, 0x070003cf,
+	0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce, 0x070003ec,
+	0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce, 0x070003ed,
+	0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e, 0x078077af,
+	0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac, 0x0b403b6e,
+	0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180, 0x09807747,
+	0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb, 0x060c3907,
+	0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210,
+	0x040012cb, 0x0b8a330b, 0x0a2240cc, 0x090022cc, 0x0680010c,
+	0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc, 0x0940840b,
+	0x060c2210, 0x0780208a, 0x0a60c08a, 0x0680000a, 0x07c01e4a,
+	0x068c000a, 0x06c0470a, 0x0680c009, 0x0c059e40, 0x06a0400b,
+	0x0c05ca80, 0x080c2301, 0x0c05cc00, 0x00000000, 0x0401a1c7,
+	0x07802248, 0x02007207, 0x07c02387, 0x07802287, 0x0aa40007,
+	0x06800009, 0x0c05c7c0, 0x080c2301, 0x0aa30047, 0x09402247,
+	0x0c05c6c0, 0x080c2301, 0x0c05c840, 0x00000000, 0x094c4247,
+	0x0c05c580, 0x080c2301, 0x0c05c700, 0x00000000, 0x09444247,
+	0x060c3109, 0x0c7f1b00, 0x00000000, 0x0c066540, 0x00000000,
+	0x0680400f, 0x0780704e, 0x0780734d, 0x0780730c, 0x078072c0,
+	0x090a1040, 0x090c1c00, 0x02c0bc01, 0x07807188, 0x0aa0c00c,
+	0x0aa3c04c, 0x0c780900, 0x05403c48, 0x020313f1, 0x04001c71,
+	0x07000c40, 0x09061040, 0x04005c71, 0x07000c70, 0x0be4c040,
+	0x0a248080, 0x0a4112c1, 0x0a410370, 0x0cc00000, 0x0680004a,
+	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x09041040,
+	0x04005c71, 0x07000c70, 0x0be18080, 0x0a214040, 0x0a4042c1,
+	0x0a403370, 0x0cc00000, 0x0680004a, 0x04803000, 0x0aa20000,
+	0x0aa1c0c0, 0x00000000, 0x04405c71, 0x07000c40, 0x09800000,
+	0x09800040, 0x07400c40, 0x06800008, 0x06830007, 0x05403c48,
+	0x020313f1, 0x04001c71, 0x07000c40, 0x0be180c0, 0x0bc051c0,
+	0x06800000, 0x07400c40, 0x0c780140, 0x07c07188, 0x04001208,
+	0x0b8f5388, 0x0c780d40, 0x07807780, 0x0580f000, 0x0a20c040,
+	0x06800001, 0x09801181, 0x07802000, 0x0a60c140, 0x04401c31,
+	0x09801141, 0x07801c40, 0x094e1040, 0x07400c01, 0x0aa7400b,
+	0x06801801, 0x07802300, 0x09021000, 0x05401000, 0x03801001,
+	0x07803cca, 0x0900828a, 0x0340a00a, 0x078078c5, 0x07807900,
+	0x09610140, 0x07803a40, 0x06031f00, 0x06033f01, 0x0c055680,
+	0x08031e15, 0x06800046, 0x07807087, 0x06431f04, 0x06800009,
+	0x03400246, 0x0bc0f1c0, 0x04401071, 0x07000070, 0x09405c09,
+	0x07400070, 0x02c07007, 0x07c07087, 0x0649c900, 0x09c007c0,
+	0x0609c900, 0x07c079c5, 0x05810145, 0x07c07a05, 0x0cc00000,
+	0x0680000a, 0x02005105, 0x04001249, 0x0b8ee289, 0x0649c900,
+	0x098007c0, 0x0609c900, 0x0cc00000, 0x07c0718e, 0x07802171,
+	0x04600031, 0x0c480b40, 0x07802180, 0x06800041, 0x0340f001,
+	0x0580138f, 0x078072c0, 0x09005000, 0x0a614140, 0x06800000,
+	0x07c07640, 0x07c07680, 0x07c07440, 0x0780764d, 0x07807680,
+	0x09610340, 0x0780734c, 0x0780744b, 0x078073b1, 0x0b4052f1,
+	0x02400c4b, 0x0b807380, 0x0c780180, 0x0200d3cd, 0x024002f1,
+	0x0b003380, 0x0c780080, 0x0240d3cd, 0x040002f1, 0x078072c0,
+	0x090a2000, 0x0aa14000, 0x0581000d, 0x07c0764d, 0x07c07680,
+	0x07c0744b, 0x07807331, 0x0b6100b1, 0x020052cd, 0x0c781d80,
+	0x04000185, 0x078074c0, 0x07807501, 0x09610001, 0x0c781c40,
+	0x02006005, 0x078020c0, 0x06800041, 0x0340f001, 0x078072c0,
+	0x09005000, 0x0a61c140, 0x06800000, 0x07c07480, 0x07c076c0,
 	0x07c07700, 0x07c07540, 0x07c07580, 0x0780748e, 0x078076cd,
 	0x07807700, 0x09610340, 0x0780734c, 0x0b40338c, 0x00000000,
 	0x0200d3cd, 0x04602031, 0x0c501200, 0x0780398b, 0x0460000b,
@@ -168,22 +166,24 @@ static const u32 MicroCode[] __initconst = {
 	0x09610001, 0x04001c30, 0x0d07fef1, 0x02009009, 0x0a608008,
 	0x0c780580, 0x04401208, 0x06800007, 0x0b8052c8, 0x00000000,
 	0x040011c7, 0x0c7fff40, 0x024082c8, 0x06031f07, 0x06033f09,
-	0x0c053340, 0x08031e15, 0x04001c48, 0x06808030, 0x06431f0a,
+	0x0c0535c0, 0x08031e15, 0x04001c48, 0x06808030, 0x06431f0a,
 	0x07000c00, 0x04001c30, 0x07000c01, 0x09610001, 0x04001c30,
 	0x0d07fef1, 0x0200a00a, 0x078072c0, 0x090a2000, 0x0a614000,
 	0x07803800, 0x07803841, 0x09610001, 0x0200a00a, 0x07807545,
 	0x07807580, 0x09610140, 0x0200514a, 0x07807331, 0x0a60c031,
-	0x0c780780, 0x04000185, 0x07803886, 0x078038c0, 0x09610180,
-	0x02006185, 0x0b60c0b1, 0x0c7805c0, 0x04000146, 0x078075c0,
-	0x07807601, 0x09610001, 0x0c780480, 0x02006006, 0x078072c0,
-	0x09005000, 0x0a614140, 0x06800005, 0x07c00b05, 0x0c7802c0,
-	0x06800006, 0x0200b30d, 0x054012cb, 0x078072c0, 0x090a2000,
-	0x0a60c000, 0x00000000, 0x044012cb, 0x0400014b, 0x0400018b,
-	0x07c076cd, 0x0581000d, 0x07c07700, 0x0b803185, 0x04000105,
-	0x04000106, 0x040002c4, 0x02c0b14b, 0x02c0b18b, 0x0a20c04b,
-	0x0680004b, 0x07c00b0b, 0x07c07744, 0x05810004, 0x07c07780,
-	0x07c077c5, 0x05810005, 0x07c07800, 0x07c07846, 0x05810006,
-	0x07c07880, 0x0cc00000, 0x07c0748c, 0x00000000, 0x00000000,
+	0x0c780740, 0x04000185, 0x07803886, 0x078038c0, 0x09610180,
+	0x02006185, 0x0b60c0b1, 0x0c780580, 0x04000146, 0x078075c0,
+	0x07807601, 0x09610001, 0x0c780440, 0x02006006, 0x078072c0,
+	0x09005000, 0x0a610140, 0x06800005, 0x0c7802c0, 0x06800006,
+	0x0200b30d, 0x054012cb, 0x078072c0, 0x090a2000, 0x0a60c000,
+	0x00000000, 0x044012cb, 0x0400014b, 0x0400018b, 0x07c076cd,
+	0x0581000d, 0x07c07700, 0x0b803185, 0x04000105, 0x04000106,
+	0x07c07744, 0x05810004, 0x07c07780, 0x07c077c5, 0x05810005,
+	0x07c07800, 0x07c07846, 0x05810006, 0x07c07880, 0x0cc00000,
+	0x07c0748c, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/h264c_linux.h b/drivers/amlogic/amports/arch/ucode/h264/h264c_linux.h
index 0b426ed..c14aeb8 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/h264c_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/h264c_linux.h
@@ -2,13 +2,13 @@ static const u32 MicroCode[] __initconst = {
 	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x064c0800,
 	0x09800300, 0x00000000, 0x060c0800, 0x0649d019, 0x0c006600,
 	0x0649c134, 0x06880000, 0x060c2900, 0x080c0002, 0x06bfda80,
-	0x07c02d40, 0x06030400, 0x00400000, 0x0c007d80, 0x00000000,
+	0x07c02d40, 0x06030400, 0x00400000, 0x0c007e00, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
 	0x00000000, 0x06431e35, 0x0befc075, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0c780500, 0x00000000, 0x0cc00000,
 	0x00400000, 0x0c780d40, 0x064c0007, 0x0cc00000, 0x00400000,
-	0x0c787dc0, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c787c40, 0x00000000, 0x0c787a00, 0x00000000,
+	0x0c787e40, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c787cc0, 0x00000000, 0x0c787a80, 0x00000000,
 	0x0cc00000, 0x00400000, 0x0aa44133, 0x0aa0c033, 0x0c7fff00,
 	0x0680001b, 0x0649cf1c, 0x0bee405c, 0x064c431c, 0x0ae0ffdc,
 	0x0c7ffd80, 0x0680001b, 0x064c411c, 0x0968c71c, 0x0a40bc9c,
@@ -34,7 +34,7 @@ static const u32 MicroCode[] __initconst = {
 	0x080c0101, 0x0684044a, 0x060c2e0a, 0x060c380e, 0x0c001880,
 	0x00000000, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0aa18009,
 	0x0649470a, 0x0910828a, 0x07802cc8, 0x0a4fc20a, 0x04401249,
-	0x0cc00000, 0x00000000, 0x0c009ac0, 0x00000000, 0x06490b09,
+	0x0cc00000, 0x00000000, 0x0c009b40, 0x00000000, 0x06490b09,
 	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
 	0x06090b09, 0x08095007, 0x08095000, 0x0683ffc9, 0x06498f0a,
 	0x0aa0c009, 0x0a6f800a, 0x04401249, 0x064c3d0a, 0x0580a28a,
@@ -60,11 +60,11 @@ static const u32 MicroCode[] __initconst = {
 	0x09808348, 0x09c08208, 0x060c2908, 0x064c080a, 0x0980a34a,
 	0x060c080a, 0x0c07e240, 0x00000000, 0x0c07f700, 0x00000000,
 	0x080c0600, 0x0fc081c0, 0x0649cf0a, 0x0a21500a, 0x0a611e47,
-	0x0a20c80a, 0x0c780dc0, 0x00000000, 0x090a2207, 0x07c02048,
+	0x0be0c40a, 0x0c780dc0, 0x00000000, 0x090a2207, 0x07c02048,
 	0x0481f1c7, 0x07c02007, 0x0aa38147, 0x0aa34047, 0x0a60c187,
-	0x0c781040, 0x0681ca8d, 0x0a60c1c7, 0x0c780f80, 0x0682000d,
+	0x0c781040, 0x0681c98d, 0x0a60c1c7, 0x0c780f80, 0x0682000d,
 	0x0a60c207, 0x0c780ec0, 0x0682738d, 0x0a608247, 0x0c780740,
-	0x0c781400, 0x0c78e480, 0x00000000, 0x064c4408, 0x09101208,
+	0x0c781400, 0x0c78e500, 0x00000000, 0x064c4408, 0x09101208,
 	0x0aaf8048, 0x064c5109, 0x064c460a, 0x07801a48, 0x05410208,
 	0x07801a0b, 0x020082c8, 0x0580a208, 0x06031f08, 0x06033f09,
 	0x0c07b180, 0x08031e15, 0x06431f08, 0x06433f09, 0x09708209,
@@ -101,291 +101,291 @@ static const u32 MicroCode[] __initconst = {
 	0x091e10c3, 0x0bef8043, 0x064c0903, 0x06803002, 0x063f0002,
 	0x06800002, 0x063f0002, 0x06803fc2, 0x060c0903, 0x06800002,
 	0x060c0c02, 0x06c04042, 0x060c0d02, 0x080c0101, 0x06840442,
-	0x060c2e02, 0x064c4010, 0x064c4211, 0x02411411, 0x04008451,
-	0x07c01a11, 0x05810451, 0x07c01a51, 0x0cc00000, 0x00000000,
-	0x07802bc2, 0x0aa0c002, 0x06800102, 0x06030502, 0x0b60c11b,
-	0x0cc00000, 0x00000000, 0x00800000, 0x00000000, 0x0c079d80,
-	0x00000000, 0x080c0a01, 0x080c2800, 0x080c0002, 0x0cc00000,
-	0x00400000, 0x064c441c, 0x0910171c, 0x0a6f801c, 0x0c7f85c0,
-	0x00000000, 0x0cc00000, 0x00400000, 0x064e1214, 0x091e1514,
-	0x0bef0054, 0x078029d5, 0x0649d914, 0x0900c514, 0x0acfe554,
-	0x07802494, 0x0aa44094, 0x0c7828c0, 0x06800015, 0x06c04015,
-	0x07802857, 0x097c1557, 0x060e1215, 0x07802d15, 0x0a20c055,
-	0x06800018, 0x06880018, 0x06c04418, 0x02018d18, 0x06800014,
-	0x07c02a94, 0x0c782280, 0x06800114, 0x07802a95, 0x0aa08095,
-	0x0c781200, 0x078024d6, 0x0aeb4096, 0x07802857, 0x0aa4c712,
-	0x07802ad4, 0x05406514, 0x07802d15, 0x05801555, 0x0be0c055,
-	0x06800015, 0x06880015, 0x06c04415, 0x02015d15, 0x02014554,
-	0x04440514, 0x060e1314, 0x0aa44017, 0x040c0614, 0x06805c16,
-	0x060c2116, 0x0c780340, 0x04040618, 0x05405514, 0x07802d15,
-	0x0be0c055, 0x06800015, 0x06880015, 0x06c04415, 0x02015d15,
-	0x02014554, 0x04420514, 0x060e1314, 0x04060614, 0x07802596,
-	0x0aa14016, 0x06a2c215, 0x0aa0c056, 0x06a2c015, 0x06a2c115,
-	0x0aa10017, 0x06c04015, 0x068003d4, 0x09506554, 0x097c1557,
-	0x060e1215, 0x06800014, 0x07c02a94, 0x06800114, 0x0c781b00,
-	0x07c02494, 0x078025d5, 0x078029d6, 0x02415595, 0x02415595,
-	0x07802857, 0x0aa0c017, 0x02415595, 0x02415595, 0x07802694,
-	0x05409514, 0x02014554, 0x05403554, 0x02015d15, 0x060e1315,
-	0x07802596, 0x0aa34016, 0x06a44215, 0x0aa2c056, 0x06a44015,
-	0x0c780240, 0x06a44115, 0x0a64c0d5, 0x078026d4, 0x064e0c16,
-	0x09010596, 0x0b8e7594, 0x0cc00000, 0x00400000, 0x0aa10017,
-	0x06c0c015, 0x068005d4, 0x09506554, 0x097c1557, 0x060e1215,
-	0x06800018, 0x06800014, 0x07c02a94, 0x06800154, 0x0c781100,
-	0x07c02494, 0x07802515, 0x0aa1c015, 0x04401555, 0x07c02515,
-	0x078024d5, 0x04401555, 0x0c780d80, 0x07c024d5, 0x07802615,
-	0x07c02655, 0x07802694, 0x05409514, 0x02014554, 0x078029d6,
-	0x02015595, 0x07c02615, 0x05403554, 0x02015d15, 0x060e1315,
-	0x07802596, 0x0aa14016, 0x06a16215, 0x0aa0c056, 0x06a16015,
-	0x06a16115, 0x07803056, 0x0aa28016, 0x078026d4, 0x064e0c16,
-	0x09010596, 0x0b804594, 0x07802656, 0x0c7fda00, 0x07c02616,
-	0x04001514, 0x07c026d4, 0x07c02715, 0x06c00015, 0x060e1215,
-	0x06800054, 0x0c780680, 0x07c02494, 0x0ba58114, 0x07802855,
-	0x0a608015, 0x0c7ff4c0, 0x078026d5, 0x04001555, 0x07c026d5,
-	0x0aa0c114, 0x06800015, 0x080c2170, 0x0c780300, 0x07c02855,
-	0x0a6d0054, 0x078024d5, 0x0aa74015, 0x04401555, 0x0b26c055,
-	0x07c024d5, 0x07802a54, 0x0aa0c0d4, 0x00000000, 0x080c2170,
-	0x06800014, 0x07c02494, 0x0cc00000, 0x00400000, 0x0aa0c014,
-	0x06880018, 0x06800018, 0x06c04418, 0x0c780a40, 0x02018d18,
-	0x0aa0c712, 0x090a8518, 0x090c7518, 0x07802c56, 0x0b823594,
-	0x0a8f5594, 0x091a1518, 0x0aa20014, 0x06880018, 0x0c780180,
-	0x06800018, 0x0aa70018, 0x078025d5, 0x0c7ffcc0, 0x00000000,
-	0x06c04418, 0x02018d18, 0x07802694, 0x05409514, 0x078029d6,
-	0x02415595, 0x02014554, 0x05403554, 0x02015d15, 0x060e1315,
-	0x07802714, 0x09004554, 0x0aa14015, 0x06a14214, 0x0aa0c115,
-	0x06a14014, 0x06a14114, 0x06c08014, 0x060e0d18, 0x0aa0c712,
-	0x04020618, 0x04020618, 0x0c7ff4c0, 0x060e1214, 0x07802694,
-	0x05409514, 0x02014554, 0x078029d6, 0x02015595, 0x07c025d5,
-	0x05403554, 0x02015d15, 0x060e1315, 0x07802714, 0x0a618018,
-	0x09c141d4, 0x060e1214, 0x068000d4, 0x0c7ff0c0, 0x07c02494,
-	0x06c08014, 0x060e0d18, 0x0aae8712, 0x04020618, 0x0c7ffe00,
-	0x04020618, 0x0683ffca, 0x0a61000a, 0x0440128a, 0x0c780140,
-	0x080e1200, 0x064e1209, 0x091e1249, 0x0bee8049, 0x064e0009,
-	0x064e030a, 0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000,
-	0x064c180d, 0x0980d20d, 0x060c180d, 0x09c0d20d, 0x060c180d,
-	0x0680020d, 0x0d00000d, 0x00000000, 0x060e0009, 0x060e030a,
-	0x060e0e0b, 0x0cc00000, 0x060e0c0c, 0x0c000ac0, 0x00000000,
-	0x06810109, 0x06c34749, 0x06090709, 0x06490b09, 0x09809009,
-	0x09809089, 0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09,
-	0x06800009, 0x06c04409, 0x02009d09, 0x06094409, 0x06880009,
-	0x06c04409, 0x02009d09, 0x06094509, 0x0cc00000, 0x00000000,
-	0x0c000c00, 0x00000000, 0x06497f08, 0x068000c7, 0x09702207,
-	0x06097f08, 0x06498e08, 0x09c08788, 0x06098e08, 0x06820888,
-	0x06c00208, 0x07802c47, 0x0b20c2c7, 0x06800447, 0x06800c07,
-	0x09706207, 0x09808648, 0x06095108, 0x08095007, 0x0cc00000,
-	0x08095000, 0x0683ffc8, 0x06490909, 0x0a210049, 0x0aa0c008,
-	0x0c7fff40, 0x04401208, 0x0683ffc8, 0x06490909, 0x09343249,
-	0x0a2241c9, 0x0aa20008, 0x06490b09, 0x098090c9, 0x06090b09,
-	0x09c090c9, 0x06090b09, 0x0c7ffdc0, 0x04401208, 0x06490b09,
-	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
-	0x06090b09, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0649bb08,
-	0x0920c208, 0x06495307, 0x090011c7, 0x020081c8, 0x0aa10008,
-	0x0aa0c009, 0x0c7ffe40, 0x04401249, 0x0cc00000, 0x00000000,
-	0x04000289, 0x02408289, 0x0b64a008, 0x00000000, 0x0c077e40,
+	0x060c2e02, 0x06bfffc2, 0x07c00ac2, 0x064c4010, 0x064c4211,
+	0x02411411, 0x04008451, 0x07c01a11, 0x05810451, 0x07c01a51,
+	0x0cc00000, 0x00000000, 0x07802bc2, 0x0aa0c002, 0x06800102,
+	0x06030502, 0x0b60c11b, 0x0cc00000, 0x00000000, 0x00800000,
+	0x00000000, 0x0c079d00, 0x00000000, 0x080c0a01, 0x080c2800,
+	0x080c0002, 0x0cc00000, 0x00400000, 0x064c441c, 0x0910171c,
+	0x0a6f801c, 0x0c7f8540, 0x00000000, 0x0cc00000, 0x00400000,
+	0x064e1214, 0x091e1514, 0x0bef0054, 0x078029d5, 0x0649d914,
+	0x0900c514, 0x0acfe554, 0x07802494, 0x0aa44094, 0x0c7828c0,
+	0x06800015, 0x06c04015, 0x07802857, 0x097c1557, 0x060e1215,
+	0x07802d15, 0x0a20c055, 0x06800018, 0x06880018, 0x06c04418,
+	0x02018d18, 0x06800014, 0x07c02a94, 0x0c782280, 0x06800114,
+	0x07802a95, 0x0aa08095, 0x0c781200, 0x078024d6, 0x0aeb4096,
+	0x07802857, 0x0aa4c712, 0x07802ad4, 0x05406514, 0x07802d15,
+	0x05801555, 0x0be0c055, 0x06800015, 0x06880015, 0x06c04415,
+	0x02015d15, 0x02014554, 0x04440514, 0x060e1314, 0x0aa44017,
+	0x040c0614, 0x06805c16, 0x060c2116, 0x0c780340, 0x04040618,
+	0x05405514, 0x07802d15, 0x0be0c055, 0x06800015, 0x06880015,
+	0x06c04415, 0x02015d15, 0x02014554, 0x04420514, 0x060e1314,
+	0x04060614, 0x07802596, 0x0aa14016, 0x06a2c215, 0x0aa0c056,
+	0x06a2c015, 0x06a2c115, 0x0aa10017, 0x06c04015, 0x068003d4,
+	0x09506554, 0x097c1557, 0x060e1215, 0x06800014, 0x07c02a94,
+	0x06800114, 0x0c781b00, 0x07c02494, 0x078025d5, 0x078029d6,
+	0x02415595, 0x02415595, 0x07802857, 0x0aa0c017, 0x02415595,
+	0x02415595, 0x07802694, 0x05409514, 0x02014554, 0x05403554,
+	0x02015d15, 0x060e1315, 0x07802596, 0x0aa34016, 0x06a44215,
+	0x0aa2c056, 0x06a44015, 0x0c780240, 0x06a44115, 0x0a64c0d5,
+	0x078026d4, 0x064e0c16, 0x09010596, 0x0b8e7594, 0x0cc00000,
+	0x00400000, 0x0aa10017, 0x06c0c015, 0x068005d4, 0x09506554,
+	0x097c1557, 0x060e1215, 0x06800018, 0x06800014, 0x07c02a94,
+	0x06800154, 0x0c781100, 0x07c02494, 0x07802515, 0x0aa1c015,
+	0x04401555, 0x07c02515, 0x078024d5, 0x04401555, 0x0c780d80,
+	0x07c024d5, 0x07802615, 0x07c02655, 0x07802694, 0x05409514,
+	0x02014554, 0x078029d6, 0x02015595, 0x07c02615, 0x05403554,
+	0x02015d15, 0x060e1315, 0x07802596, 0x0aa14016, 0x06a16215,
+	0x0aa0c056, 0x06a16015, 0x06a16115, 0x07803056, 0x0aa28016,
+	0x078026d4, 0x064e0c16, 0x09010596, 0x0b804594, 0x07802656,
+	0x0c7fda00, 0x07c02616, 0x04001514, 0x07c026d4, 0x07c02715,
+	0x06c00015, 0x060e1215, 0x06800054, 0x0c780680, 0x07c02494,
+	0x0ba58114, 0x07802855, 0x0a608015, 0x0c7ff4c0, 0x078026d5,
+	0x04001555, 0x07c026d5, 0x0aa0c114, 0x06800015, 0x080c2170,
+	0x0c780300, 0x07c02855, 0x0a6d0054, 0x078024d5, 0x0aa74015,
+	0x04401555, 0x0b26c055, 0x07c024d5, 0x07802a54, 0x0aa0c0d4,
+	0x00000000, 0x080c2170, 0x06800014, 0x07c02494, 0x0cc00000,
+	0x00400000, 0x0aa0c014, 0x06880018, 0x06800018, 0x06c04418,
+	0x0c780a40, 0x02018d18, 0x0aa0c712, 0x090a8518, 0x090c7518,
+	0x07802c56, 0x0b823594, 0x0a8f5594, 0x091a1518, 0x0aa20014,
+	0x06880018, 0x0c780180, 0x06800018, 0x0aa70018, 0x078025d5,
+	0x0c7ffcc0, 0x00000000, 0x06c04418, 0x02018d18, 0x07802694,
+	0x05409514, 0x078029d6, 0x02415595, 0x02014554, 0x05403554,
+	0x02015d15, 0x060e1315, 0x07802714, 0x09004554, 0x0aa14015,
+	0x06a14214, 0x0aa0c115, 0x06a14014, 0x06a14114, 0x06c08014,
+	0x060e0d18, 0x0aa0c712, 0x04020618, 0x04020618, 0x0c7ff4c0,
+	0x060e1214, 0x07802694, 0x05409514, 0x02014554, 0x078029d6,
+	0x02015595, 0x07c025d5, 0x05403554, 0x02015d15, 0x060e1315,
+	0x07802714, 0x0a618018, 0x09c141d4, 0x060e1214, 0x068000d4,
+	0x0c7ff0c0, 0x07c02494, 0x06c08014, 0x060e0d18, 0x0aae8712,
+	0x04020618, 0x0c7ffe00, 0x04020618, 0x0683ffca, 0x0a61000a,
+	0x0440128a, 0x0c780140, 0x080e1200, 0x064e1209, 0x091e1249,
+	0x0bee8049, 0x064e0009, 0x064e030a, 0x064e0e0b, 0x064e0c0c,
+	0x083f0040, 0x083f0000, 0x064c180d, 0x0980d20d, 0x060c180d,
+	0x09c0d20d, 0x060c180d, 0x0680020d, 0x0d00000d, 0x00000000,
+	0x060e0009, 0x060e030a, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
+	0x0c000ac0, 0x00000000, 0x06810109, 0x06c34749, 0x06090709,
+	0x06490b09, 0x09809009, 0x09809089, 0x06090b09, 0x09c09009,
+	0x09c09089, 0x06090b09, 0x06800009, 0x06c04409, 0x02009d09,
+	0x06094409, 0x06880009, 0x06c04409, 0x02009d09, 0x06094509,
+	0x0cc00000, 0x00000000, 0x0c000c00, 0x00000000, 0x06497f08,
+	0x068000c7, 0x09702207, 0x06097f08, 0x06498e08, 0x09c08788,
+	0x06098e08, 0x06820888, 0x06c00208, 0x07802c47, 0x0b20c2c7,
+	0x06800447, 0x06800c07, 0x09706207, 0x09808648, 0x06095108,
+	0x08095007, 0x0cc00000, 0x08095000, 0x0683ffc8, 0x06490909,
+	0x0a210049, 0x0aa0c008, 0x0c7fff40, 0x04401208, 0x0683ffc8,
+	0x06490909, 0x09343249, 0x0a2241c9, 0x0aa20008, 0x06490b09,
+	0x098090c9, 0x06090b09, 0x09c090c9, 0x06090b09, 0x0c7ffdc0,
+	0x04401208, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
+	0x09c09009, 0x09c09089, 0x06090b09, 0x0cc00000, 0x00000000,
+	0x0683ffc9, 0x0649bb08, 0x0920c208, 0x06495307, 0x090011c7,
+	0x020081c8, 0x0aa10008, 0x0aa0c009, 0x0c7ffe40, 0x04401249,
+	0x0cc00000, 0x00000000, 0x04000289, 0x02408289, 0x0b64a008,
+	0x00000000, 0x0c077dc0, 0x080c2301, 0x02408289, 0x0b60d008,
+	0x00000000, 0x07400247, 0x0aa280c7, 0x04001249, 0x0c077bc0,
 	0x080c2301, 0x02408289, 0x0b60d008, 0x00000000, 0x07400247,
-	0x0aa280c7, 0x04001249, 0x0c077c40, 0x080c2301, 0x02408289,
-	0x0b60d008, 0x00000000, 0x07400247, 0x0c7ffbc0, 0x04001249,
-	0x068000c7, 0x0404028a, 0x07400287, 0x0cc00000, 0x00000000,
-	0x0680000a, 0x04001249, 0x0fc011c0, 0x0aa20047, 0x0680004b,
-	0x06494207, 0x090841c7, 0x0340b1cb, 0x054082cb, 0x0c780340,
-	0x0609410b, 0x0c077640, 0x080c2301, 0x0c0777c0, 0x00000000,
-	0x040002c7, 0x0c077500, 0x080c2301, 0x0c077680, 0x00000000,
-	0x095091cb, 0x06094107, 0x0fc011c0, 0x0aa24047, 0x0680004b,
-	0x06494207, 0x091041c7, 0x0340b1cb, 0x054082cb, 0x0609410b,
-	0x0c780600, 0x0609410b, 0x0c077100, 0x080c2301, 0x0c077280,
-	0x00000000, 0x040002c7, 0x0c076fc0, 0x080c2301, 0x0c077140,
-	0x00000000, 0x095091cb, 0x06094107, 0x0c076e40, 0x080c2301,
-	0x0c076fc0, 0x00000000, 0x040002c7, 0x0c076d00, 0x080c2301,
-	0x0c076e80, 0x00000000, 0x095091cb, 0x06094107, 0x0400128a,
-	0x0b8cb24a, 0x0cc00000, 0x00000000, 0x0649c707, 0x0aa28007,
-	0x044011c7, 0x0809c700, 0x06804008, 0x054031c7, 0x02007207,
-	0x040011c7, 0x070001c8, 0x09c082c8, 0x074001c8, 0x0649c807,
-	0x0aa28007, 0x044011c7, 0x0809c800, 0x06804008, 0x054031c7,
-	0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8, 0x074001c8,
-	0x0cc00000, 0x00000000, 0x0200d308, 0x0440134d, 0x0700034d,
-	0x0540234d, 0x0200d349, 0x0700034e, 0x0400040e, 0x0400134d,
-	0x0700034d, 0x0900234d, 0x094a240d, 0x09408390, 0x09508390,
-	0x09608390, 0x09708390, 0x06800210, 0x0d000010, 0x060c220e,
-	0x0cc00000, 0x00000000, 0x0649cd09, 0x06800047, 0x054101c7,
-	0x020091c9, 0x0609cd09, 0x069fffc7, 0x07c03b47, 0x07c03b87,
-	0x07c03c47, 0x07c00a07, 0x07c00a47, 0x07c00a87, 0x07c03c87,
-	0x07c01747, 0x06800207, 0x0c7f5f80, 0x07c03bc7, 0x07803c0a,
-	0x0a60c00a, 0x0c780c80, 0x0680004a, 0x07802dca, 0x0aa0800a,
-	0x0c780b80, 0x0649cf07, 0x0a2180c7, 0x07803c07, 0x0aa0c007,
-	0x0680004a, 0x0680000a, 0x0c7809c0, 0x07807347, 0x07801f48,
-	0x0a803207, 0x0c7808c0, 0x0680004a, 0x07802407, 0x07801f08,
-	0x0a803207, 0x0c780780, 0x0680004a, 0x07802047, 0x07802e08,
-	0x02009207, 0x0aa18009, 0x0a803247, 0x0a802248, 0x0c7800c0,
-	0x0c780540, 0x0680004a, 0x07802007, 0x07802e48, 0x0a803207,
-	0x0c780400, 0x0680004a, 0x0a618147, 0x07801f87, 0x07801fc8,
-	0x0a803207, 0x0c780280, 0x0680004a, 0x07802147, 0x0aa1c087,
-	0x07801807, 0x0a4033c7, 0x07801847, 0x0a803407, 0x0c780080,
-	0x0680004a, 0x0cc00000, 0x07c02dca, 0x06490908, 0x0581f208,
-	0x0a6f8008, 0x00000000, 0x06490708, 0x09808648, 0x09c08488,
-	0x06090708, 0x068400c8, 0x096e820b, 0x097e120a, 0x07802407,
-	0x040011c7, 0x048031c7, 0x09542207, 0x0580124a, 0x06094809,
-	0x06094908, 0x06800008, 0x098092c8, 0x07801987, 0x09405247,
-	0x058051c7, 0x040011c7, 0x097c2207, 0x06094809, 0x06094908,
-	0x0c07be00, 0x00000000, 0x06490708, 0x09c08648, 0x09808488,
-	0x06090708, 0x0cc00000, 0x00000000, 0x0649cf07, 0x06800048,
-	0x0a2100c7, 0x07c01e48, 0x0cc00000, 0x00000000, 0x07801988,
-	0x0aa0c008, 0x0a210807, 0x00000000, 0x0cc00000, 0x00000000,
-	0x0c07b900, 0x00000000, 0x0c07b340, 0x00000000, 0x0680001b,
-	0x0780294e, 0x0a61038e, 0x07802c4e, 0x0c780380, 0x0980b00b,
-	0x0ae6011b, 0x0c07f180, 0x00000000, 0x0400128a, 0x0b80438a,
-	0x00000000, 0x0680000a, 0x040012cb, 0x0b8f834b, 0x0b8f730a,
-	0x0c780380, 0x00000000, 0x0ae3011b, 0x0c07ee80, 0x044012cb,
-	0x0c07ee00, 0x040012cb, 0x0400128a, 0x0b80438a, 0x00000000,
-	0x0680000a, 0x040022cb, 0x0b8f634b, 0x0b8f530a, 0x0cc00000,
-	0x0680001b, 0x07803c07, 0x07802e88, 0x0a402207, 0x0c7809c0,
-	0x07c02e87, 0x07802c49, 0x0780294a, 0x0a60c30a, 0x07802c8a,
-	0x0540128a, 0x06800008, 0x0b80a247, 0x095084c7, 0x02407247,
-	0x0b8fd288, 0x04001208, 0x0649cd07, 0x040011c7, 0x0609cd07,
-	0x0cc00000, 0x06800047, 0x0aa0c007, 0x06800049, 0x07c02d89,
-	0x0aa0c712, 0x07c02cc7, 0x05401208, 0x094084c8, 0x07c02d08,
-	0x0780188a, 0x078018cb, 0x07802ccc, 0x07802d0d, 0x0c07ebc0,
-	0x06800009, 0x07802cc7, 0x0aa18007, 0x044011c7, 0x0ba0c707,
-	0x0c7fffc0, 0x0441c1c7, 0x07c02b07, 0x07802cc7, 0x07c01887,
-	0x07802d07, 0x07c018c7, 0x0cc00000, 0x06800007, 0x0c780380,
-	0x06800087, 0x0c780300, 0x06800147, 0x0c780280, 0x06800187,
-	0x0c072b80, 0x080c2301, 0x07c03c07, 0x0c072ac0, 0x080c2301,
-	0x0aad41c7, 0x0aad8007, 0x0aadc047, 0x07c01ec7, 0x07803bc8,
-	0x09061248, 0x07c02dc9, 0x0a250208, 0x07803c08, 0x0aa08008,
-	0x0c7f2b80, 0x0649cf09, 0x0a20c0c9, 0x0aa2c087, 0x0c7f2a80,
-	0x07802008, 0x0aa20148, 0x07801c48, 0x0a614008, 0x0aa08087,
-	0x0c7f2900, 0x06800048, 0x07c01c48, 0x07c01c08, 0x0649c909,
-	0x04001249, 0x0609c909, 0x06800009, 0x07c01d89, 0x0c079a00,
-	0x00000000, 0x0c07a040, 0x00000000, 0x0c072200, 0x080c2301,
-	0x07803b8d, 0x0a806347, 0x07803bc8, 0x06800049, 0x07c02dc9,
-	0x0c780080, 0x07c03b87, 0x09082248, 0x0aa1c049, 0x0680000a,
-	0x0c06f5c0, 0x06c0000a, 0x06800049, 0x09482209, 0x07c03bc8,
-	0x06b7000a, 0x06c0444a, 0x054091c7, 0x0200a1ca, 0x06804009,
-	0x06b0c00b, 0x0c06ef80, 0x00000000, 0x0780c007, 0x06905348,
-	0x0a803207, 0x0c7f1ec0, 0x07c03b8d, 0x0780c047, 0x09105207,
-	0x07803b4e, 0x0a803388, 0x0c7802c0, 0x07c03b48, 0x07803bc7,
-	0x0be20047, 0x0694000a, 0x06c0444a, 0x06808009, 0x06b0400b,
-	0x0c06eac0, 0x00000000, 0x0c780900, 0x0697000a, 0x06c0444a,
-	0x07803b48, 0x0540a1c8, 0x0200a1ca, 0x06806009, 0x06b0400b,
-	0x0c06e840, 0x00000000, 0x07804007, 0x06905348, 0x0a805207,
-	0x00000000, 0x07c03b8d, 0x0c7f1700, 0x07c03b4e, 0x0680000a,
-	0x0c00f840, 0x00000000, 0x0c017140, 0x00000000, 0x07803bc7,
-	0x0be34107, 0x0694000a, 0x06c0444a, 0x06804009, 0x06b0400b,
-	0x0c06e340, 0x00000000, 0x0694c00a, 0x06c0444a, 0x06802009,
-	0x06b0a00b, 0x0c06e1c0, 0x00000000, 0x0c013780, 0x00000000,
-	0x07803bc7, 0x0be34107, 0x0695000a, 0x06c0444a, 0x06804009,
-	0x06b0c00b, 0x0c06df40, 0x00000000, 0x0c780180, 0x0694000a,
-	0x06c0444a, 0x0680c009, 0x0c06ddc0, 0x06b0400b, 0x078020c8,
-	0x0f8001c8, 0x0649cf0a, 0x0be6808a, 0x07803bca, 0x0be6020a,
-	0x0780200a, 0x0aa5814a, 0x07801f4a, 0x0a814287, 0x0400128a,
-	0x06800049, 0x03409209, 0x04401249, 0x0280a289, 0x0a80e287,
-	0x0780394a, 0x0a63000a, 0x0649cf0a, 0x0be0d00a, 0x0c7fa580,
-	0x00000000, 0x07801eca, 0x0a61008a, 0x0680004a, 0x0c780100,
-	0x07c00b8a, 0x0680004a, 0x07c00b4a, 0x07c01f47, 0x07802107,
-	0x0a61c007, 0x068000c9, 0x0fc011c0, 0x0aa10007, 0x00000000,
-	0x0fc011c0, 0x04001247, 0x07c01f09, 0x07802007, 0x0a614147,
-	0x00000000, 0x0c06ff80, 0x080c2301, 0x07c01f87, 0x07802147,
-	0x0a65c007, 0x07802187, 0x0f8001c7, 0x07807388, 0x07c01808,
-	0x07c07387, 0x078074c7, 0x07c01847, 0x06800007, 0x07c074c7,
-	0x07c07507, 0x078021c7, 0x0aa2c007, 0x07801f07, 0x0a6240c7,
-	0x00000000, 0x0c06fa80, 0x080c2301, 0x0c06fc00, 0x00000000,
-	0x07c074c7, 0x058101c7, 0x07c07507, 0x0780738f, 0x078074d0,
-	0x07802147, 0x06800048, 0x0a422207, 0x07807547, 0x07c01807,
-	0x078075c7, 0x07c01847, 0x06800007, 0x07c07547, 0x07c07587,
-	0x07c075c7, 0x07c07607, 0x07803a87, 0x0aa54047, 0x00000000,
-	0x0c06f480, 0x080c2301, 0x0c06f600, 0x00000000, 0x07c07547,
-	0x058101c7, 0x07c07587, 0x078021c7, 0x0aa2c007, 0x07801f07,
-	0x0a6240c7, 0x00000000, 0x0c06f180, 0x080c2301, 0x0c06f300,
-	0x00000000, 0x07c075c7, 0x058101c7, 0x07c07607, 0x0780754f,
-	0x078075d0, 0x0c079400, 0x00000000, 0x07802dc7, 0x0a608007,
-	0x0c782200, 0x07801e87, 0x069fffc8, 0x0b803207, 0x040011c7,
-	0x06800147, 0x07c01e87, 0x07802d07, 0x078023c8, 0x0b802207,
-	0x0c780200, 0x0780188a, 0x078018cb, 0x0680000c, 0x078023cd,
-	0x06800049, 0x0c07a540, 0x07c01e49, 0x07801d08, 0x0649cf09,
-	0x0aa28008, 0x07803c0a, 0x0aa0800a, 0x0c781c40, 0x04401208,
-	0x07c01d08, 0x0aa08008, 0x0c781b40, 0x09c09089, 0x0609cf09,
-	0x0a22c309, 0x0780204a, 0x0a62400a, 0x07802e0a, 0x0aa1c00a,
-	0x07801f0a, 0x0aa0c0ca, 0x0680004a, 0x0680008a, 0x0c781840,
-	0x07c01d0a, 0x0680000a, 0x07c01d0a, 0x0688000a, 0x0c06bd00,
-	0x06c0000a, 0x07803bc7, 0x0be54107, 0x068001ca, 0x06031e0a,
-	0x0680001b, 0x0649ce09, 0x0aa10009, 0x00000000, 0x0809ce00,
-	0x08007401, 0x06431e09, 0x0bee4049, 0x00000000, 0x0649cf07,
-	0x0a2200c7, 0x07801d87, 0x0aa18007, 0x07801ec7, 0x0aa10087,
-	0x06800207, 0x0c7ee180, 0x07c03bc7, 0x06800013, 0x07c02cd3,
-	0x07c02d13, 0x07c02e93, 0x07c01893, 0x07c018d3, 0x06803fc7,
-	0x07c02b07, 0x06800007, 0x07c02547, 0x07c025c7, 0x07c02607,
-	0x07802c07, 0x040011c7, 0x07c024c7, 0x06800047, 0x060e0c07,
-	0x07c026c7, 0x07c02507, 0x068003c7, 0x07c02807, 0x06805c07,
-	0x060c2107, 0x080c2170, 0x06800087, 0x07c02a47, 0x06800018,
-	0x0649cf07, 0x0be1d007, 0x00000000, 0x07801ec7, 0x0aa28187,
-	0x06800007, 0x0c780200, 0x07c01e47, 0x07801ec7, 0x0a60c087,
-	0x06800007, 0x07c00b47, 0x07800b47, 0x07c01e47, 0x068003c7,
-	0x07c02fc7, 0x06800407, 0x060c2407, 0x06800007, 0x07807048,
-	0x06804009, 0x05403287, 0x0200a289, 0x0400128a, 0x0700028b,
-	0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a, 0x0700028c,
-	0x096102cc, 0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a,
-	0x0700028c, 0x096102cc, 0x060c220b, 0x040011c7, 0x0b8ee207,
-	0x00000000, 0x07801d07, 0x0aa08007, 0x0c7ecf80, 0x06800007,
-	0x07c01947, 0x06a00007, 0x060c3d07, 0x07802dc7, 0x0a618007,
-	0x00000000, 0x0c0790c0, 0x00000000, 0x0aa08007, 0x0c7eccc0,
-	0x07802047, 0x07c02e07, 0x07802007, 0x07c02e47, 0x07801ec7,
-	0x07c02087, 0x07801f47, 0x07c07347, 0x07801f07, 0x07c02407,
-	0x07801f87, 0x07c01fc7, 0x0780248a, 0x0a6fc00a, 0x00000000,
-	0x0c073140, 0x00000000, 0x07802dc7, 0x0aa2c007, 0x00000000,
-	0x0c072940, 0x00000000, 0x06498e07, 0x06800fc8, 0x097061c8,
-	0x06098e07, 0x06800008, 0x097061c8, 0x06098e07, 0x0c073340,
-	0x00000000, 0x07802087, 0x06840009, 0x0682625a, 0x0aa1c087,
-	0x06800008, 0x0682305a, 0x0aa10147, 0x06800048, 0x06800088,
-	0x06840009, 0x07c02788, 0x07c02689, 0x06800007, 0x07c02a87,
-	0x07802c8a, 0x07802107, 0x0a630007, 0x07802409, 0x0aa280c9,
-	0x0540128a, 0x0580128a, 0x06490707, 0x09807087, 0x098070c7,
-	0x06090707, 0x06495107, 0x098073c7, 0x06095107, 0x07c023ca,
-	0x07802947, 0x094421c9, 0x07c02947, 0x0a644387, 0x068000c9,
-	0x06495107, 0x094041c9, 0x06800009, 0x097821c9, 0x06095107,
-	0x06490707, 0x09807447, 0x06090707, 0x06498e07, 0x09807787,
-	0x06098e07, 0x07802087, 0x0aa0c087, 0x0682515a, 0x068214da,
-	0x07803bc8, 0x090821c8, 0x0aa18087, 0x06800087, 0x09482207,
-	0x0690000a, 0x0c068a00, 0x06c0000a, 0x0c785140, 0x07c03bc8,
-	0x07802dc7, 0x0aa18007, 0x00000000, 0x0c077880, 0x00000000,
-	0x0aa08007, 0x0c7eb480, 0x06800007, 0x07803bc8, 0x09082208,
-	0x0aa10008, 0x0684000a, 0x0c068600, 0x06c0000a, 0x07c03bc7,
-	0x07802d87, 0x0aa34007, 0x07802c47, 0x0b22c2c7, 0x07802cc7,
-	0x0a614007, 0x06495108, 0x09c08608, 0x0c7800c0, 0x07c02d87,
-	0x09808608, 0x06095108, 0x08095017, 0x08095000, 0x0c784980,
-	0x00000000, 0x07802cc9, 0x07c02ac9, 0x07802889, 0x0cc00000,
-	0x07c03049, 0x0aa14712, 0x06800007, 0x07802d07, 0x050011c7,
-	0x048011c7, 0x0b60c709, 0x06808008, 0x0680c008, 0x0c78f280,
-	0x00000000, 0x0c7806c0, 0x07802807, 0x0aaf8387, 0x00000000,
-	0x07802947, 0x0aaec387, 0x064e0407, 0x091c2207, 0x0a24c0c8,
-	0x080c3e07, 0x064c3f07, 0x064c3f09, 0x09004249, 0x0581b1c7,
-	0x0a234047, 0x090241c7, 0x0a210088, 0x0aa20289, 0x0aa1c309,
-	0x0be18087, 0x0a21c048, 0x0aa102c9, 0x0aa0c309, 0x0be08047,
-	0x0c7800c0, 0x06800049, 0x07c01e49, 0x0cc00000, 0x00000000,
-	0x07800dc8, 0x0aa0c048, 0x0c780780, 0x00000000, 0x06800008,
-	0x07c00dc8, 0x07800d89, 0x07801f08, 0x09610248, 0x0609d509,
-	0x0aa18048, 0x0aa20088, 0x00000000, 0x0680774a, 0x0c780180,
-	0x00000000, 0x068077ca, 0x0c7800c0, 0x00000000, 0x0680784a,
-	0x07000288, 0x0400128a, 0x07000289, 0x09610209, 0x0609d608,
-	0x0649d308, 0x098083c8, 0x0609d308, 0x08007401, 0x0649d308,
-	0x0a6fc008, 0x00000000, 0x0cc00000, 0x00000000, 0x0680000c,
-	0x0680002a, 0x064c2907, 0x0a20c407, 0x0c7e99c0, 0x00000000,
-	0x0fc081c0, 0x0aaeffc7, 0x0200c1cc, 0x064c2907, 0x0a20c407,
-	0x0c7e9800, 0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0202a1ea,
-	0x0aa5400c, 0x0aa1418c, 0x0462d1cc, 0x0c500880, 0x0a61004c,
-	0x0c780e80, 0x06800047, 0x07c01c47, 0x064c0007, 0x0be14207,
-	0x064c2907, 0x0be0c407, 0x0d07ff2a, 0x0fc081c0, 0x064c0007,
-	0x0be10207, 0x064c2907, 0x0be08407, 0x0c7ff780, 0x0c7e9200,
-	0x00000000, 0x0c068dc0, 0x080c2301, 0x064c232b, 0x05810aeb,
-	0x048ffaeb, 0x0697000a, 0x06c0444a, 0x0540a1c7, 0x0200a1ca,
-	0x06804009, 0x0c065e80, 0x06b0400b, 0x07804007, 0x06905348,
-	0x0a80f207, 0x0c7e8dc0, 0x0c0689c0, 0x080c2301, 0x064c232b,
-	0x05810aeb, 0x048ffaeb, 0x0fc011c0, 0x0aa14047, 0x04001aeb,
-	0x0fc071c0, 0x04007aeb, 0x07c017c7, 0x0c780140, 0x00000000,
-	0x0680004a, 0x0c006c00, 0x00000000, 0x048071eb, 0x0580322b,
-	0x0aa14007, 0x06800209, 0x04001208, 0x024071c9, 0x0f8001c7,
-	0x0262a22a, 0x0c57f440, 0x0c7ff280, 0x0680002b, 0x07803d0d,
-	0x0a22830d, 0x07802f87, 0x09005207, 0x04001208, 0x0c00dc40,
-	0x0202b22b, 0x090a5207, 0x04001208, 0x0c00db40, 0x0202b22b,
-	0x0a21440d, 0x00000000, 0x0fc041c0, 0x07c02fc7, 0x04004aeb,
-	0x0c7ff940, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0c7ffbc0, 0x04001249, 0x068000c7, 0x0404028a, 0x07400287,
+	0x0cc00000, 0x00000000, 0x0680000a, 0x04001249, 0x0fc011c0,
+	0x0aa20047, 0x0680004b, 0x06494207, 0x090841c7, 0x0340b1cb,
+	0x054082cb, 0x0c780340, 0x0609410b, 0x0c0775c0, 0x080c2301,
+	0x0c077740, 0x00000000, 0x040002c7, 0x0c077480, 0x080c2301,
+	0x0c077600, 0x00000000, 0x095091cb, 0x06094107, 0x0fc011c0,
+	0x0aa24047, 0x0680004b, 0x06494207, 0x091041c7, 0x0340b1cb,
+	0x054082cb, 0x0609410b, 0x0c780600, 0x0609410b, 0x0c077080,
+	0x080c2301, 0x0c077200, 0x00000000, 0x040002c7, 0x0c076f40,
+	0x080c2301, 0x0c0770c0, 0x00000000, 0x095091cb, 0x06094107,
+	0x0c076dc0, 0x080c2301, 0x0c076f40, 0x00000000, 0x040002c7,
+	0x0c076c80, 0x080c2301, 0x0c076e00, 0x00000000, 0x095091cb,
+	0x06094107, 0x0400128a, 0x0b8cb24a, 0x0cc00000, 0x00000000,
+	0x0649c707, 0x0aa28007, 0x044011c7, 0x0809c700, 0x06804008,
+	0x054031c7, 0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8,
+	0x074001c8, 0x0649c807, 0x0aa28007, 0x044011c7, 0x0809c800,
+	0x06804008, 0x054031c7, 0x02007207, 0x040011c7, 0x070001c8,
+	0x09c082c8, 0x074001c8, 0x0cc00000, 0x00000000, 0x0200d308,
+	0x0440134d, 0x0700034d, 0x0540234d, 0x0200d349, 0x0700034e,
+	0x0400040e, 0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d,
+	0x09408390, 0x09508390, 0x09608390, 0x09708390, 0x06800210,
+	0x0d000010, 0x060c220e, 0x0cc00000, 0x00000000, 0x0649cd09,
+	0x06800047, 0x054101c7, 0x020091c9, 0x0609cd09, 0x069fffc7,
+	0x07c03b47, 0x07c03b87, 0x07c03c47, 0x07c00a07, 0x07c00a47,
+	0x07c00a87, 0x07c03c87, 0x07c01747, 0x06800207, 0x0c7f5f00,
+	0x07c03bc7, 0x07803c0a, 0x0a60c00a, 0x0c780c80, 0x0680004a,
+	0x07802dca, 0x0aa0800a, 0x0c780b80, 0x0649cf07, 0x0a2180c7,
+	0x07803c07, 0x0aa0c007, 0x0680004a, 0x0680000a, 0x0c7809c0,
+	0x07807347, 0x07801f48, 0x0a803207, 0x0c7808c0, 0x0680004a,
+	0x07802407, 0x07801f08, 0x0a803207, 0x0c780780, 0x0680004a,
+	0x07802047, 0x07802e08, 0x02009207, 0x0aa18009, 0x0a803247,
+	0x0a802248, 0x0c7800c0, 0x0c780540, 0x0680004a, 0x07802007,
+	0x07802e48, 0x0a803207, 0x0c780400, 0x0680004a, 0x0a618147,
+	0x07801f87, 0x07801fc8, 0x0a803207, 0x0c780280, 0x0680004a,
+	0x07802147, 0x0aa1c087, 0x07801807, 0x0a4033c7, 0x07801847,
+	0x0a803407, 0x0c780080, 0x0680004a, 0x0cc00000, 0x07c02dca,
+	0x06490908, 0x0581f208, 0x0a6f8008, 0x00000000, 0x06490708,
+	0x09808648, 0x09c08488, 0x06090708, 0x068400c8, 0x096e820b,
+	0x097e120a, 0x07802407, 0x040011c7, 0x048031c7, 0x09542207,
+	0x0580124a, 0x06094809, 0x06094908, 0x06800008, 0x098092c8,
+	0x07801987, 0x09405247, 0x058051c7, 0x040011c7, 0x097c2207,
+	0x06094809, 0x06094908, 0x0c07be00, 0x00000000, 0x06490708,
+	0x09c08648, 0x09808488, 0x06090708, 0x0cc00000, 0x00000000,
+	0x0649cf07, 0x06800048, 0x0a2100c7, 0x07c01e48, 0x0cc00000,
+	0x00000000, 0x07801988, 0x0aa0c008, 0x0a210807, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0c07b900, 0x00000000, 0x0c07b340,
+	0x00000000, 0x0680001b, 0x0780294e, 0x0a61038e, 0x07802c4e,
+	0x0c780380, 0x0980b00b, 0x0ae6011b, 0x0c07f180, 0x00000000,
+	0x0400128a, 0x0b80438a, 0x00000000, 0x0680000a, 0x040012cb,
+	0x0b8f834b, 0x0b8f730a, 0x0c780380, 0x00000000, 0x0ae3011b,
+	0x0c07ee80, 0x044012cb, 0x0c07ee00, 0x040012cb, 0x0400128a,
+	0x0b80438a, 0x00000000, 0x0680000a, 0x040022cb, 0x0b8f634b,
+	0x0b8f530a, 0x0cc00000, 0x0680001b, 0x07803c07, 0x07802e88,
+	0x0a402207, 0x0c7809c0, 0x07c02e87, 0x07802c49, 0x0780294a,
+	0x0a60c30a, 0x07802c8a, 0x0540128a, 0x06800008, 0x0b80a247,
+	0x095084c7, 0x02407247, 0x0b8fd288, 0x04001208, 0x0649cd07,
+	0x040011c7, 0x0609cd07, 0x0cc00000, 0x06800047, 0x0aa0c007,
+	0x06800049, 0x07c02d89, 0x0aa0c712, 0x07c02cc7, 0x05401208,
+	0x094084c8, 0x07c02d08, 0x0780188a, 0x078018cb, 0x07802ccc,
+	0x07802d0d, 0x0c07ebc0, 0x06800009, 0x07802cc7, 0x0aa18007,
+	0x044011c7, 0x0ba0c707, 0x0c7fffc0, 0x0441c1c7, 0x07c02b07,
+	0x07802cc7, 0x07c01887, 0x07802d07, 0x07c018c7, 0x0cc00000,
+	0x06800007, 0x0c780380, 0x06800087, 0x0c780300, 0x06800147,
+	0x0c780280, 0x06800187, 0x0c072b00, 0x080c2301, 0x07c03c07,
+	0x0c072a40, 0x080c2301, 0x0aad41c7, 0x0aad8007, 0x0aadc047,
+	0x07c01ec7, 0x07803bc8, 0x09061248, 0x07c02dc9, 0x0a250208,
+	0x07803c08, 0x0aa08008, 0x0c7f2b00, 0x0649cf09, 0x0a20c0c9,
+	0x0aa2c087, 0x0c7f2a00, 0x07802008, 0x0aa20148, 0x07801c48,
+	0x0a614008, 0x0aa08087, 0x0c7f2880, 0x06800048, 0x07c01c48,
+	0x07c01c08, 0x0649c909, 0x04001249, 0x0609c909, 0x06800009,
+	0x07c01d89, 0x0c079a00, 0x00000000, 0x0c07a040, 0x00000000,
+	0x0c072180, 0x080c2301, 0x07803b8d, 0x0a806347, 0x07803bc8,
+	0x06800049, 0x07c02dc9, 0x0c780080, 0x07c03b87, 0x09082248,
+	0x0aa1c049, 0x0680000a, 0x0c06f540, 0x06c0000a, 0x06800049,
+	0x09482209, 0x07c03bc8, 0x06b7000a, 0x06c0444a, 0x054091c7,
+	0x0200a1ca, 0x06804009, 0x06b0c00b, 0x0c06ef00, 0x00000000,
+	0x0780c007, 0x06905348, 0x0a803207, 0x0c7f1e40, 0x07c03b8d,
+	0x0780c047, 0x09105207, 0x07803b4e, 0x0a803388, 0x0c7802c0,
+	0x07c03b48, 0x07803bc7, 0x0be20047, 0x0694000a, 0x06c0444a,
+	0x06808009, 0x06b0400b, 0x0c06ea40, 0x00000000, 0x0c780900,
+	0x0697000a, 0x06c0444a, 0x07803b48, 0x0540a1c8, 0x0200a1ca,
+	0x06806009, 0x06b0400b, 0x0c06e7c0, 0x00000000, 0x07804007,
+	0x06905348, 0x0a805207, 0x00000000, 0x07c03b8d, 0x0c7f1680,
+	0x07c03b4e, 0x0680000a, 0x0c00f7c0, 0x00000000, 0x0c0170c0,
+	0x00000000, 0x07803bc7, 0x0be34107, 0x0694000a, 0x06c0444a,
+	0x06804009, 0x06b0400b, 0x0c06e2c0, 0x00000000, 0x0694c00a,
+	0x06c0444a, 0x06802009, 0x06b0a00b, 0x0c06e140, 0x00000000,
+	0x0c013700, 0x00000000, 0x07803bc7, 0x0be34107, 0x0695000a,
+	0x06c0444a, 0x06804009, 0x06b0c00b, 0x0c06dec0, 0x00000000,
+	0x0c780180, 0x0694000a, 0x06c0444a, 0x0680c009, 0x0c06dd40,
+	0x06b0400b, 0x078020c8, 0x0f8001c8, 0x0649cf0a, 0x0be5808a,
+	0x07803bca, 0x0be5020a, 0x0780200a, 0x0aa4814a, 0x07801f4a,
+	0x0a810287, 0x0400128a, 0x06800049, 0x03409209, 0x04401249,
+	0x0280a289, 0x0a80a287, 0x0780394a, 0x0a62000a, 0x07801eca,
+	0x0a61008a, 0x0680004a, 0x0c780100, 0x07c00b8a, 0x0680004a,
+	0x07c00b4a, 0x07c01f47, 0x07802107, 0x0a61c007, 0x068000c9,
+	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0fc011c0, 0x04001247,
+	0x07c01f09, 0x07802007, 0x0a614147, 0x00000000, 0x0c070000,
+	0x080c2301, 0x07c01f87, 0x07802147, 0x0a65c007, 0x07802187,
+	0x0f8001c7, 0x07807388, 0x07c01808, 0x07c07387, 0x078074c7,
+	0x07c01847, 0x06800007, 0x07c074c7, 0x07c07507, 0x078021c7,
+	0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06fb00,
+	0x080c2301, 0x0c06fc80, 0x00000000, 0x07c074c7, 0x058101c7,
+	0x07c07507, 0x0780738f, 0x078074d0, 0x07802147, 0x06800048,
+	0x0a422207, 0x07807547, 0x07c01807, 0x078075c7, 0x07c01847,
+	0x06800007, 0x07c07547, 0x07c07587, 0x07c075c7, 0x07c07607,
+	0x07803a87, 0x0aa54047, 0x00000000, 0x0c06f500, 0x080c2301,
+	0x0c06f680, 0x00000000, 0x07c07547, 0x058101c7, 0x07c07587,
+	0x078021c7, 0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000,
+	0x0c06f200, 0x080c2301, 0x0c06f380, 0x00000000, 0x07c075c7,
+	0x058101c7, 0x07c07607, 0x0780754f, 0x078075d0, 0x0c079500,
+	0x00000000, 0x07802dc7, 0x0a608007, 0x0c782180, 0x07801e87,
+	0x069fffc8, 0x0b803207, 0x040011c7, 0x06800147, 0x07c01e87,
+	0x07802d07, 0x078023c8, 0x0b802207, 0x0c780200, 0x0780188a,
+	0x078018cb, 0x0680000c, 0x078023cd, 0x06800049, 0x0c07a640,
+	0x07c01e49, 0x07801d08, 0x0649cf09, 0x0aa28008, 0x07803c0a,
+	0x0aa0800a, 0x0c781bc0, 0x04401208, 0x07c01d08, 0x0aa08008,
+	0x0c781ac0, 0x09c09089, 0x0609cf09, 0x0a22c309, 0x0780204a,
+	0x0a62400a, 0x07802e0a, 0x0aa1c00a, 0x07801f0a, 0x0aa0c0ca,
+	0x0680004a, 0x0680008a, 0x0c7817c0, 0x07c01d0a, 0x0680000a,
+	0x07c01d0a, 0x0688000a, 0x0c06bd80, 0x06c0000a, 0x07803bc7,
+	0x0be54107, 0x068001ca, 0x06031e0a, 0x0680001b, 0x0649ce09,
+	0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401, 0x06431e09,
+	0x0bee4049, 0x00000000, 0x0649cf07, 0x0a2200c7, 0x07801d87,
+	0x0aa18007, 0x07801ec7, 0x0aa10087, 0x06800207, 0x0c7ee200,
+	0x07c03bc7, 0x06800013, 0x07c02cd3, 0x07c02d13, 0x07c02e93,
+	0x07c01893, 0x07c018d3, 0x06803fc7, 0x07c02b07, 0x06800007,
+	0x07c02547, 0x07c025c7, 0x07c02607, 0x07802c07, 0x040011c7,
+	0x07c024c7, 0x06800047, 0x060e0c07, 0x07c026c7, 0x07c02507,
+	0x068003c7, 0x07c02807, 0x06805c07, 0x060c2107, 0x080c2170,
+	0x06800087, 0x07c02a47, 0x06800018, 0x07801ec7, 0x0a61c087,
+	0x06800007, 0x07800b48, 0x0aa1c008, 0x06800088, 0x0c780140,
+	0x07c00b48, 0x07800b47, 0x07801e48, 0x02c07207, 0x07c01e47,
+	0x068003c7, 0x07c02fc7, 0x06800407, 0x060c2407, 0x06800007,
+	0x07807048, 0x06804009, 0x05403287, 0x0200a289, 0x0400128a,
+	0x0700028b, 0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a,
+	0x0700028c, 0x096102cc, 0x060c220b, 0x0400128a, 0x0700028b,
+	0x0400128a, 0x0700028c, 0x096102cc, 0x060c220b, 0x040011c7,
+	0x0b8ee207, 0x00000000, 0x07801d07, 0x0aa08007, 0x0c7ed080,
+	0x06800007, 0x07c01947, 0x06a00007, 0x060c3d07, 0x07802dc7,
+	0x0a618007, 0x00000000, 0x0c079240, 0x00000000, 0x0aa08007,
+	0x0c7ecdc0, 0x07802047, 0x07c02e07, 0x07802007, 0x07c02e47,
+	0x07801ec7, 0x07c02087, 0x07801f47, 0x07c07347, 0x07801f07,
+	0x07c02407, 0x07801f87, 0x07c01fc7, 0x0780248a, 0x0a6fc00a,
+	0x00000000, 0x0c0732c0, 0x00000000, 0x07802dc7, 0x0aa2c007,
+	0x00000000, 0x0c072ac0, 0x00000000, 0x06498e07, 0x06800fc8,
+	0x097061c8, 0x06098e07, 0x06800008, 0x097061c8, 0x06098e07,
+	0x0c0734c0, 0x00000000, 0x07802087, 0x06840009, 0x0682625a,
+	0x0aa1c087, 0x06800008, 0x0682305a, 0x0aa10147, 0x06800048,
+	0x06800088, 0x06840009, 0x07c02788, 0x07c02689, 0x06800007,
+	0x07c02a87, 0x07802c8a, 0x07802107, 0x0a630007, 0x07802409,
+	0x0aa280c9, 0x0540128a, 0x0580128a, 0x06490707, 0x09807087,
+	0x098070c7, 0x06090707, 0x06495107, 0x098073c7, 0x06095107,
+	0x07c023ca, 0x07802947, 0x094421c9, 0x07c02947, 0x0a644387,
+	0x068000c9, 0x06495107, 0x094041c9, 0x06800009, 0x097821c9,
+	0x06095107, 0x06490707, 0x09807447, 0x06090707, 0x06498e07,
+	0x09807787, 0x06098e07, 0x07802087, 0x0aa0c087, 0x0682515a,
+	0x068214da, 0x07803bc8, 0x090821c8, 0x0aa18087, 0x06800087,
+	0x09482207, 0x0690000a, 0x0c068b00, 0x06c0000a, 0x0c785240,
+	0x07c03bc8, 0x07802dc7, 0x0aa18007, 0x00000000, 0x0c077a00,
+	0x00000000, 0x0aa08007, 0x0c7eb580, 0x06800007, 0x07803bc8,
+	0x09082208, 0x0aa10008, 0x0684000a, 0x0c068700, 0x06c0000a,
+	0x07c03bc7, 0x07802d87, 0x0aa34007, 0x07802c47, 0x0b22c2c7,
+	0x07802cc7, 0x0a614007, 0x06495108, 0x09c08608, 0x0c7800c0,
+	0x07c02d87, 0x09808608, 0x06095108, 0x08095017, 0x08095000,
+	0x0c784a80, 0x00000000, 0x07802cc9, 0x07c02ac9, 0x07802889,
+	0x0cc00000, 0x07c03049, 0x0aa14712, 0x06800007, 0x07802d07,
+	0x050011c7, 0x048011c7, 0x0b60c709, 0x06808008, 0x0680c008,
+	0x0c78f380, 0x00000000, 0x0c7806c0, 0x07802807, 0x0aaf8387,
+	0x00000000, 0x07802947, 0x0aaec387, 0x064e0407, 0x091c2207,
+	0x0a24c0c8, 0x080c3e07, 0x064c3f07, 0x064c3f09, 0x09004249,
+	0x0581b1c7, 0x0a234047, 0x090241c7, 0x0a210088, 0x0aa20289,
+	0x0aa1c309, 0x0be18087, 0x0a21c048, 0x0aa102c9, 0x0aa0c309,
+	0x0be08047, 0x0c7800c0, 0x06800049, 0x07c01e49, 0x0cc00000,
+	0x00000000, 0x07800dc8, 0x0aa0c048, 0x0c780780, 0x00000000,
+	0x06800008, 0x07c00dc8, 0x07800d89, 0x07801f08, 0x09610248,
+	0x0609d509, 0x0aa18048, 0x0aa20088, 0x00000000, 0x0680774a,
+	0x0c780180, 0x00000000, 0x068077ca, 0x0c7800c0, 0x00000000,
+	0x0680784a, 0x07000288, 0x0400128a, 0x07000289, 0x09610209,
+	0x0609d608, 0x0649d308, 0x098083c8, 0x0609d308, 0x08007401,
+	0x0649d308, 0x0a6fc008, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0680000c, 0x0680002a, 0x064c2907, 0x0a20c407, 0x0c7e9ac0,
+	0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0200c1cc, 0x064c2907,
+	0x0a20c407, 0x0c7e9900, 0x00000000, 0x0fc081c0, 0x0aaeffc7,
+	0x0202a1ea, 0x0aa5400c, 0x0aa1418c, 0x0462d1cc, 0x0c500880,
+	0x0a61004c, 0x0c780e80, 0x06800047, 0x07c01c47, 0x064c0007,
+	0x0be14207, 0x064c2907, 0x0be0c407, 0x0d07ff2a, 0x0fc081c0,
+	0x064c0007, 0x0be10207, 0x064c2907, 0x0be08407, 0x0c7ff780,
+	0x0c7e9300, 0x00000000, 0x0c068ec0, 0x080c2301, 0x064c232b,
+	0x05810aeb, 0x048ffaeb, 0x0697000a, 0x06c0444a, 0x0540a1c7,
+	0x0200a1ca, 0x06804009, 0x0c065f80, 0x06b0400b, 0x07804007,
+	0x06905348, 0x0a80f207, 0x0c7e8ec0, 0x0c068ac0, 0x080c2301,
+	0x064c232b, 0x05810aeb, 0x048ffaeb, 0x0fc011c0, 0x0aa14047,
+	0x04001aeb, 0x0fc071c0, 0x04007aeb, 0x07c017c7, 0x0c780140,
+	0x00000000, 0x0680004a, 0x0c006d00, 0x00000000, 0x048071eb,
+	0x0580322b, 0x0aa14007, 0x06800209, 0x04001208, 0x024071c9,
+	0x0f8001c7, 0x0262a22a, 0x0c57f440, 0x0c7ff280, 0x0680002b,
+	0x07803d0d, 0x0a22830d, 0x07802f87, 0x09005207, 0x04001208,
+	0x0c00dd40, 0x0202b22b, 0x090a5207, 0x04001208, 0x0c00dc40,
+	0x0202b22b, 0x0a21440d, 0x00000000, 0x0fc041c0, 0x07c02fc7,
+	0x04004aeb, 0x0c7ff940, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -508,7 +508,7 @@ static const u32 MicroCode[] __initconst = {
 	0x09502248, 0x060c2109, 0x080c260e, 0x06800088, 0x07c02587,
 	0x0ba0c087, 0x040011c7, 0x06800007, 0x07c02547, 0x07802cc7,
 	0x07c02ac7, 0x07802887, 0x07c03047, 0x07c02488, 0x08030580,
-	0x0c073ec0, 0x00000000, 0x07802747, 0x0aa14712, 0x040011c7,
+	0x0c073dc0, 0x00000000, 0x07802747, 0x0aa14712, 0x040011c7,
 	0x07802d08, 0x0a20c048, 0x00000000, 0x07c02747, 0x0c07aec0,
 	0x07802b0d, 0x0b608008, 0x0c7fecc0, 0x0ba13fcd, 0x06800008,
 	0x0c7810c0, 0x07c02b08, 0x06808008, 0x0ba1070d, 0x0400024d,
@@ -537,15 +537,15 @@ static const u32 MicroCode[] __initconst = {
 	0x0c7ff880, 0x07c02e87, 0x064c3b07, 0x0920c1c7, 0x0b218a07,
 	0x0680004a, 0x07c01e4a, 0x07c01d8a, 0x0680204a, 0x07c0194a,
 	0x07802cc7, 0x095084c7, 0x07802d09, 0x094084c9, 0x07801909,
-	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef480,
+	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef380,
 	0x07802c49, 0x0b014489, 0x06808008, 0x0a628712, 0x0c780840,
 	0x00000000, 0x07802d0a, 0x0a20c04a, 0x0500128a, 0x040011c7,
 	0x054011c7, 0x0c780840, 0x094011ca, 0x040011c7, 0x0a410247,
-	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1300,
+	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1200,
 	0x06800007, 0x0aa5c712, 0x07802d0a, 0x0a2bc04a, 0x04001287,
-	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f0f80, 0x00000000,
+	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f0e80, 0x00000000,
 	0x0a628047, 0x040021c9, 0x07802d07, 0x0be1c047, 0x040021c9,
-	0x0c7f0f00, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
+	0x0c7f0e00, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
 	0x0ba10707, 0x0b6cce07, 0x0680c008, 0x0441c1c7, 0x05403247,
 	0x020091c9, 0x02008248, 0x07000209, 0x07c02449, 0x04001208,
 	0x07000209, 0x04001208, 0x0700021d, 0x09610749, 0x04001208,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/h264data_linux.h b/drivers/amlogic/amports/arch/ucode/h264/h264data_linux.h
index 3e71bb0..eccace9 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/h264data_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/h264data_linux.h
@@ -98,7 +98,7 @@ static const u32 MicroCode[] __initconst = {
 	0x07802a88, 0x06801809, 0x09502248, 0x060c2109, 0x080c260e,
 	0x06800088, 0x07c02587, 0x0ba0c087, 0x040011c7, 0x06800007,
 	0x07c02547, 0x07802cc7, 0x07c02ac7, 0x07802887, 0x07c03047,
-	0x07c02488, 0x08030580, 0x0c073ec0, 0x00000000, 0x07802747,
+	0x07c02488, 0x08030580, 0x0c073dc0, 0x00000000, 0x07802747,
 	0x0aa14712, 0x040011c7, 0x07802d08, 0x0a20c048, 0x00000000,
 	0x07c02747, 0x0c07aec0, 0x07802b0d, 0x0b608008, 0x0c7fecc0,
 	0x0ba13fcd, 0x06800008, 0x0c7810c0, 0x07c02b08, 0x06808008,
@@ -128,14 +128,14 @@ static const u32 MicroCode[] __initconst = {
 	0x0920c1c7, 0x0b218a07, 0x0680004a, 0x07c01e4a, 0x07c01d8a,
 	0x0680204a, 0x07c0194a, 0x07802cc7, 0x095084c7, 0x07802d09,
 	0x094084c9, 0x07801909, 0x0aa14009, 0x04401249, 0x0a60c009,
-	0x07c01909, 0x0c7ef480, 0x07802c49, 0x0b014489, 0x06808008,
+	0x07c01909, 0x0c7ef380, 0x07802c49, 0x0b014489, 0x06808008,
 	0x0a628712, 0x0c780840, 0x00000000, 0x07802d0a, 0x0a20c04a,
 	0x0500128a, 0x040011c7, 0x054011c7, 0x0c780840, 0x094011ca,
 	0x040011c7, 0x0a410247, 0x07802b09, 0x07802d07, 0x0a25c047,
-	0x040021c9, 0x0c7f1300, 0x06800007, 0x0aa5c712, 0x07802d0a,
+	0x040021c9, 0x0c7f1200, 0x06800007, 0x0aa5c712, 0x07802d0a,
 	0x0a2bc04a, 0x04001287, 0x0a4ed24a, 0x0c780480, 0x06800007,
-	0x0c7f0f80, 0x00000000, 0x0a628047, 0x040021c9, 0x07802d07,
-	0x0be1c047, 0x040021c9, 0x0c7f0f00, 0x06800047, 0x0aadc007,
+	0x0c7f0e80, 0x00000000, 0x0a628047, 0x040021c9, 0x07802d07,
+	0x0be1c047, 0x040021c9, 0x0c7f0e00, 0x06800047, 0x0aadc007,
 	0x07802b09, 0x040011c9, 0x0ba10707, 0x0b6cce07, 0x0680c008,
 	0x0441c1c7, 0x05403247, 0x020091c9, 0x02008248, 0x07000209,
 	0x07c02449, 0x04001208, 0x07000209, 0x04001208, 0x0700021d,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/h264header_linux.h b/drivers/amlogic/amports/arch/ucode/h264/h264header_linux.h
index b9d5b7c..82b076b 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/h264header_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/h264header_linux.h
@@ -169,9 +169,9 @@ static const u32 MicroCode[] __initconst = {
 	0x07c0178a, 0x07807047, 0x07c07187, 0x068003ca, 0x06031e0a,
 	0x0649ce09, 0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401,
 	0x06431e09, 0x0bee8049, 0x00000000, 0x0649ce09, 0x0a6dc009,
-	0x00000000, 0x0c062240, 0x00000000, 0x0649c007, 0x0bef7fc7,
+	0x00000000, 0x0c0622c0, 0x00000000, 0x0649c007, 0x0bef7fc7,
 	0x07803a47, 0x0a60c047, 0x0c780000, 0x00800000, 0x068000c7,
-	0x0609c007, 0x08007401, 0x0c061f80, 0x0680001b, 0x0649c007,
+	0x0609c007, 0x08007401, 0x0c062000, 0x0680001b, 0x0649c007,
 	0x0bef7fc7, 0x07802c47, 0x07803a48, 0x095101c8, 0x07803908,
 	0x097071c8, 0x07802308, 0x09021208, 0x097e11c8, 0x0609c107,
 	0x07803d07, 0x07802108, 0x095e11c8, 0x07800688, 0x094c11c8,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/h264mmc_linux.h b/drivers/amlogic/amports/arch/ucode/h264/h264mmc_linux.h
index f99eeb4..9fb6d49 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/h264mmc_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/h264mmc_linux.h
@@ -1,14 +1,16 @@
 static const u32 MicroCode[] __initconst = {
 	0x06bfff40, 0x06032400, 0x00400000, 0x0c780000, 0x00000000,
-	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d840, 0x00000000,
-	0x0c780540, 0x0a614148, 0x00000000, 0x0c0038c0, 0x00000000,
-	0x0c780400, 0x0a614188, 0x00000000, 0x0c006c80, 0x00000000,
-	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c0079c0, 0x00000000,
-	0x0c780180, 0x0a628208, 0x00000000, 0x0c000c40, 0x00000000,
+	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d600, 0x00000000,
+	0x0c780540, 0x0a614148, 0x00000000, 0x0c003cc0, 0x00000000,
+	0x0c780400, 0x0a614188, 0x00000000, 0x0c006c40, 0x00000000,
+	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007800, 0x00000000,
+	0x0c780180, 0x0a628208, 0x00000000, 0x0c000ec0, 0x00000000,
 	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0c7ff8c0,
 	0x06431e07, 0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860,
 	0x00000000, 0x00000000, 0x0f000800, 0x06031f20, 0x0f010840,
-	0x0c7ffc80, 0x06033f21, 0x078077c5, 0x04002c4e, 0x07400c45,
+	0x0c7ffc80, 0x06033f21, 0x0aa18000, 0x07800af1, 0x04001c71,
+	0x09010c71, 0x0a610031, 0x00000000, 0x07c00ac0, 0x07c00b00,
+	0x0cc00000, 0x00000000, 0x078077c5, 0x04002c4e, 0x07400c45,
 	0x07807800, 0x04003c4e, 0x07400c40, 0x0cc00000, 0x09610140,
 	0x07807846, 0x04004c4e, 0x07400c46, 0x07807880, 0x04005c4e,
 	0x07400c40, 0x0cc00000, 0x09610180, 0x0680400f, 0x0780704e,
@@ -17,59 +19,60 @@ static const u32 MicroCode[] __initconst = {
 	0x0cc00000, 0x00000000, 0x0649c900, 0x05808000, 0x05408000,
 	0x0609c900, 0x078031d0, 0x0680400f, 0x0780718e, 0x0540338e,
 	0x0200e38f, 0x04001c4e, 0x07000c4d, 0x078072c0, 0x090a1040,
-	0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b, 0x0aa7404b,
-	0x0c780b40, 0x00000000, 0x0980d00d, 0x0c07f340, 0x0944134c,
-	0x0a22008d, 0x09481350, 0x04004c4e, 0x07000c46, 0x04005c4e,
-	0x07000c40, 0x0c780d00, 0x09610180, 0x0c07f2c0, 0x0980d28d,
-	0x07000380, 0x09c00300, 0x07400380, 0x07807200, 0x02000300,
-	0x07c07200, 0x0649cf00, 0x0be11000, 0x06800040, 0x078071c0,
-	0x04001000, 0x0c780940, 0x07c071c0, 0x0980d04d, 0x0c07eec0,
-	0x0946134c, 0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45,
-	0x04003c4e, 0x07000c40, 0x0c780680, 0x09610140, 0x0c07ea40,
-	0x0980d28d, 0x07000380, 0x09800300, 0x0c7ff9c0, 0x07400380,
-	0x0980d00d, 0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e7c0,
-	0x09481350, 0x0c07e940, 0x094a1350, 0x0980d28d, 0x07807200,
-	0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000, 0x06800040,
-	0x078071c0, 0x04001000, 0x07c071c0, 0x04006c4e, 0x07807340,
-	0x07400c40, 0x04007c4e, 0x07400c51, 0x094c234b, 0x05801010,
-	0x05409000, 0x02c0d00d, 0x07801e40, 0x07000381, 0x09501040,
-	0x0400100e, 0x07000000, 0x0be100c0, 0x00000000, 0x07802080,
-	0x09523040, 0x07400381, 0x07802fc0, 0x09584340, 0x0900200d,
-	0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340, 0x09c0d20d,
-	0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d, 0x0980d20d,
-	0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0, 0x0900200d,
-	0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002080, 0x0780718d,
-	0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000, 0x0609ce00,
-	0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040, 0x07c01d80,
-	0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e, 0x078020c0,
-	0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb, 0x06800008,
-	0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70, 0x0a230330,
-	0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301, 0x00000000,
-	0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000, 0x04000281,
-	0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000,
-	0x0780720d, 0x0780390c, 0x0b82230d, 0x0c07f840, 0x00000000,
-	0x0400024a, 0x0aa7bfcb, 0x0680400f, 0x05403c4b, 0x02031c4f,
-	0x04001c71, 0x07000c70, 0x06800000, 0x09404c00, 0x07400c70,
-	0x07807200, 0x04401000, 0x07c07200, 0x04401071, 0x07000040,
-	0x09005000, 0x06800041, 0x03401001, 0x07807080, 0x03000040,
-	0x07c07080, 0x06810000, 0x0bc09030, 0x078071c0, 0x04401000,
-	0x07c071c0, 0x0649cf00, 0x0be11000, 0x0be0c080, 0x0c07f080,
-	0x0a8e3289, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
-	0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48, 0x02031c4f,
-	0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030, 0x04001c71,
-	0x09101030, 0x02031031, 0x02031031, 0x07000c41, 0x04001c71,
-	0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c, 0x00000000,
-	0x04000301, 0x04000348, 0x04001208, 0x0b8ec388, 0x0cc00000,
-	0x00000000, 0x0649c701, 0x0aa24001, 0x04401041, 0x0809c700,
-	0x05403041, 0x020013c1, 0x04001041, 0x07000070, 0x09c302f0,
-	0x07400070, 0x0649c801, 0x0aa24001, 0x04401041, 0x0809c800,
-	0x05403041, 0x020013c1, 0x04001041, 0x07000070, 0x09c302f0,
-	0x07400070, 0x0cc00000, 0x00000000, 0x0680400f, 0x05403c4d,
-	0x02031c4f, 0x04001c71, 0x07000c40, 0x06800081, 0x09542001,
-	0x07400c40, 0x04401c31, 0x07000c04, 0x0649cf30, 0x0a20c830,
+	0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b, 0x0aa7c04b,
+	0x0c780c40, 0x00000000, 0x0980d00d, 0x0c07f340, 0x0944134c,
+	0x0c07f040, 0x04000005, 0x0a22008d, 0x09481350, 0x04004c4e,
+	0x07000c46, 0x04005c4e, 0x07000c40, 0x0c780e00, 0x09610180,
+	0x0c07f240, 0x0980d28d, 0x07000380, 0x09c00300, 0x07400380,
+	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
+	0x06800040, 0x078071c0, 0x04001000, 0x0c780a40, 0x07c071c0,
+	0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e940, 0x04000006,
+	0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45, 0x04003c4e,
+	0x07000c40, 0x0c780700, 0x09610140, 0x0c07e940, 0x0980d28d,
+	0x07000380, 0x09800300, 0x0c7ff940, 0x07400380, 0x0980d00d,
+	0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e6c0, 0x09481350,
+	0x0c07e3c0, 0x04000005, 0x0c07e7c0, 0x094a1350, 0x0980d28d,
+	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
+	0x06800040, 0x078071c0, 0x04001000, 0x07c071c0, 0x04006c4e,
+	0x07807340, 0x07400c40, 0x04007c4e, 0x07400c51, 0x094c234b,
+	0x05801010, 0x05409000, 0x02c0d00d, 0x07801e40, 0x07000381,
+	0x09501040, 0x0400100e, 0x07000000, 0x0be100c0, 0x00000000,
+	0x07802080, 0x09523040, 0x07400381, 0x07802fc0, 0x09584340,
+	0x0900200d, 0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340,
+	0x09c0d20d, 0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d,
+	0x0980d20d, 0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0,
+	0x0900200d, 0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002080,
+	0x0780718d, 0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000,
+	0x0609ce00, 0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040,
+	0x07c01d80, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
+	0x078020c0, 0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb,
+	0x06800008, 0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70,
+	0x0a230330, 0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301,
+	0x00000000, 0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000,
+	0x04000281, 0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000,
+	0x00000000, 0x0780720d, 0x0780390c, 0x0b82230d, 0x0c07f840,
+	0x00000000, 0x0400024a, 0x0aa7bfcb, 0x0680400f, 0x05403c4b,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x06800000, 0x09404c00,
+	0x07400c70, 0x07807200, 0x04401000, 0x07c07200, 0x04401071,
+	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
+	0x03000040, 0x07c07080, 0x06810000, 0x0bc09030, 0x078071c0,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be11000, 0x0be0c080,
+	0x0c07f080, 0x0a8e3289, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0780704e, 0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030,
+	0x04001c71, 0x09101030, 0x02031031, 0x02031031, 0x07000c41,
+	0x04001c71, 0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c,
+	0x00000000, 0x04000301, 0x04000348, 0x04001208, 0x0b8ec388,
+	0x0cc00000, 0x00000000, 0x0649c701, 0x0aa24001, 0x04401041,
+	0x0809c700, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
+	0x09c302f0, 0x07400070, 0x0649c801, 0x0aa24001, 0x04401041,
+	0x0809c800, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
+	0x09c302f0, 0x07400070, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x05403c4d, 0x02031c4f, 0x04001c71, 0x07000c40, 0x06800081,
+	0x09542001, 0x07400c40, 0x04401c31, 0x07000c04, 0x0c7800c0,
 	0x05808044, 0x0be20041, 0x07801c01, 0x0aa10001, 0x0a216004,
 	0x06800001, 0x07c01c01, 0x05809040, 0x0a218041, 0x06800001,
-	0x09523001, 0x07400c40, 0x0c781700, 0x044012cb, 0x0c07f400,
+	0x09523001, 0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f440,
 	0x00000000, 0x0649c001, 0x0bef7fc1, 0x09101044, 0x0a60c00b,
 	0x05409041, 0x0809d100, 0x09123c04, 0x0540210b, 0x03430130,
 	0x0649d104, 0x02c04c04, 0x0609d104, 0x0940504d, 0x09184c00,
@@ -80,128 +83,125 @@ static const u32 MicroCode[] __initconst = {
 	0x06800144, 0x06800184, 0x094a3044, 0x07802130, 0x0aa0c030,
 	0x00000000, 0x09801201, 0x090c2c00, 0x0a60c0b0, 0x00000000,
 	0x09801201, 0x04401c71, 0x07000c70, 0x090a2c30, 0x09542070,
-	0x078017f0, 0x09583070, 0x06803230, 0x02030370, 0x07000c30,
-	0x09610070, 0x06800030, 0x02030370, 0x07000c04, 0x0aa1c00b,
-	0x0aa2404b, 0x0aa3408b, 0x0aa3c0cb, 0x0aa4c10b, 0x0aa5414b,
-	0x00000000, 0x0609ca04, 0x0c780580, 0x0609c101, 0x0649ca30,
-	0x09610c04, 0x0609ca30, 0x0c780440, 0x0609c201, 0x0609cb04,
-	0x0c780380, 0x0609c301, 0x0649cb30, 0x09610c04, 0x0609cb30,
-	0x0c780240, 0x0609c401, 0x0609cc04, 0x0c780180, 0x0609c501,
-	0x0649cc30, 0x09610c04, 0x0609cc30, 0x0609c601, 0x0649cf01,
-	0x0be09001, 0x0be100c0, 0x078071c0, 0x04401000, 0x07c071c0,
-	0x0cc00000, 0x00000000, 0x0680000b, 0x07803d0d, 0x0a21880d,
-	0x0780318c, 0x07801b8d, 0x0b00334c, 0x00000000, 0x07801b8c,
-	0x078071cd, 0x0649cf00, 0x0be0d000, 0x0b01d30d, 0x0c7800c0,
-	0x0680004c, 0x0b81330d, 0x00000000, 0x0c07d080, 0x00000000,
-	0x0a617fcd, 0x0c079a00, 0x00000000, 0x0c780300, 0x00000000,
-	0x07800b00, 0x0400004c, 0x09401040, 0x07c00b01, 0x05810041,
-	0x0c07da00, 0x07c00ac1, 0x040012cb, 0x0aa0818b, 0x0c7ff840,
-	0x0aa1400b, 0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00,
-	0x0cc00000, 0x00000000, 0x07800b0c, 0x0bee004c, 0x07802fcc,
-	0x0aa0c00c, 0x0780210c, 0x0a6d004c, 0x078071cc, 0x0bac808c,
-	0x0c07c880, 0x00000000, 0x0aabffcd, 0x07800b00, 0x07800af0,
-	0x09610030, 0x04002000, 0x0b0e000c, 0x0c7ffa40, 0x00000000,
-	0x0680000b, 0x078071cd, 0x0aa4400d, 0x0c07c540, 0x00000000,
-	0x0a61bfcd, 0x00000000, 0x0c078e80, 0x00000000, 0x0c780280,
-	0x00000000, 0x07807180, 0x0a807340, 0x00000000, 0x0c07cf00,
-	0x00000000, 0x040012cb, 0x0aa0818b, 0x0c7ffbc0, 0x0aa1c00b,
-	0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00, 0x0c7ffa40,
-	0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
-	0x06800008, 0x06800007, 0x07807186, 0x078072c0, 0x0a225800,
-	0x07c07087, 0x05403c46, 0x02031c4f, 0x07000c70, 0x09005c30,
-	0x06800041, 0x03401c01, 0x07c07081, 0x05403c48, 0x02031c4f,
-	0x04001c71, 0x07000c70, 0x0a23c0f0, 0x0a406188, 0x06800000,
-	0x09444c00, 0x07400c70, 0x0c780280, 0x06800047, 0x06800000,
-	0x09406c00, 0x07400c70, 0x06810000, 0x0bc04030, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x04001208, 0x0b8ec388, 0x0cc00000,
-	0x07c07207, 0x0680400f, 0x0780704e, 0x06800008, 0x06800007,
-	0x07807186, 0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70,
-	0x06810000, 0x0a007030, 0x0a805188, 0x00000000, 0x09c302b0,
-	0x0c7800c0, 0x07400c70, 0x06800047, 0x04001208, 0x0b8f3388,
-	0x0cc00000, 0x07c071c7, 0x0400138e, 0x0780734d, 0x0240e38d,
-	0x07807300, 0x0b610080, 0x00000000, 0x0200e34e, 0x0400138e,
-	0x06800008, 0x07807109, 0x0680a00a, 0x0a403209, 0x0cc00000,
-	0x00000000, 0x05402108, 0x0200410a, 0x04002c44, 0x07000c40,
-	0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380, 0x07000105,
-	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
-	0x04001c44, 0x07000c70, 0x09002030, 0x0aa14040, 0x0aa18080,
-	0x06800000, 0x0c780180, 0x094421c0, 0x0c780100, 0x09c07087,
-	0x0c780080, 0x09c070c7, 0x0be4c307, 0x06800000, 0x094021c0,
-	0x07807200, 0x04401000, 0x07c07200, 0x04401046, 0x07000040,
-	0x09005000, 0x06800041, 0x03401001, 0x07807080, 0x03000040,
-	0x07c07080, 0x06810000, 0x0bc04007, 0x078071c0, 0x04401000,
-	0x07c071c0, 0x0649cf00, 0x0be14080, 0x07400187, 0x0be0d000,
-	0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000, 0x07807108,
-	0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000,
-	0x05402108, 0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71,
-	0x07000c41, 0x09610001, 0x0a42a380, 0x07000105, 0x06804031,
-	0x05403005, 0x02006031, 0x04001186, 0x07000187, 0x04001c44,
-	0x07000c70, 0x09002030, 0x0aa14040, 0x0aa1c080, 0x06800000,
-	0x0c780200, 0x094441c0, 0x09c07087, 0x0c780140, 0x09c07107,
-	0x09c070c7, 0x0c780080, 0x09c07147, 0x0be4c307, 0x06800000,
+	0x078017f0, 0x09583070, 0x07c00b0c, 0x05810c0c, 0x07c00af0,
+	0x06803230, 0x02030370, 0x07000c30, 0x09610070, 0x06800030,
+	0x02030370, 0x07000c04, 0x0aa0c00b, 0x0aa1404b, 0x00000000,
+	0x0609ca04, 0x0c7801c0, 0x0609c101, 0x0649ca30, 0x09610c04,
+	0x0609ca30, 0x0c780080, 0x0609c201, 0x0649cf01, 0x0be09001,
+	0x0be100c0, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
+	0x00000000, 0x0680000b, 0x07803d0d, 0x0a21880d, 0x0780318c,
+	0x07801b8d, 0x0b00334c, 0x00000000, 0x07801b8c, 0x078071cd,
+	0x0649cf00, 0x0be0d000, 0x0b01730d, 0x0c7800c0, 0x0680004c,
+	0x0b80d30d, 0x00000000, 0x0c07d4c0, 0x00000000, 0x0a613fcd,
+	0x0c079cc0, 0x00000000, 0x0c780180, 0x0c07dfc0, 0x00000000,
+	0x040012cb, 0x0aa0808b, 0x0c7ff9c0, 0x0aa1400b, 0x06800080,
+	0x0950800b, 0x0609c000, 0x0609ce00, 0x0cc00000, 0x00000000,
+	0x0649cf0c, 0x0bee208c, 0x078071cc, 0x0bad808c, 0x0c07cf40,
+	0x00000000, 0x0aacffcd, 0x07800b00, 0x07800af0, 0x09610030,
+	0x04002000, 0x07802ff0, 0x0a60c030, 0x0b8e700c, 0x0c7ffac0,
+	0x0b0e500c, 0x0c7ffa40, 0x00000000, 0x0680000b, 0x078071cd,
+	0x0aa3c00d, 0x0c07cb00, 0x00000000, 0x0a613fcd, 0x0c079300,
+	0x00000000, 0x0c780240, 0x07807180, 0x0a807340, 0x00000000,
+	0x0c07d540, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc40,
+	0x0aa1c00b, 0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00,
+	0x0c7ffac0, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0780704e, 0x06800008, 0x06800007, 0x07807186, 0x078072c0,
+	0x0a225800, 0x07c07087, 0x05403c46, 0x02031c4f, 0x07000c70,
+	0x09005c30, 0x06800041, 0x03401c01, 0x07c07081, 0x05403c48,
+	0x02031c4f, 0x04001c71, 0x07000c70, 0x0a23c0f0, 0x0a406188,
+	0x06800000, 0x09444c00, 0x07400c70, 0x0c780280, 0x06800047,
+	0x06800000, 0x09406c00, 0x07400c70, 0x06810000, 0x0bc04030,
+	0x078071c0, 0x04401000, 0x07c071c0, 0x04001208, 0x0b8ec388,
+	0x0cc00000, 0x07c07207, 0x0680400f, 0x0780704e, 0x06800008,
+	0x06800007, 0x07807186, 0x05403c48, 0x02031c4f, 0x04001c71,
+	0x07000c70, 0x06810000, 0x0a007030, 0x0a805188, 0x00000000,
+	0x09c302b0, 0x0c7800c0, 0x07400c70, 0x06800047, 0x04001208,
+	0x0b8f3388, 0x0cc00000, 0x07c071c7, 0x0400138e, 0x0780734d,
+	0x0240e38d, 0x07807300, 0x0b610080, 0x00000000, 0x0200e34e,
+	0x0400138e, 0x06800008, 0x07807109, 0x0680a00a, 0x0a403209,
+	0x0cc00000, 0x00000000, 0x05402108, 0x0200410a, 0x04002c44,
+	0x07000c40, 0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380,
+	0x07000105, 0x06804031, 0x05403005, 0x02006031, 0x04001186,
+	0x07000187, 0x04001c44, 0x07000c70, 0x09002030, 0x0aa14040,
+	0x0aa18080, 0x06800000, 0x0c780180, 0x094421c0, 0x0c780100,
+	0x09c07087, 0x0c780080, 0x09c070c7, 0x0be4c307, 0x06800000,
 	0x094021c0, 0x07807200, 0x04401000, 0x07c07200, 0x04401046,
 	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
 	0x03000040, 0x07c07080, 0x06810000, 0x0bc04007, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x0cc00000, 0x07400187, 0x04001208,
-	0x0b8ce248, 0x0cc00000, 0x00000000, 0x0680000d, 0x07807300,
-	0x0b60c080, 0x00000000, 0x0680004d, 0x07807108, 0x07807149,
-	0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000, 0x05402108,
-	0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71, 0x07000c41,
-	0x09610001, 0x03800340, 0x0a41c380, 0x07000105, 0x06804031,
-	0x05403005, 0x02006031, 0x04001186, 0x07000187, 0x0a24c307,
-	0x06800000, 0x094061c0, 0x07807200, 0x04401000, 0x07c07200,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x07400187,
+	0x0be0d000, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
+	0x07807108, 0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000,
+	0x00000000, 0x05402108, 0x0200410a, 0x04002c44, 0x07000c40,
+	0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x04001c44, 0x07000c70, 0x09002030, 0x0aa14040, 0x0aa1c080,
+	0x06800000, 0x0c780200, 0x094441c0, 0x09c07087, 0x0c780140,
+	0x09c07107, 0x09c070c7, 0x0c780080, 0x09c07147, 0x0be4c307,
+	0x06800000, 0x094021c0, 0x07807200, 0x04401000, 0x07c07200,
 	0x04401046, 0x07000040, 0x09005000, 0x06800041, 0x03401001,
 	0x07807080, 0x03000040, 0x07c07080, 0x06810000, 0x0bc04007,
 	0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000, 0x07400187,
-	0x04001208, 0x0b8db248, 0x0cc00000, 0x00000000, 0x0400134d,
-	0x0780734c, 0x0240d34c, 0x07807300, 0x0b610080, 0x00000000,
-	0x0200d30d, 0x0400134d, 0x06800008, 0x07807109, 0x0680a00a,
-	0x0a403209, 0x0cc00000, 0x00000000, 0x05402108, 0x0200410a,
-	0x04002c44, 0x07000c40, 0x04001c71, 0x07000c41, 0x09610001,
-	0x0a417340, 0x07000105, 0x06804031, 0x05403005, 0x02006031,
-	0x04001186, 0x07000187, 0x04001c44, 0x07000c70, 0x09002030,
-	0x0aa14040, 0x0aa18080, 0x068000c0, 0x0c780180, 0x094821c0,
-	0x0c780100, 0x09807107, 0x0c780080, 0x09807147, 0x04006c46,
-	0x07400c4e, 0x0cc00000, 0x07400187, 0x04001208, 0x0b8e1248,
-	0x0cc00000, 0x00000000, 0x0440138e, 0x0680000d, 0x07807300,
-	0x0b60c080, 0x00000000, 0x0680004d, 0x07807108, 0x07807149,
+	0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000, 0x0680000d,
+	0x07807300, 0x0b60c080, 0x00000000, 0x0680004d, 0x07807108,
+	0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000,
+	0x05402108, 0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71,
+	0x07000c41, 0x09610001, 0x03800340, 0x0a41c380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x0a24c307, 0x06800000, 0x094061c0, 0x07807200, 0x04401000,
+	0x07c07200, 0x04401046, 0x07000040, 0x09005000, 0x06800041,
+	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
+	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
+	0x07400187, 0x04001208, 0x0b8db248, 0x0cc00000, 0x00000000,
+	0x0400134d, 0x0780734c, 0x0240d34c, 0x07807300, 0x0b610080,
+	0x00000000, 0x0200d30d, 0x0400134d, 0x06800008, 0x07807109,
 	0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000, 0x05402108,
 	0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71, 0x07000c41,
-	0x09610001, 0x03800340, 0x0b01b380, 0x07000105, 0x06804031,
-	0x05403005, 0x02006031, 0x04001186, 0x07000187, 0x0a250307,
-	0x06800000, 0x094061c0, 0x07807200, 0x04401000, 0x07c07200,
-	0x04401046, 0x07000040, 0x09005000, 0x06800041, 0x03401001,
-	0x07807080, 0x03000040, 0x07c07080, 0x06810000, 0x0bc04007,
-	0x078071c0, 0x04401000, 0x07c071c0, 0x07400187, 0x04001208,
-	0x0b8dc248, 0x0cc00000, 0x00000000, 0x06800010, 0x078020b1,
-	0x0a6240b1, 0x0649cf31, 0x0a21d031, 0x07800bb1, 0x0aa14031,
-	0x0c07aa80, 0x07c00b90, 0x0c07a300, 0x00000000, 0x0649cf31,
-	0x0be100b1, 0x078072f1, 0x09005031, 0x0a638140, 0x06800011,
-	0x0c07a800, 0x00000000, 0x0780e100, 0x0be18080, 0x09001400,
-	0x0c079fc0, 0x00000000, 0x0c781800, 0x00000000, 0x0c07af40,
-	0x00000000, 0x0c781700, 0x06800000, 0x090a2071, 0x0780e130,
-	0x0a858001, 0x0a857030, 0x0680e10f, 0x070003c0, 0x0aa2c040,
-	0x0aa3c080, 0x0aa4c0c0, 0x0aa68100, 0x00000000, 0x04605040,
-	0x0c500740, 0x00000000, 0x04606040, 0x0c5010c0, 0x0c781280,
-	0x04001c4f, 0x0c07af00, 0x07000c4e, 0x0c7ffc40, 0x040023cf,
-	0x04001c4f, 0x0c07be80, 0x07000c4e, 0x0c7ffb00, 0x040023cf,
-	0x04002c4f, 0x0c07cc00, 0x07000c4e, 0x04001c4f, 0x0c07d800,
-	0x07000c4d, 0x0c7ff900, 0x040033cf, 0x04001c4f, 0x07000c4e,
-	0x0c07e280, 0x00000000, 0x0c7ff780, 0x040023cf, 0x0c079a80,
-	0x00000000, 0x0c079300, 0x00000000, 0x06800007, 0x07807331,
-	0x0b250071, 0x07807770, 0x07807780, 0x09610c00, 0x07807841,
-	0x07807880, 0x09610040, 0x02401c01, 0x07c07841, 0x05810001,
-	0x07c07880, 0x078077c1, 0x07807800, 0x09610040, 0x02401c01,
-	0x07c077c1, 0x05810001, 0x07c07800, 0x0c7801c0, 0x07c07441,
-	0x07c07447, 0x07c077c7, 0x07c07807, 0x07c07847, 0x07c07887,
-	0x07c07347, 0x07c07487, 0x07c07647, 0x07c07687, 0x07c076c7,
-	0x07c07707, 0x07c07747, 0x07c07787, 0x0c7fed40, 0x040013cf,
-	0x04001c4f, 0x07000c4e, 0x0c07be00, 0x00000000, 0x06800050,
-	0x0400044e, 0x0c7feb40, 0x040023cf, 0x0680400f, 0x0780718e,
-	0x0540338e, 0x0200e38f, 0x04001c4e, 0x07000c40, 0x0a2140c0,
-	0x0c071940, 0x07c031d0, 0x0cc00000, 0x00000000, 0x078072f1,
-	0x09005031, 0x090a2071, 0x0aa10140, 0x0aa0c001, 0x0c073fc0,
-	0x00000000, 0x0649cf00, 0x0a219000, 0x0c071600, 0x07c031d0,
-	0x0c077340, 0x00000000, 0x0c780140, 0x0c077280, 0x00000000,
-	0x0c071440, 0x07c031d0, 0x0cc00000, 0x00000000
+	0x09610001, 0x0a417340, 0x07000105, 0x06804031, 0x05403005,
+	0x02006031, 0x04001186, 0x07000187, 0x04001c44, 0x07000c70,
+	0x09002030, 0x0aa14040, 0x0aa18080, 0x068000c0, 0x0c780180,
+	0x094821c0, 0x0c780100, 0x09807107, 0x0c780080, 0x09807147,
+	0x04006c46, 0x07400c4e, 0x0cc00000, 0x07400187, 0x04001208,
+	0x0b8e1248, 0x0cc00000, 0x00000000, 0x0440138e, 0x0680000d,
+	0x07807300, 0x0b60c080, 0x00000000, 0x0680004d, 0x07807108,
+	0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000, 0x00000000,
+	0x05402108, 0x0200410a, 0x04002c44, 0x07000c40, 0x04001c71,
+	0x07000c41, 0x09610001, 0x03800340, 0x0b01b380, 0x07000105,
+	0x06804031, 0x05403005, 0x02006031, 0x04001186, 0x07000187,
+	0x0a250307, 0x06800000, 0x094061c0, 0x07807200, 0x04401000,
+	0x07c07200, 0x04401046, 0x07000040, 0x09005000, 0x06800041,
+	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
+	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x07400187,
+	0x04001208, 0x0b8dc248, 0x0cc00000, 0x00000000, 0x06800010,
+	0x078020b1, 0x0a62c0b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
+	0x0aa1c031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x07c01e50,
+	0x0c07a300, 0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1,
+	0x09005031, 0x0a638140, 0x06800011, 0x0c07a780, 0x00000000,
+	0x0780e100, 0x0be18080, 0x09001400, 0x0c079fc0, 0x00000000,
+	0x0c781800, 0x00000000, 0x0c07aec0, 0x00000000, 0x0c781700,
+	0x06800000, 0x090a2071, 0x0780e130, 0x0a858001, 0x0a857030,
+	0x0680e10f, 0x070003c0, 0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0,
+	0x0aa68100, 0x00000000, 0x04605040, 0x0c500740, 0x00000000,
+	0x04606040, 0x0c5010c0, 0x0c781280, 0x04001c4f, 0x0c07ae80,
+	0x07000c4e, 0x0c7ffc40, 0x040023cf, 0x04001c4f, 0x0c07be00,
+	0x07000c4e, 0x0c7ffb00, 0x040023cf, 0x04002c4f, 0x0c07cb80,
+	0x07000c4e, 0x04001c4f, 0x0c07d780, 0x07000c4d, 0x0c7ff900,
+	0x040033cf, 0x04001c4f, 0x07000c4e, 0x0c07e200, 0x00000000,
+	0x0c7ff780, 0x040023cf, 0x0c079a00, 0x00000000, 0x0c079300,
+	0x00000000, 0x06800007, 0x07807331, 0x0b250071, 0x07807770,
+	0x07807780, 0x09610c00, 0x07807841, 0x07807880, 0x09610040,
+	0x02401c01, 0x07c07841, 0x05810001, 0x07c07880, 0x078077c1,
+	0x07807800, 0x09610040, 0x02401c01, 0x07c077c1, 0x05810001,
+	0x07c07800, 0x0c7801c0, 0x07c07441, 0x07c07447, 0x07c077c7,
+	0x07c07807, 0x07c07847, 0x07c07887, 0x07c07347, 0x07c07487,
+	0x07c07647, 0x07c07687, 0x07c076c7, 0x07c07707, 0x07c07747,
+	0x07c07787, 0x0c7fed40, 0x040013cf, 0x04001c4f, 0x07000c4e,
+	0x0c07bd80, 0x00000000, 0x06800050, 0x0400044e, 0x0c7feb40,
+	0x040023cf, 0x0680400f, 0x0780718e, 0x0540338e, 0x0200e38f,
+	0x04001c4e, 0x07000c40, 0x0a2140c0, 0x0c071d80, 0x07c031d0,
+	0x0cc00000, 0x00000000, 0x078072f1, 0x09005031, 0x090a2071,
+	0x0aa10140, 0x0aa0c001, 0x0c074580, 0x00000000, 0x0649cf00,
+	0x0a219000, 0x0c071a40, 0x07c031d0, 0x0c0774c0, 0x00000000,
+	0x0c780140, 0x0c077400, 0x00000000, 0x0c071880, 0x07c031d0,
+	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
diff --git a/drivers/amlogic/amports/arch/ucode/h264/h264slice_linux.h b/drivers/amlogic/amports/arch/ucode/h264/h264slice_linux.h
index 74914e3..3beb510 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/h264slice_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/h264slice_linux.h
@@ -11,8 +11,8 @@ static const u32 MicroCode[] __initconst = {
 	0x06800000, 0x07c0e100, 0x07c07540, 0x07c07580, 0x07c075c0,
 	0x07c07600, 0x078074b1, 0x04001c71, 0x078020c0, 0x06800041,
 	0x0340f001, 0x044013cf, 0x028313f1, 0x0a834ab1, 0x07c07371,
-	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a980,
-	0x00000000, 0x068000f3, 0x0c008a80, 0x07c02bf3, 0x07807187,
+	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a780,
+	0x00000000, 0x068000f3, 0x0c008880, 0x07c02bf3, 0x07807187,
 	0x07807048, 0x0a403207, 0x0c7e0200, 0x00000000, 0x06800033,
 	0x07c02bf3, 0x068002c0, 0x06031e00, 0x00000000, 0x06431e00,
 	0x0befc040, 0x00000000, 0x0649cf00, 0x0a20d000, 0x06800340,
@@ -23,12 +23,12 @@ static const u32 MicroCode[] __initconst = {
 	0x06431e00, 0x0bee8040, 0x00000000, 0x0c7ff1c0, 0x00000000,
 	0x07c0736a, 0x07c072eb, 0x07c0732c, 0x07c0e12d, 0x07c0756e,
 	0x0581002e, 0x07c07580, 0x07c075ef, 0x0581002f, 0x07c07600,
-	0x0c009b80, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
+	0x0c009980, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
 	0x09610209, 0x060c3208, 0x078077c8, 0x07807809, 0x09610209,
 	0x060c3208, 0x07807848, 0x07807889, 0x09610209, 0x060c3208,
-	0x06800073, 0x0c007940, 0x07c02bf3, 0x07807187, 0x07807048,
+	0x06800073, 0x0c007740, 0x07c02bf3, 0x07807187, 0x07807048,
 	0x0a403207, 0x0c7df0c0, 0x00000000, 0x06800033, 0x07c02bf3,
-	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c079cc0,
+	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c079bc0,
 	0x00000000, 0x07800c48, 0x0aa1c008, 0x07800bc8, 0x07800c09,
 	0x09610209, 0x06800009, 0x0c780100, 0x07c00c49, 0x0c062a40,
 	0x00000000, 0x0649cf09, 0x0be29009, 0x07800cc9, 0x0a620009,
@@ -54,20 +54,20 @@ static const u32 MicroCode[] __initconst = {
 	0x0aa24007, 0x07807407, 0x0c062000, 0x080c2301, 0x07c073c7,
 	0x09505207, 0x0c061f00, 0x080c2301, 0x07c07407, 0x09605207,
 	0x07802947, 0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007,
-	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c069cc0, 0x0680c009,
+	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c069d40, 0x0680c009,
 	0x068000c7, 0x07c0d087, 0x0fc011c0, 0x0aa10007, 0x00000000,
-	0x0c069b00, 0x0680d089, 0x07802907, 0x0a60c087, 0x06800008,
+	0x0c069b80, 0x0680d089, 0x07802907, 0x0a60c087, 0x06800008,
 	0x06815408, 0x09402207, 0x0a644047, 0x06094208, 0x0c061800,
 	0x080c2301, 0x09484207, 0x0c061740, 0x080c2301, 0x09504207,
-	0x06094208, 0x0680c007, 0x06094007, 0x0c069cc0, 0x078073c9,
-	0x0680d807, 0x06094007, 0x0c069bc0, 0x07807409, 0x0c7808c0,
+	0x06094208, 0x0680c007, 0x06094007, 0x0c069d40, 0x078073c9,
+	0x0680d807, 0x06094007, 0x0c069c40, 0x07807409, 0x0c7808c0,
 	0x00000000, 0x0fc011c0, 0x06800808, 0x0aa14007, 0x078073c7,
 	0x0c0612c0, 0x080c2301, 0x07c073c7, 0x09505207, 0x07802947,
 	0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007, 0x0fc011c0,
-	0x0aa10007, 0x00000000, 0x0c069080, 0x0680c009, 0x078028c7,
+	0x0aa10007, 0x00000000, 0x0c069100, 0x0680c009, 0x078028c7,
 	0x04000207, 0x0aa34007, 0x06094208, 0x0c060e40, 0x080c2301,
 	0x09484207, 0x0c060d80, 0x080c2301, 0x09504207, 0x06094208,
-	0x0680c007, 0x06094007, 0x0c069300, 0x078073c9, 0x06494007,
+	0x0680c007, 0x06094007, 0x0c069380, 0x078073c9, 0x06494007,
 	0x09c07247, 0x06094007, 0x07802047, 0x0aa7c007, 0x07802007,
 	0x06800148, 0x0a82a207, 0x00000000, 0x06800007, 0x07c0e107,
 	0x0fc011c0, 0x0aa5c007, 0x0680e109, 0x04000289, 0x02407289,
@@ -80,85 +80,83 @@ static const u32 MicroCode[] __initconst = {
 	0x09402207, 0x0c780100, 0x060c2108, 0x0fc021c0, 0x07c0e107,
 	0x068004ca, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
 	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049, 0x00000000,
-	0x07801e87, 0x0a608047, 0x0c782bc0, 0x0680a009, 0x0680400a,
-	0x0680ec08, 0x080c2400, 0x0c069600, 0x078070cc, 0x080c2400,
+	0x07801e87, 0x0a608047, 0x0c782a40, 0x0680a009, 0x0680400a,
+	0x0680ec08, 0x080c2400, 0x0c069680, 0x078070cc, 0x080c2400,
 	0x0680000b, 0x0780724c, 0x078073cd, 0x0400134d, 0x0b80334c,
 	0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d, 0x0540234d,
-	0x0200d349, 0x0700034e, 0x05408410, 0x02010390, 0x0649cf07,
-	0x0a225007, 0x00000000, 0x054033ce, 0x0200f3ca, 0x070003cf,
-	0x091013cf, 0x0aa0c00f, 0x0680004f, 0x07c01e4f, 0x0400134d,
-	0x0700034d, 0x0900234d, 0x094a240d, 0x040013cb, 0x0be0c0cf,
-	0x00000000, 0x060c2210, 0x0a60c00b, 0x00000000, 0x07c01990,
-	0x040012cb, 0x0b8e330b, 0x0a2240cc, 0x090022cc, 0x0680010c,
-	0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc, 0x0940840b,
-	0x060c2210, 0x07802087, 0x06800188, 0x0a802207, 0x0c781d80,
-	0x0680f608, 0x080c2408, 0x0c068840, 0x0780728c, 0x080c2408,
-	0x0680000b, 0x0780740d, 0x0400134d, 0x0b80334c, 0x00000000,
-	0x0400030d, 0x0200d2c8, 0x0700034d, 0x0540234d, 0x0200d349,
-	0x0700034e, 0x05408410, 0x02010390, 0x0400134d, 0x0700034d,
-	0x0900234d, 0x0649cf07, 0x0a225007, 0x00000000, 0x054033ce,
+	0x0200d349, 0x0700034e, 0x05408410, 0x02010390, 0x054033ce,
 	0x0200f3ca, 0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f,
-	0x07c01e4f, 0x046002cb, 0x0c481140, 0x07803a47, 0x0540338e,
-	0x0200e38a, 0x0700038f, 0x090053cf, 0x06031f07, 0x06033f0f,
-	0x0c058840, 0x08031e15, 0x0780732b, 0x0a60c0ab, 0x0680002c,
-	0x0680006c, 0x06431f07, 0x07803c0f, 0x054013cf, 0x0380fb0f,
-	0x020073c7, 0x0680180f, 0x06031f07, 0x06033f0f, 0x0c0584c0,
-	0x08031e15, 0x06431f07, 0x06433f0f, 0x097081cf, 0x0780230f,
-	0x090213cf, 0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7,
-	0x0780790f, 0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce,
-	0x070003cf, 0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce,
-	0x070003ec, 0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce,
-	0x070003ed, 0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e,
-	0x078077af, 0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac,
-	0x0b403b6e, 0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180,
-	0x09807747, 0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb,
-	0x060c3907, 0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000,
-	0x060c2210, 0x040012cb, 0x0b8a030b, 0x0a2240cc, 0x090022cc,
-	0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc,
-	0x0940840b, 0x060c2210, 0x0649cf0a, 0x0a21500a, 0x0780208a,
-	0x0a60c08a, 0x0680000a, 0x07c01e4a, 0x0694000a, 0x06c0444a,
-	0x0680c009, 0x0c05a100, 0x06a0400b, 0x0c05cd40, 0x080c2301,
-	0x0c05cec0, 0x00000000, 0x0401a1c7, 0x07802248, 0x02007207,
-	0x07c02387, 0x07802287, 0x0aa40007, 0x06800009, 0x0c05ca80,
-	0x080c2301, 0x0aa30047, 0x09402247, 0x0c05c980, 0x080c2301,
-	0x0c05cb00, 0x00000000, 0x094c4247, 0x0c05c840, 0x080c2301,
-	0x0c05c9c0, 0x00000000, 0x09444247, 0x060c3109, 0x0c7f1480,
-	0x00000000, 0x0c065bc0, 0x00000000, 0x0680400f, 0x0780704e,
-	0x0780734d, 0x0780730c, 0x078072c0, 0x090a1040, 0x090c1c00,
-	0x02c0bc01, 0x07807188, 0x0aa0c00c, 0x0aa3c04c, 0x0c780900,
-	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x09061040,
-	0x04005c71, 0x07000c70, 0x0be4c040, 0x0a248080, 0x0a4112c1,
-	0x0a410370, 0x0cc00000, 0x0680004a, 0x05403c48, 0x020313f1,
-	0x04001c71, 0x07000c40, 0x09041040, 0x04005c71, 0x07000c70,
-	0x0be18080, 0x0a214040, 0x0a4042c1, 0x0a403370, 0x0cc00000,
-	0x0680004a, 0x04803000, 0x0aa20000, 0x0aa1c0c0, 0x00000000,
-	0x04405c71, 0x07000c40, 0x09800000, 0x09800040, 0x07400c40,
-	0x06800008, 0x06830007, 0x05403c48, 0x020313f1, 0x04001c71,
-	0x07000c40, 0x0be180c0, 0x0bc051c0, 0x06800000, 0x07400c40,
-	0x0c780140, 0x07c07188, 0x04001208, 0x0b8f5388, 0x0c780d40,
-	0x07807780, 0x0580f000, 0x0a20c040, 0x06800001, 0x09801181,
-	0x07802000, 0x0a60c140, 0x04401c31, 0x09801141, 0x07801c40,
-	0x094e1040, 0x07400c01, 0x0aa7400b, 0x06801801, 0x07802300,
-	0x09021000, 0x05401000, 0x03801001, 0x07803cca, 0x0900828a,
-	0x0340a00a, 0x078078c5, 0x07807900, 0x09610140, 0x07803a40,
-	0x06031f00, 0x06033f01, 0x0c055480, 0x08031e15, 0x06800046,
-	0x07807087, 0x06431f04, 0x06800009, 0x03400246, 0x0bc0f1c0,
-	0x04401071, 0x07000070, 0x09405c09, 0x07400070, 0x02c07007,
-	0x07c07087, 0x0649c900, 0x09c007c0, 0x0609c900, 0x07c079c5,
-	0x05810145, 0x07c07a05, 0x0cc00000, 0x0680000a, 0x02005105,
-	0x04001249, 0x0b8ee289, 0x0649c900, 0x098007c0, 0x0609c900,
-	0x0cc00000, 0x07c0718e, 0x07802171, 0x04600031, 0x0c480b80,
-	0x07802180, 0x06800041, 0x0340f001, 0x0580138f, 0x078072c0,
-	0x09005000, 0x0a618140, 0x06800000, 0x07c00b00, 0x07c07640,
-	0x07c07680, 0x07c07440, 0x0780764d, 0x07807680, 0x09610340,
-	0x0780734c, 0x0780744b, 0x078073b1, 0x0b4052f1, 0x02400c4b,
-	0x0b807380, 0x0c780180, 0x0200d3cd, 0x024002f1, 0x0b003380,
-	0x0c780080, 0x0240d3cd, 0x040002f1, 0x078072c0, 0x090a2000,
-	0x0aa14000, 0x0581000d, 0x07c0764d, 0x07c07680, 0x07c0744b,
-	0x07807331, 0x0b6100b1, 0x020052cd, 0x0c781e00, 0x04000185,
-	0x078074c0, 0x07807501, 0x09610001, 0x0c781cc0, 0x02006005,
-	0x078020c0, 0x06800041, 0x0340f001, 0x078072c0, 0x09005000,
-	0x0a620140, 0x06800000, 0x07c00b00, 0x07c07480, 0x07c076c0,
+	0x07c01e4f, 0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d,
+	0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210, 0x0a60c00b,
+	0x00000000, 0x07c01990, 0x040012cb, 0x0b8e630b, 0x0a2240cc,
+	0x090022cc, 0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410,
+	0x0d07ffcc, 0x0940840b, 0x060c2210, 0x07802087, 0x06800188,
+	0x0a802207, 0x0c781cc0, 0x0680f608, 0x080c2408, 0x0c068980,
+	0x0780728c, 0x080c2408, 0x0680000b, 0x0780740d, 0x0400134d,
+	0x0b80334c, 0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d,
+	0x0540234d, 0x0200d349, 0x0700034e, 0x05408410, 0x02010390,
+	0x0400134d, 0x0700034d, 0x0900234d, 0x054033ce, 0x0200f3ca,
+	0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f, 0x07c01e4f,
+	0x046002cb, 0x0c481140, 0x07803a47, 0x0540338e, 0x0200e38a,
+	0x0700038f, 0x090053cf, 0x06031f07, 0x06033f0f, 0x0c0589c0,
+	0x08031e15, 0x0780732b, 0x0a60c0ab, 0x0680002c, 0x0680006c,
+	0x06431f07, 0x07803c0f, 0x054013cf, 0x0380fb0f, 0x020073c7,
+	0x0680180f, 0x06031f07, 0x06033f0f, 0x0c058640, 0x08031e15,
+	0x06431f07, 0x06433f0f, 0x097081cf, 0x0780230f, 0x090213cf,
+	0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7, 0x0780790f,
+	0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce, 0x070003cf,
+	0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce, 0x070003ec,
+	0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce, 0x070003ed,
+	0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e, 0x078077af,
+	0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac, 0x0b403b6e,
+	0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180, 0x09807747,
+	0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb, 0x060c3907,
+	0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210,
+	0x040012cb, 0x0b8a330b, 0x0a2240cc, 0x090022cc, 0x0680010c,
+	0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc, 0x0940840b,
+	0x060c2210, 0x0780208a, 0x0a60c08a, 0x0680000a, 0x07c01e4a,
+	0x0694000a, 0x06c0444a, 0x0680c009, 0x0c05a300, 0x06a0400b,
+	0x0c05cf40, 0x080c2301, 0x0c05d0c0, 0x00000000, 0x0401a1c7,
+	0x07802248, 0x02007207, 0x07c02387, 0x07802287, 0x0aa40007,
+	0x06800009, 0x0c05cc80, 0x080c2301, 0x0aa30047, 0x09402247,
+	0x0c05cb80, 0x080c2301, 0x0c05cd00, 0x00000000, 0x094c4247,
+	0x0c05ca40, 0x080c2301, 0x0c05cbc0, 0x00000000, 0x09444247,
+	0x060c3109, 0x0c7f1580, 0x00000000, 0x0c065e40, 0x00000000,
+	0x0680400f, 0x0780704e, 0x0780734d, 0x0780730c, 0x078072c0,
+	0x090a1040, 0x090c1c00, 0x02c0bc01, 0x07807188, 0x0aa0c00c,
+	0x0aa3c04c, 0x0c780900, 0x05403c48, 0x020313f1, 0x04001c71,
+	0x07000c40, 0x09061040, 0x04005c71, 0x07000c70, 0x0be4c040,
+	0x0a248080, 0x0a4112c1, 0x0a410370, 0x0cc00000, 0x0680004a,
+	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x09041040,
+	0x04005c71, 0x07000c70, 0x0be18080, 0x0a214040, 0x0a4042c1,
+	0x0a403370, 0x0cc00000, 0x0680004a, 0x04803000, 0x0aa20000,
+	0x0aa1c0c0, 0x00000000, 0x04405c71, 0x07000c40, 0x09800000,
+	0x09800040, 0x07400c40, 0x06800008, 0x06830007, 0x05403c48,
+	0x020313f1, 0x04001c71, 0x07000c40, 0x0be180c0, 0x0bc051c0,
+	0x06800000, 0x07400c40, 0x0c780140, 0x07c07188, 0x04001208,
+	0x0b8f5388, 0x0c780d40, 0x07807780, 0x0580f000, 0x0a20c040,
+	0x06800001, 0x09801181, 0x07802000, 0x0a60c140, 0x04401c31,
+	0x09801141, 0x07801c40, 0x094e1040, 0x07400c01, 0x0aa7400b,
+	0x06801801, 0x07802300, 0x09021000, 0x05401000, 0x03801001,
+	0x07803cca, 0x0900828a, 0x0340a00a, 0x078078c5, 0x07807900,
+	0x09610140, 0x07803a40, 0x06031f00, 0x06033f01, 0x0c055680,
+	0x08031e15, 0x06800046, 0x07807087, 0x06431f04, 0x06800009,
+	0x03400246, 0x0bc0f1c0, 0x04401071, 0x07000070, 0x09405c09,
+	0x07400070, 0x02c07007, 0x07c07087, 0x0649c900, 0x09c007c0,
+	0x0609c900, 0x07c079c5, 0x05810145, 0x07c07a05, 0x0cc00000,
+	0x0680000a, 0x02005105, 0x04001249, 0x0b8ee289, 0x0649c900,
+	0x098007c0, 0x0609c900, 0x0cc00000, 0x07c0718e, 0x07802171,
+	0x04600031, 0x0c480b40, 0x07802180, 0x06800041, 0x0340f001,
+	0x0580138f, 0x078072c0, 0x09005000, 0x0a614140, 0x06800000,
+	0x07c07640, 0x07c07680, 0x07c07440, 0x0780764d, 0x07807680,
+	0x09610340, 0x0780734c, 0x0780744b, 0x078073b1, 0x0b4052f1,
+	0x02400c4b, 0x0b807380, 0x0c780180, 0x0200d3cd, 0x024002f1,
+	0x0b003380, 0x0c780080, 0x0240d3cd, 0x040002f1, 0x078072c0,
+	0x090a2000, 0x0aa14000, 0x0581000d, 0x07c0764d, 0x07c07680,
+	0x07c0744b, 0x07807331, 0x0b6100b1, 0x020052cd, 0x0c781d80,
+	0x04000185, 0x078074c0, 0x07807501, 0x09610001, 0x0c781c40,
+	0x02006005, 0x078020c0, 0x06800041, 0x0340f001, 0x078072c0,
+	0x09005000, 0x0a61c140, 0x06800000, 0x07c07480, 0x07c076c0,
 	0x07c07700, 0x07c07540, 0x07c07580, 0x0780748e, 0x078076cd,
 	0x07807700, 0x09610340, 0x0780734c, 0x0b40338c, 0x00000000,
 	0x0200d3cd, 0x04602031, 0x0c501200, 0x0780398b, 0x0460000b,
@@ -168,22 +166,24 @@ static const u32 MicroCode[] __initconst = {
 	0x09610001, 0x04001c30, 0x0d07fef1, 0x02009009, 0x0a608008,
 	0x0c780580, 0x04401208, 0x06800007, 0x0b8052c8, 0x00000000,
 	0x040011c7, 0x0c7fff40, 0x024082c8, 0x06031f07, 0x06033f09,
-	0x0c053340, 0x08031e15, 0x04001c48, 0x06808030, 0x06431f0a,
+	0x0c0535c0, 0x08031e15, 0x04001c48, 0x06808030, 0x06431f0a,
 	0x07000c00, 0x04001c30, 0x07000c01, 0x09610001, 0x04001c30,
 	0x0d07fef1, 0x0200a00a, 0x078072c0, 0x090a2000, 0x0a614000,
 	0x07803800, 0x07803841, 0x09610001, 0x0200a00a, 0x07807545,
 	0x07807580, 0x09610140, 0x0200514a, 0x07807331, 0x0a60c031,
-	0x0c780780, 0x04000185, 0x07803886, 0x078038c0, 0x09610180,
-	0x02006185, 0x0b60c0b1, 0x0c7805c0, 0x04000146, 0x078075c0,
-	0x07807601, 0x09610001, 0x0c780480, 0x02006006, 0x078072c0,
-	0x09005000, 0x0a614140, 0x06800005, 0x07c00b05, 0x0c7802c0,
-	0x06800006, 0x0200b30d, 0x054012cb, 0x078072c0, 0x090a2000,
-	0x0a60c000, 0x00000000, 0x044012cb, 0x0400014b, 0x0400018b,
-	0x07c076cd, 0x0581000d, 0x07c07700, 0x0b803185, 0x04000105,
-	0x04000106, 0x040002c4, 0x02c0b14b, 0x02c0b18b, 0x0a20c04b,
-	0x0680004b, 0x07c00b0b, 0x07c07744, 0x05810004, 0x07c07780,
-	0x07c077c5, 0x05810005, 0x07c07800, 0x07c07846, 0x05810006,
-	0x07c07880, 0x0cc00000, 0x07c0748c, 0x00000000, 0x00000000,
+	0x0c780740, 0x04000185, 0x07803886, 0x078038c0, 0x09610180,
+	0x02006185, 0x0b60c0b1, 0x0c780580, 0x04000146, 0x078075c0,
+	0x07807601, 0x09610001, 0x0c780440, 0x02006006, 0x078072c0,
+	0x09005000, 0x0a610140, 0x06800005, 0x0c7802c0, 0x06800006,
+	0x0200b30d, 0x054012cb, 0x078072c0, 0x090a2000, 0x0a60c000,
+	0x00000000, 0x044012cb, 0x0400014b, 0x0400018b, 0x07c076cd,
+	0x0581000d, 0x07c07700, 0x0b803185, 0x04000105, 0x04000106,
+	0x07c07744, 0x05810004, 0x07c07780, 0x07c077c5, 0x05810005,
+	0x07c07800, 0x07c07846, 0x05810006, 0x07c07880, 0x0cc00000,
+	0x07c0748c, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/vh264_mc.c b/drivers/amlogic/amports/arch/ucode/h264/vh264_mc.c
index d979df9..b040f3f 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/vh264_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/h264/vh264_mc.c
@@ -25,6 +25,10 @@
 #include "gxtvbb_h264c_linux.h"
 
 #undef MicroCode
+#define MicroCode gxm_vh264_mc
+#include "gxm_h264c_linux.h"
+
+#undef MicroCode
 #define MicroCode vh264_header_mc
 #include "h264header_linux.h"
 
@@ -33,6 +37,10 @@
 #include "gxtvbb_h264header_linux.h"
 
 #undef MicroCode
+#define MicroCode gxm_vh264_header_mc
+#include "gxm_h264header_linux.h"
+
+#undef MicroCode
 #define MicroCode vh264_data_mc
 #include "h264data_linux.h"
 
@@ -41,6 +49,10 @@
 #include "gxtvbb_h264data_linux.h"
 
 #undef MicroCode
+#define MicroCode gxm_vh264_data_mc
+#include "gxm_h264data_linux.h"
+
+#undef MicroCode
 #define MicroCode vh264_mmco_mc
 #include "h264mmc_linux.h"
 
@@ -49,6 +61,10 @@
 #include "gxtvbb_h264mmc_linux.h"
 
 #undef MicroCode
+#define MicroCode gxm_vh264_mmco_mc
+#include "gxm_h264mmc_linux.h"
+
+#undef MicroCode
 #define MicroCode vh264_list_mc
 #include "h264list_linux.h"
 
@@ -57,6 +73,10 @@
 #include "gxtvbb_h264list_linux.h"
 
 #undef MicroCode
+#define MicroCode gxm_vh264_list_mc
+#include "gxm_h264list_linux.h"
+
+#undef MicroCode
 #define MicroCode vh264_slice_mc
 #include "h264slice_linux.h"
 
@@ -64,30 +84,55 @@
 #define MicroCode gxtvbb_vh264_slice_mc
 #include "gxtvbb_h264slice_linux.h"
 
+#undef MicroCode
+#define MicroCode gxm_vh264_slice_mc
+#include "gxm_h264slice_linux.h"
+
 
 #undef FOR_CPUS
 #define FOR_CPUS {MESON_CPU_MAJOR_ID_GXTVBB, MESON_CPU_MAJOR_ID_GXL,\
 		MESON_CPU_MAJOR_ID_GXM, 0}
+
 #define FOR_VFORMAT VFORMAT_H264
 
 #define DEF_FIRMEARE_FOR_GXBB(n) \
 		REGISTER_FIRMARE_PER_CPU(MESON_CPU_MAJOR_ID_GXBB,\
 		FOR_VFORMAT, n)
 
+#define DEF_FIRMEARE_FOR_GXM(n) \
+		REGISTER_FIRMARE_PER_CPU(MESON_CPU_MAJOR_ID_GXM,\
+		FOR_VFORMAT, n)
+
+#define DEF_FIRMEARE_FOR_TXL(n) \
+		REGISTER_FIRMARE_PER_CPU(MESON_CPU_MAJOR_ID_TXL,\
+		FOR_VFORMAT, n)
+
 #define REG_FIRMWARE_ALL()\
 	do {\
 		DEF_FIRMEARE_FOR_GXBB(vh264_mc);\
 		DEF_FIRMWARE(gxtvbb_vh264_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264_mc);\
+		DEF_FIRMEARE_FOR_TXL(gxm_vh264_mc);\
 		DEF_FIRMEARE_FOR_GXBB(vh264_header_mc);\
 		DEF_FIRMWARE(gxtvbb_vh264_header_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264_header_mc);\
+		DEF_FIRMEARE_FOR_TXL(gxm_vh264_header_mc);\
 		DEF_FIRMEARE_FOR_GXBB(vh264_data_mc);\
 		DEF_FIRMWARE(gxtvbb_vh264_data_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264_data_mc);\
+		DEF_FIRMEARE_FOR_TXL(gxm_vh264_data_mc);\
 		DEF_FIRMEARE_FOR_GXBB(vh264_mmco_mc);\
 		DEF_FIRMWARE(gxtvbb_vh264_mmco_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264_mmco_mc);\
+		DEF_FIRMEARE_FOR_TXL(gxm_vh264_mmco_mc);\
 		DEF_FIRMEARE_FOR_GXBB(vh264_list_mc);\
 		DEF_FIRMWARE(gxtvbb_vh264_list_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264_list_mc);\
+		DEF_FIRMEARE_FOR_TXL(gxm_vh264_list_mc);\
 		DEF_FIRMEARE_FOR_GXBB(vh264_slice_mc);\
 		DEF_FIRMWARE(gxtvbb_vh264_slice_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264_slice_mc);\
+		DEF_FIRMEARE_FOR_TXL(gxm_vh264_slice_mc);\
 	} while (0)
 
 INIT_DEF_FIRMWARE();
diff --git a/drivers/amlogic/amports/arch/ucode/h264_enc/h264_enc_mc.c b/drivers/amlogic/amports/arch/ucode/h264_enc/h264_enc_mc.c
index 5e8879f..7d449f8 100644
--- a/drivers/amlogic/amports/arch/ucode/h264_enc/h264_enc_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/h264_enc/h264_enc_mc.c
@@ -64,6 +64,10 @@
 #define MicroCode h264_enc_mc_gxtv
 #include "h264_enc_gxtv.h"
 
+#undef MicroCode
+#define MicroCode h264_enc_mc_txl
+#include "h264_enc_txl.h"
+
 
 #define CODEC_VERSION "0.0.0.1"
 #define FOR_VFORMAT VFORMAT_H264_ENC
@@ -100,6 +104,10 @@
 	REGISTER_FIRMARE_PER_CPU_VER(MESON_CPU_MAJOR_ID_GXM, \
 				FOR_VFORMAT, n, CODEC_VERSION)
 
+#define DEF_FIRMEARE_FOR_TXL(n) \
+	REGISTER_FIRMARE_PER_CPU_VER(MESON_CPU_MAJOR_ID_TXL, \
+				FOR_VFORMAT, n, CODEC_VERSION)
+
 #define REG_FIRMWARE_ALL()\
 	do {\
 		DEF_FIRMEARE_FOR_M8(mix_dump_mc);\
@@ -126,6 +134,8 @@
 		DEF_FIRMEARE_FOR_GXL(h264_enc_mc_gxtv);\
 		DEF_FIRMEARE_FOR_GXM(mix_sw_mc_hdec_gx_dblk);\
 		DEF_FIRMEARE_FOR_GXM(h264_enc_mc_gxtv);\
+		DEF_FIRMEARE_FOR_TXL(mix_sw_mc_hdec_gx_dblk);\
+		DEF_FIRMEARE_FOR_TXL(h264_enc_mc_txl);\
 	} while (0)
 
 INIT_DEF_FIRMWARE();
diff --git a/drivers/amlogic/amports/arch/ucode/h264_enc/h264_enc_txl.h b/drivers/amlogic/amports/arch/ucode/h264_enc/h264_enc_txl.h
new file mode 100644
index 0000000..997cd66
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264_enc/h264_enc_txl.h
@@ -0,0 +1,465 @@
+/*
+ * drivers/amlogic/amports/arch/m8_m8m2/h264_enc/h264_enc_txl.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+const u32 MicroCode[] __initconst = {
+	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x0c000980,
+	0x00000000, 0x0c01d280, 0x00000000, 0x0c000fc0, 0x00000000,
+	0x06bffc40, 0x07c00000, 0x06030400, 0x00400000, 0x00000000,
+	0x00000000, 0x0c7a1f40, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0c79b540, 0x00000000, 0x0c78ef40,
+	0x064d3008, 0x0c780a80, 0x00000000, 0x0c79b580, 0x00000000,
+	0x0cc00000, 0x00400000, 0x080d1a00, 0x06800008, 0x07c003c8,
+	0x0cc00000, 0x00000000, 0x06800022, 0x06804008, 0x07c00808,
+	0x07c008c8, 0x06800008, 0x07c00888, 0x064ac808, 0x07c00108,
+	0x064ac908, 0x07c00148, 0x064ac608, 0x07c00188, 0x064ac508,
+	0x07c001c8, 0x064ac708, 0x07c00208, 0x064aca08, 0x07c00388,
+	0x064acb08, 0x07c00048, 0x064ace08, 0x07c00508, 0x0cc00000,
+	0x00000000, 0x0cc00000, 0x00000000, 0x080d2001, 0x064d2008,
+	0x0befc048, 0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408,
+	0x00400000, 0x064ac008, 0x0aa44048, 0x0a60c088, 0x0c781840,
+	0x00000000, 0x078003c9, 0x0a60c009, 0x0c002940, 0x00000000,
+	0x0a60c108, 0x0c785ac0, 0x00000000, 0x0a6100c8, 0x00000000,
+	0x0c782b00, 0x00000000, 0x0c78b700, 0x00000000, 0x0c07f300,
+	0x00000000, 0x06bc0008, 0x060d1f08, 0x064d1e08, 0x09c087c8,
+	0x060d1e08, 0x06800008, 0x06c00408, 0x060d1f08, 0x06800048,
+	0x06c00408, 0x060d1f08, 0x06a19c08, 0x060d1f08, 0x064d1e08,
+	0x098087c8, 0x060d1e08, 0x06a10808, 0x060d1f08, 0x06a00008,
+	0x060d1f08, 0x06a0a008, 0x060d1f08, 0x0c07f380, 0x080d2100,
+	0x07800148, 0x04404208, 0x0c07f280, 0x060d2108, 0x0c07f200,
+	0x080d2100, 0x07800108, 0x04404208, 0x0c07f100, 0x060d2108,
+	0x0c07f080, 0x080d2101, 0x080d1f20, 0x064d3109, 0x09010209,
+	0x0400f208, 0x05804208, 0x04401208, 0x07c00308, 0x0c07ee40,
+	0x060d2108, 0x09210209, 0x0400f208, 0x05804208, 0x04401208,
+	0x07c00348, 0x0c07ec80, 0x060d2108, 0x080d1f30, 0x080d1f30,
+	0x064d3108, 0x09210208, 0x09004248, 0x0a60c009, 0x0c7803c0,
+	0x080d1f20, 0x06800408, 0x06c00008, 0x02409248, 0x05801249,
+	0x080d1f30, 0x0c07e8c0, 0x080d2100, 0x0c07e840, 0x080d2100,
+	0x0c07e7c0, 0x080d2100, 0x0c07e740, 0x060d2109, 0x080d1f20,
+	0x080d1f30, 0x06bc0008, 0x060d1f08, 0x080ac007, 0x0c78a280,
+	0x08007801, 0x0c07de80, 0x00000000, 0x06bc0008, 0x060d1f08,
+	0x064d1e08, 0x09c087c8, 0x060d1e08, 0x06800008, 0x06c00408,
+	0x060d1f08, 0x06800048, 0x06c00408, 0x060d1f08, 0x06a1a008,
+	0x060d1f08, 0x064d1e08, 0x098087c8, 0x060d1e08, 0x0c07e080,
+	0x080d2100, 0x0c07e000, 0x080d2100, 0x080d1f20, 0x080d1f20,
+	0x0c07df00, 0x080d2100, 0x0c07de80, 0x080d2100, 0x0c07de00,
+	0x080d2100, 0x080d1f20, 0x080d1f40, 0x07800048, 0x0c009ac0,
+	0x0441a208, 0x0c07dc40, 0x060d2108, 0x0c0099c0, 0x06800008,
+	0x0c07db40, 0x060d2108, 0x0c07dac0, 0x080d2100, 0x080d1f20,
+	0x080d5500, 0x080d1f20, 0x080d1f20, 0x080d1f30, 0x06bc0008,
+	0x060d1f08, 0x00000000, 0x00000000, 0x064d1608, 0x0befc108,
+	0x00000000, 0x06800008, 0x06e00008, 0x060d1c08, 0x080d1d00,
+	0x00000000, 0x00000000, 0x064d1608, 0x0befc108, 0x064d1b08,
+	0x09808648, 0x060d1b08, 0x064d1608, 0x0befc108, 0x00000000,
+	0x080ac008, 0x0c789080, 0x08007801, 0x064d3109, 0x09010289,
+	0x0400f28a, 0x0580428a, 0x0440128a, 0x07c0030a, 0x09210289,
+	0x0400f28a, 0x0580428a, 0x0440128a, 0x07c0034a, 0x06800009,
+	0x0cc00000, 0x07c003c9, 0x0c019440, 0x00000000, 0x080f3eff,
+	0x06490b08, 0x09c08608, 0x09c08648, 0x06090b08, 0x06400908,
+	0x09c08748, 0x09c08788, 0x06000908, 0x06400808, 0x09808008,
+	0x06000808, 0x09c08008, 0x06000808, 0x0c019900, 0x00000000,
+	0x0c018f40, 0x00000000, 0x0c07c400, 0x00000000, 0x06400f08,
+	0x09808708, 0x06000f08, 0x064f4908, 0x09c08048, 0x060f4908,
+	0x06bc0008, 0x060d1f08, 0x064d1e08, 0x09c087c8, 0x060d1e08,
+	0x06800008, 0x06c00408, 0x060d1f08, 0x06800048, 0x06c00408,
+	0x060d1f08, 0x06a19408, 0x060d1f08, 0x064d1e08, 0x098087c8,
+	0x060d1e08, 0x064d3308, 0x09008248, 0x07c00089, 0x09108248,
+	0x07c000c9, 0x09210208, 0x0c07c300, 0x060d2108, 0x0c07c280,
+	0x080d2107, 0x064d3109, 0x09010209, 0x0400f208, 0x05804208,
+	0x04401208, 0x07c00308, 0x09210209, 0x0400f208, 0x05804208,
+	0x04401208, 0x07c00348, 0x06800008, 0x07c00248, 0x060f1b08,
+	0x07800309, 0x0946d209, 0x060d3208, 0x06940008, 0x06c00008,
+	0x064ac109, 0x02008248, 0x060f2008, 0x06803908, 0x064d3309,
+	0x09008249, 0x09508209, 0x09808508, 0x09808548, 0x098087c8,
+	0x060f1f08, 0x064ad508, 0x07c00448, 0x0ae0c008, 0x04001208,
+	0x06800008, 0x07c00488, 0x06800008, 0x07c00408, 0x07800308,
+	0x04001208, 0x07c004c8, 0x07800309, 0x07800348, 0x0960f248,
+	0x060f1e09, 0x0c07b6c0, 0x080d2100, 0x07800148, 0x07800189,
+	0x0680040a, 0x0240a20a, 0x03409289, 0x09605248, 0x060d1f09,
+	0x078001c8, 0x0c07b440, 0x060d2108, 0x07800108, 0x07800209,
+	0x0680040a, 0x0240a20a, 0x03409289, 0x09605248, 0x060d1f09,
+	0x080d1f20, 0x080d1f20, 0x064f1c08, 0x09206208, 0x07800049,
+	0x0c006ec0, 0x02408248, 0x0c07b040, 0x060d2108, 0x080d3d00,
+	0x064acd08, 0x060f4208, 0x0c006f00, 0x00000000, 0x0680fac3,
+	0x0681bfc4, 0x080d300f, 0x064d0008, 0x09808008, 0x09808048,
+	0x09808088, 0x09c080c8, 0x09c08148, 0x09c08188, 0x09c081c8,
+	0x060d0008, 0x06bfffca, 0x06c0000a, 0x060f770a, 0x06800008,
+	0x07c00548, 0x064f6d08, 0x09203208, 0x0b618108, 0x07800548,
+	0x04001208, 0x07c00548, 0x0c7ffe80, 0x060f760a, 0x064acf08,
+	0x060f4808, 0x06808089, 0x06d00009, 0x07800508, 0x09485248,
+	0x06c0000a, 0x04820288, 0x0aa2c00a, 0x00000000, 0x09809289,
+	0x098092c9, 0x09809309, 0x09809349, 0x09809389, 0x098093c9,
+	0x09809409, 0x09809449, 0x09809489, 0x06c0000a, 0x04840288,
+	0x0aa1400a, 0x00000000, 0x098094c9, 0x09809509, 0x09809549,
+	0x060f4009, 0x080ac005, 0x0c785e40, 0x08007801, 0x0c017040,
+	0x00000000, 0x06493008, 0x06800009, 0x09410209, 0x06093008,
+	0x060d2608, 0x064f4008, 0x09c08048, 0x060f4008, 0x080f1f00,
+	0x080f3eff, 0x064d0008, 0x09c08088, 0x060d0008, 0x09808088,
+	0x060d0008, 0x064d2508, 0x09808188, 0x098081c8, 0x09808288,
+	0x060d2508, 0x064f3408, 0x098085c8, 0x09808508, 0x09808448,
+	0x09808408, 0x098083c8, 0x09808148, 0x060f3408, 0x080f3f08,
+	0x064acf08, 0x060f4808, 0x06808089, 0x06d00009, 0x07800508,
+	0x09485248, 0x06c00008, 0x04820208, 0x0aa2c008, 0x00000000,
+	0x09809289, 0x098092c9, 0x09809309, 0x09809349, 0x09809389,
+	0x098093c9, 0x09809409, 0x09809449, 0x09809489, 0x07800508,
+	0x06c00008, 0x04840208, 0x0aa14008, 0x00000000, 0x098094c9,
+	0x09809509, 0x09809549, 0x060f4009, 0x0c0156c0, 0x00000000,
+	0x06490b08, 0x09c08608, 0x09808648, 0x06090b08, 0x06400908,
+	0x09808748, 0x09c08788, 0x06000908, 0x06400808, 0x09808008,
+	0x06000808, 0x09c08008, 0x06000808, 0x0c015bc0, 0x00000000,
+	0x0c015200, 0x00000000, 0x0c0786c0, 0x00000000, 0x06400f08,
+	0x09808708, 0x06000f08, 0x064f4308, 0x09808008, 0x09c08048,
+	0x09808088, 0x09c080c8, 0x060f4308, 0x09c08008, 0x09808048,
+	0x09c08088, 0x098080c8, 0x060f4308, 0x064f3b08, 0x098087c8,
+	0x060f3b08, 0x09c087c8, 0x060f3b08, 0x064f1508, 0x09c08508,
+	0x09c084c8, 0x09808748, 0x09c08448, 0x09c08488, 0x09c08348,
+	0x09c08308, 0x09808248, 0x09808008, 0x060f1508, 0x09808508,
+	0x098084c8, 0x060f1508, 0x080d3400, 0x080f4a00, 0x09808488,
+	0x09808448, 0x09808348, 0x09808308, 0x098085c8, 0x09808608,
+	0x09808648, 0x09c08688, 0x098086c8, 0x09c08248, 0x09c08008,
+	0x060f1508, 0x064f4908, 0x09c08048, 0x09c081c8, 0x09808008,
+	0x060f4908, 0x098087c8, 0x09808788, 0x09808748, 0x098086c8,
+	0x09808688, 0x09808648, 0x09808608, 0x09808308, 0x09808288,
+	0x09c08248, 0x098081c8, 0x09808088, 0x09808048, 0x060f4908,
+	0x068000c8, 0x068000c9, 0x09484209, 0x068000c9, 0x09504209,
+	0x06800049, 0x09581209, 0x06800009, 0x095a1209, 0x06800049,
+	0x095c5209, 0x060f5908, 0x06800388, 0x06800489, 0x09508209,
+	0x06800149, 0x09604209, 0x068000c9, 0x09684209, 0x06800109,
+	0x09704209, 0x06800089, 0x09704209, 0x060f5a08, 0x06800008,
+	0x06800009, 0x09508209, 0x06800809, 0x09608209, 0x06801409,
+	0x09708209, 0x060f5b08, 0x06801008, 0x06800009, 0x09508209,
+	0x06801809, 0x09608209, 0x06803009, 0x09708209, 0x060f5c08,
+	0x06800608, 0x06801409, 0x09508209, 0x06800809, 0x09608209,
+	0x06801809, 0x09708209, 0x060f5d08, 0x068000c8, 0x06801809,
+	0x0948c209, 0x06800249, 0x09607209, 0x06800009, 0x096e1209,
+	0x06800c09, 0x09708209, 0x060f5e08, 0x068000c8, 0x06800009,
+	0x09461209, 0x06800049, 0x09481209, 0x06800009, 0x094a2209,
+	0x06803009, 0x0950c209, 0x06801c09, 0x0968c209, 0x060f5f08,
+	0x064d3109, 0x09010209, 0x0400f208, 0x05804208, 0x04401208,
+	0x07c00308, 0x09210209, 0x0400f208, 0x05804208, 0x04401208,
+	0x07c00348, 0x07800309, 0x07800348, 0x0958c248, 0x06499008,
+	0x09708248, 0x060f4f09, 0x06bc0008, 0x060d1f08, 0x064d1e08,
+	0x09c087c8, 0x060d1e08, 0x06800008, 0x06c00408, 0x060d1f08,
+	0x06800048, 0x06c00408, 0x060d1f08, 0x06a10408, 0x060d1f08,
+	0x064d1e08, 0x098087c8, 0x060d1e08, 0x064d3308, 0x09008248,
+	0x07c00089, 0x09108248, 0x07c000c9, 0x09210208, 0x0c076100,
+	0x060d2108, 0x0c076080, 0x080d2105, 0x06800048, 0x07c00248,
+	0x060f1b08, 0x07800309, 0x0946d209, 0x060d3208, 0x06803908,
+	0x064d3309, 0x09008249, 0x09508209, 0x09808508, 0x09808548,
+	0x098087c8, 0x060f1f08, 0x064ad508, 0x07c00448, 0x0ae0c008,
+	0x04001208, 0x06800008, 0x07c00488, 0x06800008, 0x07c00408,
+	0x07800308, 0x04001208, 0x07c004c8, 0x06bfffc8, 0x060d3708,
+	0x07800309, 0x07800348, 0x0960f248, 0x060f1e09, 0x0c075840,
+	0x080d2100, 0x07800148, 0x07800189, 0x0680040a, 0x0240a20a,
+	0x03409289, 0x09605248, 0x060d1f09, 0x07800108, 0x07800209,
+	0x0680040a, 0x0240a20a, 0x03409289, 0x09605248, 0x060d1f09,
+	0x080d1f20, 0x080d1f20, 0x080d1f20, 0x064f1d08, 0x09206208,
+	0x04000248, 0x095a6248, 0x060f3c09, 0x07800049, 0x0c001000,
+	0x02408248, 0x0c075180, 0x060d2108, 0x080d3d00, 0x080d5300,
+	0x064acd08, 0x060f4208, 0x0c001e00, 0x00000000, 0x06814dc3,
+	0x0681bfc4, 0x080d300f, 0x06800008, 0x06c00448, 0x060d2f08,
+	0x064d0008, 0x09c08008, 0x09c08048, 0x09c08088, 0x09c08188,
+	0x09c081c8, 0x060d0008, 0x09808008, 0x09808048, 0x09808088,
+	0x098080c8, 0x09808148, 0x09808188, 0x098081c8, 0x060d0008,
+	0x06bfffca, 0x06c0000a, 0x060f770a, 0x06a00009, 0x06d00009,
+	0x060f6f09, 0x060f6f09, 0x060f6f09, 0x060f6f09, 0x06800008,
+	0x07c00548, 0x064f6d08, 0x0be28048, 0x07800548, 0x04001208,
+	0x07c00548, 0x060f760a, 0x060f6e09, 0x060f6e09, 0x060f6e09,
+	0x0c7ffdc0, 0x060f6e09, 0x06800048, 0x07800309, 0x0948c209,
+	0x060f4b08, 0x080ac005, 0x0c780080, 0x08007801, 0x00800000,
+	0x07800008, 0x0c7f3a40, 0x06030408, 0x06800009, 0x0b005248,
+	0x02409209, 0x05401208, 0x0cc00000, 0x04401208, 0x0cc00000,
+	0x05401209, 0x06bfffda, 0x06c0001a, 0x06800009, 0x0680001b,
+	0x06c0001b, 0x0400071b, 0x0680000b, 0x0680c00e, 0x0680100f,
+	0x0740039a, 0x0400138e, 0x07400389, 0x0400138e, 0x0740039b,
+	0x0400138e, 0x0740038b, 0x0400138e, 0x0aee004f, 0x044013cf,
+	0x0690000e, 0x06c0000e, 0x064ac10f, 0x0200e3ce, 0x0680000f,
+	0x0603510e, 0x0680400d, 0x0603520d, 0x06a0c00d, 0x0603500d,
+	0x0643500d, 0x0580f34d, 0x0bef804d, 0x00000000, 0x040403cf,
+	0x0b611e8f, 0x0680800d, 0x0c7ffd00, 0x0200e34e, 0x064d330d,
+	0x0900834d, 0x0680000e, 0x0680100f, 0x0b8053cd, 0x00000000,
+	0x0404038e, 0x0c7fff40, 0x040403cf, 0x07c0028e, 0x044013cf,
+	0x07c002cf, 0x060d371a, 0x060d391b, 0x060d381a, 0x060d3a1b,
+	0x0cc00000, 0x00000000, 0x08098002, 0x08098000, 0x06a0001d,
+	0x06d0001d, 0x06a0001e, 0x06d0001e, 0x06a0001f, 0x06d0001f,
+	0x06a00020, 0x06d00020, 0x0690000a, 0x06bfffda, 0x06c0001a,
+	0x0400085a, 0x0680000d, 0x0680001b, 0x06c0001b, 0x0400071b,
+	0x06800009, 0x0680c00e, 0x0680054f, 0x0740039a, 0x0400138e,
+	0x0740038d, 0x0400138e, 0x0740039b, 0x0400138e, 0x07400389,
+	0x0400138e, 0x0740039d, 0x0400138e, 0x0740038a, 0x0400138e,
+	0x0740039e, 0x0400138e, 0x0740038a, 0x0400138e, 0x0740039f,
+	0x0400138e, 0x0740038a, 0x0400138e, 0x074003a0, 0x0400138e,
+	0x0740038a, 0x0400138e, 0x0aea004f, 0x044013cf, 0x0690000e,
+	0x06c0000e, 0x064ac10f, 0x0200e3ce, 0x0680000f, 0x0603510e,
+	0x06803f0d, 0x0603520d, 0x06a0c00d, 0x0603500d, 0x0643500d,
+	0x0580f34d, 0x0bef804d, 0x00000000, 0x040153cf, 0x0b611e8f,
+	0x06807e0d, 0x0c7ffd00, 0x0200e34e, 0x064d330d, 0x0900834d,
+	0x0680000e, 0x0680054f, 0x0b8053cd, 0x00000000, 0x0401538e,
+	0x0c7fff40, 0x040153cf, 0x07c0028e, 0x044013cf, 0x07c002cf,
+	0x060d371a, 0x060d391b, 0x060d4a1d, 0x060d4b1e, 0x060d4c1f,
+	0x060d4d20, 0x060d4a1d, 0x060d4a1d, 0x060d381a, 0x060d3a1b,
+	0x060d4e1d, 0x060d4f1e, 0x060d501f, 0x060d5120, 0x0cc00000,
+	0x00000000, 0x0aa28008, 0x064d1e0e, 0x064d1a0f, 0x0947d38f,
+	0x0240f88e, 0x07c0084f, 0x0400088e, 0x064d370e, 0x0cb80003,
+	0x064d390f, 0x0c7f0fc0, 0x00000000, 0x078004c8, 0x0b214048,
+	0x04401208, 0x07c004c8, 0x06bfffc9, 0x060d3709, 0x07800488,
+	0x0aa38008, 0x04401208, 0x0a630008, 0x07c00488, 0x0c00eb00,
+	0x00000000, 0x06bfffc9, 0x060d3709, 0x060d3809, 0x064ad508,
+	0x07c00488, 0x07800308, 0x04001208, 0x07c004c8, 0x064d3533,
+	0x064d3e08, 0x09104208, 0x09784cc8, 0x064d3b34, 0x064d3c35,
+	0x060d371a, 0x064d3510, 0x0908c250, 0x0a620009, 0x060d391b,
+	0x06bfffc9, 0x06c00009, 0x060d3809, 0x06800009, 0x06c00009,
+	0x060d3a09, 0x09004250, 0x0aa1c249, 0x080d3601, 0x080d3603,
+	0x080d3605, 0x080d3606, 0x0c7801c0, 0x00000000, 0x080d3602,
+	0x080d3603, 0x080d3604, 0x080d3605, 0x080d3606, 0x064d3708,
+	0x064d3e09, 0x080d360f, 0x0780080a, 0x0680400b, 0x0a8152ca,
+	0x0780084b, 0x0740028b, 0x06807ccb, 0x0b8112ca, 0x0400128a,
+	0x0680400b, 0x0240c2ca, 0x0603520c, 0x064ad20a, 0x0603510a,
+	0x06a0400b, 0x0603500b, 0x054012cc, 0x0200a2ca, 0x060ad20a,
+	0x0643500b, 0x0580f2cb, 0x0bef804b, 0x00000000, 0x0680400a,
+	0x09208333, 0x090882f3, 0x0950830b, 0x0740028c, 0x0400128a,
+	0x09384333, 0x090042f3, 0x0950830b, 0x0740028c, 0x0400128a,
+	0x09210334, 0x0740028c, 0x0400128a, 0x074002b4, 0x0400128a,
+	0x09210335, 0x0740028c, 0x0400128a, 0x074002b5, 0x0400128a,
+	0x09346208, 0x09508248, 0x07400289, 0x0400128a, 0x078008c8,
+	0x04001208, 0x07c008c8, 0x04803208, 0x064f6809, 0x0aa28008,
+	0x064f640b, 0x064f6509, 0x0aa1c048, 0x064f610b, 0x064f6609,
+	0x0aa10088, 0x064f620b, 0x064f6709, 0x064f630b, 0x07400289,
+	0x0400128a, 0x0740028b, 0x0400128a, 0x06800009, 0x07400289,
+	0x0400128a, 0x07400289, 0x0400128a, 0x07c0080a, 0x0908c210,
+	0x0680c10a, 0x07800289, 0x0a814248, 0x02409248, 0x04401249,
+	0x05402249, 0x0680c00a, 0x0200a289, 0x0740028e, 0x0400128a,
+	0x0581038e, 0x0740028e, 0x0400128a, 0x0740028f, 0x0400128a,
+	0x058103cf, 0x0740028f, 0x0400528a, 0x078002c9, 0x0b42a248,
+	0x07800309, 0x0b428248, 0x0700029a, 0x0400128a, 0x0700028e,
+	0x0961068e, 0x0400128a, 0x0700029b, 0x0400128a, 0x0700028f,
+	0x096106cf, 0x07800548, 0x07800309, 0x0ac1a248, 0x07800289,
+	0x0240a248, 0x0ba0900a, 0x0c7ee640, 0x0540228a, 0x02009289,
+	0x0680c00a, 0x0200a289, 0x064f6d08, 0x09203208, 0x0b63c108,
+	0x07800548, 0x04001208, 0x07c00548, 0x07800309, 0x04001249,
+	0x0b002248, 0x0c7ee2c0, 0x07000288, 0x0400128a, 0x07000289,
+	0x09610209, 0x060f7608, 0x0c7ffc40, 0x0400328a, 0x0c7ee0c0,
+	0x00000000, 0x0908c210, 0x07800289, 0x02409248, 0x05402249,
+	0x0680c00a, 0x0200a289, 0x064d0009, 0x09384249, 0x0a6f8009,
+	0x00000000, 0x064d3609, 0x0a6ec009, 0x00000000, 0x064d370e,
+	0x064d390f, 0x0740028e, 0x0400128a, 0x0581038e, 0x0740028e,
+	0x0400128a, 0x0740028f, 0x0400128a, 0x058103cf, 0x0740028f,
+	0x0400128a, 0x0690000e, 0x06c0000e, 0x064ac10f, 0x0200e3ce,
+	0x0780028f, 0x054033cf, 0x0200e3ce, 0x0603510e, 0x0680400d,
+	0x0603520d, 0x06a0c00d, 0x0603500d, 0x0908c210, 0x07800309,
+	0x0b84d248, 0x04001208, 0x0920c210, 0x07800349, 0x0b404248,
+	0x06800008, 0x0c7811c0, 0x07c00548, 0x080d3000, 0x080d1f30,
+	0x06bc0008, 0x060d1f08, 0x06800008, 0x07c00548, 0x080f6d00,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x064d1608, 0x0befc108, 0x00000000, 0x06800008,
+	0x06e00008, 0x060d1c08, 0x080d1d00, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x064d1608,
+	0x0befc108, 0x00000000, 0x064d1b08, 0x09808648, 0x060d1b08,
+	0x064d1608, 0x0befc108, 0x00000000, 0x0643500b, 0x0580f2cb,
+	0x0bef804b, 0x00000000, 0x0780080a, 0x0780084b, 0x0740028b,
+	0x0400128a, 0x0680400b, 0x0240c2ca, 0x0603520c, 0x064ad20a,
+	0x0603510a, 0x06a0400b, 0x0603500b, 0x0643500b, 0x0580f2cb,
+	0x0bef804b, 0x00000000, 0x07800188, 0x04001208, 0x07c00188,
+	0x07800208, 0x04002208, 0x07c00208, 0x080ac009, 0x06800022,
+	0x06804008, 0x07c00808, 0x07c008c8, 0x06800008, 0x07c00888,
+	0x0c7ec3c0, 0x08007801, 0x07c00288, 0x0403f248, 0x07c002c9,
+	0x05403208, 0x0690000e, 0x06c0000e, 0x064ac10f, 0x0200e3ce,
+	0x0200e20e, 0x0680400f, 0x06b0c010, 0x0643500d, 0x0580f34d,
+	0x0bef804d, 0x00000000, 0x0643530d, 0x0900c34d, 0x0a6f800d,
+	0x00000000, 0x0603510e, 0x0603520f, 0x06035010, 0x0643500d,
+	0x0580f34d, 0x0bef804d, 0x00000000, 0x0c7fd2c0, 0x0680c00a,
+	0x078004c8, 0x0b224048, 0x04401208, 0x07c004c8, 0x06a00089,
+	0x06f00009, 0x060d4c09, 0x0b20c048, 0x00000000, 0x060d4d09,
+	0x07800488, 0x0aa44008, 0x04401208, 0x0a63c008, 0x07c00488,
+	0x0c00a700, 0x00000000, 0x06bfffc9, 0x060d3809, 0x06a00089,
+	0x06f00009, 0x060d4c09, 0x060d4d09, 0x064ad508, 0x07c00488,
+	0x07800308, 0x04001208, 0x07c004c8, 0x064d4a11, 0x064d4b12,
+	0x064d4c13, 0x064d4d14, 0x060d4a1d, 0x060d4b1e, 0x060d4c1f,
+	0x060d4d20, 0x060d371a, 0x064d3510, 0x0908c250, 0x0a638009,
+	0x060d391b, 0x06a00009, 0x06d00009, 0x060d4e09, 0x060d4f09,
+	0x060d5009, 0x060d5109, 0x06bfffc9, 0x06c00009, 0x060d3809,
+	0x06800009, 0x06c00009, 0x060d3a09, 0x064d3533, 0x09004250,
+	0x0b62c249, 0x080d3607, 0x080d3601, 0x0c00ae80, 0x080d3608,
+	0x080d3609, 0x080d3604, 0x080d3605, 0x080d3606, 0x0c780500,
+	0x00000000, 0x064d3e08, 0x09104208, 0x09784cc8, 0x064d3b34,
+	0x064d3c35, 0x080d5201, 0x0aa1c249, 0x080d3601, 0x080d3603,
+	0x080d3605, 0x080d3606, 0x0c7801c0, 0x00000000, 0x080d3602,
+	0x080d3603, 0x080d3604, 0x080d3605, 0x080d3606, 0x064d0009,
+	0x09384249, 0x0aaf8209, 0x00000000, 0x09004373, 0x064d3e09,
+	0x064d3708, 0x080d360f, 0x0780080a, 0x0680400b, 0x0a8172ca,
+	0x0780084b, 0x0740028b, 0x0a60c20d, 0x06807ccb, 0x068075cb,
+	0x0b8112ca, 0x0400128a, 0x0680400b, 0x0240c2ca, 0x0603520c,
+	0x064ad20a, 0x0603510a, 0x06a0400b, 0x0603500b, 0x054012cc,
+	0x0200a2ca, 0x060ad20a, 0x0643500b, 0x0580f2cb, 0x0bef804b,
+	0x00000000, 0x0680400a, 0x09208333, 0x090882f3, 0x0950830b,
+	0x0740028c, 0x0400128a, 0x09384333, 0x064d3533, 0x090042f3,
+	0x0950830b, 0x0740028c, 0x0400128a, 0x0b66024d, 0x09210323,
+	0x0740028c, 0x0400128a, 0x074002a3, 0x0400128a, 0x0aa300cd,
+	0x0a61820d, 0x0921032b, 0x0c00a040, 0x00000000, 0x0c7805c0,
+	0x00000000, 0x0740028c, 0x0400128a, 0x074002ab, 0x0c780480,
+	0x0400128a, 0x09210327, 0x0740028c, 0x0400128a, 0x074002a7,
+	0x0c780300, 0x0400128a, 0x09210334, 0x0740028c, 0x0400128a,
+	0x074002b4, 0x0400128a, 0x09210335, 0x0740028c, 0x0400128a,
+	0x074002b5, 0x0400128a, 0x09346208, 0x09508248, 0x07400289,
+	0x0400128a, 0x078008c8, 0x04001208, 0x07c008c8, 0x04803208,
+	0x064f6809, 0x0aa28008, 0x064f640b, 0x064f6509, 0x0aa1c048,
+	0x064f610b, 0x064f6609, 0x0aa10088, 0x064f620b, 0x064f6709,
+	0x064f630b, 0x07400289, 0x0400128a, 0x0740028b, 0x0400128a,
+	0x06800009, 0x07400289, 0x0400128a, 0x07400289, 0x0400128a,
+	0x07c0080a, 0x0908c210, 0x0aa10008, 0x0680bfca, 0x0c0014c0,
+	0x04401208, 0x0908c210, 0x07800309, 0x0b843248, 0x00000000,
+	0x064d0009, 0x09384249, 0x0a6f8009, 0x00000000, 0x064d3609,
+	0x0a6ec009, 0x00000000, 0x0920c290, 0x07800349, 0x0b80c24a,
+	0x00000000, 0x064d5309, 0x0aa1c009, 0x00000000, 0x060d2109,
+	0x080d2001, 0x064d2009, 0x0befc049, 0x00000000, 0x0c7fb100,
+	0x00000000, 0x064d370e, 0x064d390f, 0x064d4a11, 0x064d4b12,
+	0x064d4c13, 0x064d4d14, 0x0c000c80, 0x07800308, 0x0c001540,
+	0x06800011, 0x07800594, 0x0a628014, 0x06bffdca, 0x06430413,
+	0x0603040a, 0x00400000, 0x07800594, 0x0aafc014, 0x00000000,
+	0x00800000, 0x06030413, 0x09814014, 0x07c00594, 0x06a00014,
+	0x06d00014, 0x060d4d14, 0x06800009, 0x07c00549, 0x080f6d00,
+	0x060f6f14, 0x060f6f14, 0x060f6f14, 0x060f6f14, 0x06bfffca,
+	0x06c0000a, 0x060f770a, 0x0c001900, 0x0680c00a, 0x060d4a1d,
+	0x060d4b1e, 0x060d4c1f, 0x060d4d20, 0x0c780280, 0x0680c30a,
+	0x0401928a, 0x0908c210, 0x04002208, 0x078002c9, 0x0b004248,
+	0x0c000b00, 0x0908c450, 0x0680c60a, 0x0c001500, 0x00000000,
+	0x0c7e7780, 0x00000000, 0x07800289, 0x0240a248, 0x0540324a,
+	0x0540228a, 0x02009289, 0x0680c00a, 0x0200a289, 0x0740028e,
+	0x0400128a, 0x0581038e, 0x0740028e, 0x0400128a, 0x0740028f,
+	0x0400128a, 0x058103cf, 0x0740028f, 0x0400128a, 0x07400291,
+	0x0400128a, 0x05810451, 0x07400291, 0x0400128a, 0x07400292,
+	0x0400128a, 0x05810492, 0x07400292, 0x0400128a, 0x07400293,
+	0x0400128a, 0x058104d3, 0x07400293, 0x0400128a, 0x07400294,
+	0x0400128a, 0x05810514, 0x0cc00000, 0x07400294, 0x0690000e,
+	0x06c0000e, 0x064ac10f, 0x0200e3ce, 0x0780028f, 0x0540434f,
+	0x054033cf, 0x0200f34f, 0x0200e3ce, 0x0603510e, 0x06803f0d,
+	0x0603520d, 0x06a0c00d, 0x0603500d, 0x07c00291, 0x04014251,
+	0x07c002c9, 0x05404251, 0x05403211, 0x02008248, 0x0690000e,
+	0x06c0000e, 0x064ac10f, 0x0200e3ce, 0x0200e20e, 0x06803f0f,
+	0x06b0c010, 0x0643500d, 0x0580f34d, 0x0bef804d, 0x00000000,
+	0x0643530d, 0x0900c34d, 0x0a6f800d, 0x00000000, 0x0603510e,
+	0x0603520f, 0x06035010, 0x0643500d, 0x0580f34d, 0x0bef804d,
+	0x0cc00000, 0x00000000, 0x040006a1, 0x070002a1, 0x0400128a,
+	0x07000289, 0x09610849, 0x0400128a, 0x040006dc, 0x0700029c,
+	0x0400128a, 0x07000289, 0x09610709, 0x0400128a, 0x0700029d,
+	0x0400128a, 0x07000289, 0x09610749, 0x0400128a, 0x0700029e,
+	0x0400128a, 0x07000289, 0x09610789, 0x0400128a, 0x0700029f,
+	0x0400128a, 0x07000289, 0x096107c9, 0x0400128a, 0x070002a0,
+	0x0400128a, 0x07000289, 0x09610809, 0x07800548, 0x07800289,
+	0x0240a248, 0x0ba0854a, 0x0cc00000, 0x0540324a, 0x0540228a,
+	0x02009289, 0x0680c00a, 0x0200a289, 0x064f6d08, 0x09203248,
+	0x0b608109, 0x0a208048, 0x0c780a80, 0x07800548, 0x078002c9,
+	0x0acfd248, 0x04001208, 0x07c00548, 0x07800309, 0x04001249,
+	0x0b003248, 0x0c7801c0, 0x0400128a, 0x07000288, 0x0400128a,
+	0x07000289, 0x09610209, 0x060f7608, 0x0400328a, 0x07000288,
+	0x0400128a, 0x07000289, 0x09610209, 0x060f6e08, 0x0400128a,
+	0x07000288, 0x0400128a, 0x07000289, 0x09610209, 0x060f6e08,
+	0x0400128a, 0x07000288, 0x0400128a, 0x07000289, 0x09610209,
+	0x060f6e08, 0x0400128a, 0x07000288, 0x0400128a, 0x07000289,
+	0x09610209, 0x060f6e08, 0x0c7ff500, 0x0400128a, 0x0cc00000,
+	0x00000000, 0x064d1602, 0x09162082, 0x0aa0c002, 0x0c7fff40,
+	0x00000000, 0x0c7e4b80, 0x00000000, 0x080f3601, 0x0cb80004,
+	0x064f3e08, 0x0be0c088, 0x0c780e40, 0x00000000, 0x080f3e02,
+	0x064f1f08, 0x09361248, 0x0aa10009, 0x09042248, 0x0c7e4840,
+	0x00000000, 0x0aa14009, 0x0680324a, 0x0aa0c049, 0x0680348a,
+	0x0680390a, 0x07800088, 0x07800309, 0x0b809248, 0x04001208,
+	0x078000c9, 0x07800348, 0x0b803209, 0x04001249, 0x06800009,
+	0x07c000c9, 0x06800008, 0x07c00088, 0x0950c288, 0x0a60c008,
+	0x07800309, 0x0980a50a, 0x0a403248, 0x00000000, 0x0980a58a,
+	0x078000c8, 0x0a60c008, 0x060f4108, 0x0980a54a, 0x07800408,
+	0x0ac03248, 0x04001208, 0x0980a5ca, 0x0ac03248, 0x07c00408,
+	0x0980a54a, 0x07800448, 0x0aa28008, 0x04401208, 0x0a620008,
+	0x07c00448, 0x0980a50a, 0x0980a54a, 0x064ad508, 0x07c00448,
+	0x06800008, 0x07c00408, 0x0980a7ca, 0x060f1f0a, 0x064f3e08,
+	0x0be0c108, 0x0c7e3b40, 0x00000000, 0x064f4b08, 0x09384248,
+	0x0aa10009, 0x064f4a08, 0x0c7e39c0, 0x00000000, 0x080f3e04,
+	0x0920c248, 0x0780034a, 0x0b408289, 0x04001249, 0x0960c209,
+	0x060f4a08, 0x06800008, 0x07800309, 0x0948c209, 0x07c00588,
+	0x0c7e3680, 0x00000000, 0x0680c008, 0x06094008, 0x06803009,
+	0x06804008, 0x0d000009, 0x06094108, 0x06800008, 0x06094008,
+	0x0cc00000, 0x00000000, 0x0cc00000, 0x00000000, 0x0c000ac0,
+	0x00000000, 0x0780034a, 0x0400128a, 0x040002ca, 0x07800309,
+	0x04001249, 0x096102c9, 0x0609520b, 0x054042ca, 0x0968c2c9,
+	0x0609080b, 0x0681010a, 0x06c3474a, 0x0609070a, 0x06490b0a,
+	0x0980a00a, 0x0980a0ca, 0x06090b0a, 0x09c0a00a, 0x09c0a0ca,
+	0x06090b0a, 0x0698000a, 0x06c0000a, 0x064ac109, 0x0200a24a,
+	0x0609440a, 0x060f370a, 0x06a0000a, 0x06c0000a, 0x0200a24a,
+	0x0609450a, 0x060f380a, 0x0cc00000, 0x00000000, 0x0c0005c0,
+	0x00000000, 0x08095003, 0x08095000, 0x06820889, 0x06c00209,
+	0x0cc00000, 0x06095109, 0x0683ffc9, 0x0649090a, 0x0a21004a,
+	0x0aa0c009, 0x0c7fff40, 0x04401249, 0x06490b0a, 0x0980a00a,
+	0x0980a0ca, 0x06090b0a, 0x09c0a00a, 0x09c0a0ca, 0x06090b0a,
+	0x0cc00000, 0x00000000, 0x0683ffca, 0x0649530b, 0x090012cb,
+	0x0649bb09, 0x0920c249, 0x020092c9, 0x0aa10009, 0x0aa0c00a,
+	0x0c7ffe40, 0x0440128a, 0x0cc00000, 0x00000000, 0x080d1f30,
+	0x06bc0008, 0x060d1f08, 0x064d1e08, 0x09c087c8, 0x060d1e08,
+	0x06800008, 0x06c00408, 0x060d1f08, 0x06800048, 0x06c00408,
+	0x060d1f08, 0x06a19408, 0x060d1f08, 0x064d1e08, 0x098087c8,
+	0x060d1e08, 0x064d3508, 0x0920c248, 0x0780030a, 0x0400128a,
+	0x0e00024a, 0x0908c208, 0x09508209, 0x064d3509, 0x0908c249,
+	0x0f000280, 0x0200a24a, 0x0961020a, 0x060d3308, 0x0c062240,
+	0x060d210a, 0x0c0621c0, 0x080d2107, 0x0c062140, 0x080d2100,
+	0x07800148, 0x07800189, 0x0680040a, 0x0240a20a, 0x03409289,
+	0x09605248, 0x060d1f09, 0x078001c8, 0x0c061ec0, 0x060d2108,
+	0x07800108, 0x07800209, 0x0680040a, 0x0240a20a, 0x03409289,
+	0x09605248, 0x060d1f09, 0x080d1f20, 0x080d1f20, 0x064f1a08,
+	0x09086208, 0x07800049, 0x0c06d940, 0x02408248, 0x0c061ac0,
+	0x060d2108, 0x0cc00000, 0x00000000, 0x064d5308, 0x0aa1c008,
+	0x00000000, 0x060d2108, 0x080d2001, 0x064d2008, 0x0befc048,
+	0x00000000, 0x080d5300, 0x080d1f30, 0x06bc0008, 0x060d1f08,
+	0x064d1e08, 0x09c087c8, 0x060d1e08, 0x06800008, 0x06c00408,
+	0x060d1f08, 0x06800048, 0x06c00408, 0x060d1f08, 0x06a10408,
+	0x060d1f08, 0x064d1e08, 0x098087c8, 0x060d1e08, 0x064d3508,
+	0x0920c248, 0x0780030a, 0x0400128a, 0x0e00024a, 0x0908c208,
+	0x09508209, 0x064d3509, 0x0908c249, 0x0f000280, 0x0200a24a,
+	0x0961020a, 0x060d3308, 0x0c061000, 0x060d210a, 0x0c060f80,
+	0x080d2105, 0x0c060f00, 0x080d2100, 0x07800148, 0x07800189,
+	0x0680040a, 0x0240a20a, 0x03409289, 0x09605248, 0x060d1f09,
+	0x07800108, 0x07800209, 0x0680040a, 0x0240a20a, 0x03409289,
+	0x09605248, 0x060d1f09, 0x080d1f20, 0x080d1f20, 0x080d1f20,
+	0x064f1a08, 0x092e2248, 0x0aaf8009, 0x09086208, 0x07800049,
+	0x0c06c700, 0x02408248, 0x0c060880, 0x060d2108, 0x0cc00000,
+	0x00000000, 0x064d340a, 0x091c128a, 0x0aaf800a, 0x080d4800,
+	0x064d4923, 0x064d4924, 0x064d4925, 0x064d4926, 0x064d4927,
+	0x064d4928, 0x064d4929, 0x064d492a, 0x064d492b, 0x064d492c,
+	0x064d492d, 0x064d492e, 0x064d492f, 0x064d4930, 0x064d4931,
+	0x064d4932, 0x0cc00000, 0x080d5201, 0x09210324, 0x0740028c,
+	0x0400128a, 0x074002a4, 0x0400128a, 0x09210325, 0x0740028c,
+	0x0400128a, 0x074002a5, 0x0400128a, 0x09210326, 0x0740028c,
+	0x0400128a, 0x074002a6, 0x0400128a, 0x09210327, 0x0740028c,
+	0x0400128a, 0x074002a7, 0x0400128a, 0x09210328, 0x0740028c,
+	0x0400128a, 0x074002a8, 0x0400128a, 0x09210329, 0x0740028c,
+	0x0400128a, 0x074002a9, 0x0400128a, 0x0921032a, 0x0740028c,
+	0x0400128a, 0x074002aa, 0x0400128a, 0x0921032b, 0x0740028c,
+	0x0400128a, 0x074002ab, 0x0400128a, 0x0921032c, 0x0740028c,
+	0x0400128a, 0x074002ac, 0x0400128a, 0x0921032d, 0x0740028c,
+	0x0400128a, 0x074002ad, 0x0400128a, 0x0921032e, 0x0740028c,
+	0x0400128a, 0x074002ae, 0x0400128a, 0x0921032f, 0x0740028c,
+	0x0400128a, 0x074002af, 0x0400128a, 0x09210330, 0x0740028c,
+	0x0400128a, 0x074002b0, 0x0400128a, 0x09210331, 0x0740028c,
+	0x0400128a, 0x074002b1, 0x0400128a, 0x09210332, 0x0740028c,
+	0x0400128a, 0x074002b2, 0x0cc00000, 0x0400128a, 0x064ac036,
+	0x0aa34076, 0x0aa300b6, 0x0aa2c136, 0x0aa280f6, 0x00000000,
+	0x07800580, 0x0a2e4040, 0x00000000, 0x060f4b00, 0x06800000,
+	0x07c00580, 0x0c7ffd00, 0x00000000, 0x08030504, 0x0c7ffc40,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264c_mvc_linux.h b/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264c_mvc_linux.h
new file mode 100644
index 0000000..ce3287e
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264c_mvc_linux.h
@@ -0,0 +1,75 @@
+static const u32 MicroCode[] __initconst = {
+	0x0c000d00, 0x00000000, 0x00000000, 0x00000000, 0x0c003ec0,
+	0x00000000, 0x0649ca01, 0x0a60c041, 0x0c781200, 0x00800000,
+	0x0a608081, 0x0c7ffe40, 0x0a60c0c1, 0x0c781a00, 0x00800000,
+	0x0a608101, 0x0c7ffd00, 0x0a60c141, 0x0c781bc0, 0x00800000,
+	0x0a608181, 0x0c7ffbc0, 0x0a6081c1, 0x0c783800, 0x0c7ffb00,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0c781e80, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0cb80003, 0x00000000, 0x0cc00000, 0x00400000,
+	0x0c7a1300, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c7a1180, 0x00000000, 0x0c781b00, 0x00000000,
+	0x0cc00000, 0x00400000, 0x06800000, 0x06800001, 0x07400040,
+	0x0b2fc881, 0x04001041, 0x07c01c00, 0x07c01c40, 0x07c01c80,
+	0x06800380, 0x07c007c0, 0x07c00780, 0x06803fc0, 0x07c013c0,
+	0x069fffc0, 0x07c021c0, 0x07c00280, 0x064c4000, 0x064c4201,
+	0x02401001, 0x04008041, 0x07c00801, 0x05810041, 0x07c00841,
+	0x064c1e00, 0x098005c0, 0x060c1e00, 0x0cc00000, 0x00000000,
+	0x0649d100, 0x0aa18080, 0x06800000, 0x0680fa81, 0x0c000300,
+	0x06800042, 0x0809d102, 0x080c0a00, 0x080c2800, 0x080c0002,
+	0x06bffe80, 0x06030400, 0x06810003, 0x0809ca02, 0x0c7fe980,
+	0x00400000, 0x06034201, 0x0649d401, 0x02000040, 0x06034100,
+	0x06a10000, 0x06c001c0, 0x06034000, 0x0a60c042, 0x0c000980,
+	0x00000000, 0x0a60c082, 0x0c000ac0, 0x00000000, 0x0a60c0c2,
+	0x0c000a80, 0x00000000, 0x06434000, 0x0580f000, 0x0bef8040,
+	0x0cc00000, 0x00000000, 0x0649d100, 0x0aa180c0, 0x06840000,
+	0x06817f81, 0x0c07f9c0, 0x06800082, 0x0809d103, 0x06bffd80,
+	0x06030400, 0x0809ca04, 0x0c78e040, 0x00400000, 0x0649d100,
+	0x0aa18100, 0x068c0000, 0x06821401, 0x0c07f6c0, 0x068000c2,
+	0x0809d104, 0x06bffe80, 0x06030400, 0x06810e03, 0x0809ca06,
+	0x0c78dd00, 0x00400000, 0x06800000, 0x07c01340, 0x07c015c0,
+	0x06803fc0, 0x07c01540, 0x07c01580, 0x0cc00000, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0cc00000, 0x00000000, 0x0c7fe600,
+	0x00000000, 0x064c4404, 0x09101104, 0x0a6f8004, 0x0c7fe4c0,
+	0x00000000, 0x064c2305, 0x0befc045, 0x0cc00000, 0x064c2005,
+	0x04001145, 0x06800006, 0x0a20c045, 0x05801145, 0x02405146,
+	0x0cc00000, 0x00000000, 0x0cc00000, 0x00400000, 0x0683ffc5,
+	0x04401145, 0x0b224005, 0x064c4406, 0x09101186, 0x0a6f0006,
+	0x080c3e00, 0x064c3f06, 0x09002186, 0x0a2e0046, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0683ffc5, 0x04401145, 0x0b224005,
+	0x064c4406, 0x09101186, 0x0a6f0006, 0x080c3e00, 0x064c3f06,
+	0x09002186, 0x0a2e0046, 0x00000000, 0x0683ffc5, 0x04401145,
+	0x0b254005, 0x064e0006, 0x09021186, 0x0aaf0006, 0x00000000,
+	0x064e0f06, 0x091c91c6, 0x0a6e0007, 0x090631c6, 0x09003186,
+	0x0a4f51c6, 0x06981807, 0x064e1106, 0x09010186, 0x0aa08006,
+	0x0a4f01c6, 0x064e1106, 0x09210186, 0x0aa0c006, 0x0a4ec1c6,
+	0x00000000, 0x0683ffc5, 0x04401145, 0x0b210005, 0x06490906,
+	0x0bef4046, 0x00000000, 0x0683ffc5, 0x04401145, 0x0b210005,
+	0x06495306, 0x0bef4046, 0x00000000, 0x0683ffc5, 0x04401145,
+	0x0b210005, 0x06491e06, 0x0a6f4006, 0x00000000, 0x0683ffc5,
+	0x04401145, 0x0b210005, 0x06498f06, 0x0a6f4006, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0c000a40, 0x00000000, 0x0649c700,
+	0x0aaf4000, 0x0c000280, 0x00000000, 0x0c7fde00, 0x00800000,
+	0x0c000180, 0x00000000, 0x0c0007c0, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0649c700, 0x0a60c000, 0x0cc00000, 0x00000000,
+	0x00800000, 0x0649c700, 0x0a60c000, 0x0cc00000, 0x00400000,
+	0x0c000100, 0x00000000, 0x0cc00000, 0x00400000, 0x0809c700,
+	0x09104040, 0x0aa0c001, 0x06804041, 0x06806041, 0x048ff000,
+	0x04401000, 0x05403000, 0x02000040, 0x07000001, 0x09c01281,
+	0x09c012c1, 0x0cc00000, 0x07400001, 0x07800780, 0x078007c1,
+	0x0a403040, 0x0cc00000, 0x00000000, 0x0649c000, 0x0aa0c000,
+	0x0cc00000, 0x00000000, 0x00800000, 0x07800780, 0x078007c1,
+	0x0a403040, 0x0cc00000, 0x00400000, 0x0c000100, 0x00000000,
+	0x0cc00000, 0x00400000, 0x07800780, 0x07000001, 0x0609c101,
+	0x090c2081, 0x0aa0c002, 0x06804002, 0x06806002, 0x0483f041,
+	0x05403041, 0x02001081, 0x04001041, 0x0649c100, 0x07000042,
+	0x090c2082, 0x09542002, 0x07000042, 0x09121082, 0x09501002,
+	0x0609c100, 0x04001001, 0x07000001, 0x04001080, 0x07000082,
+	0x09610042, 0x0609c201, 0x04002000, 0x07000001, 0x04001080,
+	0x07000082, 0x09610042, 0x0609c401, 0x07800781, 0x07000041,
+	0x090c2081, 0x0a62c002, 0x0809c300, 0x0483f041, 0x05401041,
+	0x06802ac2, 0x02002042, 0x07000081, 0x04001082, 0x07000082,
+	0x09610081, 0x0609c302, 0x0809c003, 0x08007401, 0x07800780,
+	0x04001000, 0x06800781, 0x0b803040, 0x00000000, 0x06800380,
+	0x0cc00000, 0x07c00780
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264header_mvc_linux.h b/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264header_mvc_linux.h
new file mode 100644
index 0000000..35dd203
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264header_mvc_linux.h
@@ -0,0 +1,203 @@
+static const u32 MicroCode[] __initconst = {
+	0x06bffd8a, 0x0603040a, 0x00400000, 0x064c430a, 0x0580128a,
+	0x0baf980a, 0x064c0008, 0x0be68048, 0x00000000, 0x00800000,
+	0x06bffe8a, 0x0603040a, 0x0cc00000, 0x00400000, 0x064c0008,
+	0x0a2fc048, 0x00000000, 0x064c3a08, 0x09006208, 0x0aaec648,
+	0x00000000, 0x080c0002, 0x06800008, 0x07c01348, 0x07c015c8,
+	0x06803fc8, 0x07c01548, 0x0c7ffb80, 0x07c01588, 0x06800108,
+	0x0609c008, 0x08007401, 0x0c780000, 0x0be1c808, 0x00000000,
+	0x0649d008, 0x04001208, 0x0609d008, 0x0c7ff8c0, 0x080c0002,
+	0x0fc08200, 0x090a2248, 0x07c011c9, 0x0481f208, 0x07c01208,
+	0x0aa10388, 0x0aa0c508, 0x0c780780, 0x00000000, 0x0fc01240,
+	0x0fc01240, 0x0a614508, 0x0aa0c049, 0x06800049, 0x06800149,
+	0x07c01209, 0x0fc06240, 0x0fc0a240, 0x07c01549, 0x078013c8,
+	0x0aa1bfc8, 0x0a806209, 0x06800008, 0x07801408, 0x0a805209,
+	0x06800048, 0x0c7ff300, 0x06800049, 0x07c00249, 0x07c01588,
+	0x0fc03240, 0x0fc01240, 0x07c015c9, 0x0fc01240, 0x07c01609,
+	0x0fc01240, 0x07801208, 0x0aa24148, 0x0aa20048, 0x0a608188,
+	0x0c78ad00, 0x0aa1c1c8, 0x0aa183c8, 0x0a608208, 0x0c784640,
+	0x0c7fee40, 0x0c785e80, 0x00000000, 0x06800008, 0x07c00d48,
+	0x06808012, 0x0fc10200, 0x09108208, 0x07c00888, 0x0fc08200,
+	0x07c008c8, 0x0c00b280, 0x080c2301, 0x0b2087c8, 0x0c7feac0,
+	0x07c00908, 0x07800888, 0x0b61d908, 0x06800048, 0x07c00948,
+	0x06800008, 0x07c00988, 0x0c780540, 0x00000000, 0x0c00af40,
+	0x080c2301, 0x07c00948, 0x0c00ae80, 0x080c2301, 0x0c00ae00,
+	0x080c2301, 0x0fc01200, 0x0fc01200, 0x07c00988, 0x0aa24008,
+	0x06800010, 0x068001c8, 0x07c01648, 0x0780098e, 0x07c00d4e,
+	0x0680000f, 0x0c008740, 0x0680000a, 0x0c00aa80, 0x080c2301,
+	0x04004208, 0x07c009c8, 0x0c00a980, 0x080c2301, 0x07c00a08,
+	0x0aa20088, 0x0aa0c008, 0x00000000, 0x0c780000, 0x0c00a7c0,
+	0x080c2301, 0x04004208, 0x07c00a48, 0x0c00a6c0, 0x080c2301,
+	0x07c00a88, 0x0fc01200, 0x07c00ac8, 0x0c00a580, 0x080c2301,
+	0x0b209dc8, 0x0c7fddc0, 0x04001208, 0x07c00b08, 0x0c00a400,
+	0x080c2301, 0x0b2090c8, 0x0c7fdc40, 0x04001208, 0x07c00b48,
+	0x0fc01200, 0x07c00b88, 0x0a60c008, 0x06800009, 0x0fc01240,
+	0x09421209, 0x07c00bc8, 0x0fc01240, 0x07c00c09, 0x0fc01200,
+	0x0aa24008, 0x06800109, 0x07c00d48, 0x0c009f40, 0x080c2301,
+	0x07400488, 0x0d07ff49, 0x04001492, 0x0c780100, 0x06800008,
+	0x07c00c48, 0x07c00c88, 0x0fc01240, 0x0a610009, 0x07c00cc9,
+	0x0c781600, 0x00000000, 0x07c00d49, 0x0fc01200, 0x09421248,
+	0x07400489, 0x0aa30008, 0x04001492, 0x0fc08200, 0x07400488,
+	0x0a623fc8, 0x04001492, 0x0fc10200, 0x07400488, 0x04001492,
+	0x0fc10200, 0x07400488, 0x04001492, 0x0fc01200, 0x0aa0c008,
+	0x00000000, 0x0fc01200, 0x0fc01200, 0x0aa1c008, 0x00000000,
+	0x0fc05200, 0x0a210048, 0x00000000, 0x0fc10200, 0x0fc08200,
+	0x0fc01200, 0x0aa18008, 0x00000000, 0x0c009400, 0x080c2301,
+	0x0c009380, 0x080c2301, 0x0fc01200, 0x07400488, 0x0aa3c008,
+	0x04001492, 0x0fc10200, 0x07400488, 0x04001492, 0x0fc10200,
+	0x07400488, 0x04001492, 0x0fc10200, 0x07400488, 0x04001492,
+	0x0fc10200, 0x07400488, 0x04001492, 0x0fc01200, 0x0680000f,
+	0x0fc01200, 0x0aa18008, 0x094013c8, 0x0c008100, 0x00000000,
+	0x090aa248, 0x07c00d09, 0x0fc01200, 0x0aa1c008, 0x094213c8,
+	0x0c007f40, 0x00000000, 0x0be0c04f, 0x090aa248, 0x07c00d09,
+	0x0a20c0cf, 0x00000000, 0x0fc01200, 0x0fc01200, 0x094413c8,
+	0x0fc01200, 0x094613c8, 0x0740048f, 0x04001492, 0x0aa24008,
+	0x06800189, 0x0fc01200, 0x0c0087c0, 0x080c2301, 0x0d07ff89,
+	0x00000000, 0x07400488, 0x04001492, 0x0c008900, 0x00000000,
+	0x07800908, 0x06800049, 0x03409209, 0x0649cb0a, 0x02c0a24a,
+	0x0609cb0a, 0x0649d209, 0x09527248, 0x0c009b40, 0x0609d209,
+	0x07801208, 0x0aa0c3c8, 0x0c7fbbc0, 0x00000000, 0x0fc01200,
+	0x0c008200, 0x080c2301, 0x040013c8, 0x07c0138f, 0x068013ca,
+	0x06800010, 0x0b4083d0, 0x0c008040, 0x080c2301, 0x0b6f4090,
+	0x04001410, 0x07400288, 0x0c7ffe80, 0x0400128a, 0x06bfffc8,
+	0x07c01448, 0x07c01488, 0x07c014c8, 0x07c01508, 0x06800050,
+	0x0b4143d0, 0x0c000180, 0x0680144c, 0x0c000100, 0x0680148c,
+	0x0c7ffec0, 0x04001410, 0x0c007b40, 0x080c2301, 0x04000388,
+	0x0680000d, 0x0b80238d, 0x0cc00000, 0x0c0079c0, 0x080c2301,
+	0x0b6f004d, 0x0400134d, 0x0b6e8090, 0x0c7ffe40, 0x07400308,
+	0x06800050, 0x0b4073d0, 0x0c07fc40, 0x068014cc, 0x0c07fbc0,
+	0x0680150c, 0x0c7ffec0, 0x04001410, 0x0c7faf00, 0x00000000,
+	0x064c5109, 0x064c460a, 0x07800848, 0x05410208, 0x0780080b,
+	0x020082c8, 0x0580a208, 0x0e000248, 0x00000000, 0x00000000,
+	0x00000000, 0x0f000200, 0x0f010240, 0x09708209, 0x0540a208,
+	0x02008288, 0x064c4309, 0x02408248, 0x064c4009, 0x02408248,
+	0x07c01308, 0x05810208, 0x07c012c8, 0x0cc00000, 0x00000000,
+	0x06800008, 0x07c01188, 0x06808012, 0x0c006e80, 0x080c2301,
+	0x0b20bfc8, 0x0c7fa6c0, 0x07c00d88, 0x0c006d40, 0x080c2301,
+	0x07c00dc8, 0x0649cb09, 0x03809209, 0x0be0c049, 0x0c7fa4c0,
+	0x00000000, 0x0fc01200, 0x07c00e08, 0x0fc01200, 0x07c00e48,
+	0x0c006a40, 0x080c2301, 0x0aa0c008, 0x0c7fa280, 0x00000000,
+	0x0c006900, 0x080c2301, 0x07c00e88, 0x0c006840, 0x080c2301,
+	0x07c00ec8, 0x0fc01200, 0x07c00f08, 0x0fc02200, 0x07c00f48,
+	0x0c006680, 0x080c2301, 0x0c006700, 0x00000000, 0x07c00f88,
+	0x0c006540, 0x080c2301, 0x0c0064c0, 0x080c2301, 0x0c006540,
+	0x00000000, 0x07c00fc8, 0x07c01148, 0x0fc01200, 0x07c01008,
+	0x0fc01200, 0x07c01048, 0x0fc01200, 0x07c01088, 0x064c2908,
+	0x091c2208, 0x0a6140c8, 0x06800008, 0x07c010c8, 0x07c01108,
+	0x0c780480, 0x0fc01200, 0x07c010c8, 0x0fc01200, 0x07c01108,
+	0x0aa20008, 0x068001c8, 0x07c01648, 0x0780110e, 0x07c0118e,
+	0x0680000f, 0x0c0039c0, 0x0680000a, 0x0c005d00, 0x080c2301,
+	0x0c005d80, 0x00000000, 0x07c01148, 0x0c006a40, 0x00000000,
+	0x07800d88, 0x0b618808, 0x06800049, 0x03409209, 0x0649cc0a,
+	0x02c0a24a, 0x0609cc0a, 0x0649d209, 0x09409248, 0x0c007a80,
+	0x0609d209, 0x0c7f9180, 0x00000000, 0x0c780840, 0x06800088,
+	0x0c7807c0, 0x06800148, 0x0c780740, 0x06800188, 0x0c07e100,
+	0x00000000, 0x0c005600, 0x080c2301, 0x07c01708, 0x0aa34008,
+	0x06800051, 0x078021c9, 0x069fffd1, 0x0a402449, 0x0c7f8d00,
+	0x0a807248, 0x06800011, 0x0649d308, 0x0a610008, 0x07802108,
+	0x0a608008, 0x0c7f8f00, 0x07801309, 0x07c01289, 0x078012c8,
+	0x07c01248, 0x0c005100, 0x080c2301, 0x0aa881c8, 0x0aa8c008,
+	0x0aa90048, 0x07c01748, 0x0a610088, 0x07801589, 0x0aa1c009,
+	0x0aa1bfc9, 0x07800288, 0x069fffc9, 0x0a403248, 0x0c7f86c0,
+	0x00000000, 0x0c004d40, 0x080c2301, 0x07c01788, 0x0b618808,
+	0x0649cc09, 0x03809209, 0x0be0c049, 0x0c7f8480, 0x00000000,
+	0x0649d209, 0x09009289, 0x0a80620a, 0x09409248, 0x0c007080,
+	0x0609d209, 0x0c005800, 0x00000000, 0x07800dc8, 0x0649d209,
+	0x09127289, 0x0a80620a, 0x09527248, 0x0c006440, 0x0609d209,
+	0x0c004a00, 0x00000000, 0x078009c9, 0x0f800209, 0x078002c9,
+	0x0a803248, 0x0680000a, 0x0680004a, 0x07c002c8, 0x0942144a,
+	0x07801589, 0x0aa0c009, 0x06800308, 0x06800348, 0x07000209,
+	0x0944124a, 0x07400209, 0x07800b88, 0x0a61c008, 0x068000ca,
+	0x0fc01200, 0x0aa10008, 0x00000000, 0x0fc01200, 0x04001288,
+	0x0a614011, 0x078017c9, 0x0a80324a, 0x00000000, 0x09811091,
+	0x07c017ca, 0x078017c8, 0x04401208, 0x07800bc9, 0x02809248,
+	0x09021249, 0x02008248, 0x07c01808, 0x07801208, 0x0a628148,
+	0x00000000, 0x0c003d00, 0x080c2301, 0x0a614011, 0x07801849,
+	0x0a803248, 0x00000000, 0x098110d1, 0x07c01848, 0x07800a08,
+	0x0a654008, 0x07800a48, 0x0f800208, 0x0a614011, 0x07801889,
+	0x0a803248, 0x00000000, 0x09811111, 0x07c01888, 0x07800e49,
+	0x0aa20009, 0x06800008, 0x078017c9, 0x0a6140c9, 0x0c003740,
+	0x080c2301, 0x0c0037c0, 0x00000000, 0x07c018c8, 0x05810208,
+	0x07c01908, 0x07800a08, 0x0a608048, 0x0c780000, 0x07801088,
+	0x0aa10008, 0x00000000, 0x0c003400, 0x080c2301, 0x07800e88,
+	0x07c01988, 0x07800ec8, 0x07c019c8, 0x06800008, 0x07c01948,
+	0x07801748, 0x0aa5c188, 0x0aa28148, 0x07801208, 0x0aa0c148,
+	0x0c7809c0, 0x00000000, 0x0fc01200, 0x07c01a08, 0x0fc01200,
+	0x0c780880, 0x07c01a48, 0x0fc01200, 0x06800809, 0x0aa14008,
+	0x07801988, 0x0c002e00, 0x080c2301, 0x07c01988, 0x09505248,
+	0x07800bc8, 0x096a2248, 0x0c780580, 0x060c2109, 0x0fc01200,
+	0x07c01948, 0x06800809, 0x096e1248, 0x07801988, 0x09505248,
+	0x0fc01200, 0x0aa24008, 0x078019c8, 0x0c0029c0, 0x080c2301,
+	0x07c01988, 0x09505248, 0x0c0028c0, 0x080c2301, 0x07c019c8,
+	0x09605248, 0x07800bc8, 0x096a2248, 0x060c2109, 0x0c068800,
+	0x07c016d1, 0x0809ca03, 0x0c7f5e00, 0x06802b03, 0x0ba0c18a,
+	0x0680020d, 0x0680080d, 0x07801648, 0x0b80420a, 0x0400128a,
+	0x0cc00000, 0x00000000, 0x0540138e, 0x054013cf, 0x0fc01240,
+	0x07400489, 0x04001492, 0x09401389, 0x0aac8009, 0x0680020b,
+	0x0680020c, 0x0ba0c18a, 0x068003cd, 0x06800fcd, 0x0aa4400c,
+	0x00000000, 0x0c002040, 0x080c2301, 0x07400488, 0x04001492,
+	0x0c002040, 0x00000000, 0x020082c8, 0x048ff308, 0x0a61800c,
+	0x0aa0cfcd, 0x0b61418a, 0x0a6103cd, 0x0c7ff780, 0x0980f00f,
+	0x040002cc, 0x05408410, 0x0be0c04d, 0x0940840b, 0x06c00010,
+	0x0aeac00d, 0x0440134d, 0x07801648, 0x0b80320a, 0x0cc00000,
+	0x00000000, 0x0c7ff640, 0x0400128a, 0x0ba0c18a, 0x0680020d,
+	0x0680080d, 0x064e020b, 0x0200b34b, 0x06c0004b, 0x060e020b,
+	0x0ba101ca, 0x0400128a, 0x0cc00000, 0x00000000, 0x0540138e,
+	0x054013cf, 0x07801649, 0x0ac0424a, 0x06800009, 0x07000489,
+	0x04001492, 0x09401389, 0x0aab4009, 0x0680020b, 0x0680020c,
+	0x0ba0c18a, 0x068003cd, 0x06800fcd, 0x0aa3800c, 0x07000488,
+	0x04001492, 0x0c001380, 0x00000000, 0x020082c8, 0x048ff308,
+	0x0a61800c, 0x0aa0cfcd, 0x0b61418a, 0x0a6103cd, 0x0c7ff700,
+	0x0980f00f, 0x040002cc, 0x05408410, 0x0be1004d, 0x0940840b,
+	0x06c00010, 0x060e0210, 0x0aeb400d, 0x0440134d, 0x0ba0c1ca,
+	0x0cc00000, 0x00000000, 0x0c7ff680, 0x0400128a, 0x0c000cc0,
+	0x080c2301, 0x04001388, 0x0fc08200, 0x0c000bc0, 0x080c2301,
+	0x0c000b40, 0x080c2301, 0x0d07ff0e, 0x0fc01200, 0x0fc05200,
+	0x0cc00000, 0x0fc0f200, 0x0680000d, 0x0680001a, 0x064c2908,
+	0x0a20c408, 0x0c7f4180, 0x00000000, 0x0fc08200, 0x0aaeffc8,
+	0x0200d20d, 0x064c2908, 0x0a20c408, 0x0c7f3fc0, 0x00000000,
+	0x0fc08200, 0x0aaeffc8, 0x0201a21a, 0x0aa5000d, 0x0aa1018d,
+	0x0a61404d, 0x0c780480, 0x00000000, 0x06800048, 0x07c01688,
+	0x064c0008, 0x0be14208, 0x064c2908, 0x0be0c408, 0x0d07ff1a,
+	0x0fc08200, 0x064c0008, 0x0be10208, 0x064c2908, 0x0be08408,
+	0x0c7ff7c0, 0x0c7f3a00, 0x00000000, 0x0c7ffcc0, 0x0c7ffc80,
+	0x064c2308, 0x0befc048, 0x0cc00000, 0x064c2008, 0x04001208,
+	0x06800009, 0x0a20c048, 0x05801208, 0x02408209, 0x0cc00000,
+	0x00000000, 0x06808012, 0x064c2908, 0x09c082c8, 0x09c08308,
+	0x07800949, 0x0aa0c009, 0x098080c8, 0x09c080c8, 0x060c2908,
+	0x0780098e, 0x0aa3000e, 0x0680000f, 0x0680000a, 0x06c0004a,
+	0x060e020a, 0x068001c8, 0x07c01648, 0x0c07e240, 0x0680000a,
+	0x0680000a, 0x06c0004a, 0x060e020a, 0x064e0008, 0x096e920e,
+	0x060e0008, 0x064e0308, 0x0950820f, 0x060e0308, 0x07800b08,
+	0x060c0908, 0x07800b4a, 0x07800b88, 0x0a60c008, 0x00000000,
+	0x0540128a, 0x040002ca, 0x07800b09, 0x095082c9, 0x07c0000b,
+	0x040002ca, 0x096102c9, 0x0609520b, 0x054042ca, 0x0968c2c9,
+	0x0609080b, 0x0cc00000, 0x00000000, 0x06808012, 0x06800809,
+	0x07800e88, 0x09505248, 0x07800ec8, 0x09605248, 0x07800bc8,
+	0x096a2248, 0x060c2109, 0x07800fc8, 0x06801009, 0x09505248,
+	0x060c2109, 0x07801148, 0x06801409, 0x09505248, 0x060c2109,
+	0x0780110e, 0x0aa2800e, 0x0680000f, 0x06801c0a, 0x06c0004a,
+	0x060e020a, 0x0c07d500, 0x0680000a, 0x0680000a, 0x06c0004a,
+	0x060e020a, 0x064e0008, 0x095c920e, 0x060e0008, 0x064e0308,
+	0x0940820f, 0x060e0308, 0x0cc00000, 0x00000000, 0x06800009,
+	0x06c00049, 0x0540a288, 0x02009289, 0x0680050a, 0x0c001340,
+	0x06a0088b, 0x07800d49, 0x0aa28009, 0x06800009, 0x06c00049,
+	0x0540a288, 0x02009289, 0x0680400a, 0x02009289, 0x0680600a,
+	0x0c001080, 0x06a0800b, 0x0cc00000, 0x00000000, 0x06800009,
+	0x06c00049, 0x0540a288, 0x02009289, 0x0680050a, 0x0c000e40,
+	0x06b0088b, 0x07800d49, 0x0aa28009, 0x06800009, 0x06c00049,
+	0x0540a288, 0x02009289, 0x0680400a, 0x02009289, 0x0680600a,
+	0x0c000b80, 0x06b0800b, 0x0cc00000, 0x00000000, 0x06900009,
+	0x06c00049, 0x05409288, 0x02009289, 0x0680044a, 0x0c000940,
+	0x06a00d8b, 0x07801189, 0x0aa28009, 0x06900009, 0x06c00049,
+	0x05409288, 0x02009289, 0x0680100a, 0x02009289, 0x0680380a,
+	0x0c000680, 0x06a0800b, 0x0cc00000, 0x00000000, 0x06900009,
+	0x06c00049, 0x05409288, 0x02009289, 0x06800d8a, 0x068011ca,
+	0x0680044a, 0x0c0003c0, 0x06b00d8b, 0x07801189, 0x0aa28009,
+	0x06900009, 0x06c00049, 0x05409288, 0x02009289, 0x0680100a,
+	0x02009289, 0x0680380a, 0x0c000100, 0x06b0800b, 0x0cc00000,
+	0x00000000, 0x0603520a, 0x0649ce0a, 0x0200a24a, 0x0603510a,
+	0x0603500b, 0x06435009, 0x0580f249, 0x0bef8049, 0x00000000,
+	0x06435309, 0x0900c249, 0x0a6f8009, 0x00000000, 0x0cc00000,
+	0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264mmc_mvc_linux.h b/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264mmc_mvc_linux.h
new file mode 100644
index 0000000..6059bc2
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264mmc_mvc_linux.h
@@ -0,0 +1,309 @@
+static const u32 MicroCode[] __initconst = {
+	0x078016d8, 0x07801588, 0x0a613fc8, 0x00000000, 0x06800008,
+	0x07c01588, 0x0a60c018, 0x04000658, 0x0c781600, 0x0aa0c008,
+	0x06800049, 0x06800089, 0x0700024a, 0x0780000b, 0x0a8182ca,
+	0x0740024b, 0x078008c9, 0x097082c9, 0x07800a89, 0x096082c9,
+	0x0609c10b, 0x040012c8, 0x0609c00b, 0x08007401, 0x0649c00b,
+	0x0a6fc00b, 0x00000000, 0x0649c10b, 0x0910828b, 0x07c001ca,
+	0x0900828b, 0x07c0020a, 0x0649c20b, 0x07c0014b, 0x092102cb,
+	0x07c0018b, 0x0c004840, 0x00000000, 0x07801208, 0x0a630148,
+	0x07801588, 0x0a628008, 0x06800008, 0x07c01c08, 0x07c01c48,
+	0x07c01c88, 0x0c009640, 0x00000000, 0x06800008, 0x07c000c8,
+	0x07c00108, 0x0c004740, 0x00000000, 0x078020c8, 0x0aa10008,
+	0x0c005840, 0x00000000, 0x0c7800c0, 0x0c004c80, 0x00000000,
+	0x0a24200b, 0x0910820b, 0x0be32008, 0x0780158b, 0x0aa0c00b,
+	0x068000cb, 0x0680010b, 0x0680004a, 0x0340a20a, 0x06bfffc8,
+	0x0300a20a, 0x070002c8, 0x02808288, 0x074002c8, 0x0c7eee80,
+	0x0809ca07, 0x07c01b49, 0x07c01bca, 0x07801588, 0x0a62c008,
+	0x0900820b, 0x07c02048, 0x07800248, 0x0a60c008, 0x06800048,
+	0x07c01608, 0x06800008, 0x07c00248, 0x07801608, 0x07c02088,
+	0x078020c8, 0x0a614008, 0x0c013f40, 0x00000000, 0x0c012a00,
+	0x00000000, 0x07801748, 0x0aa08088, 0x0c780980, 0x07801209,
+	0x0aa20149, 0x078011c9, 0x0aa18009, 0x00000000, 0x0fc01240,
+	0x0aa0c009, 0x0c00d700, 0x00000000, 0x0c070d40, 0x080c2301,
+	0x0c070dc0, 0x00000000, 0x0401a205, 0x07800f89, 0x02008248,
+	0x07c01a88, 0x07801008, 0x0aa40008, 0x0680000a, 0x0c070a80,
+	0x080c2301, 0x0aa30045, 0x09402285, 0x0c070980, 0x080c2301,
+	0x0c070a00, 0x00000000, 0x094c4285, 0x0c070840, 0x080c2301,
+	0x0c0708c0, 0x00000000, 0x09444285, 0x060c310a, 0x0c7edf80,
+	0x0809ca05, 0x0aa08148, 0x0c781300, 0x0aa4c019, 0x0c008d00,
+	0x078002c8, 0x07801588, 0x0aa3c008, 0x07802088, 0x0aa34008,
+	0x078015c8, 0x0aa0c008, 0x079014c8, 0x07901448, 0x06bfffc9,
+	0x0a807248, 0x07801b49, 0x07802048, 0x04c80208, 0x07400248,
+	0x04001249, 0x07c01b49, 0x078017c8, 0x0aa0c0c8, 0x0c00d940,
+	0x06808011, 0x0fc01200, 0x0aa0c008, 0x0c00e180, 0x06808011,
+	0x0aa18019, 0x06808008, 0x07801b4a, 0x07801993, 0x0c00b3c0,
+	0x06800012, 0x07800f08, 0x04000248, 0x0aa34008, 0x06094209,
+	0x0c06fc80, 0x080c2301, 0x09484245, 0x0c06fbc0, 0x080c2301,
+	0x09504245, 0x06094209, 0x0680c008, 0x06094008, 0x0c014300,
+	0x0780198a, 0x06494008, 0x09c08248, 0x06094008, 0x078011c8,
+	0x0aa38008, 0x00000000, 0x07801208, 0x0a61c148, 0x00000000,
+	0x0fc01200, 0x07c01a08, 0x0fc01200, 0x0c780180, 0x07c01a48,
+	0x0fc01200, 0x0aa0c008, 0x0c00bf00, 0x00000000, 0x07800e08,
+	0x0aa18008, 0x06800c09, 0x0c06f480, 0x080c2301, 0x09402245,
+	0x060c2109, 0x0c7fe640, 0x00000000, 0x0aa60019, 0x0c0084c0,
+	0x06808008, 0x07c02008, 0x07801b48, 0x04020208, 0x0c009000,
+	0x07c01b88, 0x07801588, 0x0aa3c008, 0x07802088, 0x0aa34008,
+	0x078015c8, 0x0aa0c008, 0x079014c8, 0x07901448, 0x06bfffc9,
+	0x0a807248, 0x07801b49, 0x07802048, 0x04c80208, 0x07400248,
+	0x04001249, 0x07c01b49, 0x078017c8, 0x0aa0c0c8, 0x0c00c540,
+	0x06808011, 0x0fc01200, 0x0aa0c008, 0x0c00cd80, 0x06808011,
+	0x0aa44019, 0x07801588, 0x0aa3c008, 0x07802088, 0x0aa34008,
+	0x078015c8, 0x0aa0c008, 0x07901508, 0x07901488, 0x06bfffc9,
+	0x0a807248, 0x07801b89, 0x07802048, 0x04c80208, 0x07400248,
+	0x04001249, 0x07c01b89, 0x078017c8, 0x0aa340c8, 0x07801b48,
+	0x068095d1, 0x07400448, 0x07801b88, 0x07c01b48, 0x0c00bdc0,
+	0x06808811, 0x07801b48, 0x07c01b88, 0x068095d1, 0x07000448,
+	0x07c01b48, 0x0fc01200, 0x0aa2c008, 0x07801b48, 0x068095d1,
+	0x07400448, 0x07801b88, 0x07c01b48, 0x0c00c380, 0x06808811,
+	0x068095d1, 0x07000448, 0x07c01b48, 0x0aa34019, 0x06808008,
+	0x07801b4a, 0x07801993, 0x0c009500, 0x06800012, 0x06808808,
+	0x07801b8a, 0x078019d3, 0x0c0093c0, 0x06800212, 0x0c009d80,
+	0x06808808, 0x07800f48, 0x0a60c088, 0x06800009, 0x06815409,
+	0x09402248, 0x0a644048, 0x06094209, 0x0c06db40, 0x080c2301,
+	0x09484245, 0x0c06da80, 0x080c2301, 0x09504245, 0x06094209,
+	0x0680c008, 0x06094008, 0x0c0121c0, 0x0780198a, 0x0680d808,
+	0x06094008, 0x0c0120c0, 0x078019ca, 0x0c7fddc0, 0x00000000,
+	0x07801588, 0x0aa0c008, 0x06804049, 0x06806049, 0x06800008,
+	0x0780020a, 0x07400248, 0x0d07ffca, 0x04008249, 0x0cc00000,
+	0x00000000, 0x06800008, 0x07c020c8, 0x07801589, 0x0aa0c009,
+	0x06800308, 0x06800348, 0x07000209, 0x09002289, 0x0aa4800a,
+	0x0aa380ca, 0x078017cb, 0x0aa280cb, 0x0aa0c04b, 0x090012c9,
+	0x090212c9, 0x0a61800b, 0x090412c9, 0x0a61000b, 0x0680004b,
+	0x0c7801c0, 0x07c020cb, 0x0c780000, 0x00000000, 0x09c09009,
+	0x09c09049, 0x07400209, 0x0cc00000, 0x00000000, 0x0c001540,
+	0x06a0200b, 0x06808009, 0x0680900a, 0x0680000c, 0x07801588,
+	0x0aa0c008, 0x06804048, 0x06806048, 0x0700020d, 0x0be3004d,
+	0x0914238d, 0x0a63c00e, 0x0a26200b, 0x0c001800, 0x094082cc,
+	0x0780158d, 0x0aa0c00d, 0x06801acd, 0x06801b0d, 0x0c780440,
+	0x0740034b, 0x0740028c, 0x0400128a, 0x0740024c, 0x0c780300,
+	0x04001249, 0x0aa2808e, 0x0a61004e, 0x0904438d, 0x0740028c,
+	0x0400128a, 0x0aa1400e, 0x00000000, 0x0740024c, 0x0c780080,
+	0x04001249, 0x0780020d, 0x0440134d, 0x04008208, 0x0b8e134c,
+	0x0400130c, 0x0cc00000, 0x00000000, 0x07801acb, 0x06808009,
+	0x0680900a, 0x0680000c, 0x07801588, 0x0aa10008, 0x06804048,
+	0x06806048, 0x07801b0b, 0x0700020d, 0x0be1404d, 0x0914238d,
+	0x0a62000e, 0x0c780440, 0x00000000, 0x0740028c, 0x0400128a,
+	0x0740024c, 0x0c780300, 0x04001249, 0x0aa2808e, 0x0a61004e,
+	0x0904438d, 0x0740028c, 0x0400128a, 0x0aa1400e, 0x00000000,
+	0x0740024c, 0x0c780080, 0x04001249, 0x0900834b, 0x0a40330d,
+	0x0c000880, 0x00000000, 0x0780020d, 0x0440134d, 0x04008208,
+	0x0b8e434c, 0x0400130c, 0x0cc00000, 0x00000000, 0x078011c8,
+	0x0a60c008, 0x0cc00000, 0x0980b38b, 0x07801588, 0x0aa0c008,
+	0x068000c8, 0x06800108, 0x07800a8c, 0x07000209, 0x0680000a,
+	0x0a21c049, 0x05801249, 0x0b8fe30a, 0x0400128a, 0x0c780000,
+	0x0cc00000, 0x00000000, 0x095082ca, 0x0680004c, 0x0340c28c,
+	0x07000209, 0x02c09309, 0x0cc00000, 0x07400209, 0x078020ce,
+	0x0a62400e, 0x0649c80e, 0x093e13ce, 0x0aa1800f, 0x091083ce,
+	0x0aa1000f, 0x044013cf, 0x0950838f, 0x0609c80e, 0x078011ce,
+	0x0aa1000e, 0x0680000e, 0x0c780500, 0x07c0210e, 0x0649c80e,
+	0x093e13ce, 0x0a61000f, 0x0680000e, 0x0c780380, 0x07c0210e,
+	0x078020ce, 0x0a62c00e, 0x0780158e, 0x0a62400e, 0x0649c80e,
+	0x091083ce, 0x0a6dc00f, 0x090083ce, 0x0950838f, 0x0609c80e,
+	0x0680004e, 0x07c0210e, 0x06a0000e, 0x060c3d0e, 0x04401388,
+	0x091083cb, 0x0740038f, 0x0400138e, 0x06810010, 0x078011d1,
+	0x0aa3c011, 0x06bfffd1, 0x04c0c410, 0x07800151, 0x07800192,
+	0x09610452, 0x0e0003d1, 0x07801592, 0x0aa0c012, 0x0649d612,
+	0x0649d712, 0x0f000440, 0x0f0103c0, 0x0970844f, 0x02011491,
+	0x064c3d0f, 0x091613cf, 0x0a6f800f, 0x00000000, 0x060c3811,
+	0x07801811, 0x094c2411, 0x07400390, 0x0c00a3c0, 0x00000000,
+	0x07800290, 0x069fff8f, 0x0a81640f, 0x0780174f, 0x0a62c08f,
+	0x0780158f, 0x0aa1000f, 0x069fffcf, 0x0a80e40f, 0x0c7803c0,
+	0x0a80e40f, 0x07c00292, 0x069fff8f, 0x0c7802c0, 0x07c0028f,
+	0x069fffcf, 0x0a80640f, 0x091e13d0, 0x0aa0c00f, 0x06c00010,
+	0x06ffffd0, 0x0b403412, 0x0680004f, 0x07c0210f, 0x04000812,
+	0x07000390, 0x0780210f, 0x0952140f, 0x0b004452, 0x09c10210,
+	0x09810210, 0x04000811, 0x07400390, 0x080c3000, 0x060c3220,
+	0x060c3212, 0x060c3211, 0x078020d0, 0x0aa28010, 0x078017d0,
+	0x0aa0c050, 0x0400140e, 0x04002410, 0x07400412, 0x09210492,
+	0x04001410, 0x0c780700, 0x07400412, 0x0400138e, 0x07400392,
+	0x09210492, 0x0400138e, 0x07400392, 0x0400138e, 0x07400391,
+	0x09210451, 0x0400138e, 0x07400391, 0x0400138e, 0x078002d0,
+	0x07400390, 0x06806010, 0x0b40c40e, 0x0440638e, 0x06804010,
+	0x0240e40e, 0x0580238e, 0x06802ad0, 0x0200e40e, 0x07801250,
+	0x07400390, 0x07801290, 0x0400138e, 0x07400390, 0x07801590,
+	0x0aa0c010, 0x06800310, 0x06800350, 0x07000411, 0x078017d2,
+	0x0aa0c092, 0x00000000, 0x09811011, 0x0aa0c052, 0x00000000,
+	0x09811051, 0x0946544b, 0x07400411, 0x07801591, 0x0aa10011,
+	0x0900844b, 0x07800212, 0x02011491, 0x05401491, 0x02011491,
+	0x0649c612, 0x02011491, 0x04000491, 0x04001451, 0x09508491,
+	0x04001451, 0x09608491, 0x0609b212, 0x0609b012, 0x0609b112,
+	0x0cc00000, 0x00000000, 0x07801588, 0x0aa0c008, 0x0cc00000,
+	0x00000000, 0x0680000f, 0x0c000340, 0x0680400b, 0x04000512,
+	0x07800089, 0x0780000a, 0x0a405289, 0x0680004f, 0x0c000180,
+	0x0680600b, 0x0a6c8012, 0x0a6c4014, 0x0cc00000, 0x00000000,
+	0x06800012, 0x06bfffca, 0x06dfffca, 0x07800213, 0x06bfffcd,
+	0x0400134d, 0x0b41b4cd, 0x0400038d, 0x0400044e, 0x0540338e,
+	0x0200e2ce, 0x0400138e, 0x0700038c, 0x0a21004c, 0x09c0c00c,
+	0x0c7ffd80, 0x0740038c, 0x0914224c, 0x0a6cc049, 0x0910130c,
+	0x0aa0c00c, 0x0400138e, 0x0400238e, 0x0400130e, 0x0700038e,
+	0x0700030c, 0x0961038c, 0x0b0ea38a, 0x00000000, 0x06800052,
+	0x0400028e, 0x0c7ff980, 0x04000411, 0x0aa0c012, 0x0c00b700,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0680004c, 0x078009cb,
+	0x0340c2cc, 0x06808009, 0x07801b4f, 0x0b8033c9, 0x0cc00000,
+	0x00000000, 0x0780158b, 0x0aa0c00b, 0x0680400b, 0x0680600b,
+	0x0700024a, 0x0540328a, 0x0200a2ca, 0x0400628a, 0x0700028a,
+	0x0b00320a, 0x04000349, 0x0240a30a, 0x0400134d, 0x0b4113cd,
+	0x0700034e, 0x0540338e, 0x0200e2ce, 0x0400638e, 0x0700038e,
+	0x0b00320e, 0x00000000, 0x0240e30e, 0x0b4f638a, 0x00000000,
+	0x0400028e, 0x0700024e, 0x07000350, 0x0740034e, 0x0c7ffc00,
+	0x07400250, 0x04001249, 0x0b8e53c9, 0x0cc00000, 0x00000000,
+	0x06808009, 0x07801b4f, 0x0780158b, 0x0aa0c00b, 0x0680400b,
+	0x0680600b, 0x0700024a, 0x0540328a, 0x0200a2ca, 0x0400128a,
+	0x0700028c, 0x0910130c, 0x0aa0c00c, 0x0400128a, 0x0400228a,
+	0x0400130a, 0x0700028a, 0x0700030c, 0x0961028c, 0x04000349,
+	0x0400134d, 0x0b4163cd, 0x0700034e, 0x0540338e, 0x0200e2ce,
+	0x0400138e, 0x0700038c, 0x0910130c, 0x0aa0c00c, 0x0400138e,
+	0x0400238e, 0x0400130e, 0x0700038e, 0x0700030c, 0x0961038c,
+	0x0b4f138a, 0x00000000, 0x0400028e, 0x0700024e, 0x07000350,
+	0x0740034e, 0x0c7ffac0, 0x07400250, 0x0b00380a, 0x00000000,
+	0x04001208, 0x04001249, 0x0b8d73c9, 0x0cc00000, 0x00000000,
+	0x06808809, 0x0680800a, 0x07802008, 0x04401208, 0x0b806288,
+	0x0700020b, 0x0740024b, 0x04001249, 0x0c7fff00, 0x04401208,
+	0x07802008, 0x07801b4a, 0x0b406288, 0x0700020b, 0x0740024b,
+	0x04001249, 0x0c7fff00, 0x04001208, 0x06808009, 0x07801b4a,
+	0x07802008, 0x0b406288, 0x0700020b, 0x0740024b, 0x04001249,
+	0x0c7fff00, 0x04001208, 0x06808808, 0x0780200a, 0x0402028a,
+	0x0b406288, 0x0700020b, 0x0740024b, 0x04001249, 0x0c7fff00,
+	0x04001208, 0x0cc00000, 0x00000000, 0x078017d0, 0x0aa0c0d0,
+	0x0900150e, 0x0580138e, 0x0a23600e, 0x0487f38e, 0x0400040e,
+	0x054013d0, 0x0200f40f, 0x040103cf, 0x060c240f, 0x0540830c,
+	0x09405310, 0x0540338e, 0x06804010, 0x0c7802c0, 0x0200e40e,
+	0x0201044e, 0x054013d0, 0x0200f40f, 0x040103cf, 0x060c240f,
+	0x0540830c, 0x09405310, 0x0540338e, 0x0200e34e, 0x0400138e,
+	0x07000390, 0x060c2210, 0x090c23d0, 0x0b62c08f, 0x068000cf,
+	0x078017cf, 0x0a6140cf, 0x00000000, 0x090c23d0, 0x0c780140,
+	0x040013cf, 0x0a60c014, 0x00000000, 0x050033cf, 0x094a230f,
+	0x0400138e, 0x0700038f, 0x0400138e, 0x07000390, 0x096103d0,
+	0x060c220f, 0x0400138e, 0x0700038f, 0x0400138e, 0x07000390,
+	0x096103d0, 0x0cc00000, 0x060c220f, 0x078017cc, 0x0aa200cc,
+	0x0680000b, 0x040014d3, 0x054014d3, 0x078020cc, 0x0aa0c00c,
+	0x044014d3, 0x044014d3, 0x0680000c, 0x06800011, 0x0780158d,
+	0x0aa1000d, 0x0680400d, 0x0680600d, 0x07800211, 0x0ac0d4cb,
+	0x0b40c288, 0x0c07edc0, 0x0700020e, 0x090023cb, 0x0a6140cf,
+	0x058023cb, 0x0200f48f, 0x060c240f, 0x060c220c, 0x040012cb,
+	0x0c7ffd40, 0x04001208, 0x0a2280cb, 0x0580234b, 0x0200d48d,
+	0x060c240d, 0x090022cb, 0x0680010d, 0x0240b2cd, 0x054032cb,
+	0x0340c2cc, 0x060c220c, 0x0cc00000, 0x00000000, 0x078017c9,
+	0x0aa0c0c9, 0x07000208, 0x05801208, 0x05403208, 0x07801589,
+	0x0aa0c009, 0x06804009, 0x06806009, 0x02008248, 0x0700020f,
+	0x090043cf, 0x07800151, 0x07800192, 0x09610452, 0x0e0003d1,
+	0x07801592, 0x0aa0c012, 0x0649d612, 0x0649d712, 0x0f000440,
+	0x0f0103c0, 0x0970844f, 0x02011491, 0x05803451, 0x04001208,
+	0x0700020f, 0x090c23cf, 0x097c244f, 0x0b61408f, 0x078017cf,
+	0x0a60c08f, 0x00000000, 0x09811751, 0x060c3911, 0x0cc00000,
+	0x00000000, 0x0c0636c0, 0x080c2301, 0x0aa20005, 0x0ae18185,
+	0x0a610045, 0x0c0001c0, 0x00000000, 0x0c7ffe40, 0x0c780000,
+	0x0c780000, 0x0cc00000, 0x00000000, 0x0c0633c0, 0x080c2301,
+	0x0a608019, 0x0cc00000, 0x04001205, 0x078002c9, 0x02410209,
+	0x07801808, 0x0b610088, 0x00000000, 0x02010250, 0x04001410,
+	0x06808009, 0x07801b4f, 0x0780158b, 0x0aa0c00b, 0x0680400b,
+	0x0680600b, 0x0700024a, 0x0be1a00a, 0x0540328a, 0x0200a2ca,
+	0x0400628a, 0x0700028c, 0x0a80540c, 0x04001249, 0x0b8f83c9,
+	0x0cc00000, 0x00000000, 0x0440528a, 0x0700028c, 0x09c0c0cc,
+	0x09c0c08c, 0x09c0c00c, 0x0740028c, 0x0440128a, 0x0700028c,
+	0x0481f30c, 0x07801588, 0x0aa0c008, 0x068000c8, 0x06800108,
+	0x0680004a, 0x0340a30a, 0x06bfffcc, 0x0300a30a, 0x07000209,
+	0x02809289, 0x0cc00000, 0x07400209, 0x04000411, 0x07801b52,
+	0x06809013, 0x0b406490, 0x07000414, 0x074004d4, 0x040014d3,
+	0x0c7fff00, 0x04001410, 0x04000411, 0x06809011, 0x06809012,
+	0x07801595, 0x0aa0c015, 0x07801ad5, 0x07801b15, 0x09008555,
+	0x0b4084d1, 0x07000454, 0x0a8fe554, 0x04001451, 0x05401514,
+	0x04001514, 0x07400414, 0x04001410, 0x0b4074d2, 0x07000494,
+	0x0befa014, 0x04001492, 0x05401514, 0x07400414, 0x04001410,
+	0x0b8f14d1, 0x0b8f04d2, 0x07c01b50, 0x0cc00000, 0x00000000,
+	0x078002d0, 0x078017d2, 0x0aa100d2, 0x06bfffd2, 0x05401410,
+	0x04001410, 0x07801593, 0x0aa0c013, 0x06804013, 0x06806013,
+	0x0c061b80, 0x080c2301, 0x0aa440c5, 0x0aaf4019, 0x0ae38145,
+	0x0a610005, 0x0c0003c0, 0x00000000, 0x0c7ffe00, 0x0a610045,
+	0x0c000f80, 0x00000000, 0x0c7ffd00, 0x0a610145, 0x0c0011c0,
+	0x00000000, 0x0c7ffc00, 0x0c780000, 0x0c780000, 0x0cc00000,
+	0x00000000, 0x0c061640, 0x080c2301, 0x04001205, 0x06800055,
+	0x078009c9, 0x078017d4, 0x0aa0c0d4, 0x03415255, 0x05401555,
+	0x0b403210, 0x02410210, 0x02010550, 0x078002c8, 0x078017d4,
+	0x0aa100d4, 0x00000000, 0x05401208, 0x04001208, 0x0b803210,
+	0x04000510, 0x02414550, 0x04000211, 0x07801b49, 0x0b40e248,
+	0x078017ca, 0x0a6380ca, 0x0700020a, 0x0be1a00a, 0x0540328a,
+	0x0200a4ca, 0x0400628a, 0x0700028a, 0x0a80350a, 0x0c7ffd80,
+	0x04001208, 0x0c000c00, 0x00000000, 0x0cc00000, 0x00000000,
+	0x090012ca, 0x0580128a, 0x0bee200a, 0x0540328a, 0x0200a4ca,
+	0x0400628a, 0x0700028a, 0x0540128a, 0x0200a2ca, 0x0a8f350a,
+	0x0c7ffc00, 0x00000000, 0x0c060980, 0x080c2301, 0x04001205,
+	0x06800055, 0x078009c9, 0x078017d4, 0x0aa0c0d4, 0x03415255,
+	0x05401555, 0x02010210, 0x0b8cf550, 0x0c7ff380, 0x02410550,
+	0x0c060640, 0x080c2301, 0x04001205, 0x02012212, 0x0a634012,
+	0x04000211, 0x07801b49, 0x0b40a248, 0x078017ca, 0x0aa0c0ca,
+	0x0700020a, 0x0580128a, 0x0be0e00a, 0x0c7ffe80, 0x04001208,
+	0x0c000100, 0x00000000, 0x0cc00000, 0x00000000, 0x04000291,
+	0x040002c8, 0x070002cf, 0x0b00628b, 0x0440130b, 0x0700030c,
+	0x074002cc, 0x0c7fff00, 0x044012cb, 0x0740028f, 0x0cc00000,
+	0x04001451, 0x0c780000, 0x00000000, 0x07800a0f, 0x0460040f,
+	0x0c480900, 0x07800a4f, 0x06800050, 0x034173d0, 0x05801597,
+	0x07801c15, 0x07801c4f, 0x0961054f, 0x07801c93, 0x07801894,
+	0x0b4054d4, 0x0240f513, 0x0b80758f, 0x0c780180, 0x020155d5,
+	0x0240f4d4, 0x0b00358f, 0x0c780080, 0x024155d5, 0x040004d4,
+	0x078011cf, 0x0aa1400f, 0x058103d5, 0x07c01c15, 0x07c01c4f,
+	0x07c01c93, 0x078017d4, 0x0aa100d4, 0x020124d5, 0x0c780bc0,
+	0x04000452, 0x078018cf, 0x07801910, 0x096103d0, 0x0c780a80,
+	0x020113d2, 0x078009cf, 0x06800050, 0x034173d0, 0x0780120f,
+	0x0a61c14f, 0x0680000f, 0x07c01ccf, 0x07c01d0f, 0x07c01d4f,
+	0x07c01f0f, 0x07c01f4f, 0x07801cd6, 0x07801d15, 0x07801d4f,
+	0x0961054f, 0x078002d4, 0x0b403594, 0x00000000, 0x020155d5,
+	0x07800a0f, 0x0460240f, 0x0c5000c0, 0x0c780000, 0x00000000,
+	0x0780120f, 0x0a61014f, 0x06800012, 0x0c780280, 0x06800011,
+	0x02013515, 0x054014d3, 0x078011cf, 0x0a60c00f, 0x00000000,
+	0x044014d3, 0x04000493, 0x04000453, 0x07c01d15, 0x058103d5,
+	0x07c01d4f, 0x0b803452, 0x04000412, 0x04000411, 0x07c01d90,
+	0x058103d0, 0x07c01dcf, 0x07c01e12, 0x058103d2, 0x07c01e4f,
+	0x07c01e91, 0x058103d1, 0x07c01ecf, 0x078002d4, 0x0cc00000,
+	0x07c01cd4, 0x078011c8, 0x0aa18008, 0x06808008, 0x07800a89,
+	0x02009209, 0x07801b48, 0x0b403248, 0x0cc00000, 0x00000000,
+	0x06808009, 0x07801b4f, 0x0780158b, 0x0aa0c00b, 0x0680400b,
+	0x0680600b, 0x0700024a, 0x0400040a, 0x0540328a, 0x0200a2ca,
+	0x0400128a, 0x0700028c, 0x0910130c, 0x0aa0c00c, 0x0400128a,
+	0x0400228a, 0x0400130a, 0x0700028a, 0x0700030c, 0x0961028c,
+	0x04000349, 0x0400134d, 0x0b4143cd, 0x0700034e, 0x0400044e,
+	0x0540338e, 0x0200e2ce, 0x0400138e, 0x0700038c, 0x0910130c,
+	0x0aa0c00c, 0x0400138e, 0x0400238e, 0x0400130e, 0x0700038e,
+	0x0700030c, 0x0961038c, 0x0b0f038a, 0x00000000, 0x0400028e,
+	0x0c7ffb40, 0x04000411, 0x0c000100, 0x0780158f, 0x0cc00000,
+	0x00000000, 0x0aa0c00f, 0x0680400b, 0x0680600b, 0x05403390,
+	0x0200e2ce, 0x0400138e, 0x0700038c, 0x0be0804c, 0x0a24830c,
+	0x09c0c0cc, 0x09c0c08c, 0x09c0c00c, 0x0740038c, 0x0440138e,
+	0x0700038c, 0x0481f30c, 0x0aa0c00f, 0x068000c8, 0x06800108,
+	0x0680004a, 0x0340a30a, 0x06bfffcc, 0x0300a30a, 0x07000209,
+	0x02809289, 0x07400209, 0x0cc00000, 0x00000000, 0x06809008,
+	0x078001c9, 0x02009209, 0x07801bc8, 0x0b403248, 0x0cc00000,
+	0x00000000, 0x06809009, 0x07801bcf, 0x0780158b, 0x0aa0c00b,
+	0x0680400b, 0x0680600b, 0x0700024a, 0x0400040a, 0x0540328a,
+	0x0200a2ca, 0x0400128a, 0x0700028c, 0x0a21804c, 0x00000000,
+	0x04001249, 0x0b8f73c9, 0x0cc00000, 0x00000000, 0x0910130c,
+	0x0aa0c00c, 0x0400128a, 0x0400228a, 0x0400130a, 0x0700028a,
+	0x0700030c, 0x0961028c, 0x04000349, 0x0400134d, 0x0b4153cd,
+	0x0700034e, 0x0400044e, 0x0540338e, 0x0200e2ce, 0x0400138e,
+	0x0700038c, 0x0bee004c, 0x0910130c, 0x0aa0c00c, 0x0400138e,
+	0x0400238e, 0x0400130e, 0x0700038e, 0x0700030c, 0x0961038c,
+	0x0b0ef38a, 0x00000000, 0x0400028e, 0x0c7ffb00, 0x04000411,
+	0x0c000180, 0x0780158f, 0x0aa08011, 0x0c7ff680, 0x0cc00000,
+	0x00000000, 0x06800011, 0x0aa0c00f, 0x0680400b, 0x0680600b,
+	0x05403390, 0x0200e2ce, 0x0400138e, 0x0700038d, 0x0400030d,
+	0x0980d2cd, 0x09c0d28d, 0x09c0d0cd, 0x09c0d08d, 0x09c0d00d,
+	0x0740038d, 0x0a21c30c, 0x0980d00d, 0x0740038d, 0x06800051,
+	0x0440138e, 0x0700038c, 0x0481f30c, 0x094c240f, 0x078007cb,
+	0x074002d0, 0x040012cb, 0x0680078c, 0x0b80330b, 0x00000000,
+	0x0680038b, 0x0780078c, 0x0a40c30b, 0x00000000, 0x0649c70c,
+	0x0aa0c00c, 0x0c05d600, 0x00000000, 0x0649c00c, 0x0aa0c00c,
+	0x0c7ffe80, 0x00000000, 0x0c05dcc0, 0x00000000, 0x0cc00000,
+	0x07c007cb, 0x0680000b, 0x0400128a, 0x0fc01200, 0x0aa20048,
+	0x0680004c, 0x06494208, 0x09084208, 0x0340c20c, 0x0540830c,
+	0x0c780340, 0x0609410c, 0x0c05b480, 0x080c2301, 0x0c05b500,
+	0x00000000, 0x04000305, 0x0c05b340, 0x080c2301, 0x0c05b3c0,
+	0x00000000, 0x0950914c, 0x06094105, 0x0fc01200, 0x0aa24048,
+	0x0680004c, 0x06494208, 0x09104208, 0x0340c20c, 0x0540830c,
+	0x0609410c, 0x0c780600, 0x0609410c, 0x0c05af40, 0x080c2301,
+	0x0c05afc0, 0x00000000, 0x04000305, 0x0c05ae00, 0x080c2301,
+	0x0c05ae80, 0x00000000, 0x0950914c, 0x06094105, 0x0c05ac80,
+	0x080c2301, 0x0c05ad00, 0x00000000, 0x04000305, 0x0c05ab40,
+	0x080c2301, 0x0c05abc0, 0x00000000, 0x0950914c, 0x06094105,
+	0x040012cb, 0x0b8cb28b, 0x0cc00000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264slice_mvc_linux.h b/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264slice_mvc_linux.h
new file mode 100644
index 0000000..139a2b3
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264mvc/gxm_h264slice_mvc_linux.h
@@ -0,0 +1,428 @@
+static const u32 MicroCode[] __initconst = {
+	0x078016d1, 0x06840009, 0x063f0009, 0x083f0000, 0x08002a09,
+	0x08002b17, 0x06830009, 0x06032609, 0x08032261, 0x08032101,
+	0x07801048, 0x064e0e09, 0x09401248, 0x060e0e09, 0x07800b09,
+	0x04401249, 0x07c02549, 0x07800e09, 0x0aa0c009, 0x06800009,
+	0x0687ffc9, 0x07c02849, 0x06800809, 0x07801988, 0x09505248,
+	0x078019c8, 0x09605248, 0x07800bc8, 0x096a2248, 0x07801948,
+	0x096e1248, 0x060c2109, 0x07800c08, 0x0aa10008, 0x05401208,
+	0x07800b89, 0x09441209, 0x078010c9, 0x09401209, 0x07c02a08,
+	0x06800009, 0x07c02a49, 0x07c02949, 0x07801709, 0x07c02a89,
+	0x0aa0c011, 0x0c001400, 0x00000000, 0x06800008, 0x060c2108,
+	0x0c001bc0, 0x00000000, 0x080c0001, 0x08030504, 0x0c7ef380,
+	0x00400000, 0x06bfd98a, 0x0603040a, 0x00400000, 0x064c430a,
+	0x0580128a, 0x0baf980a, 0x064c0008, 0x0be3c048, 0x00000000,
+	0x00800000, 0x06bffe8a, 0x0603040a, 0x0cc00000, 0x00400000,
+	0x0c780000, 0x0c780000, 0x0c7ff540, 0x00000000, 0x0bef9008,
+	0x00000000, 0x0c78b780, 0x0680000a, 0x0aa4c048, 0x0beed208,
+	0x0683ffcb, 0x0aadc00b, 0x044012cb, 0x064e0f08, 0x09003248,
+	0x09063288, 0x0b40324a, 0x0240a24a, 0x0400828a, 0x0ba180ca,
+	0x0aedc0ca, 0x080c3e00, 0x064c3f08, 0x09002208, 0x0a6cc0c8,
+	0x0cb80024, 0x00000000, 0x0680000a, 0x0649d308, 0x0aa24008,
+	0x0aa18011, 0x0a60c048, 0x0c780180, 0x0809d300, 0x04401208,
+	0x0680004a, 0x0c78b080, 0x0609d308, 0x0680000a, 0x07802108,
+	0x0aa18008, 0x0aa0c011, 0x00000000, 0x0680004a, 0x0c78ae80,
+	0x00000000, 0x07800bc8, 0x0aa14388, 0x07801748, 0x0aa08088,
+	0x0c784840, 0x0c787800, 0x0aa08088, 0x0c783180, 0x0c786980,
+	0x00000000, 0x0649c908, 0x04001208, 0x0609c908, 0x06800015,
+	0x07c02155, 0x07c02195, 0x07c021d5, 0x07c02215, 0x07c02255,
+	0x06803fc8, 0x07c022c8, 0x06800008, 0x07c02388, 0x07c02408,
+	0x07c02448, 0x07802548, 0x04001208, 0x07c02588, 0x06800048,
+	0x060e0c08, 0x07c02788, 0x07c025c8, 0x06800008, 0x07c027c8,
+	0x068003c8, 0x07c02608, 0x06805c08, 0x060c2108, 0x080c2170,
+	0x06800088, 0x07c02708, 0x0c013900, 0x00000000, 0x0cc00000,
+	0x06800016, 0x078027cb, 0x0a6fc00b, 0x00000000, 0x0c013bc0,
+	0x00000000, 0x0c014140, 0x00000000, 0x07801748, 0x06900009,
+	0x06c000c9, 0x0649ce0a, 0x02009289, 0x05c0c289, 0x06819564,
+	0x0aa18088, 0x06800009, 0x068164e4, 0x0aa0c148, 0x06800049,
+	0x06800089, 0x07c02509, 0x078017c8, 0x094c2248, 0x060c0409,
+	0x07c0264a, 0x0581028a, 0x07c0268a, 0x06800008, 0x07c02748,
+	0x07800b0b, 0x0b20c2cb, 0x068004cb, 0x06800c0b, 0x06495108,
+	0x0970620b, 0x06095108, 0x07800b4b, 0x07800b88, 0x0a630008,
+	0x078017ca, 0x0aa280ca, 0x054012cb, 0x058012cb, 0x06490708,
+	0x09808088, 0x098080c8, 0x06090708, 0x06495108, 0x098083c8,
+	0x06095108, 0x07c026cb, 0x07800bc8, 0x0944220a, 0x07c00bc8,
+	0x0a638388, 0x068000ca, 0x06495108, 0x0940420a, 0x0680000a,
+	0x0979d20a, 0x06095108, 0x06490708, 0x09808448, 0x06090708,
+	0x07801748, 0x0aa0c088, 0x06818564, 0x06814ce4, 0x07800e08,
+	0x0a610008, 0x07801a88, 0x0c780b00, 0x060c0a08, 0x0fc07200,
+	0x080c2940, 0x07801a88, 0x09808188, 0x098083c8, 0x060c0a08,
+	0x09c083c8, 0x09808388, 0x0c00b0c0, 0x060c0a08, 0x07802509,
+	0x064c0a08, 0x091c2208, 0x0a6f8008, 0x0780285b, 0x06c0001b,
+	0x0680001c, 0x06c0001c, 0x0680001d, 0x06c0001d, 0x0680001e,
+	0x06c0001e, 0x06bfffdf, 0x0a628009, 0x07800bc8, 0x0680030a,
+	0x0aa18388, 0x07c0280a, 0x0680018a, 0x07c0280a, 0x0cc00000,
+	0x060c0715, 0x0cc00000, 0x0680030a, 0x0aa18388, 0x07c0280a,
+	0x0680018a, 0x07c0280a, 0x0cc00000, 0x060c0715, 0x0cc00000,
+	0x00000000, 0x0c00a840, 0x080c0600, 0x0780285b, 0x06c0001b,
+	0x0680001c, 0x06c0001c, 0x0680001d, 0x06c0001d, 0x0680001e,
+	0x06c0001e, 0x06bfffdf, 0x07802509, 0x0a628009, 0x07800bc8,
+	0x0680030a, 0x0aa18388, 0x07c0280a, 0x0680018a, 0x07c0280a,
+	0x0cc00000, 0x060c0715, 0x0cc00000, 0x0680030a, 0x0aa18388,
+	0x07c0280a, 0x0680018a, 0x07c0280a, 0x0cc00000, 0x060c0715,
+	0x0cc00000, 0x00000000, 0x064c031b, 0x064c031c, 0x064c031d,
+	0x064c031e, 0x064c271f, 0x0a224055, 0x07802888, 0x07c028c8,
+	0x04000817, 0x04000858, 0x04000899, 0x040008da, 0x0c781400,
+	0x060c0715, 0x0683ffc8, 0x04401208, 0x0aa0c008, 0x078027cb,
+	0x0a6f400b, 0x068000cb, 0x07802908, 0x095102c8, 0x07802148,
+	0x097082c8, 0x06031e0b, 0x0aa08008, 0x0c780b00, 0x080c0700,
+	0x07802849, 0x06c00009, 0x060c0209, 0x06800009, 0x06c00009,
+	0x060c0209, 0x06800009, 0x06c00009, 0x060c0209, 0x06800009,
+	0x06c00009, 0x060c0209, 0x06bfffca, 0x060c0320, 0x060c0321,
+	0x060c0322, 0x060c0323, 0x078028c9, 0x0961024a, 0x060c2709,
+	0x080c0701, 0x07802849, 0x06c00009, 0x060c0209, 0x06800009,
+	0x06c00009, 0x060c0209, 0x06800009, 0x06c00009, 0x060c0209,
+	0x06800009, 0x06c00009, 0x060c0209, 0x060c0317, 0x060c0318,
+	0x060c0319, 0x060c031a, 0x0780288b, 0x096102ca, 0x060c270b,
+	0x0c780580, 0x060c0715, 0x064c270a, 0x0921028a, 0x060c0320,
+	0x060c0321, 0x060c0322, 0x060c0323, 0x078028c9, 0x0961024a,
+	0x060c2709, 0x080c0701, 0x064c270a, 0x0921028a, 0x060c0317,
+	0x060c0318, 0x060c0319, 0x060c031a, 0x07802889, 0x0961024a,
+	0x060c2709, 0x060c0715, 0x06431e0a, 0x0befc04a, 0x07802a08,
+	0x04c30208, 0x0c780b40, 0x060c2508, 0x064c031b, 0x064c031c,
+	0x064c031d, 0x064c031e, 0x064c271f, 0x060c0715, 0x0921029f,
+	0x07802148, 0x0a638008, 0x07802849, 0x06c00009, 0x060c0209,
+	0x06800009, 0x06c00009, 0x060c0209, 0x06800009, 0x06c00009,
+	0x060c0209, 0x06800009, 0x06c00009, 0x060c0209, 0x06bfffca,
+	0x060c0317, 0x060c0318, 0x060c0319, 0x060c031a, 0x07802889,
+	0x0961024a, 0x060c2709, 0x07802a08, 0x04c30208, 0x060c2508,
+	0x0683ffca, 0x078027cb, 0x0aa0c00b, 0x0a6f800a, 0x0440128a,
+	0x068000cb, 0x0780290a, 0x095102ca, 0x0780214a, 0x097082ca,
+	0x06031e0b, 0x07802a4c, 0x07802608, 0x07c02988, 0x064c2308,
+	0x09304248, 0x0a6f8009, 0x090a1248, 0x09024208, 0x09521209,
+	0x0aa0c00c, 0x07c02608, 0x0c781040, 0x0aa64248, 0x060c2508,
+	0x0aa64288, 0x0aa58348, 0x0aa1c049, 0x0aa58388, 0x0a60c008,
+	0x0c7801c0, 0x00000000, 0x080c2605, 0x080c2606, 0x080c2602,
+	0x080c260f, 0x080c2603, 0x07802709, 0x0aa100c9, 0x0680008a,
+	0x0c782940, 0x07c0270a, 0x078027cc, 0x0a6fc00c, 0x00000000,
+	0x07c02749, 0x0c7827c0, 0x07c0270a, 0x080c2602, 0x080c260f,
+	0x080c2603, 0x07802709, 0x0aa50089, 0x068000ca, 0x07802149,
+	0x0aa0c009, 0x0c782540, 0x07c0270a, 0x0aa08725, 0x0bef4055,
+	0x0683ffcc, 0x07802789, 0x064e0c0a, 0x0901028a, 0x0b804289,
+	0x0aa0c00c, 0x0c7ffec0, 0x0440130c, 0x06800089, 0x068000ca,
+	0x0680180c, 0x060c210c, 0x0683ffcd, 0x0aa2c00d, 0x064e110c,
+	0x0910130c, 0x0a6f400c, 0x0440134d, 0x064e110c, 0x0910130c,
+	0x0a6e400c, 0x078027cc, 0x0a6dc00c, 0x00000000, 0x07c02749,
+	0x0c781e00, 0x07c0270a, 0x06800008, 0x07c02608, 0x060c2508,
+	0x06431e08, 0x0befc048, 0x068fdfc8, 0x06fcffc8, 0x064e0407,
+	0x02807207, 0x0c7ff140, 0x060e0408, 0x064c031b, 0x064c031c,
+	0x064c271f, 0x0a228055, 0x07802888, 0x07c028c8, 0x04000817,
+	0x04000858, 0x060c0715, 0x07802a08, 0x04c30208, 0x0c781500,
+	0x060c2508, 0x07802148, 0x0a658008, 0x080c0700, 0x07802849,
+	0x06c00009, 0x060c0209, 0x080c0200, 0x06bfffca, 0x060c0320,
+	0x060c0321, 0x078028cb, 0x096102ca, 0x060c270b, 0x080c0701,
+	0x060c0209, 0x080c0200, 0x060c0317, 0x060c0318, 0x0780288b,
+	0x096102ca, 0x060c270b, 0x0c780480, 0x060c0715, 0x064c270a,
+	0x0921028a, 0x060c0320, 0x060c0321, 0x078028c9, 0x0961024a,
+	0x060c2709, 0x080c0701, 0x064c270a, 0x0921028a, 0x060c0317,
+	0x060c0318, 0x07802889, 0x0961024a, 0x060c2709, 0x060c0715,
+	0x07802a08, 0x04c30208, 0x060c2508, 0x078027cb, 0x0a6fc00b,
+	0x068000cb, 0x0780290a, 0x095102ca, 0x0780214a, 0x097082ca,
+	0x0c780840, 0x06031e0b, 0x064c031b, 0x064c031c, 0x064c271f,
+	0x060c0715, 0x0921029f, 0x07802148, 0x0a618008, 0x07802849,
+	0x06c00009, 0x060c0209, 0x080c0200, 0x06bfffca, 0x060c0317,
+	0x060c0318, 0x07802889, 0x0961024a, 0x060c2709, 0x07802a08,
+	0x04c30208, 0x060c2508, 0x0683ffca, 0x0440128a, 0x0aa0c00a,
+	0x078027cb, 0x0a6f400b, 0x068000cb, 0x0780290a, 0x095102ca,
+	0x0780214a, 0x097082ca, 0x06031e0b, 0x07802608, 0x07c02988,
+	0x064c2308, 0x09304248, 0x0a6f8009, 0x09024208, 0x07c02608,
+	0x0aa10288, 0x060c2508, 0x080c2602, 0x080c260f, 0x080c2603,
+	0x04c00208, 0x09808208, 0x060c2108, 0x07802388, 0x0aa14008,
+	0x06a01009, 0x0aa0c048, 0x06a22009, 0x06a40009, 0x06431e0a,
+	0x0befc04a, 0x06c00109, 0x07800bca, 0x0a66838a, 0x0a264055,
+	0x0780298b, 0x0aa1c00b, 0x0780274b, 0x00800000, 0x0780278a,
+	0x0400128a, 0x07c0278a, 0x00400000, 0x0b61408b, 0x00000000,
+	0x080c2170, 0x0c7807c0, 0x080c260e, 0x0683ffcb, 0x044012cb,
+	0x0aa0c00b, 0x078027ca, 0x0a6f400a, 0x0780278a, 0x0440128a,
+	0x0c006d40, 0x07c0278a, 0x0c780500, 0x08030580, 0x060e0509,
+	0x07802749, 0x0680180a, 0x09502289, 0x060c210a, 0x080c260e,
+	0x06800089, 0x07c023c8, 0x0ba0c088, 0x04001208, 0x06800008,
+	0x07c02388, 0x07802148, 0x07c02288, 0x07802988, 0x07c029c8,
+	0x07c027c9, 0x08030580, 0x07802908, 0x0aa14725, 0x04001208,
+	0x07802189, 0x0a20c049, 0x00000000, 0x07c02908, 0x0683ffc9,
+	0x064c2308, 0x09304208, 0x0aa2c008, 0x00000000, 0x080c3e01,
+	0x064c3f08, 0x093e1208, 0x0aae4008, 0x0b6e0049, 0x04401249,
+	0x06bfffc9, 0x0c7f5f00, 0x07c02a89, 0x064c2b08, 0x060c2b08,
+	0x078022ce, 0x0ba13fce, 0x06800009, 0x0c781140, 0x07c022c9,
+	0x06808009, 0x0ba1070e, 0x0400028e, 0x0441c28a, 0x0680c009,
+	0x054032ca, 0x0200b28b, 0x020092c9, 0x0740025f, 0x04001249,
+	0x0921031b, 0x0740024c, 0x04001249, 0x0740025b, 0x04001249,
+	0x0740025c, 0x04001249, 0x0921031c, 0x0740024c, 0x04001249,
+	0x0740025d, 0x04001249, 0x0921031d, 0x0740024c, 0x04001249,
+	0x0740025e, 0x04001249, 0x0921031e, 0x0740024c, 0x07800b09,
+	0x0ac07949, 0x0780214b, 0x0aa38725, 0x0400030b, 0x0780218b,
+	0x0c7802c0, 0x0942f2cc, 0x0a61000b, 0x0aa14725, 0x0780218b,
+	0x0a20c04b, 0x0a6146ca, 0x040012ce, 0x0b60c70e, 0x0680000b,
+	0x0680070b, 0x07c022cb, 0x0b014949, 0x0aa0800b, 0x0a64870b,
+	0x0780230b, 0x0a20c04b, 0x06a0800c, 0x06a0c00c, 0x0690000a,
+	0x06c0024a, 0x0649ce0b, 0x0200a2ca, 0x0780234d, 0x054092cd,
+	0x0200b28b, 0x0603510b, 0x06803f0b, 0x0603520b, 0x0603500c,
+	0x0c0049c0, 0x00000000, 0x07800bc8, 0x0aa64388, 0x07802148,
+	0x04001208, 0x07c02148, 0x078021c9, 0x04001249, 0x07c021c9,
+	0x07800b09, 0x0b82a248, 0x06800008, 0x07c02148, 0x07802189,
+	0x04001249, 0x078026ca, 0x0b824289, 0x07c02189, 0x0680004a,
+	0x0c001ec0, 0x00000000, 0x0c0663c0, 0x00000000, 0x08032100,
+	0x0809ca01, 0x0c7f4440, 0x06802b03, 0x07802189, 0x0be10049,
+	0x04001209, 0x0c780580, 0x07c02188, 0x04401209, 0x07c02188,
+	0x07802148, 0x04001208, 0x07c02148, 0x078021c9, 0x04001249,
+	0x07c021c9, 0x07800b09, 0x0b80b248, 0x06800008, 0x07c02148,
+	0x07802189, 0x04002249, 0x078026ca, 0x0b805289, 0x07c02189,
+	0x06800008, 0x0c7ff800, 0x07c021c8, 0x064c3b08, 0x0920c208,
+	0x0b20ca08, 0x0680204b, 0x07c02a4b, 0x07802148, 0x09508548,
+	0x0780218a, 0x0940854a, 0x07800b0a, 0x0b01494a, 0x06808009,
+	0x0a628725, 0x0c780a40, 0x00000000, 0x0780218b, 0x0a20c04b,
+	0x050012cb, 0x04001208, 0x05401208, 0x0c780a40, 0x0940120b,
+	0x04001208, 0x0a418288, 0x078022ca, 0x07802188, 0x0a27c048,
+	0x0400220a, 0x0c780380, 0x06800008, 0x0aa7c725, 0x0780218b,
+	0x0a2bc04b, 0x040012c8, 0x0a4ed28b, 0x0c780680, 0x06800008,
+	0x0aa14725, 0x06800008, 0x07802188, 0x05001208, 0x04801208,
+	0x0b60c70a, 0x06808009, 0x0680c009, 0x0c780400, 0x00000000,
+	0x0a628048, 0x0400220a, 0x07802188, 0x0be1c048, 0x0400220a,
+	0x0c7ffd80, 0x06800048, 0x0aabc008, 0x078022ca, 0x0400120a,
+	0x0ba10708, 0x0b6ace08, 0x0680c009, 0x0441c208, 0x05403288,
+	0x0200a20a, 0x02009289, 0x0700024a, 0x07c0288a, 0x04001249,
+	0x0700024a, 0x04001249, 0x07000257, 0x096105ca, 0x04001249,
+	0x07000258, 0x04001249, 0x0700024a, 0x0961060a, 0x04001249,
+	0x07000259, 0x04001249, 0x0700024a, 0x0961064a, 0x04001249,
+	0x0700025a, 0x04001249, 0x0700024a, 0x0961068a, 0x06bfda8a,
+	0x0603040a, 0x0cc00000, 0x00400000, 0x078027c8, 0x0a6fc008,
+	0x00000000, 0x064c0008, 0x0a2f0048, 0x064c3d08, 0x0580a208,
+	0x0bef80c8, 0x06a00008, 0x060c3d08, 0x064c3d08, 0x0580a208,
+	0x0bef80c8, 0x00000000, 0x0cc00000, 0x00000000, 0x07800bcc,
+	0x0a60c38c, 0x06800725, 0x05801965, 0x06bfffcc, 0x0680001b,
+	0x07802857, 0x06800018, 0x0680001c, 0x06800019, 0x0680001d,
+	0x0680001a, 0x0680001e, 0x04000817, 0x04000858, 0x04000899,
+	0x040008da, 0x0680800b, 0x0680070f, 0x074002cc, 0x040012cb,
+	0x074002db, 0x040012cb, 0x074002d7, 0x040012cb, 0x074002d8,
+	0x040012cb, 0x074002dc, 0x040012cb, 0x074002d9, 0x040012cb,
+	0x074002dd, 0x040012cb, 0x074002da, 0x040012cb, 0x074002de,
+	0x0d07fbcf, 0x040012cb, 0x07c0288c, 0x07c028cc, 0x0961030c,
+	0x080c0700, 0x060c270c, 0x096105db, 0x060c0217, 0x0961061c,
+	0x0780250f, 0x0aa1800f, 0x060c0218, 0x0961065d, 0x060c0219,
+	0x0961069e, 0x060c021a, 0x080c0701, 0x060c270c, 0x060c0217,
+	0x0aa1000f, 0x060c0218, 0x060c0219, 0x060c021a, 0x07800b0f,
+	0x0b00a94f, 0x06900008, 0x06c00248, 0x0649ce09, 0x02008248,
+	0x06035108, 0x06803f08, 0x06035208, 0x06a08008, 0x06035008,
+	0x07802148, 0x0a60c008, 0x06803fc8, 0x07c022c8, 0x06800008,
+	0x07c02908, 0x0ac0b94f, 0x078022c8, 0x0b613fc8, 0x0ba0c708,
+	0x0441c208, 0x07c022c8, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x0cc00000, 0x00000000, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008, 0x00000000,
+	0x06900008, 0x06c00248, 0x0649ce09, 0x02008248, 0x06035108,
+	0x06803f08, 0x06035208, 0x06b0c008, 0x06035008, 0x05401225,
+	0x0ac0520f, 0x06800088, 0x07c02308, 0x0c7ff840, 0x07c02348,
+	0x06910009, 0x06c00249, 0x0649ce0a, 0x02009289, 0x054012a5,
+	0x0200a94a, 0x0680008b, 0x07c0230b, 0x068000cb, 0x06435008,
+	0x0580f208, 0x0bef8048, 0x06803f08, 0x06035109, 0x06035208,
+	0x06a08008, 0x06035008, 0x0ac0328f, 0x0c7ff340, 0x07c0234b,
+	0x06808008, 0x02009209, 0x0200a94a, 0x0c7ffc80, 0x040012cb,
+	0x0400134d, 0x0480f34d, 0x07c0234d, 0x0980c38c, 0x0780230d,
+	0x054092cd, 0x0690000a, 0x06c0024a, 0x0200b28b, 0x0649ce0a,
+	0x0200b28b, 0x0400134d, 0x0480f34d, 0x07c0230d, 0x0643500d,
+	0x0580f34d, 0x0bef804d, 0x00000000, 0x0643530d, 0x0900c34d,
+	0x0a6f800d, 0x00000000, 0x0603510b, 0x06803f0b, 0x0603520b,
+	0x0c7fec80, 0x0603500c, 0x0780238c, 0x0a60c00c, 0x0440120c,
+	0x06800088, 0x0aa14008, 0x06a01009, 0x0aa0c048, 0x06a22009,
+	0x06a40009, 0x06c00109, 0x060e0509, 0x07c023c8, 0x07802749,
+	0x0680180a, 0x09502289, 0x060c210a, 0x080c260e, 0x0680004a,
+	0x07c0294a, 0x07802149, 0x07c02289, 0x07802989, 0x07c029c9,
+	0x06800089, 0x0cc00000, 0x07c027c9, 0x0cc00000, 0x00400000,
+	0x064e1226, 0x091e19a6, 0x0bef0066, 0x07802827, 0x0649d926,
+	0x0900c9a6, 0x0acfe9e6, 0x078027e6, 0x0aa4c0a6, 0x0c782ac0,
+	0x06800027, 0x06c04027, 0x07802969, 0x097c19e9, 0x060e1227,
+	0x078021a7, 0x06a00016, 0x0a210067, 0x06c00256, 0x06a80016,
+	0x06c00256, 0x0649ce26, 0x02016996, 0x06800026, 0x07c02766,
+	0x0c782400, 0x06800126, 0x07802767, 0x0aa080a7, 0x0c781340,
+	0x078025a8, 0x0aeac0a8, 0x07802969, 0x0aa54725, 0x078022a6,
+	0x054069a6, 0x078021a8, 0x05801a28, 0x06a00027, 0x0be10068,
+	0x06c00267, 0x06a80027, 0x06c00267, 0x0649ce28, 0x02027a27,
+	0x020269e6, 0x044409a6, 0x060e1326, 0x0aa4c029, 0x040c05a6,
+	0x06805c28, 0x060c2128, 0x0c7803c0, 0x04040596, 0x054059a6,
+	0x078021a8, 0x06a00027, 0x0be10068, 0x06c00267, 0x06a80027,
+	0x06c00267, 0x0649ce28, 0x02027a27, 0x020269e6, 0x044209a6,
+	0x060e1326, 0x040605a6, 0x078023e8, 0x0aa14028, 0x06a2c227,
+	0x0aa0c068, 0x06a2c027, 0x06a2c127, 0x0aa10029, 0x06c04027,
+	0x068003e6, 0x095069e6, 0x097c19e9, 0x060e1227, 0x06800026,
+	0x07c02766, 0x06800126, 0x0c781b80, 0x07c027e6, 0x07802427,
+	0x07802828, 0x02427a27, 0x02427a27, 0x07802969, 0x0aa0c029,
+	0x02427a27, 0x02427a27, 0x07802666, 0x078026a8, 0x096109a8,
+	0x054099a6, 0x020269e6, 0x054039e6, 0x060e1327, 0x078023e8,
+	0x0aa34028, 0x06a44227, 0x0aa2c068, 0x06a44027, 0x0c780240,
+	0x06a44127, 0x0a64c0e7, 0x078027a6, 0x064e0c28, 0x09010a28,
+	0x0b8e6a26, 0x0cc00000, 0x00400000, 0x0aa10029, 0x06c0c027,
+	0x068005e6, 0x095069e6, 0x097c19e9, 0x060e1227, 0x06800016,
+	0x06800026, 0x07c02766, 0x06800166, 0x0c781140, 0x07c027e6,
+	0x078025e7, 0x0aa1c027, 0x044019e7, 0x07c025e7, 0x078025a7,
+	0x044019e7, 0x0c780dc0, 0x07c025a7, 0x07802467, 0x07c024a7,
+	0x07802666, 0x078026a8, 0x096109a8, 0x054099a6, 0x020269e6,
+	0x07802828, 0x02027a27, 0x07c02467, 0x054039e6, 0x060e1327,
+	0x078023e8, 0x0aa14028, 0x06a16227, 0x0aa0c068, 0x06a16027,
+	0x06a16127, 0x078029e8, 0x0aa28028, 0x078027a6, 0x064e0c28,
+	0x09010a28, 0x0b804a26, 0x078024a8, 0x0c7fd800, 0x07c02468,
+	0x040019a6, 0x07c027a6, 0x07c024e7, 0x06c00027, 0x060e1227,
+	0x06800066, 0x0c780680, 0x07c027e6, 0x0ba58126, 0x07802967,
+	0x0a608027, 0x0c7ff480, 0x078027a7, 0x040019e7, 0x07c027a7,
+	0x0aa0c126, 0x06800027, 0x080c2170, 0x0c780300, 0x07c02967,
+	0x0a6d0066, 0x078025a7, 0x0aa30027, 0x044019e7, 0x0b228067,
+	0x07c025a7, 0x07802726, 0x0aa0c0e6, 0x00000000, 0x080c2170,
+	0x06800026, 0x07c027e6, 0x0cc00000, 0x00400000, 0x0c7805c0,
+	0x00000000, 0x06a80016, 0x0aa10026, 0x06c00256, 0x06a00016,
+	0x06c00256, 0x0649ce28, 0x0c780b00, 0x02016a16, 0x0aa0c725,
+	0x090a8996, 0x090c7996, 0x07800b28, 0x0b826a26, 0x0a8f3a26,
+	0x091a1996, 0x06a80016, 0x0aa24026, 0x06c00256, 0x06a00016,
+	0x0c780180, 0x06c00256, 0x0aa74016, 0x07802427, 0x0c7ffc40,
+	0x00000000, 0x0649ce28, 0x02016a16, 0x07802666, 0x078026a8,
+	0x096109a8, 0x054099a6, 0x07802828, 0x02427a27, 0x020269e6,
+	0x054039e6, 0x060e1327, 0x078024e6, 0x090049e6, 0x0aa14027,
+	0x06a14226, 0x0aa0c127, 0x06a14026, 0x06a14126, 0x06c08026,
+	0x060e0d16, 0x0aa0c725, 0x04020596, 0x04020596, 0x0c7ff300,
+	0x060e1226, 0x07802666, 0x078026a8, 0x096109a8, 0x054099a6,
+	0x020269e6, 0x07802828, 0x02027a27, 0x07c02427, 0x054039e6,
+	0x060e1327, 0x078024e6, 0x0a618016, 0x09c261e6, 0x060e1226,
+	0x068000e6, 0x0c7feec0, 0x07c027e6, 0x06c08026, 0x060e0d16,
+	0x0aae8725, 0x04020596, 0x0c7ffe00, 0x04020596, 0x064e120a,
+	0x091e128a, 0x0bef804a, 0x064e000a, 0x064e030b, 0x064e0e0c,
+	0x064e0c0d, 0x0680100e, 0x063f000e, 0x083f0000, 0x0680020e,
+	0x0d00000e, 0x00000000, 0x060e000a, 0x060e030b, 0x060e0e0c,
+	0x0cc00000, 0x060e0c0d, 0x0c000b00, 0x00000000, 0x0681010a,
+	0x06c3474a, 0x0609070a, 0x06490b0a, 0x0980a00a, 0x0980a0ca,
+	0x06090b0a, 0x09c0a00a, 0x09c0a0ca, 0x06090b0a, 0x06a0000a,
+	0x06c0024a, 0x0649ce0b, 0x0200a2ca, 0x0609440a, 0x06a8000a,
+	0x06c0024a, 0x0649ce0b, 0x0200a2ca, 0x0609450a, 0x0cc00000,
+	0x00000000, 0x0c0008c0, 0x00000000, 0x08095007, 0x08095000,
+	0x06800049, 0x07800b0b, 0x068002ca, 0x0b00328b, 0x00000000,
+	0x06800009, 0x06498e0b, 0x097c12c9, 0x06098e0b, 0x06497f09,
+	0x068000cb, 0x0970224b, 0x06097f09, 0x06820889, 0x0cc00000,
+	0x06095109, 0x0683ffc9, 0x0649090a, 0x0a21004a, 0x0aa0c009,
+	0x0c7fff40, 0x04401249, 0x06490b0a, 0x0980a00a, 0x0980a0ca,
+	0x06090b0a, 0x09c0a00a, 0x09c0a0ca, 0x06090b0a, 0x0cc00000,
+	0x00000000, 0x0683ffca, 0x06495309, 0x0a210049, 0x0aa0c00a,
+	0x0c7fff40, 0x0440128a, 0x0cc00000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x06bff7c0,
+	0x06032400, 0x00400000, 0x0c780000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0c780200, 0x06431e07, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x09027207, 0x0a668048,
+	0x068fdfca, 0x06fcffca, 0x064e0408, 0x02808288, 0x09110287,
+	0x064c0909, 0x0ac0924a, 0x0b80324a, 0x0c7801c0, 0x09808688,
+	0x0400128a, 0x098083c8, 0x0a40324a, 0x0440128a, 0x098086c8,
+	0x0aa1000a, 0x09308287, 0x0a60c00a, 0x0400128a, 0x09808388,
+	0x0b80324a, 0x00000000, 0x098081c8, 0x0c780080, 0x060e0408,
+	0x08031e00, 0x0cc00000, 0x00400000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264mvc/vh264mvc_mc.c b/drivers/amlogic/amports/arch/ucode/h264mvc/vh264mvc_mc.c
index 98aeeca..acdf089 100644
--- a/drivers/amlogic/amports/arch/ucode/h264mvc/vh264mvc_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/h264mvc/vh264mvc_mc.c
@@ -21,25 +21,49 @@
 #include "h264c_mvc_linux.h"
 
 #undef MicroCode
+#define MicroCode gxm_vh264mvc_mc
+#include "gxm_h264c_mvc_linux.h"
+
+#undef MicroCode
 #define MicroCode vh264mvc_header_mc
 #include "h264header_mvc_linux.h"
 
 #undef MicroCode
+#define MicroCode gxm_vh264mvc_header_mc
+#include "gxm_h264header_mvc_linux.h"
+
+#undef MicroCode
 #define MicroCode vh264mvc_mmco_mc
 #include "h264mmc_mvc_linux.h"
 
 #undef MicroCode
+#define MicroCode gxm_vh264mvc_mmco_mc
+#include "gxm_h264mmc_mvc_linux.h"
+
+#undef MicroCode
 #define MicroCode vh264mvc_slice_mc
 #include "h264slice_mvc_linux.h"
 
+#undef MicroCode
+#define MicroCode gxm_vh264mvc_slice_mc
+#include "gxm_h264slice_mvc_linux.h"
+
 #define FOR_VFORMAT VFORMAT_H264MVC
 
+#define DEF_FIRMEARE_FOR_GXM(n) \
+		REGISTER_FIRMARE_PER_CPU(MESON_CPU_MAJOR_ID_GXM,\
+		FOR_VFORMAT, n)
+
 #define REG_FIRMWARE_ALL()\
 	do {\
 		DEF_FIRMWARE(vh264mvc_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264mvc_mc);\
 		DEF_FIRMWARE(vh264mvc_header_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264mvc_header_mc);\
 		DEF_FIRMWARE(vh264mvc_mmco_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264mvc_mmco_mc);\
 		DEF_FIRMWARE(vh264mvc_slice_mc);\
+		DEF_FIRMEARE_FOR_GXM(gxm_vh264mvc_slice_mc);\
 	} while (0)
 
 INIT_DEF_FIRMWARE();
diff --git a/drivers/amlogic/amports/arch/ucode/mpeg4/vmpeg4_mc.c b/drivers/amlogic/amports/arch/ucode/mpeg4/vmpeg4_mc.c
index cd4e1b2..9536c0c 100644
--- a/drivers/amlogic/amports/arch/ucode/mpeg4/vmpeg4_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/mpeg4/vmpeg4_mc.c
@@ -20,80 +20,86 @@
 #define VERSTR "00000"
 
 const u32 vmpeg4_mc_4[] __initconst = {
-	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c014380, 0x00000000,
-	0x00000000, 0x00000000, 0x080c0002, 0x080c2901, 0x06bfde80,
-	0x07c017c0, 0x06030400, 0x00400000, 0x0c019a00, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
+	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014d40,
+	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x080c2901,
+	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a400,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0c7ffe80, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x0c780400, 0x04001965, 0x0cc00000, 0x00400000,
-	0x0c7804c0, 0x064c0007, 0x0c79a100, 0x06800025, 0x0cc00000,
-	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
-	0x0c79ee00, 0x06800025, 0x0cc00000, 0x00400000, 0x06800025,
-	0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409, 0x078001c9,
-	0x0aa0c009, 0x0c78ff80, 0x00000000, 0x06bfdd89, 0x06030409,
-	0x00400000, 0x07801509, 0x0aa2c109, 0x07c0151f, 0x0a2c4047,
-	0x06800025, 0x0aa14009, 0x0a608049, 0x0c790940, 0x0a608089,
-	0x0c78fc00, 0x0a240807, 0x0c788a40, 0x00000000, 0x0683ffc8,
-	0x0ba20048, 0x064c0007, 0x0a2f8047, 0x04401208, 0x064c3a07,
-	0x090061c7, 0x0aae8647, 0x00000000, 0x06800007, 0x0c017100,
-	0x07c003c7, 0x0c792b00, 0x0bec9007, 0x078003c7, 0x0a6fc007,
-	0x07800007, 0x07800988, 0x0b822207, 0x06800007, 0x07c00007,
-	0x0a628060, 0x06a00008, 0x06e00008, 0x06431e09, 0x0befc049,
-	0x00000000, 0x080c24a0, 0x060c2208, 0x0c780300, 0x060c2208,
-	0x0a6280a0, 0x00000000, 0x06431e09, 0x0befc049, 0x00000000,
-	0x080c24c0, 0x080c2200, 0x080c2200, 0x080c2200, 0x080c2200,
-	0x078016c8, 0x04001208, 0x078009c9, 0x0b80a248, 0x07c016c8,
-	0x0c020500, 0x00000000, 0x078003c7, 0x0a6fc007, 0x0c792180,
-	0x00000000, 0x06431e09, 0x0befc049, 0x07800347, 0x0a61c007,
-	0x00000000, 0x064c2907, 0x091c21c7, 0x0a60c0c7, 0x0c021000,
-	0x00000000, 0x0aa080a0, 0x0c780f40, 0x078003c7, 0x0a6fc007,
-	0x07801bc8, 0x0a63c008, 0x078004c8, 0x0a634348, 0x06800107,
-	0x07c003c7, 0x08030580, 0x068003c9, 0x07c00149, 0x06800007,
-	0x0c018d80, 0x07c01d07, 0x07800007, 0x040011c7, 0x0c7fef80,
-	0x07c00007, 0x0c792d80, 0x078003c7, 0x0a6fc007, 0x078005c7,
-	0x0ba0c087, 0x06800007, 0x06800047, 0x07c01fc7, 0x07800787,
-	0x0aa180c7, 0x06810007, 0x060e0907, 0x060e0a07, 0x0c780440,
-	0x060e0b07, 0x07800507, 0x0aa0c007, 0x068000c8, 0x068003c8,
-	0x060e1408, 0x064e1507, 0x060e0907, 0x04003208, 0x060e1408,
-	0x064e1507, 0x060e0a07, 0x04003208, 0x060e1408, 0x064e1507,
-	0x060e0b07, 0x0683ffc7, 0x080e1418, 0x060e1507, 0x080e141b,
-	0x060e1507, 0x080e141e, 0x060e1507, 0x080e1421, 0x0c01f280,
-	0x060e1507, 0x0c785580, 0x00000000, 0x0aa6c020, 0x00000000,
-	0x0fc011c0, 0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147,
-	0x06431e07, 0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224,
-	0x060c2224, 0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07,
-	0x091011c7, 0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7,
-	0x0aae8007, 0x0c7ff000, 0x080c2800, 0x0c7fda80, 0x00000000,
-	0x080c2801, 0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008,
-	0x0c7fd8c0, 0x058011c7, 0x09004207, 0x07c00148, 0x090821c7,
-	0x07c00187, 0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781900,
-	0x00000000, 0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802,
-	0x064c2807, 0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207,
-	0x07c01388, 0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0,
-	0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089, 0x04401249,
-	0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809, 0x04401249,
-	0x068007c9, 0x07c00109, 0x0c012f80, 0x040001c9, 0x07801fcb,
-	0x0aa1400b, 0x078005c9, 0x0b60c089, 0x0c004880, 0x00000000,
-	0x068fdfca, 0x06feffca, 0x064e0408, 0x02808288, 0x078005ca,
-	0x0ba0c08a, 0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a,
-	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
-	0x098081c8, 0x07802007, 0x09605207, 0x07800007, 0x040811c7,
+	0x00000000, 0x00000000, 0x0c780400, 0x04001965, 0x0cc00000,
+	0x00400000, 0x0c7804c0, 0x064c0007, 0x0c79ab00, 0x06800025,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c79f800, 0x06800025, 0x0cc00000, 0x00400000,
+	0x06800025, 0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409,
+	0x078001c9, 0x0aa0c009, 0x0c790940, 0x00000000, 0x06bfdd89,
+	0x06030409, 0x00400000, 0x07801509, 0x0aa2c109, 0x07c0151f,
+	0x0a2c4047, 0x06800025, 0x0aa14009, 0x0a608049, 0x0c791300,
+	0x0a608089, 0x0c7905c0, 0x0a240807, 0x0c789400, 0x00000000,
+	0x0683ffc8, 0x0ba20048, 0x064c0007, 0x0a2f8047, 0x04401208,
+	0x064c3a07, 0x090061c7, 0x0aae8647, 0x00000000, 0x06800007,
+	0x0c017b00, 0x07c003c7, 0x0c7934c0, 0x0bec9007, 0x078003c7,
+	0x0a6fc007, 0x07800007, 0x07800988, 0x0b822207, 0x06800007,
+	0x07c00007, 0x0a628060, 0x06a00008, 0x06e00008, 0x06431e09,
+	0x0befc049, 0x00000000, 0x080c24a0, 0x060c2208, 0x0c780300,
+	0x060c2208, 0x0a6280a0, 0x00000000, 0x06431e09, 0x0befc049,
+	0x00000000, 0x080c24c0, 0x080c2200, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x078016c8, 0x04001208, 0x078009c9, 0x0b80a248,
+	0x07c016c8, 0x0c020f00, 0x00000000, 0x078003c7, 0x0a6fc007,
+	0x0c792b40, 0x00000000, 0x06431e09, 0x0befc049, 0x07800347,
+	0x0aa0c007, 0x0c780880, 0x00000000, 0x064c1d07, 0x09227207,
+	0x0a678008, 0x064c2a08, 0x064c3607, 0x091081c7, 0x095101c8,
+	0x064c3b08, 0x09103248, 0x04001209, 0x03807207, 0x0900f207,
+	0x0a650008, 0x0580f1c7, 0x06800048, 0x05407208, 0x03808248,
+	0x04401208, 0x0a40e207, 0x064c1d07, 0x0a60c009, 0x00000000,
+	0x054081c7, 0x06800009, 0x09201207, 0x0a610008, 0x054011c7,
+	0x0c7fff40, 0x04001249, 0x060c0e09, 0x0c021300, 0x00000000,
+	0x0aa080a0, 0x0c780f40, 0x078003c7, 0x0a6fc007, 0x07801bc8,
+	0x0a63c008, 0x078004c8, 0x0a634348, 0x06800107, 0x07c003c7,
+	0x08030580, 0x068003c9, 0x07c00149, 0x06800007, 0x0c019080,
+	0x07c01d07, 0x07800007, 0x040011c7, 0x0c7fe880, 0x07c00007,
+	0x0c793040, 0x078003c7, 0x0a6fc007, 0x078005c7, 0x0ba0c087,
+	0x06800007, 0x06800047, 0x07c01fc7, 0x07800787, 0x0aa180c7,
+	0x06810007, 0x060e0907, 0x060e0a07, 0x0c780440, 0x060e0b07,
+	0x07800507, 0x0aa0c007, 0x068000c8, 0x068003c8, 0x060e1408,
+	0x064e1507, 0x060e0907, 0x04003208, 0x060e1408, 0x064e1507,
+	0x060e0a07, 0x04003208, 0x060e1408, 0x064e1507, 0x060e0b07,
+	0x0683ffc7, 0x080e1418, 0x060e1507, 0x080e141b, 0x060e1507,
+	0x080e141e, 0x060e1507, 0x080e1421, 0x0c01f580, 0x060e1507,
+	0x0c7855c0, 0x00000000, 0x0aa6c020, 0x00000000, 0x0fc011c0,
+	0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147, 0x06431e07,
+	0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224, 0x060c2224,
+	0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07, 0x091011c7,
+	0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7, 0x0aae8007,
+	0x0c7ff000, 0x080c2800, 0x0c7fd380, 0x00000000, 0x080c2801,
+	0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008, 0x0c7fd1c0,
+	0x058011c7, 0x09004207, 0x07c00148, 0x090821c7, 0x07c00187,
+	0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940, 0x00000000,
+	0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802, 0x064c2807,
+	0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207, 0x07c01388,
+	0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0, 0x0b61c087,
+	0x07800109, 0x024091c9, 0x0b620089, 0x04401249, 0x0c780180,
+	0x06800049, 0x020091c9, 0x0b20c809, 0x04401249, 0x068007c9,
+	0x07c00109, 0x0c013240, 0x040001c9, 0x07801fcb, 0x0aa1400b,
+	0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000, 0x068fdfca,
+	0x06feffca, 0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a,
+	0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a,
+	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
+	0x07808007, 0x09605207, 0x07800007, 0x06808049, 0x02007247,
 	0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248, 0x07c01fc9,
 	0x07801388, 0x060c2b08, 0x06880008, 0x098083c8, 0x07800507,
 	0x07801989, 0x0a610049, 0x09581207, 0x09808408, 0x098083c8,
 	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
 	0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0, 0x07c01cc7,
-	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01d240, 0x00000000,
-	0x080c0080, 0x0c015a00, 0x00000000, 0x080c24a0, 0x080c2200,
+	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01d500, 0x00000000,
+	0x080c0080, 0x0c015cc0, 0x00000000, 0x080c24a0, 0x080c2200,
 	0x080c2200, 0x07800007, 0x040011c7, 0x07c00007, 0x07800147,
-	0x0c012fc0, 0x07c00447, 0x0c7fb800, 0x00000000, 0x0a60c0e0,
+	0x0c013240, 0x07c00447, 0x0c7fb0c0, 0x00000000, 0x0a60c0e0,
 	0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802, 0x064c2807,
 	0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8, 0x07800188,
 	0x09444207, 0x07c01388, 0x07800148, 0x0a644048, 0x080c2800,
 	0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089,
 	0x04401249, 0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809,
-	0x04401249, 0x068007c9, 0x07c00109, 0x0c011640, 0x040001c9,
+	0x04401249, 0x068007c9, 0x07c00109, 0x0c0118c0, 0x040001c9,
 	0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007, 0x0c7806c0,
 	0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0, 0x07c01cc7,
 	0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148, 0x07800489,
@@ -118,22 +124,24 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147, 0x078004c7,
 	0x07c00387, 0x07800487, 0x07c00247, 0x07801107, 0x07c01787,
 	0x06800107, 0x07c003c7, 0x08030580, 0x064c2407, 0x0befc3c7,
-	0x00000000, 0x07800147, 0x0aa10147, 0x0c0137c0, 0x00000000,
-	0x0c7800c0, 0x0c015e00, 0x00000000, 0x07800007, 0x040011c7,
-	0x0c7f8f40, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
+	0x00000000, 0x07800147, 0x0aa10147, 0x0c013a80, 0x00000000,
+	0x0c7800c0, 0x0c0160c0, 0x00000000, 0x07800007, 0x040011c7,
+	0x0c7f8800, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
 	0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca, 0x06feffca,
 	0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a, 0x064c0909,
 	0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a, 0x0400128a,
 	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x060e0408,
-	0x091e1248, 0x07c01fc9, 0x0c019f40, 0x00000000, 0x064c2407,
+	0x091e1248, 0x07c01fc9, 0x0c01a200, 0x00000000, 0x064c2407,
 	0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000, 0x080c2130,
-	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c012c80, 0x00000000,
+	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c012f40, 0x00000000,
 	0x07800007, 0x040011c7, 0x07c00007, 0x07801d08, 0x07801d47,
 	0x09421207, 0x07801d87, 0x09441207, 0x07c00308, 0x07800148,
-	0x0aa0c348, 0x07c00448, 0x0c7f8240, 0x078003c7, 0x0a6fc007,
+	0x0aa0c348, 0x07c00448, 0x0c7f7b00, 0x078003c7, 0x0a6fc007,
 	0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0,
-	0x060c2207, 0x0c7f89c0, 0x060c2208, 0x0780044b, 0x0aa1034b,
-	0x064e160b, 0x090102cb, 0x0aaf800b, 0x0681000b, 0x060e090b,
+	0x060c2207, 0x0c7f8280, 0x060c2208, 0x0780044b, 0x0aa3834b,
+	0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009, 0x00000000,
+	0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140, 0x00000000,
+	0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b, 0x060e090b,
 	0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009, 0x064e0e0b,
 	0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d,
 	0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
@@ -156,7 +164,7 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x0a6103c7, 0x07c01887, 0x0fc101c0, 0x0609c507, 0x0fc011c0,
 	0x0aa30007, 0x00000000, 0x0fc021c0, 0x07c018c7, 0x0fc021c0,
 	0x0a21c047, 0x00000000, 0x0fc101c0, 0x0fc101c0, 0x0fc101c0,
-	0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007, 0x0c7f6780,
+	0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007, 0x0c7f5dc0,
 	0x00000000, 0x0fc011c0, 0x0fc101c0, 0x07c01907, 0x0649c308,
 	0x09410207, 0x0609c308, 0x0b220087, 0x06800048, 0x06800008,
 	0x06800049, 0x0b004247, 0x05401249, 0x0c7fff80, 0x04001208,
@@ -184,7 +192,7 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x040011c7, 0x058011c7, 0x0d000007, 0x060e030a, 0x04c08208,
 	0x060e0008, 0x07801807, 0x0aa18047, 0x00000000, 0x0fc011c0,
 	0x0540b1c7, 0x09807007, 0x060c0107, 0x0fc011c0, 0x0aa60007,
-	0x0fc011c0, 0x07c00347, 0x0aa0c047, 0x0c016080, 0x00000000,
+	0x0fc011c0, 0x07c00347, 0x0aa0c047, 0x0c0160c0, 0x00000000,
 	0x0fc011c0, 0x0a20c047, 0x00000000, 0x0fc011c0, 0x07801807,
 	0x06800008, 0x0aa18047, 0x06800007, 0x0fc011c0, 0x0a624007,
 	0x0fc01200, 0x0a61c008, 0x07c01a07, 0x07c01a48, 0x0fc011c0,
@@ -212,7 +220,7 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x0c780540, 0x07c010c7, 0x07801008, 0x04001208, 0x0ae44048,
 	0x07c01008, 0x078010c9, 0x02007247, 0x0b21c007, 0x0b406247,
 	0x0b406247, 0x00000000, 0x024091c9, 0x0c7fff40, 0x04080208,
-	0x0c7f2280, 0x058011c7, 0x0b403247, 0x00000000, 0x04080208,
+	0x0c7f18c0, 0x058011c7, 0x0b403247, 0x00000000, 0x04080208,
 	0x07c01008, 0x090071c8, 0x090e7208, 0x09545207, 0x060e0708,
 	0x07800047, 0x0b624087, 0x0aa180a0, 0x0aa08020, 0x0aa10007,
 	0x040011c7, 0x0c780100, 0x07c00047, 0x0c784c00, 0x00000000,
@@ -222,21 +230,21 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x07c01b07, 0x0fc031c0, 0x07c000c7, 0x07801c07, 0x0aa20007,
 	0x00000000, 0x0fc011c0, 0x07c01c47, 0x0fc011c0, 0x07c01c87,
 	0x054021c7, 0x060c0307, 0x0a6740e0, 0x07801e47, 0x0aa6c007,
-	0x09066207, 0x0aa08088, 0x0c7fae00, 0x0c00a740, 0x06801ec8,
-	0x07901ee3, 0x06801409, 0x09510263, 0x060c2109, 0x0c00a5c0,
+	0x09066207, 0x0aa08088, 0x0c7fae00, 0x0c00a780, 0x06801ec8,
+	0x07901ee3, 0x06801409, 0x09510263, 0x060c2109, 0x0c00a600,
 	0x06801f08, 0x07901f08, 0x06801809, 0x09510248, 0x060c2109,
-	0x096108c8, 0x0c00a400, 0x06801f48, 0x0c00a380, 0x06801f88,
+	0x096108c8, 0x0c00a440, 0x06801f48, 0x0c00a3c0, 0x06801f88,
 	0x05401923, 0x09c24424, 0x0942f923, 0x0a20c047, 0x0c7fa880,
 	0x00000000, 0x0fc051c0, 0x0c006f00, 0x07c00107, 0x0c006c40,
 	0x00000000, 0x0a6180a0, 0x078003c7, 0x0a6fc007, 0x06800107,
 	0x07c003c7, 0x08030580, 0x0aa28020, 0x06800048, 0x0a6100a0,
 	0x0fc03200, 0x0fc03240, 0x07c01b89, 0x07c01b48, 0x09503248,
 	0x09809149, 0x060c2109, 0x060c0e08, 0x06800025, 0x06490908,
-	0x0ae10225, 0x00000000, 0x0bef4048, 0x0c780080, 0x0c7f0840,
+	0x0ae10225, 0x00000000, 0x0bef4048, 0x0c780080, 0x0c7efe80,
 	0x0683ffc7, 0x0649bb08, 0x0900c208, 0x0aa10008, 0x0aa0c007,
 	0x0c7fff00, 0x044011c7, 0x06490b07, 0x09807007, 0x06090b07,
 	0x06090b07, 0x09c07007, 0x06090b07, 0x0649c909, 0x0aa10009,
-	0x06800087, 0x0c7efe00, 0x07c01507, 0x07801487, 0x0a608007,
+	0x06800087, 0x0c7ef440, 0x07c01507, 0x07801487, 0x0a608007,
 	0x0c780b00, 0x044011c7, 0x0aa0c087, 0x07801549, 0x078015c9,
 	0x0b20c1c9, 0x00000000, 0x0c780940, 0x07800fc8, 0x0609ca08,
 	0x07c00fdf, 0x0680420a, 0x02007289, 0x070001c7, 0x054101c7,
@@ -255,7 +263,7 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x078048ca, 0x07804908, 0x09610288, 0x0a240807, 0x06800148,
 	0x0780494a, 0x07804988, 0x09610288, 0x0a22d007, 0x06800188,
 	0x078049ca, 0x07804a08, 0x09610288, 0x0a21a007, 0x068001c8,
-	0x0809cd11, 0x06800047, 0x0c7ee600, 0x07c01507, 0x0809cd00,
+	0x0809cd11, 0x06800047, 0x0c7edc40, 0x07c01507, 0x0809cd00,
 	0x07801607, 0x090041c7, 0x0a8051c8, 0x0a6200a0, 0x07801607,
 	0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207, 0x0c7ff180,
 	0x02c091c9, 0x07800b47, 0x0680400f, 0x020093c8, 0x07400247,
@@ -276,16 +284,16 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x05810208, 0x0c7800c0, 0x00000000, 0x058103cf, 0x02c083c8,
 	0x06098108, 0x06499108, 0x05410208, 0x058103c8, 0x02c083c8,
 	0x06098208, 0x080980f4, 0x07801b07, 0x06800048, 0x09421207,
-	0x0c7ee000, 0x06090708, 0x06800025, 0x0ae20225, 0x064c0007,
+	0x0c7ed640, 0x06090708, 0x06800025, 0x0ae20225, 0x064c0007,
 	0x0a2f8047, 0x00000000, 0x064c3a07, 0x090061c7, 0x0aae8647,
-	0x0c7800c0, 0x0c7ecf80, 0x00000000, 0x080c2800, 0x080c0002,
-	0x0c7ec880, 0x00000000, 0x0649c007, 0x07c04647, 0x058101c7,
+	0x0c7800c0, 0x0c7ec5c0, 0x00000000, 0x080c2800, 0x080c0002,
+	0x0c7ebec0, 0x00000000, 0x0649c007, 0x07c04647, 0x058101c7,
 	0x07c04687, 0x0649c107, 0x07c046c7, 0x058101c7, 0x07c04707,
 	0x0649c207, 0x07c04747, 0x058101c7, 0x07c04787, 0x0649c307,
 	0x07c047c7, 0x058101c7, 0x07c04807, 0x0649d007, 0x07c04847,
 	0x058101c7, 0x07c04887, 0x0649d107, 0x07c048c7, 0x058101c7,
 	0x07c04907, 0x0649d207, 0x07c04947, 0x058101c7, 0x07c04987,
-	0x0649d307, 0x07c049c7, 0x058101c7, 0x07c04a07, 0x0c004240,
+	0x0649d307, 0x07c049c7, 0x058101c7, 0x07c04a07, 0x0c004280,
 	0x06800025, 0x08002501, 0x08002605, 0x08002708, 0x08002815,
 	0x08002c14, 0x08002a09, 0x08002b17, 0x06830002, 0x06032602,
 	0x08032261, 0x08032101, 0x0cc00000, 0x00000000, 0x080c2804,
@@ -302,9 +310,9 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x080c2141, 0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207,
 	0x064e1507, 0x060c2207, 0x080c2147, 0x064c2407, 0x0befc3c7,
 	0x078004c7, 0x07c00387, 0x07800487, 0x07c00247, 0x07801107,
-	0x07c01787, 0x06800107, 0x07c003c7, 0x0c0078c0, 0x00000000,
+	0x07c01787, 0x06800107, 0x07c003c7, 0x0c007900, 0x00000000,
 	0x08030580, 0x07800007, 0x040011c7, 0x07c00007, 0x06431e07,
-	0x0befc047, 0x0c7eb2c0, 0x00000000, 0x0fc01200, 0x0fc011c0,
+	0x0befc047, 0x0c7ea900, 0x00000000, 0x0fc01200, 0x0fc011c0,
 	0x0aa28047, 0x06800147, 0x0fc011c0, 0x0aa1c047, 0x06800187,
 	0x0fc011c0, 0x0aa10047, 0x068001c7, 0x0fc011c0, 0x06800207,
 	0x07c00147, 0x0a60c008, 0x06800007, 0x0fc061c0, 0x07c01387,
@@ -312,7 +320,7 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x0fc011c0, 0x0aa38007, 0x07800108, 0x0fc011c0, 0x0aa14007,
 	0x0b21c748, 0x04002208, 0x0c780140, 0x068007c8, 0x0b60c0c8,
 	0x04402208, 0x06800048, 0x07c00108, 0x0c0005c0, 0x040001c8,
-	0x0c7eef80, 0x00000000, 0x06a00007, 0x06e00007, 0x080c24a0,
+	0x0c7eed00, 0x00000000, 0x06a00007, 0x06e00007, 0x080c24a0,
 	0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207,
 	0x0cc00000, 0x060c2207, 0x07801988, 0x094c11c8, 0x0c07fd00,
 	0x060e0407, 0x06800007, 0x07c01cc7, 0x07c00907, 0x0cc00000,
@@ -331,165 +339,156 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x06800087, 0x05c0438e, 0x0540138e, 0x0200e1ce, 0x0ae1000f,
 	0x06bfffcd, 0x0300e34e, 0x0400138e, 0x0cc00000, 0x040003ce,
 	0x07800007, 0x0ae10007, 0x07800109, 0x07800988, 0x02007207,
-	0x044011c7, 0x040811c7, 0x074001c9, 0x0cc00000, 0x07c02009,
-	0x0681f409, 0x04401249, 0x0aefc009, 0x00000000, 0x083f0040,
-	0x083f0000, 0x08090b65, 0x00000000, 0x08090b60, 0x06498e07,
-	0x09807007, 0x068007c9, 0x097051c9, 0x06098e07, 0x0681f409,
-	0x04601249, 0x0c4fffc0, 0x00000000, 0x06800009, 0x097051c9,
-	0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187, 0x09807207,
-	0x060c0007, 0x064c0807, 0x09807347, 0x060c0807, 0x083f0040,
-	0x083f0000, 0x08090b65, 0x0cc00000, 0x08090b60, 0x0680001f,
-	0x07c0149f, 0x07c014df, 0x07c0151f, 0x064c091f, 0x07c0175f,
-	0x07c0005f, 0x06800020, 0x06803fc2, 0x07c01542, 0x07c01582,
-	0x07c015c2, 0x07c01602, 0x060c091f, 0x080c0101, 0x080c2901,
-	0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226, 0x024269e6,
-	0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726, 0x0649cf31,
-	0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207, 0x092101c7,
-	0x0401f287, 0x0580528a, 0x0403e247, 0x05806249, 0x09610289,
-	0x04000287, 0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7,
-	0x058041c7, 0x060c0907, 0x07c00987, 0x04401247, 0x07c00609,
-	0x0961020a, 0x06090808, 0x06c00008, 0x0649c707, 0x094101c8,
-	0x0609c707, 0x0400f208, 0x05804208, 0x07c009c8, 0x0809c300,
-	0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803, 0x0aa14003,
-	0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800, 0x07801502,
-	0x0aa0c002, 0x06800102, 0x06030502, 0x064c0002, 0x0be14042,
-	0x0ba1d025, 0x06800102, 0x07c01502, 0x08030504, 0x06800025,
-	0x0cc00000, 0x00000000, 0x078001c2, 0x0aa1c002, 0x078016c2,
-	0x078009c3, 0x0a4040c2, 0x00000000, 0x06800102, 0x06030502,
-	0x0cc00000, 0x00000000, 0x0fc02240, 0x0aa4c009, 0x0680000a,
-	0x0b6180c9, 0x0680010a, 0x0fc01280, 0x09422289, 0x0c780140,
-	0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a, 0x06800049,
-	0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a, 0x05401249,
-	0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000, 0x0fc01240,
-	0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e60c0, 0x00000000,
-	0x06490628, 0x0aefcc28, 0x00000000, 0x07800028, 0x078016e9,
-	0x09508a68, 0x068000a8, 0x06c00028, 0x06090628, 0x06090629,
-	0x06881068, 0x06090628, 0x0cc00000, 0x00000000, 0x06490628,
-	0x0aefcc28, 0x06c00028, 0x069001a8, 0x069fffea, 0x06090628,
-	0x06090629, 0x05401a23, 0x06090628, 0x09210a23, 0x05401a28,
-	0x02828aa8, 0x06090628, 0x06985168, 0x0c782700, 0x06090628,
-	0x078003e8, 0x0a6fc028, 0x07800028, 0x078016e9, 0x06800030,
-	0x09508a68, 0x0780016b, 0x07801d2a, 0x04601aaa, 0x0c500ec0,
-	0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b, 0x0aa883eb,
-	0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb, 0x06c0002a,
-	0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb, 0x0c500980,
-	0x0690002a, 0x0c7e5900, 0x00000000, 0x06490628, 0x0aefcc28,
-	0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629,
-	0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400, 0x080e1424,
-	0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x09210a68, 0x06090628, 0x02828ae9, 0x06090628, 0x06a00028,
-	0x0a007a2a, 0x080c2440, 0x064c2228, 0x09210a68, 0x06090628,
-	0x02828ae9, 0x06090628, 0x0688d068, 0x02c28aa8, 0x09441a30,
-	0x0c781780, 0x06090628, 0x09441ab0, 0x06031f2a, 0x0680016b,
-	0x09510ae9, 0x0c781600, 0x06031e2b, 0x0aa241eb, 0x06a0002a,
-	0x0aa1c1ab, 0x06b0002a, 0x0aa1416b, 0x0aa1026b, 0x06800070,
-	0x0690002a, 0x06800030, 0x06490628, 0x0aefcc28, 0x06c0002a,
-	0x068408a8, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629,
-	0x069fffec, 0x06900028, 0x0a00ba2a, 0x080c2400, 0x064c222e,
-	0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28, 0x09828428,
-	0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028, 0x0a00ba2a,
-	0x080c2440, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
-	0x02828b28, 0x09828428, 0x07801ded, 0x095e1a2d, 0x06090628,
-	0x068c5828, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06860828,
-	0x02c28aa8, 0x09441a30, 0x06090628, 0x06900028, 0x0a00ba2a,
-	0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068,
-	0x02828b28, 0x09828428, 0x07801dad, 0x095e1a2d, 0x06090628,
-	0x06a00028, 0x0a00ba2a, 0x080c2450, 0x064c2228, 0x06090628,
-	0x09210a28, 0x09c28068, 0x02828b28, 0x09828428, 0x07801e2d,
-	0x095e1a2d, 0x06090628, 0x068ed868, 0x02c28aa8, 0x09441a30,
-	0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228, 0x060e152e,
-	0x060e152f, 0x060e1528, 0x0c780080, 0x060e1528, 0x0cc00000,
-	0x00000000, 0x07800028, 0x078016e9, 0x06800030, 0x09508a68,
-	0x0780016b, 0x0780026a, 0x04601aaa, 0x0c500c00, 0x0aa1416b,
-	0x00000000, 0x06800070, 0x0a61826b, 0x00000000, 0x078003a8,
-	0x04602a28, 0x0c500840, 0x0c7800c0, 0x0c780000, 0x00000000,
-	0x06490628, 0x0aefcc28, 0x06b000a8, 0x09441a30, 0x06090628,
-	0x06090629, 0x069fffeb, 0x06900028, 0x080c2400, 0x080e1424,
-	0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x09210a68, 0x06090628, 0x02828ae9, 0x06090628, 0x080c2440,
-	0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
-	0x06b8d068, 0x09441a30, 0x0c781340, 0x06090628, 0x06b0002a,
-	0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9, 0x0c781180,
-	0x06031e2b, 0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0c7ff5c0,
-	0x00000000, 0x06490628, 0x0aefcc28, 0x06b408a8, 0x09441a30,
-	0x06090628, 0x06090629, 0x069fffec, 0x06900028, 0x080c2400,
+	0x044011c7, 0x06808048, 0x02007207, 0x074001c9, 0x0cc00000,
+	0x07c08009, 0x0681f409, 0x04401249, 0x0aefc009, 0x00000000,
+	0x083f0040, 0x083f0000, 0x08090b65, 0x00000000, 0x08090b60,
+	0x06498e07, 0x09807007, 0x068007c9, 0x097051c9, 0x06098e07,
+	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x06800009,
+	0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187,
+	0x09807207, 0x060c0007, 0x064c0807, 0x09807347, 0x060c0807,
+	0x083f0040, 0x083f0000, 0x08090b65, 0x0cc00000, 0x08090b60,
+	0x0680001f, 0x07c0149f, 0x07c014df, 0x07c0151f, 0x064c091f,
+	0x07c0175f, 0x07c0005f, 0x06800020, 0x06803fc2, 0x07c01542,
+	0x07c01582, 0x07c015c2, 0x07c01602, 0x060c091f, 0x080c0101,
+	0x080c2901, 0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226,
+	0x024269e6, 0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726,
+	0x0649cf31, 0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207,
+	0x092101c7, 0x0401f287, 0x0580528a, 0x0403e247, 0x05806249,
+	0x09610289, 0x04000287, 0x0649c709, 0x09610247, 0x0609c709,
+	0x0400f1c7, 0x058041c7, 0x060c0907, 0x07c00987, 0x04401247,
+	0x07c00609, 0x0961020a, 0x06090808, 0x06c00008, 0x0649c707,
+	0x094101c8, 0x0609c707, 0x0400f208, 0x05804208, 0x07c009c8,
+	0x0809c300, 0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803,
+	0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800,
+	0x07801502, 0x0aa0c002, 0x06800102, 0x06030502, 0x064c0002,
+	0x0be14042, 0x0ba1d025, 0x06800102, 0x07c01502, 0x08030504,
+	0x06800025, 0x0cc00000, 0x00000000, 0x078001c2, 0x0aa1c002,
+	0x078016c2, 0x078009c3, 0x0a4040c2, 0x00000000, 0x06800102,
+	0x06030502, 0x0cc00000, 0x00000000, 0x0fc02240, 0x0aa4c009,
+	0x0680000a, 0x0b6180c9, 0x0680010a, 0x0fc01280, 0x09422289,
+	0x0c780140, 0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a,
+	0x06800049, 0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a,
+	0x05401249, 0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000,
+	0x0fc01240, 0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e56c0,
+	0x00000000, 0x06490628, 0x0aefcc28, 0x00000000, 0x07800028,
+	0x078016e9, 0x09508a68, 0x068000a8, 0x06c00028, 0x06090628,
+	0x06090629, 0x06881068, 0x06090628, 0x0cc00000, 0x00000000,
+	0x06490628, 0x0aefcc28, 0x06c00028, 0x069001a8, 0x069fffea,
+	0x06090628, 0x06090629, 0x05401a23, 0x06090628, 0x09210a23,
+	0x05401a28, 0x02828aa8, 0x06090628, 0x06985168, 0x0c782700,
+	0x06090628, 0x078003e8, 0x0a6fc028, 0x07800028, 0x078016e9,
+	0x06800030, 0x09508a68, 0x0780016b, 0x07801d2a, 0x04601aaa,
+	0x0c500ec0, 0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b,
+	0x0aa883eb, 0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb,
+	0x06c0002a, 0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb,
+	0x0c500980, 0x0690002a, 0x0c7e4f00, 0x00000000, 0x06490628,
+	0x0aefcc28, 0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x06090629, 0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400,
+	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
+	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
+	0x06a00028, 0x0a007a2a, 0x080c2440, 0x064c2228, 0x09210a68,
+	0x06090628, 0x02828ae9, 0x06090628, 0x0688d068, 0x02c28aa8,
+	0x09441a30, 0x0c781780, 0x06090628, 0x09441ab0, 0x06031f2a,
+	0x0680016b, 0x09510ae9, 0x0c781600, 0x06031e2b, 0x0aa241eb,
+	0x06a0002a, 0x0aa1c1ab, 0x06b0002a, 0x0aa1416b, 0x0aa1026b,
+	0x06800070, 0x0690002a, 0x06800030, 0x06490628, 0x0aefcc28,
+	0x06c0002a, 0x068408a8, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x06090629, 0x069fffec, 0x06900028, 0x0a00ba2a, 0x080c2400,
 	0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28,
-	0x09828428, 0x078017ad, 0x095e1a2d, 0x06090628, 0x080c2440,
-	0x064c2228, 0x06090628, 0x09210a28, 0x09c28068, 0x02828b28,
-	0x09828428, 0x06090628, 0x06bc5828, 0x09441a30, 0x06090628,
-	0x06b60828, 0x09441a30, 0x06090628, 0x06900028, 0x080c2410,
-	0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28,
-	0x09828428, 0x078017ad, 0x05801b6d, 0x095e1a2d, 0x06090628,
-	0x080c2450, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
-	0x02828b28, 0x09828428, 0x098283e8, 0x06090628, 0x06bed868,
+	0x09828428, 0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028,
+	0x0a00ba2a, 0x080c2440, 0x064c2228, 0x06090628, 0x09210a28,
+	0x09c28068, 0x02828b28, 0x09828428, 0x07801ded, 0x095e1a2d,
+	0x06090628, 0x068c5828, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x06860828, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06900028,
+	0x0a00ba2a, 0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f,
+	0x09c28068, 0x02828b28, 0x09828428, 0x07801dad, 0x095e1a2d,
+	0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2450, 0x064c2228,
+	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
+	0x07801e2d, 0x095e1a2d, 0x06090628, 0x068ed868, 0x02c28aa8,
 	0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228,
-	0x060e152e, 0x060e152f, 0x060e1528, 0x060e1528, 0x0cc00000,
-	0x00000000, 0x064e1215, 0x091e1555, 0x0a208055, 0x0c782300,
-	0x0649d915, 0x0900c555, 0x0a6f8015, 0x00000000, 0x078003d5,
-	0x0aa08055, 0x0c780940, 0x07800596, 0x0aa1c016, 0x04401596,
-	0x07c00596, 0x078005d6, 0x04401596, 0x0c7814c0, 0x07c005d6,
-	0x07800916, 0x07800295, 0x05408555, 0x02015595, 0x04003596,
-	0x07c00916, 0x05404595, 0x02016c56, 0x060e1316, 0x07800517,
-	0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416, 0x069fffd7,
-	0x044015d7, 0x0aa1c017, 0x00000000, 0x064e1615, 0x09010555,
-	0x0aaec015, 0x04401555, 0x060e1615, 0x06c00016, 0x060e1216,
-	0x06800095, 0x0c781880, 0x07c003d5, 0x0a660095, 0x078005d6,
-	0x0aa18016, 0x04401596, 0x0b210056, 0x07c005d6, 0x0c780bc0,
-	0x00000000, 0x07800956, 0x07800295, 0x05408555, 0x02015595,
+	0x060e152e, 0x060e152f, 0x060e1528, 0x0c780080, 0x060e1528,
+	0x0cc00000, 0x00000000, 0x07800028, 0x078016e9, 0x06800030,
+	0x09508a68, 0x0780016b, 0x0780026a, 0x04601aaa, 0x0c500c00,
+	0x0aa1416b, 0x00000000, 0x06800070, 0x0a61826b, 0x00000000,
+	0x078003a8, 0x04602a28, 0x0c500840, 0x0c7800c0, 0x0c780000,
+	0x00000000, 0x06490628, 0x0aefcc28, 0x06b000a8, 0x09441a30,
+	0x06090628, 0x06090629, 0x069fffeb, 0x06900028, 0x080c2400,
+	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
+	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
+	0x080c2440, 0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9,
+	0x06090628, 0x06b8d068, 0x09441a30, 0x0c781340, 0x06090628,
+	0x06b0002a, 0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9,
+	0x0c781180, 0x06031e2b, 0x0aa1416b, 0x0aa1026b, 0x06800070,
+	0x0c7ff5c0, 0x00000000, 0x06490628, 0x0aefcc28, 0x06b408a8,
+	0x09441a30, 0x06090628, 0x06090629, 0x069fffec, 0x06900028,
+	0x080c2400, 0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068,
+	0x02828b28, 0x09828428, 0x078017ad, 0x095e1a2d, 0x06090628,
+	0x080c2440, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
+	0x02828b28, 0x09828428, 0x06090628, 0x06bc5828, 0x09441a30,
+	0x06090628, 0x06b60828, 0x09441a30, 0x06090628, 0x06900028,
+	0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068,
+	0x02828b28, 0x09828428, 0x078017ad, 0x05801b6d, 0x095e1a2d,
+	0x06090628, 0x080c2450, 0x064c2228, 0x06090628, 0x09210a28,
+	0x09c28068, 0x02828b28, 0x09828428, 0x098283e8, 0x06090628,
+	0x06bed868, 0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424,
+	0x064c2228, 0x060e152e, 0x060e152f, 0x060e1528, 0x060e1528,
+	0x0cc00000, 0x00000000, 0x064e1215, 0x091e1555, 0x0a208055,
+	0x0c782300, 0x0649d915, 0x0900c555, 0x0a6f8015, 0x00000000,
+	0x078003d5, 0x0aa08055, 0x0c780940, 0x07800596, 0x0aa1c016,
+	0x04401596, 0x07c00596, 0x078005d6, 0x04401596, 0x0c7814c0,
+	0x07c005d6, 0x07800916, 0x07800295, 0x05408555, 0x02015595,
+	0x04003596, 0x07c00916, 0x05404595, 0x02016c56, 0x060e1316,
+	0x07800517, 0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416,
+	0x069fffd7, 0x044015d7, 0x0aa1c017, 0x00000000, 0x064e1615,
+	0x09010555, 0x0aaec015, 0x04401555, 0x060e1615, 0x06c00016,
+	0x060e1216, 0x06800095, 0x0c781880, 0x07c003d5, 0x0a660095,
+	0x078005d6, 0x0aa18016, 0x04401596, 0x0b210056, 0x07c005d6,
+	0x0c780bc0, 0x00000000, 0x07800956, 0x07800295, 0x05408555,
+	0x02015595, 0x04003596, 0x07c00956, 0x05404595, 0x02016c56,
+	0x060e1316, 0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215,
+	0x068000d5, 0x0c781280, 0x07c003d5, 0x0aa080d5, 0x0c780700,
+	0x07800516, 0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417,
+	0x07800795, 0x07c00755, 0x0683ffd5, 0x064e1516, 0x0900c5d6,
+	0x0a40b5d5, 0x091845d6, 0x07c00797, 0x064e1516, 0x064e1516,
+	0x064e1516, 0x080c24e0, 0x060c2216, 0x064e1516, 0x0c780200,
+	0x060c2216, 0x068000d6, 0x07c00796, 0x06800016, 0x080c24e0,
+	0x060c2216, 0x060c2216, 0x0aa080a0, 0x0c780a00, 0x078003d5,
+	0x0a644115, 0x07800956, 0x068ac015, 0x05408555, 0x02015595,
 	0x04003596, 0x07c00956, 0x05404595, 0x02016c56, 0x060e1316,
-	0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215, 0x068000d5,
-	0x0c781280, 0x07c003d5, 0x0aa080d5, 0x0c780700, 0x07800516,
-	0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417, 0x07800795,
-	0x07c00755, 0x0683ffd5, 0x064e1516, 0x0900c5d6, 0x0a40b5d5,
-	0x091845d6, 0x07c00797, 0x064e1516, 0x064e1516, 0x064e1516,
-	0x080c24e0, 0x060c2216, 0x064e1516, 0x0c780200, 0x060c2216,
-	0x068000d6, 0x07c00796, 0x06800016, 0x080c24e0, 0x060c2216,
-	0x060c2216, 0x0aa080a0, 0x0c780a00, 0x078003d5, 0x0a644115,
-	0x07800956, 0x068ac015, 0x05408555, 0x02015595, 0x04003596,
-	0x07c00956, 0x05404595, 0x02016c56, 0x060e1316, 0x06a16015,
-	0x09c151d5, 0x06c00015, 0x060e1215, 0x06800195, 0x0c780640,
-	0x07c003d5, 0x0aa0c195, 0x0c780500, 0x00000000, 0x06431e18,
-	0x0befc058, 0x064e1418, 0x080e1400, 0x064e1516, 0x0683ffd5,
-	0x0900c5d6, 0x09203656, 0x0a8045d5, 0x091845d6, 0x068000d7,
-	0x06800019, 0x07c004d7, 0x090015d9, 0x07c00497, 0x090225d9,
-	0x07c01117, 0x060e1418, 0x06800015, 0x07c003d5, 0x0cc00000,
-	0x00400000, 0x06800047, 0x07c003c7, 0x07800507, 0x050011c7,
-	0x07c00507, 0x064e1608, 0x09010208, 0x04001208, 0x060e1608,
-	0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408, 0x06b7ffc7,
-	0x06c00007, 0x060e1507, 0x060e1524, 0x060e1524, 0x060e1524,
-	0x060e1524, 0x0cc00000, 0x08030580, 0x078003c7, 0x0a6fc007,
-	0x07800447, 0x0aa0c0c7, 0x0aa98347, 0x0a638107, 0x07800507,
-	0x050011c7, 0x07c00507, 0x06800047, 0x07c003c7, 0x080c24e0,
-	0x064c2207, 0x064c2208, 0x080c24c0, 0x060c2207, 0x060c2208,
-	0x0cc00000, 0x08030580, 0x06800047, 0x07c003c7, 0x07800507,
-	0x050011c7, 0x07c00507, 0x080e1424, 0x064e1509, 0x064e150a,
-	0x064e150b, 0x064e150c, 0x0aa0c007, 0x06800008, 0x06800308,
-	0x060e1408, 0x0683ffc7, 0x07800448, 0x095841c8, 0x07800308,
-	0x096031c8, 0x060e1507, 0x060e1509, 0x060e150a, 0x060e150b,
-	0x060e150c, 0x0cc00000, 0x08030580, 0x07800987, 0x078009c8,
-	0x06800009, 0x0d000008, 0x020091c9, 0x04401249, 0x06800047,
-	0x0ba10089, 0x05801249, 0x0c7fff80, 0x040011c7, 0x0cc00000,
-	0x07c00687, 0x06800208, 0x064c3b07, 0x091031c7, 0x024071c8,
-	0x0f8001c7, 0x0fc0f1c0, 0x064c0e07, 0x040011c7, 0x0f8001c7,
-	0x07800687, 0x0f8001c7, 0x0fc051c0, 0x0c073dc0, 0x07c00107,
-	0x0fc011c0, 0x0aa0c007, 0x0c000640, 0x00000000, 0x078002c7,
-	0x07801988, 0x094c11c8, 0x0c0736c0, 0x060e0407, 0x06800007,
-	0x07c01cc7, 0x078005c7, 0x0b210087, 0x07800988, 0x04002208,
-	0x024081c8, 0x07800947, 0x04401208, 0x02007207, 0x05401208,
-	0x02007207, 0x07c00947, 0x07800987, 0x040011c7, 0x07c005c7,
-	0x0cc00000, 0x00000000, 0x0fc011c0, 0x0a600007, 0x0fc011c0,
-	0x07801408, 0x0f8001c8, 0x0fc011c0, 0x0fc021c0, 0x0fc03200,
-	0x0aa10007, 0x0aa0c047, 0x0fc03200, 0x0fc03200, 0x0cc00000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x06a16015, 0x09c151d5, 0x06c00015, 0x060e1215, 0x06800195,
+	0x0c780640, 0x07c003d5, 0x0aa0c195, 0x0c780500, 0x00000000,
+	0x06431e18, 0x0befc058, 0x064e1418, 0x080e1400, 0x064e1516,
+	0x0683ffd5, 0x0900c5d6, 0x09203656, 0x0a8045d5, 0x091845d6,
+	0x068000d7, 0x06800019, 0x07c004d7, 0x090015d9, 0x07c00497,
+	0x090225d9, 0x07c01117, 0x060e1418, 0x06800015, 0x07c003d5,
+	0x0cc00000, 0x00400000, 0x06800047, 0x07c003c7, 0x07800507,
+	0x050011c7, 0x07c00507, 0x064e1608, 0x09010208, 0x04001208,
+	0x060e1608, 0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408,
+	0x06b7ffc7, 0x06c00007, 0x060e1507, 0x060e1524, 0x060e1524,
+	0x060e1524, 0x060e1524, 0x0cc00000, 0x08030580, 0x078003c7,
+	0x0a6fc007, 0x07800447, 0x0aa0c0c7, 0x0aa98347, 0x0a638107,
+	0x07800507, 0x050011c7, 0x07c00507, 0x06800047, 0x07c003c7,
+	0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0, 0x060c2207,
+	0x060c2208, 0x0cc00000, 0x08030580, 0x06800047, 0x07c003c7,
+	0x07800507, 0x050011c7, 0x07c00507, 0x080e1424, 0x064e1509,
+	0x064e150a, 0x064e150b, 0x064e150c, 0x0aa0c007, 0x06800008,
+	0x06800308, 0x060e1408, 0x0683ffc7, 0x07800448, 0x095841c8,
+	0x07800308, 0x096031c8, 0x060e1507, 0x060e1509, 0x060e150a,
+	0x060e150b, 0x060e150c, 0x0cc00000, 0x08030580, 0x07800987,
+	0x078009c8, 0x06800009, 0x0d000008, 0x020091c9, 0x04401249,
+	0x06800047, 0x0ba10089, 0x05801249, 0x0c7fff80, 0x040011c7,
+	0x0cc00000, 0x07c00687, 0x06800208, 0x064c3b07, 0x091031c7,
+	0x024071c8, 0x0f8001c7, 0x0fc0f1c0, 0x064c0e07, 0x040011c7,
+	0x0f8001c7, 0x07800687, 0x0f8001c7, 0x0fc051c0, 0x0c073d80,
+	0x07c00107, 0x0fc011c0, 0x0aa0c007, 0x0c000640, 0x00000000,
+	0x078002c7, 0x07801988, 0x094c11c8, 0x0c073680, 0x060e0407,
+	0x06800007, 0x07c01cc7, 0x078005c7, 0x0b210087, 0x07800988,
+	0x04002208, 0x024081c8, 0x07800947, 0x04401208, 0x02007207,
+	0x05401208, 0x02007207, 0x07c00947, 0x07800987, 0x040011c7,
+	0x07c005c7, 0x0cc00000, 0x00000000, 0x0fc011c0, 0x0a600007,
+	0x0fc011c0, 0x07801408, 0x0f8001c8, 0x0fc011c0, 0x0fc021c0,
+	0x0fc03200, 0x0aa10007, 0x0aa0c047, 0x0fc03200, 0x0fc03200,
+	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -634,108 +633,116 @@ const u32 vmpeg4_mc_4[] __initconst = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x06bff7c0, 0x06032400, 0x00400000, 0x0c780000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x06bff7c0, 0x06032400, 0x00400000,
+	0x0c780000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x0cc00000, 0x00400000,
-	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0cc00000, 0x00400000, 0x0c780200, 0x06431e07,
-	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x09027207, 0x0a654048, 0x068fdfca, 0x06feffca,
-	0x064e0408, 0x02808288, 0x09108287, 0x0ba0c08a, 0x064c0909,
-	0x098083c8, 0x0ac0424a, 0x09208287, 0x0a60c00a, 0x0400128a,
-	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x0c780d40,
-	0x060e0408, 0x0c780cc0, 0x00000000, 0x0a6f8088, 0x0680002c,
-	0x080e1424, 0x09110a47, 0x06431f2a, 0x069fffeb, 0x06490628,
-	0x0aefcc28, 0x05404a2c, 0x060c2428, 0x068010a8, 0x02c28aa8,
-	0x09462a2c, 0x06090628, 0x06090629, 0x064c2228, 0x060e1528,
-	0x09210b68, 0x06090628, 0x02828aed, 0x06090628, 0x06a00028,
-	0x0a009a2a, 0x05404a2c, 0x098281a8, 0x060c2428, 0x064c2228,
-	0x09210b68, 0x06090628, 0x02828aed, 0x06090628, 0x0ba9c0ec,
-	0x04001b2c, 0x06881068, 0x02c28aa8, 0x06090628, 0x080c2480,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0c780200,
+	0x06431e07, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x09027207, 0x0a654048, 0x068fdfca,
+	0x06feffca, 0x064e0408, 0x02808288, 0x09108287, 0x0ba0c08a,
+	0x064c0909, 0x098083c8, 0x0ac0424a, 0x09208287, 0x0a60c00a,
+	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
+	0x0c780d40, 0x060e0408, 0x0c780cc0, 0x00000000, 0x0a6f8088,
+	0x0680002c, 0x080e1424, 0x09110a47, 0x06431f2a, 0x069fffeb,
+	0x06490628, 0x0aefcc28, 0x05404a2c, 0x060c2428, 0x068010a8,
+	0x02c28aa8, 0x09462a2c, 0x06090628, 0x06090629, 0x064c2228,
+	0x060e1528, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
+	0x06a00028, 0x0a009a2a, 0x05404a2c, 0x098281a8, 0x060c2428,
 	0x064c2228, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
-	0x06a00028, 0x0a006a2a, 0x064c2228, 0x09210b68, 0x06090628,
-	0x02828aed, 0x06090628, 0x08031e00, 0x0cc00000, 0x00400000
+	0x0ba9c0ec, 0x04001b2c, 0x06881068, 0x02c28aa8, 0x06090628,
+	0x080c2480, 0x064c2228, 0x09210b68, 0x06090628, 0x02828aed,
+	0x06090628, 0x06a00028, 0x0a006a2a, 0x064c2228, 0x09210b68,
+	0x06090628, 0x02828aed, 0x06090628, 0x08031e00, 0x0cc00000,
+	0x00400000
 };
 
 const u32 __initconst vmpeg4_mc_5[] = {
-	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c014380, 0x00000000,
-	0x00000000, 0x00000000, 0x080c0002, 0x080c2901, 0x06bfde80,
-	0x07c017c0, 0x06030400, 0x00400000, 0x0c019a00, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
+	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014d40,
+	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x080c2901,
+	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a400,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0c7ffe80, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x0c780400, 0x04001965, 0x0cc00000, 0x00400000,
-	0x0c7804c0, 0x064c0007, 0x0c79a100, 0x06800025, 0x0cc00000,
-	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
-	0x0c79ee00, 0x06800025, 0x0cc00000, 0x00400000, 0x06800025,
-	0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409, 0x078001c9,
-	0x0aa0c009, 0x0c78ff80, 0x00000000, 0x06bfdd89, 0x06030409,
-	0x00400000, 0x07801509, 0x0aa2c109, 0x07c0151f, 0x0a2c4047,
-	0x06800025, 0x0aa14009, 0x0a608049, 0x0c790940, 0x0a608089,
-	0x0c78fc00, 0x0a240807, 0x0c788a40, 0x00000000, 0x0683ffc8,
-	0x0ba20048, 0x064c0007, 0x0a2f8047, 0x04401208, 0x064c3a07,
-	0x090061c7, 0x0aae8647, 0x00000000, 0x06800007, 0x0c017100,
-	0x07c003c7, 0x0c792b00, 0x0bec9007, 0x078003c7, 0x0a6fc007,
-	0x07800007, 0x07800988, 0x0b822207, 0x06800007, 0x07c00007,
-	0x0a628060, 0x06a00008, 0x06e00008, 0x06431e09, 0x0befc049,
-	0x00000000, 0x080c24a0, 0x060c2208, 0x0c780300, 0x060c2208,
-	0x0a6280a0, 0x00000000, 0x06431e09, 0x0befc049, 0x00000000,
-	0x080c24c0, 0x080c2200, 0x080c2200, 0x080c2200, 0x080c2200,
-	0x078016c8, 0x04001208, 0x078009c9, 0x0b80a248, 0x07c016c8,
-	0x0c020500, 0x00000000, 0x078003c7, 0x0a6fc007, 0x0c792180,
-	0x00000000, 0x06431e09, 0x0befc049, 0x07800347, 0x0a61c007,
-	0x00000000, 0x064c2907, 0x091c21c7, 0x0a60c0c7, 0x0c021000,
-	0x00000000, 0x0aa080a0, 0x0c780f40, 0x078003c7, 0x0a6fc007,
-	0x07801bc8, 0x0a63c008, 0x078004c8, 0x0a634348, 0x06800107,
-	0x07c003c7, 0x08030580, 0x068003c9, 0x07c00149, 0x06800007,
-	0x0c018d80, 0x07c01d07, 0x07800007, 0x040011c7, 0x0c7fef80,
-	0x07c00007, 0x0c792d80, 0x078003c7, 0x0a6fc007, 0x078005c7,
-	0x0ba0c087, 0x06800007, 0x06800047, 0x07c01fc7, 0x07800787,
-	0x0aa180c7, 0x06810007, 0x060e0907, 0x060e0a07, 0x0c780440,
-	0x060e0b07, 0x07800507, 0x0aa0c007, 0x068000c8, 0x068003c8,
-	0x060e1408, 0x064e1507, 0x060e0907, 0x04003208, 0x060e1408,
-	0x064e1507, 0x060e0a07, 0x04003208, 0x060e1408, 0x064e1507,
-	0x060e0b07, 0x0683ffc7, 0x080e1418, 0x060e1507, 0x080e141b,
-	0x060e1507, 0x080e141e, 0x060e1507, 0x080e1421, 0x0c01f280,
-	0x060e1507, 0x0c785580, 0x00000000, 0x0aa6c020, 0x00000000,
-	0x0fc011c0, 0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147,
-	0x06431e07, 0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224,
-	0x060c2224, 0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07,
-	0x091011c7, 0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7,
-	0x0aae8007, 0x0c7ff000, 0x080c2800, 0x0c7fda80, 0x00000000,
-	0x080c2801, 0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008,
-	0x0c7fd8c0, 0x058011c7, 0x09004207, 0x07c00148, 0x090821c7,
-	0x07c00187, 0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781900,
-	0x00000000, 0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802,
-	0x064c2807, 0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207,
-	0x07c01388, 0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0,
-	0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089, 0x04401249,
-	0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809, 0x04401249,
-	0x068007c9, 0x07c00109, 0x0c012f80, 0x040001c9, 0x07801fcb,
-	0x0aa1400b, 0x078005c9, 0x0b60c089, 0x0c004880, 0x00000000,
-	0x068fdfca, 0x06feffca, 0x064e0408, 0x02808288, 0x078005ca,
-	0x0ba0c08a, 0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a,
-	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
-	0x098081c8, 0x07802007, 0x09605207, 0x07800007, 0x040811c7,
+	0x00000000, 0x00000000, 0x0c780400, 0x04001965, 0x0cc00000,
+	0x00400000, 0x0c7804c0, 0x064c0007, 0x0c79ab00, 0x06800025,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c79f800, 0x06800025, 0x0cc00000, 0x00400000,
+	0x06800025, 0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409,
+	0x078001c9, 0x0aa0c009, 0x0c790940, 0x00000000, 0x06bfdd89,
+	0x06030409, 0x00400000, 0x07801509, 0x0aa2c109, 0x07c0151f,
+	0x0a2c4047, 0x06800025, 0x0aa14009, 0x0a608049, 0x0c791300,
+	0x0a608089, 0x0c7905c0, 0x0a240807, 0x0c789400, 0x00000000,
+	0x0683ffc8, 0x0ba20048, 0x064c0007, 0x0a2f8047, 0x04401208,
+	0x064c3a07, 0x090061c7, 0x0aae8647, 0x00000000, 0x06800007,
+	0x0c017b00, 0x07c003c7, 0x0c7934c0, 0x0bec9007, 0x078003c7,
+	0x0a6fc007, 0x07800007, 0x07800988, 0x0b822207, 0x06800007,
+	0x07c00007, 0x0a628060, 0x06a00008, 0x06e00008, 0x06431e09,
+	0x0befc049, 0x00000000, 0x080c24a0, 0x060c2208, 0x0c780300,
+	0x060c2208, 0x0a6280a0, 0x00000000, 0x06431e09, 0x0befc049,
+	0x00000000, 0x080c24c0, 0x080c2200, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x078016c8, 0x04001208, 0x078009c9, 0x0b80a248,
+	0x07c016c8, 0x0c020f00, 0x00000000, 0x078003c7, 0x0a6fc007,
+	0x0c792b40, 0x00000000, 0x06431e09, 0x0befc049, 0x07800347,
+	0x0aa0c007, 0x0c780880, 0x00000000, 0x064c1d07, 0x09227207,
+	0x0a678008, 0x064c2a08, 0x064c3607, 0x091081c7, 0x095101c8,
+	0x064c3b08, 0x09103248, 0x04001209, 0x03807207, 0x0900f207,
+	0x0a650008, 0x0580f1c7, 0x06800048, 0x05407208, 0x03808248,
+	0x04401208, 0x0a40e207, 0x064c1d07, 0x0a60c009, 0x00000000,
+	0x054081c7, 0x06800009, 0x09201207, 0x0a610008, 0x054011c7,
+	0x0c7fff40, 0x04001249, 0x060c0e09, 0x0c021300, 0x00000000,
+	0x0aa080a0, 0x0c780f40, 0x078003c7, 0x0a6fc007, 0x07801bc8,
+	0x0a63c008, 0x078004c8, 0x0a634348, 0x06800107, 0x07c003c7,
+	0x08030580, 0x068003c9, 0x07c00149, 0x06800007, 0x0c019080,
+	0x07c01d07, 0x07800007, 0x040011c7, 0x0c7fe880, 0x07c00007,
+	0x0c793040, 0x078003c7, 0x0a6fc007, 0x078005c7, 0x0ba0c087,
+	0x06800007, 0x06800047, 0x07c01fc7, 0x07800787, 0x0aa180c7,
+	0x06810007, 0x060e0907, 0x060e0a07, 0x0c780440, 0x060e0b07,
+	0x07800507, 0x0aa0c007, 0x068000c8, 0x068003c8, 0x060e1408,
+	0x064e1507, 0x060e0907, 0x04003208, 0x060e1408, 0x064e1507,
+	0x060e0a07, 0x04003208, 0x060e1408, 0x064e1507, 0x060e0b07,
+	0x0683ffc7, 0x080e1418, 0x060e1507, 0x080e141b, 0x060e1507,
+	0x080e141e, 0x060e1507, 0x080e1421, 0x0c01f580, 0x060e1507,
+	0x0c7855c0, 0x00000000, 0x0aa6c020, 0x00000000, 0x0fc011c0,
+	0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147, 0x06431e07,
+	0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224, 0x060c2224,
+	0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07, 0x091011c7,
+	0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7, 0x0aae8007,
+	0x0c7ff000, 0x080c2800, 0x0c7fd380, 0x00000000, 0x080c2801,
+	0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008, 0x0c7fd1c0,
+	0x058011c7, 0x09004207, 0x07c00148, 0x090821c7, 0x07c00187,
+	0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940, 0x00000000,
+	0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802, 0x064c2807,
+	0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207, 0x07c01388,
+	0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0, 0x0b61c087,
+	0x07800109, 0x024091c9, 0x0b620089, 0x04401249, 0x0c780180,
+	0x06800049, 0x020091c9, 0x0b20c809, 0x04401249, 0x068007c9,
+	0x07c00109, 0x0c013240, 0x040001c9, 0x07801fcb, 0x0aa1400b,
+	0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000, 0x068fdfca,
+	0x06feffca, 0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a,
+	0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a,
+	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
+	0x07808007, 0x09605207, 0x07800007, 0x06808049, 0x02007247,
 	0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248, 0x07c01fc9,
 	0x07801388, 0x060c2b08, 0x06880008, 0x098083c8, 0x07800507,
 	0x07801989, 0x0a610049, 0x09581207, 0x09808408, 0x098083c8,
 	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
 	0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0, 0x07c01cc7,
-	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01d240, 0x00000000,
-	0x080c0080, 0x0c015a00, 0x00000000, 0x080c24a0, 0x080c2200,
+	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01d500, 0x00000000,
+	0x080c0080, 0x0c015cc0, 0x00000000, 0x080c24a0, 0x080c2200,
 	0x080c2200, 0x07800007, 0x040011c7, 0x07c00007, 0x07800147,
-	0x0c012fc0, 0x07c00447, 0x0c7fb800, 0x00000000, 0x0a60c0e0,
+	0x0c013240, 0x07c00447, 0x0c7fb0c0, 0x00000000, 0x0a60c0e0,
 	0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802, 0x064c2807,
 	0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8, 0x07800188,
 	0x09444207, 0x07c01388, 0x07800148, 0x0a644048, 0x080c2800,
 	0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089,
 	0x04401249, 0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809,
-	0x04401249, 0x068007c9, 0x07c00109, 0x0c011640, 0x040001c9,
+	0x04401249, 0x068007c9, 0x07c00109, 0x0c0118c0, 0x040001c9,
 	0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007, 0x0c7806c0,
 	0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0, 0x07c01cc7,
 	0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148, 0x07800489,
@@ -760,22 +767,24 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147, 0x078004c7,
 	0x07c00387, 0x07800487, 0x07c00247, 0x07801107, 0x07c01787,
 	0x06800107, 0x07c003c7, 0x08030580, 0x064c2407, 0x0befc3c7,
-	0x00000000, 0x07800147, 0x0aa10147, 0x0c0137c0, 0x00000000,
-	0x0c7800c0, 0x0c015e00, 0x00000000, 0x07800007, 0x040011c7,
-	0x0c7f8f40, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
+	0x00000000, 0x07800147, 0x0aa10147, 0x0c013a80, 0x00000000,
+	0x0c7800c0, 0x0c0160c0, 0x00000000, 0x07800007, 0x040011c7,
+	0x0c7f8800, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
 	0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca, 0x06feffca,
 	0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a, 0x064c0909,
 	0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a, 0x0400128a,
 	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x060e0408,
-	0x091e1248, 0x07c01fc9, 0x0c019f40, 0x00000000, 0x064c2407,
+	0x091e1248, 0x07c01fc9, 0x0c01a200, 0x00000000, 0x064c2407,
 	0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000, 0x080c2130,
-	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c012c80, 0x00000000,
+	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c012f40, 0x00000000,
 	0x07800007, 0x040011c7, 0x07c00007, 0x07801d08, 0x07801d47,
 	0x09421207, 0x07801d87, 0x09441207, 0x07c00308, 0x07800148,
-	0x0aa0c348, 0x07c00448, 0x0c7f8240, 0x078003c7, 0x0a6fc007,
+	0x0aa0c348, 0x07c00448, 0x0c7f7b00, 0x078003c7, 0x0a6fc007,
 	0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0,
-	0x060c2207, 0x0c7f89c0, 0x060c2208, 0x0780044b, 0x0aa1034b,
-	0x064e160b, 0x090102cb, 0x0aaf800b, 0x0681000b, 0x060e090b,
+	0x060c2207, 0x0c7f8280, 0x060c2208, 0x0780044b, 0x0aa3834b,
+	0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009, 0x00000000,
+	0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140, 0x00000000,
+	0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b, 0x060e090b,
 	0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009, 0x064e0e0b,
 	0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d,
 	0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
@@ -798,7 +807,7 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x0a6103c7, 0x07c01887, 0x0fc101c0, 0x0609c507, 0x0fc011c0,
 	0x0aa30007, 0x00000000, 0x0fc021c0, 0x07c018c7, 0x0fc021c0,
 	0x0a21c047, 0x00000000, 0x0fc101c0, 0x0fc101c0, 0x0fc101c0,
-	0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007, 0x0c7f6780,
+	0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007, 0x0c7f5dc0,
 	0x00000000, 0x0fc011c0, 0x0fc101c0, 0x07c01907, 0x0649c308,
 	0x09410207, 0x0609c308, 0x0b220087, 0x06800048, 0x06800008,
 	0x06800049, 0x0b004247, 0x05401249, 0x0c7fff80, 0x04001208,
@@ -826,7 +835,7 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x040011c7, 0x058011c7, 0x0d000007, 0x060e030a, 0x04c08208,
 	0x060e0008, 0x07801807, 0x0aa18047, 0x00000000, 0x0fc011c0,
 	0x0540b1c7, 0x09807007, 0x060c0107, 0x0fc011c0, 0x0aa60007,
-	0x0fc011c0, 0x07c00347, 0x0aa0c047, 0x0c016080, 0x00000000,
+	0x0fc011c0, 0x07c00347, 0x0aa0c047, 0x0c0160c0, 0x00000000,
 	0x0fc011c0, 0x0a20c047, 0x00000000, 0x0fc011c0, 0x07801807,
 	0x06800008, 0x0aa18047, 0x06800007, 0x0fc011c0, 0x0a624007,
 	0x0fc01200, 0x0a61c008, 0x07c01a07, 0x07c01a48, 0x0fc011c0,
@@ -854,7 +863,7 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x0c780540, 0x07c010c7, 0x07801008, 0x04001208, 0x0ae44048,
 	0x07c01008, 0x078010c9, 0x02007247, 0x0b21c007, 0x0b406247,
 	0x0b406247, 0x00000000, 0x024091c9, 0x0c7fff40, 0x04080208,
-	0x0c7f2280, 0x058011c7, 0x0b403247, 0x00000000, 0x04080208,
+	0x0c7f18c0, 0x058011c7, 0x0b403247, 0x00000000, 0x04080208,
 	0x07c01008, 0x090071c8, 0x090e7208, 0x09545207, 0x060e0708,
 	0x07800047, 0x0b624087, 0x0aa180a0, 0x0aa08020, 0x0aa10007,
 	0x040011c7, 0x0c780100, 0x07c00047, 0x0c784c00, 0x00000000,
@@ -864,21 +873,21 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x07c01b07, 0x0fc031c0, 0x07c000c7, 0x07801c07, 0x0aa20007,
 	0x00000000, 0x0fc011c0, 0x07c01c47, 0x0fc011c0, 0x07c01c87,
 	0x054021c7, 0x060c0307, 0x0a6740e0, 0x07801e47, 0x0aa6c007,
-	0x09066207, 0x0aa08088, 0x0c7fae00, 0x0c00a740, 0x06801ec8,
-	0x07901ee3, 0x06801409, 0x09510263, 0x060c2109, 0x0c00a5c0,
+	0x09066207, 0x0aa08088, 0x0c7fae00, 0x0c00a780, 0x06801ec8,
+	0x07901ee3, 0x06801409, 0x09510263, 0x060c2109, 0x0c00a600,
 	0x06801f08, 0x07901f08, 0x06801809, 0x09510248, 0x060c2109,
-	0x096108c8, 0x0c00a400, 0x06801f48, 0x0c00a380, 0x06801f88,
+	0x096108c8, 0x0c00a440, 0x06801f48, 0x0c00a3c0, 0x06801f88,
 	0x05401923, 0x09c24424, 0x0942f923, 0x0a20c047, 0x0c7fa880,
 	0x00000000, 0x0fc051c0, 0x0c006f00, 0x07c00107, 0x0c006c40,
 	0x00000000, 0x0a6180a0, 0x078003c7, 0x0a6fc007, 0x06800107,
 	0x07c003c7, 0x08030580, 0x0aa28020, 0x06800048, 0x0a6100a0,
 	0x0fc03200, 0x0fc03240, 0x07c01b89, 0x07c01b48, 0x09503248,
 	0x09809149, 0x060c2109, 0x060c0e08, 0x06800025, 0x06490908,
-	0x0ae10225, 0x00000000, 0x0bef4048, 0x0c780080, 0x0c7f0840,
+	0x0ae10225, 0x00000000, 0x0bef4048, 0x0c780080, 0x0c7efe80,
 	0x0683ffc7, 0x0649bb08, 0x0900c208, 0x0aa10008, 0x0aa0c007,
 	0x0c7fff00, 0x044011c7, 0x06490b07, 0x09807007, 0x06090b07,
 	0x06090b07, 0x09c07007, 0x06090b07, 0x0649c909, 0x0aa10009,
-	0x06800087, 0x0c7efe00, 0x07c01507, 0x07801487, 0x0a608007,
+	0x06800087, 0x0c7ef440, 0x07c01507, 0x07801487, 0x0a608007,
 	0x0c780b00, 0x044011c7, 0x0aa0c087, 0x07801549, 0x078015c9,
 	0x0b20c1c9, 0x00000000, 0x0c780940, 0x07800fc8, 0x0609ca08,
 	0x07c00fdf, 0x0680420a, 0x02007289, 0x070001c7, 0x054101c7,
@@ -897,7 +906,7 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x078048ca, 0x07804908, 0x09610288, 0x0a240807, 0x06800148,
 	0x0780494a, 0x07804988, 0x09610288, 0x0a22d007, 0x06800188,
 	0x078049ca, 0x07804a08, 0x09610288, 0x0a21a007, 0x068001c8,
-	0x0809cd11, 0x06800047, 0x0c7ee600, 0x07c01507, 0x0809cd00,
+	0x0809cd11, 0x06800047, 0x0c7edc40, 0x07c01507, 0x0809cd00,
 	0x07801607, 0x090041c7, 0x0a8051c8, 0x0a6200a0, 0x07801607,
 	0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207, 0x0c7ff180,
 	0x02c091c9, 0x07800b47, 0x0680400f, 0x020093c8, 0x07400247,
@@ -918,16 +927,16 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x05810208, 0x0c7800c0, 0x00000000, 0x058103cf, 0x02c083c8,
 	0x06098108, 0x06499108, 0x05410208, 0x058103c8, 0x02c083c8,
 	0x06098208, 0x080980f4, 0x07801b07, 0x06800048, 0x09421207,
-	0x0c7ee000, 0x06090708, 0x06800025, 0x0ae20225, 0x064c0007,
+	0x0c7ed640, 0x06090708, 0x06800025, 0x0ae20225, 0x064c0007,
 	0x0a2f8047, 0x00000000, 0x064c3a07, 0x090061c7, 0x0aae8647,
-	0x0c7800c0, 0x0c7ecf80, 0x00000000, 0x080c2800, 0x080c0002,
-	0x0c7ec880, 0x00000000, 0x0649c007, 0x07c04647, 0x058101c7,
+	0x0c7800c0, 0x0c7ec5c0, 0x00000000, 0x080c2800, 0x080c0002,
+	0x0c7ebec0, 0x00000000, 0x0649c007, 0x07c04647, 0x058101c7,
 	0x07c04687, 0x0649c107, 0x07c046c7, 0x058101c7, 0x07c04707,
 	0x0649c207, 0x07c04747, 0x058101c7, 0x07c04787, 0x0649c307,
 	0x07c047c7, 0x058101c7, 0x07c04807, 0x0649d007, 0x07c04847,
 	0x058101c7, 0x07c04887, 0x0649d107, 0x07c048c7, 0x058101c7,
 	0x07c04907, 0x0649d207, 0x07c04947, 0x058101c7, 0x07c04987,
-	0x0649d307, 0x07c049c7, 0x058101c7, 0x07c04a07, 0x0c004240,
+	0x0649d307, 0x07c049c7, 0x058101c7, 0x07c04a07, 0x0c004280,
 	0x06800025, 0x08002501, 0x08002605, 0x08002708, 0x08002815,
 	0x08002c14, 0x08002a09, 0x08002b17, 0x06830002, 0x06032602,
 	0x08032261, 0x08032101, 0x0cc00000, 0x00000000, 0x080c2804,
@@ -944,9 +953,9 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x080c2141, 0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207,
 	0x064e1507, 0x060c2207, 0x080c2147, 0x064c2407, 0x0befc3c7,
 	0x078004c7, 0x07c00387, 0x07800487, 0x07c00247, 0x07801107,
-	0x07c01787, 0x06800107, 0x07c003c7, 0x0c0078c0, 0x00000000,
+	0x07c01787, 0x06800107, 0x07c003c7, 0x0c007900, 0x00000000,
 	0x08030580, 0x07800007, 0x040011c7, 0x07c00007, 0x06431e07,
-	0x0befc047, 0x0c7eb2c0, 0x00000000, 0x0fc01200, 0x0fc011c0,
+	0x0befc047, 0x0c7ea900, 0x00000000, 0x0fc01200, 0x0fc011c0,
 	0x0aa28047, 0x06800147, 0x0fc011c0, 0x0aa1c047, 0x06800187,
 	0x0fc011c0, 0x0aa10047, 0x068001c7, 0x0fc011c0, 0x06800207,
 	0x07c00147, 0x0a60c008, 0x06800007, 0x0fc061c0, 0x07c01387,
@@ -954,7 +963,7 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x0fc011c0, 0x0aa38007, 0x07800108, 0x0fc011c0, 0x0aa14007,
 	0x0b21c748, 0x04002208, 0x0c780140, 0x068007c8, 0x0b60c0c8,
 	0x04402208, 0x06800048, 0x07c00108, 0x0c0005c0, 0x040001c8,
-	0x0c7eef80, 0x00000000, 0x06a00007, 0x06e00007, 0x080c24a0,
+	0x0c7eed00, 0x00000000, 0x06a00007, 0x06e00007, 0x080c24a0,
 	0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207,
 	0x0cc00000, 0x060c2207, 0x07801988, 0x094c11c8, 0x0c07fd00,
 	0x060e0407, 0x06800007, 0x07c01cc7, 0x07c00907, 0x0cc00000,
@@ -973,165 +982,156 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x06800087, 0x05c0438e, 0x0540138e, 0x0200e1ce, 0x0ae1000f,
 	0x06bfffcd, 0x0300e34e, 0x0400138e, 0x0cc00000, 0x040003ce,
 	0x07800007, 0x0ae10007, 0x07800109, 0x07800988, 0x02007207,
-	0x044011c7, 0x040811c7, 0x074001c9, 0x0cc00000, 0x07c02009,
-	0x0681f409, 0x04401249, 0x0aefc009, 0x00000000, 0x083f0040,
-	0x083f0000, 0x08090b65, 0x00000000, 0x08090b60, 0x06498e07,
-	0x09807007, 0x068007c9, 0x097051c9, 0x06098e07, 0x0681f409,
-	0x04601249, 0x0c4fffc0, 0x00000000, 0x06800009, 0x097051c9,
-	0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187, 0x09807207,
-	0x060c0007, 0x064c0807, 0x09807347, 0x060c0807, 0x083f0040,
-	0x083f0000, 0x08090b65, 0x0cc00000, 0x08090b60, 0x0680001f,
-	0x07c0149f, 0x07c014df, 0x07c0151f, 0x064c091f, 0x07c0175f,
-	0x07c0005f, 0x06800020, 0x06803fc2, 0x07c01542, 0x07c01582,
-	0x07c015c2, 0x07c01602, 0x060c091f, 0x080c0101, 0x080c2901,
-	0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226, 0x024269e6,
-	0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726, 0x0649cf31,
-	0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207, 0x092101c7,
-	0x0401f287, 0x0580528a, 0x0403e247, 0x05806249, 0x09610289,
-	0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7,
-	0x060c0907, 0x07c00987, 0x04401247, 0x07c00609, 0x05404287,
-	0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208, 0x05804208,
-	0x07c009c8, 0x05404208, 0x0961020a, 0x06090808, 0x0809c300,
-	0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803, 0x0aa14003,
-	0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800, 0x07801502,
-	0x0aa0c002, 0x06800102, 0x06030502, 0x064c0002, 0x0be14042,
-	0x0ba1d025, 0x06800102, 0x07c01502, 0x08030504, 0x06800025,
-	0x0cc00000, 0x00000000, 0x078001c2, 0x0aa1c002, 0x078016c2,
-	0x078009c3, 0x0a4040c2, 0x00000000, 0x06800102, 0x06030502,
-	0x0cc00000, 0x00000000, 0x0fc02240, 0x0aa4c009, 0x0680000a,
-	0x0b6180c9, 0x0680010a, 0x0fc01280, 0x09422289, 0x0c780140,
-	0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a, 0x06800049,
-	0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a, 0x05401249,
-	0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000, 0x0fc01240,
-	0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e60c0, 0x00000000,
-	0x06490628, 0x0aefcc28, 0x00000000, 0x07800028, 0x078016e9,
-	0x09508a68, 0x068000a8, 0x06c00028, 0x06090628, 0x06090629,
-	0x06881068, 0x06090628, 0x0cc00000, 0x00000000, 0x06490628,
-	0x0aefcc28, 0x06c00028, 0x069001a8, 0x069fffea, 0x06090628,
-	0x06090629, 0x05401a23, 0x06090628, 0x09210a23, 0x05401a28,
-	0x02828aa8, 0x06090628, 0x06985168, 0x0c782700, 0x06090628,
-	0x078003e8, 0x0a6fc028, 0x07800028, 0x078016e9, 0x06800030,
-	0x09508a68, 0x0780016b, 0x07801d2a, 0x04601aaa, 0x0c500ec0,
-	0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b, 0x0aa883eb,
-	0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb, 0x06c0002a,
-	0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb, 0x0c500980,
-	0x0690002a, 0x0c7e5900, 0x00000000, 0x06490628, 0x0aefcc28,
-	0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629,
-	0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400, 0x080e1424,
-	0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x09210a68, 0x06090628, 0x02828ae9, 0x06090628, 0x06a00028,
-	0x0a007a2a, 0x080c2440, 0x064c2228, 0x09210a68, 0x06090628,
-	0x02828ae9, 0x06090628, 0x0688d068, 0x02c28aa8, 0x09441a30,
-	0x0c781780, 0x06090628, 0x09441ab0, 0x06031f2a, 0x0680016b,
-	0x09510ae9, 0x0c781600, 0x06031e2b, 0x0aa241eb, 0x06a0002a,
-	0x0aa1c1ab, 0x06b0002a, 0x0aa1416b, 0x0aa1026b, 0x06800070,
-	0x0690002a, 0x06800030, 0x06490628, 0x0aefcc28, 0x06c0002a,
-	0x068408a8, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629,
-	0x069fffec, 0x06900028, 0x0a00ba2a, 0x080c2400, 0x064c222e,
-	0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28, 0x09828428,
-	0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028, 0x0a00ba2a,
-	0x080c2440, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
-	0x02828b28, 0x09828428, 0x07801ded, 0x095e1a2d, 0x06090628,
-	0x068c5828, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06860828,
-	0x02c28aa8, 0x09441a30, 0x06090628, 0x06900028, 0x0a00ba2a,
-	0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068,
-	0x02828b28, 0x09828428, 0x07801dad, 0x095e1a2d, 0x06090628,
-	0x06a00028, 0x0a00ba2a, 0x080c2450, 0x064c2228, 0x06090628,
-	0x09210a28, 0x09c28068, 0x02828b28, 0x09828428, 0x07801e2d,
-	0x095e1a2d, 0x06090628, 0x068ed868, 0x02c28aa8, 0x09441a30,
-	0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228, 0x060e152e,
-	0x060e152f, 0x060e1528, 0x0c780080, 0x060e1528, 0x0cc00000,
-	0x00000000, 0x07800028, 0x078016e9, 0x06800030, 0x09508a68,
-	0x0780016b, 0x0780026a, 0x04601aaa, 0x0c500c00, 0x0aa1416b,
-	0x00000000, 0x06800070, 0x0a61826b, 0x00000000, 0x078003a8,
-	0x04602a28, 0x0c500840, 0x0c7800c0, 0x0c780000, 0x00000000,
-	0x06490628, 0x0aefcc28, 0x06b000a8, 0x09441a30, 0x06090628,
-	0x06090629, 0x069fffeb, 0x06900028, 0x080c2400, 0x080e1424,
-	0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x09210a68, 0x06090628, 0x02828ae9, 0x06090628, 0x080c2440,
-	0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
-	0x06b8d068, 0x09441a30, 0x0c781340, 0x06090628, 0x06b0002a,
-	0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9, 0x0c781180,
-	0x06031e2b, 0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0c7ff5c0,
-	0x00000000, 0x06490628, 0x0aefcc28, 0x06b408a8, 0x09441a30,
-	0x06090628, 0x06090629, 0x069fffec, 0x06900028, 0x080c2400,
+	0x044011c7, 0x06808048, 0x02007207, 0x074001c9, 0x0cc00000,
+	0x07c08009, 0x0681f409, 0x04401249, 0x0aefc009, 0x00000000,
+	0x083f0040, 0x083f0000, 0x08090b65, 0x00000000, 0x08090b60,
+	0x06498e07, 0x09807007, 0x068007c9, 0x097051c9, 0x06098e07,
+	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x06800009,
+	0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187,
+	0x09807207, 0x060c0007, 0x064c0807, 0x09807347, 0x060c0807,
+	0x083f0040, 0x083f0000, 0x08090b65, 0x0cc00000, 0x08090b60,
+	0x0680001f, 0x07c0149f, 0x07c014df, 0x07c0151f, 0x064c091f,
+	0x07c0175f, 0x07c0005f, 0x06800020, 0x06803fc2, 0x07c01542,
+	0x07c01582, 0x07c015c2, 0x07c01602, 0x060c091f, 0x080c0101,
+	0x080c2901, 0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226,
+	0x024269e6, 0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726,
+	0x0649cf31, 0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207,
+	0x092101c7, 0x0401f287, 0x0580528a, 0x0403e247, 0x05806249,
+	0x09610289, 0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7,
+	0x058041c7, 0x060c0907, 0x07c00987, 0x04401247, 0x07c00609,
+	0x05404287, 0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208,
+	0x05804208, 0x07c009c8, 0x05404208, 0x0961020a, 0x06090808,
+	0x0809c300, 0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803,
+	0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800,
+	0x07801502, 0x0aa0c002, 0x06800102, 0x06030502, 0x064c0002,
+	0x0be14042, 0x0ba1d025, 0x06800102, 0x07c01502, 0x08030504,
+	0x06800025, 0x0cc00000, 0x00000000, 0x078001c2, 0x0aa1c002,
+	0x078016c2, 0x078009c3, 0x0a4040c2, 0x00000000, 0x06800102,
+	0x06030502, 0x0cc00000, 0x00000000, 0x0fc02240, 0x0aa4c009,
+	0x0680000a, 0x0b6180c9, 0x0680010a, 0x0fc01280, 0x09422289,
+	0x0c780140, 0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a,
+	0x06800049, 0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a,
+	0x05401249, 0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000,
+	0x0fc01240, 0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e56c0,
+	0x00000000, 0x06490628, 0x0aefcc28, 0x00000000, 0x07800028,
+	0x078016e9, 0x09508a68, 0x068000a8, 0x06c00028, 0x06090628,
+	0x06090629, 0x06881068, 0x06090628, 0x0cc00000, 0x00000000,
+	0x06490628, 0x0aefcc28, 0x06c00028, 0x069001a8, 0x069fffea,
+	0x06090628, 0x06090629, 0x05401a23, 0x06090628, 0x09210a23,
+	0x05401a28, 0x02828aa8, 0x06090628, 0x06985168, 0x0c782700,
+	0x06090628, 0x078003e8, 0x0a6fc028, 0x07800028, 0x078016e9,
+	0x06800030, 0x09508a68, 0x0780016b, 0x07801d2a, 0x04601aaa,
+	0x0c500ec0, 0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b,
+	0x0aa883eb, 0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb,
+	0x06c0002a, 0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb,
+	0x0c500980, 0x0690002a, 0x0c7e4f00, 0x00000000, 0x06490628,
+	0x0aefcc28, 0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x06090629, 0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400,
+	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
+	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
+	0x06a00028, 0x0a007a2a, 0x080c2440, 0x064c2228, 0x09210a68,
+	0x06090628, 0x02828ae9, 0x06090628, 0x0688d068, 0x02c28aa8,
+	0x09441a30, 0x0c781780, 0x06090628, 0x09441ab0, 0x06031f2a,
+	0x0680016b, 0x09510ae9, 0x0c781600, 0x06031e2b, 0x0aa241eb,
+	0x06a0002a, 0x0aa1c1ab, 0x06b0002a, 0x0aa1416b, 0x0aa1026b,
+	0x06800070, 0x0690002a, 0x06800030, 0x06490628, 0x0aefcc28,
+	0x06c0002a, 0x068408a8, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x06090629, 0x069fffec, 0x06900028, 0x0a00ba2a, 0x080c2400,
 	0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28,
-	0x09828428, 0x078017ad, 0x095e1a2d, 0x06090628, 0x080c2440,
-	0x064c2228, 0x06090628, 0x09210a28, 0x09c28068, 0x02828b28,
-	0x09828428, 0x06090628, 0x06bc5828, 0x09441a30, 0x06090628,
-	0x06b60828, 0x09441a30, 0x06090628, 0x06900028, 0x080c2410,
-	0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28,
-	0x09828428, 0x078017ad, 0x05801b6d, 0x095e1a2d, 0x06090628,
-	0x080c2450, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
-	0x02828b28, 0x09828428, 0x098283e8, 0x06090628, 0x06bed868,
+	0x09828428, 0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028,
+	0x0a00ba2a, 0x080c2440, 0x064c2228, 0x06090628, 0x09210a28,
+	0x09c28068, 0x02828b28, 0x09828428, 0x07801ded, 0x095e1a2d,
+	0x06090628, 0x068c5828, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x06860828, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06900028,
+	0x0a00ba2a, 0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f,
+	0x09c28068, 0x02828b28, 0x09828428, 0x07801dad, 0x095e1a2d,
+	0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2450, 0x064c2228,
+	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
+	0x07801e2d, 0x095e1a2d, 0x06090628, 0x068ed868, 0x02c28aa8,
 	0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228,
-	0x060e152e, 0x060e152f, 0x060e1528, 0x060e1528, 0x0cc00000,
-	0x00000000, 0x064e1215, 0x091e1555, 0x0a208055, 0x0c782300,
-	0x0649d915, 0x0900c555, 0x0a6f8015, 0x00000000, 0x078003d5,
-	0x0aa08055, 0x0c780940, 0x07800596, 0x0aa1c016, 0x04401596,
-	0x07c00596, 0x078005d6, 0x04401596, 0x0c7814c0, 0x07c005d6,
-	0x07800916, 0x07800295, 0x05408555, 0x02015595, 0x04003596,
-	0x07c00916, 0x05404595, 0x02016c56, 0x060e1316, 0x07800517,
-	0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416, 0x069fffd7,
-	0x044015d7, 0x0aa1c017, 0x00000000, 0x064e1615, 0x09010555,
-	0x0aaec015, 0x04401555, 0x060e1615, 0x06c00016, 0x060e1216,
-	0x06800095, 0x0c781880, 0x07c003d5, 0x0a660095, 0x078005d6,
-	0x0aa18016, 0x04401596, 0x0b210056, 0x07c005d6, 0x0c780bc0,
-	0x00000000, 0x07800956, 0x07800295, 0x05408555, 0x02015595,
+	0x060e152e, 0x060e152f, 0x060e1528, 0x0c780080, 0x060e1528,
+	0x0cc00000, 0x00000000, 0x07800028, 0x078016e9, 0x06800030,
+	0x09508a68, 0x0780016b, 0x0780026a, 0x04601aaa, 0x0c500c00,
+	0x0aa1416b, 0x00000000, 0x06800070, 0x0a61826b, 0x00000000,
+	0x078003a8, 0x04602a28, 0x0c500840, 0x0c7800c0, 0x0c780000,
+	0x00000000, 0x06490628, 0x0aefcc28, 0x06b000a8, 0x09441a30,
+	0x06090628, 0x06090629, 0x069fffeb, 0x06900028, 0x080c2400,
+	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
+	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
+	0x080c2440, 0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9,
+	0x06090628, 0x06b8d068, 0x09441a30, 0x0c781340, 0x06090628,
+	0x06b0002a, 0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9,
+	0x0c781180, 0x06031e2b, 0x0aa1416b, 0x0aa1026b, 0x06800070,
+	0x0c7ff5c0, 0x00000000, 0x06490628, 0x0aefcc28, 0x06b408a8,
+	0x09441a30, 0x06090628, 0x06090629, 0x069fffec, 0x06900028,
+	0x080c2400, 0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068,
+	0x02828b28, 0x09828428, 0x078017ad, 0x095e1a2d, 0x06090628,
+	0x080c2440, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
+	0x02828b28, 0x09828428, 0x06090628, 0x06bc5828, 0x09441a30,
+	0x06090628, 0x06b60828, 0x09441a30, 0x06090628, 0x06900028,
+	0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068,
+	0x02828b28, 0x09828428, 0x078017ad, 0x05801b6d, 0x095e1a2d,
+	0x06090628, 0x080c2450, 0x064c2228, 0x06090628, 0x09210a28,
+	0x09c28068, 0x02828b28, 0x09828428, 0x098283e8, 0x06090628,
+	0x06bed868, 0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424,
+	0x064c2228, 0x060e152e, 0x060e152f, 0x060e1528, 0x060e1528,
+	0x0cc00000, 0x00000000, 0x064e1215, 0x091e1555, 0x0a208055,
+	0x0c782300, 0x0649d915, 0x0900c555, 0x0a6f8015, 0x00000000,
+	0x078003d5, 0x0aa08055, 0x0c780940, 0x07800596, 0x0aa1c016,
+	0x04401596, 0x07c00596, 0x078005d6, 0x04401596, 0x0c7814c0,
+	0x07c005d6, 0x07800916, 0x07800295, 0x05408555, 0x02015595,
+	0x04003596, 0x07c00916, 0x05404595, 0x02016c56, 0x060e1316,
+	0x07800517, 0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416,
+	0x069fffd7, 0x044015d7, 0x0aa1c017, 0x00000000, 0x064e1615,
+	0x09010555, 0x0aaec015, 0x04401555, 0x060e1615, 0x06c00016,
+	0x060e1216, 0x06800095, 0x0c781880, 0x07c003d5, 0x0a660095,
+	0x078005d6, 0x0aa18016, 0x04401596, 0x0b210056, 0x07c005d6,
+	0x0c780bc0, 0x00000000, 0x07800956, 0x07800295, 0x05408555,
+	0x02015595, 0x04003596, 0x07c00956, 0x05404595, 0x02016c56,
+	0x060e1316, 0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215,
+	0x068000d5, 0x0c781280, 0x07c003d5, 0x0aa080d5, 0x0c780700,
+	0x07800516, 0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417,
+	0x07800795, 0x07c00755, 0x0683ffd5, 0x064e1516, 0x0900c5d6,
+	0x0a40b5d5, 0x091845d6, 0x07c00797, 0x064e1516, 0x064e1516,
+	0x064e1516, 0x080c24e0, 0x060c2216, 0x064e1516, 0x0c780200,
+	0x060c2216, 0x068000d6, 0x07c00796, 0x06800016, 0x080c24e0,
+	0x060c2216, 0x060c2216, 0x0aa080a0, 0x0c780a00, 0x078003d5,
+	0x0a644115, 0x07800956, 0x068ac015, 0x05408555, 0x02015595,
 	0x04003596, 0x07c00956, 0x05404595, 0x02016c56, 0x060e1316,
-	0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215, 0x068000d5,
-	0x0c781280, 0x07c003d5, 0x0aa080d5, 0x0c780700, 0x07800516,
-	0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417, 0x07800795,
-	0x07c00755, 0x0683ffd5, 0x064e1516, 0x0900c5d6, 0x0a40b5d5,
-	0x091845d6, 0x07c00797, 0x064e1516, 0x064e1516, 0x064e1516,
-	0x080c24e0, 0x060c2216, 0x064e1516, 0x0c780200, 0x060c2216,
-	0x068000d6, 0x07c00796, 0x06800016, 0x080c24e0, 0x060c2216,
-	0x060c2216, 0x0aa080a0, 0x0c780a00, 0x078003d5, 0x0a644115,
-	0x07800956, 0x068ac015, 0x05408555, 0x02015595, 0x04003596,
-	0x07c00956, 0x05404595, 0x02016c56, 0x060e1316, 0x06a16015,
-	0x09c151d5, 0x06c00015, 0x060e1215, 0x06800195, 0x0c780640,
-	0x07c003d5, 0x0aa0c195, 0x0c780500, 0x00000000, 0x06431e18,
-	0x0befc058, 0x064e1418, 0x080e1400, 0x064e1516, 0x0683ffd5,
-	0x0900c5d6, 0x09203656, 0x0a8045d5, 0x091845d6, 0x068000d7,
-	0x06800019, 0x07c004d7, 0x090015d9, 0x07c00497, 0x090225d9,
-	0x07c01117, 0x060e1418, 0x06800015, 0x07c003d5, 0x0cc00000,
-	0x00400000, 0x06800047, 0x07c003c7, 0x07800507, 0x050011c7,
-	0x07c00507, 0x064e1608, 0x09010208, 0x04001208, 0x060e1608,
-	0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408, 0x06b7ffc7,
-	0x06c00007, 0x060e1507, 0x060e1524, 0x060e1524, 0x060e1524,
-	0x060e1524, 0x0cc00000, 0x08030580, 0x078003c7, 0x0a6fc007,
-	0x07800447, 0x0aa0c0c7, 0x0aa98347, 0x0a638107, 0x07800507,
-	0x050011c7, 0x07c00507, 0x06800047, 0x07c003c7, 0x080c24e0,
-	0x064c2207, 0x064c2208, 0x080c24c0, 0x060c2207, 0x060c2208,
-	0x0cc00000, 0x08030580, 0x06800047, 0x07c003c7, 0x07800507,
-	0x050011c7, 0x07c00507, 0x080e1424, 0x064e1509, 0x064e150a,
-	0x064e150b, 0x064e150c, 0x0aa0c007, 0x06800008, 0x06800308,
-	0x060e1408, 0x0683ffc7, 0x07800448, 0x095841c8, 0x07800308,
-	0x096031c8, 0x060e1507, 0x060e1509, 0x060e150a, 0x060e150b,
-	0x060e150c, 0x0cc00000, 0x08030580, 0x07800987, 0x078009c8,
-	0x06800009, 0x0d000008, 0x020091c9, 0x04401249, 0x06800047,
-	0x0ba10089, 0x05801249, 0x0c7fff80, 0x040011c7, 0x0cc00000,
-	0x07c00687, 0x06800208, 0x064c3b07, 0x091031c7, 0x024071c8,
-	0x0f8001c7, 0x0fc0f1c0, 0x064c0e07, 0x040011c7, 0x0f8001c7,
-	0x07800687, 0x0f8001c7, 0x0fc051c0, 0x0c073dc0, 0x07c00107,
-	0x0fc011c0, 0x0aa0c007, 0x0c000640, 0x00000000, 0x078002c7,
-	0x07801988, 0x094c11c8, 0x0c0736c0, 0x060e0407, 0x06800007,
-	0x07c01cc7, 0x078005c7, 0x0b210087, 0x07800988, 0x04002208,
-	0x024081c8, 0x07800947, 0x04401208, 0x02007207, 0x05401208,
-	0x02007207, 0x07c00947, 0x07800987, 0x040011c7, 0x07c005c7,
-	0x0cc00000, 0x00000000, 0x0fc011c0, 0x0a600007, 0x0fc011c0,
-	0x07801408, 0x0f8001c8, 0x0fc011c0, 0x0fc021c0, 0x0fc03200,
-	0x0aa10007, 0x0aa0c047, 0x0fc03200, 0x0fc03200, 0x0cc00000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x06a16015, 0x09c151d5, 0x06c00015, 0x060e1215, 0x06800195,
+	0x0c780640, 0x07c003d5, 0x0aa0c195, 0x0c780500, 0x00000000,
+	0x06431e18, 0x0befc058, 0x064e1418, 0x080e1400, 0x064e1516,
+	0x0683ffd5, 0x0900c5d6, 0x09203656, 0x0a8045d5, 0x091845d6,
+	0x068000d7, 0x06800019, 0x07c004d7, 0x090015d9, 0x07c00497,
+	0x090225d9, 0x07c01117, 0x060e1418, 0x06800015, 0x07c003d5,
+	0x0cc00000, 0x00400000, 0x06800047, 0x07c003c7, 0x07800507,
+	0x050011c7, 0x07c00507, 0x064e1608, 0x09010208, 0x04001208,
+	0x060e1608, 0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408,
+	0x06b7ffc7, 0x06c00007, 0x060e1507, 0x060e1524, 0x060e1524,
+	0x060e1524, 0x060e1524, 0x0cc00000, 0x08030580, 0x078003c7,
+	0x0a6fc007, 0x07800447, 0x0aa0c0c7, 0x0aa98347, 0x0a638107,
+	0x07800507, 0x050011c7, 0x07c00507, 0x06800047, 0x07c003c7,
+	0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0, 0x060c2207,
+	0x060c2208, 0x0cc00000, 0x08030580, 0x06800047, 0x07c003c7,
+	0x07800507, 0x050011c7, 0x07c00507, 0x080e1424, 0x064e1509,
+	0x064e150a, 0x064e150b, 0x064e150c, 0x0aa0c007, 0x06800008,
+	0x06800308, 0x060e1408, 0x0683ffc7, 0x07800448, 0x095841c8,
+	0x07800308, 0x096031c8, 0x060e1507, 0x060e1509, 0x060e150a,
+	0x060e150b, 0x060e150c, 0x0cc00000, 0x08030580, 0x07800987,
+	0x078009c8, 0x06800009, 0x0d000008, 0x020091c9, 0x04401249,
+	0x06800047, 0x0ba10089, 0x05801249, 0x0c7fff80, 0x040011c7,
+	0x0cc00000, 0x07c00687, 0x06800208, 0x064c3b07, 0x091031c7,
+	0x024071c8, 0x0f8001c7, 0x0fc0f1c0, 0x064c0e07, 0x040011c7,
+	0x0f8001c7, 0x07800687, 0x0f8001c7, 0x0fc051c0, 0x0c073d80,
+	0x07c00107, 0x0fc011c0, 0x0aa0c007, 0x0c000640, 0x00000000,
+	0x078002c7, 0x07801988, 0x094c11c8, 0x0c073680, 0x060e0407,
+	0x06800007, 0x07c01cc7, 0x078005c7, 0x0b210087, 0x07800988,
+	0x04002208, 0x024081c8, 0x07800947, 0x04401208, 0x02007207,
+	0x05401208, 0x02007207, 0x07c00947, 0x07800987, 0x040011c7,
+	0x07c005c7, 0x0cc00000, 0x00000000, 0x0fc011c0, 0x0a600007,
+	0x0fc011c0, 0x07801408, 0x0f8001c8, 0x0fc011c0, 0x0fc021c0,
+	0x0fc03200, 0x0aa10007, 0x0aa0c047, 0x0fc03200, 0x0fc03200,
+	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1276,505 +1276,513 @@ const u32 __initconst vmpeg4_mc_5[] = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x06bff7c0, 0x06032400, 0x00400000, 0x0c780000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x06bff7c0, 0x06032400, 0x00400000,
+	0x0c780000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x0cc00000, 0x00400000,
-	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0cc00000, 0x00400000, 0x0c780200, 0x06431e07,
-	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x09027207, 0x0a654048, 0x068fdfca, 0x06feffca,
-	0x064e0408, 0x02808288, 0x09108287, 0x0ba0c08a, 0x064c0909,
-	0x098083c8, 0x0ac0424a, 0x09208287, 0x0a60c00a, 0x0400128a,
-	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x0c780d40,
-	0x060e0408, 0x0c780cc0, 0x00000000, 0x0a6f8088, 0x0680002c,
-	0x080e1424, 0x09110a47, 0x06431f2a, 0x069fffeb, 0x06490628,
-	0x0aefcc28, 0x05404a2c, 0x060c2428, 0x068010a8, 0x02c28aa8,
-	0x09462a2c, 0x06090628, 0x06090629, 0x064c2228, 0x060e1528,
-	0x09210b68, 0x06090628, 0x02828aed, 0x06090628, 0x06a00028,
-	0x0a009a2a, 0x05404a2c, 0x098281a8, 0x060c2428, 0x064c2228,
-	0x09210b68, 0x06090628, 0x02828aed, 0x06090628, 0x0ba9c0ec,
-	0x04001b2c, 0x06881068, 0x02c28aa8, 0x06090628, 0x080c2480,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0c780200,
+	0x06431e07, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x09027207, 0x0a654048, 0x068fdfca,
+	0x06feffca, 0x064e0408, 0x02808288, 0x09108287, 0x0ba0c08a,
+	0x064c0909, 0x098083c8, 0x0ac0424a, 0x09208287, 0x0a60c00a,
+	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
+	0x0c780d40, 0x060e0408, 0x0c780cc0, 0x00000000, 0x0a6f8088,
+	0x0680002c, 0x080e1424, 0x09110a47, 0x06431f2a, 0x069fffeb,
+	0x06490628, 0x0aefcc28, 0x05404a2c, 0x060c2428, 0x068010a8,
+	0x02c28aa8, 0x09462a2c, 0x06090628, 0x06090629, 0x064c2228,
+	0x060e1528, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
+	0x06a00028, 0x0a009a2a, 0x05404a2c, 0x098281a8, 0x060c2428,
 	0x064c2228, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
-	0x06a00028, 0x0a006a2a, 0x064c2228, 0x09210b68, 0x06090628,
-	0x02828aed, 0x06090628, 0x08031e00, 0x0cc00000, 0x00400000
+	0x0ba9c0ec, 0x04001b2c, 0x06881068, 0x02c28aa8, 0x06090628,
+	0x080c2480, 0x064c2228, 0x09210b68, 0x06090628, 0x02828aed,
+	0x06090628, 0x06a00028, 0x0a006a2a, 0x064c2228, 0x09210b68,
+	0x06090628, 0x02828aed, 0x06090628, 0x08031e00, 0x0cc00000,
+	0x00400000
 };
 
 const u32 __initconst vmpeg4_mc_311[] = {
-	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c00b7c0, 0x00000000,
-	0x00000000, 0x00000000, 0x080c0002, 0x080c2903, 0x06bfde80,
-	0x07c017c0, 0x06030400, 0x00400000, 0x0c015300, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
+	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c00b7c0,
+	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x080c2903,
+	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c015300,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0c7ffe80, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x0c780400, 0x04001965, 0x0cc00000, 0x00400000,
-	0x0c780480, 0x064c0007, 0x0c795840, 0x06800025, 0x0cc00000,
-	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
-	0x0c798740, 0x00000000, 0x0cc00000, 0x00400000, 0x00800000,
-	0x078017c9, 0x0c7fff00, 0x06030409, 0x06bfdd89, 0x06030409,
-	0x00400000, 0x07801509, 0x0aa14009, 0x0a608049, 0x0c788d80,
-	0x0a608089, 0x0c7885c0, 0x0be0c807, 0x0c780980, 0x00000000,
-	0x0c785840, 0x00000000, 0x0681f409, 0x04401249, 0x0aefc009,
-	0x00000000, 0x083f0040, 0x083f0000, 0x08090703, 0x08090700,
-	0x06498e07, 0x09807007, 0x068007c9, 0x097051c9, 0x06098e07,
-	0x0681f409, 0x04401249, 0x0aefc009, 0x00000000, 0x06800009,
-	0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187,
-	0x09807207, 0x060c0007, 0x064c0807, 0x09807347, 0x060c0807,
-	0x083f0040, 0x083f0000, 0x08090703, 0x08090700, 0x0c789d00,
-	0x00000000, 0x0a20d007, 0x0c7ff700, 0x00000000, 0x07800247,
-	0x0aa10147, 0x040011c7, 0x0c7824c0, 0x07c00247, 0x07800007,
-	0x07800988, 0x0b83f207, 0x0c00b180, 0x06800007, 0x07c00007,
-	0x07800087, 0x0a618047, 0x06a00008, 0x07c00c08, 0x07c00c48,
-	0x07c03988, 0x07c039c8, 0x078025c8, 0x04001208, 0x078009c9,
-	0x0b815248, 0x07c025c8, 0x07800088, 0x0a644008, 0x00000000,
-	0x0fc05200, 0x0a624008, 0x06800147, 0x0fc01200, 0x0aafc008,
-	0x040011c7, 0x0ba245c7, 0x06800007, 0x0c784600, 0x07c02647,
-	0x0fc0b200, 0x0aae0008, 0x06800407, 0x0fc01200, 0x07c02648,
-	0x0c789180, 0x07800048, 0x04001208, 0x07802587, 0x0b8191c8,
-	0x07c00048, 0x078002c7, 0x07801988, 0x094c11c8, 0x060e0407,
-	0x078003c7, 0x0a6fc007, 0x0c00a840, 0x00000000, 0x0c00a5c0,
-	0x06800007, 0x07c01cc7, 0x07c01bc7, 0x07800947, 0x07800988,
-	0x04401208, 0x07c005c8, 0x02007207, 0x05401208, 0x02007207,
-	0x07c00947, 0x06800007, 0x0c780080, 0x07c00047, 0x06800007,
-	0x07c00247, 0x07800087, 0x0aa3c007, 0x080c2805, 0x07802547,
-	0x0aa2c007, 0x080c2800, 0x0fc011c0, 0x0aa20007, 0x06800347,
-	0x07c00147, 0x06800007, 0x07c01387, 0x07c00a07, 0x0c7806c0,
-	0x07c00207, 0x080c2806, 0x064c2807, 0x0a2fc047, 0x058011c7,
-	0x0ba11007, 0x06800049, 0x06800009, 0x044401c7, 0x07800088,
-	0x0a610008, 0x07c01387, 0x0c00c440, 0x00000000, 0x0a60c009,
-	0x068000c8, 0x06800008, 0x07c00148, 0x080c2800, 0x07c00a09,
-	0x07c00209, 0x0aa0c0c8, 0x0a610108, 0x06800007, 0x0fc011c0,
-	0x07c00207, 0x07801388, 0x060c2b08, 0x07800148, 0x0aa20008,
-	0x0aa1c188, 0x0aa18208, 0x0aa14048, 0x06800009, 0x07c00a49,
-	0x0c7805c0, 0x07c00a89, 0x07802509, 0x0aa0c009, 0x080c280b,
-	0x080c280c, 0x064c2807, 0x0a2fc047, 0x058011c7, 0x06820809,
-	0x0a806247, 0x090c6247, 0x07c00a49, 0x09006247, 0x0c780240,
-	0x07c00a89, 0x080c2800, 0x0fc061c0, 0x044201c7, 0x07c00a47,
-	0x0fc061c0, 0x044201c7, 0x07c00a87, 0x080c2800, 0x07800a09,
-	0x09421249, 0x07801cc8, 0x094a1248, 0x060c2c09, 0x07800a07,
-	0x0a60c007, 0x0c781200, 0x06800007, 0x07800247, 0x0ba0c107,
-	0x068001c7, 0x06800247, 0x07802448, 0x02008207, 0x060c2808,
-	0x064c2807, 0x0a2fc047, 0x058011c7, 0x080c2800, 0x0a65c1c8,
-	0x0b60cc07, 0x0c780cc0, 0x00000000, 0x0fc06200, 0x0b6f4388,
-	0x040281c8, 0x0ba24208, 0x0aae8208, 0x06800c87, 0x0aae0248,
-	0x06800c47, 0x0aad8348, 0x06800c07, 0x0c7809c0, 0x040291c8,
-	0x05401208, 0x0fc011c0, 0x09401207, 0x0babc3c8, 0x040681c8,
-	0x0c780800, 0x0fc081c0, 0x0a640208, 0x0ba75107, 0x00000000,
-	0x0fc05200, 0x0aa68688, 0x0b6646c8, 0x040301c8, 0x0b65c508,
-	0x040311c8, 0x05401208, 0x0fc011c0, 0x09401207, 0x0ba489c8,
-	0x040501c8, 0x0c780400, 0x0fc081c0, 0x0aa08248, 0x0a634288,
-	0x0ba30c07, 0x00000000, 0x0fc06200, 0x0b624208, 0x040281c8,
-	0x05401208, 0x0fc011c0, 0x09401207, 0x0ba103c8, 0x040681c8,
-	0x0c780080, 0x0fc081c0, 0x0aa18007, 0x00000000, 0x0fc01200,
-	0x0aa0c008, 0x06800008, 0x024071c8, 0x07800209, 0x0540e249,
-	0x07800248, 0x0ba18108, 0x0b624148, 0x060c2d09, 0x0940d247,
-	0x0c780200, 0x098093c9, 0x0960d247, 0x098097c9, 0x0c780140,
-	0x060c2d09, 0x0960d247, 0x098097c9, 0x060c2f09, 0x07800249,
-	0x0a62c009, 0x064e0408, 0x07800107, 0x09605207, 0x096a5207,
-	0x060e0408, 0x06880008, 0x098083c8, 0x07800507, 0x09581207,
-	0x060e0508, 0x07800249, 0x07800a08, 0x0aa14008, 0x09809249,
-	0x09c09249, 0x0ba10109, 0x078024c8, 0x07802488, 0x05403208,
-	0x09466248, 0x07800bc8, 0x09541248, 0x060c2a09, 0x07800247,
-	0x0a644007, 0x068fdfc7, 0x064e0408, 0x06ffffc7, 0x028081c8,
-	0x07800047, 0x0a60c007, 0x07800007, 0x098083c8, 0x0a60c007,
-	0x040011c7, 0x09808388, 0x07800989, 0x0b803247, 0x00000000,
-	0x098081c8, 0x060e0408, 0x07800247, 0x0a60c007, 0x0c015500,
-	0x00000000, 0x080c0080, 0x07800247, 0x0a6340c7, 0x07800147,
-	0x0aa340c7, 0x0aa30107, 0x0aa0c3c7, 0x0c005fc0, 0x00000000,
-	0x0c010240, 0x00000000, 0x07800007, 0x040011c7, 0x0c015800,
-	0x07c00007, 0x0c7fa6c0, 0x00000000, 0x0c00fcc0, 0x00000000,
-	0x06800009, 0x07c00a49, 0x07c00a89, 0x07c00c09, 0x07c03989,
-	0x07c00c49, 0x0c7ffc80, 0x07c039c9, 0x0fc081c0, 0x0b2187c7,
-	0x0b21cbc7, 0x0aa16c87, 0x0a60ad87, 0x0c780900, 0x0c784bc0,
-	0x0c784b80, 0x0c784b40, 0x00000000, 0x0fc0c1c0, 0x0fc0c200,
-	0x06811009, 0x0b002248, 0x0c7fa480, 0x04000248, 0x09610247,
-	0x0609c709, 0x0400f1c7, 0x058041c7, 0x060c0907, 0x07c00987,
-	0x04401247, 0x07c00609, 0x05404287, 0x0400f208, 0x05804208,
-	0x07c009c8, 0x05404208, 0x0961020a, 0x06090808, 0x06800007,
-	0x07c01c07, 0x07c01d07, 0x060c0307, 0x07c01987, 0x07c01a07,
-	0x0c784400, 0x00000000, 0x0c780000, 0x00000000, 0x064c5126,
-	0x064c4627, 0x07802b88, 0x05410208, 0x07802b49, 0x02008248,
-	0x0580a208, 0x0e000988, 0x00000000, 0x00000000, 0x00000000,
-	0x0f000200, 0x0f010980, 0x09708226, 0x0540a208, 0x020089c8,
-	0x064c4326, 0x02408988, 0x064c4026, 0x02408988, 0x07c02bc8,
-	0x05810208, 0x07c02c08, 0x06800007, 0x07c00007, 0x07c00047,
-	0x068035c8, 0x07400207, 0x0bafffc8, 0x04001208, 0x07c00507,
-	0x07c025c7, 0x06800047, 0x07c00587, 0x07800607, 0x07c005c7,
-	0x0fc101c0, 0x0fc101c0, 0x0fc101c0, 0x0fc101c0, 0x0fc101c0,
-	0x0a61c007, 0x0fc101c0, 0x0a614007, 0x07802607, 0x040011c7,
-	0x0c783780, 0x07c02607, 0x0fc021c0, 0x07c00087, 0x07800308,
-	0x0b624088, 0x0aa18087, 0x0aa08007, 0x0aa10008, 0x04001208,
-	0x0c780100, 0x07c00308, 0x0c783480, 0x00000000, 0x06800023,
-	0x06800024, 0x0a60c087, 0x068ac008, 0x068ae008, 0x07c00288,
-	0x07800087, 0x0a624047, 0x06800047, 0x07802647, 0x0aa18007,
-	0x06800007, 0x06490707, 0x0a20c087, 0x00000000, 0x06800007,
-	0x07c01b07, 0x0fc051c0, 0x0c00aec0, 0x07c00107, 0x0c006b00,
-	0x00000000, 0x07800087, 0x0a618087, 0x078003c7, 0x0a6fc007,
-	0x06800107, 0x07c003c7, 0x08030580, 0x07800087, 0x0a648007,
-	0x00000000, 0x0fc051c0, 0x07c02407, 0x0aa105c7, 0x069fffc7,
-	0x078009c7, 0x058011c7, 0x07c02587, 0x0c006900, 0x00000000,
-	0x07c02487, 0x0c006840, 0x00000000, 0x07c024c7, 0x0fc011c0,
-	0x0c780300, 0x07c02447, 0x0fc011c0, 0x07c02547, 0x0c006640,
-	0x00000000, 0x07c02487, 0x07c024c7, 0x0fc011c0, 0x07c02447,
-	0x0fc011c0, 0x07c02507, 0x06800025, 0x06490908, 0x0ae0c125,
-	0x0bef8048, 0x00000000, 0x06490b08, 0x09808008, 0x098080c8,
-	0x06090b08, 0x09c08008, 0x09c080c8, 0x06090b08, 0x0683ffc8,
-	0x0649bb07, 0x0900c1c7, 0x0aa10007, 0x0aa0c008, 0x0c7fff00,
-	0x04401208, 0x0649c909, 0x0aa10009, 0x06800087, 0x0c7f7680,
-	0x07c01507, 0x07801487, 0x0a608007, 0x0c780580, 0x044011c7,
-	0x0aa0c087, 0x07801549, 0x078015c9, 0x0ae441c9, 0x00000000,
-	0x040a41c9, 0x070001c7, 0x054101c7, 0x0409c209, 0x07000208,
-	0x094101c8, 0x0609cc07, 0x04081209, 0x07000208, 0x09464248,
-	0x09809209, 0x0609c909, 0x08007401, 0x06800009, 0x07c01489,
-	0x06800009, 0x07c01509, 0x07c02609, 0x078014c7, 0x02c07247,
-	0x07802c4a, 0x07802c88, 0x09610288, 0x0be0c047, 0x0c780a40,
-	0x06800008, 0x07802cca, 0x07802d08, 0x09610288, 0x0be0c087,
-	0x0c7808c0, 0x06800048, 0x07802d4a, 0x07802d88, 0x09610288,
-	0x0a278107, 0x06800088, 0x07802dca, 0x07802e08, 0x09610288,
-	0x0a264207, 0x068000c8, 0x07802e4a, 0x07802e88, 0x09610288,
-	0x0a250407, 0x06800108, 0x07802eca, 0x07802f08, 0x09610288,
-	0x0a23c807, 0x06800148, 0x07802f4a, 0x07802f88, 0x09610288,
-	0x0a229007, 0x06800188, 0x07802fca, 0x07803008, 0x09610288,
-	0x0a216007, 0x068001c8, 0x06800047, 0x0c7f6400, 0x07c01507,
-	0x07802007, 0x090041c7, 0x0a8061c8, 0x07800087, 0x0a620087,
-	0x07802007, 0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207,
-	0x0c7ff1c0, 0x02c091c9, 0x07802bc7, 0x0409c248, 0x07400247,
-	0x07802c07, 0x04008249, 0x07400247, 0x07800087, 0x098070c7,
-	0x04081248, 0x07400247, 0x06800047, 0x03407207, 0x078014c9,
-	0x02c091c9, 0x07c014c9, 0x0609b20a, 0x07800087, 0x04001247,
-	0x07c01489, 0x0a608087, 0x0c780340, 0x07801587, 0x07c015c7,
-	0x07c01588, 0x06499109, 0x06099009, 0x07802009, 0x05404249,
-	0x09404248, 0x07c02009, 0x0609910a, 0x0c7800c0, 0x00000000,
-	0x07c01548, 0x07801b07, 0x06800048, 0x06c00008, 0x09421207,
-	0x0c7f7640, 0x06090708, 0x064c0007, 0x0a2fc047, 0x00000000,
-	0x064c3a07, 0x090061c7, 0x0aaec647, 0x00000000, 0x080c2800,
-	0x080c0002, 0x0c7f5440, 0x00000000, 0x0649c007, 0x07c02c47,
-	0x058101c7, 0x07c02c87, 0x0649c107, 0x07c02cc7, 0x058101c7,
-	0x07c02d07, 0x0649c207, 0x07c02d47, 0x058101c7, 0x07c02d87,
-	0x0649c307, 0x07c02dc7, 0x058101c7, 0x07c02e07, 0x0649d007,
-	0x07c02e47, 0x058101c7, 0x07c02e87, 0x0649d107, 0x07c02ec7,
-	0x058101c7, 0x07c02f07, 0x0649d207, 0x07c02f47, 0x058101c7,
-	0x07c02f87, 0x0649d307, 0x07c02fc7, 0x058101c7, 0x07c03007,
-	0x0c008dc0, 0x00000000, 0x08002501, 0x08002605, 0x08002708,
-	0x08002815, 0x08002c14, 0x069fffc2, 0x07c02582, 0x0cc00000,
-	0x00000000, 0x07800a49, 0x0541a249, 0x05c1a249, 0x07c00a49,
-	0x07800a89, 0x0541a249, 0x05c1a249, 0x07c00a89, 0x0c001bc0,
-	0x00000000, 0x0cc00000, 0x00000000, 0x07800149, 0x0aa280c8,
-	0x0aa24108, 0x06800009, 0x07c00c09, 0x07c03989, 0x0680000f,
-	0x07c00c4f, 0x07c039cf, 0x0cc00000, 0x00000000, 0x0cc00000,
-	0x00000000, 0x0700024f, 0x0ba24047, 0x0900638f, 0x0aa1c00e,
-	0x0440134e, 0x04401387, 0x0340d38d, 0x090e938f, 0x0200e34e,
-	0x0400138e, 0x0a21100f, 0x06bfffcd, 0x0300e38d, 0x0400138e,
-	0x0cc00000, 0x0740024e, 0x06800d48, 0x04001208, 0x0bafcf48,
-	0x07400207, 0x07c03607, 0x07c035c7, 0x0cc00000, 0x00000000,
-	0x06a00007, 0x07c00c07, 0x07c00c47, 0x07c00c87, 0x07c00cc7,
-	0x07c00d07, 0x07c00d47, 0x078025c7, 0x0a618007, 0x06800007,
-	0x06803588, 0x04001208, 0x0baff7c8, 0x07400207, 0x0cc00000,
-	0x00000000, 0x07800007, 0x040011c7, 0x0780098a, 0x0b803287,
-	0x06a00007, 0x06a0000d, 0x0a40f1cf, 0x0a4091ce, 0x0a4051cd,
-	0x0680000f, 0x0680000e, 0x0c780500, 0x0680000d, 0x040003cd,
-	0x0c780440, 0x0400038d, 0x0a40f1cd, 0x0680000f, 0x040003ce,
-	0x0c780300, 0x0400034e, 0x0a4071ce, 0x0a4041cd, 0x0400038f,
-	0x0c7801c0, 0x0400034f, 0x0c780140, 0x0680000e, 0x0a4031cd,
-	0x00000000, 0x0680000d, 0x0b40438f, 0x040001ce, 0x0400038f,
-	0x040003c7, 0x0b4053cd, 0x040001cf, 0x0b40338d, 0x040001cd,
-	0x040001ce, 0x0cc00000, 0x00000000, 0x0200f1cf, 0x06bff00d,
-	0x0ac0434f, 0x0680100d, 0x0cc00000, 0x0200f34f, 0x0680100d,
-	0x0b40234f, 0x0cc00000, 0x0680100d, 0x0cc00000, 0x0240f34f,
-	0x078003c7, 0x0a6fc007, 0x07800147, 0x0aa10347, 0x07900c0f,
-	0x0c780140, 0x00000000, 0x07900a4f, 0x0c780200, 0x00000000,
-	0x07900c8e, 0x0c07efc0, 0x07900d0d, 0x0c07f9c0, 0x07900a4f,
-	0x07c00a4f, 0x07c00c0f, 0x0400024f, 0x07800147, 0x0aa10347,
-	0x07900c4f, 0x0c780140, 0x00000000, 0x07900a8f, 0x0c780200,
-	0x00000000, 0x07900cce, 0x0c07ebc0, 0x07900d4d, 0x0c07f5c0,
-	0x07900a8f, 0x07c00a8f, 0x07c00c4f, 0x0cc00000, 0x00000000,
-	0x060e0709, 0x091e13c7, 0x0aa1000f, 0x04000347, 0x0680000d,
-	0x0240d1cd, 0x060e060d, 0x0680000d, 0x064e060e, 0x0aa0c00f,
-	0x0580538e, 0x0240e38d, 0x0200e20e, 0x0aa0c008, 0x0cc00000,
-	0x0240d1ce, 0x09145349, 0x0240d349, 0x0954524d, 0x060e0709,
-	0x06800009, 0x064e060d, 0x0a60c00f, 0x0580534d, 0x0240d349,
-	0x0cc00000, 0x00000000, 0x0200a28f, 0x05c013ca, 0x0480128a,
-	0x0cc00000, 0x02c0f28f, 0x07801988, 0x094c11c8, 0x0c07dd40,
-	0x060e0407, 0x0c07dac0, 0x06800007, 0x07c01cc7, 0x07c01bc7,
-	0x07c00907, 0x0cc00000, 0x07c00947, 0x0fc011c0, 0x0aa18007,
-	0x06800047, 0x0fc011c0, 0x0aa0c007, 0x06800087, 0x06800107,
-	0x0cc00000, 0x00000000, 0x0780000f, 0x0580338f, 0x0680368d,
-	0x0200d38d, 0x0700034d, 0x048073cf, 0x054013cf, 0x0380d3cd,
-	0x0900234d, 0x054023cd, 0x07c0364f, 0x078035ce, 0x0a20810e,
-	0x0c781ec0, 0x0480c34f, 0x0a66000d, 0x07803608, 0x04814348,
-	0x0aa5000d, 0x05000207, 0x0a61c10d, 0x0be44807, 0x05000207,
-	0x0be3c407, 0x05008207, 0x0c780340, 0x0500c207, 0x0a61c40d,
-	0x0be28807, 0x0503c207, 0x0be20407, 0x05034207, 0x0c780180,
-	0x05030207, 0x0a60c50d, 0x0c7800c0, 0x0503c207, 0x06800008,
-	0x0c782f80, 0x0aa0810d, 0x0c7809c0, 0x07803608, 0x04814348,
-	0x0a61c00d, 0x0bee8807, 0x05000207, 0x0bee0207, 0x05010207,
-	0x0c7ffd80, 0x05014207, 0x0a62410d, 0x0be6c807, 0x05000207,
-	0x0ba10207, 0x0b60c607, 0x0c7805c0, 0x05018207, 0x0c780540,
-	0x0501c207, 0x0a62840d, 0x0a214807, 0x0be44207, 0x05028207,
-	0x0c7803c0, 0x0502c207, 0x0be34407, 0x05034207, 0x0c7802c0,
-	0x05030207, 0x0a62050d, 0x0a214807, 0x0be1c207, 0x05028207,
-	0x0c780140, 0x0502c207, 0x0c7800c0, 0x0503c207, 0x06800008,
-	0x0c782580, 0x0aa0820d, 0x0c780800, 0x07803608, 0x04814348,
-	0x0aa5400d, 0x0a62810d, 0x0a214807, 0x0be64407, 0x05030207,
-	0x0c7805c0, 0x05034207, 0x0be54207, 0x0502c207, 0x0c7804c0,
-	0x05028207, 0x0a62440d, 0x0be40807, 0x0503c207, 0x0ba10207,
-	0x0b60c607, 0x0c780300, 0x05024207, 0x0c780280, 0x05020207,
-	0x0a61c50d, 0x0be1c807, 0x0503c207, 0x0be14207, 0x0502c207,
-	0x0c7800c0, 0x05028207, 0x06800008, 0x0c781d40, 0x0a66030d,
-	0x07803608, 0x04814348, 0x0aa4400d, 0x0a62010d, 0x0a214807,
-	0x0be44407, 0x05030207, 0x0c7803c0, 0x05034207, 0x0c780340,
-	0x0503c207, 0x0a61c40d, 0x0be28807, 0x0503c207, 0x0be20407,
-	0x05034207, 0x0c780180, 0x05030207, 0x0a60c50d, 0x0c7800c0,
-	0x0503c207, 0x06800008, 0x0c781740, 0x0480c34f, 0x0a64800d,
-	0x07803608, 0x04814348, 0x0aa2c00d, 0x0a60810d, 0x0c7fe1c0,
-	0x0a61c40d, 0x0a228807, 0x05000207, 0x0be20407, 0x0500c207,
-	0x0c780180, 0x05008207, 0x0a60c50d, 0x0c7800c0, 0x05000207,
-	0x06800008, 0x0c781280, 0x0aa0810d, 0x0c780680, 0x07803608,
-	0x04814348, 0x0a60800d, 0x0c7fe300, 0x0a60810d, 0x0c7fe440,
-	0x0a62840d, 0x0a214807, 0x0be40407, 0x0500c207, 0x0c780380,
-	0x05008207, 0x0be30207, 0x05010207, 0x0c780280, 0x05014207,
-	0x0a61c50d, 0x0be1c807, 0x05000207, 0x0be14207, 0x05010207,
-	0x0c7800c0, 0x05014207, 0x06800008, 0x0c780bc0, 0x0aa0820d,
-	0x0c780680, 0x07803608, 0x04814348, 0x0a61c00d, 0x0a254807,
-	0x05000207, 0x0be4c207, 0x05014207, 0x0c780440, 0x05010207,
-	0x0a62810d, 0x0a214807, 0x0be34207, 0x05014207, 0x0c7802c0,
-	0x05010207, 0x0be24407, 0x05008207, 0x0c7801c0, 0x0500c207,
-	0x0a60840d, 0x0c7fe4c0, 0x0a60850d, 0x0c7fe680, 0x06800008,
-	0x0c780500, 0x0a64c30d, 0x07803608, 0x04814348, 0x0aa3c00d,
-	0x05000207, 0x0a61c10d, 0x0be30807, 0x05000207, 0x0be28407,
-	0x05008207, 0x0c780200, 0x0500c207, 0x0a60840d, 0x0c7fe7c0,
-	0x0a60c50d, 0x0c7800c0, 0x0503c207, 0x06800008, 0x0c780040,
-	0x07c035cf, 0x07c03608, 0x07c01388, 0x05802208, 0x0780000f,
-	0x0580338f, 0x0680368d, 0x0200d38d, 0x0700034e, 0x048073cf,
-	0x054013cf, 0x038073ce, 0x094021c8, 0x034073c7, 0x06800048,
-	0x034083c8, 0x04401208, 0x02808388, 0x02c0e207, 0x0cc00000,
-	0x0740034e, 0x060c0a07, 0x078000c8, 0x0aa24008, 0x06800009,
-	0x0aa1c1c8, 0x06800049, 0x05401247, 0x0400b249, 0x0b403247,
-	0x06800049, 0x06800009, 0x07c00bc9, 0x0b218107, 0x0ae08207,
-	0x0c780ec0, 0x0b218607, 0x0c780980, 0x00000000, 0x06a02009,
-	0x0c781140, 0x06820207, 0x0aa7c247, 0x068f1749, 0x0aa74287,
-	0x068e5749, 0x0aa6c2c7, 0x068d9549, 0x0aa64307, 0x068cd549,
-	0x0aa5c347, 0x068c53c9, 0x0aa54387, 0x068bd3c9, 0x0aa4c3c7,
-	0x068b5249, 0x0aa44407, 0x068ad249, 0x0aa3c447, 0x068a5109,
-	0x0aa34487, 0x0689d109, 0x0aa2c4c7, 0x06899009, 0x0aa24507,
-	0x06895009, 0x0aa1c547, 0x0688cf09, 0x0aa14587, 0x06888f09,
-	0x0aa0c5c7, 0x06884e49, 0x06880e49, 0x0c780740, 0x00000000,
-	0x0aa34647, 0x06878d89, 0x0aa2c687, 0x06870cc9, 0x0aa246c7,
-	0x0686cc49, 0x0aa1c707, 0x06868bc9, 0x0aa14747, 0x06860b49,
-	0x0aa0c787, 0x0685cac9, 0x06858a49, 0x05401207, 0x04410208,
-	0x044061c7, 0x054081c7, 0x0c780440, 0x094081c8, 0x0aa1c147,
-	0x06999c89, 0x0aa14187, 0x06955c89, 0x0aa0c1c7, 0x06925989,
-	0x06901989, 0x0c7800c0, 0x0c7800c0, 0x04008207, 0x05401207,
-	0x0400d1c7, 0x054071c7, 0x0c780080, 0x094081c8, 0x07c002c7,
-	0x05410249, 0x060e0809, 0x06b00008, 0x064c2d09, 0x09610248,
-	0x060c2d09, 0x09610208, 0x060c2f08, 0x07801988, 0x094c11c8,
-	0x0cc00000, 0x060e0407, 0x0680001f, 0x07c0149f, 0x07c014df,
-	0x07c0151f, 0x07c0261f, 0x07c0031f, 0x064c091f, 0x07c00082,
-	0x06803fc2, 0x07c01542, 0x07c01582, 0x07c015c2, 0x07c02002,
-	0x060c091f, 0x080c0101, 0x080c2903, 0x06840442, 0x060c2e02,
-	0x064c4027, 0x064c4226, 0x024269e6, 0x040089a6, 0x07c02b66,
-	0x058109a6, 0x07c02ba6, 0x0649cf30, 0x0809c500, 0x0809c700,
-	0x0809c300, 0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803,
-	0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800,
-	0x07801502, 0x0aa0c002, 0x06800102, 0x06030502, 0x0cc00000,
-	0x00000000, 0x06800402, 0x060c0802, 0x06800002, 0x060c4402,
-	0x06800002, 0x06c07802, 0x060c4002, 0x06bffe02, 0x06c07fc2,
-	0x060c4202, 0x06800002, 0x06c07802, 0x060c4102, 0x06800082,
-	0x060c4802, 0x06bffe02, 0x06c07fc2, 0x060c4502, 0x06810002,
-	0x060c4402, 0x06810042, 0x060c4402, 0x06810002, 0x060c4402,
-	0x068000c2, 0x060c4802, 0x06800082, 0x060c4802, 0x06810182,
-	0x06c00442, 0x060c4402, 0x0cc00000, 0x00000000, 0x064c4419,
-	0x09121659, 0x0aaf8019, 0x0c7ea980, 0x00000000, 0x06490628,
-	0x0aefcc28, 0x00000000, 0x07800028, 0x078025e9, 0x09508a68,
-	0x068000a8, 0x06c00028, 0x06090628, 0x06090629, 0x06881068,
-	0x06090628, 0x0cc00000, 0x00000000, 0x07800028, 0x078025e9,
-	0x09508a68, 0x0780016b, 0x0aa4c0eb, 0x0aa4812b, 0x07801d2a,
-	0x04601aaa, 0x0c500c00, 0x0aa5002b, 0x0690002a, 0x0aa4806b,
-	0x0aa4436b, 0x0aa403eb, 0x0aa3c22b, 0x00000000, 0x06a0002a,
-	0x0aa301eb, 0x06c0002a, 0x06b0002a, 0x0aa241ab, 0x06c0002a,
-	0x0c780000, 0x06800068, 0x06090628, 0x06090629, 0x06889068,
-	0x0c7821c0, 0x06090628, 0x068000a8, 0x02c28aa8, 0x06090628,
-	0x06090629, 0x069fffeb, 0x06900028, 0x0a008a2a, 0x0c002000,
-	0x07900a68, 0x06090628, 0x0c001f40, 0x07900aa8, 0x02828ae8,
-	0x06090628, 0x06a00028, 0x0a008a2a, 0x0c001dc0, 0x07900ae8,
-	0x06090628, 0x0c001d00, 0x07900b28, 0x02828ae8, 0x06090628,
-	0x0688d068, 0x02c28aa8, 0x0c781b00, 0x06090628, 0x0aa3c02b,
-	0x0690002a, 0x0aa3406b, 0x0aa3036b, 0x0aa2c22b, 0x00000000,
-	0x06a0002a, 0x0aa201eb, 0x06c0002a, 0x06b0002a, 0x0aa141ab,
-	0x06c0002a, 0x0aa0c16b, 0x0c7ff440, 0x00000000, 0x068408a8,
-	0x02c28aa8, 0x06090628, 0x06090629, 0x069fffec, 0x06900028,
-	0x0a012a2a, 0x0aa1816b, 0x07900a68, 0x05401a28, 0x06090628,
-	0x0c780180, 0x07900aa8, 0x079011a8, 0x05401a28, 0x06090628,
-	0x07901228, 0x09c28028, 0x05401a28, 0x02828b28, 0x09828428,
-	0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028, 0x0a012a2a,
-	0x0aa1816b, 0x07900ae8, 0x05401a28, 0x06090628, 0x0c780180,
-	0x07900b28, 0x079012a8, 0x05401a28, 0x06090628, 0x07901328,
-	0x09c28028, 0x05401a28, 0x02828b28, 0x09828428, 0x07801ded,
-	0x095e1a2d, 0x06090628, 0x068c5828, 0x02c28aa8, 0x06090628,
-	0x06860828, 0x02c28aa8, 0x06090628, 0x06900028, 0x0a012a2a,
-	0x0aa1816b, 0x079016e8, 0x05401a28, 0x06090628, 0x0c780180,
-	0x07901728, 0x079011e8, 0x05401a28, 0x06090628, 0x07901268,
-	0x09c28028, 0x05401a28, 0x02828b28, 0x09828428, 0x07801dad,
-	0x095e1a2d, 0x06090628, 0x06a00028, 0x0a012a2a, 0x0aa1816b,
-	0x07901768, 0x05401a28, 0x06090628, 0x0c780180, 0x079017a8,
-	0x079012e8, 0x05401a28, 0x06090628, 0x07901368, 0x09c28028,
-	0x05401a28, 0x02828b28, 0x09828428, 0x07801e2d, 0x095e1a2d,
-	0x06090628, 0x068ed868, 0x02c28aa8, 0x0c780080, 0x06090628,
-	0x0cc00000, 0x00000000, 0x078019ee, 0x0aa0c06e, 0x00000000,
-	0x05401a28, 0x0cc00000, 0x00000000, 0x078019ee, 0x0aa1006e,
-	0x00000000, 0x05401a28, 0x05401b6d, 0x0cc00000, 0x00000000,
-	0x064e1215, 0x091e1555, 0x0a208055, 0x0c782280, 0x078003d5,
-	0x0aa08055, 0x0c7809c0, 0x07800596, 0x0aa1c016, 0x04401596,
-	0x07c00596, 0x078005d6, 0x04401596, 0x0c7817c0, 0x07c005d6,
-	0x07800916, 0x07800295, 0x05408555, 0x02015595, 0x04003596,
-	0x07c00916, 0x05404595, 0x02016c16, 0x060e1316, 0x07800517,
-	0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416, 0x06800017,
-	0x064c3a15, 0x09183555, 0x0be24095, 0x06c00016, 0x0aa1c055,
-	0x0aa18115, 0x064c0015, 0x0be10055, 0x0bae3fd7, 0x040015d7,
-	0x06c00016, 0x060e1216, 0x06800095, 0x0c781880, 0x07c003d5,
-	0x0a658095, 0x078005d6, 0x0aa10016, 0x04401596, 0x0c780ec0,
-	0x07c005d6, 0x07800956, 0x07800295, 0x05408555, 0x02015595,
-	0x04003596, 0x07c00956, 0x05404595, 0x02016c16, 0x060e1316,
-	0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215, 0x068000d5,
-	0x0c781300, 0x07c003d5, 0x0aa080d5, 0x0c780a00, 0x07800516,
-	0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417, 0x07900d15,
-	0x07c00c95, 0x07900d55, 0x07c00cd5, 0x07903a95, 0x07c03a15,
-	0x07903ad5, 0x07c03a55, 0x07800795, 0x07c00755, 0x0683ffd5,
-	0x064e1516, 0x0900c5d6, 0x0a40e5d5, 0x091845d6, 0x07c00797,
-	0x064e1516, 0x064e1516, 0x064e1516, 0x07c00d16, 0x05810596,
-	0x07c00d56, 0x064e1516, 0x07c03a96, 0x05810596, 0x0c780240,
-	0x07c03ad6, 0x068000d6, 0x07c00796, 0x06800016, 0x07c00d16,
-	0x07c00d56, 0x07c03a96, 0x07c03ad6, 0x07800095, 0x0aa08095,
-	0x0c780740, 0x078003d5, 0x0a640115, 0x07800956, 0x07801655,
-	0x05408555, 0x02015595, 0x04003596, 0x07c00956, 0x05404595,
-	0x060e1316, 0x06a16015, 0x09c151d5, 0x06c00015, 0x060e1215,
-	0x06800195, 0x0c7803c0, 0x07c003d5, 0x0aa0c195, 0x0c780280,
-	0x00000000, 0x080e1400, 0x064e1516, 0x0683ffd5, 0x0900c5d6,
-	0x0a8035d5, 0x091845d6, 0x068000d7, 0x07c004d7, 0x06800015,
-	0x07c003d5, 0x0cc00000, 0x00400000, 0x07800507, 0x050011c7,
-	0x07c00507, 0x06800047, 0x07c003c7, 0x07800447, 0x0aa080c7,
-	0x0a608107, 0x0c780440, 0x07800507, 0x0aa0c007, 0x06800008,
-	0x06800308, 0x060e1408, 0x0683ffc7, 0x07800448, 0x095841c8,
-	0x060e1507, 0x07902687, 0x079026c8, 0x096101c8, 0x060e1507,
-	0x060e1507, 0x060e1507, 0x060e1507, 0x0cc00000, 0x08030580,
-	0x078003c7, 0x0a6fc007, 0x07800147, 0x07c00447, 0x07801d07,
-	0x0aa1c007, 0x07900a47, 0x07900c08, 0x07900c49, 0x07c02688,
-	0x0cc00000, 0x07c026c9, 0x07c02687, 0x07800a87, 0x0cc00000,
-	0x07c026c7, 0x07800987, 0x078009c8, 0x06800009, 0x0d000008,
-	0x020091c9, 0x04401249, 0x06800047, 0x0ba10089, 0x05801249,
-	0x0c7fff80, 0x040011c7, 0x0cc00000, 0x07c00687
+	0x00000000, 0x00000000, 0x0c780400, 0x04001965, 0x0cc00000,
+	0x00400000, 0x0c780480, 0x064c0007, 0x0c795840, 0x06800025,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c798740, 0x00000000, 0x0cc00000, 0x00400000,
+	0x00800000, 0x078017c9, 0x0c7fff00, 0x06030409, 0x06bfdd89,
+	0x06030409, 0x00400000, 0x07801509, 0x0aa14009, 0x0a608049,
+	0x0c788d80, 0x0a608089, 0x0c7885c0, 0x0be0c807, 0x0c780980,
+	0x00000000, 0x0c785840, 0x00000000, 0x0681f409, 0x04401249,
+	0x0aefc009, 0x00000000, 0x083f0040, 0x083f0000, 0x08090703,
+	0x08090700, 0x06498e07, 0x09807007, 0x068007c9, 0x097051c9,
+	0x06098e07, 0x0681f409, 0x04401249, 0x0aefc009, 0x00000000,
+	0x06800009, 0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007,
+	0x09c07187, 0x09807207, 0x060c0007, 0x064c0807, 0x09807347,
+	0x060c0807, 0x083f0040, 0x083f0000, 0x08090703, 0x08090700,
+	0x0c789d00, 0x00000000, 0x0a20d007, 0x0c7ff700, 0x00000000,
+	0x07800247, 0x0aa10147, 0x040011c7, 0x0c7824c0, 0x07c00247,
+	0x07800007, 0x07800988, 0x0b83f207, 0x0c00b180, 0x06800007,
+	0x07c00007, 0x07800087, 0x0a618047, 0x06a00008, 0x07c00c08,
+	0x07c00c48, 0x07c03988, 0x07c039c8, 0x078025c8, 0x04001208,
+	0x078009c9, 0x0b815248, 0x07c025c8, 0x07800088, 0x0a644008,
+	0x00000000, 0x0fc05200, 0x0a624008, 0x06800147, 0x0fc01200,
+	0x0aafc008, 0x040011c7, 0x0ba245c7, 0x06800007, 0x0c784600,
+	0x07c02647, 0x0fc0b200, 0x0aae0008, 0x06800407, 0x0fc01200,
+	0x07c02648, 0x0c789180, 0x07800048, 0x04001208, 0x07802587,
+	0x0b8191c8, 0x07c00048, 0x078002c7, 0x07801988, 0x094c11c8,
+	0x060e0407, 0x078003c7, 0x0a6fc007, 0x0c00a840, 0x00000000,
+	0x0c00a5c0, 0x06800007, 0x07c01cc7, 0x07c01bc7, 0x07800947,
+	0x07800988, 0x04401208, 0x07c005c8, 0x02007207, 0x05401208,
+	0x02007207, 0x07c00947, 0x06800007, 0x0c780080, 0x07c00047,
+	0x06800007, 0x07c00247, 0x07800087, 0x0aa3c007, 0x080c2805,
+	0x07802547, 0x0aa2c007, 0x080c2800, 0x0fc011c0, 0x0aa20007,
+	0x06800347, 0x07c00147, 0x06800007, 0x07c01387, 0x07c00a07,
+	0x0c7806c0, 0x07c00207, 0x080c2806, 0x064c2807, 0x0a2fc047,
+	0x058011c7, 0x0ba11007, 0x06800049, 0x06800009, 0x044401c7,
+	0x07800088, 0x0a610008, 0x07c01387, 0x0c00c440, 0x00000000,
+	0x0a60c009, 0x068000c8, 0x06800008, 0x07c00148, 0x080c2800,
+	0x07c00a09, 0x07c00209, 0x0aa0c0c8, 0x0a610108, 0x06800007,
+	0x0fc011c0, 0x07c00207, 0x07801388, 0x060c2b08, 0x07800148,
+	0x0aa20008, 0x0aa1c188, 0x0aa18208, 0x0aa14048, 0x06800009,
+	0x07c00a49, 0x0c7805c0, 0x07c00a89, 0x07802509, 0x0aa0c009,
+	0x080c280b, 0x080c280c, 0x064c2807, 0x0a2fc047, 0x058011c7,
+	0x06820809, 0x0a806247, 0x090c6247, 0x07c00a49, 0x09006247,
+	0x0c780240, 0x07c00a89, 0x080c2800, 0x0fc061c0, 0x044201c7,
+	0x07c00a47, 0x0fc061c0, 0x044201c7, 0x07c00a87, 0x080c2800,
+	0x07800a09, 0x09421249, 0x07801cc8, 0x094a1248, 0x060c2c09,
+	0x07800a07, 0x0a60c007, 0x0c781200, 0x06800007, 0x07800247,
+	0x0ba0c107, 0x068001c7, 0x06800247, 0x07802448, 0x02008207,
+	0x060c2808, 0x064c2807, 0x0a2fc047, 0x058011c7, 0x080c2800,
+	0x0a65c1c8, 0x0b60cc07, 0x0c780cc0, 0x00000000, 0x0fc06200,
+	0x0b6f4388, 0x040281c8, 0x0ba24208, 0x0aae8208, 0x06800c87,
+	0x0aae0248, 0x06800c47, 0x0aad8348, 0x06800c07, 0x0c7809c0,
+	0x040291c8, 0x05401208, 0x0fc011c0, 0x09401207, 0x0babc3c8,
+	0x040681c8, 0x0c780800, 0x0fc081c0, 0x0a640208, 0x0ba75107,
+	0x00000000, 0x0fc05200, 0x0aa68688, 0x0b6646c8, 0x040301c8,
+	0x0b65c508, 0x040311c8, 0x05401208, 0x0fc011c0, 0x09401207,
+	0x0ba489c8, 0x040501c8, 0x0c780400, 0x0fc081c0, 0x0aa08248,
+	0x0a634288, 0x0ba30c07, 0x00000000, 0x0fc06200, 0x0b624208,
+	0x040281c8, 0x05401208, 0x0fc011c0, 0x09401207, 0x0ba103c8,
+	0x040681c8, 0x0c780080, 0x0fc081c0, 0x0aa18007, 0x00000000,
+	0x0fc01200, 0x0aa0c008, 0x06800008, 0x024071c8, 0x07800209,
+	0x0540e249, 0x07800248, 0x0ba18108, 0x0b624148, 0x060c2d09,
+	0x0940d247, 0x0c780200, 0x098093c9, 0x0960d247, 0x098097c9,
+	0x0c780140, 0x060c2d09, 0x0960d247, 0x098097c9, 0x060c2f09,
+	0x07800249, 0x0a62c009, 0x064e0408, 0x07800107, 0x09605207,
+	0x096a5207, 0x060e0408, 0x06880008, 0x098083c8, 0x07800507,
+	0x09581207, 0x060e0508, 0x07800249, 0x07800a08, 0x0aa14008,
+	0x09809249, 0x09c09249, 0x0ba10109, 0x078024c8, 0x07802488,
+	0x05403208, 0x09466248, 0x07800bc8, 0x09541248, 0x060c2a09,
+	0x07800247, 0x0a644007, 0x068fdfc7, 0x064e0408, 0x06ffffc7,
+	0x028081c8, 0x07800047, 0x0a60c007, 0x07800007, 0x098083c8,
+	0x0a60c007, 0x040011c7, 0x09808388, 0x07800989, 0x0b803247,
+	0x00000000, 0x098081c8, 0x060e0408, 0x07800247, 0x0a60c007,
+	0x0c015500, 0x00000000, 0x080c0080, 0x07800247, 0x0a6340c7,
+	0x07800147, 0x0aa340c7, 0x0aa30107, 0x0aa0c3c7, 0x0c005fc0,
+	0x00000000, 0x0c010240, 0x00000000, 0x07800007, 0x040011c7,
+	0x0c015800, 0x07c00007, 0x0c7fa6c0, 0x00000000, 0x0c00fcc0,
+	0x00000000, 0x06800009, 0x07c00a49, 0x07c00a89, 0x07c00c09,
+	0x07c03989, 0x07c00c49, 0x0c7ffc80, 0x07c039c9, 0x0fc081c0,
+	0x0b2187c7, 0x0b21cbc7, 0x0aa16c87, 0x0a60ad87, 0x0c780900,
+	0x0c784bc0, 0x0c784b80, 0x0c784b40, 0x00000000, 0x0fc0c1c0,
+	0x0fc0c200, 0x06811009, 0x0b002248, 0x0c7fa480, 0x04000248,
+	0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7, 0x060c0907,
+	0x07c00987, 0x04401247, 0x07c00609, 0x05404287, 0x0400f208,
+	0x05804208, 0x07c009c8, 0x05404208, 0x0961020a, 0x06090808,
+	0x06800007, 0x07c01c07, 0x07c01d07, 0x060c0307, 0x07c01987,
+	0x07c01a07, 0x0c784400, 0x00000000, 0x0c780000, 0x00000000,
+	0x064c5126, 0x064c4627, 0x07802b88, 0x05410208, 0x07802b49,
+	0x02008248, 0x0580a208, 0x0e000988, 0x00000000, 0x00000000,
+	0x00000000, 0x0f000200, 0x0f010980, 0x09708226, 0x0540a208,
+	0x020089c8, 0x064c4326, 0x02408988, 0x064c4026, 0x02408988,
+	0x07c02bc8, 0x05810208, 0x07c02c08, 0x06800007, 0x07c00007,
+	0x07c00047, 0x068035c8, 0x07400207, 0x0bafffc8, 0x04001208,
+	0x07c00507, 0x07c025c7, 0x06800047, 0x07c00587, 0x07800607,
+	0x07c005c7, 0x0fc101c0, 0x0fc101c0, 0x0fc101c0, 0x0fc101c0,
+	0x0fc101c0, 0x0a61c007, 0x0fc101c0, 0x0a614007, 0x07802607,
+	0x040011c7, 0x0c783780, 0x07c02607, 0x0fc021c0, 0x07c00087,
+	0x07800308, 0x0b624088, 0x0aa18087, 0x0aa08007, 0x0aa10008,
+	0x04001208, 0x0c780100, 0x07c00308, 0x0c783480, 0x00000000,
+	0x06800023, 0x06800024, 0x0a60c087, 0x068ac008, 0x068ae008,
+	0x07c00288, 0x07800087, 0x0a624047, 0x06800047, 0x07802647,
+	0x0aa18007, 0x06800007, 0x06490707, 0x0a20c087, 0x00000000,
+	0x06800007, 0x07c01b07, 0x0fc051c0, 0x0c00aec0, 0x07c00107,
+	0x0c006b00, 0x00000000, 0x07800087, 0x0a618087, 0x078003c7,
+	0x0a6fc007, 0x06800107, 0x07c003c7, 0x08030580, 0x07800087,
+	0x0a648007, 0x00000000, 0x0fc051c0, 0x07c02407, 0x0aa105c7,
+	0x069fffc7, 0x078009c7, 0x058011c7, 0x07c02587, 0x0c006900,
+	0x00000000, 0x07c02487, 0x0c006840, 0x00000000, 0x07c024c7,
+	0x0fc011c0, 0x0c780300, 0x07c02447, 0x0fc011c0, 0x07c02547,
+	0x0c006640, 0x00000000, 0x07c02487, 0x07c024c7, 0x0fc011c0,
+	0x07c02447, 0x0fc011c0, 0x07c02507, 0x06800025, 0x06490908,
+	0x0ae0c125, 0x0bef8048, 0x00000000, 0x06490b08, 0x09808008,
+	0x098080c8, 0x06090b08, 0x09c08008, 0x09c080c8, 0x06090b08,
+	0x0683ffc8, 0x0649bb07, 0x0900c1c7, 0x0aa10007, 0x0aa0c008,
+	0x0c7fff00, 0x04401208, 0x0649c909, 0x0aa10009, 0x06800087,
+	0x0c7f7680, 0x07c01507, 0x07801487, 0x0a608007, 0x0c780580,
+	0x044011c7, 0x0aa0c087, 0x07801549, 0x078015c9, 0x0ae441c9,
+	0x00000000, 0x040a41c9, 0x070001c7, 0x054101c7, 0x0409c209,
+	0x07000208, 0x094101c8, 0x0609cc07, 0x04081209, 0x07000208,
+	0x09464248, 0x09809209, 0x0609c909, 0x08007401, 0x06800009,
+	0x07c01489, 0x06800009, 0x07c01509, 0x07c02609, 0x078014c7,
+	0x02c07247, 0x07802c4a, 0x07802c88, 0x09610288, 0x0be0c047,
+	0x0c780a40, 0x06800008, 0x07802cca, 0x07802d08, 0x09610288,
+	0x0be0c087, 0x0c7808c0, 0x06800048, 0x07802d4a, 0x07802d88,
+	0x09610288, 0x0a278107, 0x06800088, 0x07802dca, 0x07802e08,
+	0x09610288, 0x0a264207, 0x068000c8, 0x07802e4a, 0x07802e88,
+	0x09610288, 0x0a250407, 0x06800108, 0x07802eca, 0x07802f08,
+	0x09610288, 0x0a23c807, 0x06800148, 0x07802f4a, 0x07802f88,
+	0x09610288, 0x0a229007, 0x06800188, 0x07802fca, 0x07803008,
+	0x09610288, 0x0a216007, 0x068001c8, 0x06800047, 0x0c7f6400,
+	0x07c01507, 0x07802007, 0x090041c7, 0x0a8061c8, 0x07800087,
+	0x0a620087, 0x07802007, 0x090841c7, 0x0a4051c8, 0x06800047,
+	0x03407207, 0x0c7ff1c0, 0x02c091c9, 0x07802bc7, 0x0409c248,
+	0x07400247, 0x07802c07, 0x04008249, 0x07400247, 0x07800087,
+	0x098070c7, 0x04081248, 0x07400247, 0x06800047, 0x03407207,
+	0x078014c9, 0x02c091c9, 0x07c014c9, 0x0609b20a, 0x07800087,
+	0x04001247, 0x07c01489, 0x0a608087, 0x0c780340, 0x07801587,
+	0x07c015c7, 0x07c01588, 0x06499109, 0x06099009, 0x07802009,
+	0x05404249, 0x09404248, 0x07c02009, 0x0609910a, 0x0c7800c0,
+	0x00000000, 0x07c01548, 0x07801b07, 0x06800048, 0x06c00008,
+	0x09421207, 0x0c7f7640, 0x06090708, 0x064c0007, 0x0a2fc047,
+	0x00000000, 0x064c3a07, 0x090061c7, 0x0aaec647, 0x00000000,
+	0x080c2800, 0x080c0002, 0x0c7f5440, 0x00000000, 0x0649c007,
+	0x07c02c47, 0x058101c7, 0x07c02c87, 0x0649c107, 0x07c02cc7,
+	0x058101c7, 0x07c02d07, 0x0649c207, 0x07c02d47, 0x058101c7,
+	0x07c02d87, 0x0649c307, 0x07c02dc7, 0x058101c7, 0x07c02e07,
+	0x0649d007, 0x07c02e47, 0x058101c7, 0x07c02e87, 0x0649d107,
+	0x07c02ec7, 0x058101c7, 0x07c02f07, 0x0649d207, 0x07c02f47,
+	0x058101c7, 0x07c02f87, 0x0649d307, 0x07c02fc7, 0x058101c7,
+	0x07c03007, 0x0c008dc0, 0x00000000, 0x08002501, 0x08002605,
+	0x08002708, 0x08002815, 0x08002c14, 0x069fffc2, 0x07c02582,
+	0x0cc00000, 0x00000000, 0x07800a49, 0x0541a249, 0x05c1a249,
+	0x07c00a49, 0x07800a89, 0x0541a249, 0x05c1a249, 0x07c00a89,
+	0x0c001bc0, 0x00000000, 0x0cc00000, 0x00000000, 0x07800149,
+	0x0aa280c8, 0x0aa24108, 0x06800009, 0x07c00c09, 0x07c03989,
+	0x0680000f, 0x07c00c4f, 0x07c039cf, 0x0cc00000, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0700024f, 0x0ba24047, 0x0900638f,
+	0x0aa1c00e, 0x0440134e, 0x04401387, 0x0340d38d, 0x090e938f,
+	0x0200e34e, 0x0400138e, 0x0a21100f, 0x06bfffcd, 0x0300e38d,
+	0x0400138e, 0x0cc00000, 0x0740024e, 0x06800d48, 0x04001208,
+	0x0bafcf48, 0x07400207, 0x07c03607, 0x07c035c7, 0x0cc00000,
+	0x00000000, 0x06a00007, 0x07c00c07, 0x07c00c47, 0x07c00c87,
+	0x07c00cc7, 0x07c00d07, 0x07c00d47, 0x078025c7, 0x0a618007,
+	0x06800007, 0x06803588, 0x04001208, 0x0baff7c8, 0x07400207,
+	0x0cc00000, 0x00000000, 0x07800007, 0x040011c7, 0x0780098a,
+	0x0b803287, 0x06a00007, 0x06a0000d, 0x0a40f1cf, 0x0a4091ce,
+	0x0a4051cd, 0x0680000f, 0x0680000e, 0x0c780500, 0x0680000d,
+	0x040003cd, 0x0c780440, 0x0400038d, 0x0a40f1cd, 0x0680000f,
+	0x040003ce, 0x0c780300, 0x0400034e, 0x0a4071ce, 0x0a4041cd,
+	0x0400038f, 0x0c7801c0, 0x0400034f, 0x0c780140, 0x0680000e,
+	0x0a4031cd, 0x00000000, 0x0680000d, 0x0b40438f, 0x040001ce,
+	0x0400038f, 0x040003c7, 0x0b4053cd, 0x040001cf, 0x0b40338d,
+	0x040001cd, 0x040001ce, 0x0cc00000, 0x00000000, 0x0200f1cf,
+	0x06bff00d, 0x0ac0434f, 0x0680100d, 0x0cc00000, 0x0200f34f,
+	0x0680100d, 0x0b40234f, 0x0cc00000, 0x0680100d, 0x0cc00000,
+	0x0240f34f, 0x078003c7, 0x0a6fc007, 0x07800147, 0x0aa10347,
+	0x07900c0f, 0x0c780140, 0x00000000, 0x07900a4f, 0x0c780200,
+	0x00000000, 0x07900c8e, 0x0c07efc0, 0x07900d0d, 0x0c07f9c0,
+	0x07900a4f, 0x07c00a4f, 0x07c00c0f, 0x0400024f, 0x07800147,
+	0x0aa10347, 0x07900c4f, 0x0c780140, 0x00000000, 0x07900a8f,
+	0x0c780200, 0x00000000, 0x07900cce, 0x0c07ebc0, 0x07900d4d,
+	0x0c07f5c0, 0x07900a8f, 0x07c00a8f, 0x07c00c4f, 0x0cc00000,
+	0x00000000, 0x060e0709, 0x091e13c7, 0x0aa1000f, 0x04000347,
+	0x0680000d, 0x0240d1cd, 0x060e060d, 0x0680000d, 0x064e060e,
+	0x0aa0c00f, 0x0580538e, 0x0240e38d, 0x0200e20e, 0x0aa0c008,
+	0x0cc00000, 0x0240d1ce, 0x09145349, 0x0240d349, 0x0954524d,
+	0x060e0709, 0x06800009, 0x064e060d, 0x0a60c00f, 0x0580534d,
+	0x0240d349, 0x0cc00000, 0x00000000, 0x0200a28f, 0x05c013ca,
+	0x0480128a, 0x0cc00000, 0x02c0f28f, 0x07801988, 0x094c11c8,
+	0x0c07dd40, 0x060e0407, 0x0c07dac0, 0x06800007, 0x07c01cc7,
+	0x07c01bc7, 0x07c00907, 0x0cc00000, 0x07c00947, 0x0fc011c0,
+	0x0aa18007, 0x06800047, 0x0fc011c0, 0x0aa0c007, 0x06800087,
+	0x06800107, 0x0cc00000, 0x00000000, 0x0780000f, 0x0580338f,
+	0x0680368d, 0x0200d38d, 0x0700034d, 0x048073cf, 0x054013cf,
+	0x0380d3cd, 0x0900234d, 0x054023cd, 0x07c0364f, 0x078035ce,
+	0x0a20810e, 0x0c781ec0, 0x0480c34f, 0x0a66000d, 0x07803608,
+	0x04814348, 0x0aa5000d, 0x05000207, 0x0a61c10d, 0x0be44807,
+	0x05000207, 0x0be3c407, 0x05008207, 0x0c780340, 0x0500c207,
+	0x0a61c40d, 0x0be28807, 0x0503c207, 0x0be20407, 0x05034207,
+	0x0c780180, 0x05030207, 0x0a60c50d, 0x0c7800c0, 0x0503c207,
+	0x06800008, 0x0c782f80, 0x0aa0810d, 0x0c7809c0, 0x07803608,
+	0x04814348, 0x0a61c00d, 0x0bee8807, 0x05000207, 0x0bee0207,
+	0x05010207, 0x0c7ffd80, 0x05014207, 0x0a62410d, 0x0be6c807,
+	0x05000207, 0x0ba10207, 0x0b60c607, 0x0c7805c0, 0x05018207,
+	0x0c780540, 0x0501c207, 0x0a62840d, 0x0a214807, 0x0be44207,
+	0x05028207, 0x0c7803c0, 0x0502c207, 0x0be34407, 0x05034207,
+	0x0c7802c0, 0x05030207, 0x0a62050d, 0x0a214807, 0x0be1c207,
+	0x05028207, 0x0c780140, 0x0502c207, 0x0c7800c0, 0x0503c207,
+	0x06800008, 0x0c782580, 0x0aa0820d, 0x0c780800, 0x07803608,
+	0x04814348, 0x0aa5400d, 0x0a62810d, 0x0a214807, 0x0be64407,
+	0x05030207, 0x0c7805c0, 0x05034207, 0x0be54207, 0x0502c207,
+	0x0c7804c0, 0x05028207, 0x0a62440d, 0x0be40807, 0x0503c207,
+	0x0ba10207, 0x0b60c607, 0x0c780300, 0x05024207, 0x0c780280,
+	0x05020207, 0x0a61c50d, 0x0be1c807, 0x0503c207, 0x0be14207,
+	0x0502c207, 0x0c7800c0, 0x05028207, 0x06800008, 0x0c781d40,
+	0x0a66030d, 0x07803608, 0x04814348, 0x0aa4400d, 0x0a62010d,
+	0x0a214807, 0x0be44407, 0x05030207, 0x0c7803c0, 0x05034207,
+	0x0c780340, 0x0503c207, 0x0a61c40d, 0x0be28807, 0x0503c207,
+	0x0be20407, 0x05034207, 0x0c780180, 0x05030207, 0x0a60c50d,
+	0x0c7800c0, 0x0503c207, 0x06800008, 0x0c781740, 0x0480c34f,
+	0x0a64800d, 0x07803608, 0x04814348, 0x0aa2c00d, 0x0a60810d,
+	0x0c7fe1c0, 0x0a61c40d, 0x0a228807, 0x05000207, 0x0be20407,
+	0x0500c207, 0x0c780180, 0x05008207, 0x0a60c50d, 0x0c7800c0,
+	0x05000207, 0x06800008, 0x0c781280, 0x0aa0810d, 0x0c780680,
+	0x07803608, 0x04814348, 0x0a60800d, 0x0c7fe300, 0x0a60810d,
+	0x0c7fe440, 0x0a62840d, 0x0a214807, 0x0be40407, 0x0500c207,
+	0x0c780380, 0x05008207, 0x0be30207, 0x05010207, 0x0c780280,
+	0x05014207, 0x0a61c50d, 0x0be1c807, 0x05000207, 0x0be14207,
+	0x05010207, 0x0c7800c0, 0x05014207, 0x06800008, 0x0c780bc0,
+	0x0aa0820d, 0x0c780680, 0x07803608, 0x04814348, 0x0a61c00d,
+	0x0a254807, 0x05000207, 0x0be4c207, 0x05014207, 0x0c780440,
+	0x05010207, 0x0a62810d, 0x0a214807, 0x0be34207, 0x05014207,
+	0x0c7802c0, 0x05010207, 0x0be24407, 0x05008207, 0x0c7801c0,
+	0x0500c207, 0x0a60840d, 0x0c7fe4c0, 0x0a60850d, 0x0c7fe680,
+	0x06800008, 0x0c780500, 0x0a64c30d, 0x07803608, 0x04814348,
+	0x0aa3c00d, 0x05000207, 0x0a61c10d, 0x0be30807, 0x05000207,
+	0x0be28407, 0x05008207, 0x0c780200, 0x0500c207, 0x0a60840d,
+	0x0c7fe7c0, 0x0a60c50d, 0x0c7800c0, 0x0503c207, 0x06800008,
+	0x0c780040, 0x07c035cf, 0x07c03608, 0x07c01388, 0x05802208,
+	0x0780000f, 0x0580338f, 0x0680368d, 0x0200d38d, 0x0700034e,
+	0x048073cf, 0x054013cf, 0x038073ce, 0x094021c8, 0x034073c7,
+	0x06800048, 0x034083c8, 0x04401208, 0x02808388, 0x02c0e207,
+	0x0cc00000, 0x0740034e, 0x060c0a07, 0x078000c8, 0x0aa24008,
+	0x06800009, 0x0aa1c1c8, 0x06800049, 0x05401247, 0x0400b249,
+	0x0b403247, 0x06800049, 0x06800009, 0x07c00bc9, 0x0b218107,
+	0x0ae08207, 0x0c780ec0, 0x0b218607, 0x0c780980, 0x00000000,
+	0x06a02009, 0x0c781140, 0x06820207, 0x0aa7c247, 0x068f1749,
+	0x0aa74287, 0x068e5749, 0x0aa6c2c7, 0x068d9549, 0x0aa64307,
+	0x068cd549, 0x0aa5c347, 0x068c53c9, 0x0aa54387, 0x068bd3c9,
+	0x0aa4c3c7, 0x068b5249, 0x0aa44407, 0x068ad249, 0x0aa3c447,
+	0x068a5109, 0x0aa34487, 0x0689d109, 0x0aa2c4c7, 0x06899009,
+	0x0aa24507, 0x06895009, 0x0aa1c547, 0x0688cf09, 0x0aa14587,
+	0x06888f09, 0x0aa0c5c7, 0x06884e49, 0x06880e49, 0x0c780740,
+	0x00000000, 0x0aa34647, 0x06878d89, 0x0aa2c687, 0x06870cc9,
+	0x0aa246c7, 0x0686cc49, 0x0aa1c707, 0x06868bc9, 0x0aa14747,
+	0x06860b49, 0x0aa0c787, 0x0685cac9, 0x06858a49, 0x05401207,
+	0x04410208, 0x044061c7, 0x054081c7, 0x0c780440, 0x094081c8,
+	0x0aa1c147, 0x06999c89, 0x0aa14187, 0x06955c89, 0x0aa0c1c7,
+	0x06925989, 0x06901989, 0x0c7800c0, 0x0c7800c0, 0x04008207,
+	0x05401207, 0x0400d1c7, 0x054071c7, 0x0c780080, 0x094081c8,
+	0x07c002c7, 0x05410249, 0x060e0809, 0x06b00008, 0x064c2d09,
+	0x09610248, 0x060c2d09, 0x09610208, 0x060c2f08, 0x07801988,
+	0x094c11c8, 0x0cc00000, 0x060e0407, 0x0680001f, 0x07c0149f,
+	0x07c014df, 0x07c0151f, 0x07c0261f, 0x07c0031f, 0x064c091f,
+	0x07c00082, 0x06803fc2, 0x07c01542, 0x07c01582, 0x07c015c2,
+	0x07c02002, 0x060c091f, 0x080c0101, 0x080c2903, 0x06840442,
+	0x060c2e02, 0x064c4027, 0x064c4226, 0x024269e6, 0x040089a6,
+	0x07c02b66, 0x058109a6, 0x07c02ba6, 0x0649cf30, 0x0809c500,
+	0x0809c700, 0x0809c300, 0x0809cb00, 0x0cc00000, 0x00000000,
+	0x0649c803, 0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2,
+	0x0809c800, 0x07801502, 0x0aa0c002, 0x06800102, 0x06030502,
+	0x0cc00000, 0x00000000, 0x06800402, 0x060c0802, 0x06800002,
+	0x060c4402, 0x06800002, 0x06c07802, 0x060c4002, 0x06bffe02,
+	0x06c07fc2, 0x060c4202, 0x06800002, 0x06c07802, 0x060c4102,
+	0x06800082, 0x060c4802, 0x06bffe02, 0x06c07fc2, 0x060c4502,
+	0x06810002, 0x060c4402, 0x06810042, 0x060c4402, 0x06810002,
+	0x060c4402, 0x068000c2, 0x060c4802, 0x06800082, 0x060c4802,
+	0x06810182, 0x06c00442, 0x060c4402, 0x0cc00000, 0x00000000,
+	0x064c4419, 0x09121659, 0x0aaf8019, 0x0c7ea980, 0x00000000,
+	0x06490628, 0x0aefcc28, 0x00000000, 0x07800028, 0x078025e9,
+	0x09508a68, 0x068000a8, 0x06c00028, 0x06090628, 0x06090629,
+	0x06881068, 0x06090628, 0x0cc00000, 0x00000000, 0x07800028,
+	0x078025e9, 0x09508a68, 0x0780016b, 0x0aa4c0eb, 0x0aa4812b,
+	0x07801d2a, 0x04601aaa, 0x0c500c00, 0x0aa5002b, 0x0690002a,
+	0x0aa4806b, 0x0aa4436b, 0x0aa403eb, 0x0aa3c22b, 0x00000000,
+	0x06a0002a, 0x0aa301eb, 0x06c0002a, 0x06b0002a, 0x0aa241ab,
+	0x06c0002a, 0x0c780000, 0x06800068, 0x06090628, 0x06090629,
+	0x06889068, 0x0c7821c0, 0x06090628, 0x068000a8, 0x02c28aa8,
+	0x06090628, 0x06090629, 0x069fffeb, 0x06900028, 0x0a008a2a,
+	0x0c002000, 0x07900a68, 0x06090628, 0x0c001f40, 0x07900aa8,
+	0x02828ae8, 0x06090628, 0x06a00028, 0x0a008a2a, 0x0c001dc0,
+	0x07900ae8, 0x06090628, 0x0c001d00, 0x07900b28, 0x02828ae8,
+	0x06090628, 0x0688d068, 0x02c28aa8, 0x0c781b00, 0x06090628,
+	0x0aa3c02b, 0x0690002a, 0x0aa3406b, 0x0aa3036b, 0x0aa2c22b,
+	0x00000000, 0x06a0002a, 0x0aa201eb, 0x06c0002a, 0x06b0002a,
+	0x0aa141ab, 0x06c0002a, 0x0aa0c16b, 0x0c7ff440, 0x00000000,
+	0x068408a8, 0x02c28aa8, 0x06090628, 0x06090629, 0x069fffec,
+	0x06900028, 0x0a012a2a, 0x0aa1816b, 0x07900a68, 0x05401a28,
+	0x06090628, 0x0c780180, 0x07900aa8, 0x079011a8, 0x05401a28,
+	0x06090628, 0x07901228, 0x09c28028, 0x05401a28, 0x02828b28,
+	0x09828428, 0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028,
+	0x0a012a2a, 0x0aa1816b, 0x07900ae8, 0x05401a28, 0x06090628,
+	0x0c780180, 0x07900b28, 0x079012a8, 0x05401a28, 0x06090628,
+	0x07901328, 0x09c28028, 0x05401a28, 0x02828b28, 0x09828428,
+	0x07801ded, 0x095e1a2d, 0x06090628, 0x068c5828, 0x02c28aa8,
+	0x06090628, 0x06860828, 0x02c28aa8, 0x06090628, 0x06900028,
+	0x0a012a2a, 0x0aa1816b, 0x079016e8, 0x05401a28, 0x06090628,
+	0x0c780180, 0x07901728, 0x079011e8, 0x05401a28, 0x06090628,
+	0x07901268, 0x09c28028, 0x05401a28, 0x02828b28, 0x09828428,
+	0x07801dad, 0x095e1a2d, 0x06090628, 0x06a00028, 0x0a012a2a,
+	0x0aa1816b, 0x07901768, 0x05401a28, 0x06090628, 0x0c780180,
+	0x079017a8, 0x079012e8, 0x05401a28, 0x06090628, 0x07901368,
+	0x09c28028, 0x05401a28, 0x02828b28, 0x09828428, 0x07801e2d,
+	0x095e1a2d, 0x06090628, 0x068ed868, 0x02c28aa8, 0x0c780080,
+	0x06090628, 0x0cc00000, 0x00000000, 0x078019ee, 0x0aa0c06e,
+	0x00000000, 0x05401a28, 0x0cc00000, 0x00000000, 0x078019ee,
+	0x0aa1006e, 0x00000000, 0x05401a28, 0x05401b6d, 0x0cc00000,
+	0x00000000, 0x064e1215, 0x091e1555, 0x0a208055, 0x0c782280,
+	0x078003d5, 0x0aa08055, 0x0c7809c0, 0x07800596, 0x0aa1c016,
+	0x04401596, 0x07c00596, 0x078005d6, 0x04401596, 0x0c7817c0,
+	0x07c005d6, 0x07800916, 0x07800295, 0x05408555, 0x02015595,
+	0x04003596, 0x07c00916, 0x05404595, 0x02016c16, 0x060e1316,
+	0x07800517, 0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416,
+	0x06800017, 0x064c3a15, 0x09183555, 0x0be24095, 0x06c00016,
+	0x0aa1c055, 0x0aa18115, 0x064c0015, 0x0be10055, 0x0bae3fd7,
+	0x040015d7, 0x06c00016, 0x060e1216, 0x06800095, 0x0c781880,
+	0x07c003d5, 0x0a658095, 0x078005d6, 0x0aa10016, 0x04401596,
+	0x0c780ec0, 0x07c005d6, 0x07800956, 0x07800295, 0x05408555,
+	0x02015595, 0x04003596, 0x07c00956, 0x05404595, 0x02016c16,
+	0x060e1316, 0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215,
+	0x068000d5, 0x0c781300, 0x07c003d5, 0x0aa080d5, 0x0c780a00,
+	0x07800516, 0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417,
+	0x07900d15, 0x07c00c95, 0x07900d55, 0x07c00cd5, 0x07903a95,
+	0x07c03a15, 0x07903ad5, 0x07c03a55, 0x07800795, 0x07c00755,
+	0x0683ffd5, 0x064e1516, 0x0900c5d6, 0x0a40e5d5, 0x091845d6,
+	0x07c00797, 0x064e1516, 0x064e1516, 0x064e1516, 0x07c00d16,
+	0x05810596, 0x07c00d56, 0x064e1516, 0x07c03a96, 0x05810596,
+	0x0c780240, 0x07c03ad6, 0x068000d6, 0x07c00796, 0x06800016,
+	0x07c00d16, 0x07c00d56, 0x07c03a96, 0x07c03ad6, 0x07800095,
+	0x0aa08095, 0x0c780740, 0x078003d5, 0x0a640115, 0x07800956,
+	0x07801655, 0x05408555, 0x02015595, 0x04003596, 0x07c00956,
+	0x05404595, 0x060e1316, 0x06a16015, 0x09c151d5, 0x06c00015,
+	0x060e1215, 0x06800195, 0x0c7803c0, 0x07c003d5, 0x0aa0c195,
+	0x0c780280, 0x00000000, 0x080e1400, 0x064e1516, 0x0683ffd5,
+	0x0900c5d6, 0x0a8035d5, 0x091845d6, 0x068000d7, 0x07c004d7,
+	0x06800015, 0x07c003d5, 0x0cc00000, 0x00400000, 0x07800507,
+	0x050011c7, 0x07c00507, 0x06800047, 0x07c003c7, 0x07800447,
+	0x0aa080c7, 0x0a608107, 0x0c780440, 0x07800507, 0x0aa0c007,
+	0x06800008, 0x06800308, 0x060e1408, 0x0683ffc7, 0x07800448,
+	0x095841c8, 0x060e1507, 0x07902687, 0x079026c8, 0x096101c8,
+	0x060e1507, 0x060e1507, 0x060e1507, 0x060e1507, 0x0cc00000,
+	0x08030580, 0x078003c7, 0x0a6fc007, 0x07800147, 0x07c00447,
+	0x07801d07, 0x0aa1c007, 0x07900a47, 0x07900c08, 0x07900c49,
+	0x07c02688, 0x0cc00000, 0x07c026c9, 0x07c02687, 0x07800a87,
+	0x0cc00000, 0x07c026c7, 0x07800987, 0x078009c8, 0x06800009,
+	0x0d000008, 0x020091c9, 0x04401249, 0x06800047, 0x0ba10089,
+	0x05801249, 0x0c7fff80, 0x040011c7, 0x0cc00000, 0x07c00687
 };
 
 const u32 __initconst h263_mc[] = {
-	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c0140c0, 0x00000000,
-	0x00000000, 0x00000000, 0x080c0002, 0x00000000, 0x06bfde80,
-	0x07c017c0, 0x06030400, 0x00400000, 0x0c019780, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
+	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014a80,
+	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x00000000,
+	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a180,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0c7ffe80, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x0c780400, 0x04001965, 0x0cc00000, 0x00400000,
-	0x0c780540, 0x064c0007, 0x0c799e80, 0x06800025, 0x0cc00000,
-	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
-	0x0c79f680, 0x06800025, 0x0cc00000, 0x00400000, 0x06800025,
-	0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409, 0x0c781240,
-	0x00000000, 0x078001c9, 0x0aa0c009, 0x0c78fc00, 0x00000000,
-	0x06bfdd89, 0x06030409, 0x00400000, 0x07801509, 0x0aa30109,
-	0x07c0151f, 0x0a2bc047, 0x06800025, 0x0aac80c9, 0x0aa14009,
-	0x0a608049, 0x0c790640, 0x0a608089, 0x0c78f840, 0x0a240807,
-	0x0c78b180, 0x00000000, 0x0683ffc8, 0x0ba20048, 0x064c0007,
-	0x0a2f8047, 0x04401208, 0x064c3a07, 0x090061c7, 0x0aae8647,
-	0x00000000, 0x06800007, 0x0c016e00, 0x07c003c7, 0x0c792780,
-	0x0bec9007, 0x078003c7, 0x0a6fc007, 0x07800007, 0x07800988,
-	0x0b81c207, 0x06800007, 0x07c00007, 0x0a61c060, 0x06a00008,
-	0x06e00008, 0x080c24a0, 0x060c2208, 0x0c780240, 0x060c2208,
-	0x0a61c0a0, 0x00000000, 0x080c24c0, 0x080c2200, 0x080c2200,
-	0x080c2200, 0x080c2200, 0x078016c8, 0x04001208, 0x078009c9,
-	0x0b808248, 0x07c016c8, 0x0c020dc0, 0x00000000, 0x078003c7,
-	0x0a6fc007, 0x0c791f80, 0x00000000, 0x07800992, 0x078009d3,
-	0x0680000f, 0x06800010, 0x06800007, 0x07c01507, 0x064c4707,
-	0x06810008, 0x0ac04207, 0x068000c7, 0x0c7feb00, 0x07c01507,
-	0x06490607, 0x0aefcc07, 0x00000000, 0x0540838f, 0x02c0e40e,
-	0x0fc081c0, 0x0a62c007, 0x00000000, 0x06900187, 0x06090607,
-	0x0609060e, 0x08090600, 0x08090600, 0x06985147, 0x06090607,
-	0x0c781f80, 0x00000000, 0x0aa28087, 0x0aa600c7, 0x00000000,
-	0x06800087, 0x06090607, 0x0609060e, 0x06881047, 0x06090607,
-	0x0c781100, 0x00000000, 0x06900087, 0x06090607, 0x0609060e,
-	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x0fc101c0,
-	0x091a1207, 0x095c11c8, 0x06090607, 0x06985047, 0x06090607,
-	0x0c780d40, 0x00000000, 0x06901087, 0x06090607, 0x0609060e,
-	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x0fc101c0,
-	0x091a1207, 0x095c11c8, 0x06090607, 0x06901207, 0x06090607,
-	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x0fc101c0,
-	0x091a1207, 0x095c11c8, 0x06090607, 0x06901407, 0x06090607,
-	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x0fc101c0,
-	0x091a1207, 0x095c11c8, 0x06090607, 0x06901607, 0x06090607,
-	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x0fc101c0,
-	0x091a1207, 0x095c11c8, 0x06090607, 0x06981047, 0x06090607,
-	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x0fc101c0,
-	0x091a1207, 0x095c11c8, 0x06090607, 0x080c2540, 0x080c0a10,
-	0x080c2c01, 0x080c2a00, 0x06800007, 0x098077c7, 0x060c2d07,
-	0x098073c7, 0x060c2f07, 0x0680000d, 0x06800009, 0x064c2407,
-	0x0a20c3c7, 0x0c7fff80, 0x00000000, 0x080c25c0, 0x06800707,
-	0x060e0007, 0x06bc000c, 0x06c0000c, 0x064c2507, 0x0a2fe007,
-	0x00000000, 0x0fc102c0, 0x0a80a30b, 0x0918428b, 0x06800049,
-	0x0aa0c3ca, 0x0c7ffe00, 0x060c240b, 0x060c270b, 0x0fc102c0,
-	0x0c7ffd00, 0x060c240b, 0x0aa14009, 0x00000000, 0x060c240c,
-	0x0c7801c0, 0x00000000, 0x060c2409, 0x064c2507, 0x0a2fe007,
-	0x00000000, 0x060c240c, 0x0400134d, 0x0aa0c18d, 0x0c7ff700,
-	0x00000000, 0x040013cf, 0x0a80348f, 0x0c7fda40, 0x00000000,
-	0x04001410, 0x0a8054d0, 0x00000000, 0x0680000f, 0x0c7fd8c0,
-	0x00000000, 0x06490907, 0x0befc047, 0x00000000, 0x0c78f580,
-	0x00000000, 0x07800347, 0x0a61c007, 0x00000000, 0x064c2907,
-	0x091c21c7, 0x0a60c0c7, 0x0c01ef40, 0x00000000, 0x0aa080a0,
-	0x0c780f40, 0x078003c7, 0x0a6fc007, 0x07801bc8, 0x0a63c008,
-	0x078004c8, 0x0a634348, 0x06800107, 0x07c003c7, 0x08030580,
-	0x068003c9, 0x07c00149, 0x06800007, 0x0c016240, 0x07c01d07,
-	0x07800007, 0x040011c7, 0x0c7fc780, 0x07c00007, 0x0c790300,
-	0x078003c7, 0x0a6fc007, 0x078005c7, 0x0ba0c087, 0x06800007,
-	0x06800047, 0x07c01fc7, 0x07800787, 0x0aa180c7, 0x06810007,
-	0x060e0907, 0x060e0a07, 0x0c780440, 0x060e0b07, 0x07800507,
-	0x0aa0c007, 0x068000c8, 0x068003c8, 0x060e1408, 0x064e1507,
-	0x060e0907, 0x04003208, 0x060e1408, 0x064e1507, 0x060e0a07,
-	0x04003208, 0x060e1408, 0x064e1507, 0x060e0b07, 0x0683ffc7,
-	0x080e1418, 0x060e1507, 0x080e141b, 0x060e1507, 0x080e141e,
-	0x060e1507, 0x080e1421, 0x0c01d1c0, 0x060e1507, 0x0c7854c0,
-	0x00000000, 0x0aa60020, 0x00000000, 0x0fc011c0, 0x0aa58007,
-	0x080c2803, 0x06800347, 0x07c00147, 0x080c24a0, 0x060c2224,
-	0x060c2224, 0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07,
-	0x091011c7, 0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7,
-	0x0aae8007, 0x0c7ff0c0, 0x080c2800, 0x0c7fb340, 0x00000000,
-	0x080c2801, 0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008,
-	0x0c7fb180, 0x058011c7, 0x09004207, 0x07c00148, 0x090821c7,
-	0x07c00187, 0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781900,
-	0x00000000, 0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802,
-	0x064c2807, 0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207,
-	0x07c01388, 0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0,
-	0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089, 0x04401249,
-	0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809, 0x04401249,
-	0x068007c9, 0x07c00109, 0x0c010540, 0x040001c9, 0x07801fcb,
-	0x0aa1400b, 0x078005c9, 0x0b60c089, 0x0c004880, 0x00000000,
-	0x068fdfca, 0x06feffca, 0x064e0408, 0x02808288, 0x078005ca,
-	0x0ba0c08a, 0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a,
-	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
-	0x098081c8, 0x07802007, 0x09605207, 0x07800007, 0x040811c7,
+	0x00000000, 0x00000000, 0x0c780400, 0x04001965, 0x0cc00000,
+	0x00400000, 0x0c780540, 0x064c0007, 0x0c79a880, 0x06800025,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c7a0080, 0x06800025, 0x0cc00000, 0x00400000,
+	0x06800025, 0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409,
+	0x0c781240, 0x00000000, 0x078001c9, 0x0aa0c009, 0x0c7905c0,
+	0x00000000, 0x06bfdd89, 0x06030409, 0x00400000, 0x07801509,
+	0x0aa30109, 0x07c0151f, 0x0a2bc047, 0x06800025, 0x0aac80c9,
+	0x0aa14009, 0x0a608049, 0x0c791000, 0x0a608089, 0x0c790200,
+	0x0a240807, 0x0c78bb40, 0x00000000, 0x0683ffc8, 0x0ba20048,
+	0x064c0007, 0x0a2f8047, 0x04401208, 0x064c3a07, 0x090061c7,
+	0x0aae8647, 0x00000000, 0x06800007, 0x0c017800, 0x07c003c7,
+	0x0c793140, 0x0bec9007, 0x078003c7, 0x0a6fc007, 0x07800007,
+	0x07800988, 0x0b81c207, 0x06800007, 0x07c00007, 0x0a61c060,
+	0x06a00008, 0x06e00008, 0x080c24a0, 0x060c2208, 0x0c780240,
+	0x060c2208, 0x0a61c0a0, 0x00000000, 0x080c24c0, 0x080c2200,
+	0x080c2200, 0x080c2200, 0x080c2200, 0x078016c8, 0x04001208,
+	0x078009c9, 0x0b808248, 0x07c016c8, 0x0c0217c0, 0x00000000,
+	0x078003c7, 0x0a6fc007, 0x0c792940, 0x00000000, 0x07800992,
+	0x078009d3, 0x0680000f, 0x06800010, 0x06800007, 0x07c01507,
+	0x064c4707, 0x06810008, 0x0ac04207, 0x068000c7, 0x0c7feb00,
+	0x07c01507, 0x06490607, 0x0aefcc07, 0x00000000, 0x0540838f,
+	0x02c0e40e, 0x0fc081c0, 0x0a62c007, 0x00000000, 0x06900187,
+	0x06090607, 0x0609060e, 0x08090600, 0x08090600, 0x06985147,
+	0x06090607, 0x0c781f80, 0x00000000, 0x0aa28087, 0x0aa600c7,
+	0x00000000, 0x06800087, 0x06090607, 0x0609060e, 0x06881047,
+	0x06090607, 0x0c781100, 0x00000000, 0x06900087, 0x06090607,
+	0x0609060e, 0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607,
+	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x06985047,
+	0x06090607, 0x0c780d40, 0x00000000, 0x06901087, 0x06090607,
+	0x0609060e, 0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607,
+	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x06901207,
+	0x06090607, 0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607,
+	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x06901407,
+	0x06090607, 0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607,
+	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x06901607,
+	0x06090607, 0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607,
+	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x06981047,
+	0x06090607, 0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607,
+	0x0fc101c0, 0x091a1207, 0x095c11c8, 0x06090607, 0x080c2540,
+	0x080c0a10, 0x080c2c01, 0x080c2a00, 0x06800007, 0x098077c7,
+	0x060c2d07, 0x098073c7, 0x060c2f07, 0x0680000d, 0x06800009,
+	0x064c2407, 0x0a20c3c7, 0x0c7fff80, 0x00000000, 0x080c25c0,
+	0x06800707, 0x060e0007, 0x06bc000c, 0x06c0000c, 0x064c2507,
+	0x0a2fe007, 0x00000000, 0x0fc102c0, 0x0a80a30b, 0x0918428b,
+	0x06800049, 0x0aa0c3ca, 0x0c7ffe00, 0x060c240b, 0x060c270b,
+	0x0fc102c0, 0x0c7ffd00, 0x060c240b, 0x0aa14009, 0x00000000,
+	0x060c240c, 0x0c7801c0, 0x00000000, 0x060c2409, 0x064c2507,
+	0x0a2fe007, 0x00000000, 0x060c240c, 0x0400134d, 0x0aa0c18d,
+	0x0c7ff700, 0x00000000, 0x040013cf, 0x0a80348f, 0x0c7fda40,
+	0x00000000, 0x04001410, 0x0a8054d0, 0x00000000, 0x0680000f,
+	0x0c7fd8c0, 0x00000000, 0x06490907, 0x0befc047, 0x00000000,
+	0x0c78ff40, 0x00000000, 0x07800347, 0x0aa0c007, 0x0c780880,
+	0x00000000, 0x064c1d07, 0x09227207, 0x0a678008, 0x064c2a08,
+	0x064c3607, 0x091081c7, 0x095101c8, 0x064c3b08, 0x09103248,
+	0x04001209, 0x03807207, 0x0900f207, 0x0a650008, 0x0580f1c7,
+	0x06800048, 0x05407208, 0x03808248, 0x04401208, 0x0a40e207,
+	0x064c1d07, 0x0a60c009, 0x00000000, 0x054081c7, 0x06800009,
+	0x09201207, 0x0a610008, 0x054011c7, 0x0c7fff40, 0x04001249,
+	0x060c0e09, 0x0c01f240, 0x00000000, 0x0aa080a0, 0x0c780f40,
+	0x078003c7, 0x0a6fc007, 0x07801bc8, 0x0a63c008, 0x078004c8,
+	0x0a634348, 0x06800107, 0x07c003c7, 0x08030580, 0x068003c9,
+	0x07c00149, 0x06800007, 0x0c016540, 0x07c01d07, 0x07800007,
+	0x040011c7, 0x0c7fc080, 0x07c00007, 0x0c7905c0, 0x078003c7,
+	0x0a6fc007, 0x078005c7, 0x0ba0c087, 0x06800007, 0x06800047,
+	0x07c01fc7, 0x07800787, 0x0aa180c7, 0x06810007, 0x060e0907,
+	0x060e0a07, 0x0c780440, 0x060e0b07, 0x07800507, 0x0aa0c007,
+	0x068000c8, 0x068003c8, 0x060e1408, 0x064e1507, 0x060e0907,
+	0x04003208, 0x060e1408, 0x064e1507, 0x060e0a07, 0x04003208,
+	0x060e1408, 0x064e1507, 0x060e0b07, 0x0683ffc7, 0x080e1418,
+	0x060e1507, 0x080e141b, 0x060e1507, 0x080e141e, 0x060e1507,
+	0x080e1421, 0x0c01d4c0, 0x060e1507, 0x0c785500, 0x00000000,
+	0x0aa60020, 0x00000000, 0x0fc011c0, 0x0aa58007, 0x080c2803,
+	0x06800347, 0x07c00147, 0x080c24a0, 0x060c2224, 0x060c2224,
+	0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07, 0x091011c7,
+	0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7, 0x0aae8007,
+	0x0c7ff0c0, 0x080c2800, 0x0c7fac40, 0x00000000, 0x080c2801,
+	0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008, 0x0c7faa80,
+	0x058011c7, 0x09004207, 0x07c00148, 0x090821c7, 0x07c00187,
+	0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940, 0x00000000,
+	0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802, 0x064c2807,
+	0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207, 0x07c01388,
+	0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0, 0x0b61c087,
+	0x07800109, 0x024091c9, 0x0b620089, 0x04401249, 0x0c780180,
+	0x06800049, 0x020091c9, 0x0b20c809, 0x04401249, 0x068007c9,
+	0x07c00109, 0x0c010800, 0x040001c9, 0x07801fcb, 0x0aa1400b,
+	0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000, 0x068fdfca,
+	0x06feffca, 0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a,
+	0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a,
+	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
+	0x07808007, 0x09605207, 0x07800007, 0x06808049, 0x02007247,
 	0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248, 0x07c01fc9,
 	0x07801388, 0x060c2b08, 0x06880008, 0x098083c8, 0x07800507,
 	0x07801989, 0x0a610049, 0x09581207, 0x09808408, 0x098083c8,
 	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
 	0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0, 0x07c01cc7,
-	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01b240, 0x00000000,
-	0x080c0080, 0x0c012f80, 0x00000000, 0x080c24a0, 0x080c2200,
+	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01b500, 0x00000000,
+	0x080c0080, 0x0c013240, 0x00000000, 0x080c24a0, 0x080c2200,
 	0x080c2200, 0x07800007, 0x040011c7, 0x07c00007, 0x07800147,
-	0x0c010580, 0x07c00447, 0x0c7f9000, 0x00000000, 0x0a60c0e0,
+	0x0c010800, 0x07c00447, 0x0c7f88c0, 0x00000000, 0x0a60c0e0,
 	0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802, 0x064c2807,
 	0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8, 0x07800188,
 	0x09444207, 0x07c01388, 0x07800148, 0x0a644048, 0x080c2800,
 	0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089,
 	0x04401249, 0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809,
-	0x04401249, 0x068007c9, 0x07c00109, 0x0c00ec00, 0x040001c9,
+	0x04401249, 0x068007c9, 0x07c00109, 0x0c00ee80, 0x040001c9,
 	0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007, 0x0c7806c0,
 	0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0, 0x07c01cc7,
 	0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148, 0x07800489,
@@ -1799,22 +1807,24 @@ const u32 __initconst h263_mc[] = {
 	0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147, 0x078004c7,
 	0x07c00387, 0x07800487, 0x07c00247, 0x07801107, 0x07c01787,
 	0x06800107, 0x07c003c7, 0x08030580, 0x064c2407, 0x0befc3c7,
-	0x00000000, 0x07800147, 0x0aa10147, 0x0c010d40, 0x00000000,
-	0x0c7800c0, 0x0c013f00, 0x00000000, 0x07800007, 0x040011c7,
-	0x0c7f6740, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
+	0x00000000, 0x07800147, 0x0aa10147, 0x0c011000, 0x00000000,
+	0x0c7800c0, 0x0c0141c0, 0x00000000, 0x07800007, 0x040011c7,
+	0x0c7f6000, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
 	0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca, 0x06feffca,
 	0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a, 0x064c0909,
 	0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a, 0x0400128a,
 	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x060e0408,
-	0x091e1248, 0x07c01fc9, 0x0c017f40, 0x00000000, 0x064c2407,
+	0x091e1248, 0x07c01fc9, 0x0c018200, 0x00000000, 0x064c2407,
 	0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000, 0x080c2130,
-	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c010200, 0x00000000,
+	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c0104c0, 0x00000000,
 	0x07800007, 0x040011c7, 0x07c00007, 0x07801d08, 0x07801d47,
 	0x09421207, 0x07801d87, 0x09441207, 0x07c00308, 0x07800148,
-	0x0aa0c348, 0x07c00448, 0x0c7f5a40, 0x078003c7, 0x0a6fc007,
+	0x0aa0c348, 0x07c00448, 0x0c7f5300, 0x078003c7, 0x0a6fc007,
 	0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0,
-	0x060c2207, 0x0c7f6280, 0x060c2208, 0x0780044b, 0x0aa1034b,
-	0x064e160b, 0x090102cb, 0x0aaf800b, 0x0681000b, 0x060e090b,
+	0x060c2207, 0x0c7f5b40, 0x060c2208, 0x0780044b, 0x0aa3834b,
+	0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009, 0x00000000,
+	0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140, 0x00000000,
+	0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b, 0x060e090b,
 	0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009, 0x064e0e0b,
 	0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d,
 	0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
@@ -1837,7 +1847,7 @@ const u32 __initconst h263_mc[] = {
 	0x0609c507, 0x0fc011c0, 0x0aa30007, 0x00000000, 0x0fc021c0,
 	0x07c018c7, 0x0fc021c0, 0x0a21c047, 0x00000000, 0x0fc101c0,
 	0x0fc101c0, 0x0fc101c0, 0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0,
-	0x0aa0c007, 0x0c7f4100, 0x00000000, 0x0fc011c0, 0x0fc101c0,
+	0x0aa0c007, 0x0c7f3740, 0x00000000, 0x0fc011c0, 0x0fc101c0,
 	0x07c01907, 0x0649c308, 0x09410207, 0x0609c308, 0x0b220087,
 	0x06800048, 0x06800008, 0x06800049, 0x0b004247, 0x05401249,
 	0x0c7fff80, 0x04001208, 0x07c01408, 0x0fc021c0, 0x0a21c047,
@@ -1865,7 +1875,7 @@ const u32 __initconst h263_mc[] = {
 	0x060e030a, 0x04c08208, 0x060e0008, 0x07801807, 0x0aa18047,
 	0x00000000, 0x0fc011c0, 0x0540b1c7, 0x09807007, 0x060c0107,
 	0x0fc011c0, 0x0aa60007, 0x0fc011c0, 0x07c00347, 0x0aa0c047,
-	0x0c014140, 0x00000000, 0x0fc011c0, 0x0a20c047, 0x00000000,
+	0x0c014180, 0x00000000, 0x0fc011c0, 0x0a20c047, 0x00000000,
 	0x0fc011c0, 0x07801807, 0x06800008, 0x0aa18047, 0x06800007,
 	0x0fc011c0, 0x0a624007, 0x0fc01200, 0x0a61c008, 0x07c01a07,
 	0x07c01a48, 0x0fc011c0, 0x046011c7, 0x0c57e900, 0x0c784400,
@@ -1879,10 +1889,10 @@ const u32 __initconst h263_mc[] = {
 	0x058044d3, 0x07c009d3, 0x06800007, 0x060c0307, 0x0fc08800,
 	0x0fc081c0, 0x07c01b07, 0x06800047, 0x060c0a07, 0x06820207,
 	0x060e0407, 0x06800025, 0x06490908, 0x0ae10225, 0x00000000,
-	0x0bef4048, 0x0c780080, 0x0c7f0c00, 0x0683ffc7, 0x0649bb08,
+	0x0bef4048, 0x0c780080, 0x0c7f0240, 0x0683ffc7, 0x0649bb08,
 	0x0900c208, 0x0aa10008, 0x0aa0c007, 0x0c7fff00, 0x044011c7,
 	0x06490b07, 0x09807007, 0x06090b07, 0x06090b07, 0x09c07007,
-	0x06090b07, 0x0649c909, 0x0aa10009, 0x06800087, 0x0c7f0100,
+	0x06090b07, 0x0649c909, 0x0aa10009, 0x06800087, 0x0c7ef740,
 	0x07c01507, 0x07801487, 0x0a608007, 0x0c780bc0, 0x044011c7,
 	0x040002c7, 0x07801589, 0x0b20c1c9, 0x00000000, 0x0c780a40,
 	0x07800fc8, 0x0609ca08, 0x07c00fdf, 0x0680420a, 0x02007289,
@@ -1902,7 +1912,7 @@ const u32 __initconst h263_mc[] = {
 	0x06800108, 0x078048ca, 0x07804908, 0x09610288, 0x0a240807,
 	0x06800148, 0x0780494a, 0x07804988, 0x09610288, 0x0a22d007,
 	0x06800188, 0x078049ca, 0x07804a08, 0x09610288, 0x0a21a007,
-	0x068001c8, 0x0809cd11, 0x06800047, 0x0c7ee840, 0x07c01507,
+	0x068001c8, 0x0809cd11, 0x06800047, 0x0c7ede80, 0x07c01507,
 	0x0809cd00, 0x07801607, 0x090041c7, 0x0a8041c8, 0x07801607,
 	0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207, 0x0c7ff1c0,
 	0x02c091c9, 0x07800b47, 0x0680400f, 0x020093c8, 0x07400247,
@@ -1922,17 +1932,17 @@ const u32 __initconst h263_mc[] = {
 	0x054103cf, 0x07801c47, 0x0a614047, 0x00000000, 0x05810208,
 	0x0c7800c0, 0x00000000, 0x058103cf, 0x02c083c8, 0x06098108,
 	0x06499108, 0x05410208, 0x058103c8, 0x02c083c8, 0x06098208,
-	0x080980f4, 0x07801b07, 0x06800048, 0x09421207, 0x0c7ee180,
+	0x080980f4, 0x07801b07, 0x06800048, 0x09421207, 0x0c7ed7c0,
 	0x06090708, 0x06800025, 0x0ae20225, 0x064c0007, 0x0a2f8047,
 	0x00000000, 0x064c3a07, 0x090061c7, 0x0aae8647, 0x0c7800c0,
-	0x0c7ed300, 0x00000000, 0x080c2800, 0x080c0002, 0x0c7ecb40,
+	0x0c7ec940, 0x00000000, 0x080c2800, 0x080c0002, 0x0c7ec180,
 	0x00000000, 0x0649c007, 0x07c04647, 0x058101c7, 0x07c04687,
 	0x0649c107, 0x07c046c7, 0x058101c7, 0x07c04707, 0x0649c207,
 	0x07c04747, 0x058101c7, 0x07c04787, 0x0649c307, 0x07c047c7,
 	0x058101c7, 0x07c04807, 0x0649d007, 0x07c04847, 0x058101c7,
 	0x07c04887, 0x0649d107, 0x07c048c7, 0x058101c7, 0x07c04907,
 	0x0649d207, 0x07c04947, 0x058101c7, 0x07c04987, 0x0649d307,
-	0x07c049c7, 0x058101c7, 0x07c04a07, 0x0c0042c0, 0x06800025,
+	0x07c049c7, 0x058101c7, 0x07c04a07, 0x0c004300, 0x06800025,
 	0x08002501, 0x08002605, 0x08002708, 0x08002815, 0x08002c14,
 	0x06804002, 0x060c2902, 0x06800802, 0x06804043, 0x0d000002,
 	0x060e0203, 0x06800802, 0x06804043, 0x0d000002, 0x060e0303,
@@ -1950,8 +1960,8 @@ const u32 __initconst h263_mc[] = {
 	0x060c2207, 0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207,
 	0x080c2147, 0x064c2407, 0x0befc3c7, 0x078004c7, 0x07c00387,
 	0x07800487, 0x07c00247, 0x07801107, 0x07c01787, 0x06800107,
-	0x07c003c7, 0x0c008380, 0x00000000, 0x08030580, 0x07800007,
-	0x040011c7, 0x07c00007, 0x0c7eb5c0, 0x00000000, 0x0fc01200,
+	0x07c003c7, 0x0c0083c0, 0x00000000, 0x08030580, 0x07800007,
+	0x040011c7, 0x07c00007, 0x0c7eac00, 0x00000000, 0x0fc01200,
 	0x0fc011c0, 0x0aa28047, 0x06800147, 0x0fc011c0, 0x0aa1c047,
 	0x06800187, 0x0fc011c0, 0x0aa10047, 0x068001c7, 0x0fc011c0,
 	0x06800207, 0x07c00147, 0x0a60c008, 0x06800007, 0x0fc061c0,
@@ -1959,7 +1969,7 @@ const u32 __initconst h263_mc[] = {
 	0x00000000, 0x0fc011c0, 0x0aa38007, 0x07800108, 0x0fc011c0,
 	0x0aa14007, 0x0b21c748, 0x04002208, 0x0c780140, 0x068007c8,
 	0x0b60c0c8, 0x04402208, 0x06800048, 0x07c00108, 0x0c0005c0,
-	0x040001c8, 0x0c7f19c0, 0x00000000, 0x06a00007, 0x06e00007,
+	0x040001c8, 0x0c7f1740, 0x00000000, 0x06a00007, 0x06e00007,
 	0x080c24a0, 0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207,
 	0x060c2207, 0x0cc00000, 0x060c2207, 0x07801988, 0x094c11c8,
 	0x0c07fd00, 0x060e0407, 0x06800007, 0x07c01cc7, 0x07c00907,
@@ -1978,164 +1988,164 @@ const u32 __initconst h263_mc[] = {
 	0x06800047, 0x06800087, 0x05c0438e, 0x0540138e, 0x0200e1ce,
 	0x0ae1000f, 0x06bfffcd, 0x0300e34e, 0x0400138e, 0x0cc00000,
 	0x040003ce, 0x07800007, 0x0ae10007, 0x07800109, 0x07800988,
-	0x02007207, 0x044011c7, 0x040811c7, 0x074001c9, 0x0cc00000,
-	0x07c02009, 0x0681f409, 0x04401249, 0x0aefc009, 0x00000000,
-	0x083f0040, 0x083f0000, 0x08090b65, 0x00000000, 0x08090b60,
-	0x06498e07, 0x09807007, 0x068007c9, 0x097051c9, 0x06098e07,
-	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x06800009,
-	0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187,
-	0x09807207, 0x060c0007, 0x064c0807, 0x09807347, 0x060c0807,
-	0x083f0040, 0x083f0000, 0x08090b65, 0x0cc00000, 0x08090b60,
-	0x0680001f, 0x07c0149f, 0x07c014df, 0x07c0151f, 0x064c091f,
-	0x07c0175f, 0x07c0005f, 0x06800020, 0x06803fc2, 0x07c01542,
-	0x07c01582, 0x07c015c2, 0x07c01602, 0x060c091f, 0x080c0101,
-	0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226, 0x024269e6,
-	0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726, 0x0649cf31,
-	0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207, 0x092101c7,
-	0x0401f287, 0x0580528a, 0x0403e247, 0x05806249, 0x09610289,
-	0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7,
-	0x060c0907, 0x07c00987, 0x04401247, 0x07c00609, 0x05404287,
-	0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208, 0x05804208,
-	0x07c009c8, 0x05404208, 0x0961020a, 0x06090808, 0x0809c300,
-	0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803, 0x0aa14003,
-	0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800, 0x07801502,
-	0x0aa0c002, 0x06800102, 0x06030502, 0x064c0002, 0x0be14042,
-	0x0ba1d025, 0x06800102, 0x07c01502, 0x08030504, 0x06800025,
-	0x0cc00000, 0x00000000, 0x078001c2, 0x0aa1c002, 0x078016c2,
-	0x078009c3, 0x0a4040c2, 0x00000000, 0x06800102, 0x06030502,
-	0x0cc00000, 0x00000000, 0x0fc02240, 0x0aa4c009, 0x0680000a,
-	0x0b6180c9, 0x0680010a, 0x0fc01280, 0x09422289, 0x0c780140,
-	0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a, 0x06800049,
-	0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a, 0x05401249,
-	0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000, 0x0fc01240,
-	0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e6340, 0x00000000,
-	0x06490628, 0x0aefcc28, 0x00000000, 0x07800028, 0x078016e9,
-	0x09508a68, 0x068000a8, 0x06c00028, 0x06090628, 0x06090629,
-	0x06881068, 0x06090628, 0x0cc00000, 0x00000000, 0x06490628,
-	0x0aefcc28, 0x06c00028, 0x069001a8, 0x069fffea, 0x06090628,
-	0x06090629, 0x05401a23, 0x06090628, 0x09210a23, 0x05401a28,
-	0x02828aa8, 0x06090628, 0x06985168, 0x0c783280, 0x06090628,
-	0x078003e8, 0x0a6fc028, 0x07800028, 0x078016e9, 0x06800030,
-	0x09508a68, 0x0780016b, 0x07801d2a, 0x04601aaa, 0x0c501a40,
-	0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b, 0x0aa883eb,
-	0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb, 0x06c0002a,
-	0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb, 0x0c500980,
-	0x0690002a, 0x0c7e5c40, 0x00000000, 0x06490628, 0x0aefcc28,
-	0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629,
-	0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400, 0x080e1424,
-	0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x09210a68, 0x06090628, 0x02828ae9, 0x06090628, 0x06a00028,
-	0x0a007a2a, 0x080c2440, 0x064c2228, 0x09210a68, 0x06090628,
-	0x02828ae9, 0x06090628, 0x0688d068, 0x02c28aa8, 0x09441a30,
-	0x0c782300, 0x06090628, 0x0c000100, 0x09441ab0, 0x0c782200,
-	0x00000000, 0x0680002c, 0x080e1424, 0x069fffeb, 0x06490628,
-	0x0aefcc28, 0x05404a2c, 0x060c2428, 0x068010a8, 0x02c28aa8,
-	0x09462a2c, 0x06090628, 0x06090629, 0x064c2228, 0x060e1528,
-	0x09210b68, 0x06090628, 0x02828aed, 0x06090628, 0x06a00028,
-	0x0a009a2a, 0x05404a2c, 0x098281a8, 0x060c2428, 0x064c2228,
-	0x09210b68, 0x06090628, 0x02828aed, 0x06090628, 0x0ba9c0ec,
-	0x04001b2c, 0x06881068, 0x02c28aa8, 0x06090628, 0x080c2480,
-	0x064c2228, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
-	0x06a00028, 0x0a006a2a, 0x064c2228, 0x09210b68, 0x06090628,
-	0x02828aed, 0x06090628, 0x0cc00000, 0x00000000, 0x0aa241eb,
-	0x06a0002a, 0x0aa1c1ab, 0x06b0002a, 0x0aa1416b, 0x0aa1026b,
-	0x06800070, 0x0690002a, 0x06800030, 0x06490628, 0x0aefcc28,
-	0x06c0002a, 0x068408a8, 0x02c28aa8, 0x09441a30, 0x06090628,
-	0x06090629, 0x069fffec, 0x06900028, 0x0a00ba2a, 0x080c2400,
-	0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28,
-	0x09828428, 0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028,
-	0x0a00ba2a, 0x080c2440, 0x064c2228, 0x06090628, 0x09210a28,
-	0x09c28068, 0x02828b28, 0x09828428, 0x07801ded, 0x095e1a2d,
-	0x06090628, 0x068c5828, 0x02c28aa8, 0x09441a30, 0x06090628,
-	0x06860828, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06900028,
-	0x0a00ba2a, 0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f,
-	0x09c28068, 0x02828b28, 0x09828428, 0x07801dad, 0x095e1a2d,
-	0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2450, 0x064c2228,
-	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
-	0x07801e2d, 0x095e1a2d, 0x06090628, 0x068ed868, 0x02c28aa8,
-	0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228,
-	0x060e152e, 0x060e152f, 0x060e1528, 0x0c780080, 0x060e1528,
-	0x0cc00000, 0x00000000, 0x07800028, 0x078016e9, 0x06800030,
-	0x09508a68, 0x0780016b, 0x0780026a, 0x04601aaa, 0x0c500b80,
-	0x0aa1416b, 0x00000000, 0x06800070, 0x0a61826b, 0x00000000,
-	0x078003a8, 0x04602a28, 0x0c500840, 0x0c7800c0, 0x0c780000,
-	0x00000000, 0x06490628, 0x0aefcc28, 0x06b000a8, 0x09441a30,
-	0x06090628, 0x06090629, 0x069fffeb, 0x06900028, 0x080c2400,
+	0x02007207, 0x044011c7, 0x06808048, 0x02007207, 0x074001c9,
+	0x0cc00000, 0x07c08009, 0x0681f409, 0x04401249, 0x0aefc009,
+	0x00000000, 0x083f0040, 0x083f0000, 0x08090b65, 0x00000000,
+	0x08090b60, 0x06498e07, 0x09807007, 0x068007c9, 0x097051c9,
+	0x06098e07, 0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000,
+	0x06800009, 0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007,
+	0x09c07187, 0x09807207, 0x060c0007, 0x064c0807, 0x09807347,
+	0x060c0807, 0x083f0040, 0x083f0000, 0x08090b65, 0x0cc00000,
+	0x08090b60, 0x0680001f, 0x07c0149f, 0x07c014df, 0x07c0151f,
+	0x064c091f, 0x07c0175f, 0x07c0005f, 0x06800020, 0x06803fc2,
+	0x07c01542, 0x07c01582, 0x07c015c2, 0x07c01602, 0x060c091f,
+	0x080c0101, 0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226,
+	0x024269e6, 0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726,
+	0x0649cf31, 0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207,
+	0x092101c7, 0x0401f287, 0x0580528a, 0x0403e247, 0x05806249,
+	0x09610289, 0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7,
+	0x058041c7, 0x060c0907, 0x07c00987, 0x04401247, 0x07c00609,
+	0x05404287, 0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208,
+	0x05804208, 0x07c009c8, 0x05404208, 0x0961020a, 0x06090808,
+	0x0809c300, 0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803,
+	0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800,
+	0x07801502, 0x0aa0c002, 0x06800102, 0x06030502, 0x064c0002,
+	0x0be14042, 0x0ba1d025, 0x06800102, 0x07c01502, 0x08030504,
+	0x06800025, 0x0cc00000, 0x00000000, 0x078001c2, 0x0aa1c002,
+	0x078016c2, 0x078009c3, 0x0a4040c2, 0x00000000, 0x06800102,
+	0x06030502, 0x0cc00000, 0x00000000, 0x0fc02240, 0x0aa4c009,
+	0x0680000a, 0x0b6180c9, 0x0680010a, 0x0fc01280, 0x09422289,
+	0x0c780140, 0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a,
+	0x06800049, 0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a,
+	0x05401249, 0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000,
+	0x0fc01240, 0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e5940,
+	0x00000000, 0x06490628, 0x0aefcc28, 0x00000000, 0x07800028,
+	0x078016e9, 0x09508a68, 0x068000a8, 0x06c00028, 0x06090628,
+	0x06090629, 0x06881068, 0x06090628, 0x0cc00000, 0x00000000,
+	0x06490628, 0x0aefcc28, 0x06c00028, 0x069001a8, 0x069fffea,
+	0x06090628, 0x06090629, 0x05401a23, 0x06090628, 0x09210a23,
+	0x05401a28, 0x02828aa8, 0x06090628, 0x06985168, 0x0c783280,
+	0x06090628, 0x078003e8, 0x0a6fc028, 0x07800028, 0x078016e9,
+	0x06800030, 0x09508a68, 0x0780016b, 0x07801d2a, 0x04601aaa,
+	0x0c501a40, 0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b,
+	0x0aa883eb, 0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb,
+	0x06c0002a, 0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb,
+	0x0c500980, 0x0690002a, 0x0c7e5240, 0x00000000, 0x06490628,
+	0x0aefcc28, 0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x06090629, 0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400,
 	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
 	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
-	0x080c2440, 0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9,
-	0x06090628, 0x06b8d068, 0x09441a30, 0x0c7812c0, 0x06090628,
-	0x06b0002a, 0x0c07d1c0, 0x09441ab0, 0x0c7ff2c0, 0x00000000,
-	0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0c7ff640, 0x00000000,
-	0x06490628, 0x0aefcc28, 0x06b408a8, 0x09441a30, 0x06090628,
-	0x06090629, 0x069fffec, 0x06900028, 0x080c2400, 0x064c222e,
-	0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28, 0x09828428,
-	0x078017ad, 0x095e1a2d, 0x06090628, 0x080c2440, 0x064c2228,
-	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
-	0x06090628, 0x06bc5828, 0x09441a30, 0x06090628, 0x06b60828,
-	0x09441a30, 0x06090628, 0x06900028, 0x080c2410, 0x064c222f,
-	0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28, 0x09828428,
-	0x078017ad, 0x05801b6d, 0x095e1a2d, 0x06090628, 0x080c2450,
+	0x06a00028, 0x0a007a2a, 0x080c2440, 0x064c2228, 0x09210a68,
+	0x06090628, 0x02828ae9, 0x06090628, 0x0688d068, 0x02c28aa8,
+	0x09441a30, 0x0c782300, 0x06090628, 0x0c000100, 0x09441ab0,
+	0x0c782200, 0x00000000, 0x0680002c, 0x080e1424, 0x069fffeb,
+	0x06490628, 0x0aefcc28, 0x05404a2c, 0x060c2428, 0x068010a8,
+	0x02c28aa8, 0x09462a2c, 0x06090628, 0x06090629, 0x064c2228,
+	0x060e1528, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
+	0x06a00028, 0x0a009a2a, 0x05404a2c, 0x098281a8, 0x060c2428,
+	0x064c2228, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
+	0x0ba9c0ec, 0x04001b2c, 0x06881068, 0x02c28aa8, 0x06090628,
+	0x080c2480, 0x064c2228, 0x09210b68, 0x06090628, 0x02828aed,
+	0x06090628, 0x06a00028, 0x0a006a2a, 0x064c2228, 0x09210b68,
+	0x06090628, 0x02828aed, 0x06090628, 0x0cc00000, 0x00000000,
+	0x0aa241eb, 0x06a0002a, 0x0aa1c1ab, 0x06b0002a, 0x0aa1416b,
+	0x0aa1026b, 0x06800070, 0x0690002a, 0x06800030, 0x06490628,
+	0x0aefcc28, 0x06c0002a, 0x068408a8, 0x02c28aa8, 0x09441a30,
+	0x06090628, 0x06090629, 0x069fffec, 0x06900028, 0x0a00ba2a,
+	0x080c2400, 0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068,
+	0x02828b28, 0x09828428, 0x07801d6d, 0x095e1a2d, 0x06090628,
+	0x06a00028, 0x0a00ba2a, 0x080c2440, 0x064c2228, 0x06090628,
+	0x09210a28, 0x09c28068, 0x02828b28, 0x09828428, 0x07801ded,
+	0x095e1a2d, 0x06090628, 0x068c5828, 0x02c28aa8, 0x09441a30,
+	0x06090628, 0x06860828, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x06900028, 0x0a00ba2a, 0x080c2410, 0x064c222f, 0x0609062f,
+	0x09210a2f, 0x09c28068, 0x02828b28, 0x09828428, 0x07801dad,
+	0x095e1a2d, 0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2450,
 	0x064c2228, 0x06090628, 0x09210a28, 0x09c28068, 0x02828b28,
-	0x09828428, 0x098283e8, 0x06090628, 0x06bed868, 0x09441a30,
-	0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228, 0x060e152e,
-	0x060e152f, 0x060e1528, 0x060e1528, 0x0cc00000, 0x00000000,
-	0x064e1215, 0x091e1555, 0x0a208055, 0x0c782280, 0x0649d915,
-	0x0900c555, 0x0a6f8015, 0x00000000, 0x078003d5, 0x0aa08055,
-	0x0c780940, 0x07800596, 0x0aa1c016, 0x04401596, 0x07c00596,
-	0x078005d6, 0x04401596, 0x0c7814c0, 0x07c005d6, 0x07800916,
-	0x07800295, 0x05408555, 0x02015595, 0x04003596, 0x07c00916,
-	0x05404595, 0x02016c56, 0x060e1316, 0x07800517, 0x0aa0c017,
-	0x06a16016, 0x06a16196, 0x07c00416, 0x069fffd7, 0x044015d7,
-	0x0aa1c017, 0x00000000, 0x064e1615, 0x09010555, 0x0aaec015,
-	0x04401555, 0x060e1615, 0x06c00016, 0x060e1216, 0x06800095,
-	0x0c781800, 0x07c003d5, 0x0a660095, 0x078005d6, 0x0aa18016,
-	0x04401596, 0x0b210056, 0x07c005d6, 0x0c780bc0, 0x00000000,
-	0x07800956, 0x07800295, 0x05408555, 0x02015595, 0x04003596,
-	0x07c00956, 0x05404595, 0x02016c56, 0x060e1316, 0x07800415,
-	0x09c151d5, 0x06c00015, 0x060e1215, 0x068000d5, 0x0c781200,
-	0x07c003d5, 0x0aa080d5, 0x0c780700, 0x07800516, 0x0aa0c016,
-	0x06800017, 0x06800317, 0x060e1417, 0x07800795, 0x07c00755,
-	0x0683ffd5, 0x064e1516, 0x0900c5d6, 0x0a40b5d5, 0x091845d6,
-	0x07c00797, 0x064e1516, 0x064e1516, 0x064e1516, 0x080c24e0,
-	0x060c2216, 0x064e1516, 0x0c780200, 0x060c2216, 0x068000d6,
-	0x07c00796, 0x06800016, 0x080c24e0, 0x060c2216, 0x060c2216,
-	0x0aa080a0, 0x0c780980, 0x078003d5, 0x0a644115, 0x07800956,
-	0x068ac015, 0x05408555, 0x02015595, 0x04003596, 0x07c00956,
-	0x05404595, 0x02016c56, 0x060e1316, 0x06a16015, 0x09c151d5,
-	0x06c00015, 0x060e1215, 0x06800195, 0x0c7805c0, 0x07c003d5,
-	0x0aa0c195, 0x0c780480, 0x00000000, 0x064e1418, 0x080e1400,
-	0x064e1516, 0x0683ffd5, 0x0900c5d6, 0x09203656, 0x0a8045d5,
-	0x091845d6, 0x068000d7, 0x06800019, 0x07c004d7, 0x090015d9,
-	0x07c00497, 0x090225d9, 0x07c01117, 0x060e1418, 0x06800015,
-	0x07c003d5, 0x0cc00000, 0x00400000, 0x06800047, 0x07c003c7,
-	0x07800507, 0x050011c7, 0x07c00507, 0x064e1608, 0x09010208,
-	0x04001208, 0x060e1608, 0x0aa0c007, 0x06800008, 0x06800308,
-	0x060e1408, 0x06b7ffc7, 0x06c00007, 0x060e1507, 0x060e1524,
-	0x060e1524, 0x060e1524, 0x060e1524, 0x0cc00000, 0x08030580,
-	0x078003c7, 0x0a6fc007, 0x07800447, 0x0aa0c0c7, 0x0aa98347,
-	0x0a638107, 0x07800507, 0x050011c7, 0x07c00507, 0x06800047,
-	0x07c003c7, 0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0,
-	0x060c2207, 0x060c2208, 0x0cc00000, 0x08030580, 0x06800047,
-	0x07c003c7, 0x07800507, 0x050011c7, 0x07c00507, 0x080e1424,
-	0x064e1509, 0x064e150a, 0x064e150b, 0x064e150c, 0x0aa0c007,
-	0x06800008, 0x06800308, 0x060e1408, 0x0683ffc7, 0x07800448,
-	0x095841c8, 0x07800308, 0x096031c8, 0x060e1507, 0x060e1509,
-	0x060e150a, 0x060e150b, 0x060e150c, 0x0cc00000, 0x08030580,
-	0x07800987, 0x078009c8, 0x06800009, 0x0d000008, 0x020091c9,
-	0x04401249, 0x06800047, 0x0ba10089, 0x05801249, 0x0c7fff80,
-	0x040011c7, 0x0cc00000, 0x07c00687, 0x06800208, 0x064c3b07,
-	0x091031c7, 0x024071c8, 0x0f8001c7, 0x0fc0f1c0, 0x064c0e07,
-	0x040011c7, 0x0f8001c7, 0x07800687, 0x0f8001c7, 0x0fc051c0,
-	0x0c073380, 0x07c00107, 0x0fc011c0, 0x0aa0c007, 0x0c000640,
-	0x00000000, 0x078002c7, 0x07801988, 0x094c11c8, 0x0c072c80,
-	0x060e0407, 0x06800007, 0x07c01cc7, 0x078005c7, 0x0b210087,
-	0x07800988, 0x04002208, 0x024081c8, 0x07800947, 0x04401208,
-	0x02007207, 0x05401208, 0x02007207, 0x07c00947, 0x07800987,
-	0x040011c7, 0x07c005c7, 0x0cc00000, 0x00000000, 0x0fc011c0,
-	0x0a600007, 0x0fc011c0, 0x07801408, 0x0f8001c8, 0x0fc011c0,
-	0x0fc021c0, 0x0fc03200, 0x0aa10007, 0x0aa0c047, 0x0fc03200,
-	0x0fc03200, 0x0cc00000, 0x00000000
+	0x09828428, 0x07801e2d, 0x095e1a2d, 0x06090628, 0x068ed868,
+	0x02c28aa8, 0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424,
+	0x064c2228, 0x060e152e, 0x060e152f, 0x060e1528, 0x0c780080,
+	0x060e1528, 0x0cc00000, 0x00000000, 0x07800028, 0x078016e9,
+	0x06800030, 0x09508a68, 0x0780016b, 0x0780026a, 0x04601aaa,
+	0x0c500b80, 0x0aa1416b, 0x00000000, 0x06800070, 0x0a61826b,
+	0x00000000, 0x078003a8, 0x04602a28, 0x0c500840, 0x0c7800c0,
+	0x0c780000, 0x00000000, 0x06490628, 0x0aefcc28, 0x06b000a8,
+	0x09441a30, 0x06090628, 0x06090629, 0x069fffeb, 0x06900028,
+	0x080c2400, 0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528,
+	0x060e1528, 0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9,
+	0x06090628, 0x080c2440, 0x064c2228, 0x09210a68, 0x06090628,
+	0x02828ae9, 0x06090628, 0x06b8d068, 0x09441a30, 0x0c7812c0,
+	0x06090628, 0x06b0002a, 0x0c07d1c0, 0x09441ab0, 0x0c7ff2c0,
+	0x00000000, 0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0c7ff640,
+	0x00000000, 0x06490628, 0x0aefcc28, 0x06b408a8, 0x09441a30,
+	0x06090628, 0x06090629, 0x069fffec, 0x06900028, 0x080c2400,
+	0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28,
+	0x09828428, 0x078017ad, 0x095e1a2d, 0x06090628, 0x080c2440,
+	0x064c2228, 0x06090628, 0x09210a28, 0x09c28068, 0x02828b28,
+	0x09828428, 0x06090628, 0x06bc5828, 0x09441a30, 0x06090628,
+	0x06b60828, 0x09441a30, 0x06090628, 0x06900028, 0x080c2410,
+	0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28,
+	0x09828428, 0x078017ad, 0x05801b6d, 0x095e1a2d, 0x06090628,
+	0x080c2450, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
+	0x02828b28, 0x09828428, 0x098283e8, 0x06090628, 0x06bed868,
+	0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228,
+	0x060e152e, 0x060e152f, 0x060e1528, 0x060e1528, 0x0cc00000,
+	0x00000000, 0x064e1215, 0x091e1555, 0x0a208055, 0x0c782280,
+	0x0649d915, 0x0900c555, 0x0a6f8015, 0x00000000, 0x078003d5,
+	0x0aa08055, 0x0c780940, 0x07800596, 0x0aa1c016, 0x04401596,
+	0x07c00596, 0x078005d6, 0x04401596, 0x0c7814c0, 0x07c005d6,
+	0x07800916, 0x07800295, 0x05408555, 0x02015595, 0x04003596,
+	0x07c00916, 0x05404595, 0x02016c56, 0x060e1316, 0x07800517,
+	0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416, 0x069fffd7,
+	0x044015d7, 0x0aa1c017, 0x00000000, 0x064e1615, 0x09010555,
+	0x0aaec015, 0x04401555, 0x060e1615, 0x06c00016, 0x060e1216,
+	0x06800095, 0x0c781800, 0x07c003d5, 0x0a660095, 0x078005d6,
+	0x0aa18016, 0x04401596, 0x0b210056, 0x07c005d6, 0x0c780bc0,
+	0x00000000, 0x07800956, 0x07800295, 0x05408555, 0x02015595,
+	0x04003596, 0x07c00956, 0x05404595, 0x02016c56, 0x060e1316,
+	0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215, 0x068000d5,
+	0x0c781200, 0x07c003d5, 0x0aa080d5, 0x0c780700, 0x07800516,
+	0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417, 0x07800795,
+	0x07c00755, 0x0683ffd5, 0x064e1516, 0x0900c5d6, 0x0a40b5d5,
+	0x091845d6, 0x07c00797, 0x064e1516, 0x064e1516, 0x064e1516,
+	0x080c24e0, 0x060c2216, 0x064e1516, 0x0c780200, 0x060c2216,
+	0x068000d6, 0x07c00796, 0x06800016, 0x080c24e0, 0x060c2216,
+	0x060c2216, 0x0aa080a0, 0x0c780980, 0x078003d5, 0x0a644115,
+	0x07800956, 0x068ac015, 0x05408555, 0x02015595, 0x04003596,
+	0x07c00956, 0x05404595, 0x02016c56, 0x060e1316, 0x06a16015,
+	0x09c151d5, 0x06c00015, 0x060e1215, 0x06800195, 0x0c7805c0,
+	0x07c003d5, 0x0aa0c195, 0x0c780480, 0x00000000, 0x064e1418,
+	0x080e1400, 0x064e1516, 0x0683ffd5, 0x0900c5d6, 0x09203656,
+	0x0a8045d5, 0x091845d6, 0x068000d7, 0x06800019, 0x07c004d7,
+	0x090015d9, 0x07c00497, 0x090225d9, 0x07c01117, 0x060e1418,
+	0x06800015, 0x07c003d5, 0x0cc00000, 0x00400000, 0x06800047,
+	0x07c003c7, 0x07800507, 0x050011c7, 0x07c00507, 0x064e1608,
+	0x09010208, 0x04001208, 0x060e1608, 0x0aa0c007, 0x06800008,
+	0x06800308, 0x060e1408, 0x06b7ffc7, 0x06c00007, 0x060e1507,
+	0x060e1524, 0x060e1524, 0x060e1524, 0x060e1524, 0x0cc00000,
+	0x08030580, 0x078003c7, 0x0a6fc007, 0x07800447, 0x0aa0c0c7,
+	0x0aa98347, 0x0a638107, 0x07800507, 0x050011c7, 0x07c00507,
+	0x06800047, 0x07c003c7, 0x080c24e0, 0x064c2207, 0x064c2208,
+	0x080c24c0, 0x060c2207, 0x060c2208, 0x0cc00000, 0x08030580,
+	0x06800047, 0x07c003c7, 0x07800507, 0x050011c7, 0x07c00507,
+	0x080e1424, 0x064e1509, 0x064e150a, 0x064e150b, 0x064e150c,
+	0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408, 0x0683ffc7,
+	0x07800448, 0x095841c8, 0x07800308, 0x096031c8, 0x060e1507,
+	0x060e1509, 0x060e150a, 0x060e150b, 0x060e150c, 0x0cc00000,
+	0x08030580, 0x07800987, 0x078009c8, 0x06800009, 0x0d000008,
+	0x020091c9, 0x04401249, 0x06800047, 0x0ba10089, 0x05801249,
+	0x0c7fff80, 0x040011c7, 0x0cc00000, 0x07c00687, 0x06800208,
+	0x064c3b07, 0x091031c7, 0x024071c8, 0x0f8001c7, 0x0fc0f1c0,
+	0x064c0e07, 0x040011c7, 0x0f8001c7, 0x07800687, 0x0f8001c7,
+	0x0fc051c0, 0x0c073340, 0x07c00107, 0x0fc011c0, 0x0aa0c007,
+	0x0c000640, 0x00000000, 0x078002c7, 0x07801988, 0x094c11c8,
+	0x0c072c40, 0x060e0407, 0x06800007, 0x07c01cc7, 0x078005c7,
+	0x0b210087, 0x07800988, 0x04002208, 0x024081c8, 0x07800947,
+	0x04401208, 0x02007207, 0x05401208, 0x02007207, 0x07c00947,
+	0x07800987, 0x040011c7, 0x07c005c7, 0x0cc00000, 0x00000000,
+	0x0fc011c0, 0x0a600007, 0x0fc011c0, 0x07801408, 0x0f8001c8,
+	0x0fc011c0, 0x0fc021c0, 0x0fc03200, 0x0aa10007, 0x0aa0c047,
+	0x0fc03200, 0x0fc03200, 0x0cc00000, 0x00000000
 };
 
 
diff --git a/drivers/amlogic/amports/arch/ucode/vp9/vvp9_mc.c b/drivers/amlogic/amports/arch/ucode/vp9/vvp9_mc.c
index 24e6c9c..4f23164 100644
--- a/drivers/amlogic/amports/arch/ucode/vp9/vvp9_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/vp9/vvp9_mc.c
@@ -16,477 +16,962 @@
 */
 
 #include "../firmware_def.h"
+#include "../../../vvp9.h"
 
 /* #def SEND_PARAM_WITH_REG */
 #define VERSTR "00000012"
 const u32  vvp9_mc[] __initconst = {
-	0x06814001, 0x06800000, 0x0d000001, 0x07400040, 0x0c000900,
+#ifndef VP9_10B_MMU
+	0x06814001, 0x06800000, 0x0d000001, 0x07400040, 0x0c0010c0,
 	0x00000000, 0x06bffe40, 0x07c00000, 0x06030400, 0x00400000,
-	0x0800c0ff, 0x0c0210c0, 0x00000000, 0x00000000, 0x00000000,
+	0x0800c0ff, 0x0c021900, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x0c7ffd80, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x0c796180, 0x00000000, 0x0c792a00,
-	0x06412108, 0x0c780980, 0x00000000, 0x0cc00000, 0x00400000,
-	0x06800040, 0x09800540, 0x09800580, 0x06014000, 0x0800c000,
-	0x068000c0, 0x07c004c0, 0x06800000, 0x07c00480, 0x06860000,
-	0x06c000c0, 0x06011100, 0x08002515, 0x08002608, 0x0640d000,
-	0x07c013c0, 0x0640d200, 0x07c01380, 0x0640c108, 0x06035108,
-	0x06800408, 0x06035208, 0x06a02008, 0x06035008, 0x06435008,
-	0x0580f208, 0x0bef8048, 0x00000000, 0x06435308, 0x0900c208,
-	0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000, 0x06bfff88,
-	0x06030408, 0x00400000, 0x0640c008, 0x0680042f, 0x0c021380,
-	0x04000c08, 0x0a6181c8, 0x00000000, 0x0c016740, 0x00000000,
-	0x0c7918c0, 0x0800c0ff, 0x0aa0c048, 0x0c7916c0, 0x00000000,
-	0x06bf0008, 0x06e012c8, 0x06014d08, 0x06410c08, 0x08010e84,
-	0x09382248, 0x0ae18089, 0x0aa20009, 0x0aa1c049, 0x06800089,
-	0x0c780140, 0x06800049, 0x09361208, 0x08010e81, 0x02009209,
-	0x07c00149, 0x07800a48, 0x0aa14008, 0x07800a88, 0x0aa0c008,
-	0x06800048, 0x07c00b48, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x07c02049, 0x0aa2c009, 0x06410c08, 0x08010e83, 0x093a3248,
-	0x07c02089, 0x0c020540, 0x00000000, 0x0c020640, 0x00000000,
-	0x0c790ec0, 0x0800c0ff, 0x06410c08, 0x08010e83, 0x093a1248,
-	0x07c00209, 0x093c1248, 0x07c001c9, 0x093e1248, 0x07c00189,
-	0x06411008, 0x05001249, 0x07c00f89, 0x09421209, 0x06011008,
-	0x06414f08, 0x095e1209, 0x09761209, 0x05001289, 0x0968120a,
-	0x06014f08, 0x0aa0c049, 0x0c78ed80, 0x00000000, 0x06800008,
-	0x0c01e2c0, 0x07c00b48, 0x06410c08, 0x08010e88, 0x08010e90,
-	0x06a0d089, 0x06c01249, 0x09118208, 0x0a803248, 0x0c780000,
-	0x00000000, 0x07800188, 0x0aa28008, 0x07800148, 0x0a620008,
-	0x06800209, 0x07c00249, 0x06800049, 0x07c00289, 0x06800049,
-	0x0c780600, 0x00000000, 0x0ba20088, 0x06800209, 0x06410c08,
-	0x08010e81, 0x093e1208, 0x0aa0c008, 0x06800289, 0x06800309,
-	0x07c00249, 0x06410c08, 0x08010e83, 0x093a3248, 0x07c00289,
-	0x0a60c1c9, 0x0c780000, 0x00000000, 0x06410c08, 0x08010e81,
-	0x07800149, 0x0a20c049, 0x0c780000, 0x00000000, 0x07800188,
-	0x0aa14008, 0x06410c08, 0x08010e88, 0x09308248, 0x07c01009,
-	0x06410c08, 0x08010e90, 0x09210248, 0x04001249, 0x07c002c9,
-	0x06410c08, 0x08010e90, 0x09210208, 0x04001208, 0x07c00308,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa24009, 0x00000000,
-	0x06410c08, 0x08010e90, 0x09210248, 0x04001249, 0x08010e90,
-	0x09010208, 0x04001208, 0x07800208, 0x06800009, 0x0a618008,
-	0x0680004a, 0x06410c08, 0x08010e82, 0x093e1248, 0x093c1288,
-	0x07c00549, 0x07c0058a, 0x06410c08, 0x08010e82, 0x093c2248,
-	0x07c005c9, 0x06410c08, 0x08010e8a, 0x09346248, 0x07c00649,
-	0x092e3248, 0x07c00689, 0x092c1248, 0x07c006c9, 0x0aa14009,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0a608009, 0x0c7810c0,
+	0x00000000, 0x00000000, 0x0c7969c0, 0x00000000, 0x0c793240,
+	0x06412108, 0x0c7811c0, 0x00000000, 0x0cc00000, 0x00400000,
+	0x06450400, 0x0600d000, 0x0640d000, 0x06035100, 0x0680c000,
+	0x06035200, 0x06a04000, 0x06035000, 0x06435000, 0x0580f000,
+	0x0bef8040, 0x00000000, 0x06435300, 0x0900c000, 0x0a6f8000,
+	0x00000000, 0x0640d000, 0x06818001, 0x02000040, 0x0600d000,
+	0x07803fc0, 0x04001000, 0x07c03fc0, 0x06805581, 0x0b8ea040,
+	0x00000000, 0x06800000, 0x07c03fc0, 0x0600d000, 0x0cc00000,
+	0x00000000, 0x0c07f840, 0x00000000, 0x06800040, 0x09800540,
+	0x09800580, 0x06014000, 0x0800c000, 0x068000c0, 0x07c004c0,
+	0x06800000, 0x07c00480, 0x06860000, 0x06c000c0, 0x06011100,
+	0x08002515, 0x08002608, 0x0640d000, 0x07c013c0, 0x0640d200,
+	0x07c01380, 0x0640c108, 0x06035108, 0x06800408, 0x06035208,
+	0x06a04008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008, 0x00000000,
+	0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408, 0x00400000,
+	0x0640c008, 0x0680042f, 0x0c021380, 0x04000c08, 0x0a6181c8,
+	0x00000000, 0x0c016740, 0x00000000, 0x0c7918c0, 0x0800c0ff,
+	0x0aa0c048, 0x0c7916c0, 0x00000000, 0x06bf0008, 0x06e012c8,
+	0x06014d08, 0x06410c08, 0x08010e84, 0x09382248, 0x0ae18089,
+	0x0aa20009, 0x0aa1c049, 0x06800089, 0x0c780140, 0x06800049,
+	0x09361208, 0x08010e81, 0x02009209, 0x07c00149, 0x07800a48,
+	0x0aa14008, 0x07800a88, 0x0aa0c008, 0x06800048, 0x07c00b48,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x07c02049, 0x0aa2c009,
+	0x06410c08, 0x08010e83, 0x093a3248, 0x07c02089, 0x0c020540,
+	0x00000000, 0x0c020640, 0x00000000, 0x0c790ec0, 0x0800c0ff,
+	0x06410c08, 0x08010e83, 0x093a1248, 0x07c00209, 0x093c1248,
+	0x07c001c9, 0x093e1248, 0x07c00189, 0x06411008, 0x05001249,
+	0x07c00f89, 0x09421209, 0x06011008, 0x06414f08, 0x095e1209,
+	0x09761209, 0x05001289, 0x0968120a, 0x06014f08, 0x0aa0c049,
+	0x0c78ed80, 0x00000000, 0x06800008, 0x0c01e2c0, 0x07c00b48,
+	0x06410c08, 0x08010e88, 0x08010e90, 0x06a0d089, 0x06c01249,
+	0x09118208, 0x0a803248, 0x0c780000, 0x00000000, 0x07800188,
+	0x0aa28008, 0x07800148, 0x0a620008, 0x06800209, 0x07c00249,
+	0x06800049, 0x07c00289, 0x06800049, 0x0c780600, 0x00000000,
+	0x0ba20088, 0x06800209, 0x06410c08, 0x08010e81, 0x093e1208,
+	0x0aa0c008, 0x06800289, 0x06800309, 0x07c00249, 0x06410c08,
+	0x08010e83, 0x093a3248, 0x07c00289, 0x0a60c1c9, 0x0c780000,
+	0x00000000, 0x06410c08, 0x08010e81, 0x07800149, 0x0a20c049,
+	0x0c780000, 0x00000000, 0x07800188, 0x0aa14008, 0x06410c08,
+	0x08010e88, 0x09308248, 0x07c01009, 0x06410c08, 0x08010e90,
+	0x09210248, 0x04001249, 0x07c002c9, 0x06410c08, 0x08010e90,
+	0x09210208, 0x04001208, 0x07c00308, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa24009, 0x00000000, 0x06410c08, 0x08010e90,
+	0x09210248, 0x04001249, 0x08010e90, 0x09010208, 0x04001208,
+	0x07800208, 0x06800009, 0x0a618008, 0x0680004a, 0x06410c08,
+	0x08010e82, 0x093e1248, 0x093c1288, 0x07c00549, 0x07c0058a,
+	0x06410c08, 0x08010e82, 0x093c2248, 0x07c005c9, 0x06410c08,
+	0x08010e8a, 0x09346248, 0x07c00649, 0x092e3248, 0x07c00689,
+	0x092c1248, 0x07c006c9, 0x0aa14009, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0a608009, 0x0c7810c0, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a,
+	0x09326248, 0x0680000a, 0x0240924a, 0x07c00709, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87,
+	0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a, 0x07c00749,
 	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288,
 	0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a,
-	0x07c00709, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009,
+	0x07c00789, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009,
 	0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a,
-	0x0240924a, 0x07c00749, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0240924a, 0x07c007c9, 0x06410c08, 0x08010e81, 0x093e1248,
 	0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248,
-	0x0680000a, 0x0240924a, 0x07c00789, 0x06410c08, 0x08010e81,
+	0x0680000a, 0x0240924a, 0x07c00809, 0x06410c08, 0x08010e81,
 	0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a,
-	0x09326248, 0x0680000a, 0x0240924a, 0x07c007c9, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87,
-	0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a, 0x07c00809,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288,
-	0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a,
-	0x07c00849, 0x06410c08, 0x08010e88, 0x09308248, 0x07c00889,
+	0x09326248, 0x0680000a, 0x0240924a, 0x07c00849, 0x06410c08,
+	0x08010e88, 0x09308248, 0x07c00889, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a,
+	0x09364248, 0x0680000a, 0x0240924a, 0x07c00989, 0x07800888,
+	0x02009209, 0x07c008c9, 0x09508248, 0x06c00009, 0x06014609,
 	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa1c009, 0x09341288,
 	0x08010e85, 0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a,
-	0x07c00989, 0x07800888, 0x02009209, 0x07c008c9, 0x09508248,
-	0x06c00009, 0x06014609, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a, 0x09364248,
-	0x0680000a, 0x0240924a, 0x07c009c9, 0x07800888, 0x02009209,
-	0x07c00909, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa1c009,
-	0x09341288, 0x08010e85, 0x0aa1000a, 0x09364248, 0x0680000a,
-	0x0240924a, 0x07c00a09, 0x07800888, 0x02009209, 0x07c00949,
-	0x07800908, 0x09508209, 0x06c00048, 0x06014608, 0x06800089,
-	0x07800888, 0x0a624008, 0x07800988, 0x0a61c008, 0x078009c8,
-	0x0a614008, 0x07800a08, 0x0a60c008, 0x00000000, 0x068000c9,
-	0x06414f08, 0x096a2209, 0x06014f08, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa14009, 0x07c00a49, 0x06800008, 0x0c012100,
-	0x07c00ac8, 0x06414f08, 0x07800a49, 0x096e1209, 0x07800a89,
-	0x09701209, 0x07800ac9, 0x09721209, 0x07800b09, 0x09741209,
-	0x06014f08, 0x0c01bf40, 0x00000000, 0x0c01c040, 0x00000000,
-	0x0640c008, 0x0a610188, 0x00000000, 0x0c78c800, 0x0800c0ff,
-	0x0c01a780, 0x00000000, 0x06800048, 0x07800409, 0x0680100a,
-	0x0340b20a, 0x0ac0324b, 0x0c7fff80, 0x04001208, 0x04401208,
-	0x07c00048, 0x06800048, 0x07800409, 0x0380b209, 0x0ba0c10b,
-	0x0c7fff80, 0x04001208, 0x04401208, 0x07c00088, 0x0780004a,
-	0x07800089, 0x0b40724a, 0x06410c08, 0x08010e81, 0x093e1208,
-	0x0aa0c008, 0x0c7ffec0, 0x0400128a, 0x07c00bca, 0x06800048,
-	0x03408288, 0x04401208, 0x07c00c48, 0x06410c08, 0x08010e81,
-	0x093e1288, 0x0aa1400a, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0200a24a, 0x07c00c0a, 0x06800048, 0x03408288, 0x04401208,
-	0x07c00c88, 0x06410c08, 0x08010e90, 0x09210248, 0x06812008,
-	0x06010e08, 0x08010e00, 0x05403249, 0x098097c9, 0x09809749,
-	0x06013a09, 0x07800188, 0x0aa14008, 0x07800208, 0x0a60c008,
-	0x07800fc8, 0x0a60c0c8, 0x06800008, 0x07c00608, 0x07800fc8,
-	0x0aa18088, 0x06800009, 0x07800609, 0x078005c8, 0x03809209,
-	0x04801249, 0x0641100a, 0x0a610009, 0x0980a3ca, 0x0c7809c0,
-	0x00000000, 0x0601100a, 0x06414d09, 0x093e1249, 0x0a6f8009,
-	0x00000000, 0x0640c308, 0x09108208, 0x0aafbf48, 0x00000000,
-	0x06410108, 0x09808348, 0x06010108, 0x06410108, 0x09021208,
-	0x0a6f8008, 0x00000000, 0x06af0008, 0x06ec09c8, 0x06014d08,
-	0x0640c908, 0x078005c9, 0x0540c249, 0x02008248, 0x06013408,
-	0x08013501, 0x06413508, 0x090e1248, 0x0a6f8009, 0x09308248,
-	0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00, 0x06410108,
-	0x09c08348, 0x0c780b80, 0x06010108, 0x06807fc8, 0x09449288,
-	0x0601100a, 0x06800049, 0x078005c8, 0x03409209, 0x07800608,
-	0x02c08248, 0x07c00608, 0x06411009, 0x0904a249, 0x0a6f8009,
-	0x00000000, 0x06414d09, 0x093e1249, 0x0a6f8009, 0x00000000,
-	0x06410108, 0x09808348, 0x06010108, 0x06410108, 0x09021208,
-	0x0a6f8008, 0x00000000, 0x06af0008, 0x06ec05c8, 0x06014d08,
-	0x0640c908, 0x078005c9, 0x0540c249, 0x02008248, 0x06013408,
-	0x08013503, 0x06413508, 0x090e1248, 0x0a6f8009, 0x09308248,
-	0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00, 0x06410108,
-	0x09c08348, 0x06010108, 0x06411009, 0x091e1249, 0x0a6f8009,
-	0x00000000, 0x06a00208, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x09201248, 0x0aa08009, 0x0c780000, 0x078008c8,
-	0x0a624008, 0x07800888, 0x0a61c008, 0x07800908, 0x0a614008,
-	0x07800948, 0x0a60c008, 0x0c780400, 0x0680000a, 0x06a00608,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09202288,
-	0x0a6200ca, 0x06a00208, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x09201248, 0x0200a24a, 0x07c00f4a, 0x06414f08,
-	0x0958320a, 0x06014f08, 0x0a62010a, 0x06bf0248, 0x06c002c8,
+	0x07c009c9, 0x07800888, 0x02009209, 0x07c00909, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85,
+	0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a, 0x07c00a09,
+	0x07800888, 0x02009209, 0x07c00949, 0x07800908, 0x09508209,
+	0x06c00048, 0x06014608, 0x06800089, 0x07800888, 0x0a624008,
+	0x07800988, 0x0a61c008, 0x078009c8, 0x0a614008, 0x07800a08,
+	0x0a60c008, 0x00000000, 0x068000c9, 0x06414f08, 0x096a2209,
+	0x06014f08, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009,
+	0x07c00a49, 0x06800008, 0x0c012100, 0x07c00ac8, 0x06414f08,
+	0x07800a49, 0x096e1209, 0x07800a89, 0x09701209, 0x07800ac9,
+	0x09721209, 0x07800b09, 0x09741209, 0x06014f08, 0x0c01bf40,
+	0x00000000, 0x0c01c040, 0x00000000, 0x0640c008, 0x0a610188,
+	0x00000000, 0x0c78c800, 0x0800c0ff, 0x0c01a780, 0x00000000,
+	0x06800048, 0x07800409, 0x0680100a, 0x0340b20a, 0x0ac0324b,
+	0x0c7fff80, 0x04001208, 0x04401208, 0x07c00048, 0x06800048,
+	0x07800409, 0x0380b209, 0x0ba0c10b, 0x0c7fff80, 0x04001208,
+	0x04401208, 0x07c00088, 0x0780004a, 0x07800089, 0x0b40724a,
+	0x06410c08, 0x08010e81, 0x093e1208, 0x0aa0c008, 0x0c7ffec0,
+	0x0400128a, 0x07c00bca, 0x06800048, 0x03408288, 0x04401208,
+	0x07c00c48, 0x06410c08, 0x08010e81, 0x093e1288, 0x0aa1400a,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0200a24a, 0x07c00c0a,
+	0x06800048, 0x03408288, 0x04401208, 0x07c00c88, 0x06410c08,
+	0x08010e90, 0x09210248, 0x06812008, 0x06010e08, 0x08010e00,
+	0x05403249, 0x098097c9, 0x09809749, 0x06013a09, 0x07800188,
+	0x0aa14008, 0x07800208, 0x0a60c008, 0x07800fc8, 0x0a60c0c8,
+	0x06800008, 0x07c00608, 0x07800fc8, 0x0aa18088, 0x06800009,
+	0x07800609, 0x078005c8, 0x03809209, 0x04801249, 0x0641100a,
+	0x0a610009, 0x0980a3ca, 0x0c7809c0, 0x00000000, 0x0601100a,
+	0x06414d09, 0x093e1249, 0x0a6f8009, 0x00000000, 0x0640c308,
+	0x09108208, 0x0aafbf48, 0x00000000, 0x06410108, 0x09808348,
+	0x06010108, 0x06410108, 0x09021208, 0x0a6f8008, 0x00000000,
+	0x06af0008, 0x06ec09c8, 0x06014d08, 0x0640c908, 0x078005c9,
+	0x0540c249, 0x02008248, 0x06013408, 0x08013501, 0x06413508,
+	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
+	0x08013500, 0x08014d00, 0x06410108, 0x09c08348, 0x0c780b80,
+	0x06010108, 0x06807fc8, 0x09449288, 0x0601100a, 0x06800049,
+	0x078005c8, 0x03409209, 0x07800608, 0x02c08248, 0x07c00608,
+	0x06411009, 0x0904a249, 0x0a6f8009, 0x00000000, 0x06414d09,
+	0x093e1249, 0x0a6f8009, 0x00000000, 0x06410108, 0x09808348,
+	0x06010108, 0x06410108, 0x09021208, 0x0a6f8008, 0x00000000,
+	0x06af0008, 0x06ec05c8, 0x06014d08, 0x0640c908, 0x078005c9,
+	0x0540c249, 0x02008248, 0x06013408, 0x08013503, 0x06413508,
+	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
+	0x08013500, 0x08014d00, 0x06410108, 0x09c08348, 0x06010108,
+	0x06411009, 0x091e1249, 0x0a6f8009, 0x00000000, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0aa08009, 0x0c780000, 0x078008c8, 0x0a624008, 0x07800888,
+	0x0a61c008, 0x07800908, 0x0a614008, 0x07800948, 0x0a60c008,
+	0x0c780400, 0x0680000a, 0x06a00608, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09202288, 0x0a6200ca, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0200a24a, 0x07c00f4a, 0x06414f08, 0x0958320a, 0x06014f08,
+	0x0a62010a, 0x06bf0248, 0x06c002c8, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x0680000a, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0aa24009, 0x06bf0648, 0x06c062c8, 0x097c220a, 0x06014108,
+	0x06414108, 0x09061248, 0x0a6d4009, 0x00000000, 0x07800f48,
+	0x0b40420a, 0x0babc0ca, 0x0400128a, 0x00000000, 0x06bf0a48,
+	0x06c00088, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x07800f88, 0x0aa08008, 0x0c781ac0, 0x06bf0e48,
+	0x06c00508, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x078010c8, 0x0a620108, 0x06bf1248, 0x06c001c8,
 	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
+	0x06bf1648, 0x06c000c8, 0x06014108, 0x06414108, 0x09061248,
+	0x0a6f8009, 0x00000000, 0x06414f0a, 0x07801048, 0x09001248,
+	0x09501289, 0x09081248, 0x094e1289, 0x09101248, 0x094c1289,
+	0x06014f0a, 0x09081288, 0x0a40424a, 0x09001288, 0x0a81324a,
 	0x0680000a, 0x06a00208, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x09201248, 0x0aa24009, 0x06bf0648, 0x06c062c8,
-	0x097c220a, 0x06014108, 0x06414108, 0x09061248, 0x0a6d4009,
-	0x00000000, 0x07800f48, 0x0b40420a, 0x0babc0ca, 0x0400128a,
-	0x00000000, 0x06bf0a48, 0x06c00088, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x07800f88, 0x0aa08008,
-	0x0c781ac0, 0x06bf0e48, 0x06c00508, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x078010c8, 0x0a620108,
-	0x06bf1248, 0x06c001c8, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x00000000, 0x06bf1648, 0x06c000c8, 0x06014108,
-	0x06414108, 0x09061248, 0x0a6f8009, 0x00000000, 0x06414f0a,
-	0x07801048, 0x09001248, 0x09501289, 0x09081248, 0x094e1289,
-	0x09101248, 0x094c1289, 0x06014f0a, 0x09081288, 0x0a40424a,
-	0x09001288, 0x0a81324a, 0x0680000a, 0x06a00208, 0x06014108,
-	0x06414108, 0x09061248, 0x0a6f8009, 0x09201248, 0x0aa2c009,
-	0x0680000a, 0x06a00208, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x09201248, 0x0aa0c009, 0x0680004a, 0x0680008a,
-	0x07c0110a, 0x06414f08, 0x0954220a, 0x06014f08, 0x0a62008a,
-	0x06bf1a48, 0x06c00108, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x00000000, 0x0aa2004a, 0x06bf2248, 0x06c00248,
+	0x0a6f8009, 0x09201248, 0x0aa2c009, 0x0680000a, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0aa0c009, 0x0680004a, 0x0680008a, 0x07c0110a, 0x06414f08,
+	0x0954220a, 0x06014f08, 0x0a62008a, 0x06bf1a48, 0x06c00108,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
+	0x0aa2004a, 0x06bf2248, 0x06c00248, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x0aa2000a, 0x06bf1e48,
+	0x06c00108, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x06bf2648, 0x06c008c8, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2a48, 0x06c00bc8,
 	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x0aa2000a, 0x06bf1e48, 0x06c00108, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2648, 0x06c008c8,
+	0x06bf2e48, 0x07801089, 0x0a60c009, 0x06c01108, 0x06c01008,
 	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x06bf2a48, 0x06c00bc8, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x00000000, 0x06bf2e48, 0x07801089, 0x0a60c009,
-	0x06c01108, 0x06c01008, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x00000000, 0x06413a08, 0x09013208, 0x0aa0c008,
-	0x00000000, 0x08010e88, 0x06800008, 0x07c00cc8, 0x07c00d08,
-	0x08013a00, 0x08011c00, 0x08011e00, 0x08011d00, 0x08011f00,
-	0x08014700, 0x08014800, 0x08014200, 0x08014300, 0x08014400,
-	0x08014500, 0x07800cc8, 0x07800409, 0x0e000248, 0x068001df,
-	0x00000000, 0x07800bc9, 0x0f000200, 0x03808248, 0x07c00d48,
-	0x07800cc8, 0x04001208, 0x07800409, 0x0e000248, 0x0680000a,
-	0x07c00b8a, 0x07800bc9, 0x0f000200, 0x03808248, 0x07c00dc8,
-	0x07800d49, 0x02408248, 0x07c00e48, 0x07800d08, 0x07800449,
-	0x0e000248, 0x00000000, 0x00000000, 0x07800c09, 0x0f000200,
-	0x03808248, 0x0aa10008, 0x07c00d88, 0x0c00e980, 0x09c1f05f,
-	0x07800d08, 0x04001208, 0x07800449, 0x0e000248, 0x00000000,
-	0x00000000, 0x07800c09, 0x0f000200, 0x03808248, 0x07c00e08,
-	0x07800d89, 0x02408248, 0x07c00e88, 0x07800d48, 0x04001208,
-	0x07800dc9, 0x0b807248, 0x07800d88, 0x04001208, 0x07800e09,
-	0x0b803248, 0x00000000, 0x0981f0df, 0x07800d88, 0x07800409,
-	0x0e000248, 0x07c00f08, 0x07c01348, 0x07800d49, 0x07c00ec9,
-	0x07c01309, 0x0f000200, 0x02008248, 0x07c00508, 0x05404248,
-	0x05403208, 0x02008248, 0x07c01208, 0x07c01248, 0x06800008,
-	0x07c01288, 0x07c012c8, 0x06812008, 0x06010e08, 0x08010e00,
-	0x07800cc8, 0x0a60c008, 0x07800d08, 0x0aa20008, 0x0641390a,
-	0x0aa1800a, 0x00000000, 0x08010e88, 0x00000000, 0x0c7ffec0,
-	0x00000000, 0x07800cc8, 0x07800c49, 0x0b804248, 0x07800d08,
-	0x07800c89, 0x0b40d248, 0x06410c08, 0x08010e90, 0x09210248,
-	0x06410c08, 0x08010e90, 0x09210288, 0x09610289, 0x0601390a,
-	0x0540324a, 0x098097c9, 0x09809789, 0x06013a09, 0x07800e48,
-	0x0aa0c008, 0x07800e88, 0x0a630008, 0x07800cc8, 0x04001208,
-	0x07800c49, 0x0b082248, 0x07c00cc8, 0x06800008, 0x07c00cc8,
-	0x07800d08, 0x04001208, 0x0c7fdf00, 0x07c00d08, 0x07800a48,
-	0x0aa0c008, 0x0c00db40, 0x00000000, 0x06411009, 0x098093c9,
-	0x06011009, 0x06470109, 0x09809209, 0x06070109, 0x06470b08,
-	0x07800249, 0x04408249, 0x09402209, 0x09482209, 0x09502209,
-	0x06070b08, 0x078002c8, 0x07800309, 0x09610209, 0x06020508,
-	0x07800d48, 0x07800d89, 0x09610209, 0x06020708, 0x06060708,
-	0x07800e48, 0x07800e89, 0x09610209, 0x06020808, 0x06060808,
-	0x07800408, 0x04401208, 0x07800449, 0x04401249, 0x09610209,
-	0x06020608, 0x06420109, 0x07800188, 0x0aa0c008, 0x06800388,
-	0x06800308, 0x09403248, 0x078004c8, 0x04003208, 0x09604248,
-	0x07800488, 0x04003208, 0x09684248, 0x06020109, 0x06424c09,
-	0x09809009, 0x09809049, 0x09809089, 0x07801088, 0x05001208,
-	0x09501248, 0x07801048, 0x09001288, 0x095c124a, 0x09081288,
-	0x095a124a, 0x09101288, 0x0958124a, 0x06024c09, 0x06420408,
-	0x093e1208, 0x0a6f8008, 0x00000000, 0x078002c9, 0x0780030a,
-	0x0960f24a, 0x06040209, 0x07800409, 0x0780044a, 0x0960c24a,
-	0x06040309, 0x08040400, 0x07800c48, 0x0a618008, 0x06800049,
-	0x07800c88, 0x0a60c008, 0x06800049, 0x06800009, 0x06040509,
-	0x07800e48, 0x07800e89, 0x09610209, 0x06040308, 0x07800d48,
-	0x07800d89, 0x09610209, 0x06040408, 0x06450d08, 0x09001248,
-	0x0a6f8009, 0x00000000, 0x08040640, 0x06414f0a, 0x07800148,
-	0x0aa10008, 0x06800009, 0x06800289, 0x0980a24a, 0x06040c09,
-	0x06014f0a, 0x06440009, 0x09809009, 0x06040009, 0x09c09009,
-	0x06040009, 0x06800048, 0x09482248, 0x09809049, 0x06040009,
-	0x07800249, 0x04408249, 0x06450108, 0x09602209, 0x09642209,
-	0x06050108, 0x078002c8, 0x07800309, 0x09610209, 0x06050208,
-	0x07800bc8, 0x06050c08, 0x07800d48, 0x07800d89, 0x0960a209,
-	0x07800cc9, 0x09584209, 0x07800d09, 0x09784209, 0x06050608,
-	0x07800d4a, 0x07800e48, 0x02008288, 0x04401208, 0x07800d8a,
-	0x07800e89, 0x02009289, 0x04401249, 0x0960a209, 0x06050708,
-	0x07800d48, 0x07800d89, 0x0960a209, 0x06050808, 0x078002c8,
-	0x07800309, 0x09610209, 0x06060508, 0x07800408, 0x04401208,
-	0x07800449, 0x04401249, 0x09610209, 0x06060608, 0x06460109,
-	0x09809709, 0x06060109, 0x07800ec9, 0x07800f08, 0x0958c248,
-	0x0978425f, 0x06011609, 0x06411009, 0x091e1249, 0x0a6f8009,
-	0x00000000, 0x06a00208, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x09201248, 0x0aa08009, 0x0c780000, 0x07800508,
-	0x09808788, 0x098087c8, 0x06012408, 0x07800d48, 0x0a610008,
-	0x07800d88, 0x0a608008, 0x00000000, 0x06800048, 0x0541f208,
-	0x06020408, 0x06060408, 0x08040701, 0x06450808, 0x098087c8,
-	0x06050808, 0x06414008, 0x09808048, 0x06014008, 0x06414008,
-	0x0c783500, 0x00000000, 0x078001c8, 0x0a614008, 0x06800009,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x07c00f89, 0x0a60c009,
-	0x0780020a, 0x0aa0c00a, 0x0c00f380, 0x00000000, 0x06414f08,
-	0x095e1209, 0x05001289, 0x0968120a, 0x06014f08, 0x07800208,
-	0x0a614008, 0x06800009, 0x06410c08, 0x08010e82, 0x093c2248,
-	0x07c00fc9, 0x07800f88, 0x0aa08008, 0x0c7f0c80, 0x06410c08,
-	0x08010e88, 0x09308248, 0x07c01009, 0x06410c08, 0x08010e8c,
-	0x0928c248, 0x07c01049, 0x09101209, 0x09081289, 0x0a806288,
-	0x068009ca, 0x09001289, 0x0a803288, 0x06800d8a, 0x06800e8a,
-	0x06414f09, 0x0940624a, 0x06014f09, 0x0680008a, 0x0680000b,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x03408289, 0x02c0b20b,
-	0x0a63c009, 0x07c023cb, 0x0b20c00a, 0x0c7ffe00, 0x0440128a,
-	0x06410c08, 0x08010e90, 0x09210248, 0x04001249, 0x06410c08,
-	0x08010e90, 0x09210208, 0x04001208, 0x07c00308, 0x07c002c9,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x07c021c9, 0x0aa2c009,
-	0x00000000, 0x06410c08, 0x08010e90, 0x09210248, 0x04001249,
-	0x07c02309, 0x08010e90, 0x09010208, 0x04001208, 0x07c02348,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x07c01089, 0x06414f08,
-	0x09661209, 0x06014f08, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0a61c009, 0x0680010a, 0x08010e82, 0x093a2248, 0x0b60c089,
-	0x04000289, 0x0500128a, 0x07c010ca, 0x06414f08, 0x0960320a,
-	0x06014f08, 0x0c7f0b40, 0x00000000, 0x0a60c188, 0x00000000,
-	0x08010e90, 0x0c780080, 0x0800c0ff, 0x00800000, 0x07800008,
-	0x0c7edb00, 0x06030408, 0x06806008, 0x06010e08, 0x06410f08,
-	0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248, 0x0680e008,
-	0x06010e08, 0x06410f08, 0x0befc0c8, 0x09118208, 0x0cc00000,
-	0x07400248, 0x06410509, 0x06bfff89, 0x06030409, 0x00400000,
-	0x0be0c108, 0x0c7ffa40, 0x00000000, 0x08012104, 0x080150c0,
-	0x06411c26, 0x06411d27, 0x06414728, 0x06414229, 0x07800409,
-	0x0ae1c049, 0x0641432a, 0x04000866, 0x040008a7, 0x040008e8,
-	0x04000929, 0x0400096a, 0x06014224, 0x06014325, 0x06011c21,
-	0x06011d22, 0x0a21c91f, 0x06014723, 0x08011e00, 0x08011f00,
-	0x08014800, 0x08014400, 0x08014500, 0x0be0e026, 0x0c7809c0,
-	0x00000000, 0x07800a48, 0x0aa0c008, 0x0c00aac0, 0x00000000,
-	0x068001df, 0x0978479f, 0x06420409, 0x093e1209, 0x0a6f8008,
-	0x09c09749, 0x06020409, 0x07800cc8, 0x04001208, 0x07800c49,
-	0x0b009248, 0x07c00cc8, 0x06800008, 0x07c00cc8, 0x07800d08,
-	0x04001208, 0x07800c89, 0x0ac08248, 0x07c00d08, 0x0c006940,
-	0x00000000, 0x0c003e40, 0x00000000, 0x0c7f7c00, 0x00000000,
-	0x07800549, 0x0aa0c009, 0x0c00ac40, 0x00000000, 0x0c003c40,
-	0x00000000, 0x0c7fea00, 0x0800c0ff, 0x0601161e, 0x07800508,
-	0x09808788, 0x098087c8, 0x06012408, 0x06414009, 0x09809049,
-	0x06014009, 0x06414009, 0x09c1f09f, 0x07800508, 0x04001208,
-	0x07c00508, 0x07800b88, 0x04001208, 0x07c00b88, 0x0a21409f,
-	0x07800e49, 0x0b803248, 0x00000000, 0x09c1f05f, 0x07800ec8,
-	0x04001208, 0x07800dc9, 0x0b811248, 0x07c00ec8, 0x07800d48,
-	0x07c00ec8, 0x0981f09f, 0x07800508, 0x07800409, 0x02008248,
-	0x07800e49, 0x02408248, 0x07c00508, 0x07800f08, 0x04001208,
-	0x07800e09, 0x0b803248, 0x07c00f08, 0x0981f0df, 0x07800f08,
-	0x04001208, 0x07800e09, 0x0b80f248, 0x07800ec8, 0x04001208,
-	0x07800dc9, 0x0b80b248, 0x07800409, 0x0b807248, 0x07800f08,
-	0x04001208, 0x07800449, 0x0b803248, 0x0c7800c0, 0x09c1f11f,
-	0x0981f11f, 0x0981f0df, 0x07800ede, 0x07800f08, 0x0958c788,
-	0x0978479f, 0x07800b88, 0x0ae08048, 0x0c780a00, 0x07800ec9,
-	0x07800d4a, 0x0400228a, 0x0b407289, 0x04402209, 0x0440128a,
-	0x07800dc8, 0x0b403289, 0x04401208, 0x04401208, 0x05403248,
-	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07400266,
-	0x09210226, 0x04001249, 0x07400248, 0x04001249, 0x07400269,
-	0x09210229, 0x04001249, 0x07400248, 0x04001249, 0x0740026a,
-	0x0921022a, 0x04001249, 0x07400248, 0x04001249, 0x07400267,
-	0x09210227, 0x04001249, 0x07400248, 0x04001249, 0x07400268,
-	0x09210228, 0x04001249, 0x07400248, 0x0a21c09f, 0x06800024,
-	0x06800025, 0x06800021, 0x06800022, 0x0c780800, 0x06800023,
-	0x07800ec8, 0x05403248, 0x02009248, 0x02008248, 0x06806009,
+	0x06413a08, 0x09013208, 0x0aa0c008, 0x00000000, 0x08010e88,
+	0x06800008, 0x07c00cc8, 0x07c00d08, 0x08013a00, 0x08011c00,
+	0x08011e00, 0x08011d00, 0x08011f00, 0x08014700, 0x08014800,
+	0x08014200, 0x08014300, 0x08014400, 0x08014500, 0x07800cc8,
+	0x07800409, 0x0e000248, 0x068001df, 0x00000000, 0x07800bc9,
+	0x0f000200, 0x03808248, 0x07c00d48, 0x07800cc8, 0x04001208,
+	0x07800409, 0x0e000248, 0x0680000a, 0x07c00b8a, 0x07800bc9,
+	0x0f000200, 0x03808248, 0x07c00dc8, 0x07800d49, 0x02408248,
+	0x07c00e48, 0x07800d08, 0x07800449, 0x0e000248, 0x00000000,
+	0x00000000, 0x07800c09, 0x0f000200, 0x03808248, 0x0aa10008,
+	0x07c00d88, 0x0c00e980, 0x09c1f05f, 0x07800d08, 0x04001208,
+	0x07800449, 0x0e000248, 0x00000000, 0x00000000, 0x07800c09,
+	0x0f000200, 0x03808248, 0x07c00e08, 0x07800d89, 0x02408248,
+	0x07c00e88, 0x07800d48, 0x04001208, 0x07800dc9, 0x0b807248,
+	0x07800d88, 0x04001208, 0x07800e09, 0x0b803248, 0x00000000,
+	0x0981f0df, 0x07800d88, 0x07800409, 0x0e000248, 0x07c00f08,
+	0x07c01348, 0x07800d49, 0x07c00ec9, 0x07c01309, 0x0f000200,
+	0x02008248, 0x07c00508, 0x05404248, 0x05403208, 0x02008248,
+	0x07c01208, 0x07c01248, 0x06800008, 0x07c01288, 0x07c012c8,
+	0x06812008, 0x06010e08, 0x08010e00, 0x07800cc8, 0x0a60c008,
+	0x07800d08, 0x0aa20008, 0x0641390a, 0x0aa1800a, 0x00000000,
+	0x08010e88, 0x00000000, 0x0c7ffec0, 0x00000000, 0x07800cc8,
+	0x07800c49, 0x0b804248, 0x07800d08, 0x07800c89, 0x0b40d248,
+	0x06410c08, 0x08010e90, 0x09210248, 0x06410c08, 0x08010e90,
+	0x09210288, 0x09610289, 0x0601390a, 0x0540324a, 0x098097c9,
+	0x09809789, 0x06013a09, 0x07800e48, 0x0aa0c008, 0x07800e88,
+	0x0a630008, 0x07800cc8, 0x04001208, 0x07800c49, 0x0b082248,
+	0x07c00cc8, 0x06800008, 0x07c00cc8, 0x07800d08, 0x04001208,
+	0x0c7fdf00, 0x07c00d08, 0x07800a48, 0x0aa0c008, 0x0c00db40,
+	0x00000000, 0x06411009, 0x098093c9, 0x06011009, 0x06470109,
+	0x09809209, 0x06070109, 0x06470b08, 0x07800249, 0x04408249,
+	0x09402209, 0x09482209, 0x09502209, 0x06070b08, 0x078002c8,
+	0x07800309, 0x09610209, 0x06020508, 0x07800d48, 0x07800d89,
+	0x09610209, 0x06020708, 0x06060708, 0x07800e48, 0x07800e89,
+	0x09610209, 0x06020808, 0x06060808, 0x07800408, 0x04401208,
+	0x07800449, 0x04401249, 0x09610209, 0x06020608, 0x06420109,
+	0x07800188, 0x0aa0c008, 0x06800388, 0x06800308, 0x09403248,
+	0x078004c8, 0x04003208, 0x09604248, 0x07800488, 0x04003208,
+	0x09684248, 0x06020109, 0x06424c09, 0x09809009, 0x09809049,
+	0x09809089, 0x07801088, 0x05001208, 0x09501248, 0x07801048,
+	0x09001288, 0x095c124a, 0x09081288, 0x095a124a, 0x09101288,
+	0x0958124a, 0x06024c09, 0x06420408, 0x093e1208, 0x0a6f8008,
+	0x00000000, 0x078002c9, 0x0780030a, 0x0960f24a, 0x06040209,
+	0x07800409, 0x0780044a, 0x0960c24a, 0x06040309, 0x08040400,
+	0x07800c48, 0x0a618008, 0x06800049, 0x07800c88, 0x0a60c008,
+	0x06800049, 0x06800009, 0x06040509, 0x07800e48, 0x07800e89,
+	0x09610209, 0x06040308, 0x07800d48, 0x07800d89, 0x09610209,
+	0x06040408, 0x06450d08, 0x09001248, 0x0a6f8009, 0x00000000,
+	0x08040640, 0x06414f0a, 0x07800148, 0x0aa10008, 0x06800009,
+	0x06800289, 0x0980a24a, 0x06040c09, 0x06014f0a, 0x06440009,
+	0x09809009, 0x06040009, 0x09c09009, 0x06040009, 0x06800048,
+	0x09482248, 0x09809049, 0x06040009, 0x07800249, 0x04408249,
+	0x06450108, 0x09602209, 0x09642209, 0x06050108, 0x078002c8,
+	0x07800309, 0x09610209, 0x06050208, 0x07800bc8, 0x06050c08,
+	0x07800d48, 0x07800d89, 0x0960a209, 0x07800cc9, 0x09584209,
+	0x07800d09, 0x09784209, 0x06050608, 0x07800d4a, 0x07800e48,
+	0x02008288, 0x04401208, 0x07800d8a, 0x07800e89, 0x02009289,
+	0x04401249, 0x0960a209, 0x06050708, 0x07800d48, 0x07800d89,
+	0x0960a209, 0x06050808, 0x078002c8, 0x07800309, 0x09610209,
+	0x06060508, 0x07800408, 0x04401208, 0x07800449, 0x04401249,
+	0x09610209, 0x06060608, 0x06460109, 0x09809709, 0x06060109,
+	0x07800ec9, 0x07800f08, 0x0958c248, 0x0978425f, 0x06011609,
+	0x06411009, 0x091e1249, 0x0a6f8009, 0x00000000, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0aa08009, 0x0c780000, 0x07800508, 0x09808788, 0x098087c8,
+	0x06012408, 0x07800d48, 0x0a610008, 0x07800d88, 0x0a608008,
+	0x00000000, 0x06800048, 0x0541f208, 0x06020408, 0x06060408,
+	0x08040701, 0x06450808, 0x098087c8, 0x06050808, 0x06414008,
+	0x09808048, 0x06014008, 0x06414008, 0x0c783500, 0x00000000,
+	0x078001c8, 0x0a614008, 0x06800009, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c00f89, 0x0a60c009, 0x0780020a, 0x0aa0c00a,
+	0x0c00f380, 0x00000000, 0x06414f08, 0x095e1209, 0x05001289,
+	0x0968120a, 0x06014f08, 0x07800208, 0x0a614008, 0x06800009,
+	0x06410c08, 0x08010e82, 0x093c2248, 0x07c00fc9, 0x07800f88,
+	0x0aa08008, 0x0c7f0c80, 0x06410c08, 0x08010e88, 0x09308248,
+	0x07c01009, 0x06410c08, 0x08010e8c, 0x0928c248, 0x07c01049,
+	0x09101209, 0x09081289, 0x0a806288, 0x068009ca, 0x09001289,
+	0x0a803288, 0x06800d8a, 0x06800e8a, 0x06414f09, 0x0940624a,
+	0x06014f09, 0x0680008a, 0x0680000b, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x03408289, 0x02c0b20b, 0x0a63c009, 0x07c023cb,
+	0x0b20c00a, 0x0c7ffe00, 0x0440128a, 0x06410c08, 0x08010e90,
+	0x09210248, 0x04001249, 0x06410c08, 0x08010e90, 0x09210208,
+	0x04001208, 0x07c00308, 0x07c002c9, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c021c9, 0x0aa2c009, 0x00000000, 0x06410c08,
+	0x08010e90, 0x09210248, 0x04001249, 0x07c02309, 0x08010e90,
+	0x09010208, 0x04001208, 0x07c02348, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c01089, 0x06414f08, 0x09661209, 0x06014f08,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0a61c009, 0x0680010a,
+	0x08010e82, 0x093a2248, 0x0b60c089, 0x04000289, 0x0500128a,
+	0x07c010ca, 0x06414f08, 0x0960320a, 0x06014f08, 0x0c7f0b40,
+	0x00000000, 0x0a60c188, 0x00000000, 0x08010e90, 0x0c780080,
+	0x0800c0ff, 0x00800000, 0x07800008, 0x0c7ed2c0, 0x06030408,
+	0x06806008, 0x06010e08, 0x06410f08, 0x0befc0c8, 0x09118208,
+	0x0cc00000, 0x07400248, 0x0680e008, 0x06010e08, 0x06410f08,
+	0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248, 0x06410509,
+	0x06bfff89, 0x06030409, 0x00400000, 0x0be0c108, 0x0c7ffa40,
+	0x00000000, 0x08012104, 0x080150c0, 0x06411c26, 0x06411d27,
+	0x06414728, 0x06414229, 0x07800409, 0x0ae1c049, 0x0641432a,
+	0x04000866, 0x040008a7, 0x040008e8, 0x04000929, 0x0400096a,
+	0x06014224, 0x06014325, 0x06011c21, 0x06011d22, 0x0a21c91f,
+	0x06014723, 0x08011e00, 0x08011f00, 0x08014800, 0x08014400,
+	0x08014500, 0x0be0e026, 0x0c7809c0, 0x00000000, 0x07800a48,
+	0x0aa0c008, 0x0c00aac0, 0x00000000, 0x068001df, 0x0978479f,
+	0x06420409, 0x093e1209, 0x0a6f8008, 0x09c09749, 0x06020409,
+	0x07800cc8, 0x04001208, 0x07800c49, 0x0b009248, 0x07c00cc8,
+	0x06800008, 0x07c00cc8, 0x07800d08, 0x04001208, 0x07800c89,
+	0x0ac08248, 0x07c00d08, 0x0c006940, 0x00000000, 0x0c003e40,
+	0x00000000, 0x0c7f7c00, 0x00000000, 0x07800549, 0x0aa0c009,
+	0x0c00ac40, 0x00000000, 0x0c003c40, 0x00000000, 0x0c7fea00,
+	0x0800c0ff, 0x0601161e, 0x07800508, 0x09808788, 0x098087c8,
+	0x06012408, 0x06414009, 0x09809049, 0x06014009, 0x06414009,
+	0x09c1f09f, 0x07800508, 0x04001208, 0x07c00508, 0x07800b88,
+	0x04001208, 0x07c00b88, 0x0a21409f, 0x07800e49, 0x0b803248,
+	0x00000000, 0x09c1f05f, 0x07800ec8, 0x04001208, 0x07800dc9,
+	0x0b811248, 0x07c00ec8, 0x07800d48, 0x07c00ec8, 0x0981f09f,
+	0x07800508, 0x07800409, 0x02008248, 0x07800e49, 0x02408248,
+	0x07c00508, 0x07800f08, 0x04001208, 0x07800e09, 0x0b803248,
+	0x07c00f08, 0x0981f0df, 0x07800f08, 0x04001208, 0x07800e09,
+	0x0b80f248, 0x07800ec8, 0x04001208, 0x07800dc9, 0x0b80b248,
+	0x07800409, 0x0b807248, 0x07800f08, 0x04001208, 0x07800449,
+	0x0b803248, 0x0c7800c0, 0x09c1f11f, 0x0981f11f, 0x0981f0df,
+	0x07800ede, 0x07800f08, 0x0958c788, 0x0978479f, 0x07800b88,
+	0x0ae08048, 0x0c780a00, 0x07800ec9, 0x07800d4a, 0x0400228a,
+	0x0b407289, 0x04402209, 0x0440128a, 0x07800dc8, 0x0b403289,
+	0x04401208, 0x04401208, 0x05403248, 0x02009248, 0x02008248,
+	0x06806009, 0x02009209, 0x07400266, 0x09210226, 0x04001249,
+	0x07400248, 0x04001249, 0x07400269, 0x09210229, 0x04001249,
+	0x07400248, 0x04001249, 0x0740026a, 0x0921022a, 0x04001249,
+	0x07400248, 0x04001249, 0x07400267, 0x09210227, 0x04001249,
+	0x07400248, 0x04001249, 0x07400268, 0x09210228, 0x04001249,
+	0x07400248, 0x0a21c09f, 0x06800024, 0x06800025, 0x06800021,
+	0x06800022, 0x0c780800, 0x06800023, 0x07800ec8, 0x05403248,
+	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07000261,
+	0x04001249, 0x07000248, 0x09610848, 0x04001249, 0x07000264,
+	0x04001249, 0x07000248, 0x09610908, 0x04001249, 0x07000265,
+	0x04001249, 0x07000248, 0x09610948, 0x04001249, 0x07000262,
+	0x04001249, 0x07000248, 0x09610888, 0x04001249, 0x07000263,
+	0x04001249, 0x07000248, 0x096108c8, 0x07800a48, 0x0aa0c008,
+	0x0c005cc0, 0x00000000, 0x0c7fc500, 0x00000000, 0x06412106,
+	0x090c1186, 0x0a6f8006, 0x0c7e9700, 0x00000000, 0x06804009,
+	0x06012d09, 0x06800f8a, 0x08012e00, 0x00000000, 0x0d07ff8a,
+	0x00000000, 0x0cc00000, 0x00000000, 0x07800148, 0x07c02008,
+	0x07800188, 0x07c020c8, 0x078001c8, 0x07c02108, 0x07800208,
+	0x07c02148, 0x07800f88, 0x07c02188, 0x07800fc8, 0x07c02208,
+	0x07801008, 0x07c02248, 0x078002c8, 0x07c02288, 0x07800308,
+	0x07c022c8, 0x07801048, 0x07c02388, 0x078006c8, 0x07c02408,
+	0x07800708, 0x07c02448, 0x07800748, 0x07c02488, 0x07800788,
+	0x07c024c8, 0x078007c8, 0x07c02508, 0x07800808, 0x07c02548,
+	0x07800848, 0x07c02588, 0x07800648, 0x07c025c8, 0x07800688,
+	0x07c02608, 0x07800248, 0x07c02648, 0x07800a48, 0x07c02888,
+	0x07800b08, 0x07c028c8, 0x0640c108, 0x06035108, 0x06802008,
+	0x06035208, 0x06a02008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0800cf00, 0x0800c0ff,
+	0x06800009, 0x0680ffca, 0x07000248, 0x09808408, 0x0600cf08,
+	0x00000000, 0x0640cf08, 0x0a6fc008, 0x0b403289, 0x0c7ffe40,
+	0x04001249, 0x0cc00000, 0x00000000, 0x069fffca, 0x06440109,
+	0x0a2fc049, 0x0440128a, 0x06460309, 0x093e1289, 0x0a6f800a,
+	0x00000000, 0x0cc00000, 0x00000000, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0a60c009, 0x07c00a89, 0x0c780b80, 0x06847f4a,
+	0x06012d0a, 0x0680000a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa14009, 0x06803fc9, 0x06410c08, 0x08010e88, 0x09308248,
+	0x054082cb, 0x094082c9, 0x0bad80ca, 0x0400128a, 0x0a60c10a,
+	0x00000000, 0x06012e0b, 0x0bac41ca, 0x00000000, 0x054082cb,
+	0x06012e0b, 0x06847fca, 0x06012d0a, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x06bfc00b, 0x0aa40009, 0x07c00ac9, 0x0680000a,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x06803fc9,
+	0x06410c08, 0x08010e88, 0x09308248, 0x054082cb, 0x094082c9,
+	0x0bad808a, 0x0400128a, 0x054082cb, 0x06012e0b, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0a60c009, 0x0c780d80, 0x00000000,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x07c00b09, 0x0680000c,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x0680000a,
+	0x06410c08, 0x08010e89, 0x092e9288, 0x0680268b, 0x0200b30b,
+	0x074002ca, 0x0680000b, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0540f289, 0x0aa28009, 0x095612c9, 0x06410c08, 0x08010e87,
+	0x09346248, 0x09406289, 0x094862c9, 0x09321248, 0x09501289,
+	0x095412c9, 0x040a420c, 0x0740020a, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa18009, 0x094612c9, 0x06410c08, 0x08010e82,
+	0x093c2248, 0x094222c9, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x094012c9, 0x096c32cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b,
+	0x0c7ff4c0, 0x0400130c, 0x0680000c, 0x07800b0a, 0x0aa0c00a,
+	0x0780088b, 0x0680000b, 0x06802688, 0x02008308, 0x07000208,
+	0x09028288, 0x09001248, 0x0aa0c009, 0x0200928b, 0x0240928b,
+	0x0ba14009, 0x0680000a, 0x0ae0ffc9, 0x06803fca, 0x04000289,
+	0x07900988, 0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9,
+	0x06803fcb, 0x040002c9, 0x095082ca, 0x096232cc, 0x0601460b,
+	0x07900a08, 0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9,
+	0x06803fcb, 0x040002c9, 0x079009c8, 0x0200920a, 0x0ba14009,
+	0x06800008, 0x0ae0ffc9, 0x06803fc8, 0x04000209, 0x0950820b,
+	0x0962320c, 0x09808408, 0x06014608, 0x0b60c1cc, 0x0c7ff480,
+	0x0400130c, 0x0cc00000, 0x00000000, 0x07800dc8, 0x04401208,
+	0x05403248, 0x02009248, 0x02008248, 0x06806009, 0x02009209,
+	0x07400266, 0x09210226, 0x04001249, 0x07400248, 0x04001249,
+	0x07400269, 0x09210229, 0x04001249, 0x07400248, 0x04001249,
+	0x0740026a, 0x0921022a, 0x04001249, 0x07400248, 0x04001249,
+	0x07400267, 0x09210227, 0x04001249, 0x07400248, 0x04001249,
+	0x07400268, 0x09210228, 0x04001249, 0x0cc00000, 0x07400248,
+	0x07800d48, 0x05403248, 0x02009248, 0x02008248, 0x06806009,
 	0x02009209, 0x07000261, 0x04001249, 0x07000248, 0x09610848,
 	0x04001249, 0x07000264, 0x04001249, 0x07000248, 0x09610908,
 	0x04001249, 0x07000265, 0x04001249, 0x07000248, 0x09610948,
 	0x04001249, 0x07000262, 0x04001249, 0x07000248, 0x09610888,
 	0x04001249, 0x07000263, 0x04001249, 0x07000248, 0x096108c8,
-	0x07800a48, 0x0aa0c008, 0x0c005cc0, 0x00000000, 0x0c7fc500,
-	0x00000000, 0x06412106, 0x090c1186, 0x0a6f8006, 0x0c7e9f40,
-	0x00000000, 0x06804009, 0x06012d09, 0x06800f8a, 0x08012e00,
-	0x00000000, 0x0d07ff8a, 0x00000000, 0x0cc00000, 0x00000000,
-	0x07800148, 0x07c02008, 0x07800188, 0x07c020c8, 0x078001c8,
-	0x07c02108, 0x07800208, 0x07c02148, 0x07800f88, 0x07c02188,
-	0x07800fc8, 0x07c02208, 0x07801008, 0x07c02248, 0x078002c8,
-	0x07c02288, 0x07800308, 0x07c022c8, 0x07801048, 0x07c02388,
-	0x078006c8, 0x07c02408, 0x07800708, 0x07c02448, 0x07800748,
-	0x07c02488, 0x07800788, 0x07c024c8, 0x078007c8, 0x07c02508,
-	0x07800808, 0x07c02548, 0x07800848, 0x07c02588, 0x07800648,
-	0x07c025c8, 0x07800688, 0x07c02608, 0x07800248, 0x07c02648,
-	0x07800a48, 0x07c02888, 0x07800b08, 0x07c028c8, 0x0640c108,
-	0x06035108, 0x06802008, 0x06035208, 0x06a02008, 0x06035008,
-	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
-	0x0900c208, 0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000,
-	0x0800cf00, 0x0800c0ff, 0x06800009, 0x0680ffca, 0x07000248,
-	0x09808408, 0x0600cf08, 0x00000000, 0x0640cf08, 0x0a6fc008,
-	0x0b403289, 0x0c7ffe40, 0x04001249, 0x0cc00000, 0x00000000,
-	0x069fffca, 0x06440109, 0x0a2fc049, 0x0440128a, 0x06460309,
-	0x093e1289, 0x0a6f800a, 0x00000000, 0x0cc00000, 0x00000000,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0a60c009, 0x07c00a89,
-	0x0c780b80, 0x06847f4a, 0x06012d0a, 0x0680000a, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0aa14009, 0x06803fc9, 0x06410c08,
-	0x08010e88, 0x09308248, 0x054082cb, 0x094082c9, 0x0bad80ca,
-	0x0400128a, 0x0a60c10a, 0x00000000, 0x06012e0b, 0x0bac41ca,
-	0x00000000, 0x054082cb, 0x06012e0b, 0x06847fca, 0x06012d0a,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x06bfc00b, 0x0aa40009,
-	0x07c00ac9, 0x0680000a, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0aa14009, 0x06803fc9, 0x06410c08, 0x08010e88, 0x09308248,
-	0x054082cb, 0x094082c9, 0x0bad808a, 0x0400128a, 0x054082cb,
-	0x06012e0b, 0x06410c08, 0x08010e81, 0x093e1248, 0x0a60c009,
-	0x0c780d80, 0x00000000, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x07c00b09, 0x0680000c, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0aa14009, 0x0680000a, 0x06410c08, 0x08010e89, 0x092e9288,
-	0x0680268b, 0x0200b30b, 0x074002ca, 0x0680000b, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0540f289, 0x0aa28009, 0x095612c9,
-	0x06410c08, 0x08010e87, 0x09346248, 0x09406289, 0x094862c9,
-	0x09321248, 0x09501289, 0x095412c9, 0x040a420c, 0x0740020a,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa18009, 0x094612c9,
-	0x06410c08, 0x08010e82, 0x093c2248, 0x094222c9, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x094012c9, 0x096c32cc, 0x0980b7cb,
-	0x0b6101cc, 0x0601460b, 0x0c7ff4c0, 0x0400130c, 0x0680000c,
-	0x07800b0a, 0x0aa0c00a, 0x0780088b, 0x0680000b, 0x06802688,
-	0x02008308, 0x07000208, 0x09028288, 0x09001248, 0x0aa0c009,
-	0x0200928b, 0x0240928b, 0x0ba14009, 0x0680000a, 0x0ae0ffc9,
-	0x06803fca, 0x04000289, 0x07900988, 0x0200920a, 0x0ba14009,
-	0x0680000b, 0x0ae0ffc9, 0x06803fcb, 0x040002c9, 0x095082ca,
-	0x096232cc, 0x0601460b, 0x07900a08, 0x0200920a, 0x0ba14009,
-	0x0680000b, 0x0ae0ffc9, 0x06803fcb, 0x040002c9, 0x079009c8,
-	0x0200920a, 0x0ba14009, 0x06800008, 0x0ae0ffc9, 0x06803fc8,
-	0x04000209, 0x0950820b, 0x0962320c, 0x09808408, 0x06014608,
-	0x0b60c1cc, 0x0c7ff480, 0x0400130c, 0x0cc00000, 0x00000000,
-	0x07800dc8, 0x04401208, 0x05403248, 0x02009248, 0x02008248,
+	0x06014224, 0x06014325, 0x06011c21, 0x06011d22, 0x0cc00000,
+	0x06014723, 0x07800a88, 0x0aa14008, 0x07800ac8, 0x0a60c008,
+	0x0cc00000, 0x00000000, 0x07801208, 0x0640cb09, 0x02009248,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06035109,
+	0x06800c08, 0x06035208, 0x06b10008, 0x06035008, 0x08015020,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x06810008, 0x0680018b,
+	0x07800b49, 0x0a618009, 0x06800009, 0x0d00000b, 0x06015109,
+	0x0cc00000, 0x08015080, 0x07000209, 0x04001208, 0x0700020a,
+	0x04001208, 0x0961024a, 0x0d07fecb, 0x06015109, 0x0cc00000,
+	0x08015080, 0x07800b88, 0x0ae08048, 0x0c780900, 0x078012c8,
+	0x05403248, 0x05402208, 0x02008248, 0x06810009, 0x02008248,
+	0x08015020, 0x0643500b, 0x0580f2cb, 0x0bef804b, 0x0680018b,
+	0x06415109, 0x07400209, 0x04001208, 0x09210249, 0x07400209,
+	0x0d07fecb, 0x04001208, 0x07c012c8, 0x07801288, 0x0be3c0c8,
+	0x0be0c108, 0x0681000b, 0x040302cb, 0x07800a88, 0x0aa28008,
+	0x07801248, 0x0640cb09, 0x02009248, 0x06035109, 0x078012c8,
+	0x024082c8, 0x06035208, 0x0980b3cb, 0x0603500b, 0x07801208,
+	0x07c01248, 0x07801288, 0x07c012c8, 0x07800f08, 0x07801349,
+	0x0a408248, 0x07800eca, 0x07801309, 0x04001249, 0x0a40c289,
+	0x07801289, 0x0c780340, 0x04001249, 0x04001249, 0x0a407209,
+	0x07800eca, 0x0a61400a, 0x07801309, 0x04001249, 0x0780040a,
+	0x0a8f6289, 0x07801289, 0x04004249, 0x048fc249, 0x04807249,
+	0x07c01289, 0x0be340c9, 0x07800f08, 0x07800409, 0x0e000248,
+	0x07800ec9, 0x00000000, 0x00000000, 0x0f000200, 0x02008248,
+	0x05404248, 0x05403208, 0x02008248, 0x07c01208, 0x07800ec8,
+	0x07c01308, 0x07800f08, 0x07c01348, 0x07800a88, 0x0aa14008,
+	0x07800ac8, 0x0a60c008, 0x0cc00000, 0x00000000, 0x07801289,
+	0x0be400c9, 0x07801208, 0x0640cb09, 0x02009248, 0x06435008,
+	0x0580f208, 0x0bef8048, 0x00000000, 0x06035109, 0x06800c08,
+	0x06035208, 0x07801289, 0x0be0c109, 0x06b10c08, 0x06b10008,
+	0x06035008, 0x06435008, 0x0580f208, 0x0bef8048, 0x00000000,
+	0x07801288, 0x05403248, 0x05402208, 0x02008248, 0x06810009,
+	0x02008248, 0x08015020, 0x0680018b, 0x07800b49, 0x0a618009,
+	0x06800009, 0x0d00000b, 0x06015109, 0x0cc00000, 0x00000000,
+	0x07000209, 0x04001208, 0x0700020a, 0x04001208, 0x0961024a,
+	0x0d07fecb, 0x06015109, 0x0cc00000, 0x00000000, 0x078012c8,
+	0x0a20c108, 0x0681000a, 0x06810c0a, 0x05403248, 0x05402208,
+	0x02008248, 0x06810009, 0x02008248, 0x08015020, 0x0643500b,
+	0x0580f2cb, 0x0bef804b, 0x0680018b, 0x06415109, 0x07400209,
+	0x04001208, 0x09210249, 0x07400209, 0x0d07fecb, 0x04001208,
+	0x07c012c8, 0x07800a88, 0x0a608008, 0x0cc00000, 0x07801248,
+	0x0640cb09, 0x02009248, 0x06035109, 0x078012c8, 0x02408288,
+	0x06035208, 0x0980a3ca, 0x0cc00000, 0x0603500a, 0x06410108,
+	0x09808348, 0x06010108, 0x06410108, 0x09021208, 0x0a6f8008,
+	0x07800588, 0x0aa34048, 0x06bf0008, 0x06e016c8, 0x06014d08,
+	0x0640ca08, 0x06013408, 0x08013503, 0x06413508, 0x090e1248,
+	0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000, 0x08014d00,
+	0x06af0008, 0x06ec05c8, 0x06014d08, 0x0640c908, 0x07800589,
+	0x0aa10009, 0x06900009, 0x078005c9, 0x0540c249, 0x02008248,
+	0x06013408, 0x08013503, 0x06413508, 0x090e1248, 0x0a6f8009,
+	0x09308248, 0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00,
+	0x07800588, 0x0aa14048, 0x06803f48, 0x078005c9, 0x09502209,
+	0x0600c308, 0x06410108, 0x09c08348, 0x0cc00000, 0x06010108,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0640c408,
+	0x07801189, 0x05408249, 0x02008248, 0x06035108, 0x08035280,
+	0x06bd4008, 0x06035008, 0x07801189, 0x04001249, 0x07c01189,
+	0x06814009, 0x07c01149, 0x06462308, 0x09808288, 0x06062308,
+	0x06462d08, 0x09808048, 0x06062d08, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x0cc00000, 0x00000000, 0x06463908,
+	0x09105248, 0x0aa40009, 0x0780114a, 0x07000288, 0x0400128a,
+	0x0700028b, 0x0961020b, 0x06063808, 0x0400128a, 0x07c0114a,
+	0x06816008, 0x0b8f620a, 0x04401249, 0x0c07f540, 0x00000000,
+	0x0c7ffc00, 0x00000000, 0x0cc00000, 0x00000000, 0x0680000c,
+	0x06800008, 0x07c00b48, 0x0409a2cc, 0x074002c8, 0x040a42cc,
+	0x074002c8, 0x054162cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b,
+	0x0c7ffe00, 0x0400130c, 0x06800048, 0x07c00708, 0x06800008,
+	0x07c00748, 0x07c00808, 0x07c00848, 0x04401208, 0x07c00788,
+	0x0cc00000, 0x07c007c8, 0x07800349, 0x07800388, 0x09610248,
+	0x06412308, 0x0a804248, 0x06800009, 0x07c00b49, 0x06800049,
+	0x07c003c9, 0x09010248, 0x07c002c9, 0x07c00349, 0x09210208,
+	0x07c00308, 0x07c00388, 0x0403f289, 0x0580628a, 0x07c0040a,
+	0x0403f288, 0x0580628a, 0x0cc00000, 0x07c0044a, 0x067f2f2b,
+	0x0a2fc12b, 0x0640c02b, 0x0a6f7feb, 0x00000000, 0x0641392b,
+	0x0680006f, 0x0c001200, 0x06800030, 0x0c001d00, 0x069fffb1,
+	0x08013900, 0x06410b2b, 0x0982b0ab, 0x06010b2b, 0x0641212b,
+	0x0a2fc06b, 0x00000000, 0x069315ae, 0x06d0536e, 0x06410c2b,
+	0x068000af, 0x0c000e40, 0x04000c2b, 0x0a4edbab, 0x08012101,
+	0x08010e90, 0x08010e90, 0x06410c2b, 0x068000ef, 0x0c000c40,
+	0x04000c2b, 0x0695556e, 0x06d5556e, 0x0a409bab, 0x00000000,
+	0x08012101, 0x0800c0f2, 0x08007401, 0x0640c02e, 0x0aaffcae,
+	0x0c7ff700, 0x00000000, 0x093c2aeb, 0x0aa0c0ab, 0x0c7ff600,
+	0x00000000, 0x0641162c, 0x093e1b2c, 0x0aa0402c, 0x0640d22c,
+	0x0a21406c, 0x00000000, 0x0800c0f1, 0x0c7ff280, 0x08007401,
+	0x0680006d, 0x0680012f, 0x0c000540, 0x04000c2d, 0x0600c02d,
+	0x08030504, 0x0c7ff080, 0x00000000, 0x0c074980, 0x00000000,
+	0x0800c0f0, 0x08007401, 0x0cc00000, 0x00000000, 0x0640c009,
+	0x0aa0c149, 0x0a6f8189, 0x00000000, 0x068004af, 0x0c000100,
+	0x06800030, 0x0cc00000, 0x00000000, 0x0600d130, 0x078013f0,
+	0x0aa18030, 0x00000000, 0x0600d02f, 0x08007401, 0x0640d02f,
+	0x0a6fc02f, 0x00000000, 0x0cc00000, 0x00000000, 0x0600d130,
+	0x078013f0, 0x0aa54030, 0x00000000, 0x0640cf30, 0x06035130,
+	0x0680fc30, 0x06035230, 0x06a00030, 0x06035030, 0x06435030,
+	0x0580fc30, 0x0bef8070, 0x00000000, 0x06435330, 0x0900cc30,
+	0x0a6f8030, 0x00000000, 0x0982f42f, 0x0600d02f, 0x08007401,
+	0x0640d02f, 0x0a6fc02f, 0x0cc00000, 0x00000000, 0x06810030,
+	0x06800008, 0x06410c2f, 0x08010e90, 0x09210bef, 0x0740022f,
+	0x0d07ff30, 0x04001208, 0x0cc00000, 0x00000000, 0x0aa54031,
+	0x04000c31, 0x0640d42f, 0x09010bef, 0x0a411c2f, 0x0640d42f,
+	0x09202bef, 0x0a61406f, 0x00000000, 0x0c07f500, 0x06800030,
+	0x0c780180, 0x0a6d80ef, 0x00000000, 0x0c07fa00, 0x00000000,
+	0x0c780040, 0x04000c31, 0x0600d430, 0x0c7ffbc0, 0x00000000,
+	0x0cc00000, 0x00000000, 0x078002c8, 0x07800309, 0x09610209,
+	0x06012308, 0x06800208, 0x078004c9, 0x03408248, 0x06040608,
+	0x078002c9, 0x0780030a, 0x0960f24a, 0x06040209, 0x07800409,
+	0x0780044a, 0x0960c24a, 0x06040309, 0x08040400, 0x0cc00000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+
+#else
+	0x06814001, 0x06800000, 0x0d000001, 0x07400040, 0x0c0010c0,
+	0x00000000, 0x06bffe40, 0x07c00000, 0x06030400, 0x00400000,
+	0x0800c0ff, 0x0c021cc0, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x0c7ffd80, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0c796d80, 0x00000000, 0x0c793600,
+	0x06412108, 0x0c7811c0, 0x00000000, 0x0cc00000, 0x00400000,
+	0x06450400, 0x0600d000, 0x0640d000, 0x06035100, 0x0680c000,
+	0x06035200, 0x06a04000, 0x06035000, 0x06435000, 0x0580f000,
+	0x0bef8040, 0x00000000, 0x06435300, 0x0900c000, 0x0a6f8000,
+	0x00000000, 0x0640d000, 0x06818001, 0x02000040, 0x0600d000,
+	0x07803fc0, 0x04001000, 0x07c03fc0, 0x06805581, 0x0b8ea040,
+	0x00000000, 0x06800000, 0x07c03fc0, 0x0600d000, 0x0cc00000,
+	0x00000000, 0x0c07f840, 0x00000000, 0x06800040, 0x09800540,
+	0x09800580, 0x06014000, 0x0800c000, 0x068000c0, 0x07c004c0,
+	0x06800000, 0x07c00480, 0x06860000, 0x06c000c0, 0x06011100,
+	0x08002515, 0x08002608, 0x0640d000, 0x07c013c0, 0x0640d200,
+	0x07c01380, 0x0640c108, 0x06035108, 0x06800408, 0x06035208,
+	0x06a04008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008, 0x00000000,
+	0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408, 0x00400000,
+	0x0640c008, 0x0680042f, 0x0c021740, 0x04000c08, 0x0a6181c8,
+	0x00000000, 0x0c016b00, 0x00000000, 0x0c791c00, 0x0800c0ff,
+	0x0aa0c048, 0x0c791a00, 0x00000000, 0x06bf0008, 0x06e012c8,
+	0x06014d08, 0x06410c08, 0x08010e84, 0x09382248, 0x0ae18089,
+	0x0aa20009, 0x0aa1c049, 0x06800089, 0x0c780140, 0x06800049,
+	0x09361208, 0x08010e81, 0x02009209, 0x07c00149, 0x07800a48,
+	0x0aa14008, 0x07800a88, 0x0aa0c008, 0x06800048, 0x07c00b48,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x07c02049, 0x0aa2c009,
+	0x06410c08, 0x08010e83, 0x093a3248, 0x07c02089, 0x0c020900,
+	0x00000000, 0x0c020a00, 0x00000000, 0x0c791200, 0x0800c0ff,
+	0x06410c08, 0x08010e83, 0x093a1248, 0x07c00209, 0x093c1248,
+	0x07c001c9, 0x093e1248, 0x07c00189, 0x06411008, 0x05001249,
+	0x07c00f89, 0x09421209, 0x06011008, 0x06414f08, 0x095e1209,
+	0x09761209, 0x05001289, 0x0968120a, 0x06014f08, 0x0aa0c049,
+	0x0c78f0c0, 0x00000000, 0x06800008, 0x0c01e680, 0x07c00b48,
+	0x06410c08, 0x08010e88, 0x08010e90, 0x06a0d089, 0x06c01249,
+	0x09118208, 0x0a803248, 0x0c780000, 0x00000000, 0x07800188,
+	0x0aa28008, 0x07800148, 0x0a620008, 0x06800209, 0x07c00249,
+	0x06800049, 0x07c00289, 0x06800049, 0x0c780600, 0x00000000,
+	0x0ba20088, 0x06800209, 0x06410c08, 0x08010e81, 0x093e1208,
+	0x0aa0c008, 0x06800289, 0x06800309, 0x07c00249, 0x06410c08,
+	0x08010e83, 0x093a3248, 0x07c00289, 0x0a60c1c9, 0x0c780000,
+	0x00000000, 0x06410c08, 0x08010e81, 0x07800149, 0x0a20c049,
+	0x0c780000, 0x00000000, 0x07800188, 0x0aa14008, 0x06410c08,
+	0x08010e88, 0x09308248, 0x07c01009, 0x06410c08, 0x08010e90,
+	0x09210248, 0x04001249, 0x07c002c9, 0x06410c08, 0x08010e90,
+	0x09210208, 0x04001208, 0x07c00308, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa24009, 0x00000000, 0x06410c08, 0x08010e90,
+	0x09210248, 0x04001249, 0x08010e90, 0x09010208, 0x04001208,
+	0x07800208, 0x06800009, 0x0a618008, 0x0680004a, 0x06410c08,
+	0x08010e82, 0x093e1248, 0x093c1288, 0x07c00549, 0x07c0058a,
+	0x06410c08, 0x08010e82, 0x093c2248, 0x07c005c9, 0x06410c08,
+	0x08010e8a, 0x09346248, 0x07c00649, 0x092e3248, 0x07c00689,
+	0x092c1248, 0x07c006c9, 0x0aa14009, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0a608009, 0x0c7810c0, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a,
+	0x09326248, 0x0680000a, 0x0240924a, 0x07c00709, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87,
+	0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a, 0x07c00749,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288,
+	0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a,
+	0x07c00789, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009,
+	0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a,
+	0x0240924a, 0x07c007c9, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248,
+	0x0680000a, 0x0240924a, 0x07c00809, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a,
+	0x09326248, 0x0680000a, 0x0240924a, 0x07c00849, 0x06410c08,
+	0x08010e88, 0x09308248, 0x07c00889, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a,
+	0x09364248, 0x0680000a, 0x0240924a, 0x07c00989, 0x07800888,
+	0x02009209, 0x07c008c9, 0x09508248, 0x06c00009, 0x06014609,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa1c009, 0x09341288,
+	0x08010e85, 0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a,
+	0x07c009c9, 0x07800888, 0x02009209, 0x07c00909, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85,
+	0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a, 0x07c00a09,
+	0x07800888, 0x02009209, 0x07c00949, 0x07800908, 0x09508209,
+	0x06c00048, 0x06014608, 0x06800089, 0x07800888, 0x0a624008,
+	0x07800988, 0x0a61c008, 0x078009c8, 0x0a614008, 0x07800a08,
+	0x0a60c008, 0x00000000, 0x068000c9, 0x06414f08, 0x096a2209,
+	0x06014f08, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009,
+	0x07c00a49, 0x06800008, 0x0c0124c0, 0x07c00ac8, 0x06414f08,
+	0x07800a49, 0x096e1209, 0x07800a89, 0x09701209, 0x07800ac9,
+	0x09721209, 0x07800b09, 0x09741209, 0x06014f08, 0x0c01c300,
+	0x00000000, 0x0c01c400, 0x00000000, 0x0640c008, 0x0a610188,
+	0x00000000, 0x0c78cb40, 0x0800c0ff, 0x0c01ab40, 0x00000000,
+	0x06800048, 0x07800409, 0x0680100a, 0x0340b20a, 0x0ac0324b,
+	0x0c7fff80, 0x04001208, 0x04401208, 0x07c00048, 0x06800048,
+	0x07800409, 0x0380b209, 0x0ba0c10b, 0x0c7fff80, 0x04001208,
+	0x04401208, 0x07c00088, 0x0780004a, 0x07800089, 0x0b40724a,
+	0x06410c08, 0x08010e81, 0x093e1208, 0x0aa0c008, 0x0c7ffec0,
+	0x0400128a, 0x07c00bca, 0x06800048, 0x03408288, 0x04401208,
+	0x07c00c48, 0x06410c08, 0x08010e81, 0x093e1288, 0x0aa1400a,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0200a24a, 0x07c00c0a,
+	0x06800048, 0x03408288, 0x04401208, 0x07c00c88, 0x06410c08,
+	0x08010e90, 0x09210248, 0x06812008, 0x06010e08, 0x08010e00,
+	0x05403249, 0x098097c9, 0x09809749, 0x06013a09, 0x07800188,
+	0x0aa14008, 0x07800208, 0x0a60c008, 0x07800fc8, 0x0a60c0c8,
+	0x06800008, 0x07c00608, 0x07800fc8, 0x0aa18088, 0x06800009,
+	0x07800609, 0x078005c8, 0x03809209, 0x04801249, 0x0641100a,
+	0x0a610009, 0x0980a3ca, 0x0c7809c0, 0x00000000, 0x0601100a,
+	0x06414d09, 0x093e1249, 0x0a6f8009, 0x00000000, 0x0640c308,
+	0x09108208, 0x0aafbf48, 0x00000000, 0x06410108, 0x09808348,
+	0x06010108, 0x06410108, 0x09021208, 0x0a6f8008, 0x00000000,
+	0x06af0008, 0x06ec09c8, 0x06014d08, 0x0640c908, 0x078005c9,
+	0x0540c249, 0x02008248, 0x06013408, 0x08013501, 0x06413508,
+	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
+	0x08013500, 0x08014d00, 0x06410108, 0x09c08348, 0x0c780b80,
+	0x06010108, 0x06807fc8, 0x09449288, 0x0601100a, 0x06800049,
+	0x078005c8, 0x03409209, 0x07800608, 0x02c08248, 0x07c00608,
+	0x06411009, 0x0904a249, 0x0a6f8009, 0x00000000, 0x06414d09,
+	0x093e1249, 0x0a6f8009, 0x00000000, 0x06410108, 0x09808348,
+	0x06010108, 0x06410108, 0x09021208, 0x0a6f8008, 0x00000000,
+	0x06af0008, 0x06ec05c8, 0x06014d08, 0x0640c908, 0x078005c9,
+	0x0540c249, 0x02008248, 0x06013408, 0x08013503, 0x06413508,
+	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
+	0x08013500, 0x08014d00, 0x06410108, 0x09c08348, 0x06010108,
+	0x06411009, 0x091e1249, 0x0a6f8009, 0x00000000, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0aa08009, 0x0c780000, 0x078008c8, 0x0a624008, 0x07800888,
+	0x0a61c008, 0x07800908, 0x0a614008, 0x07800948, 0x0a60c008,
+	0x0c780400, 0x0680000a, 0x06a00608, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09202288, 0x0a6200ca, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0200a24a, 0x07c00f4a, 0x06414f08, 0x0958320a, 0x06014f08,
+	0x0a62010a, 0x06bf0248, 0x06c002c8, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x0680000a, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0aa24009, 0x06bf0648, 0x06c062c8, 0x097c220a, 0x06014108,
+	0x06414108, 0x09061248, 0x0a6d4009, 0x00000000, 0x07800f48,
+	0x0b40420a, 0x0babc0ca, 0x0400128a, 0x00000000, 0x06bf0a48,
+	0x06c00088, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x07800f88, 0x0aa08008, 0x0c781ac0, 0x06bf0e48,
+	0x06c00508, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x078010c8, 0x0a620108, 0x06bf1248, 0x06c001c8,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
+	0x06bf1648, 0x06c000c8, 0x06014108, 0x06414108, 0x09061248,
+	0x0a6f8009, 0x00000000, 0x06414f0a, 0x07801048, 0x09001248,
+	0x09501289, 0x09081248, 0x094e1289, 0x09101248, 0x094c1289,
+	0x06014f0a, 0x09081288, 0x0a40424a, 0x09001288, 0x0a81324a,
+	0x0680000a, 0x06a00208, 0x06014108, 0x06414108, 0x09061248,
+	0x0a6f8009, 0x09201248, 0x0aa2c009, 0x0680000a, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0aa0c009, 0x0680004a, 0x0680008a, 0x07c0110a, 0x06414f08,
+	0x0954220a, 0x06014f08, 0x0a62008a, 0x06bf1a48, 0x06c00108,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
+	0x0aa2004a, 0x06bf2248, 0x06c00248, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x0aa2000a, 0x06bf1e48,
+	0x06c00108, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x06bf2648, 0x06c008c8, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2a48, 0x06c00bc8,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
+	0x06bf2e48, 0x07801089, 0x0a60c009, 0x06c01108, 0x06c01008,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
+	0x06413a08, 0x09013208, 0x0aa0c008, 0x00000000, 0x08010e88,
+	0x06800008, 0x07c00cc8, 0x07c00d08, 0x08013a00, 0x08011c00,
+	0x08011e00, 0x08011d00, 0x08011f00, 0x08014700, 0x08014800,
+	0x08014200, 0x08014300, 0x08014400, 0x08014500, 0x07800cc8,
+	0x07800409, 0x0e000248, 0x068001df, 0x00000000, 0x07800bc9,
+	0x0f000200, 0x03808248, 0x07c00d48, 0x07800cc8, 0x04001208,
+	0x07800409, 0x0e000248, 0x0680000a, 0x07c00b8a, 0x07800bc9,
+	0x0f000200, 0x03808248, 0x07c00dc8, 0x07800d49, 0x02408248,
+	0x07c00e48, 0x07800d08, 0x07800449, 0x0e000248, 0x00000000,
+	0x00000000, 0x07800c09, 0x0f000200, 0x03808248, 0x0aa10008,
+	0x07c00d88, 0x0c00ed40, 0x09c1f05f, 0x07800d08, 0x04001208,
+	0x07800449, 0x0e000248, 0x00000000, 0x00000000, 0x07800c09,
+	0x0f000200, 0x03808248, 0x07c00e08, 0x07800d89, 0x02408248,
+	0x07c00e88, 0x07800d48, 0x04001208, 0x07800dc9, 0x0b807248,
+	0x07800d88, 0x04001208, 0x07800e09, 0x0b803248, 0x00000000,
+	0x0981f0df, 0x07800d88, 0x07800409, 0x0e000248, 0x07c00f08,
+	0x07c01348, 0x07800d49, 0x07c00ec9, 0x07c01309, 0x0f000200,
+	0x02008248, 0x07c00508, 0x05404248, 0x05403208, 0x02008248,
+	0x07c01208, 0x07c01248, 0x06800008, 0x07c01288, 0x07c012c8,
+	0x06812008, 0x06010e08, 0x08010e00, 0x07800cc8, 0x0a60c008,
+	0x07800d08, 0x0aa20008, 0x0641390a, 0x0aa1800a, 0x00000000,
+	0x08010e88, 0x00000000, 0x0c7ffec0, 0x00000000, 0x07800cc8,
+	0x07800c49, 0x0b804248, 0x07800d08, 0x07800c89, 0x0b40d248,
+	0x06410c08, 0x08010e90, 0x09210248, 0x06410c08, 0x08010e90,
+	0x09210288, 0x09610289, 0x0601390a, 0x0540324a, 0x098097c9,
+	0x09809789, 0x06013a09, 0x07800e48, 0x0aa0c008, 0x07800e88,
+	0x0a630008, 0x07800cc8, 0x04001208, 0x07800c49, 0x0b082248,
+	0x07c00cc8, 0x06800008, 0x07c00cc8, 0x07800d08, 0x04001208,
+	0x0c7fdf00, 0x07c00d08, 0x07800a48, 0x0aa0c008, 0x0c00df00,
+	0x00000000, 0x06411009, 0x098093c9, 0x06011009, 0x06470109,
+	0x09809209, 0x06070109, 0x06470b08, 0x07800249, 0x04408249,
+	0x09402209, 0x09482209, 0x09502209, 0x06070b08, 0x078002c8,
+	0x07800309, 0x09610209, 0x06020508, 0x07800d48, 0x07800d89,
+	0x09610209, 0x06020708, 0x06060708, 0x07800e48, 0x07800e89,
+	0x09610209, 0x06020808, 0x06060808, 0x07800408, 0x04401208,
+	0x07800449, 0x04401249, 0x09610209, 0x06020608, 0x06420109,
+	0x07800188, 0x0aa0c008, 0x06800388, 0x06800308, 0x09403248,
+	0x078004c8, 0x04003208, 0x09604248, 0x07800488, 0x04003208,
+	0x09684248, 0x06020109, 0x06424c09, 0x09809009, 0x09809049,
+	0x09809089, 0x07801088, 0x05001208, 0x09501248, 0x07801048,
+	0x09001288, 0x095c124a, 0x09081288, 0x095a124a, 0x09101288,
+	0x0958124a, 0x06024c09, 0x06420408, 0x093e1208, 0x0a6f8008,
+	0x00000000, 0x078002c9, 0x0780030a, 0x0960f24a, 0x06040209,
+	0x07800409, 0x0780044a, 0x0960c24a, 0x06040309, 0x08040400,
+	0x07800c48, 0x0a618008, 0x06800049, 0x07800c88, 0x0a60c008,
+	0x06800049, 0x06800009, 0x06040509, 0x07800e48, 0x07800e89,
+	0x09610209, 0x06040308, 0x07800d48, 0x07800d89, 0x09610209,
+	0x06040408, 0x06450d08, 0x09001248, 0x0a6f8009, 0x00000000,
+	0x08040640, 0x06414f0a, 0x07800148, 0x0aa10008, 0x06800009,
+	0x06800289, 0x0980a24a, 0x06040c09, 0x06014f0a, 0x06440009,
+	0x09809009, 0x06040009, 0x09c09009, 0x06040009, 0x06800048,
+	0x09482248, 0x09809049, 0x06040009, 0x07800249, 0x04408249,
+	0x06450108, 0x09602209, 0x09642209, 0x06050108, 0x078002c8,
+	0x07800309, 0x09610209, 0x06050208, 0x07800bc8, 0x06050c08,
+	0x07800d48, 0x07800d89, 0x0960a209, 0x07800cc9, 0x09584209,
+	0x07800d09, 0x09784209, 0x06050608, 0x07800d4a, 0x07800e48,
+	0x02008288, 0x04401208, 0x07800d8a, 0x07800e89, 0x02009289,
+	0x04401249, 0x0960a209, 0x06050708, 0x07800d48, 0x07800d89,
+	0x0960a209, 0x06050808, 0x078002c8, 0x07800309, 0x09610209,
+	0x06060508, 0x07800408, 0x04401208, 0x07800449, 0x04401249,
+	0x09610209, 0x06060608, 0x06460109, 0x09809709, 0x06060109,
+	0x07800ec9, 0x07800f08, 0x0958c248, 0x0978425f, 0x06011609,
+	0x06411009, 0x091e1249, 0x0a6f8009, 0x00000000, 0x06a00208,
+	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
+	0x0aa08009, 0x0c780000, 0x07800508, 0x09808788, 0x098087c8,
+	0x06012408, 0x07800d48, 0x0a644008, 0x07800d88, 0x0a63c008,
+	0x00000000, 0x06400408, 0x09808688, 0x06000408, 0x09c08688,
+	0x06000408, 0x06814008, 0x07c01148, 0x06800008, 0x07c01188,
+	0x0c00eec0, 0x00000000, 0x0c00f580, 0x00000000, 0x06800048,
+	0x0541f208, 0x06020408, 0x06060408, 0x08040701, 0x06450808,
+	0x098087c8, 0x06050808, 0x06414008, 0x09808048, 0x06014008,
+	0x06414008, 0x0c783580, 0x00000000, 0x078001c8, 0x0a614008,
+	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c00f89,
+	0x0a60c009, 0x0780020a, 0x0aa0c00a, 0x0c00f400, 0x00000000,
+	0x06414f08, 0x095e1209, 0x05001289, 0x0968120a, 0x06014f08,
+	0x07800208, 0x0a614008, 0x06800009, 0x06410c08, 0x08010e82,
+	0x093c2248, 0x07c00fc9, 0x07800f88, 0x0aa08008, 0x0c7f0940,
+	0x06410c08, 0x08010e88, 0x09308248, 0x07c01009, 0x06410c08,
+	0x08010e8c, 0x0928c248, 0x07c01049, 0x09101209, 0x09081289,
+	0x0a806288, 0x068009ca, 0x09001289, 0x0a803288, 0x06800d8a,
+	0x06800e8a, 0x06414f09, 0x0940624a, 0x06014f09, 0x0680008a,
+	0x0680000b, 0x06410c08, 0x08010e81, 0x093e1248, 0x03408289,
+	0x02c0b20b, 0x0a63c009, 0x07c023cb, 0x0b20c00a, 0x0c7ffe00,
+	0x0440128a, 0x06410c08, 0x08010e90, 0x09210248, 0x04001249,
+	0x06410c08, 0x08010e90, 0x09210208, 0x04001208, 0x07c00308,
+	0x07c002c9, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c021c9,
+	0x0aa2c009, 0x00000000, 0x06410c08, 0x08010e90, 0x09210248,
+	0x04001249, 0x07c02309, 0x08010e90, 0x09010208, 0x04001208,
+	0x07c02348, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c01089,
+	0x06414f08, 0x09661209, 0x06014f08, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0a61c009, 0x0680010a, 0x08010e82, 0x093a2248,
+	0x0b60c089, 0x04000289, 0x0500128a, 0x07c010ca, 0x06414f08,
+	0x0960320a, 0x06014f08, 0x0c7f0800, 0x00000000, 0x0a60c188,
+	0x00000000, 0x08010e90, 0x0c780080, 0x0800c0ff, 0x00800000,
+	0x0c00d580, 0x00000000, 0x07800008, 0x0c7ecf00, 0x06030408,
+	0x06806008, 0x06010e08, 0x06410f08, 0x0befc0c8, 0x09118208,
+	0x0cc00000, 0x07400248, 0x0680e008, 0x06010e08, 0x06410f08,
+	0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248, 0x06410509,
+	0x06bfff89, 0x06030409, 0x00400000, 0x0be0c108, 0x0c7ff9c0,
+	0x00000000, 0x08012104, 0x080150c0, 0x06411c26, 0x06411d27,
+	0x06414728, 0x06414229, 0x07800409, 0x0ae1c049, 0x0641432a,
+	0x04000866, 0x040008a7, 0x040008e8, 0x04000929, 0x0400096a,
+	0x06014224, 0x06014325, 0x06011c21, 0x06011d22, 0x0a21c91f,
+	0x06014723, 0x08011e00, 0x08011f00, 0x08014800, 0x08014400,
+	0x08014500, 0x0be0e026, 0x0c7809c0, 0x00000000, 0x07800a48,
+	0x0aa0c008, 0x0c00aac0, 0x00000000, 0x068001df, 0x0978479f,
+	0x06420409, 0x093e1209, 0x0a6f8008, 0x09c09749, 0x06020409,
+	0x07800cc8, 0x04001208, 0x07800c49, 0x0b009248, 0x07c00cc8,
+	0x06800008, 0x07c00cc8, 0x07800d08, 0x04001208, 0x07800c89,
+	0x0ac08248, 0x07c00d08, 0x0c006940, 0x00000000, 0x0c003e40,
+	0x00000000, 0x0c7f7840, 0x00000000, 0x07800549, 0x0aa0c009,
+	0x0c00ac40, 0x00000000, 0x0c003c40, 0x00000000, 0x0c7fe980,
+	0x0800c0ff, 0x0601161e, 0x07800508, 0x09808788, 0x098087c8,
+	0x06012408, 0x06414009, 0x09809049, 0x06014009, 0x06414009,
+	0x09c1f09f, 0x07800508, 0x04001208, 0x07c00508, 0x07800b88,
+	0x04001208, 0x07c00b88, 0x0a21409f, 0x07800e49, 0x0b803248,
+	0x00000000, 0x09c1f05f, 0x07800ec8, 0x04001208, 0x07800dc9,
+	0x0b811248, 0x07c00ec8, 0x07800d48, 0x07c00ec8, 0x0981f09f,
+	0x07800508, 0x07800409, 0x02008248, 0x07800e49, 0x02408248,
+	0x07c00508, 0x07800f08, 0x04001208, 0x07800e09, 0x0b803248,
+	0x07c00f08, 0x0981f0df, 0x07800f08, 0x04001208, 0x07800e09,
+	0x0b80f248, 0x07800ec8, 0x04001208, 0x07800dc9, 0x0b80b248,
+	0x07800409, 0x0b807248, 0x07800f08, 0x04001208, 0x07800449,
+	0x0b803248, 0x0c7800c0, 0x09c1f11f, 0x0981f11f, 0x0981f0df,
+	0x07800ede, 0x07800f08, 0x0958c788, 0x0978479f, 0x07800b88,
+	0x0ae08048, 0x0c780a00, 0x07800ec9, 0x07800d4a, 0x0400228a,
+	0x0b407289, 0x04402209, 0x0440128a, 0x07800dc8, 0x0b403289,
+	0x04401208, 0x04401208, 0x05403248, 0x02009248, 0x02008248,
 	0x06806009, 0x02009209, 0x07400266, 0x09210226, 0x04001249,
 	0x07400248, 0x04001249, 0x07400269, 0x09210229, 0x04001249,
 	0x07400248, 0x04001249, 0x0740026a, 0x0921022a, 0x04001249,
 	0x07400248, 0x04001249, 0x07400267, 0x09210227, 0x04001249,
 	0x07400248, 0x04001249, 0x07400268, 0x09210228, 0x04001249,
-	0x0cc00000, 0x07400248, 0x07800d48, 0x05403248, 0x02009248,
-	0x02008248, 0x06806009, 0x02009209, 0x07000261, 0x04001249,
-	0x07000248, 0x09610848, 0x04001249, 0x07000264, 0x04001249,
-	0x07000248, 0x09610908, 0x04001249, 0x07000265, 0x04001249,
-	0x07000248, 0x09610948, 0x04001249, 0x07000262, 0x04001249,
-	0x07000248, 0x09610888, 0x04001249, 0x07000263, 0x04001249,
-	0x07000248, 0x096108c8, 0x06014224, 0x06014325, 0x06011c21,
-	0x06011d22, 0x0cc00000, 0x06014723, 0x07800a88, 0x0aa14008,
-	0x07800ac8, 0x0a60c008, 0x0cc00000, 0x00000000, 0x07801208,
-	0x0640cb09, 0x02009248, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x00000000, 0x06035109, 0x06800c08, 0x06035208, 0x06b10008,
-	0x06035008, 0x08015020, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x06810008, 0x0680018b, 0x07800b49, 0x0a618009, 0x06800009,
-	0x0d00000b, 0x06015109, 0x0cc00000, 0x08015080, 0x07000209,
-	0x04001208, 0x0700020a, 0x04001208, 0x0961024a, 0x0d07fecb,
-	0x06015109, 0x0cc00000, 0x08015080, 0x07800b88, 0x0ae08048,
-	0x0c780900, 0x078012c8, 0x05403248, 0x05402208, 0x02008248,
-	0x06810009, 0x02008248, 0x08015020, 0x0643500b, 0x0580f2cb,
-	0x0bef804b, 0x0680018b, 0x06415109, 0x07400209, 0x04001208,
-	0x09210249, 0x07400209, 0x0d07fecb, 0x04001208, 0x07c012c8,
-	0x07801288, 0x0be3c0c8, 0x0be0c108, 0x0681000b, 0x040302cb,
-	0x07800a88, 0x0aa28008, 0x07801248, 0x0640cb09, 0x02009248,
-	0x06035109, 0x078012c8, 0x024082c8, 0x06035208, 0x0980b3cb,
-	0x0603500b, 0x07801208, 0x07c01248, 0x07801288, 0x07c012c8,
-	0x07800f08, 0x07801349, 0x0a408248, 0x07800eca, 0x07801309,
-	0x04001249, 0x0a40c289, 0x07801289, 0x0c780340, 0x04001249,
-	0x04001249, 0x0a407209, 0x07800eca, 0x0a61400a, 0x07801309,
-	0x04001249, 0x0780040a, 0x0a8f6289, 0x07801289, 0x04004249,
-	0x048fc249, 0x04807249, 0x07c01289, 0x0be340c9, 0x07800f08,
-	0x07800409, 0x0e000248, 0x07800ec9, 0x00000000, 0x00000000,
-	0x0f000200, 0x02008248, 0x05404248, 0x05403208, 0x02008248,
-	0x07c01208, 0x07800ec8, 0x07c01308, 0x07800f08, 0x07c01348,
-	0x07800a88, 0x0aa14008, 0x07800ac8, 0x0a60c008, 0x0cc00000,
-	0x00000000, 0x07801289, 0x0be400c9, 0x07801208, 0x0640cb09,
-	0x02009248, 0x06435008, 0x0580f208, 0x0bef8048, 0x00000000,
-	0x06035109, 0x06800c08, 0x06035208, 0x07801289, 0x0be0c109,
-	0x06b10c08, 0x06b10008, 0x06035008, 0x06435008, 0x0580f208,
-	0x0bef8048, 0x00000000, 0x07801288, 0x05403248, 0x05402208,
-	0x02008248, 0x06810009, 0x02008248, 0x08015020, 0x0680018b,
+	0x07400248, 0x0a21c09f, 0x06800024, 0x06800025, 0x06800021,
+	0x06800022, 0x0c780800, 0x06800023, 0x07800ec8, 0x05403248,
+	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07000261,
+	0x04001249, 0x07000248, 0x09610848, 0x04001249, 0x07000264,
+	0x04001249, 0x07000248, 0x09610908, 0x04001249, 0x07000265,
+	0x04001249, 0x07000248, 0x09610948, 0x04001249, 0x07000262,
+	0x04001249, 0x07000248, 0x09610888, 0x04001249, 0x07000263,
+	0x04001249, 0x07000248, 0x096108c8, 0x07800a48, 0x0aa0c008,
+	0x0c005cc0, 0x00000000, 0x0c7fc480, 0x00000000, 0x06412106,
+	0x090c1186, 0x0a6f8006, 0x0c7e9340, 0x00000000, 0x06804009,
+	0x06012d09, 0x06800f8a, 0x08012e00, 0x00000000, 0x0d07ff8a,
+	0x00000000, 0x0cc00000, 0x00000000, 0x07800148, 0x07c02008,
+	0x07800188, 0x07c020c8, 0x078001c8, 0x07c02108, 0x07800208,
+	0x07c02148, 0x07800f88, 0x07c02188, 0x07800fc8, 0x07c02208,
+	0x07801008, 0x07c02248, 0x078002c8, 0x07c02288, 0x07800308,
+	0x07c022c8, 0x07801048, 0x07c02388, 0x078006c8, 0x07c02408,
+	0x07800708, 0x07c02448, 0x07800748, 0x07c02488, 0x07800788,
+	0x07c024c8, 0x078007c8, 0x07c02508, 0x07800808, 0x07c02548,
+	0x07800848, 0x07c02588, 0x07800648, 0x07c025c8, 0x07800688,
+	0x07c02608, 0x07800248, 0x07c02648, 0x07800a48, 0x07c02888,
+	0x07800b08, 0x07c028c8, 0x0640c108, 0x06035108, 0x06802008,
+	0x06035208, 0x06a02008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0800cf00, 0x0800c0ff,
+	0x06800009, 0x0680ffca, 0x07000248, 0x09808408, 0x0600cf08,
+	0x00000000, 0x0640cf08, 0x0a6fc008, 0x0b403289, 0x0c7ffe40,
+	0x04001249, 0x0cc00000, 0x00000000, 0x069fffca, 0x06440109,
+	0x0a2fc049, 0x0440128a, 0x06460309, 0x093e1289, 0x0a6f800a,
+	0x00000000, 0x0cc00000, 0x00000000, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0a60c009, 0x07c00a89, 0x0c780b80, 0x06847f4a,
+	0x06012d0a, 0x0680000a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa14009, 0x06803fc9, 0x06410c08, 0x08010e88, 0x09308248,
+	0x054082cb, 0x094082c9, 0x0bad80ca, 0x0400128a, 0x0a60c10a,
+	0x00000000, 0x06012e0b, 0x0bac41ca, 0x00000000, 0x054082cb,
+	0x06012e0b, 0x06847fca, 0x06012d0a, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x06bfc00b, 0x0aa40009, 0x07c00ac9, 0x0680000a,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x06803fc9,
+	0x06410c08, 0x08010e88, 0x09308248, 0x054082cb, 0x094082c9,
+	0x0bad808a, 0x0400128a, 0x054082cb, 0x06012e0b, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0a60c009, 0x0c780d80, 0x00000000,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x07c00b09, 0x0680000c,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x0680000a,
+	0x06410c08, 0x08010e89, 0x092e9288, 0x0680268b, 0x0200b30b,
+	0x074002ca, 0x0680000b, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0540f289, 0x0aa28009, 0x095612c9, 0x06410c08, 0x08010e87,
+	0x09346248, 0x09406289, 0x094862c9, 0x09321248, 0x09501289,
+	0x095412c9, 0x040a420c, 0x0740020a, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa18009, 0x094612c9, 0x06410c08, 0x08010e82,
+	0x093c2248, 0x094222c9, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x094012c9, 0x096c32cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b,
+	0x0c7ff4c0, 0x0400130c, 0x0680000c, 0x07800b0a, 0x0aa0c00a,
+	0x0780088b, 0x0680000b, 0x06802688, 0x02008308, 0x07000208,
+	0x09028288, 0x09001248, 0x0aa0c009, 0x0200928b, 0x0240928b,
+	0x0ba14009, 0x0680000a, 0x0ae0ffc9, 0x06803fca, 0x04000289,
+	0x07900988, 0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9,
+	0x06803fcb, 0x040002c9, 0x095082ca, 0x096232cc, 0x0601460b,
+	0x07900a08, 0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9,
+	0x06803fcb, 0x040002c9, 0x079009c8, 0x0200920a, 0x0ba14009,
+	0x06800008, 0x0ae0ffc9, 0x06803fc8, 0x04000209, 0x0950820b,
+	0x0962320c, 0x09808408, 0x06014608, 0x0b60c1cc, 0x0c7ff480,
+	0x0400130c, 0x0cc00000, 0x00000000, 0x07800dc8, 0x04401208,
+	0x05403248, 0x02009248, 0x02008248, 0x06806009, 0x02009209,
+	0x07400266, 0x09210226, 0x04001249, 0x07400248, 0x04001249,
+	0x07400269, 0x09210229, 0x04001249, 0x07400248, 0x04001249,
+	0x0740026a, 0x0921022a, 0x04001249, 0x07400248, 0x04001249,
+	0x07400267, 0x09210227, 0x04001249, 0x07400248, 0x04001249,
+	0x07400268, 0x09210228, 0x04001249, 0x0cc00000, 0x07400248,
+	0x07800d48, 0x05403248, 0x02009248, 0x02008248, 0x06806009,
+	0x02009209, 0x07000261, 0x04001249, 0x07000248, 0x09610848,
+	0x04001249, 0x07000264, 0x04001249, 0x07000248, 0x09610908,
+	0x04001249, 0x07000265, 0x04001249, 0x07000248, 0x09610948,
+	0x04001249, 0x07000262, 0x04001249, 0x07000248, 0x09610888,
+	0x04001249, 0x07000263, 0x04001249, 0x07000248, 0x096108c8,
+	0x06014224, 0x06014325, 0x06011c21, 0x06011d22, 0x0cc00000,
+	0x06014723, 0x07800a88, 0x0aa14008, 0x07800ac8, 0x0a60c008,
+	0x0cc00000, 0x00000000, 0x07801208, 0x0640cb09, 0x02009248,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06035109,
+	0x06800c08, 0x06035208, 0x06b10008, 0x06035008, 0x08015020,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x06810008, 0x0680018b,
 	0x07800b49, 0x0a618009, 0x06800009, 0x0d00000b, 0x06015109,
-	0x0cc00000, 0x00000000, 0x07000209, 0x04001208, 0x0700020a,
+	0x0cc00000, 0x08015080, 0x07000209, 0x04001208, 0x0700020a,
 	0x04001208, 0x0961024a, 0x0d07fecb, 0x06015109, 0x0cc00000,
-	0x00000000, 0x078012c8, 0x0a20c108, 0x0681000a, 0x06810c0a,
+	0x08015080, 0x07800b88, 0x0ae08048, 0x0c780900, 0x078012c8,
 	0x05403248, 0x05402208, 0x02008248, 0x06810009, 0x02008248,
 	0x08015020, 0x0643500b, 0x0580f2cb, 0x0bef804b, 0x0680018b,
 	0x06415109, 0x07400209, 0x04001208, 0x09210249, 0x07400209,
-	0x0d07fecb, 0x04001208, 0x07c012c8, 0x07800a88, 0x0a608008,
-	0x0cc00000, 0x07801248, 0x0640cb09, 0x02009248, 0x06035109,
-	0x078012c8, 0x02408288, 0x06035208, 0x0980a3ca, 0x0cc00000,
-	0x0603500a, 0x06410108, 0x09808348, 0x06010108, 0x06410108,
-	0x09021208, 0x0a6f8008, 0x07800588, 0x0aa34048, 0x06bf0008,
-	0x06e016c8, 0x06014d08, 0x0640ca08, 0x06013408, 0x08013503,
-	0x06413508, 0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009,
-	0x00000000, 0x08014d00, 0x06af0008, 0x06ec05c8, 0x06014d08,
-	0x0640c908, 0x07800589, 0x0aa10009, 0x06900009, 0x078005c9,
-	0x0540c249, 0x02008248, 0x06013408, 0x08013503, 0x06413508,
-	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
-	0x08013500, 0x08014d00, 0x07800588, 0x0aa14048, 0x06803f48,
-	0x078005c9, 0x09502209, 0x0600c308, 0x06410108, 0x09c08348,
-	0x0cc00000, 0x06010108, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x00000000, 0x0640c408, 0x07801189, 0x05408249, 0x02008248,
-	0x06035108, 0x08035280, 0x06bd4008, 0x06035008, 0x07801189,
-	0x04001249, 0x07c01189, 0x06814009, 0x07c01149, 0x06462308,
-	0x09808288, 0x06062308, 0x06462d08, 0x09808048, 0x06062d08,
-	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0cc00000,
-	0x00000000, 0x06463908, 0x09105248, 0x0aa40009, 0x0780114a,
-	0x07000288, 0x0400128a, 0x0700028b, 0x0961020b, 0x06063808,
-	0x0400128a, 0x07c0114a, 0x06816008, 0x0b8f620a, 0x04401249,
-	0x0c07f540, 0x00000000, 0x0c7ffc00, 0x00000000, 0x0cc00000,
-	0x00000000, 0x0680000c, 0x06800008, 0x07c00b48, 0x0409a2cc,
-	0x074002c8, 0x040a42cc, 0x074002c8, 0x054162cc, 0x0980b7cb,
-	0x0b6101cc, 0x0601460b, 0x0c7ffe00, 0x0400130c, 0x06800048,
-	0x07c00708, 0x06800008, 0x07c00748, 0x07c00808, 0x07c00848,
-	0x04401208, 0x07c00788, 0x0cc00000, 0x07c007c8, 0x07800349,
-	0x07800388, 0x09610248, 0x06412308, 0x0a804248, 0x06800009,
-	0x07c00b49, 0x06800049, 0x07c003c9, 0x09010248, 0x07c002c9,
-	0x07c00349, 0x09210208, 0x07c00308, 0x07c00388, 0x0403f289,
-	0x0580628a, 0x07c0040a, 0x0403f288, 0x0580628a, 0x0cc00000,
-	0x07c0044a, 0x067f2f2b, 0x0a2fc12b, 0x0640c02b, 0x0a6f7feb,
-	0x00000000, 0x0641392b, 0x0680006f, 0x0c001200, 0x06800030,
-	0x0c001d00, 0x069fffb1, 0x08013900, 0x06410b2b, 0x0982b0ab,
-	0x06010b2b, 0x0641212b, 0x0a2fc06b, 0x00000000, 0x069315ae,
-	0x06d0536e, 0x06410c2b, 0x068000af, 0x0c000e40, 0x04000c2b,
-	0x0a4edbab, 0x08012101, 0x08010e90, 0x08010e90, 0x06410c2b,
-	0x068000ef, 0x0c000c40, 0x04000c2b, 0x0695556e, 0x06d5556e,
-	0x0a409bab, 0x00000000, 0x08012101, 0x0800c0f2, 0x08007401,
-	0x0640c02e, 0x0aaffcae, 0x0c7ff700, 0x00000000, 0x093c2aeb,
-	0x0aa0c0ab, 0x0c7ff600, 0x00000000, 0x0641162c, 0x093e1b2c,
-	0x0aa0402c, 0x0640d22c, 0x0a21406c, 0x00000000, 0x0800c0f1,
-	0x0c7ff280, 0x08007401, 0x0680006d, 0x0680012f, 0x0c000540,
-	0x04000c2d, 0x0600c02d, 0x08030504, 0x0c7ff080, 0x00000000,
-	0x0c074980, 0x00000000, 0x0800c0f0, 0x08007401, 0x0cc00000,
-	0x00000000, 0x0640c009, 0x0aa0c149, 0x0a6f8189, 0x00000000,
-	0x068004af, 0x0c000100, 0x06800030, 0x0cc00000, 0x00000000,
-	0x0600d130, 0x078013f0, 0x0aa18030, 0x00000000, 0x0600d02f,
-	0x08007401, 0x0640d02f, 0x0a6fc02f, 0x00000000, 0x0cc00000,
-	0x00000000, 0x0600d130, 0x078013f0, 0x0aa54030, 0x00000000,
-	0x0640cf30, 0x06035130, 0x0680fc30, 0x06035230, 0x06a00030,
-	0x06035030, 0x06435030, 0x0580fc30, 0x0bef8070, 0x00000000,
-	0x06435330, 0x0900cc30, 0x0a6f8030, 0x00000000, 0x0982f42f,
-	0x0600d02f, 0x08007401, 0x0640d02f, 0x0a6fc02f, 0x0cc00000,
-	0x00000000, 0x06810030, 0x06800008, 0x06410c2f, 0x08010e90,
-	0x09210bef, 0x0740022f, 0x0d07ff30, 0x04001208, 0x0cc00000,
-	0x00000000, 0x0aa54031, 0x04000c31, 0x0640d42f, 0x09010bef,
-	0x0a411c2f, 0x0640d42f, 0x09202bef, 0x0a61406f, 0x00000000,
-	0x0c07f500, 0x06800030, 0x0c780180, 0x0a6d80ef, 0x00000000,
-	0x0c07fa00, 0x00000000, 0x0c780040, 0x04000c31, 0x0600d430,
-	0x0c7ffbc0, 0x00000000, 0x0cc00000, 0x00000000, 0x078002c8,
-	0x07800309, 0x09610209, 0x06012308, 0x06800208, 0x078004c9,
-	0x03408248, 0x06040608, 0x078002c9, 0x0780030a, 0x0960f24a,
-	0x06040209, 0x07800409, 0x0780044a, 0x0960c24a, 0x06040309,
-	0x08040400, 0x0cc00000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0d07fecb, 0x04001208, 0x07c012c8, 0x07801288, 0x0be3c0c8,
+	0x0be0c108, 0x0681000b, 0x040302cb, 0x07800a88, 0x0aa28008,
+	0x07801248, 0x0640cb09, 0x02009248, 0x06035109, 0x078012c8,
+	0x024082c8, 0x06035208, 0x0980b3cb, 0x0603500b, 0x07801208,
+	0x07c01248, 0x07801288, 0x07c012c8, 0x07800f08, 0x07801349,
+	0x0a408248, 0x07800eca, 0x07801309, 0x04001249, 0x0a40c289,
+	0x07801289, 0x0c780340, 0x04001249, 0x04001249, 0x0a407209,
+	0x07800eca, 0x0a61400a, 0x07801309, 0x04001249, 0x0780040a,
+	0x0a8f6289, 0x07801289, 0x04004249, 0x048fc249, 0x04807249,
+	0x07c01289, 0x0be340c9, 0x07800f08, 0x07800409, 0x0e000248,
+	0x07800ec9, 0x00000000, 0x00000000, 0x0f000200, 0x02008248,
+	0x05404248, 0x05403208, 0x02008248, 0x07c01208, 0x07800ec8,
+	0x07c01308, 0x07800f08, 0x07c01348, 0x07800a88, 0x0aa14008,
+	0x07800ac8, 0x0a60c008, 0x0cc00000, 0x00000000, 0x07801289,
+	0x0be400c9, 0x07801208, 0x0640cb09, 0x02009248, 0x06435008,
+	0x0580f208, 0x0bef8048, 0x00000000, 0x06035109, 0x06800c08,
+	0x06035208, 0x07801289, 0x0be0c109, 0x06b10c08, 0x06b10008,
+	0x06035008, 0x06435008, 0x0580f208, 0x0bef8048, 0x00000000,
+	0x07801288, 0x05403248, 0x05402208, 0x02008248, 0x06810009,
+	0x02008248, 0x08015020, 0x0680018b, 0x07800b49, 0x0a618009,
+	0x06800009, 0x0d00000b, 0x06015109, 0x0cc00000, 0x00000000,
+	0x07000209, 0x04001208, 0x0700020a, 0x04001208, 0x0961024a,
+	0x0d07fecb, 0x06015109, 0x0cc00000, 0x00000000, 0x078012c8,
+	0x0a20c108, 0x0681000a, 0x06810c0a, 0x05403248, 0x05402208,
+	0x02008248, 0x06810009, 0x02008248, 0x08015020, 0x0643500b,
+	0x0580f2cb, 0x0bef804b, 0x0680018b, 0x06415109, 0x07400209,
+	0x04001208, 0x09210249, 0x07400209, 0x0d07fecb, 0x04001208,
+	0x07c012c8, 0x07800a88, 0x0a608008, 0x0cc00000, 0x07801248,
+	0x0640cb09, 0x02009248, 0x06035109, 0x078012c8, 0x02408288,
+	0x06035208, 0x0980a3ca, 0x0cc00000, 0x0603500a, 0x06410108,
+	0x09808348, 0x06010108, 0x06410108, 0x09021208, 0x0a6f8008,
+	0x07800588, 0x0aa34048, 0x06bf0008, 0x06e016c8, 0x06014d08,
+	0x0640ca08, 0x06013408, 0x08013503, 0x06413508, 0x090e1248,
+	0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000, 0x08014d00,
+	0x06af0008, 0x06ec05c8, 0x06014d08, 0x0640c908, 0x07800589,
+	0x0aa10009, 0x06900009, 0x078005c9, 0x0540c249, 0x02008248,
+	0x06013408, 0x08013503, 0x06413508, 0x090e1248, 0x0a6f8009,
+	0x09308248, 0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00,
+	0x07800588, 0x0aa14048, 0x06803f48, 0x078005c9, 0x09502209,
+	0x0600c308, 0x06410108, 0x09c08348, 0x0cc00000, 0x06010108,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0640c408,
+	0x07801189, 0x05408249, 0x02008248, 0x06035108, 0x08035280,
+	0x06bd4008, 0x06035008, 0x07801189, 0x04001249, 0x07c01189,
+	0x06814009, 0x07c01149, 0x06462308, 0x09808288, 0x06062308,
+	0x06462d08, 0x09808048, 0x06062d08, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x0cc00000, 0x00000000, 0x06463908,
+	0x09105248, 0x0aa40009, 0x0780114a, 0x07000288, 0x0400128a,
+	0x0700028b, 0x0961020b, 0x06063808, 0x0400128a, 0x07c0114a,
+	0x06816008, 0x0b8f620a, 0x04401249, 0x0c07f540, 0x00000000,
+	0x0c7ffc00, 0x00000000, 0x0cc00000, 0x00000000, 0x0680000c,
+	0x06800008, 0x07c00b48, 0x0409a2cc, 0x074002c8, 0x040a42cc,
+	0x074002c8, 0x054162cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b,
+	0x0c7ffe00, 0x0400130c, 0x06800048, 0x07c00708, 0x06800008,
+	0x07c00748, 0x07c00808, 0x07c00848, 0x04401208, 0x07c00788,
+	0x0cc00000, 0x07c007c8, 0x07800349, 0x07800388, 0x09610248,
+	0x06412308, 0x0a804248, 0x06800009, 0x07c00b49, 0x06800049,
+	0x07c003c9, 0x09010248, 0x07c002c9, 0x07c00349, 0x09210208,
+	0x07c00308, 0x07c00388, 0x0403f289, 0x0580628a, 0x07c0040a,
+	0x0403f288, 0x0580628a, 0x0cc00000, 0x07c0044a, 0x067f2f2b,
+	0x0a2fc12b, 0x0640c02b, 0x0a6f7feb, 0x00000000, 0x0641392b,
+	0x0680006f, 0x0c001200, 0x06800030, 0x0c001d00, 0x069fffb1,
+	0x08013900, 0x06410b2b, 0x0982b0ab, 0x06010b2b, 0x0641212b,
+	0x0a2fc06b, 0x00000000, 0x069315ae, 0x06d0536e, 0x06410c2b,
+	0x068000af, 0x0c000e40, 0x04000c2b, 0x0a4edbab, 0x08012101,
+	0x08010e90, 0x08010e90, 0x06410c2b, 0x068000ef, 0x0c000c40,
+	0x04000c2b, 0x0695556e, 0x06d5556e, 0x0a409bab, 0x00000000,
+	0x08012101, 0x0800c0f2, 0x08007401, 0x0640c02e, 0x0aaffcae,
+	0x0c7ff700, 0x00000000, 0x093c2aeb, 0x0aa0c0ab, 0x0c7ff600,
+	0x00000000, 0x0641162c, 0x093e1b2c, 0x0aa0402c, 0x0640d22c,
+	0x0a21406c, 0x00000000, 0x0800c0f1, 0x0c7ff280, 0x08007401,
+	0x0680006d, 0x0680012f, 0x0c000540, 0x04000c2d, 0x0600c02d,
+	0x08030504, 0x0c7ff080, 0x00000000, 0x0c074980, 0x00000000,
+	0x0800c0f0, 0x08007401, 0x0cc00000, 0x00000000, 0x0640c009,
+	0x0aa0c149, 0x0a6f8189, 0x00000000, 0x068004af, 0x0c000100,
+	0x06800030, 0x0cc00000, 0x00000000, 0x0600d130, 0x078013f0,
+	0x0aa18030, 0x00000000, 0x0600d02f, 0x08007401, 0x0640d02f,
+	0x0a6fc02f, 0x00000000, 0x0cc00000, 0x00000000, 0x0600d130,
+	0x078013f0, 0x0aa54030, 0x00000000, 0x0640cf30, 0x06035130,
+	0x0680fc30, 0x06035230, 0x06a00030, 0x06035030, 0x06435030,
+	0x0580fc30, 0x0bef8070, 0x00000000, 0x06435330, 0x0900cc30,
+	0x0a6f8030, 0x00000000, 0x0982f42f, 0x0600d02f, 0x08007401,
+	0x0640d02f, 0x0a6fc02f, 0x0cc00000, 0x00000000, 0x06810030,
+	0x06800008, 0x06410c2f, 0x08010e90, 0x09210bef, 0x0740022f,
+	0x0d07ff30, 0x04001208, 0x0cc00000, 0x00000000, 0x0aa54031,
+	0x04000c31, 0x0640d42f, 0x09010bef, 0x0a411c2f, 0x0640d42f,
+	0x09202bef, 0x0a61406f, 0x00000000, 0x0c07f500, 0x06800030,
+	0x0c780180, 0x0a6d80ef, 0x00000000, 0x0c07fa00, 0x00000000,
+	0x0c780040, 0x04000c31, 0x0600d430, 0x0c7ffbc0, 0x00000000,
+	0x0cc00000, 0x00000000, 0x078002c8, 0x07800309, 0x09610209,
+	0x06012308, 0x06800208, 0x078004c9, 0x03408248, 0x06040608,
+	0x078002c9, 0x0780030a, 0x0960f24a, 0x06040209, 0x07800409,
+	0x0780044a, 0x0960c24a, 0x06040309, 0x08040400, 0x0cc00000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+
+#endif
 };
 
 
diff --git a/drivers/amlogic/amports/avs.h b/drivers/amlogic/amports/avs.h
index 1f41e45..d415645 100644
--- a/drivers/amlogic/amports/avs.h
+++ b/drivers/amlogic/amports/avs.h
@@ -22,7 +22,7 @@ extern void *avsp_heap_adr;
 
 int avs_get_debug_flag(void);
 
-void process_long_cabac(void);
+int process_long_cabac(void);
 
 /* bit [6] - skip_mode_flag
  bit [5:4] - picture_type
@@ -47,6 +47,7 @@ void process_long_cabac(void);
 */
 #define AVS_DEBUG_PRINT         0x01
 #define AVS_DEBUG_UCODE         0x02
+#define AVS_DEBUG_OLD_ERROR_HANDLE	0x10
 #define AVS_DEBUG_USE_FULL_SPEED 0x80
 #define AEC_DUMP				0x100
 #define STREAM_INFO_DUMP		0x200
diff --git a/drivers/amlogic/amports/avsp_trans.c b/drivers/amlogic/amports/avsp_trans.c
index f9321fb..9b585b2 100644
--- a/drivers/amlogic/amports/avsp_trans.c
+++ b/drivers/amlogic/amports/avsp_trans.c
@@ -25,15 +25,18 @@
 #include "avs.h"
 #ifdef AVSP_LONG_CABAC
 
+#define DECODING_SANITY_CHECK
 
 #define TRACE 0
 #define LIWR_FIX 0
 #define pow2(a, b) (1<<b)
 #define io_printf pr_info
 
-unsigned char *local_heap_adr;
-int local_heap_size;
-int local_heap_pos;
+static unsigned char *local_heap_adr;
+static int local_heap_size;
+static int local_heap_pos;
+static int transcoding_error_flag;
+
 unsigned char *local_alloc(int num, int size)
 {
 	unsigned char *ret_buf = NULL;
@@ -3773,7 +3776,7 @@ void readdquant_aec(struct syntaxelement *se, struct img_par *img,
 				ctx->delta_qp_contexts + act_ctx, 1);
 		act_sym++;
 	}
-
+	act_sym &= 0x3f;
 	push_es(UE[act_sym][0], UE[act_sym][1]);
 
 	dquant = (act_sym + 1) / 2;
@@ -3791,6 +3794,7 @@ int csyntax;
 	if (img->qp+curr_mb->delta_quant > 63\
 			|| img->qp+curr_mb->delta_quant < 0) {\
 		csyntax = 0;\
+		transcoding_error_flag = 1;\
 		io_printf("error(0) (%3d|%3d) @ MB%d\n",\
 			curr_mb->delta_quant,\
 			img->qp+curr_mb->delta_quant,\
@@ -3837,10 +3841,19 @@ void readrunlevel_aec_ref(struct syntaxelement *se, struct img_par *img,
 		rank = 0;
 		pos = 0;
 		for (pairs = 0; pairs < 65; pairs++) {
+#ifdef DECODING_SANITY_CHECK
+			/*max index is NUM_BLOCK_TYPES - 1*/
+			pctx = primary[rank & 0x7];
+#else
 			pctx = primary[rank];
-
+#endif
 			if (rank > 0) {
+#ifdef DECODING_SANITY_CHECK
+				/*max index is NUM_BLOCK_TYPES - 1*/
+				pCTX2 = primary[(5 + (pos >> 5)) & 0x7];
+#else
 				pCTX2 = primary[5 + (pos >> 5)];
+#endif
 				ctx2 = (pos >> 1) & 0x0f;
 				ctx = 0;
 
@@ -4734,7 +4747,7 @@ int aec_startcode_follows(struct img_par *img, int eos_bit)
 }
 
 #ifdef AVSP_LONG_CABAC
-void process_long_cabac(void)
+int process_long_cabac(void)
 #else
 void main(void)
 #endif
@@ -4750,11 +4763,11 @@ void main(void)
 #ifdef PERFORMANCE_DEBUG
 	pr_info("enter %s\r\n", __func__);
 #endif
-
+	transcoding_error_flag = 0;
 	es_buf = es_write_addr_virt;
 
 	if (local_heap_init(MAX_CODED_FRAME_SIZE * 4) < 0)
-		return;
+		return -1;
 
 	img = (struct img_par *)local_alloc(1, sizeof(struct img_par));
 	if (img	== NULL)
@@ -4904,13 +4917,16 @@ void main(void)
 #ifdef AVSP_LONG_CABAC
 	push_es(0xff, 64);
 
+	if (transcoding_error_flag == 0) {
 #if 1
-	dma_sync_single_for_device(amports_get_dma_device(), es_write_addr_phy,
+		dma_sync_single_for_device(amports_get_dma_device(),
+			es_write_addr_phy,
 			es_ptr, DMA_TO_DEVICE);
 
-	wmb(); /**/
+		wmb(); /**/
 #endif
-	WRITE_VREG(LONG_CABAC_REQ, 0);
+		WRITE_VREG(LONG_CABAC_REQ, 0);
+	}
 #else
 	fclose(f_es);
 #endif
@@ -4919,6 +4935,6 @@ void main(void)
 #ifdef PERFORMANCE_DEBUG
 	pr_info("exit %s\r\n", __func__);
 #endif
-
+	return (transcoding_error_flag == 0) ? 0 : -1;
 }
 #endif
diff --git a/drivers/amlogic/amports/encoder.c b/drivers/amlogic/amports/encoder.c
index daf74e6..351477d 100644
--- a/drivers/amlogic/amports/encoder.c
+++ b/drivers/amlogic/amports/encoder.c
@@ -56,7 +56,7 @@
 #define AMVENC_CANVAS_INDEX 0xE4
 #define AMVENC_CANVAS_MAX_INDEX 0xEF
 
-#define MIN_SIZE 18
+#define MIN_SIZE 20
 #define DUMP_INFO_BYTES_PER_MB 80
 /* #define USE_OLD_DUMP_MC */
 
@@ -98,7 +98,7 @@ static u32 enable_dblk = 1;  /* 0 disable, 1 vdec 2 hdec */
 
 static u32 encode_print_level = LOG_DEBUG;
 static u32 no_timeout;
-static u32 nr_mode = -1;
+static int nr_mode = -1;
 
 static u32 me_mv_merge_ctl =
 	(0x1 << 31)  |  /* [31] me_merge_mv_en_16 */
@@ -294,6 +294,20 @@ static DEFINE_SPINLOCK(lock);
 #define v3_left_small_max_ie_sad 0x00
 #define v3_left_small_max_me_sad 0x40
 
+#define v5_use_small_diff_cnt 0
+#define v5_simple_mb_inter_all_en 1
+#define v5_simple_mb_inter_8x8_en 1
+#define v5_simple_mb_inter_16_8_en 1
+#define v5_simple_mb_inter_16x16_en 1
+#define v5_simple_mb_intra_en 1
+#define v5_simple_mb_C_en 0
+#define v5_simple_mb_Y_en 1
+#define v5_small_diff_Y 0x10
+#define v5_small_diff_C 0x18
+/* shift 8-bits, 2, 1, 0, -1, -2, -3, -4 */
+#define v5_simple_dq_setting 0x43210fed
+#define v5_simple_me_weight_setting 0
+
 #ifndef USE_OLD_DUMP_MC
 static u32 qp_table_pr;
 static u32 v3_mv_sad[64] = {
@@ -349,22 +363,22 @@ static u32 v3_mv_sad[64] = {
 	0x002e0030,
 	0x002f0050,
 	/* For step2 4x4-8x8 */
-	0x00300006,
-	0x0031000c,
-	0x0032000c,
-	0x00330018,
-	0x00340018,
-	0x00350018,
-	0x00360018,
-	0x00370030,
-	0x00380030,
-	0x00390030,
-	0x003a0030,
-	0x003b0030,
-	0x003c0030,
-	0x003d0030,
-	0x003e0030,
-	0x003f0050
+	0x00300001,
+	0x00310002,
+	0x00320002,
+	0x00330004,
+	0x00340004,
+	0x00350004,
+	0x00360004,
+	0x00370006,
+	0x00380006,
+	0x00390006,
+	0x003a0006,
+	0x003b0006,
+	0x003c0006,
+	0x003d0006,
+	0x003e0006,
+	0x003f0006
 };
 #endif
 
@@ -508,26 +522,26 @@ static struct BuffInfo_s amvenc_buffspec[] = {
 		},
 		.scale_buff = {
 			.buf_start = 0xf00000,
-			.buf_size = 0x200000,
+			.buf_size = 0x300000,
 		},
 		.inter_bits_info = {
-			.buf_start = 0x1100000,
+			.buf_start = 0x1200000,
 			.buf_size = 0x8000,
 		},
 		.inter_mv_info = {
-			.buf_start = 0xf08000,
+			.buf_start = 0x1208000,
 			.buf_size = 0x80000,
 		},
 		.intra_bits_info = {
-			.buf_start = 0x1188000,
+			.buf_start = 0x1288000,
 			.buf_size = 0x8000,
 		},
 		.intra_pred_info = {
-			.buf_start = 0x1190000,
+			.buf_start = 0x1290000,
 			.buf_size = 0x80000,
 		},
 		.qp_info = {
-			.buf_start = 0x1210000,
+			.buf_start = 0x1310000,
 			.buf_size = 0x8000,
 		}
 #ifdef USE_VDEC2
@@ -553,6 +567,7 @@ enum ucode_type_e {
 	UCODE_VDEC2,
 	UCODE_GX,
 	UCODE_GXTV,
+	UCODE_TXL,
 	UCODE_MAX
 };
 
@@ -569,6 +584,7 @@ const char *ucode_name[] = {
 	"vdec2_encoder_mc",
 	"h264_enc_mc_gx",
 	"h264_enc_mc_gxtv",
+	"h264_enc_mc_txl",
 };
 
 static void dma_flush(u32 buf_start, u32 buf_size);
@@ -579,7 +595,13 @@ static const char *select_ucode(u32 ucode_index)
 	enum ucode_type_e ucode = UCODE_DUMP;
 	switch (ucode_index) {
 	case UCODE_MODE_FULL:
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+#ifndef USE_OLD_DUMP_MC
+			ucode = UCODE_TXL;
+#else
+			ucode = UCODE_DUMP_GX_DBLK;
+#endif
+		} else if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
 #ifndef USE_OLD_DUMP_MC
 			ucode = UCODE_GXTV;
 #else
@@ -1101,7 +1123,7 @@ static void avc_init_ie_me_parameter(struct encode_wq_s *wq, u32 quant)
 
 static void mfdin_basic(u32 input, u8 iformat,
 			u8 oformat, u32 picsize_x, u32 picsize_y,
-			u8 r2y_en, u8 nr)
+			u8 r2y_en, u8 nr, u8 ifmt_extra)
 {
 	u8 dsample_en; /* Downsample Enable */
 	u8 interp_en;  /* Interpolation Enable */
@@ -1128,10 +1150,30 @@ static void mfdin_basic(u32 input, u8 iformat,
 	u32 linear_bytesperline;
 	s32 reg_offset;
 	bool linear_enable = false;
+	bool format_err = false;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		if ((iformat == 7) && (ifmt_extra > 2))
+			format_err = true;
+	} else if (iformat == 7)
+		format_err = true;
+
+	if (format_err) {
+		enc_pr(LOG_ERROR,
+			"mfdin format err, iformat:%d, ifmt_extra:%d\n",
+			iformat, ifmt_extra);
+		return;
+	}
+	if (iformat != 7)
+		ifmt_extra = 0;
 
 	ifmt444 = ((iformat == 1) || (iformat == 5) || (iformat == 8) ||
 		   (iformat == 9) || (iformat == 12)) ? 1 : 0;
+	if (iformat == 7 && ifmt_extra == 1)
+		ifmt444 = 1;
 	ifmt422 = ((iformat == 0) || (iformat == 10)) ? 1 : 0;
+	if (iformat == 7 && ifmt_extra != 1)
+		ifmt422 = 1;
 	ifmt420 = ((iformat == 2) || (iformat == 3) || (iformat == 4) ||
 		   (iformat == 11)) ? 1 : 0;
 	dsample_en = ((ifmt444 && (oformat != 2)) ||
@@ -1242,7 +1284,8 @@ static void mfdin_basic(u32 input, u8 iformat,
 			(iformat << 0) | (oformat << 4) |
 			(dsample_en << 6) | (y_size << 8) |
 			(interp_en << 9) | (r2y_en << 12) |
-			(r2y_mode << 13) | (nr_enable << 19));
+			(r2y_mode << 13) | (ifmt_extra << 16) |
+			(nr_enable << 19));
 		WRITE_HREG((HCODEC_MFDIN_REG8_DMBL + reg_offset),
 			(picsize_x << 14) | (picsize_y << 0));
 	} else {
@@ -1286,7 +1329,8 @@ static void mfdin_basic(u32 input, u8 iformat,
 #ifdef CONFIG_AM_GE2D
 static int scale_frame(struct encode_wq_s *wq,
 	struct encode_request_s *request,
-	struct config_para_ex_s *ge2d_config)
+	struct config_para_ex_s *ge2d_config,
+	u32 src_addr, bool canvas)
 {
 	struct ge2d_context_s *context = encode_manager.context;
 	int src_top, src_left, src_width, src_height;
@@ -1301,38 +1345,58 @@ static int scale_frame(struct encode_wq_s *wq,
 	src_left = request->crop_left;
 	src_width = request->src_w - src_left - request->crop_right;
 	src_height = request->src_h - src_top - request->crop_bottom;
-	if ((request->fmt == FMT_NV21) || (request->fmt == FMT_NV12)) {
-		src_canvas_w =  ((request->src_w + 31) >> 5) << 5;
-		canvas_config(ENC_CANVAS_OFFSET + 9,
-			wq->mem.dct_buff_start_addr,
-			src_canvas_w, src_h,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config(ENC_CANVAS_OFFSET + 10,
-			wq->mem.dct_buff_start_addr + src_canvas_w*src_h,
-			src_canvas_w , src_h / 2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		src_canvas = ((ENC_CANVAS_OFFSET + 10) << 8) |
-			(ENC_CANVAS_OFFSET + 9);
-		input_format =  GE2D_FORMAT_M24_NV21;
+	if (canvas) {
+		if ((request->fmt == FMT_NV21)
+			|| (request->fmt == FMT_NV12)) {
+			src_canvas = src_addr & 0xffff;
+			input_format = GE2D_FORMAT_M24_NV21;
+		} else {
+			src_canvas = src_addr & 0xffffff;
+			input_format = GE2D_FORMAT_M24_YUV420;
+		}
 	} else {
-		src_canvas_w =  ((request->src_w + 63) >> 6) << 6;
-		canvas_config(ENC_CANVAS_OFFSET + 9,
-			wq->mem.dct_buff_start_addr,
-			src_canvas_w, src_h,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config(ENC_CANVAS_OFFSET + 10,
-			wq->mem.dct_buff_start_addr + src_canvas_w*src_h,
-			src_canvas_w / 2, src_h / 2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config(ENC_CANVAS_OFFSET + 11,
-			wq->mem.dct_buff_start_addr +
-			src_canvas_w * src_h * 5 / 4,
-			src_canvas_w / 2 , src_h / 2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		src_canvas = ((ENC_CANVAS_OFFSET + 11) << 16) |
-			((ENC_CANVAS_OFFSET + 10) << 8) |
-			(ENC_CANVAS_OFFSET + 9);
-		input_format =  GE2D_FORMAT_M24_YUV420;
+		if ((request->fmt == FMT_NV21)
+			|| (request->fmt == FMT_NV12)) {
+			src_canvas_w =
+				((request->src_w + 31) >> 5) << 5;
+			canvas_config(ENC_CANVAS_OFFSET + 9,
+				src_addr,
+				src_canvas_w, src_h,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			canvas_config(ENC_CANVAS_OFFSET + 10,
+				src_addr + src_canvas_w * src_h,
+				src_canvas_w, src_h / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			src_canvas =
+				((ENC_CANVAS_OFFSET + 10) << 8)
+				| (ENC_CANVAS_OFFSET + 9);
+			input_format = GE2D_FORMAT_M24_NV21;
+		} else {
+			src_canvas_w =
+				((request->src_w + 63) >> 6) << 6;
+			canvas_config(ENC_CANVAS_OFFSET + 9,
+				src_addr,
+				src_canvas_w, src_h,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			canvas_config(ENC_CANVAS_OFFSET + 10,
+				src_addr + src_canvas_w * src_h,
+				src_canvas_w / 2, src_h / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			canvas_config(ENC_CANVAS_OFFSET + 11,
+				src_addr + src_canvas_w * src_h * 5 / 4,
+				src_canvas_w / 2, src_h / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			src_canvas =
+				((ENC_CANVAS_OFFSET + 11) << 16) |
+				((ENC_CANVAS_OFFSET + 10) << 8) |
+				(ENC_CANVAS_OFFSET + 9);
+			input_format = GE2D_FORMAT_M24_YUV420;
+		}
 	}
 	dst_canvas_w =  ((dst_w + 31) >> 5) << 5;
 	canvas_config(ENC_CANVAS_OFFSET + 6,
@@ -1340,8 +1404,8 @@ static int scale_frame(struct encode_wq_s *wq,
 		dst_canvas_w, dst_h,
 		CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
 	canvas_config(ENC_CANVAS_OFFSET + 7,
-		wq->mem.scaler_buff_start_addr + dst_canvas_w*dst_h,
-		dst_canvas_w , dst_h / 2,
+		wq->mem.scaler_buff_start_addr + dst_canvas_w * dst_h,
+		dst_canvas_w, dst_h / 2,
 		CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
 	dst_canvas = ((ENC_CANVAS_OFFSET + 7) << 8) |
 		(ENC_CANVAS_OFFSET + 6);
@@ -1351,7 +1415,7 @@ static int scale_frame(struct encode_wq_s *wq,
 	ge2d_config->dst_xy_swap = 0;
 	canvas_read(src_canvas & 0xff, &cs0);
 	canvas_read((src_canvas >> 8) & 0xff, &cs1);
-	canvas_read((src_canvas>>16) & 0xff, &cs2);
+	canvas_read((src_canvas >> 16) & 0xff, &cs2);
 	ge2d_config->src_planes[0].addr = cs0.addr;
 	ge2d_config->src_planes[0].w = cs0.width;
 	ge2d_config->src_planes[0].h = cs0.height;
@@ -1414,6 +1478,7 @@ static s32 set_input_format(struct encode_wq_s *wq,
 	u32 picsize_x, picsize_y;
 	u32 canvas_w = 0;
 	u32 input = request->src;
+	u8 ifmt_extra = 0;
 
 	if ((request->fmt == FMT_RGB565) || (request->fmt >= MAX_FRAME_FMT))
 		return -1;
@@ -1421,7 +1486,8 @@ static s32 set_input_format(struct encode_wq_s *wq,
 	picsize_x = ((wq->pic.encoder_width + 15) >> 4) << 4;
 	picsize_y = ((wq->pic.encoder_height + 15) >> 4) << 4;
 	oformat = 0;
-	if ((request->type == LOCAL_BUFF) || (request->type == PHYSICAL_BUFF)) {
+	if ((request->type == LOCAL_BUFF)
+		|| (request->type == PHYSICAL_BUFF)) {
 		if (request->type == LOCAL_BUFF) {
 			if (request->flush_flag & AMVENC_FLUSH_FLAG_INPUT)
 				dma_flush(wq->mem.dct_buff_start_addr,
@@ -1429,13 +1495,18 @@ static s32 set_input_format(struct encode_wq_s *wq,
 			if (request->scale_enable) {
 #ifdef CONFIG_AM_GE2D
 				struct config_para_ex_s ge2d_config;
+				u32 src_addr =
+					wq->mem.dct_buff_start_addr;
 				memset(&ge2d_config, 0,
 					sizeof(struct config_para_ex_s));
 				if (request->flush_flag &
 					AMVENC_FLUSH_FLAG_INPUT) {
 					int scale_size =
-						scale_frame(wq, request,
-							&ge2d_config);
+						scale_frame(
+							wq, request,
+							&ge2d_config,
+							src_addr,
+							false);
 					if (scale_size > 0)
 						cache_flush(
 						wq->mem.scaler_buff_start_addr,
@@ -1444,95 +1515,137 @@ static s32 set_input_format(struct encode_wq_s *wq,
 #else
 				enc_pr(LOG_ERROR,
 					"Warning: need enable ge2d for scale frame!\n");
+				return -1;
 #endif
 				iformat = 2;
 				r2y_en = 0;
 				input = ((ENC_CANVAS_OFFSET + 7) << 8) |
-						(ENC_CANVAS_OFFSET + 6);
+					(ENC_CANVAS_OFFSET + 6);
 				ret = 0;
 				goto MFDIN;
 			} else {
 				input = wq->mem.dct_buff_start_addr;
 			}
+		} else {
+			picsize_y = wq->pic.encoder_height;
+			if (request->scale_enable) {
+#ifdef CONFIG_AM_GE2D
+				struct config_para_ex_s ge2d_config;
+				memset(&ge2d_config, 0,
+					sizeof(struct config_para_ex_s));
+				scale_frame(
+					wq, request,
+					&ge2d_config,
+					input, false);
+				iformat = 2;
+				r2y_en = 0;
+				input = ((ENC_CANVAS_OFFSET + 7) << 8) |
+						(ENC_CANVAS_OFFSET + 6);
+				ret = 0;
+				goto MFDIN;
+#else
+				enc_pr(LOG_ERROR,
+					"Warning: need enable ge2d for scale frame!\n");
+				return -1;
+#endif
+			}
 		}
-		if (request->fmt <= FMT_YUV444_PLANE)
+		if ((request->fmt <= FMT_YUV444_PLANE) ||
+			(request->fmt >= FMT_YUV422_12BIT))
 			r2y_en = 0;
 		else
 			r2y_en = 1;
 
-		if (request->fmt == FMT_YUV422_SINGLE)
+		if (request->fmt >= FMT_YUV422_12BIT) {
+			iformat = 7;
+			ifmt_extra = request->fmt - FMT_YUV422_12BIT;
+			if (request->fmt == FMT_YUV422_12BIT)
+				canvas_w = picsize_x * 24 / 8;
+			else if (request->fmt == FMT_YUV444_10BIT)
+				canvas_w = picsize_x * 32 / 8;
+			else
+				canvas_w = (picsize_x * 20 + 7) / 8;
+			canvas_w = ((canvas_w + 31) >> 5) << 5;
+			canvas_config(ENC_CANVAS_OFFSET + 6,
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			input = ENC_CANVAS_OFFSET + 6;
+			input = input & 0xff;
+		} else if (request->fmt == FMT_YUV422_SINGLE)
 			iformat = 10;
-		else if ((request->fmt == FMT_YUV444_SINGLE) ||
-				(request->fmt == FMT_RGB888)) {
+		else if ((request->fmt == FMT_YUV444_SINGLE)
+			|| (request->fmt == FMT_RGB888)) {
 			iformat = 1;
 			if (request->fmt == FMT_RGB888)
 				r2y_en = 1;
 			canvas_w =  picsize_x * 3;
 			canvas_w = ((canvas_w + 31) >> 5) << 5;
 			canvas_config(ENC_CANVAS_OFFSET + 6,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ENC_CANVAS_OFFSET + 6;
-		} else if ((request->fmt == FMT_NV21) ||
-				(request->fmt == FMT_NV12)) {
+		} else if ((request->fmt == FMT_NV21)
+			|| (request->fmt == FMT_NV12)) {
 			canvas_w = ((wq->pic.encoder_width + 31) >> 5) << 5;
 			iformat = (request->fmt == FMT_NV21) ? 2 : 3;
 			canvas_config(ENC_CANVAS_OFFSET + 6,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 7,
-				      input + canvas_w * picsize_y,
-				      canvas_w, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y,
+				canvas_w, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 7) << 8) |
-					(ENC_CANVAS_OFFSET + 6);
+				(ENC_CANVAS_OFFSET + 6);
 		} else if (request->fmt == FMT_YUV420) {
 			iformat = 4;
 			canvas_w = ((wq->pic.encoder_width + 63) >> 6) << 6;
 			canvas_config(ENC_CANVAS_OFFSET + 6,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 7,
-				      input + canvas_w * picsize_y,
-				      canvas_w / 2, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y,
+				canvas_w / 2, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 8,
-				      input + canvas_w * picsize_y * 5 / 4,
-				      canvas_w / 2, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y * 5 / 4,
+				canvas_w / 2, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 8) << 16) |
 				((ENC_CANVAS_OFFSET + 7) << 8) |
 				(ENC_CANVAS_OFFSET + 6);
-		} else if ((request->fmt == FMT_YUV444_PLANE) ||
-			   (request->fmt == FMT_RGB888_PLANE)) {
+		} else if ((request->fmt == FMT_YUV444_PLANE)
+			|| (request->fmt == FMT_RGB888_PLANE)) {
 			if (request->fmt == FMT_RGB888_PLANE)
 				r2y_en = 1;
 			iformat = 5;
 			canvas_w = ((wq->pic.encoder_width + 31) >> 5) << 5;
 			canvas_config(ENC_CANVAS_OFFSET + 6,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 7,
-				      input + canvas_w * picsize_y,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 8,
-				      input + canvas_w * picsize_y * 2,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y * 2,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 8) << 16) |
 				((ENC_CANVAS_OFFSET + 7) << 8) |
 				(ENC_CANVAS_OFFSET + 6);
@@ -1543,34 +1656,61 @@ static s32 set_input_format(struct encode_wq_s *wq,
 		ret = 0;
 	} else if (request->type == CANVAS_BUFF) {
 		r2y_en = 0;
+		if (request->scale_enable) {
+#ifdef CONFIG_AM_GE2D
+			struct config_para_ex_s ge2d_config;
+			memset(&ge2d_config, 0,
+				sizeof(struct config_para_ex_s));
+				scale_frame(
+				wq, request,
+				&ge2d_config,
+				input, true);
+			iformat = 2;
+			r2y_en = 0;
+			input = ((ENC_CANVAS_OFFSET + 7) << 8) |
+				(ENC_CANVAS_OFFSET + 6);
+			ret = 0;
+			goto MFDIN;
+#else
+			enc_pr(LOG_ERROR,
+				"Warning: need enable ge2d for scale frame!\n");
+			return -1;
+#endif
+		}
 		if (request->fmt == FMT_YUV422_SINGLE) {
 			iformat = 0;
 			input = input & 0xff;
 		} else if (request->fmt == FMT_YUV444_SINGLE) {
 			iformat = 1;
 			input = input & 0xff;
-		} else if ((request->fmt == FMT_NV21) ||
-				(request->fmt == FMT_NV12)) {
+		} else if ((request->fmt == FMT_NV21)
+			|| (request->fmt == FMT_NV12)) {
 			iformat = (request->fmt == FMT_NV21) ? 2 : 3;
 			input = input & 0xffff;
 		} else if (request->fmt == FMT_YUV420) {
 			iformat = 4;
 			input = input & 0xffffff;
-		} else if ((request->fmt == FMT_YUV444_PLANE) ||
-			   (request->fmt == FMT_RGB888_PLANE)) {
+		} else if ((request->fmt == FMT_YUV444_PLANE)
+			|| (request->fmt == FMT_RGB888_PLANE)) {
 			if (request->fmt == FMT_RGB888_PLANE)
 				r2y_en = 1;
 			iformat = 5;
 			input = input & 0xffffff;
+		} else if ((request->fmt == FMT_YUV422_12BIT)
+			|| (request->fmt == FMT_YUV444_10BIT)
+			|| (request->fmt == FMT_YUV422_10BIT)) {
+			iformat = 7;
+			ifmt_extra = request->fmt - FMT_YUV422_12BIT;
+			input = input & 0xff;
 		} else
 			ret = -1;
 	}
 MFDIN:
 	if (ret == 0)
 		mfdin_basic(input, iformat, oformat,
-			    picsize_x, picsize_y, r2y_en,
-			    (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) ?
-				request->nr_mode : 0);
+			picsize_x, picsize_y, r2y_en,
+			(get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) ?
+			request->nr_mode : 0, ifmt_extra);
 	wq->control.finish = true;
 	return ret;
 }
@@ -2242,6 +2382,28 @@ static void avc_prot_init(struct encode_wq_s *wq,
 		WRITE_HREG(HCODEC_ME_SAD_RANGE_INC, me_sad_range_inc);
 
 #ifndef USE_OLD_DUMP_MC
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+			WRITE_HREG(HCODEC_V5_SIMPLE_MB_CTL, 0);
+			WRITE_HREG(HCODEC_V5_SIMPLE_MB_CTL,
+				(v5_use_small_diff_cnt << 7) |
+				(v5_simple_mb_inter_all_en << 6) |
+				(v5_simple_mb_inter_8x8_en << 5) |
+				(v5_simple_mb_inter_16_8_en << 4) |
+				(v5_simple_mb_inter_16x16_en << 3) |
+				(v5_simple_mb_intra_en << 2) |
+				(v5_simple_mb_C_en << 1) |
+				(v5_simple_mb_Y_en << 0));
+			WRITE_HREG(HCODEC_V5_MB_DIFF_SUM, 0);
+			WRITE_HREG(HCODEC_V5_SMALL_DIFF_CNT,
+				(v5_small_diff_C<<16) |
+				(v5_small_diff_Y<<0));
+			WRITE_HREG(HCODEC_V5_SIMPLE_MB_DQUANT,
+				v5_simple_dq_setting);
+			WRITE_HREG(HCODEC_V5_SIMPLE_MB_ME_WEIGHT,
+				v5_simple_me_weight_setting);
+			WRITE_HREG(HCODEC_QDCT_CONFIG, 1 << 0);
+		}
+
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
 			WRITE_HREG(HCODEC_V4_FORCE_SKIP_CFG,
 				(i_pic_qp << 26) | /* v4_force_q_r_intra */
@@ -3950,6 +4112,22 @@ Again:
 			}
 		} else {
 			manager->encode_hw_status = ENCODER_ERROR;
+			enc_pr(LOG_DEBUG, "avc encode light reset --- ");
+			enc_pr(LOG_DEBUG,
+				"frame type: %s, size: %dx%d, wq: %p\n",
+				(request->cmd == ENCODER_IDR) ? "IDR" : "P",
+				wq->pic.encoder_width,
+				wq->pic.encoder_height, (void *)wq);
+			enc_pr(LOG_DEBUG,
+				"mb info: 0x%x, encode status: 0x%x, dct status: 0x%x ",
+				READ_HREG(HCODEC_VLC_MB_INFO),
+				READ_HREG(ENCODER_STATUS),
+				READ_HREG(HCODEC_QDCT_STATUS_CTRL));
+			enc_pr(LOG_DEBUG,
+				"vlc status: 0x%x, me status: 0x%x, risc pc:0x%x\n",
+				READ_HREG(HCODEC_VLC_STATUS_CTRL),
+				READ_HREG(HCODEC_ME_STATUS),
+				READ_HREG(HCODEC_MPC_E));
 			amvenc_avc_light_reset(wq, 30);
 		}
 	}
@@ -4796,7 +4974,7 @@ MODULE_PARM_DESC(encode_print_level, "\n encode_print_level\n");
 module_param(no_timeout, uint, 0664);
 MODULE_PARM_DESC(no_timeout, "\n no_timeout flag for process request\n");
 
-module_param(nr_mode, uint, 0664);
+module_param(nr_mode, int, 0664);
 MODULE_PARM_DESC(nr_mode, "\n nr_mode option\n");
 
 module_param(y_tnr_mc_en, uint, 0664);
diff --git a/drivers/amlogic/amports/encoder.h b/drivers/amlogic/amports/encoder.h
index ab00214..db01573 100644
--- a/drivers/amlogic/amports/encoder.h
+++ b/drivers/amlogic/amports/encoder.h
@@ -153,6 +153,9 @@ enum amvenc_frame_fmt_e {
 	FMT_RGB888_PLANE,
 	FMT_RGB565,
 	FMT_RGBA8888,
+	FMT_YUV422_12BIT,
+	FMT_YUV444_10BIT,
+	FMT_YUV422_10BIT,
 	MAX_FRAME_FMT
 };
 
diff --git a/drivers/amlogic/amports/esparser.c b/drivers/amlogic/amports/esparser.c
index b8f059d..aab12b1 100644
--- a/drivers/amlogic/amports/esparser.c
+++ b/drivers/amlogic/amports/esparser.c
@@ -559,12 +559,13 @@ s32 esparser_init(struct stream_buf_s *buf)
 		int block_size = (buf->type == BUF_TYPE_AUDIO) ?
 			PAGE_SIZE << 2 : PAGE_SIZE << 4;
 		int buf_num = (buf->type == BUF_TYPE_AUDIO) ?
-			5 : 5;
-		if (!(buf->type == BUF_TYPE_SUBTITLE) &&
-			!(buf->type == BUF_TYPE_AUDIO)) /*for audio manual*/
+			5 : 10;
+		if (!(buf->type == BUF_TYPE_SUBTITLE))
 			buf->write_thread = threadrw_alloc(buf_num,
 				block_size,
-				esparser_write_ex);
+				esparser_write_ex,
+			(buf->type == BUF_TYPE_AUDIO) ? 1 : 0);
+			/*manul mode for audio*/
 	}
 	return 0;
 
diff --git a/drivers/amlogic/amports/jpegdec.c b/drivers/amlogic/amports/jpegdec.c
index 37dbbc8..2a7b3a1 100644
--- a/drivers/amlogic/amports/jpegdec.c
+++ b/drivers/amlogic/amports/jpegdec.c
@@ -27,24 +27,28 @@
 #include <linux/slab.h>
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
-/* #include <mach/am_regs.h> */
-#include <plat/io.h>
 
 #include <linux/amlogic/amports/jpegdec.h>
-#include <linux/amlogic/amports/canvas.h>
-
+#include <linux/amlogic/canvas/canvas.h>
 #include <linux/uaccess.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/dma-contiguous.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+
 
 #include "amvdec.h"
 #include "streambuf.h"
 #include "vdec_reg.h"
 #include "amports_priv.h"
+/* #include "jpegdec_mc.h" */
 
 #define DEVICE_NAME "amjpegdec"
 #define DRIVER_NAME "amjpegdec"
 #define MODULE_NAME "amjpegdec"
 
 /* #define DEBUG */
+#define JPEGDEC_CANVAS_INDEX   0
 
 #define JPEGDEC_OUTPUT_CANVAS_Y (JPEGDEC_CANVAS_INDEX)
 #define JPEGDEC_OUTPUT_CANVAS_U (JPEGDEC_CANVAS_INDEX+1)
@@ -73,6 +77,8 @@
 #define JPEG_MCU_CROP_VSTART    PSCALE_PICO_W
 #define JPEG_MCU_CROP_VEND      PSCALE_PICO_H
 
+#define CMA_ALLOC_SIZE 10
+
 #ifdef DEBUG
 #define pr_dbg(fmt, args...) pr_info(KERN_DEBUG "amjpegdec: " fmt, ## args)
 #else
@@ -81,8 +87,8 @@
 #define pr_error(fmt, args...) pr_err(KERN_ERR "amjpegdec: " fmt, ## args)
 
 struct jpegdec_s {
-	jpegdec_config_t conf;
-	jpegdec_info_t info;
+	struct jpegdec_config_s conf;
+	struct jpegdec_info_s info;
 	unsigned state;
 };
 
@@ -94,10 +100,11 @@ static DEFINE_MUTEX(jpegdec_module_mutex);
 static struct jpegdec_s *dec;
 static unsigned long pbufAddr;
 static unsigned long pbufSize;
-static jpegdec_mem_info_t jegdec_mem_info;
+static struct jpegdec_mem_info_s jegdec_mem_info;
 
 static irqreturn_t jpegdec_isr(int irq, void *dev_id)
 {
+
 	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
 
 	if ((dec->state & JPEGDEC_STAT_INFO_READY) == 0) {
@@ -138,12 +145,12 @@ static int _init_dec(struct jpegdec_s *d)
 
 	amvdec_enable();
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	WRITE_VREG(DOS_SW_RESET0, (1 << 11));
-	WRITE_VREG(DOS_SW_RESET0, 0);
-#else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU);
-#endif
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
+		WRITE_VREG(DOS_SW_RESET0, (1 << 11));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+	} else {
+		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU);
+	}
 
 	WRITE_VREG(ASSIST_AMR1_INT0, 0x1);
 	WRITE_VREG(ASSIST_AMR1_INT1, 0xf);
@@ -153,26 +160,28 @@ static int _init_dec(struct jpegdec_s *d)
 	WRITE_VREG(ASSIST_AMR1_INT5, 0x9);
 	WRITE_VREG(ASSIST_AMR1_INT6, 0x4);
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	WRITE_VREG(DOS_SW_RESET0, (1 << 11) | (1 << 7) | (1 << 6));
-	WRITE_VREG(DOS_SW_RESET0, 0);
-#else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU | RESET_IQIDCT | RESET_MC);
-#endif
-
-	if (amvdec_loadmc(jpegdec_mc) < 0) {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
+		WRITE_VREG(DOS_SW_RESET0, (1 << 11) | (1 << 7) | (1 << 6));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+	} else {
+		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU |
+			RESET_IQIDCT | RESET_MC);
+	}
+	if (amvdec_loadmc_ex(VFORMAT_JPEG, "jpegdec_mc", NULL) < 0) {
 		amvdec_disable();
 
 		pr_error("jpegdec ucode loading failed.\n");
 		return -EBUSY;
 	}
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	WRITE_VREG(DOS_SW_RESET0, (1 << 11) | (1 << 10) | (1 << 7) | (1 << 6));
-	WRITE_VREG(DOS_SW_RESET0, 0);
-#else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU | RESET_IQIDCT | RESET_MC);
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
-#endif
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
+		WRITE_VREG(DOS_SW_RESET0, (1 << 11) | (1 << 10) |
+			(1 << 7) | (1 << 6));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+	} else {
+		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU |
+			RESET_IQIDCT | RESET_MC);
+		WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
+	}
 	WRITE_VREG(PSCALE_RST, 0x7);
 	WRITE_VREG(PSCALE_RST, 0x0);
 
@@ -396,7 +405,7 @@ static int amjpegdec_open(struct inode *inode, struct file *file)
 	if (dec != NULL)
 		r = -EBUSY;
 
-	dec = kcalloc(1, sizeof(struct jpegdec_s);
+	dec = kcalloc(1, sizeof(struct jpegdec_s), GFP_KERNEL);
 	if (dec == NULL)
 		r = -ENOMEM;
 
@@ -425,17 +434,26 @@ static int amjpegdec_release(struct inode *inode, struct file *file)
 
 	amvdec_disable();
 
+	if (pbufAddr) {
+		codec_mm_free_for_dma(
+			"jpegdec",
+			pbufAddr);
+		pbufAddr = 0;
+		pbufSize = 0;
+		pr_info("jpegdec cma memory release succeed\n");
+	}
 	return 0;
 }
 
 static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 {
 	int r = 0;
+	void __user *argp;
+	argp = (void __user *)arg;
 
 	switch (cmd) {
 	case JPEGDEC_IOC_INFOCONFIG:
 		if (dec->state & JPEGDEC_STAT_WAIT_INFOCONFIG) {
-			pr_dbg("amjpegdec_ioctl:  JPEGDEC_IOC_INFOCONFIG\n");
 
 			dec->conf.opt |= arg & (JPEGDEC_OPT_THUMBNAIL_ONLY |
 				JPEGDEC_OPT_THUMBNAIL_PREFERED);
@@ -446,16 +464,65 @@ static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 
 			dec->state &= ~JPEGDEC_STAT_WAIT_INFOCONFIG;
 			dec->state |= JPEGDEC_STAT_WAIT_DATA;
-
 			amvdec_start();
 		} else
 			r = -EPERM;
 		break;
+	case JPEGDEC_IOC_DECCONFIG32:
+		if (dec->state & JPEGDEC_STAT_WAIT_DECCONFIG) {
+			ulong paddr_y, paddr_u, paddr_v , r;
+			struct compat_jpegdec_config_s __user *uf =
+				(struct compat_jpegdec_config_s *)argp;
+			memset(&dec->conf, 0, sizeof(struct jpegdec_config_s));
+			r = get_user(paddr_y, &uf->addr_y);
+			dec->conf.addr_y = paddr_y;
+			r |= get_user(paddr_u, &uf->addr_u);
+			dec->conf.addr_u = paddr_u;
+			r |= get_user(paddr_v, &uf->addr_v);
+			dec->conf.addr_v = paddr_v;
+			r |= get_user(dec->conf.canvas_width,
+				&uf->canvas_width);
+			r |= get_user(dec->conf.opt, &uf->opt);
+			r |= get_user(dec->conf.src_crop_x, &uf->src_crop_x);
+			r |= get_user(dec->conf.src_crop_y, &uf->src_crop_y);
+			r |= get_user(dec->conf.src_crop_w, &uf->src_crop_w);
+			r |= get_user(dec->conf.src_crop_h, &uf->src_crop_h);
+			r |= get_user(dec->conf.dec_x, &uf->dec_x);
+			r |= get_user(dec->conf.dec_y, &uf->dec_y);
+			r |= get_user(dec->conf.dec_w, &uf->dec_w);
+			r |= get_user(dec->conf.dec_h, &uf->dec_h);
+			r |= get_user(dec->conf.angle, &uf->angle);
+			if (r) {
+				pr_err("JPEGDEC_IOC_DECCONFIG32 get parameter failed .\n");
+				return -EFAULT;
+			}
+			pr_dbg("amjpegdec_ioctl:config,target (%d-%d-%d-%d)\n",
+				dec->conf.dec_x, dec->conf.dec_y,
+				dec->conf.dec_w, dec->conf.dec_h);
+			pr_dbg("planes (0x%lx-0x%lx-0x%lx), pbufAddr=0x%lx\n",
+				dec->conf.addr_y, dec->conf.addr_u,
+				dec->conf.addr_v, pbufAddr);
+
+			if ((dec->conf.angle & 1) == 0) {
+				if ((dec->conf.dec_w > dec->info.width) ||
+					(dec->conf.dec_h > dec->info.height))
+					return -EPERM;
+
+			} else {
+				if ((dec->conf.dec_w > dec->info.height) ||
+					(dec->conf.dec_h > dec->info.width))
+					return -EPERM;
+			}
 
+			dec->state &= ~JPEGDEC_STAT_WAIT_DECCONFIG;
+			_dec_run();
+		} else
+			r = -EPERM;
+		break;
 	case JPEGDEC_IOC_DECCONFIG:
 		if (dec->state & JPEGDEC_STAT_WAIT_DECCONFIG) {
 			if (copy_from_user(&dec->conf,
-				(void *)arg, sizeof(jpegdec_config_t)))
+				(void *)arg, sizeof(struct jpegdec_config_s)))
 				return -EFAULT;
 
 			pr_dbg("amjpegdec_ioctl:config,target (%d-%d-%d-%d)\n",
@@ -490,7 +557,7 @@ static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 				dec->info.width,
 				dec->info.height);
 			if (copy_to_user((void *)arg, &dec->info,
-					sizeof(jpegdec_info_t)))
+					sizeof(struct jpegdec_info_s)))
 				return -EFAULT;
 		} else
 			r = -EAGAIN;
@@ -500,7 +567,7 @@ static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 		return dec->state;
 	case JPEGDEC_G_MEM_INFO:
 		if (copy_from_user(&jegdec_mem_info, (void __user *)arg,
-						   sizeof(jpegdec_mem_info_t)))
+				   sizeof(struct jpegdec_mem_info_s)))
 			r = -EFAULT;
 		else {
 			unsigned pscaleCanvasbwidth =
@@ -514,7 +581,7 @@ static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 				pbufSize - pscaleCanvasbwidth;
 
 			if (copy_to_user((void __user *)arg, &jegdec_mem_info,
-						sizeof(jpegdec_mem_info_t)))
+					sizeof(struct jpegdec_mem_info_s)))
 				r = -EFAULT;
 		}
 		break;
@@ -546,44 +613,65 @@ static int mmap(struct file *filp, struct vm_area_struct *vma)
 
 }
 
+#ifdef CONFIG_COMPAT
+static long amjpegdec_compat_ioctl(struct file *filp,
+			      unsigned int cmd, unsigned long args)
+{
+	unsigned long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = amjpegdec_ioctl(filp, cmd, args);
+
+	return ret;
+}
+#endif
+
 static const struct file_operations amjpegdec_fops = {
 	.owner = THIS_MODULE,
 	.open = amjpegdec_open,
 	.mmap = mmap,
 	.release = amjpegdec_release,
 	.unlocked_ioctl = amjpegdec_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = amjpegdec_compat_ioctl,
+#endif
 };
 
 int AMHWJPEGDEC_MAJOR = 0;
 static int amjpegdec_probe(struct platform_device *pdev)
 {
 	int r;
+	int flags;
 
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
-
-	if (pdata == NULL) {
-		pr_info("amjpegdec memory resource undefined.\n");
-		return -EFAULT;
-	}
-
+	pr_dbg(" register amjpegdec .\n");
 	AMHWJPEGDEC_MAJOR = 0;
-	r = register_chrdev(AMHWJPEGDEC_MAJOR, "amjpegdev", &amjpegdec_fops);
+	r = register_chrdev(AMHWJPEGDEC_MAJOR, "amjpegdec", &amjpegdec_fops);
 
 	if (r < 0) {
 		pr_err("Can't register major for amjpegdec device\n");
 		return r;
 	}
 	AMHWJPEGDEC_MAJOR = r;
-
 	amjpegdec_class = class_create(THIS_MODULE, DEVICE_NAME);
 
 	amjpegdec_dev = device_create(amjpegdec_class, NULL,
 					MKDEV(AMHWJPEGDEC_MAJOR, 0),
 					NULL, DEVICE_NAME);
-	pbufAddr = pdata->mem_start;
-	pbufSize = pdata->mem_end - pdata->mem_start + 1;
 
+	flags = CODEC_MM_FLAGS_DMA_CPU|CODEC_MM_FLAGS_CMA_CLEAR;
+
+	pbufAddr = codec_mm_alloc_for_dma(
+					"jpegdec",
+					(CMA_ALLOC_SIZE*SZ_1M)/PAGE_SIZE,
+					0, flags);
+	if (!pbufAddr) {
+		pr_err("jpegdec alloc cma buffer failed\n");
+		return -1;
+	} else {
+		pbufSize = (CMA_ALLOC_SIZE*SZ_1M);
+	}
+	pr_info("jpegdec cma memory is %lx , size is  %lx\n" ,
+		pbufAddr , pbufSize);
 	return 0;
 }
 
@@ -598,19 +686,28 @@ static int amjpegdec_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id amlogic_amjpegdec_dt_match[] = {
+	{
+		.compatible = "amlogic, amjpegdec",
+	},
+	{},
+};
+
 static struct platform_driver amjpegdec_driver = {
 	.probe = amjpegdec_probe,
 	.remove = amjpegdec_remove,
 	.driver = {
 		.name = "amjpegdec",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_amjpegdec_dt_match,
 	}
 };
 
 static int __init amjpegdec_init(void)
 {
 	if (platform_driver_register(&amjpegdec_driver)) {
-		pr_error("failed to register amjpegdec module\n");
-		return -ENODEV;
+		pr_err("failed to register amjpegdec module\n");
+		return -ENOENT;
 	}
 
 	return 0;
diff --git a/drivers/amlogic/amports/jpegenc.c b/drivers/amlogic/amports/jpegenc.c
index 12a8331..dc67045 100644
--- a/drivers/amlogic/amports/jpegenc.c
+++ b/drivers/amlogic/amports/jpegenc.c
@@ -2253,8 +2253,9 @@ static void jpegenc_buffspec_init(struct jpegenc_wq_s *wq)
 #define HCODEC_MFDIN_REG15			(HCODEC_MFDIN_REGB_AMPC + 0xa)
 #define HCODEC_MFDIN_REG16			(HCODEC_MFDIN_REGB_AMPC + 0xb)
 
-static void mfdin_basic_jpeg(u32 input, u8 iformat,
-	u8 oformat, u32 picsize_x, u32 picsize_y, u8 r2y_en)
+static void mfdin_basic_jpeg(
+	u32 input, u8 iformat, u8 oformat, u32 picsize_x,
+	u32 picsize_y, u8 r2y_en, u8 ifmt_extra)
 {
 	u8 dsample_en; /* Downsample Enable */
 	u8 interp_en; /* Interpolation Enable */
@@ -2276,10 +2277,30 @@ static void mfdin_basic_jpeg(u32 input, u8 iformat,
 	u32 linear_bytesperline;
 	bool linear_enable = false;
 	s32 reg_offset;
+	bool format_err = false;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		if ((iformat == 7) && (ifmt_extra > 2))
+			format_err = true;
+	} else if (iformat == 7)
+		format_err = true;
+
+	if (format_err) {
+		jenc_pr(LOG_ERROR,
+			"mfdin format err, iformat:%d, ifmt_extra:%d\n",
+			iformat, ifmt_extra);
+		return;
+	}
+	if (iformat != 7)
+		ifmt_extra = 0;
 
 	ifmt444 = ((iformat == 1) || (iformat == 5) || (iformat == 8)
 		|| (iformat == 9) || (iformat == 12)) ? 1 : 0;
+	if (iformat == 7 && ifmt_extra == 1)
+		ifmt444 = 1;
 	ifmt422 = ((iformat == 0) || (iformat == 10)) ? 1 : 0;
+	if (iformat == 7 && ifmt_extra != 1)
+		ifmt422 = 1;
 	ifmt420 = ((iformat == 2) || (iformat == 3) || (iformat == 4)
 		|| (iformat == 11)) ? 1 : 0;
 	dsample_en = ((ifmt444 && (oformat != 2))
@@ -2322,7 +2343,8 @@ static void mfdin_basic_jpeg(u32 input, u8 iformat,
 		(iformat << 0) | (oformat << 4) |
 		(dsample_en << 6) | (y_size << 8) |
 		(interp_en << 9) | (r2y_en << 12) |
-		(r2y_mode << 13) | (2 << 29));
+		(r2y_mode << 13) | (ifmt_extra << 16) |
+		(2 << 29));
 
 	if (linear_enable == false) {
 		WRITE_HREG((HCODEC_MFDIN_REG3_CANV + reg_offset),
@@ -2362,6 +2384,7 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 	u32 picsize_x, picsize_y;
 	u32 canvas_w = 0;
 	u32 input = cmd->src;
+	u8 ifmt_extra = 0;
 
 	jenc_pr(LOG_INFO, "************begin set input format**************\n");
 	jenc_pr(LOG_INFO, "type is %d\n", cmd->type);
@@ -2392,12 +2415,31 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 					cmd->framesize);
 			input = wq->InputBuffStart;
 		}
-		if (cmd->input_fmt <= JPEGENC_FMT_YUV444_PLANE)
+		if ((cmd->input_fmt <= JPEGENC_FMT_YUV444_PLANE) ||
+			(cmd->input_fmt >= JPEGENC_FMT_YUV422_12BIT))
 			r2y_en = 0;
 		else
 			r2y_en = 1;
 
-		if (cmd->input_fmt == JPEGENC_FMT_YUV422_SINGLE) {
+		if (cmd->input_fmt >= JPEGENC_FMT_YUV422_12BIT) {
+			iformat = 7;
+			ifmt_extra =
+				cmd->input_fmt - JPEGENC_FMT_YUV422_12BIT;
+			if (cmd->input_fmt == JPEGENC_FMT_YUV422_12BIT)
+				canvas_w = picsize_x * 24 / 8;
+			else if (cmd->input_fmt == JPEGENC_FMT_YUV444_10BIT)
+				canvas_w = picsize_x * 32 / 8;
+			else
+				canvas_w = (picsize_x * 20 + 7) / 8;
+			canvas_w = ((canvas_w + 31) >> 5) << 5;
+			canvas_config(ENC_CANVAS_OFFSET,
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			input = ENC_CANVAS_OFFSET;
+			input = input & 0xff;
+		} else if (cmd->input_fmt == JPEGENC_FMT_YUV422_SINGLE) {
 			iformat = 0;
 			canvas_w = picsize_x * 2;
 			canvas_w = ((canvas_w + 31) >> 5) << 5;
@@ -2439,20 +2481,20 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 			iformat = 4;
 			canvas_w = ((cmd->encoder_width + 63) >> 6) << 6;
 			canvas_config(ENC_CANVAS_OFFSET,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 2,
-				      input + canvas_w * picsize_y,
-				      canvas_w / 2, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y,
+				canvas_w / 2, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 2,
-				      input + canvas_w * picsize_y * 5 / 4,
-				      canvas_w / 2, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y * 5 / 4,
+				canvas_w / 2, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 2) << 16) |
 				((ENC_CANVAS_OFFSET + 1) << 8) |
 				ENC_CANVAS_OFFSET;
@@ -2463,18 +2505,18 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 				r2y_en = 1;
 			canvas_w = ((cmd->encoder_width + 31) >> 5) << 5;
 			canvas_config(ENC_CANVAS_OFFSET,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 1,
-				      input + canvas_w * picsize_y, canvas_w,
-				      picsize_y, CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y, canvas_w,
+				picsize_y, CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 2,
-				      input + canvas_w * picsize_y * 2,
-				      canvas_w, picsize_y, CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y * 2,
+				canvas_w, picsize_y, CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 2) << 16) |
 				((ENC_CANVAS_OFFSET + 1) << 8) |
 				ENC_CANVAS_OFFSET;
@@ -2504,12 +2546,18 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 				r2y_en = 1;
 			iformat = 5;
 			input = input & 0xffffff;
+		} else if ((cmd->input_fmt == JPEGENC_FMT_YUV422_12BIT)
+			|| (cmd->input_fmt == JPEGENC_FMT_YUV444_10BIT)
+			|| (cmd->input_fmt == JPEGENC_FMT_YUV422_10BIT)) {
+			iformat = 7;
+			ifmt_extra = cmd->input_fmt - JPEGENC_FMT_YUV422_12BIT;
+			input = input & 0xff;
 		} else
 			ret = -1;
 	}
 	if (ret == 0)
 		mfdin_basic_jpeg(input, iformat, oformat,
-			picsize_x, picsize_y, r2y_en);
+			picsize_x, picsize_y, r2y_en, ifmt_extra);
 	return ret;
 }
 
diff --git a/drivers/amlogic/amports/jpegenc.h b/drivers/amlogic/amports/jpegenc.h
index 4749e56..0d86f7b 100644
--- a/drivers/amlogic/amports/jpegenc.h
+++ b/drivers/amlogic/amports/jpegenc.h
@@ -122,6 +122,9 @@ enum jpegenc_frame_fmt_e {
 	JPEGENC_FMT_RGB888_PLANE,
 	JPEGENC_FMT_RGB565,
 	JPEGENC_FMT_RGBA8888,
+	JPEGENC_FMT_YUV422_12BIT,
+	JPEGENC_FMT_YUV444_10BIT,
+	JPEGENC_FMT_YUV422_10BIT,
 	JPEGENC_MAX_FRAME_FMT
 };
 
diff --git a/drivers/amlogic/amports/thread_rw.c b/drivers/amlogic/amports/thread_rw.c
index 60ff106..7b142f6 100644
--- a/drivers/amlogic/amports/thread_rw.c
+++ b/drivers/amlogic/amports/thread_rw.c
@@ -63,6 +63,7 @@ struct threadrw_write_task {
 	int data_offset;
 	int writework_on;
 	unsigned long codec_mm_buffer;
+	int manual_write;
 	wait_queue_head_t wq;
 	ssize_t (*write)(struct file *,
 		struct stream_buf_s *,
@@ -205,11 +206,17 @@ static int do_write_work_in(struct threadrw_write_task *task)
 		codec_mm_dma_flush(rwbuf->vbuffer,
 				rwbuf->data_size,
 				DMA_TO_DEVICE);
-
-	ret = task->write(task->file, task->sbuf,
+	if (task->manual_write) {
+		ret = task->write(task->file, task->sbuf,
+			(const char __user *)rwbuf->vbuffer + rwbuf->write_off,
+			rwbuf->data_size,
+			2);	/* noblock,virtual addr */
+	} else {
+		ret = task->write(task->file, task->sbuf,
 		(const char __user *)rwbuf->dma_handle + rwbuf->write_off,
 		rwbuf->data_size,
 		3);	/* noblock,phy addr */
+	}
 	if (ret == -EAGAIN) {
 		need_re_write = 0;
 		/*do later retry. */
@@ -330,7 +337,8 @@ static struct threadrw_write_task *threadrw_buf_alloc_in(int num,
 		int block_size,
 		ssize_t (*write)(struct file *,
 			struct stream_buf_s *,
-			const char __user *, size_t, int))
+			const char __user *, size_t, int),
+			int flags)
 {
 	int task_buffer_size = sizeof(struct threadrw_write_task) +
 				sizeof(struct threadrw_buf) * (num - 1) + 4;
@@ -353,6 +361,7 @@ static struct threadrw_write_task *threadrw_buf_alloc_in(int num,
 	task->write = write;
 	task->file = NULL;
 	task->buffer_size = 0;
+	task->manual_write = flags & 1;
 	ret = init_task_buffers(task, num, block_size);
 	if (ret < 0)
 		goto err3;
@@ -460,9 +469,10 @@ void *threadrw_alloc(int num,
 			ssize_t (*write)(struct file *,
 				struct stream_buf_s *,
 				const char __user *,
-				size_t, int))
+				size_t, int),
+				int flags)
 {
-	return threadrw_buf_alloc_in(num, block_size, write);
+	return threadrw_buf_alloc_in(num, block_size, write, flags);
 }
 
 void threadrw_release(struct stream_buf_s *stbuf)
diff --git a/drivers/amlogic/amports/thread_rw.h b/drivers/amlogic/amports/thread_rw.h
index 23e9b22..df7d4f3 100644
--- a/drivers/amlogic/amports/thread_rw.h
+++ b/drivers/amlogic/amports/thread_rw.h
@@ -13,9 +13,11 @@ ssize_t threadrw_write(struct file *file,
 void *threadrw_alloc(int num,
 		int block_size,
 			ssize_t (*write)(struct file *,
-					struct stream_buf_s *,
-					const char __user *,
-					size_t, int));
+				struct stream_buf_s *,
+				const char __user *,
+				size_t, int),
+				int flags);/*flags &1: manual mode*/
+
 void threadrw_release(struct stream_buf_s *stbuf);
 
 int threadrw_buffer_level(struct stream_buf_s *stbuf);
diff --git a/drivers/amlogic/amports/tsync_pcr.c b/drivers/amlogic/amports/tsync_pcr.c
index 33aabfe..b08738f 100644
--- a/drivers/amlogic/amports/tsync_pcr.c
+++ b/drivers/amlogic/amports/tsync_pcr.c
@@ -189,6 +189,9 @@ static u8 tsync_pcr_usepcr = 1;
 static u64 first_time_record;
 static u8 wait_pcr_count;
 
+static int abuf_fatal_error;
+static int vbuf_fatal_error;
+
 static DEFINE_SPINLOCK(tsync_pcr_lock);
 
 #define LTRACE() pr_info("[%s:%d]\n", __func__, __LINE__);
@@ -786,6 +789,37 @@ static unsigned long tsync_pcr_check(void)
 	vbuf_level = get_stream_buffer_level(0);
 	vbuf_size = get_stream_buffer_size(0);
 
+	/***********************************************************
+	 On S905/S905X Platform, when we play avs video file on dtv
+	 which contian long cabac   some time it will cause amstream
+	 video buffer enter an error status. vbuf_level will over  vbuf_size,
+	 this will cause a lot of print in this function. And that will
+	 prevent reset ts monitor work thread from getting cpu control
+	 and to reset ts module. So we add the following  code to avoid
+	 this case.
+
+	       Rong.Zhang@amlogic.com    2016-08-10
+	***********************************************************/
+	if (abuf_level > abuf_size) {
+		if (!abuf_fatal_error) {
+			abuf_fatal_error = 1;
+			pr_info("amstream must be some fatal error for audio and wait for reset\n");
+			pr_info("abuf_level = 0x%x, abuf_size = 0x%x, vbuf_level = 0x%x, vbuf_size = 0x%x\n",
+				abuf_level, abuf_size, vbuf_level, vbuf_size);
+		}
+		return res;
+	}
+
+	if (vbuf_level > vbuf_size) {
+		if (!vbuf_fatal_error) {
+			vbuf_fatal_error = 1;
+			pr_info("amstream must be some fatal error for video and wait for reset\n");
+			pr_info("abuf_level = 0x%x, abuf_size = 0x%x, vbuf_level = 0x%x, vbuf_size = 0x%x\n",
+				abuf_level, abuf_size, vbuf_level, vbuf_size);
+		}
+		return res;
+	}
+
 	last_checkin_vpts = (u32) get_last_checkin_pts(PTS_TYPE_VIDEO);
 	last_checkin_apts = (u32) get_last_checkin_pts(PTS_TYPE_AUDIO);
 	last_cur_pcr = timestamp_pcrscr_get();
@@ -899,6 +933,7 @@ static unsigned long tsync_pcr_check(void)
 		|| (abuf_level * 3 > abuf_size * 2 && abuf_size > 0))
 		&& play_mode != PLAY_MODE_FORCE_SPEED) {
 		/* the stream buffer have too much data. speed out */
+#if 0
 		pr_info
 		("[tsync_pcr_check]Buffer will overflow and speed play. ");
 
@@ -906,6 +941,16 @@ static unsigned long tsync_pcr_check(void)
 		("vlevel=%x,vsize=%x\n", vbuf_level, vbuf_size);
 		pr_info("alevel=%x asize=%x play_mode=%d\n",
 			abuf_level, abuf_size, play_mode);
+#else
+		if (vbuf_level * 3 > vbuf_size * 2 && vbuf_size > 0) {
+			pr_info("vbuf > 2/3 %x %x mode=%d\n",
+				vbuf_level, vbuf_size, play_mode);
+		}
+		if (abuf_level * 3 > abuf_size * 2 && abuf_size > 0) {
+			pr_info("abuf > 2/3 %x %x mode=%d\n",
+				abuf_level, abuf_size, play_mode);
+		}
+#endif
 		play_mode = PLAY_MODE_FORCE_SPEED;
 	} else if ((vbuf_level * 5 > vbuf_size * 4 && vbuf_size > 0)
 		|| (abuf_level * 5 > abuf_size * 4 && abuf_size > 0)) {
@@ -919,12 +964,23 @@ static unsigned long tsync_pcr_check(void)
 			 __func__, timestamp_pcrscr_get(), new_pcr);
 		}
 		timestamp_pcrscr_set(new_pcr);
+#if 0
 		pr_info
 		("[tsync_pcr_check]Buffer will overflow and speed play. ");
 		pr_info("new_pcr=%x vlevel=%x vsize=%x ",
 				new_pcr, vbuf_level, vbuf_size);
 		pr_info("alevel=%x asize=%x play_mode=%d\n",
 				abuf_level, abuf_size, play_mode);
+#else
+		if (vbuf_level * 5 > vbuf_size * 4 && vbuf_size > 0) {
+			pr_info("vbuf > 4/5 %x %x new_pcr=%x\n",
+				vbuf_level, vbuf_size, new_pcr);
+		}
+		if (abuf_level * 5 > abuf_size * 4 && abuf_size > 0) {
+			pr_info("abuf > 4/5 %x %x new_pcr=%x\n",
+				abuf_level, abuf_size, new_pcr);
+		}
+#endif
 	}
 
 	if (play_mode == PLAY_MODE_FORCE_SLOW) {
@@ -1162,6 +1218,8 @@ int tsync_pcr_start(void)
 			tsync_pcr_usepcr, tsync_pcr_inited_mode);
 		add_timer(&tsync_pcr_check_timer);
 	}
+	abuf_fatal_error = 0;
+	vbuf_fatal_error = 0;
 	return 0;
 }
 
diff --git a/drivers/amlogic/amports/vavs.c b/drivers/amlogic/amports/vavs.c
index 80ff2ef..9e7294e 100644
--- a/drivers/amlogic/amports/vavs.c
+++ b/drivers/amlogic/amports/vavs.c
@@ -105,6 +105,7 @@ static const char vavs_dec_id[] = "vavs-dev";
 
 #define PROVIDER_NAME   "decoder.avs"
 static DEFINE_SPINLOCK(lock);
+static DEFINE_MUTEX(vavs_mutex);
 
 static const struct vframe_operations_s vavs_vf_provider = {
 	.peek = vavs_vf_peek,
@@ -126,9 +127,12 @@ static u32 canvas_base = 128;
 #else
 	int	canvas_num = 3;
 #endif
-	static u32 work_buf_size;
+static u32 work_buf_size;
 
 static struct vframe_s vfpool[VF_POOL_SIZE];
+/*static struct vframe_s vfpool2[VF_POOL_SIZE];*/
+static struct vframe_s *cur_vfpool;
+static unsigned char recover_flag;
 static s32 vfbuf_use[VF_BUF_NUM_MAX];
 static u32 saved_resolution;
 static u32 frame_width, frame_height, frame_dur, frame_prog;
@@ -546,15 +550,25 @@ static void vavs_isr(void)
 	return;
 #endif
 }
-
+/*
 static int run_flag = 1;
 static int step_flag;
+*/
 static int error_recovery_mode;   /*0: blocky  1: mosaic*/
+/*
+static uint error_watchdog_threshold=10;
+static uint error_watchdog_count;
+static uint error_watchdog_buf_threshold = 0x4000000;
+*/
+static uint long_cabac_busy;
 
 static struct vframe_s *vavs_vf_peek(void *op_arg)
 {
 	struct vframe_s *vf;
 
+	if (recover_flag)
+		return NULL;
+
 	if (kfifo_peek(&display_q, &vf))
 		return vf;
 
@@ -566,6 +580,9 @@ static struct vframe_s *vavs_vf_get(void *op_arg)
 {
 	struct vframe_s *vf;
 
+	if (recover_flag)
+		return NULL;
+
 	if (kfifo_get(&display_q, &vf))
 		return vf;
 
@@ -575,7 +592,16 @@ static struct vframe_s *vavs_vf_get(void *op_arg)
 
 static void vavs_vf_put(struct vframe_s *vf, void *op_arg)
 {
-	kfifo_put(&recycle_q, (const struct vframe_s *)vf);
+	int i;
+	if (recover_flag)
+		return;
+
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		if (vf == &cur_vfpool[i])
+			break;
+	}
+	if (i < VF_POOL_SIZE)
+		kfifo_put(&recycle_q, (const struct vframe_s *)vf);
 
 }
 
@@ -631,7 +657,9 @@ static void vavs_canvas_init(void)
 	if (vf_buf_num_used > vf_buf_num_avail)
 		vf_buf_num_used = vf_buf_num_avail;
 
-	buf_offset = buf_offset + ((vf_buf_num_used + 1) * decbuf_size);
+	if (firmware_sel == 0)
+		buf_offset = buf_offset + ((vf_buf_num_used + 1) * decbuf_size);
+
 	if (READ_MPEG_REG(VPP_MISC) & VPP_VD1_POSTBLEND) {
 		struct canvas_s cur_canvas;
 
@@ -723,6 +751,84 @@ static void vavs_canvas_init(void)
 	}
 }
 
+void vavs_recover(void)
+{
+	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6) | (1 << 4));
+	WRITE_VREG(DOS_SW_RESET0, 0);
+
+	READ_VREG(DOS_SW_RESET0);
+
+	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6) | (1 << 4));
+	WRITE_VREG(DOS_SW_RESET0, 0);
+
+	WRITE_VREG(DOS_SW_RESET0, (1 << 9) | (1 << 8));
+	WRITE_VREG(DOS_SW_RESET0, 0);
+	/*
+	WRITE_VREG(POWER_CTL_VLD, 0x10);
+	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 2, MEM_FIFO_CNT_BIT, 2);
+	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 8, MEM_LEVEL_CNT_BIT, 6);
+	*/
+	if (firmware_sel == 0)
+		WRITE_VREG(AV_SCRATCH_5, 0);
+
+	if (firmware_sel == 0) {
+		/* fixed canvas index */
+		WRITE_VREG(AV_SCRATCH_0, canvas_base);
+		WRITE_VREG(AV_SCRATCH_1, vf_buf_num_used);
+	} else {
+		int ii;
+		for (ii = 0; ii < 4; ii++) {
+			WRITE_VREG(AV_SCRATCH_0 + ii,
+				(canvas_base + canvas_num * ii) |
+				((canvas_base + canvas_num * ii + 1)
+					<< 8) |
+				((canvas_base + canvas_num * ii + 1)
+					<< 16)
+			);
+		}
+	}
+
+	/* notify ucode the buffer offset */
+	WRITE_VREG(AV_SCRATCH_F, buf_offset);
+
+	/* disable PSCALE for hardware sharing */
+	WRITE_VREG(PSCALE_CTRL, 0);
+
+	WRITE_VREG(AVS_SOS_COUNT, 0);
+	WRITE_VREG(AVS_BUFFERIN, 0);
+	WRITE_VREG(AVS_BUFFEROUT, 0);
+	if (error_recovery_mode)
+		WRITE_VREG(AVS_ERROR_RECOVERY_MODE, 0);
+	else
+		WRITE_VREG(AVS_ERROR_RECOVERY_MODE, 1);
+	/* clear mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+
+	/* enable mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 1);
+#if 1				/* def DEBUG_UCODE */
+	WRITE_VREG(AV_SCRATCH_D, 0);
+#endif
+
+#ifdef NV21
+	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
+#endif
+
+#ifdef PIC_DC_NEED_CLEAR
+	CLEAR_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 31);
+#endif
+
+#ifdef AVSP_LONG_CABAC
+	if (firmware_sel == 0) {
+		WRITE_VREG(LONG_CABAC_DES_ADDR, es_write_addr_phy);
+		WRITE_VREG(LONG_CABAC_REQ, 0);
+		WRITE_VREG(LONG_CABAC_PIC_SIZE, 0);
+		WRITE_VREG(LONG_CABAC_SRC_ADDR, 0);
+	}
+#endif
+
+}
+
 static void vavs_prot_init(void)
 {
 #if 1 /* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
@@ -747,9 +853,11 @@ static void vavs_prot_init(void)
 	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
 #endif
 
+	/***************** reset vld   **********************************/
 	WRITE_VREG(POWER_CTL_VLD, 0x10);
 	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 2, MEM_FIFO_CNT_BIT, 2);
-	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 8, MEM_LEVEL_CNT_BIT, 6);
+	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL,	8, MEM_LEVEL_CNT_BIT, 6);
+	/*************************************************************/
 
 	vavs_canvas_init();
 	if (firmware_sel == 0)
@@ -859,6 +967,8 @@ static void vavs_local_init(void)
 	for (i = 0; i < vf_buf_num; i++)
 		vfbuf_use[i] = 0;
 
+	cur_vfpool = vfpool;
+
 }
 
 static int vavs_vf_states(struct vframe_states *states, void *op_arg)
@@ -884,6 +994,28 @@ static void vavs_ppmgr_reset(void)
 }
 #endif
 
+static void vavs_local_reset(void)
+{
+	mutex_lock(&vavs_mutex);
+	recover_flag = 1;
+	pr_info("error, local reset\n");
+	amvdec_stop();
+	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_RESET, NULL);
+	vavs_local_init();
+	vavs_recover();
+	amvdec_start();
+	recover_flag = 0;
+#if 0
+	error_watchdog_count = 0;
+
+	pr_info("pc %x stream buf wp %x rp %x level %x\n",
+		READ_VREG(MPC_E),
+		READ_VREG(VLD_MEM_VIFIFO_WP),
+		READ_VREG(VLD_MEM_VIFIFO_RP),
+		READ_VREG(VLD_MEM_VIFIFO_LEVEL));
+#endif
+	mutex_unlock(&vavs_mutex);
+}
 
 static void vavs_put_timer_func(unsigned long arg)
 {
@@ -893,20 +1025,47 @@ static void vavs_put_timer_func(unsigned long arg)
 	vavs_isr();
 #endif
 
-#if 1
-	if (!error_recovery_mode && READ_VREG(AVS_SOS_COUNT)) {
-		pr_info("vavs fatal error reset !\n");
-		amvdec_stop();
+	if (READ_VREG(AVS_SOS_COUNT)) {
+		if (!error_recovery_mode) {
+			if (debug_flag & AVS_DEBUG_OLD_ERROR_HANDLE) {
+				mutex_lock(&vavs_mutex);
+				pr_info("vavs fatal error reset !\n");
+				amvdec_stop();
 #ifdef CONFIG_POST_PROCESS_MANAGER
-		vavs_ppmgr_reset();
+				vavs_ppmgr_reset();
 #else
-		vf_light_unreg_provider(&vavs_vf_prov);
-		vavs_local_init();
-		vf_reg_provider(&vavs_vf_prov);
+				vf_light_unreg_provider(&vavs_vf_prov);
+				vavs_local_init();
+				vf_reg_provider(&vavs_vf_prov);
 #endif
-		vavs_prot_init();
-		amvdec_start();
+				vavs_recover();
+				amvdec_start();
+				mutex_unlock(&vavs_mutex);
+			} else {
+				vavs_local_reset();
+			}
+		}
 	}
+#if 0
+	if (long_cabac_busy == 0 &&
+		error_watchdog_threshold > 0 &&
+		kfifo_len(&display_q) == 0 &&
+		READ_VREG(VLD_MEM_VIFIFO_LEVEL) >
+		error_watchdog_buf_threshold) {
+		pr_info("newq %d dispq %d recyq %d\r\n",
+			kfifo_len(&newframe_q),
+			kfifo_len(&display_q),
+			kfifo_len(&recycle_q));
+		pr_info("pc %x stream buf wp %x rp %x level %x\n",
+			READ_VREG(MPC_E),
+			READ_VREG(VLD_MEM_VIFIFO_WP),
+			READ_VREG(VLD_MEM_VIFIFO_RP),
+			READ_VREG(VLD_MEM_VIFIFO_LEVEL));
+		error_watchdog_count++;
+		if (error_watchdog_count >= error_watchdog_threshold)
+			vavs_local_reset();
+	} else
+		error_watchdog_count = 0;
 #endif
 	if (radr != 0) {
 		if (rval != 0) {
@@ -955,6 +1114,7 @@ static void vavs_put_timer_func(unsigned long arg)
 
 static void long_cabac_do_work(struct work_struct *work)
 {
+	int status = 0;
 #ifdef PERFORMANCE_DEBUG
 	pr_info("enter %s buf level (new %d, display %d, recycle %d)\r\n",
 		__func__,
@@ -963,8 +1123,16 @@ static void long_cabac_do_work(struct work_struct *work)
 		kfifo_len(&recycle_q)
 		);
 #endif
-	while (READ_VREG(LONG_CABAC_REQ))
-		process_long_cabac();
+	mutex_lock(&vavs_mutex);
+	long_cabac_busy = 1;
+	while (READ_VREG(LONG_CABAC_REQ)) {
+		if (process_long_cabac() < 0) {
+			status = -1;
+			break;
+		}
+	}
+	long_cabac_busy = 0;
+	mutex_unlock(&vavs_mutex);
 #ifdef PERFORMANCE_DEBUG
 	pr_info("exit %s buf level (new %d, display %d, recycle %d)\r\n",
 		__func__,
@@ -973,6 +1141,10 @@ static void long_cabac_do_work(struct work_struct *work)
 		kfifo_len(&recycle_q)
 		);
 #endif
+	if (status < 0) {
+		pr_info("transcoding error, local reset\r\n");
+		vavs_local_reset();
+	}
 
 }
 #endif
@@ -1062,32 +1234,53 @@ static s32 vavs_init(void)
 
 	vavs_local_init();
 
-#ifdef AVSP_LONG_CABAC
-	if (firmware_sel == 0)
-		init_avsp_long_cabac_buf();
-#endif
-	if (debug_flag & AVS_DEBUG_UCODE) {
-		if (amvdec_loadmc_ex(VFORMAT_AVS, "vavs_mc_debug", NULL) < 0) {
-			amvdec_disable();
-			pr_info("failed\n");
-			return -EBUSY;
-		}
-		pr_info("debug ucode loaded\r\n");
-	} else if (firmware_sel == 1) {
-		/* old ucode */
-		if (amvdec_loadmc_ex(VFORMAT_AVS, "vavs_mc_old", NULL) < 0) {
-			amvdec_disable();
-			pr_info("failed\n");
-			return -EBUSY;
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		if (debug_flag & 2) {
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"txl_vavs_mc_debug", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
+		} else {
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"txl_vavs_mc", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
 		}
-		pr_info("old ucode loaded\r\n");
 	} else {
-		if (amvdec_loadmc_ex(VFORMAT_AVS, "vavs_mc", NULL) < 0) {
-			amvdec_disable();
-			pr_info("failed\n");
-			return -EBUSY;
+#ifdef AVSP_LONG_CABAC
+		if (firmware_sel == 0)
+			init_avsp_long_cabac_buf();
+#endif
+		if (debug_flag & AVS_DEBUG_UCODE) {
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"vavs_mc_debug", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
+			pr_info("debug ucode loaded\r\n");
+		} else if (firmware_sel == 1) {
+			/* old ucode */
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"vavs_mc_old", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
+			pr_info("old ucode loaded\r\n");
+		} else {
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"vavs_mc", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
+			pr_info("ucode loaded\r\n");
 		}
-		pr_info("ucode loaded\r\n");
 	}
 
 	stat |= STAT_MC_LOAD;
@@ -1152,6 +1345,10 @@ static int amvdec_avs_probe(struct platform_device *pdev)
 		pr_info("amvdec_avs memory resource undefined.\n");
 		return -EFAULT;
 	}
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		firmware_sel = 1;
+	}
+
 	if (firmware_sel == 1) {
 		vf_buf_num = 4;
 		canvas_base = 0;
@@ -1213,7 +1410,9 @@ static int amvdec_avs_remove(struct platform_device *pdev)
 	}
 #ifdef AVSP_LONG_CABAC
 	if (firmware_sel == 0) {
+		mutex_lock(&vavs_mutex);
 		cancel_work_sync(&long_cabac_wd_work);
+		mutex_unlock(&vavs_mutex);
 
 		if (es_write_addr_virt) {
 #if 0
@@ -1310,11 +1509,13 @@ static void __exit amvdec_avs_driver_remove_module(void)
 module_param(stat, uint, 0664);
 MODULE_PARM_DESC(stat, "\n amvdec_avs stat\n");
 
+/******************************************
 module_param(run_flag, uint, 0664);
 MODULE_PARM_DESC(run_flag, "\n run_flag\n");
 
 module_param(step_flag, uint, 0664);
 MODULE_PARM_DESC(step_flag, "\n step_flag\n");
+*******************************************/
 
 module_param(debug_flag, uint, 0664);
 MODULE_PARM_DESC(debug_flag, "\n debug_flag\n");
@@ -1322,6 +1523,14 @@ MODULE_PARM_DESC(debug_flag, "\n debug_flag\n");
 module_param(error_recovery_mode, uint, 0664);
 MODULE_PARM_DESC(error_recovery_mode, "\n error_recovery_mode\n");
 
+/******************************************
+module_param(error_watchdog_threshold, uint, 0664);
+MODULE_PARM_DESC(error_watchdog_threshold, "\n error_watchdog_threshold\n");
+
+module_param(error_watchdog_buf_threshold, uint, 0664);
+MODULE_PARM_DESC(error_watchdog_buf_threshold,
+			"\n error_watchdog_buf_threshold\n");
+*******************************************/
 
 module_param(pic_type, uint, 0444);
 MODULE_PARM_DESC(pic_type, "\n amdec_vas picture type\n");
diff --git a/drivers/amlogic/amports/vdec.c b/drivers/amlogic/amports/vdec.c
index 2a7f7d3..8259da5 100644
--- a/drivers/amlogic/amports/vdec.c
+++ b/drivers/amlogic/amports/vdec.c
@@ -186,7 +186,10 @@ s32 vdec_init(enum vformat_e vf, int is_4k)
 		(vf == VFORMAT_HEVC && is_4k)) {
 		try_free_keep_video();
 	}
+
+	mutex_lock(&vdec_mutex);
 	inited_vcodec_num++;
+	mutex_unlock(&vdec_mutex);
 
 	pr_debug("vdec_dev_reg.mem[0x%lx -- 0x%lx]\n",
 		vdec_dev_reg.mem_start,
@@ -282,6 +285,26 @@ s32 vdec_release(enum vformat_e vf)
 	return 0;
 }
 
+void vdec_free_cmabuf(void)
+{
+	mutex_lock(&vdec_mutex);
+
+	if ((inited_vcodec_num > 0) || (vdec_device)) {
+		mutex_unlock(&vdec_mutex);
+		return;
+	}
+
+	if (vdec_mem_alloced_from_codec && vdec_dev_reg.mem_start) {
+		codec_mm_free_for_dma(MEM_NAME, vdec_dev_reg.mem_start);
+		vdec_cma_page = NULL;
+		vdec_dev_reg.mem_start = reserved_mem_start;
+		vdec_dev_reg.mem_end = reserved_mem_end;
+		pr_info("force free vdec memory\n");
+	}
+
+	mutex_unlock(&vdec_mutex);
+}
+
 #if 1				/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 static bool test_hevc(u32 decomp_addr, u32 us_delay)
 {
diff --git a/drivers/amlogic/amports/vh264.c b/drivers/amlogic/amports/vh264.c
index 37a137b..0fbd030 100644
--- a/drivers/amlogic/amports/vh264.c
+++ b/drivers/amlogic/amports/vh264.c
@@ -46,10 +46,7 @@
 #include "streambuf.h"
 #include <linux/delay.h>
 
-
-#ifdef CONFIG_GE2D_KEEP_FRAME
 #include <linux/amlogic/ge2d/ge2d.h>
-#endif
 
 #define DRIVER_NAME "amvdec_h264"
 #define MODULE_NAME "amvdec_h264"
@@ -69,15 +66,13 @@
 #define PTS2DUR(x) ((x)*96/90)
 #define DUR2PTS_REM(x) (x*90 - DUR2PTS(x)*96)
 #define FIX_FRAME_RATE_CHECK_IDRFRAME_NUM 2
+#define VDEC_CLOCK_ADJUST_FRAME 50
 
 static inline bool close_to(int a, int b, int m)
 {
 	return (abs(a - b) < m) ? true : false;
 }
 
-/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
-#define NV21
-/* #endif */
 static DEFINE_MUTEX(vh264_mutex);
 /* 12M for L41 */
 #define MAX_DPB_BUFF_SIZE       (12*1024*1024)
@@ -112,6 +107,7 @@ static DEFINE_MUTEX(vh264_mutex);
 
 #define DEC_CONTROL_FLAG_FORCE_2997_1080P_INTERLACE 0x0001
 #define DEC_CONTROL_FLAG_FORCE_2500_576P_INTERLACE  0x0002
+#define DEC_CONTROL_FLAG_DISABLE_FAST_POC              0x0004
 
 #define INCPTR(p) ptr_atomic_wrap_inc(&p)
 
@@ -127,7 +123,7 @@ struct buffer_spec_s {
 	int y_canvas_index;
 	int u_canvas_index;
 	int v_canvas_index;
-#ifdef CONFIG_GE2D_KEEP_FRAME
+
 	unsigned int y_canvas_width;
 	unsigned int u_canvas_width;
 	unsigned int v_canvas_width;
@@ -135,8 +131,7 @@ struct buffer_spec_s {
 	unsigned int y_canvas_height;
 	unsigned int u_canvas_height;
 	unsigned int v_canvas_height;
-#endif
-	struct page *alloc_pages;
+
 	unsigned long phy_addr;
 	int alloc_count;
 };
@@ -186,11 +181,13 @@ static u32 frame_packing_type;
 static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
 static DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
 static DECLARE_KFIFO(recycle_q, struct vframe_s *, VF_POOL_SIZE);
+static DECLARE_KFIFO(delay_display_q, struct vframe_s *, VF_POOL_SIZE);
 
 static struct vframe_s vfpool[VF_POOL_SIZE];
 static s32 vfbuf_use[VF_BUF_NUM];
 static struct buffer_spec_s buffer_spec[VF_BUF_NUM];
-static struct vframe_s switching_fense_vf;
+static struct buffer_spec_s fense_buffer_spec[2];
+static struct vframe_s fense_vf[2];
 
 static struct timer_list recycle_timer;
 static u32 stat;
@@ -213,6 +210,7 @@ static u32 aspect_ratio_info;
 static u32 num_units_in_tick;
 static u32 time_scale;
 static u32 h264_ar;
+static u32 decoder_debug_flag;
 #ifdef DROP_B_FRAME_FOR_1080P_50_60FPS
 static u32 last_interlaced;
 #endif
@@ -275,6 +273,7 @@ static u64 first_pts64;
 static bool first_pts_cached;
 static void *sei_data_buffer;
 static dma_addr_t sei_data_buffer_phys;
+static int clk_adj_frame_count;
 
 #define MC_OFFSET_HEADER    0x0000
 #define MC_OFFSET_DATA      0x1000
@@ -289,7 +288,10 @@ static dma_addr_t sei_data_buffer_phys;
 #define MODE_FULL  1
 
 static DEFINE_SPINLOCK(lock);
+static DEFINE_SPINLOCK(prepare_lock);
+static DEFINE_SPINLOCK(recycle_lock);
 
+static bool block_display_q;
 static int vh264_stop(int mode);
 static s32 vh264_init(void);
 
@@ -297,7 +299,6 @@ static s32 vh264_init(void);
 
 static bool pts_discontinue;
 
-#ifdef CONFIG_GE2D_KEEP_FRAME
 static struct ge2d_context_s *ge2d_videoh264_context;
 
 static int ge2d_videoh264task_init(void)
@@ -327,8 +328,8 @@ static int ge2d_canvas_dup(struct canvas_s *srcy, struct canvas_s *srcu,
 {
 
 	struct config_para_ex_s ge2d_config;
-	pr_info("[%s]h264 ADDR srcy[0x%lx] srcu[0x%lx] des[0x%lx]\n",
-		   __func__, srcy->addr, srcu->addr, des->addr);
+	/* pr_info("[%s]h264 ADDR srcy[0x%lx] srcu[0x%lx] des[0x%lx]\n",
+		   __func__, srcy->addr, srcu->addr, des->addr); */
 	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
 
 	ge2d_config.alu_const_color = 0;
@@ -379,7 +380,6 @@ static int ge2d_canvas_dup(struct canvas_s *srcy, struct canvas_s *srcu,
 
 	return 0;
 }
-#endif
 
 static inline int fifo_level(void)
 {
@@ -390,7 +390,6 @@ static inline int fifo_level(void)
 void spec_set_canvas(struct buffer_spec_s *spec,
 					 unsigned width, unsigned height)
 {
-#ifdef NV21
 	canvas_config(spec->y_canvas_index,
 			spec->y_addr,
 			width, height,
@@ -400,25 +399,44 @@ void spec_set_canvas(struct buffer_spec_s *spec,
 				  spec->u_addr,
 				  width, height / 2,
 				  CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-#else
-	canvas_config(spec->y_canvas_index,
-				  spec->y_addr,
-				  width, height,
-				  CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+	return;
+}
 
-	canvas_config(spec->u_canvas_index,
-				  spec->u_addr,
-				  width / 2,
-				  height / 2,
-				  CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+static void prepare_display_q(void)
+{
+	unsigned long flags;
+	int count;
 
-	canvas_config(spec->v_canvas_index,
-				  spec->v_addr,
-				  width / 2,
-				  height / 2,
-				  CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-#endif
-	return;
+	spin_lock_irqsave(&prepare_lock, flags);
+
+	if (block_display_q) {
+		spin_unlock_irqrestore(&prepare_lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&prepare_lock, flags);
+
+	count  = (int)VF_POOL_SIZE -
+		kfifo_len(&delay_display_q) -
+		kfifo_len(&display_q) -
+		kfifo_len(&recycle_q) -
+		kfifo_len(&newframe_q);
+
+	if ((vh264_stream_switching_state != SWITCHING_STATE_OFF)
+		|| is_4k)
+		count = 0;
+	else
+		count = (count < 2) ? 0 : 2;
+
+	while (kfifo_len(&delay_display_q) > count) {
+		struct vframe_s *vf;
+		if (kfifo_get(&delay_display_q, &vf)) {
+			kfifo_put(&display_q,
+				(const struct vframe_s *)vf);
+			vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+		}
+	}
 }
 
 static struct vframe_s *vh264_vf_peek(void *op_arg)
@@ -443,7 +461,14 @@ static struct vframe_s *vh264_vf_get(void *op_arg)
 
 static void vh264_vf_put(struct vframe_s *vf, void *op_arg)
 {
-	kfifo_put(&recycle_q, (const struct vframe_s *)vf);
+	unsigned long flags;
+
+	spin_lock_irqsave(&recycle_lock, flags);
+
+	  if ((vf != &fense_vf[0]) && (vf != &fense_vf[1]))
+		kfifo_put(&recycle_q, (const struct vframe_s *)vf);
+
+	spin_unlock_irqrestore(&recycle_lock, flags);
 }
 
 static int vh264_event_cb(int type, void *data, void *private_data)
@@ -473,7 +498,8 @@ static int vh264_vf_states(struct vframe_states *states, void *op_arg)
 
 	states->vf_pool_size = VF_POOL_SIZE;
 	states->buf_free_num = kfifo_len(&newframe_q);
-	states->buf_avail_num = kfifo_len(&display_q);
+	states->buf_avail_num = kfifo_len(&display_q) +
+				kfifo_len(&delay_display_q);
 	states->buf_recycle_num = kfifo_len(&recycle_q);
 
 	spin_unlock_irqrestore(&lock, flags);
@@ -610,10 +636,15 @@ static void vh264_set_params(struct work_struct *work)
 	unsigned int crop_infor, crop_bottom, crop_right, level_idc;
 	u32 disp_addr = 0xffffffff;
 	struct canvas_s cur_canvas;
+	if (!atomic_read(&vh264_active))
+		return;
 	mutex_lock(&vh264_mutex);
 	if (vh264_stream_switching_state == SWITCHING_STATE_ON_CMD1)
 		vh264_stream_switching_state = SWITCHING_STATE_ON_CMD1_PENDING;
 	post_canvas = get_post_canvas();
+	clk_adj_frame_count = 0;
+	/* set to max decoder clock rate at the beginning */
+	vdec_source_changed(VFORMAT_H264, 3840, 2160, 60);
 	timing_info_present_flag = 0;
 	mb_width = READ_VREG(AV_SCRATCH_1);
 	seq_info = READ_VREG(AV_SCRATCH_2);
@@ -703,13 +734,14 @@ static void vh264_set_params(struct work_struct *work)
 							   chroma444)
 							  - 1));
 		}
+#if 0
 		pr_info
 		("frame_mbs_only_flag %d, crop_bottom %d,  frame_height %d, ",
 		 frame_mbs_only_flag, crop_bottom, frame_height);
 		pr_info
 		("mb_height %d,crop_right %d, frame_width %d, mb_width %d\n",
 		 mb_height, crop_right, frame_width, mb_width);
-
+#endif
 		if (frame_height == 1088)
 			frame_height = 1080;
 	}
@@ -783,7 +815,7 @@ static void vh264_set_params(struct work_struct *work)
 					>= buf_end) && (!use_alloc)) {
 				pr_info("start alloc for %d\n", i);
 				use_alloc = true;
-			   }
+			}
 			if (use_alloc) {
 #ifdef DOUBLE_WRITE
 				int page_count =
@@ -803,7 +835,6 @@ static void vh264_set_params(struct work_struct *work)
 						codec_mm_free_for_dma(MEM_NAME,
 						buffer_spec[i].phy_addr);
 						buffer_spec[i].phy_addr = 0;
-					buffer_spec[i].alloc_pages = NULL;
 						buffer_spec[i].alloc_count = 0;
 					} else
 					pr_info("Re-use CMA buffer %d\n", i);
@@ -815,15 +846,16 @@ static void vh264_set_params(struct work_struct *work)
 						fatal_error_flag =
 						DECODER_FATAL_ERROR_NO_MEM;
 						vh264_running = 0;
-					mutex_unlock(&vh264_mutex);
-					pr_err("CMA  not enough mem!  %d\n", i);
-					return;
-				}
+						mutex_unlock(&vh264_mutex);
+						pr_err("CMA  not enough mem! %d\n",
+							i);
+						return;
+					}
 					buffer_spec[i].alloc_count = page_count;
 					buffer_spec[i].phy_addr =
 						codec_mm_alloc_for_dma(MEM_NAME,
 						buffer_spec[i].alloc_count,
-						4 +	PAGE_SHIFT,
+						4 + PAGE_SHIFT,
 						CODEC_MM_FLAGS_CMA_CLEAR |
 						CODEC_MM_FLAGS_FOR_VDECODER);
 					pr_info("CMA malloc ok  %d\n", i);
@@ -831,10 +863,11 @@ static void vh264_set_params(struct work_struct *work)
 				alloc_count++;
 				if (!buffer_spec[i].phy_addr) {
 					buffer_spec[i].alloc_count = 0;
-				pr_err("264-4k mem alloc failed %d\n", i);
-				vh264_running = 0;
-				mutex_unlock(&vh264_mutex);
-				return;
+					pr_err("264-4k mem alloc failed %d\n",
+						i);
+					vh264_running = 0;
+					mutex_unlock(&vh264_mutex);
+					return;
 				}
 				addr = buffer_spec[i].phy_addr;
 			} else {
@@ -842,8 +875,6 @@ static void vh264_set_params(struct work_struct *work)
 						codec_mm_free_for_dma(MEM_NAME,
 						buffer_spec[i].phy_addr);
 						buffer_spec[i].phy_addr = 0;
-						buffer_spec[i].alloc_pages =
-							NULL;
 						buffer_spec[i].alloc_count = 0;
 					}
 			}
@@ -853,30 +884,22 @@ static void vh264_set_params(struct work_struct *work)
 			if (i <= 21) {
 				buffer_spec[i].y_addr = addr;
 				addr += mb_total << 8;
-#ifdef NV21
 				buffer_spec[i].u_addr = addr;
 				buffer_spec[i].v_addr = addr;
 				addr += mb_total << 7;
-#else
-				buffer_spec[i].u_addr = addr;
-				addr += mb_total << 6;
-				buffer_spec[i].v_addr = addr;
-				addr += mb_total << 6;
-#endif
 				vfbuf_use[i] = 0;
 
-#ifdef NV21
 				buffer_spec[i].y_canvas_index = 128 + i * 2;
 				buffer_spec[i].u_canvas_index = 128 + i * 2 + 1;
 				buffer_spec[i].v_canvas_index = 128 + i * 2 + 1;
-#ifdef CONFIG_GE2D_KEEP_FRAME
+
 				buffer_spec[i].y_canvas_width = mb_width << 4;
 				buffer_spec[i].y_canvas_height = mb_height << 4;
 				buffer_spec[i].u_canvas_width = mb_width << 4;
 				buffer_spec[i].u_canvas_height = mb_height << 4;
 				buffer_spec[i].v_canvas_width = mb_width << 4;
 				buffer_spec[i].v_canvas_height = mb_height << 4;
-#endif
+
 				canvas_config(128 + i * 2,
 						buffer_spec[i].y_addr,
 						mb_width << 4, mb_height << 4,
@@ -889,73 +912,30 @@ static void vh264_set_params(struct work_struct *work)
 						CANVAS_BLKMODE_32X32);
 				WRITE_VREG(ANC0_CANVAS_ADDR + i,
 						spec2canvas(&buffer_spec[i]));
-#else
-				buffer_spec[i].y_canvas_index = 128 + i * 3;
-				buffer_spec[i].u_canvas_index = 128 + i * 3 + 1;
-				buffer_spec[i].v_canvas_index = 128 + i * 3 + 2;
-
-				canvas_config(128 + i * 3,
-						buffer_spec[i].y_addr,
-						mb_width << 4, mb_height << 4,
-						CANVAS_ADDR_NOWRAP,
-						CANVAS_BLKMODE_32X32);
-				canvas_config(128 + i * 3 + 1,
-						buffer_spec[i].u_addr,
-						mb_width << 3, mb_height << 3,
-						CANVAS_ADDR_NOWRAP,
-						CANVAS_BLKMODE_32X32);
-				canvas_config(128 + i * 3 + 2,
-						buffer_spec[i].v_addr,
-						mb_width << 3, mb_height << 3,
-						CANVAS_ADDR_NOWRAP,
-						CANVAS_BLKMODE_32X32);
-				WRITE_VREG(ANC0_CANVAS_ADDR + i,
-						spec2canvas(&buffer_spec[i]));
-#endif
 				} else {
-#ifdef NV21
 				buffer_spec[i].y_canvas_index =
-					2 * (i - 21) + 2;
+					2 * (i - 21) + 4;
 				buffer_spec[i].y_addr = addr;
 				addr += mb_total << 8;
 				buffer_spec[i].u_canvas_index =
-					2 * (i - 21) + 3;
+					2 * (i - 21) + 5;
 				buffer_spec[i].v_canvas_index =
-					2 * (i - 21) + 3;
+					2 * (i - 21) + 5;
 				buffer_spec[i].u_addr = addr;
 				addr += mb_total << 7;
 				vfbuf_use[i] = 0;
-#ifdef CONFIG_GE2D_KEEP_FRAME
+
 				buffer_spec[i].y_canvas_width = mb_width << 4;
 				buffer_spec[i].y_canvas_height = mb_height << 4;
 				buffer_spec[i].u_canvas_width = mb_width << 4;
 				buffer_spec[i].u_canvas_height = mb_height << 4;
 				buffer_spec[i].v_canvas_width = mb_width << 4;
 				buffer_spec[i].v_canvas_height = mb_height << 4;
-#endif
-				spec_set_canvas(&buffer_spec[i]
-					, mb_width << 4, mb_height << 4);
-				WRITE_VREG(ANC0_CANVAS_ADDR + i
-					, spec2canvas(&buffer_spec[i]));
-#else
-				buffer_spec[i].y_canvas_index =
-					3 * (i - 21) + 3;
-				buffer_spec[i].y_addr = addr;
-				addr += mb_total << 8;
-				buffer_spec[i].u_canvas_index =
-					3 * (i - 21) + 4;
-				buffer_spec[i].u_addr = addr;
-				addr += mb_total << 6;
-				buffer_spec[i].v_canvas_index =
-					3 * (i - 21) + 5;
-				buffer_spec[i].v_addr = addr;
-				addr += mb_total << 6;
-				vfbuf_use[i] = 0;
+
 				spec_set_canvas(&buffer_spec[i]
 					, mb_width << 4, mb_height << 4);
 				WRITE_VREG(ANC0_CANVAS_ADDR + i
 					, spec2canvas(&buffer_spec[i]));
-#endif
 			}
 		}
 	} else
@@ -1279,8 +1259,7 @@ static void vh264_isr(void)
 		DEC_CONTROL_FLAG_FORCE_2997_1080P_INTERLACE;
 	static const unsigned int flg_576_itl =
 		DEC_CONTROL_FLAG_FORCE_2500_576P_INTERLACE;
-	static const unsigned int vf_ready =
-		VFRAME_EVENT_PROVIDER_VFRAME_READY;
+
 	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
 
 	if (0 == (stat & STAT_VDEC_RUN)) {
@@ -1377,6 +1356,12 @@ static void vh264_isr(void)
 				vh264_eos = 1;
 
 			b_offset = (status >> 16) & 0xffff;
+			if (decoder_debug_flag) {
+				pr_info("slice_type %x idr %x  error %x",
+						slice_type, idr_flag, error);
+				pr_info(" prog %x pic_struct %x offset %x\n",
+				prog_frame, pic_struct,	b_offset);
+			}
 #ifdef DROP_B_FRAME_FOR_1080P_50_60FPS
 			last_interlaced = prog_frame ? 0 : 1;
 #endif
@@ -1386,6 +1371,9 @@ static void vh264_isr(void)
 				return IRQ_HANDLED;
 			}
 
+			if (clk_adj_frame_count < VDEC_CLOCK_ADJUST_FRAME)
+				clk_adj_frame_count++;
+
 			set_frame_info(vf);
 
 			switch (i) {
@@ -1542,9 +1530,18 @@ static void vh264_isr(void)
 					last_pts_remainder = 0;
 
 			} else {
-				pts =
-					pts_inc_by_duration(&pts,
-							&last_pts_remainder);
+				if (fixed_frame_rate_flag && !pts_discontinue &&
+					(fixed_frame_rate_check_count
+							> idr_num) &&
+					pts_valid_save && (sync_outside == 0) &&
+					(abs(pts_inc_by_duration(NULL, NULL)
+					 - pts)
+					 > DUR2PTS(frame_dur))) {
+						duration_from_pts_done = 0;
+						pr_info("recalc frame_dur\n");
+				} else
+					pts = pts_inc_by_duration(&pts,
+						&last_pts_remainder);
 				pts_valid = 1;
 			}
 
@@ -1619,15 +1616,10 @@ static void vh264_isr(void)
 							frame_dur);
 
 				vf->index = buffer_index;
-#ifdef NV21
 				vf->type =
 					VIDTYPE_PROGRESSIVE |
 					VIDTYPE_VIU_FIELD |
 					VIDTYPE_VIU_NV21;
-#else
-				vf->type =
-					VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
-#endif
 				vf->duration_pulldown = 0;
 				vf->signal_type = video_signal_from_vui;
 				vf->index = buffer_index;
@@ -1647,14 +1639,9 @@ static void vh264_isr(void)
 				} else {
 					p_last_vf = vf;
 					pts_discontinue = false;
-					kfifo_put(&display_q,
+					kfifo_put(&delay_display_q,
 						  (const struct vframe_s *)vf);
-
-					vf_notify_receiver(PROVIDER_NAME,
-						vf_ready,
-						NULL);
 				}
-
 			} else {
 				if (pic_struct_present
 					&& pic_struct == PIC_TOP_BOT)
@@ -1668,9 +1655,7 @@ static void vh264_isr(void)
 						VIDTYPE_INTERLACE_BOTTOM :
 						VIDTYPE_INTERLACE_TOP;
 				}
-#ifdef NV21
 				vf->type |= VIDTYPE_VIU_NV21;
-#endif
 				vf->type |= VIDTYPE_INTERLACE_FIRST;
 
 				vf->duration >>= 1;
@@ -1694,14 +1679,11 @@ static void vh264_isr(void)
 					continue;
 				} else {
 					pts_discontinue = false;
-					kfifo_put(&display_q,
+					kfifo_put(&delay_display_q,
 						(const struct vframe_s *)vf);
 				}
 
 				if (READ_VREG(AV_SCRATCH_F) & 2) {
-					vf_notify_receiver(PROVIDER_NAME,
-						vf_ready,
-						NULL);
 					continue;
 				}
 
@@ -1726,16 +1708,13 @@ static void vh264_isr(void)
 						VIDTYPE_INTERLACE_BOTTOM;
 				}
 
-#ifdef NV21
 				vf->type |= VIDTYPE_VIU_NV21;
-#endif
-
 				vf->duration >>= 1;
 				vf->duration_pulldown = 0;
 				vf->signal_type = video_signal_from_vui;
 				vf->index = buffer_index;
 				vf->pts = 0;
-
+				vf->pts_us64 = 0;
 				vf->canvas0Addr = vf->canvas1Addr =
 					spec2canvas(&buffer_spec[buffer_index]);
 				vf->type_original = vf->type;
@@ -1744,12 +1723,8 @@ static void vh264_isr(void)
 				p_last_vf = vf;
 				vf->ready_jiffies64 = jiffies_64;
 
-				kfifo_put(&display_q,
+				kfifo_put(&delay_display_q,
 						(const struct vframe_s *)vf);
-
-				vf_notify_receiver(PROVIDER_NAME,
-					vf_ready,
-					NULL);
 			}
 		}
 
@@ -1816,14 +1791,9 @@ static void vh264_isr(void)
 				}
 
 			set_frame_info(vf);
-#ifdef NV21
 			vf->type = VIDTYPE_PROGRESSIVE |
 					VIDTYPE_VIU_FIELD |
 					VIDTYPE_VIU_NV21;
-#else
-			vf->type =
-					VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
-#endif
 			vf->duration_pulldown = 0;
 			vf->signal_type = video_signal_from_vui;
 			vf->index = buffer_index;
@@ -1834,8 +1804,8 @@ static void vh264_isr(void)
 			p_last_vf = vf;
 			pts_discontinue = false;
 			iponly_early_mode = 1;
-			kfifo_put(&display_q, (const struct vframe_s *)vf);
-			vf_notify_receiver(PROVIDER_NAME, vf_ready, NULL);
+			kfifo_put(&delay_display_q,
+				(const struct vframe_s *)vf);
 			WRITE_VREG(AV_SCRATCH_0, 0);
 		}
 
@@ -1899,6 +1869,9 @@ static void vh264_put_timer_func(unsigned long arg)
 		pr_info("operation forbidden in timer !\n");
 		goto exit;
 	}
+
+	prepare_display_q();
+
 	if (vf_get_receiver(PROVIDER_NAME)) {
 		state =
 			vf_notify_receiver(PROVIDER_NAME,
@@ -1924,6 +1897,7 @@ static void vh264_put_timer_func(unsigned long arg)
 		wait_i_pass_frames = reg_val & 0xff;
 		if (wait_buffer_status) {
 			if (kfifo_is_empty(&display_q) &&
+				kfifo_is_empty(&delay_display_q) &&
 				kfifo_is_empty(&recycle_q) &&
 				(state == RECEIVER_INACTIVE)) {
 				pr_info("$$$$decoder is waiting for buffer\n");
@@ -1984,8 +1958,7 @@ static void vh264_put_timer_func(unsigned long arg)
 		   && (vh264_stream_switching_state == SWITCHING_STATE_OFF)) {
 		struct vframe_s *vf;
 		if (kfifo_get(&recycle_q, &vf)) {
-			if ((vf->index >= 0) && (vf->index < VF_BUF_NUM) &&
-					(vf != &switching_fense_vf)) {
+			if ((vf->index >= 0) && (vf->index < VF_BUF_NUM)) {
 				if (--vfbuf_use[vf->index] == 0) {
 					if (READ_VREG(AV_SCRATCH_7) == 0) {
 						WRITE_VREG(AV_SCRATCH_7,
@@ -2007,8 +1980,8 @@ static void vh264_put_timer_func(unsigned long arg)
 		while (!kfifo_is_empty(&recycle_q)) {
 			struct vframe_s *vf;
 			if (kfifo_get(&recycle_q, &vf)) {
-				if ((vf->index >= 0 && (vf->index < VF_BUF_NUM))
-					&& (vf != &switching_fense_vf)) {
+				if ((vf->index >= 0 &&
+					(vf->index < VF_BUF_NUM))) {
 					vf->index = VF_BUF_NUM;
 					kfifo_put(&newframe_q,
 						(const struct vframe_s *)vf);
@@ -2022,7 +1995,9 @@ static void vh264_put_timer_func(unsigned long arg)
 		if (kfifo_len(&newframe_q) == VF_POOL_SIZE)
 			stream_switching_done();
 	}
+
 	if (ucode_type != UCODE_IP_ONLY_PARAM &&
+		(clk_adj_frame_count > VDEC_CLOCK_ADJUST_FRAME) &&
 		frame_dur > 0 && saved_resolution !=
 		frame_width * frame_height * (96000 / frame_dur)) {
 		int fps = 96000 / frame_dur;
@@ -2122,17 +2097,17 @@ static void vh264_prot_init(void)
 		 0) ? error_recovery_mode : error_recovery_mode_in;
 	WRITE_VREG(AV_SCRATCH_F,
 			   (READ_VREG(AV_SCRATCH_F) & 0xffffffc3) |
+			   (READ_VREG(AV_SCRATCH_F) & 0xffffff43) |
 			   ((error_recovery_mode_use & 0x1) << 4));
-
+	if (dec_control & DEC_CONTROL_FLAG_DISABLE_FAST_POC)
+				SET_VREG_MASK(AV_SCRATCH_F, 1 << 7);
 	/* clear mailbox interrupt */
 	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
 
 	/* enable mailbox interrupt */
 	WRITE_VREG(ASSIST_MBOX1_MASK, 1);
 
-#ifdef NV21
 	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
-#endif
 	if (ucode_type == UCODE_IP_ONLY_PARAM)
 		SET_VREG_MASK(AV_SCRATCH_F, 1 << 6);
 	else
@@ -2196,6 +2171,7 @@ static void vh264_local_init(void)
 		vfbuf_use[i] = 0;
 
 	INIT_KFIFO(display_q);
+	INIT_KFIFO(delay_display_q);
 	INIT_KFIFO(recycle_q);
 	INIT_KFIFO(newframe_q);
 
@@ -2236,6 +2212,7 @@ static s32 vh264_init(void)
 {
 	int trickmode_fffb = 0;
 	int firmwareloaded = 0;
+	int i;
 
 	/* pr_info("\nvh264_init\n"); */
 	init_timer(&recycle_timer);
@@ -2342,11 +2319,11 @@ static s32 vh264_init(void)
 		int r0 , r1 , r2 , r3 , r4 , r5;
 		unsigned int cpu_type = get_cpu_type();
 		pr_debug("start load orignal firmware ...\n");
-		r0 = amvdec_loadmc_ex(VFORMAT_H264, "vh264_mc", NULL);
+	 if (cpu_type == MESON_CPU_MAJOR_ID_GXBB) {
 
+		r0 = amvdec_loadmc_ex(VFORMAT_H264, "vh264_mc", NULL);
 		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_HEADER, vh264_header_mc,
-			   MC_SWAP_SIZE);*/
-	 if (cpu_type == MESON_CPU_MAJOR_ID_GXBB) {
+				MC_SWAP_SIZE);*/
 		r1 = get_decoder_firmware_data(VFORMAT_H264, "vh264_header_mc",
 			(u8 *) mc_cpu_addr + MC_OFFSET_HEADER, MC_SWAP_SIZE);
 		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_DATA, vh264_data_mc,
@@ -2369,6 +2346,23 @@ static s32 vh264_init(void)
 		*/
 		r5 = get_decoder_firmware_data(VFORMAT_H264, "vh264_slice_mc",
 			(u8 *) mc_cpu_addr + MC_OFFSET_SLICE, MC_SWAP_SIZE);
+	 } else if (cpu_type >= MESON_CPU_MAJOR_ID_GXM) {
+		r0 = amvdec_loadmc_ex(VFORMAT_H264, "gxm_vh264_mc", NULL);
+		r1 = get_decoder_firmware_data(VFORMAT_H264,
+			"gxm_vh264_header_mc",
+			(u8 *) mc_cpu_addr + MC_OFFSET_HEADER, MC_SWAP_SIZE);
+		r2 = get_decoder_firmware_data(VFORMAT_H264,
+			"gxm_vh264_data_mc",
+			(u8 *) mc_cpu_addr + MC_OFFSET_DATA, MC_SWAP_SIZE);
+		r3 = get_decoder_firmware_data(VFORMAT_H264,
+			"gxm_vh264_mmco_mc",
+			(u8 *) mc_cpu_addr + MC_OFFSET_MMCO, MC_SWAP_SIZE);
+		r4 = get_decoder_firmware_data(VFORMAT_H264,
+			"gxm_vh264_list_mc",
+			(u8 *) mc_cpu_addr + MC_OFFSET_LIST, MC_SWAP_SIZE);
+		r5 = get_decoder_firmware_data(VFORMAT_H264,
+			"gxm_vh264_slice_mc",
+			(u8 *) mc_cpu_addr + MC_OFFSET_SLICE, MC_SWAP_SIZE);
 	 } else if (cpu_type >= MESON_CPU_MAJOR_ID_GXTVBB) {
 		r0 = amvdec_loadmc_ex(VFORMAT_H264, "gxtvbb_vh264_mc", NULL);
 		r1 = get_decoder_firmware_data(VFORMAT_H264,
@@ -2407,6 +2401,21 @@ static s32 vh264_init(void)
 
 	stat |= STAT_MC_LOAD;
 
+	for (i = 0; i < ARRAY_SIZE(fense_buffer_spec); i++) {
+		struct buffer_spec_s *s = &fense_buffer_spec[i];
+		if (!codec_mm_enough_for_size(3 * SZ_1M))
+			return -ENOMEM;
+
+		s->alloc_count = 3 * SZ_1M / PAGE_SIZE;
+		s->phy_addr = codec_mm_alloc_for_dma(MEM_NAME,
+			s->alloc_count,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR | CODEC_MM_FLAGS_FOR_VDECODER);
+		s->y_canvas_index = 2 * i;
+		s->u_canvas_index = 2 * i + 1;
+		s->v_canvas_index = 2 * i + 1;
+	}
+
 	/* enable AMRISC side protocol */
 	vh264_prot_init();
 
@@ -2515,6 +2524,15 @@ static int vh264_stop(int mode)
 	}
 	amvdec_disable();
 
+	for (i = 0; i < ARRAY_SIZE(fense_buffer_spec); i++) {
+		if (fense_buffer_spec[i].phy_addr) {
+			codec_mm_free_for_dma(MEM_NAME,
+				fense_buffer_spec[i].phy_addr);
+			fense_buffer_spec[i].phy_addr = 0;
+			fense_buffer_spec[i].alloc_count = 0;
+		}
+	}
+
 	  for (i = 0; i < ARRAY_SIZE(buffer_spec); i++) {
 			if (buffer_spec[i].phy_addr) {
 				if (is_4k && !get_blackout_policy())
@@ -2524,7 +2542,6 @@ static int vh264_stop(int mode)
 					codec_mm_free_for_dma(MEM_NAME,
 					buffer_spec[i].phy_addr);
 					buffer_spec[i].phy_addr = 0;
-					buffer_spec[i].alloc_pages = NULL;
 					buffer_spec[i].alloc_count = 0;
 				}
 			}
@@ -2591,182 +2608,131 @@ static void stream_switching_done(void)
 	pr_info("Leaving switching mode.\n");
 }
 
-#if !defined(NV21) || !defined(CONFIG_GE2D_KEEP_FRAME)
-static int canvas_dup(u8 *dst, ulong src_paddr, ulong size)
-{
-	void __iomem *p = ioremap_wc(src_paddr, size);
-	if (p) {
-		memcpy(dst, p, size);
-		iounmap(p);
-		return 1;
-	}
-	return 0;
-}
-#endif
-
 /* construt a new frame as a copy of last frame so frame receiver can
  * release all buffer resources to decoder.
  */
 static void stream_switching_do(struct work_struct *work)
 {
-	unsigned int buffer_index;
-	bool do_copy = true;
-	int mb_total_num, mb_width_num, mb_height_num;
-	struct vframe_s *vf;
-
-#ifdef CONFIG_GE2D_KEEP_FRAME
-	u32 y_index, u_index, src_index, des_index, y_desindex, u_dexindex;
+	int mb_total_num, mb_width_num, mb_height_num, i = 0;
+	struct vframe_s *vf = NULL;
+	u32 y_index, u_index, src_index, des_index, y_desindex, u_desindex;
 	struct canvas_s csy, csu, cyd;
-#endif
+	unsigned long flags;
+	bool delay = true;
+
 	if (!atomic_read(&vh264_active))
 		return;
-	if ((!p_last_vf)
-		|| (vh264_stream_switching_state == SWITCHING_STATE_OFF))
+
+	if (vh264_stream_switching_state == SWITCHING_STATE_OFF)
 		return;
 
-	if (atomic_read(&vh264_active)) {
-		ulong videoKeepBuf[3], videoKeepBufPhys[3];
+	spin_lock_irqsave(&prepare_lock, flags);
 
-		get_video_keep_buffer(videoKeepBuf, videoKeepBufPhys);
-#ifdef NV21
-#ifdef CONFIG_GE2D_KEEP_FRAME
-		if (!videoKeepBufPhys[0] || !videoKeepBufPhys[1])
-			do_copy = false;
-#else
-		if (!videoKeepBuf[0] || !videoKeepBuf[1])
-			do_copy = false;
-#endif
-#else
-		if (!videoKeepBuf[0] || !videoKeepBuf[1] || !videoKeepBuf[2])
-			do_copy = false;
-#endif
-		buffer_index = p_last_vf->index;
-		mb_total_num = mb_total;
-		mb_width_num = mb_width;
-		mb_height_num = mb_height;
+	block_display_q = true;
+
+	spin_unlock_irqrestore(&prepare_lock, flags);
+
+	mb_total_num = mb_total;
+	mb_width_num = mb_width;
+	mb_height_num = mb_height;
 
-		if (buffer_index > VF_BUF_NUM - 1 || is_4k)
-			do_copy = false;
+	while (is_4k || kfifo_len(&delay_display_q) > 2) {
+		if (kfifo_get(&delay_display_q, &vf)) {
+			kfifo_put(&display_q,
+				(const struct vframe_s *)vf);
+			vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+		} else
+			break;
+	}
+
+	if (!kfifo_get(&delay_display_q, &vf)) {
+		vf = p_last_vf;
+		delay = false;
+	}
+
+	while (vf) {
+		int buffer_index;
+
+		buffer_index = vf->index & 0xff;
 
 		/* construct a clone of the frame from last frame */
-		if (do_copy) {
-			/* construct a clone of the frame from last frame */
-#ifdef NV21
-#ifdef CONFIG_GE2D_KEEP_FRAME
-			pr_info
-			("src yaddr[0x%x] index[%d] width[%d] heigth[%d]\n",
-			 buffer_spec[buffer_index].y_addr,
-			 buffer_spec[buffer_index].y_canvas_index,
-			 buffer_spec[buffer_index].y_canvas_width,
-			 buffer_spec[buffer_index].y_canvas_height);
-
-			pr_info
-			("src uaddr[0x%x] index[%d] width[%d] heigth[%d]\n",
-			 buffer_spec[buffer_index].u_addr,
-			 buffer_spec[buffer_index].u_canvas_index,
-			 buffer_spec[buffer_index].u_canvas_width,
-			 buffer_spec[buffer_index].u_canvas_height);
+#if 0
+		pr_info("src yaddr[0x%x] index[%d] width[%d] heigth[%d]\n",
+			buffer_spec[buffer_index].y_addr,
+			buffer_spec[buffer_index].y_canvas_index,
+			buffer_spec[buffer_index].y_canvas_width,
+			buffer_spec[buffer_index].y_canvas_height);
+
+		pr_info("src uaddr[0x%x] index[%d] width[%d] heigth[%d]\n",
+			buffer_spec[buffer_index].u_addr,
+			buffer_spec[buffer_index].u_canvas_index,
+			buffer_spec[buffer_index].u_canvas_width,
+			buffer_spec[buffer_index].u_canvas_height);
+#endif
+		if (!is_4k) {
 			y_index = buffer_spec[buffer_index].y_canvas_index;
 			u_index = buffer_spec[buffer_index].u_canvas_index;
+
 			canvas_read(y_index, &csy);
 			canvas_read(u_index, &csu);
 
-			canvas_config(0, videoKeepBufPhys[0],
-					mb_width_num << 4, mb_height_num << 4,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-			canvas_config(1, videoKeepBufPhys[1],
-					mb_width_num << 4, mb_height_num << 3,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_LINEAR);
-
-			y_desindex = 0;
-			u_dexindex = 1;
+			canvas_config(fense_buffer_spec[i].y_canvas_index,
+				fense_buffer_spec[i].phy_addr,
+				mb_width_num << 4, mb_height_num << 4,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			canvas_config(fense_buffer_spec[i].u_canvas_index,
+				fense_buffer_spec[i].phy_addr +
+				(mb_total_num << 8),
+				mb_width_num << 4, mb_height_num << 3,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+
+			y_desindex = fense_buffer_spec[i].y_canvas_index;
+			u_desindex = fense_buffer_spec[i].u_canvas_index;
+
 			canvas_read(y_desindex, &cyd);
-			src_index =
-				((y_index & 0xff) |
-				 ((u_index << 8) & 0x0000ff00));
-			des_index =
-				((y_desindex & 0xff) |
-				 ((u_dexindex << 8) & 0x0000ff00));
+
+			src_index = ((y_index & 0xff) |
+				((u_index << 8) & 0x0000ff00));
+			des_index = ((y_desindex & 0xff) |
+				((u_desindex << 8) & 0x0000ff00));
+
 			ge2d_canvas_dup(&csy, &csu, &cyd,
-					GE2D_FORMAT_M24_NV21,
-					src_index, des_index);
-#else
-			canvas_dup((u8 *) videoKeepBuf[0],
-					   buffer_spec[buffer_index].y_addr,
-					   mb_total_num << 8);
-			canvas_dup((u8 *) videoKeepBuf[1],
-					   buffer_spec[buffer_index].u_addr,
-					   mb_total_num << 7);
-
-			canvas_config(0, videoKeepBufPhys[0],
-					mb_width_num << 4,
-					mb_height_num << 4,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
-			canvas_config(1, videoKeepBufPhys[1],
-					mb_width_num << 4,
-					mb_height_num << 3,
-					CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
-#endif
-#else
-			canvas_dup((u8 *) videoKeepBuf[0],
-					   buffer_spec[buffer_index].y_addr,
-					   mb_total_num << 8);
-			canvas_dup((u8 *) videoKeepBuf[1],
-					   buffer_spec[buffer_index].u_addr,
-					   mb_total_num << 6);
-			canvas_dup((u8 *) videoKeepBuf[2],
-					   buffer_spec[buffer_index].v_addr,
-					   mb_total_num << 6);
-
-			canvas_config(0, videoKeepBufPhys[0], mb_width_num << 4,
-					mb_height_num << 4, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
-			canvas_config(1, videoKeepBufPhys[1], mb_width_num << 3,
-					mb_height_num << 3, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
-			canvas_config(2, videoKeepBufPhys[2], mb_width_num << 3,
-					mb_height_num << 3, CANVAS_ADDR_NOWRAP,
-					CANVAS_BLKMODE_32X32);
-#endif
+				GE2D_FORMAT_M24_NV21,
+				src_index,
+				des_index);
 		}
+		fense_vf[i] = *vf;
+		fense_vf[i].index = -1;
 
-		switching_fense_vf = *p_last_vf;
-		switching_fense_vf.duration = 1;
-		switching_fense_vf.index = -1;
-		switching_fense_vf.flag |= VFRAME_FLAG_SWITCHING_FENSE;
-		if (do_copy) {
-#ifdef NV21
-			switching_fense_vf.canvas0Addr = 0x010100;
-#else
-			switching_fense_vf.canvas0Addr = 0x020100;
-#endif
-		}
+		if (!is_4k)
+			fense_vf[i].canvas0Addr =
+				spec2canvas(&fense_buffer_spec[i]);
+		else
+			fense_vf[i].flag |= VFRAME_FLAG_SWITCHING_FENSE;
 
-		vf = &switching_fense_vf;
-
-		if (vh264_stream_switching_state != SWITCHING_STATE_OFF) {
-			/* we only insert the fense frame when necessary,
-			 * if all buffers are already recycled to decoder
-			 * then it's not  necessary to post fense frame.
-			 * Such cases may happen when receiver side generates
-			 * its own buffer for final output, such as ppmgr
-			 * and ionvideo. The frame buffer from provider will
-			 * be recycled pretty fast. It could happen that
-			 * all frames are returned to decoder before a
-			 * fense frame is ready from this delay work queue.
-			 */
-			kfifo_put(&display_q, (const struct vframe_s *)vf);
-			vf_notify_receiver(PROVIDER_NAME,
-					VFRAME_EVENT_PROVIDER_VFRAME_READY,
-					NULL);
+		/* send clone to receiver */
+		kfifo_put(&display_q,
+			(const struct vframe_s *)&fense_vf[i]);
 
-			pr_info("Switching fense frame post\n");
-		}
+		/* early recycle frames for last session */
+		if (delay)
+			vh264_vf_put(vf, NULL);
+
+		vf_notify_receiver(PROVIDER_NAME,
+			VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+
+		i++;
+
+		if (!kfifo_get(&delay_display_q, &vf))
+			break;
 	}
+
+	block_display_q = false;
+
+	pr_info("Switching fense frame post\n");
 }
 
 static int amvdec_h264_probe(struct platform_device *pdev)
@@ -2786,6 +2752,7 @@ static int amvdec_h264_probe(struct platform_device *pdev)
 	buf_size = pdata->mem_end - pdata->mem_start + 1;
 	if (buf_size < DEFAULT_MEM_SIZE) {
 		pr_info("\namvdec_h264 memory size not enough.\n");
+		mutex_unlock(&vh264_mutex);
 		return -ENOMEM;
 	}
 
@@ -2805,6 +2772,7 @@ static int amvdec_h264_probe(struct platform_device *pdev)
 		if (!sei_data_buffer) {
 			pr_info("%s: Can not allocate sei_data_buffer\n",
 				   __func__);
+			mutex_unlock(&vh264_mutex);
 			return -ENOMEM;
 		}
 		/* pr_info("buffer 0x%x, phys 0x%x, remap 0x%x\n",
@@ -2874,9 +2842,9 @@ static struct codec_profile_t amvdec_h264_profile = {
 static int __init amvdec_h264_driver_init_module(void)
 {
 	pr_debug("amvdec_h264 module init\n");
-#ifdef CONFIG_GE2D_KEEP_FRAME
+
 	ge2d_videoh264task_init();
-#endif
+
 	if (platform_driver_register(&amvdec_h264_driver)) {
 		pr_err("failed to register amvdec_h264 driver\n");
 		return -ENODEV;
@@ -2892,9 +2860,8 @@ static void __exit amvdec_h264_driver_remove_module(void)
 	pr_debug("amvdec_h264 module remove.\n");
 
 	platform_driver_unregister(&amvdec_h264_driver);
-#ifdef CONFIG_GE2D_KEEP_FRAME
+
 	ge2d_videoh264task_release();
-#endif
 }
 
 /****************************************/
@@ -2921,6 +2888,9 @@ MODULE_PARM_DESC(debugfirmware, "\n amvdec_h264 debug load firmware\n");
 module_param(fixed_frame_rate_flag, uint, 0664);
 MODULE_PARM_DESC(fixed_frame_rate_flag,
 				 "\n amvdec_h264 fixed_frame_rate_flag\n");
+module_param(decoder_debug_flag, uint, 0664);
+MODULE_PARM_DESC(decoder_debug_flag,
+				 "\n amvdec_h264 decoder_debug_flag\n");
 
 module_param(decoder_force_reset, uint, 0664);
 MODULE_PARM_DESC(decoder_force_reset,
diff --git a/drivers/amlogic/amports/vh264_4k2k.c b/drivers/amlogic/amports/vh264_4k2k.c
index 70ace88..fffbb1d 100644
--- a/drivers/amlogic/amports/vh264_4k2k.c
+++ b/drivers/amlogic/amports/vh264_4k2k.c
@@ -119,6 +119,8 @@ static void *mc_cpu_addr;
 static DEFINE_SPINLOCK(lock);
 static int fatal_error;
 
+static atomic_t vh264_4k2k_active = ATOMIC_INIT(0);
+
 static DEFINE_MUTEX(vh264_4k2k_mutex);
 
 static void (*probe_callback)(void);
@@ -1661,6 +1663,25 @@ static int vh264_4k2k_stop(void)
 	return 0;
 }
 
+void vh264_4k_free_cmabuf(void)
+{
+	int i;
+	if (atomic_read(&vh264_4k2k_active))
+		return;
+	mutex_lock(&vh264_4k2k_mutex);
+	for (i = 0; i < ARRAY_SIZE(buffer_spec); i++) {
+		if (buffer_spec[i].phy_addr) {
+			codec_mm_free_for_dma(MEM_NAME,
+				buffer_spec[i].phy_addr);
+			buffer_spec[i].phy_addr = 0;
+			buffer_spec[i].alloc_pages = NULL;
+			buffer_spec[i].alloc_count = 0;
+			pr_info("force free CMA buffer %d\n", i);
+		}
+	}
+	mutex_unlock(&vh264_4k2k_mutex);
+}
+
 #if 0 /* (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) && (HAS_HDEC) */
 /* extern void AbortEncodeWithVdec2(int abort); */
 #endif
@@ -1751,6 +1772,7 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 	/*set the max clk for smooth playing...*/
 		vdec_source_changed(VFORMAT_H264_4K2K,
 				4096, 2048, 30);
+	atomic_set(&vh264_4k2k_active, 1);
 	mutex_unlock(&vh264_4k2k_mutex);
 
 	return 0;
@@ -1761,6 +1783,7 @@ static int amvdec_h264_4k2k_remove(struct platform_device *pdev)
 	cancel_work_sync(&alloc_work);
 
 	mutex_lock(&vh264_4k2k_mutex);
+	atomic_set(&vh264_4k2k_active, 0);
 
 	vh264_4k2k_stop();
 
diff --git a/drivers/amlogic/amports/vh264mvc.c b/drivers/amlogic/amports/vh264mvc.c
index 098ce1d..5ea7750 100644
--- a/drivers/amlogic/amports/vh264mvc.c
+++ b/drivers/amlogic/amports/vh264mvc.c
@@ -1309,7 +1309,7 @@ static void vh264mvc_local_init(void)
 static s32 vh264mvc_init(void)
 {
 	int r1, r2, r3, r4;
-
+	unsigned int cpu_type = get_cpu_type();
 	pr_info("\nvh264mvc_init\n");
 	init_timer(&recycle_timer);
 
@@ -1329,26 +1329,48 @@ static s32 vh264mvc_init(void)
 	}
 
 	WRITE_VREG(UCODE_START_ADDR, mc_dma_handle);
+	if (cpu_type >= MESON_CPU_MAJOR_ID_GXM) {
+		r1 = amvdec_loadmc_ex(VFORMAT_H264MVC, "gxm_vh264mvc_mc", NULL);
+
+		/*memcpy(p, vh264mvc_header_mc, sizeof(vh264mvc_header_mc));*/
+		r2 = get_decoder_firmware_data(VFORMAT_H264MVC,
+			"gxm_vh264mvc_header_mc", mc_cpu_addr, 0x1000);
+
+		/*memcpy((void *)((ulong) p + 0x1000),
+			   vh264mvc_mmco_mc, sizeof(vh264mvc_mmco_mc));
+		*/
+		r3 = get_decoder_firmware_data(VFORMAT_H264MVC,
+			"gxm_vh264mvc_mmco_mc",
+			(void *)((u8 *) mc_cpu_addr + 0x1000), 0x2000);
+
+		/*memcpy((void *)((ulong) p + 0x3000),
+			   vh264mvc_slice_mc, sizeof(vh264mvc_slice_mc));
+		*/
+		r4 = get_decoder_firmware_data(VFORMAT_H264MVC,
+			"gxm_vh264mvc_slice_mc",
+			(void *)((u8 *) mc_cpu_addr + 0x3000), 0x4000);
 
-	r1 = amvdec_loadmc_ex(VFORMAT_H264MVC, "vh264mvc_mc", NULL);
-
-	/*memcpy(p, vh264mvc_header_mc, sizeof(vh264mvc_header_mc));*/
-	r2 = get_decoder_firmware_data(VFORMAT_H264MVC, "vh264mvc_header_mc",
-					mc_cpu_addr, 0x1000);
-
-	/*memcpy((void *)((ulong) p + 0x1000),
-		   vh264mvc_mmco_mc, sizeof(vh264mvc_mmco_mc));
-	*/
-	r3 = get_decoder_firmware_data(VFORMAT_H264MVC, "vh264mvc_mmco_mc",
-					(void *)((u8 *) mc_cpu_addr + 0x1000),
-					0x2000);
-
-	/*memcpy((void *)((ulong) p + 0x3000),
-		   vh264mvc_slice_mc, sizeof(vh264mvc_slice_mc));
-	*/
-	r4 = get_decoder_firmware_data(VFORMAT_H264MVC, "vh264mvc_slice_mc",
-					(void *)((u8 *) mc_cpu_addr + 0x3000),
-					0x4000);
+		} else {
+		r1 = amvdec_loadmc_ex(VFORMAT_H264MVC, "vh264mvc_mc", NULL);
+
+		/*memcpy(p, vh264mvc_header_mc, sizeof(vh264mvc_header_mc));*/
+		r2 = get_decoder_firmware_data(VFORMAT_H264MVC,
+			"vh264mvc_header_mc", mc_cpu_addr, 0x1000);
+
+		/*memcpy((void *)((ulong) p + 0x1000),
+			   vh264mvc_mmco_mc, sizeof(vh264mvc_mmco_mc));
+		*/
+		r3 = get_decoder_firmware_data(VFORMAT_H264MVC,
+			"vh264mvc_mmco_mc",
+			(void *)((u8 *) mc_cpu_addr + 0x1000), 0x2000);
+
+		/*memcpy((void *)((ulong) p + 0x3000),
+			   vh264mvc_slice_mc, sizeof(vh264mvc_slice_mc));
+		*/
+		r4 = get_decoder_firmware_data(VFORMAT_H264MVC,
+			"vh264mvc_slice_mc",
+			(void *)((u8 *) mc_cpu_addr + 0x3000), 0x4000);
+		}
 	if (r1 < 0 || r2 < 0 || r3 < 0 || r4 < 0) {
 		amvdec_disable();
 
diff --git a/drivers/amlogic/amports/vh265.c b/drivers/amlogic/amports/vh265.c
index e962733..6ed562b 100644
--- a/drivers/amlogic/amports/vh265.c
+++ b/drivers/amlogic/amports/vh265.c
@@ -154,7 +154,7 @@ static u32 workaround_enable;
 static u32 force_w_h;
 #endif
 static u32 force_fps;
-
+static u32 pts_unstable;
 #define H265_DEBUG_BUFMGR                   0x01
 #define H265_DEBUG_BUFMGR_MORE              0x02
 #define H265_DEBUG_UCODE                    0x04
@@ -1069,8 +1069,8 @@ struct hevc_state_s {
 	int tile_height_lcu;
 
 	int slice_type;
-	int slice_addr;
-	int slice_segment_addr;
+	unsigned int slice_addr;
+	unsigned int slice_segment_addr;
 
 	unsigned char interlace_flag;
 	unsigned char curr_pic_struct;
@@ -1351,7 +1351,7 @@ static unsigned int log2i(unsigned int val)
 static int init_buf_spec(struct hevc_state_s *hevc);
 
 /*USE_BUF_BLOCK*/
-static void uninit_buf_list(struct hevc_state_s *hevc)
+static void uninit_buf_list(struct hevc_state_s *hevc, bool force_free)
 {
 	int i;
 	unsigned char release_cma_flag = 0;
@@ -1364,6 +1364,12 @@ static void uninit_buf_list(struct hevc_state_s *hevc)
 
 	hevc->predisp_addr = 0;
 
+	if (force_free) {
+		blackout = 0;
+		buffer_mode_real = 0;
+		pr_info("maybe reuinit buf_list, free cma buffer\n");
+	}
+
 	if (buffer_mode_real & 1) {
 		if (blackout == 1)
 			release_cma_flag = 1;
@@ -1424,6 +1430,7 @@ static void uninit_buf_list(struct hevc_state_s *hevc)
 	}
 
 	if (release_cma_flag) {
+		pr_info("release cma begin\n");
 		for (i = 0; i < hevc->used_buf_num; i++) {
 			if (hevc->m_BUF[i].alloc_addr != 0
 				&& hevc->m_BUF[i].cma_page_count > 0) {
@@ -1448,7 +1455,7 @@ static void uninit_buf_list(struct hevc_state_s *hevc)
 					}
 				}
 
-				pr_info("release cma buffer[%d] (%d %ld)\n", i,
+				pr_debug("release cma buffer[%d] (%d %ld)\n", i,
 					hevc->m_BUF[i].cma_page_count,
 					hevc->m_BUF[i].alloc_addr);
 				codec_mm_free_for_dma(MEM_NAME,
@@ -1458,6 +1465,7 @@ static void uninit_buf_list(struct hevc_state_s *hevc)
 
 			}
 		}
+		pr_info("release cma end\n");
 	}
 	pr_info("%s, blackout %x r%x buf_mode %x r%x rel_cma_flag %x hevc->predisp_addr %d pre_alloc_addr(%ld, %ld)\n",
 		__func__, get_blackout_policy(), blackout,
@@ -1548,6 +1556,8 @@ static void init_buf_list(struct hevc_state_s *hevc)
 		}
 	}
 
+	pr_info("allocate begin\n");
+	get_cma_alloc_ref();
 	for (i = 0; i < hevc->used_buf_num; i++) {
 		if (((i + 1) * buf_size) > hevc->mc_buf->buf_size) {
 			if (use_cma)
@@ -1617,7 +1627,7 @@ static void init_buf_list(struct hevc_state_s *hevc)
 					hevc->m_BUF[i].cma_page_count = 0;
 					break;
 				}
-				pr_info("allocate cma buffer[%d] (%d,%ld,%ld)\n",
+				pr_debug("allocate cma buffer[%d] (%d,%ld,%ld)\n",
 						i,
 						hevc->m_BUF[i].cma_page_count,
 						hevc->m_BUF[i].alloc_addr,
@@ -1654,6 +1664,8 @@ static void init_buf_list(struct hevc_state_s *hevc)
 				   hevc->m_BUF[i].size);
 		}
 	}
+	put_cma_alloc_ref();
+	pr_info("allocate end\n");
 
 	hevc->buf_num = i;
 
@@ -1680,7 +1692,7 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 					 5 ? 0x80 : 0x20;
 	int mpred_mv_end = hevc->work_space_buf->mpred_mv.buf_start +
 				 hevc->work_space_buf->mpred_mv.buf_size;
-	int y_adr = 0;
+	unsigned int y_adr = 0;
 	int buf_size = 0;
 #ifdef LOSLESS_COMPRESS_MODE
 /*SUPPORT_10BIT*/
@@ -4661,6 +4673,9 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		else
 			hevc->pts_hit++;
 #endif
+		if (pts_unstable && (hevc->frame_dur > 0)) {
+			hevc->pts_mode = PTS_NONE_REF_USE_DURATION;
+		}
 
 		if ((hevc->pts_mode == PTS_NORMAL) && (vf->pts != 0)
 			&& hevc->get_frame_dur) {
@@ -5836,6 +5851,7 @@ static int h265_task_handle(void *data)
 {
 	int ret = 0;
 	struct hevc_state_s *hevc = (struct hevc_state_s *)data;
+	set_user_nice(current, -10);
 	while (1) {
 		if (use_cma == 0) {
 			pr_info
@@ -5858,7 +5874,7 @@ static int h265_task_handle(void *data)
 
 		if (hevc->uninit_list) {
 			/*USE_BUF_BLOCK*/
-			uninit_buf_list(hevc);
+			uninit_buf_list(hevc, false);
 			pr_info("uninit list\n");
 			hevc->uninit_list = 0;
 		}
@@ -5869,6 +5885,25 @@ static int h265_task_handle(void *data)
 
 }
 
+void vh265_free_cmabuf(void)
+{
+	struct hevc_state_s *hevc = &gHevc;
+
+	mutex_lock(&vh265_mutex);
+
+	if (hevc->init_flag) {
+		mutex_unlock(&vh265_mutex);
+		return;
+	}
+
+	if (use_cma) {
+		pr_info("force uninit_buf_list\n");
+		uninit_buf_list(hevc, true);
+	}
+
+	mutex_unlock(&vh265_mutex);
+}
+
 int vh265_dec_status(struct vdec_status *vstatus)
 {
 	struct hevc_state_s *hevc = &gHevc;
@@ -5968,6 +6003,9 @@ static int vh265_local_init(struct hevc_state_s *hevc)
 		hevc->frame_ar = hevc->frame_height * 0x100 / hevc->frame_width;
 	hevc->error_watchdog_count = 0;
 	hevc->sei_present_flag = 0;
+	pts_unstable = ((unsigned long)hevc->vh265_amstream_dec_info.param
+		& 0x40) >> 6;
+	pr_info("h265:pts_unstable=%d\n", pts_unstable);
 /*
 TODO:FOR VERSION
 */
@@ -6448,7 +6486,8 @@ MODULE_PARM_DESC(max_decoding_time, "\n max_decoding_time\n");
 
 module_param(interlace_enable, uint, 0664);
 MODULE_PARM_DESC(interlace_enable, "\n interlace_enable\n");
-
+module_param(pts_unstable, uint, 0664);
+MODULE_PARM_DESC(pts_unstable, "\n amvdec_h265 pts_unstable\n");
 module_param(parser_sei_enable, uint, 0664);
 MODULE_PARM_DESC(parser_sei_enable, "\n parser_sei_enable\n");
 
diff --git a/drivers/amlogic/amports/video.c b/drivers/amlogic/amports/video.c
index f62dcf0..7481409 100644
--- a/drivers/amlogic/amports/video.c
+++ b/drivers/amlogic/amports/video.c
@@ -1841,25 +1841,19 @@ static void zoom_get_vert_pos(struct vframe_s *vf, u32 vpp_3d_mode, u32 *ls,
 static void zoom_display_horz(int hscale)
 {
 	u32 ls, le, rs, re;
-	if (platform_type == 1) {
-		if (process_3d_type & MODE_3D_ENABLE) {
-			zoom_get_horz_pos(cur_dispbuf,
-			cur_frame_par->vpp_3d_mode, &ls,
-			&le, &rs, &re);
-		} else {
-			ls = rs = zoom_start_x_lines;
-			le = re = zoom_end_x_lines;
-		}
+	int content_w, content_l, content_r;
+#ifdef TV_3D_FUNCTION_OPEN
+	if (process_3d_type & MODE_3D_ENABLE) {
+		zoom_get_horz_pos(cur_dispbuf, cur_frame_par->vpp_3d_mode, &ls,
+				  &le, &rs, &re);
 	} else {
-		if (process_3d_type & MODE_3D_ENABLE) {
-			zoom_get_horz_pos(cur_dispbuf,
-			cur_frame_par->vpp_3d_mode, &ls,
-			&le, &rs, &re);
-		} else {
-			ls = rs = zoom_start_x_lines;
-			le = re = zoom_end_x_lines;
-		}
+		ls = rs = zoom_start_x_lines;
+		le = re = zoom_end_x_lines;
 	}
+#else
+	ls = rs = zoom_start_x_lines;
+	le = re = zoom_end_x_lines;
+#endif
 	VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_X0 + cur_dev->viu_off,
 			  (ls << VDIF_PIC_START_BIT) |
 			  (le << VDIF_PIC_END_BIT));
@@ -1901,19 +1895,29 @@ static void zoom_display_horz(int hscale)
 			  ((l_aligned / 32) << 16) |
 			  ((r_aligned / 32) - 1));
 
-
-		VSYNC_WR_MPEG_REG(AFBC_PIXEL_HOR_SCOPE,
-			  ((zoom_start_x_lines - l_aligned) << 16) |
-			  (zoom_end_x_lines - l_aligned));
-
-	VSYNC_WR_MPEG_REG(AFBC_SIZE_IN,
-		  (VSYNC_RD_MPEG_REG(AFBC_SIZE_IN) & 0xffff) |
-		  ((r_aligned - l_aligned) << 16));
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
 			VSYNC_WR_MPEG_REG(AFBC_SIZE_OUT,
 				(VSYNC_RD_MPEG_REG(AFBC_SIZE_OUT) & 0xffff) |
 				((r_aligned - l_aligned) << 16));
 		}
+#ifdef TV_REVERSE
+		if (reverse) {
+			content_w = zoom_end_x_lines - zoom_start_x_lines + 1;
+			content_l = (r_aligned - zoom_end_x_lines - 1) +
+			(zoom_start_x_lines - l_aligned);
+			content_r = content_l + content_w - 1;
+			VSYNC_WR_MPEG_REG(AFBC_PIXEL_HOR_SCOPE,
+				  (content_l << 16) | content_r);
+		} else
+#endif
+		{
+			VSYNC_WR_MPEG_REG(AFBC_PIXEL_HOR_SCOPE,
+				  ((zoom_start_x_lines - l_aligned) << 16) |
+				  (zoom_end_x_lines - l_aligned));
+		}
+		VSYNC_WR_MPEG_REG(AFBC_SIZE_IN,
+			 (VSYNC_RD_MPEG_REG(AFBC_SIZE_IN) & 0xffff) |
+			 ((r_aligned - l_aligned) << 16));
 	}
 
 	VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_X0,
@@ -2213,7 +2217,9 @@ static void vsync_toggle_frame(struct vframe_s *vf)
 		(vf->type & VIDTYPE_COMPRESS)) {
 		VSYNC_WR_MPEG_REG(AFBC_HEAD_BADDR, vf->compHeadAddr>>4);
 		VSYNC_WR_MPEG_REG(AFBC_BODY_BADDR, vf->compBodyAddr>>4);
-	} else if ((VSYNC_RD_MPEG_REG(DI_IF1_GEN_REG) & 0x1) == 0) {
+	}
+	if ((vf->canvas0Addr != 0) &&
+	(VSYNC_RD_MPEG_REG(DI_IF1_GEN_REG) & 0x1) == 0) {
 #ifdef CONFIG_VSYNC_RDMA
 		canvas_copy(vf->canvas0Addr & 0xff,
 			    disp_canvas_index[rdma_canvas_id][0]);
@@ -2603,7 +2609,7 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 	u32 pat, loop;
 	static const u32 vpat[] = { 0, 0x8, 0x9, 0xa, 0xb, 0xc };
 	u32 u, v;
-	u32 type = vf->type;
+	u32 type = vf->type, bit_mode = 0;
 
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 		if (frame_par->nocomp)
@@ -2635,14 +2641,28 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 				0x80 << (u + 10) |
 				0x80 << v);
 			/* chroma formatter */
-			VSYNC_WR_MPEG_REG(AFBC_VD_CFMT_CTRL,
-				HFORMATTER_RRT_PIXEL0 |
-				HFORMATTER_YC_RATIO_2_1 |
-				HFORMATTER_EN |
-				VFORMATTER_RPTLINE0_EN |
-				/*(0xa << VFORMATTER_INIPHASE_BIT) |*/
-				(0x8 << VFORMATTER_PHASE_BIT) |
-				VFORMATTER_EN);
+#ifdef TV_REVERSE
+			if (reverse) {
+				VSYNC_WR_MPEG_REG(AFBC_VD_CFMT_CTRL,
+					/*HFORMATTER_RRT_PIXEL0 |*/
+					HFORMATTER_YC_RATIO_2_1 |
+					HFORMATTER_EN |
+					VFORMATTER_RPTLINE0_EN |
+					/*(0xa << VFORMATTER_INIPHASE_BIT) |*/
+					(0x8 << VFORMATTER_PHASE_BIT) |
+					VFORMATTER_EN);
+			} else
+#endif
+			{
+				VSYNC_WR_MPEG_REG(AFBC_VD_CFMT_CTRL,
+					HFORMATTER_RRT_PIXEL0 |
+					HFORMATTER_YC_RATIO_2_1 |
+					HFORMATTER_EN |
+					VFORMATTER_RPTLINE0_EN |
+					/*(0xa << VFORMATTER_INIPHASE_BIT) |*/
+					(0x8 << VFORMATTER_PHASE_BIT) |
+					VFORMATTER_EN);
+			}
 			if ((READ_VCBUS_REG(DI_POST_CTRL) & 0x100) == 0)
 				VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0 +
 					cur_dev->viu_off, 0, 16, 3);
@@ -2652,24 +2672,26 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 			return;
 
 		} else {
-			if (vf->bitdepth & BITDEPTH_Y10) {
+			if ((vf->bitdepth & BITDEPTH_Y10) &&
+			(!frame_par->nocomp)) {
 				if (vf->type & VIDTYPE_VIU_444) {
-					VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG3,
-						2, 8, 2);
-					VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3,
-						2, 8, 2);
+					bit_mode = 2;
 				} else {
-					VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG3,
-						1, 8, 2);
-					VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3,
-						1, 8, 2);
+					if (vf->bitdepth & FULL_PACK_422_MODE)
+						bit_mode = 3;
+					else
+						bit_mode = 1;
 				}
 			} else {
-				VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG3,
-				0, 8, 2);
-				VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3,
-				0, 8, 2);
+				bit_mode = 0;
 			}
+			VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG3,
+				(bit_mode&0x3), 8, 2);
+			VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3,
+				(bit_mode&0x3), 8, 2);
+			if (is_meson_txl_cpu())
+				VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG3,
+				(bit_mode&0x3), 8, 2);
 			if ((READ_VCBUS_REG(DI_POST_CTRL) & 0x100) == 0)
 				VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0 +
 					cur_dev->viu_off, 0, 16, 3);
@@ -2770,7 +2792,7 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 		vphase =
 		    ((type & VIDTYPE_VIU_422) ? 0x10 : 0x08) <<
 		    VFORMATTER_PHASE_BIT;
-	if (is_meson_gxtvbb_cpu()) {
+	if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) {
 		if ((vf->width >= 3840) &&
 			(vf->height >= 2160) &&
 			(type & VIDTYPE_VIU_422)) {
@@ -4133,7 +4155,7 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 
 		/* vpp super scaler */
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
-			vpp_set_super_sclaer_regs(cur_frame_par->supscl_path,
+			vpp_set_super_scaler_regs(cur_frame_par->supscl_path,
 				cur_frame_par->supsc0_enable,
 				cur_frame_par->spsc0_w_in,
 				cur_frame_par->spsc0_h_in,
@@ -4257,7 +4279,7 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 				(cur_frame_par->hscale_skip_count + 1);
 			}
 		}
-		if (is_meson_gxtvbb_cpu()) {
+		if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) {
 			if (cur_dispbuf->type & VIDTYPE_INTERLACE) {
 				cur_frame_par->VPP_pic_in_height_ =
 				(zoom_end_y_lines - zoom_start_y_lines + 1)  <<
@@ -5061,6 +5083,7 @@ unsigned int vf_keep_current(void)
 	if (!keep_y_addr
 	    || (cur_dispbuf->type & VIDTYPE_VIU_422) == VIDTYPE_VIU_422) {
 		/* no support VIDTYPE_VIU_422... */
+		pr_info("%s:no support VIDTYPE_VIU_422\n", __func__);
 		return -1;
 	}
 
@@ -5287,6 +5310,8 @@ static void _set_video_window(int *p)
 {
 	int w, h;
 	int *parsed = p;
+	int last_x, last_y, last_w, last_h;
+	int new_x, new_y, new_w, new_h;
 #ifdef TV_REVERSE
 	int temp, temp1;
 	const struct vinfo_s *info = get_current_vinfo();
@@ -5303,6 +5328,7 @@ static void _set_video_window(int *p)
 		parsed[3] = info->height - temp1 - 1;
 	}
 #endif
+	vpp_get_video_layer_position(&last_x, &last_y, &last_w, &last_h);
 	if (parsed[0] < 0 && parsed[2] < 2) {
 		parsed[2] = 2;
 		parsed[0] = 0;
@@ -5341,7 +5367,11 @@ static void _set_video_window(int *p)
 						     h);
 		}
 	}
-	video_property_changed = true;
+	vpp_get_video_layer_position(&new_x, &new_y, &new_w, &new_h);
+	if ((last_x != new_x) || (last_y != new_y)
+	|| (last_w != new_w) || (last_h != new_h)) {
+		video_property_changed = true;
+	}
 }
 
 /*********************************************************
@@ -6513,9 +6543,14 @@ static ssize_t video_test_screen_store(struct class *cla,
 		if (READ_VCBUS_REG(VIU_OSD1_BLK0_CFG_W0) & 0x80)
 			WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
 				test_screen & 0x00ffffff);
-		else /* RGB blend */
-			WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
+		else {/* RGB blend */
+			if (is_meson_txl_cpu())
+				WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
+					test_screen & 0x00ffffff);
+			else
+				WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
 				yuv2rgb(test_screen & 0x00ffffff));
+		}
 	}
 	WRITE_VCBUS_REG(VPP_MISC, data);
 
@@ -7234,6 +7269,25 @@ static ssize_t video_free_keep_buffer_store(struct class *cla,
 }
 
 
+static ssize_t free_cma_buffer_store(struct class *cla,
+				   struct class_attribute *attr,
+				   const char *buf, size_t count)
+{
+	size_t r;
+	int val;
+	r = sscanf(buf, "%d", &val);
+	if (r != 1)
+		return -EINVAL;
+	if (val == 1) {
+		pr_info("start to free cma buffer\n");
+		vh265_free_cmabuf();
+		vh264_4k_free_cmabuf();
+		vdec_free_cmabuf();
+	}
+	return count;
+}
+
+
 static struct class_attribute amvideo_class_attrs[] = {
 	__ATTR(axis,
 	       S_IRUGO | S_IWUSR | S_IWGRP,
@@ -7352,6 +7406,9 @@ static struct class_attribute amvideo_class_attrs[] = {
 	__ATTR(free_keep_buffer,
 	       S_IRUGO | S_IWUSR | S_IWGRP, NULL,
 	       video_free_keep_buffer_store),
+	__ATTR(free_cma_buffer,
+	       S_IRUGO | S_IWUSR | S_IWGRP, NULL,
+	       free_cma_buffer_store),
 #ifdef CONFIG_AM_VOUT
 	__ATTR_RO(device_resolution),
 #endif
@@ -7761,6 +7818,12 @@ static int __init video_early_init(void)
 	WRITE_VCBUS_REG(VPP_PREBLEND_VD1_H_START_END, 4096);
 	WRITE_VCBUS_REG(VPP_BLEND_VD2_H_START_END, 4096);
 #endif
+	if (is_meson_txl_cpu()) {
+		/* fifo max size on txl :128*3=384[0x180]  */
+		WRITE_VCBUS_REG(VD1_IF0_LUMA_FIFO_SIZE, 0x180);
+		WRITE_VCBUS_REG(VD2_IF0_LUMA_FIFO_SIZE, 0x180);
+	}
+
 	 /*fix S905 av out flicker black dot*/
 	if (is_meson_gxbb_cpu())
 		SET_VCBUS_REG_MASK(VPP_MISC, VPP_OUT_SATURATE);
@@ -7797,7 +7860,7 @@ static int __init video_early_init(void)
 	/* default 10bit setting for gxm */
 	if (is_meson_gxm_cpu()) {
 		WRITE_VCBUS_REG_BITS(VIU_MISC_CTRL1, 0xff, 16, 8);
-		WRITE_VCBUS_REG(VPP_DOLBY_CTRL, 0x20000);
+		WRITE_VCBUS_REG(VPP_DOLBY_CTRL, 0x22000);
 		/* default setting is black for dummy data1& dumy data0,
 		for dummy data1 the y/cb/cr data width is 10bit on gxm,
 		for dummy data the y/cb/cr data width is 8bit but
diff --git a/drivers/amlogic/amports/vmpeg4.c b/drivers/amlogic/amports/vmpeg4.c
index 2d303d6..fa3535d 100644
--- a/drivers/amlogic/amports/vmpeg4.c
+++ b/drivers/amlogic/amports/vmpeg4.c
@@ -648,6 +648,23 @@ static void vmpeg_put_timer_func(unsigned long arg)
 		vdec_source_changed(VFORMAT_MPEG4,
 			frame_width, frame_height, fps);
 	}
+	if (READ_VREG(AV_SCRATCH_L)) {
+		unsigned long flags;
+		pr_info("mpeg4 fatal error happened,need reset    !!\n");
+		amvdec_stop();
+#ifndef CONFIG_POST_PROCESS_MANAGER
+		vf_light_unreg_provider(&vmpeg_vf_prov);
+#endif
+		spin_lock_irqsave(&lock, flags);
+		vmpeg4_local_init();
+		vmpeg4_prot_init();
+		spin_unlock_irqrestore(&lock, flags);
+#ifndef CONFIG_POST_PROCESS_MANAGER
+		vf_reg_provider(&vmpeg_vf_prov);
+#endif
+		amvdec_start();
+	}
+
 
 	timer->expires = jiffies + PUT_INTERVAL;
 
@@ -815,6 +832,7 @@ static void vmpeg4_prot_init(void)
 	WRITE_VREG(AV_SCRATCH_I, 0x141312);
 	WRITE_VREG(AV_SCRATCH_J, 0x171615);
 #endif
+	WRITE_VREG(AV_SCRATCH_L, 0);/*clearfatal error flag*/
 
 	/* notify ucode the buffer offset */
 	WRITE_VREG(AV_SCRATCH_F, buf_offset);
diff --git a/drivers/amlogic/amports/vpp.c b/drivers/amlogic/amports/vpp.c
index 9f14e4d..f6a4514 100644
--- a/drivers/amlogic/amports/vpp.c
+++ b/drivers/amlogic/amports/vpp.c
@@ -300,7 +300,8 @@ static uint coeff(uint *settings, uint ratio, uint phase, bool interlace)
 	}
 	coeff_type = settings[coeff_select];
 	/* TODO: add future TV chips */
-	if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) {
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+		(get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)) {
 		if (coeff_type == COEF_BICUBIC_SHARP)
 			coeff_type = COEF_BICUBIC;
 	} else {
@@ -578,8 +579,10 @@ vpp_process_speed_check(s32 width_in,
 						(u64)vinfo->height *
 						1000,
 						height_out * 2160);
-					if (cur_ratio > MIN_RATIO_1000)
-						return SPEED_CHECK_VSKIP;
+				if ((cur_ratio > MIN_RATIO_1000) &&
+				(vf->source_type != VFRAME_SOURCE_TYPE_TUNER) &&
+				(vf->source_type != VFRAME_SOURCE_TYPE_CVBS))
+					return SPEED_CHECK_VSKIP;
 			}
 			if (vf->type & VIDTYPE_VIU_422) {
 				/*TODO vpu */
@@ -1172,9 +1175,10 @@ RESTART:
 	if (start >= end) {
 		/* nothing to display */
 		next_frame_par->VPP_hsc_startp = 0;
-
 		next_frame_par->VPP_hsc_endp = 0;
-
+		/* avoid mif set wrong or di out size overflow */
+		next_frame_par->VPP_hd_start_lines_ = 0;
+		next_frame_par->VPP_hd_end_lines_ = 0;
 	} else {
 		next_frame_par->VPP_hsc_startp = start;
 
@@ -1320,6 +1324,11 @@ RESTART:
 		pre_scaler_en) {
 		filter->vpp_pre_vsc_en = 1;
 		filter->vpp_vsc_start_phase_step >>= 1;
+		ratio_y >>= 1;
+		f2v_get_vertical_phase(ratio_y, ini_vphase,
+		next_frame_par->VPP_vf_ini_phase_,
+		vpp_flags & VPP_FLAG_INTERLACE_OUT);
+
 	} else
 		filter->vpp_pre_vsc_en = 0;
 
@@ -1442,7 +1451,7 @@ VPP_SRSHARP0_CTRL:0x1d91
 [1]if sharpness is enable or vscaler is enable,must set to 1,
 sharpness1;reg can only to be w
 */
-int vpp_set_super_sclaer_regs(int scaler_path_sel,
+int vpp_set_super_scaler_regs(int scaler_path_sel,
 		int reg_srscl0_enable,
 		int reg_srscl0_hsize,
 		int reg_srscl0_vsize,
@@ -2008,8 +2017,13 @@ vpp_set_filters(u32 process_3d_type, u32 wide_mode,
 		vpp_get_video_source_size(&src_width, &src_height,
 			process_3d_type, vf, next_frame_par);
 	} else {
-		src_width = vf->width;
-		src_height = vf->height;
+		if (vf->type & VIDTYPE_COMPRESS) {
+			src_width = vf->compWidth;
+			src_height = vf->compHeight;
+		} else {
+			src_width = vf->width;
+			src_height = vf->height;
+		}
 		next_frame_par->vpp_3d_mode = VPP_3D_MODE_NULL;
 		next_frame_par->vpp_2pic_mode = 0;
 		next_frame_par->vpp_3d_scale = 0;
@@ -2307,7 +2321,8 @@ void vpp_set_3d_scale(bool enable)
 
 void vpp_super_scaler_support(void)
 {
-	if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB)
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+		(get_cpu_type() == MESON_CPU_MAJOR_ID_TXL))
 		super_scaler = 1;
 	else
 		super_scaler = 0;
diff --git a/drivers/amlogic/amports/vpp.h b/drivers/amlogic/amports/vpp.h
index 3fab111..3e35c16 100644
--- a/drivers/amlogic/amports/vpp.h
+++ b/drivers/amlogic/amports/vpp.h
@@ -264,7 +264,7 @@ extern void vpp2_set_zoom_ratio(u32 r);
 extern u32 vpp2_get_zoom_ratio(void);
 #endif
 
-extern int vpp_set_super_sclaer_regs(int scaler_path_sel,
+extern int vpp_set_super_scaler_regs(int scaler_path_sel,
 		int reg_srscl0_enable,
 		int reg_srscl0_hsize,
 		int reg_srscl0_vsize,
diff --git a/drivers/amlogic/amports/vreal.c b/drivers/amlogic/amports/vreal.c
index 822d3ee..fdf9468 100644
--- a/drivers/amlogic/amports/vreal.c
+++ b/drivers/amlogic/amports/vreal.c
@@ -512,7 +512,7 @@ static void vreal_canvas_init(void)
 	u32 canvas_width, canvas_height;
 	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
 	u32 disp_addr = 0xffffffff;
-
+	u32 buff_off = 0;
 	if (buf_size <= 0x00400000) {
 		/* SD only */
 		canvas_width = 768;
@@ -522,11 +522,49 @@ static void vreal_canvas_init(void)
 		decbuf_size = 0x100000;
 	} else {
 		/* HD & SD */
-		canvas_width = 1920;
+	#if 1
+		int w = vreal_amstream_dec_info.width;
+		int h = vreal_amstream_dec_info.height;
+		int align_w, align_h;
+		int max, min;
+		align_w = ALIGN(w, 64);
+		align_h = ALIGN(h, 64);
+		if (align_w > align_h) {
+			max = align_w;
+			min = align_h;
+		} else {
+			canvas_width = 1920;
+			canvas_height = 1088;
+			max = align_h;
+			min = align_w;
+		}
+		/* HD & SD */
+		if ((max > 1920 || min > 1088) &&
+			ALIGN(align_w * align_h * 3/2, SZ_64K) * 9 <=
+			buf_size) {
+			canvas_width = align_w;
+			canvas_height = align_h;
+			decbuf_y_size = ALIGN(align_w * align_h, SZ_64K);
+			decbuf_uv_size = ALIGN(align_w * align_h/4, SZ_64K);
+			decbuf_size = ALIGN(align_w * align_h * 3/2, SZ_64K);
+		} else { /*1080p*/
+			if (h > w) {
+				canvas_width = 1088;
+				canvas_height = 1920;
+			} else {
+				canvas_width = 1920;
+				canvas_height = 1088;
+			}
+			decbuf_y_size = 0x200000;
+			decbuf_uv_size = 0x80000;
+			decbuf_size = 0x300000;
+		}
+		#endif
+	/*	canvas_width = 1920;
 		canvas_height = 1088;
 		decbuf_y_size = 0x200000;
 		decbuf_uv_size = 0x80000;
-		decbuf_size = 0x300000;
+		decbuf_size = 0x300000;*/
 	}
 
 	if (is_vpp_postblend()) {
@@ -538,61 +576,57 @@ static void vreal_canvas_init(void)
 	}
 
 	for (i = 0; i < 4; i++) {
-		if (((buf_start + i * decbuf_size + 7) >> 3) == disp_addr) {
-#ifdef NV21
-			canvas_config(2 * i + 0,
-				buf_start + 4 * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(2 * i + 1,
-				buf_start + 4 * decbuf_size +
-				decbuf_y_size, canvas_width,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-#else
-			canvas_config(3 * i + 0,
-				buf_start + 4 * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 1,
-				buf_start + 4 * decbuf_size +
-				decbuf_y_size, canvas_width / 2,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 2,
-				buf_start + 4 * decbuf_size +
-				decbuf_y_size + decbuf_uv_size,
-				canvas_width / 2, canvas_height / 2,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-#endif
-		} else {
-#ifdef NV21
-			canvas_config(2 * i + 0,
-				buf_start + i * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(2 * i + 1,
-				buf_start + i * decbuf_size +
-				decbuf_y_size, canvas_width,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-#else
-			canvas_config(3 * i + 0,
-				buf_start + i * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 1,
-				buf_start + i * decbuf_size +
-				decbuf_y_size, canvas_width / 2,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 2,
-				buf_start + i * decbuf_size +
-				decbuf_y_size + decbuf_uv_size,
-				canvas_width / 2, canvas_height / 2,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-#endif
+		u32 one_buf_start = buf_start + buff_off;
+		if (((one_buf_start + 7) >> 3) == disp_addr) {
+			/*last disp buffer, to next..*/
+			buff_off += decbuf_size;
+			one_buf_start = buf_start + buff_off;
+			pr_info("one_buf_start %d,=== %x disp_addr %x",
+				i, one_buf_start, disp_addr);
+		}
+		if (buff_off < 0x01000000 &&
+			buff_off + decbuf_size > 0x0f00000){
+			/*0x01b00000 is references buffer.
+			to next 16M;*/
+			buff_off = 16 * SZ_1M;/*next 16M*/
+			one_buf_start = buf_start + buff_off;
+		}
+		if (buff_off + decbuf_size > buf_size) {
+			pr_err("ERROR::too small buffer for buf%d %d x%d ,size =%d\n",
+				i,
+				canvas_width,
+				canvas_height,
+				buf_size);
 		}
+		pr_info("alloced buffer %d at %x,%d\n",
+				i, one_buf_start, decbuf_size);
+ #ifdef NV21
+		canvas_config(2 * i + 0,
+			one_buf_start,
+			canvas_width, canvas_height,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(2 * i + 1,
+			one_buf_start +
+			decbuf_y_size, canvas_width,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_32X32);
+ #else
+		canvas_config(3 * i + 0,
+			one_buf_start,
+			canvas_width, canvas_height,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(3 * i + 1,
+			one_buf_start +
+			decbuf_y_size, canvas_width / 2,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_32X32);
+		canvas_config(3 * i + 2,
+			one_buf_start +
+			decbuf_y_size + decbuf_uv_size,
+			canvas_width / 2, canvas_height / 2,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+ #endif
+		buff_off = buff_off + decbuf_size;
 	}
 }
 
@@ -952,7 +986,7 @@ static struct platform_driver amvdec_real_driver = {
 
 static struct codec_profile_t amvdec_real_profile = {
 	.name = "real",
-	.profile = "rmvb,"
+	.profile = "rmvb,1080p+"
 };
 
 static int __init amvdec_real_driver_init_module(void)
diff --git a/drivers/amlogic/amports/vvc1.c b/drivers/amlogic/amports/vvc1.c
index 991bae1..689b19c 100644
--- a/drivers/amlogic/amports/vvc1.c
+++ b/drivers/amlogic/amports/vvc1.c
@@ -389,6 +389,8 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 
 		if (frm.state != RATE_MEASURE_DONE)
 			frm.num += (repeat_count > 1) ? repeat_count : 1;
+		if (0 == vvc1_amstream_dec_info.rate)
+			vvc1_amstream_dec_info.rate = PTS2DUR(frm.rate);
 
 		if (reg & INTERLACE_FLAG) {	/* interlace */
 			if (kfifo_get(&newframe_q, &vf) == 0) {
@@ -505,7 +507,7 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 
 			vf->duration_pulldown = 0;
 			vf->type = (reg & BOTTOM_FIELD_FIRST_FLAG) ?
-			VIDTYPE_INTERLACE_BOTTOM : VIDTYPE_INTERLACE_TOP;
+			VIDTYPE_INTERLACE_TOP : VIDTYPE_INTERLACE_BOTTOM;
 #ifdef NV21
 			vf->type |= VIDTYPE_VIU_NV21;
 #endif
diff --git a/drivers/amlogic/amports/vvp9.c b/drivers/amlogic/amports/vvp9.c
index d129327..822f65c 100644
--- a/drivers/amlogic/amports/vvp9.c
+++ b/drivers/amlogic/amports/vvp9.c
@@ -198,6 +198,7 @@ static u32 frame_width;
 static u32 frame_height;
 static u32 video_signal_type;
 static u32 pts_unstable;
+static u32 on_no_keyframe_skiped;
 
 
 #define PROB_SIZE    (496 * 2 * 4)
@@ -1159,10 +1160,11 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 
 	if (pbi->has_keyframe == 0 &&
 		params->p.frame_type != KEY_FRAME){
+		on_no_keyframe_skiped++;
 		return -2;
 	}
 	pbi->has_keyframe = 1;
-
+	on_no_keyframe_skiped = 0;
 #ifdef VP9_10B_MMU
 	if (cm->prev_fb_idx >= 0) {
 		long used_4k_num = (READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
@@ -2039,7 +2041,6 @@ static  int  compute_losless_comp_header_size(int width, int height)
 
 static void init_buff_spec(struct BuffInfo_s *buf_spec)
 {
-	void *mem_start_virt;
 	buf_spec->ipp.buf_start = buf_spec->start_adr;
 	buf_spec->sao_abv.buf_start =
 		buf_spec->ipp.buf_start + buf_spec->ipp.buf_size;
@@ -2104,11 +2105,6 @@ static void init_buff_spec(struct BuffInfo_s *buf_spec)
 				buf_spec->rpm.buf_size;
 		}
 	}
-	mem_start_virt = codec_mm_phys_to_virt(buf_spec->dblk_para.buf_start);
-	if (mem_start_virt)
-		memset(mem_start_virt, 0, buf_spec->dblk_para.buf_size);
-	else
-		pr_err("mem_start_virt failed\n");
 
 	if (debug) {
 		pr_info("%s workspace (%x %x) size = %x\n", __func__,
@@ -5570,6 +5566,7 @@ static int vvp9_local_init(struct VP9Decoder_s *pbi)
 #endif
 	pbi->saved_resolution = 0;
 	pbi->get_frame_dur = false;
+	on_no_keyframe_skiped = 0;
 	width = pbi->vvp9_amstream_dec_info.width;
 	height = pbi->vvp9_amstream_dec_info.height;
 	pbi->frame_dur =
@@ -5979,6 +5976,9 @@ MODULE_PARM_DESC(force_fps, "\n force_fps\n");
 module_param(max_decoding_time, uint, 0664);
 MODULE_PARM_DESC(max_decoding_time, "\n max_decoding_time\n");
 
+module_param(on_no_keyframe_skiped, uint, 0664);
+MODULE_PARM_DESC(on_no_keyframe_skiped, "\n on_no_keyframe_skiped\n");
+
 module_init(amvdec_vp9_driver_init_module);
 module_exit(amvdec_vp9_driver_remove_module);
 
diff --git a/drivers/amlogic/amvecm/amcm.c b/drivers/amlogic/amvecm/amcm.c
index b173013..5005d45 100644
--- a/drivers/amlogic/amvecm/amcm.c
+++ b/drivers/amlogic/amvecm/amcm.c
@@ -48,6 +48,10 @@ int cm_en = 0;/* 0:disabel;1:enable */
 module_param(cm_en, int, 0664);
 MODULE_PARM_DESC(cm_en, "\n enable or disable cm\n");
 
+static unsigned int cm_width_limit = 50;/* vlsi adjust */
+module_param(cm_width_limit, uint, 0664);
+MODULE_PARM_DESC(cm_width_limit, "\n cm_width_limit\n");
+
 #if 0
 struct cm_region_s cm_region;
 struct cm_top_s    cm_top;
@@ -132,6 +136,14 @@ void am_set_regmap(struct am_regs_s *p)
 				} else
 					cm2_patch_flag = 0;
 			}
+			/* add for cm patch size config */
+			if ((p->am_reg[i].addr == 0x205) ||
+				(p->am_reg[i].addr == 0x209) ||
+				(p->am_reg[i].addr == 0x20a)) {
+				pr_amcm_dbg("[amcm]:%s REG_TYPE_INDEX_VPPCHROMA addr:0x%x",
+					__func__, p->am_reg[i].addr);
+				break;
+			}
 			WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT,
 					p->am_reg[i].addr);
 			if (p->am_reg[i].mask == 0xffffffff)
@@ -241,14 +253,14 @@ void amcm_level_sel(unsigned int cm_level)
 void cm2_frame_size_patch(unsigned int width, unsigned int height)
 {
 	unsigned int vpp_size;
+	if (width < cm_width_limit)
+		amcm_disable();
+	else if (cm_en)
+		amcm_enable();
 	/*check if the cm2 enable/disable to config the cm2 size*/
 	if (!(READ_VPP_REG(VPP_MISC)&(0x1<<28)))
 		return;
 	vpp_size = width|(height << 16);
-	if (cm_size == 0) {
-		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x205);
-		cm_size = READ_VPP_REG(VPP_CHROMA_DATA_PORT);
-	}
 	if (cm_size != vpp_size) {
 		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x205);
 		WRITE_VPP_REG(VPP_CHROMA_DATA_PORT, vpp_size);
diff --git a/drivers/amlogic/amvecm/amcsc.c b/drivers/amlogic/amvecm/amcsc.c
index a54467d..3209eaf 100644
--- a/drivers/amlogic/amvecm/amcsc.c
+++ b/drivers/amlogic/amvecm/amcsc.c
@@ -124,6 +124,25 @@ static bool skip_csc_en;
 module_param(skip_csc_en, bool, 0664);
 MODULE_PARM_DESC(skip_csc_en, "\n skip_csc_en\n");
 
+/* white balance adjust */
+static bool cur_eye_protect_mode;
+
+static int num_wb_val = 10;
+static int wb_val[10] = {
+	0, /* wb enable */
+	0, /* -1024~1023, r_pre_offset */
+	0, /* -1024~1023, g_pre_offset */
+	0, /* -1024~1023, b_pre_offset */
+	1024, /* 0~2047, r_gain */
+	1024, /* 0~2047, g_gain */
+	1024, /* 0~2047, b_gain */
+	0, /* -1024~1023, r_post_offset */
+	0, /* -1024~1023, g_post_offset */
+	0  /* -1024~1023, b_post_offset */
+};
+module_param_array(wb_val, int, &num_wb_val, 0664);
+MODULE_PARM_DESC(wb_val, "\n white balance setting\n");
+
 static enum vframe_source_type_e pre_src_type = VFRAME_SOURCE_TYPE_COMP;
 static uint cur_csc_type = 0xffff;
 module_param(cur_csc_type, uint, 0444);
@@ -829,9 +848,9 @@ static int YUV709f_to_YUV709l_coeff[MATRIX_5x3_COEF_SIZE] = {
 	0, 0, 0 /* mode, right_shift, clip_en */
 };
 
-#if 0
+
 static int YUV709l_to_RGB709_coeff[MATRIX_5x3_COEF_SIZE] = {
-	0, -512, -512, /* pre offset */
+	-64, -512, -512, /* pre offset */
 	COEFF_NORM(1.16895),	COEFF_NORM(0.00000),	COEFF_NORM(1.79977),
 	COEFF_NORM(1.16895),	COEFF_NORM(-0.21408),	COEFF_NORM(-0.53500),
 	COEFF_NORM(1.16895),	COEFF_NORM(2.12069),	COEFF_NORM(0.00000),
@@ -841,6 +860,7 @@ static int YUV709l_to_RGB709_coeff[MATRIX_5x3_COEF_SIZE] = {
 	0, 0, 0 /* mode, right_shift, clip_en */
 };
 
+#if 0
 /*  eotf matrix: RGB2020 to RGB709 */
 static int eotf_RGB2020_to_RGB709_coeff[EOTF_COEFF_SIZE] = {
 	EOTF_COEFF_NORM(1.6607056/2), EOTF_COEFF_NORM(-0.5877533/2),
@@ -1898,6 +1918,7 @@ static struct vframe_master_display_colour_s cur_master_display_colour = {
 #define SIG_KNEE_FACTOR	0x08
 #define SIG_HDR_MODE	0x10
 #define SIG_HDR_SUPPORT	0x20
+#define SIG_WB_CHG	0x40
 int signal_type_changed(struct vframe_s *vf, struct vinfo_s *vinfo)
 {
 	u32 signal_type = 0;
@@ -2010,6 +2031,12 @@ int signal_type_changed(struct vframe_s *vf, struct vinfo_s *vinfo)
 		cur_hdr_support = vinfo->hdr_info.hdr_support & 0x4;
 	}
 
+	if ((cur_eye_protect_mode != wb_val[0]) ||
+		(cur_eye_protect_mode == 1)) {
+		pr_csc(" eye protect mode changed.\n");
+		change_flag |= SIG_WB_CHG;
+	}
+
 	return change_flag;
 }
 
@@ -2225,30 +2252,69 @@ static int check_primaries(
 	int need_calculate_mtx = 0;
 	const struct master_display_info_s *d;
 
-	/* check source */
-	for (i = 0; i < 3; i++) {
-		for (j = 0; j < 2; j++) {
-			(*si)[i][j] = (*p)[(i + 2) % 3][j];
+	/* check and copy primaries */
+	if (((*p)[0][1] > (*p)[1][1])
+		&& ((*p)[0][1] > (*p)[2][1])
+		&& ((*p)[2][0] > (*p)[0][0])
+		&& ((*p)[2][0] > (*p)[1][0])) {
+		/* reasonable g,b,r */
+		for (i = 0; i < 3; i++)
+			for (j = 0; j < 2; j++) {
+				(*si)[i][j] = (*p)[(i + 2) % 3][j];
 			if ((*si)[i][j] != bt2020_primaries[(i + 2) % 3][j])
 				need_calculate_mtx = 1;
-		}
-	}
-	for (i = 0; i < 2; i++) {
-		(*si)[3][i] = (*w)[i];
-		if ((*si)[3][i] != bt2020_white_point[i])
-			need_calculate_mtx = 1;
+			}
+	} else if (((*p)[0][0] > (*p)[1][0])
+		&& ((*p)[0][0] > (*p)[2][0])
+		&& ((*p)[1][1] > (*p)[0][1])
+		&& ((*p)[1][1] > (*p)[2][1])) {
+		/* reasonable r,g,b */
+		for (i = 0; i < 3; i++)
+			for (j = 0; j < 2; j++) {
+				(*si)[i][j] = (*p)[i][j];
+			if ((*si)[i][j] != bt2020_primaries[(i + 2) % 3][j])
+				need_calculate_mtx = 1;
+			}
+	} else {
+		/* source not usable, use standard bt2020 */
+		for (i = 0; i < 3; i++)
+			for (j = 0; j < 2; j++)
+				(*si)[i][j] = bt2020_primaries[(i + 2) % 3][j];
 	}
 
-	if (((*si)[0][0] == 0) &&
-		((*si)[0][1] == 0) &&
-		((*si)[1][0] == 0) &&
-		((*si)[1][1] == 0) &&
-		((*si)[2][0] == 0) &&
-		((*si)[2][1] == 0) &&
-		((*si)[3][0] == 0) &&
-		((*si)[3][0] == 0))
-		/* if primaries is 0, set default mtx*/
-		need_calculate_mtx = 0;
+	/* check white point */
+	if (need_calculate_mtx == 1) {
+		if (((*w)[0] > (*si)[2][0]) &&
+			((*w)[0] < (*si)[0][0]) &&
+			((*w)[1] > (*si)[2][1]) &&
+			((*w)[1] < (*si)[1][1])) {
+				for (i = 0; i < 2; i++)
+					(*si)[3][i] = (*w)[i];
+		} else {
+			for (i = 0; i < 3; i++)
+				for (j = 0; j < 2; j++)
+					(*si)[i][j] =
+				bt2020_primaries[(i + 2) % 3][j];
+
+			for (i = 0; i < 2; i++)
+				(*si)[3][i] = bt2020_white_point[i];
+			need_calculate_mtx = 0;
+		}
+	} else {
+		if (((*w)[0] > (*si)[2][0]) &&
+			((*w)[0] < (*si)[0][0]) &&
+			((*w)[1] > (*si)[2][1]) &&
+			((*w)[1] < (*si)[1][1])) {
+			for (i = 0; i < 2; i++) {
+				(*si)[3][i] = (*w)[i];
+				if ((*si)[3][i] != bt2020_white_point[i])
+					need_calculate_mtx = 1;
+			}
+		} else {
+			for (i = 0; i < 2; i++)
+				(*si)[3][i] = bt2020_white_point[i];
+		}
+	}
 
 	/* check display */
 	if (v->master_display_info.present_flag) {
@@ -2525,11 +2591,15 @@ static int hdr_process(
 			oetf_289_hlg_mapping,
 			CSC_ON);
 
-		/* xvycc matrix RGB709 to YUV709 limit */
-		set_vpp_matrix(VPP_MATRIX_XVYCC,
-			RGB709_to_YUV709l_coeff,
-			CSC_ON);
-
+		/* xvyccc matrix3: bypass */
+		if (vinfo->viu_color_fmt != TVIN_RGB444)
+			set_vpp_matrix(VPP_MATRIX_XVYCC,
+				RGB709_to_YUV709l_coeff,
+				CSC_ON);
+		else /* xvycc matrix bypass for LCD */
+			set_vpp_matrix(VPP_MATRIX_XVYCC,
+				bypass_coeff,
+				CSC_ON);
 		/* not adjust contrast in gxl for now */
 		need_adjust_contrast = 0;
 	} else {
@@ -2610,10 +2680,15 @@ static void bypass_hdr_process(
 		}
 
 		/* post matrix bypass */
-		set_vpp_matrix(VPP_MATRIX_POST,
-			bypass_coeff,
-			CSC_ON);
-
+		if (vinfo->viu_color_fmt != TVIN_RGB444)
+			/* yuv2rgb for eye protect mode */
+			set_vpp_matrix(VPP_MATRIX_POST,
+				bypass_coeff,
+				CSC_ON);
+		else /* matrix yuv2rgb for LCD */
+			set_vpp_matrix(VPP_MATRIX_POST,
+				YUV709l_to_RGB709_coeff,
+				CSC_ON);
 		/* eotf lut bypass */
 		set_vpp_lut(VPP_LUT_EOTF,
 			eotf_33_linear_mapping, /* R */
@@ -2666,6 +2741,47 @@ static void bypass_hdr_process(
 	}
 }
 
+static int vpp_eye_protection_process(
+	enum vpp_matrix_csc_e csc_type,
+	struct vinfo_s *vinfo)
+{
+	cur_eye_protect_mode = wb_val[0];
+	memcpy(&video_rgb_ogo, wb_val,
+		sizeof(struct tcon_rgb_ogo_s));
+	ve_ogo_param_update();
+
+	/* only SDR need switch csc */
+	if ((csc_type == VPP_MATRIX_BT2020YUV_BT2020RGB) &&
+			hdr_process_mode)
+		return 0;
+
+	/* post matrix bypass */
+	if ((vinfo->viu_color_fmt != TVIN_RGB444) &&
+		(cur_eye_protect_mode == 0))
+		/* yuv2rgb for eye protect mode */
+		set_vpp_matrix(VPP_MATRIX_POST,
+			bypass_coeff,
+			CSC_ON);
+	else /* matrix yuv2rgb for LCD */
+		set_vpp_matrix(VPP_MATRIX_POST,
+			YUV709l_to_RGB709_coeff,
+			CSC_ON);
+
+	/* xvycc matrix bypass */
+	if ((vinfo->viu_color_fmt != TVIN_RGB444) &&
+		(cur_eye_protect_mode == 1))
+		/*  for eye protect mode */
+		set_vpp_matrix(VPP_MATRIX_XVYCC,
+			RGB709_to_YUV709l_coeff,
+			CSC_ON);
+	else /* matrix yuv2rgb for LCD */
+		set_vpp_matrix(VPP_MATRIX_XVYCC,
+			bypass_coeff,
+			CSC_ON);
+
+	return 0;
+}
+
 static void vpp_matrix_update(struct vframe_s *vf)
 {
 	struct vinfo_s *vinfo;
@@ -2776,6 +2892,11 @@ static void vpp_matrix_update(struct vframe_s *vf)
 			cur_csc_type = csc_type;
 		}
 	}
+
+	/* eye protection mode */
+	if (signal_change_flag & SIG_WB_CHG)
+		vpp_eye_protection_process(csc_type, vinfo);
+
 	vecm_latch_flag &= ~FLAG_MATRIX_UPDATE;
 }
 
@@ -2812,24 +2933,27 @@ void amvecm_matrix_process(struct vframe_s *vf)
 					CSC_ON);
 	}
 
-	if (vf == last_vf)
+	if ((vf == last_vf) &&
+		(cur_eye_protect_mode == wb_val[0]))
 		return;
 
-	/* debug vframe info backup */
-	dbg_vf = vf;
-
 	if (vf != NULL) {
 		vpp_matrix_update(vf);
 		last_vf = vf;
 		null_vf_cnt = 0;
 		fg_vf_sw_dbg = 1;
+
+		/* debug vframe info backup */
+		dbg_vf = vf;
 	} else {
 		/* check last signal type */
 		if ((last_vf != NULL) &&
 			((last_vf->signal_type >> 16) & 0xff) == 9)
 			null_vf_cnt++;
-		if (((READ_VPP_REG(VPP_MISC) & (1<<10)) == 0)
-			&& (null_vf_cnt > null_vf_max)) {
+
+		if ((((READ_VPP_REG(VPP_MISC) & (1<<10)) == 0)
+			&& (null_vf_cnt > null_vf_max)) ||
+			(cur_eye_protect_mode != wb_val[0])) {
 			/* send a faked vframe to switch matrix
 			   from 2020 to 601 when video disabled */
 			fake_vframe.source_type = VFRAME_SOURCE_TYPE_OTHERS;
@@ -2846,13 +2970,18 @@ void amvecm_matrix_process(struct vframe_s *vf)
 	}
 }
 
-int amvecm_hdr_dbg(void)
+int amvecm_hdr_dbg(u32 sel)
 {
 	int i, j;
 
+	/* select debug information */
+	if (sel == 1) /* dump reg */
+		goto reg_dump;
+
 	if (dbg_vf == NULL)
 		goto hdr_dump;
-	pr_err("\n----vframe info----\n");
+
+	pr_err("----vframe info----\n");
 	pr_err("index:%d, type:0x%x, type_backup:0x%x, blend_mode:%d\n",
 		dbg_vf->index, dbg_vf->type,
 		dbg_vf->type_backup, dbg_vf->blend_mode);
@@ -2914,123 +3043,125 @@ int amvecm_hdr_dbg(void)
 		dbg_vf->pixel_ratio, &dbg_vf->list,
 		dbg_vf->ready_jiffies64, dbg_vf->frame_dirty);
 
-	pr_err("\n----Source HDR info----\n");
-	pr_err("\t\tsignal_type:0x%x, present_flag:%d\n",
+	pr_err("----Source HDR info----\n");
+	pr_err("\tsignal_type:0x%x, present_flag:%d\n",
 		dbg_vf->signal_type,
 		dbg_vf->prop.master_display_colour.present_flag);
 	for (i = 0; i < 3; i++)
 		for (j = 0; j < 2; j++)
 			pr_err(
-				"\t\tprimaries[%1d][%1d] = %04x\n",
+				"\tprimaries[%1d][%1d] = %04x\n",
 			i, j,
 			dbg_vf->prop.master_display_colour.primaries[i][j]);
-	pr_err("\t\twhite_point = (%04x, %04x)\n",
+	pr_err("\twhite_point = (%04x, %04x)\n",
 		dbg_vf->prop.master_display_colour.white_point[0],
 		dbg_vf->prop.master_display_colour.white_point[1]);
-	pr_err("\t\tmax,min luminance = %08x, %08x\n",
+	pr_err("\tmax,min luminance = %08x, %08x\n",
 		dbg_vf->prop.master_display_colour.luminance[0],
 		dbg_vf->prop.master_display_colour.luminance[1]);
 hdr_dump:
-	pr_err("\n----HDR process info----\n");
+	pr_err("----HDR process info----\n");
 
-	pr_err("hdr_mode:%d, hdr_process_mode:%d, force_csc_type:0x%x\n",
+	pr_err("hdr_mode:0x%x, hdr_process_mode:0x%x, force_csc_type:0x%x\n",
 		hdr_mode, hdr_process_mode, force_csc_type);
 	pr_err("cur_signal_type:0x%x, cur_csc_mode:0x%x, cur_csc_type:0x%x\n",
 		cur_signal_type, cur_csc_mode, cur_csc_type);
 
-	pr_err("knee_lut_on:%d,knee_interpolation_mode:%d,cur_knee_factor:%d\n",
+	pr_err("knee_lut_on:0x%x,knee_interpolation_mode:0x%x,cur_knee_factor:0x%x\n",
 		knee_lut_on, knee_interpolation_mode, cur_knee_factor);
-	pr_err("fg_vf_sw_dbg: %d\n", fg_vf_sw_dbg);
+	pr_err("fg_vf_sw_dbg: 0x%x\n", fg_vf_sw_dbg);
 
-	pr_err("\n----TV EDID info----\n");
+	pr_err("----TV EDID info----\n");
 	pr_err("hdr_support:0x%x,lumi_max:%d,lumi_avg:%d,lumi_min:%d\n",
 		receiver_hdr_info.hdr_support,
 		receiver_hdr_info.lumi_max,
 		receiver_hdr_info.lumi_avg,
 		receiver_hdr_info.lumi_min);
 
-	pr_err("\n----Tx HDR package info----\n");
-	pr_err("\t\t features = 0x%08x\n", dbg_hdr_send.features);
+	pr_err("----Tx HDR package info----\n");
+	pr_err("\tfeatures = 0x%08x\n", dbg_hdr_send.features);
 	for (i = 0; i < 3; i++)
 		for (j = 0; j < 2; j++)
 			pr_err(
-				"\t\tprimaries[%1d][%1d] = %04x\n",
+				"\tprimaries[%1d][%1d] = %04x\n",
 				i, j,
 				dbg_hdr_send.primaries[i][j]);
-	pr_err("\t\twhite_point = (%04x, %04x)\n",
+	pr_err("\twhite_point = (%04x, %04x)\n",
 		dbg_hdr_send.white_point[0],
 		dbg_hdr_send.white_point[1]);
-	pr_err("\t\tmax,min luminance = %08x, %08x\n",
+	pr_err("\tmax,min luminance = %08x, %08x\n",
 		dbg_hdr_send.luminance[0], dbg_hdr_send.luminance[1]);
 
+	goto dbg_end;
+
 	/************************dump reg start***************************/
-	pr_err("\n----dump regs----\n");
+reg_dump:
 
 	/* osd matrix, VPP_MATRIX_0 */
-	pr_err("\n----dump regs VPP_MATRIX_OSD----\n");
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("----dump regs VPP_MATRIX_OSD----\n");
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_PRE_OFFSET0_1,
 		READ_VPP_REG(VIU_OSD1_MATRIX_PRE_OFFSET0_1));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_PRE_OFFSET2,
 		READ_VPP_REG(VIU_OSD1_MATRIX_PRE_OFFSET2));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COEF00_01,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COEF00_01));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COEF02_10,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COEF02_10));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COEF11_12,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COEF11_12));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COEF20_21,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COEF20_21));
 
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COEF22_30,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COEF22_30));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COEF31_32,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COEF31_32));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COEF40_41,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COEF40_41));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COLMOD_COEF42,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COLMOD_COEF42));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COEF22_30,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COEF22_30));
 
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_OFFSET0_1,
 		READ_VPP_REG(VIU_OSD1_MATRIX_OFFSET0_1));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_OFFSET2,
 		READ_VPP_REG(VIU_OSD1_MATRIX_OFFSET2));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COLMOD_COEF42,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COLMOD_COEF42));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_COLMOD_COEF42,
 		READ_VPP_REG(VIU_OSD1_MATRIX_COLMOD_COEF42));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_PRE_OFFSET0_1,
 		READ_VPP_REG(VIU_OSD1_MATRIX_PRE_OFFSET0_1));
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_MATRIX_CTRL,
 		READ_VPP_REG(VIU_OSD1_MATRIX_CTRL));
 
 	/* osd eotf matrix, VPP_MATRIX_OSD_EOTF */
-	pr_err("\n----dump regs VPP_MATRIX_OSD_EOTF----\n");
+	pr_err("----dump regs VPP_MATRIX_OSD_EOTF----\n");
 
 	for (i = 0; i < 5; i++)
-		pr_err("\t\taddr = %08x, val = %08x\n",
+		pr_err("\taddr = %08x, val = %08x\n",
 			(VIU_OSD1_EOTF_CTL + i + 1),
 			READ_VPP_REG(VIU_OSD1_EOTF_CTL + i + 1));
 
-	pr_err("\t\taddr = %08x, val = %08x\n",
+	pr_err("\taddr = %08x, val = %08x\n",
 		VIU_OSD1_EOTF_CTL,
 		READ_VPP_REG(VIU_OSD1_EOTF_CTL));
 
@@ -3044,7 +3175,7 @@ hdr_dump:
 		unsigned int data;
 		int i;
 
-		pr_err("\n----dump regs VPP_LUT_OSD_OETF----\n");
+		pr_err("----dump regs VPP_LUT_OSD_OETF----\n");
 
 		addr_port = VIU_OSD1_OETF_LUT_ADDR_PORT;
 		data_port = VIU_OSD1_OETF_LUT_DATA_PORT;
@@ -3076,12 +3207,11 @@ hdr_dump:
 			pr_err("\t[%d] = 0x%04x 0x%04x 0x%04x\n",
 				i, r_map[i], g_map[i], b_map[i]);
 		}
-		pr_err("\n");
 
 		addr_port = VIU_OSD1_EOTF_LUT_ADDR_PORT;
 		data_port = VIU_OSD1_EOTF_LUT_DATA_PORT;
 		ctrl_port = VIU_OSD1_EOTF_CTL;
-		pr_err("\n----dump regs VPP_LUT_OSD_EOTF----\n");
+		pr_err("----dump regs VPP_LUT_OSD_EOTF----\n");
 		WRITE_VPP_REG(addr_port, 0);
 		for (i = 0; i < 16; i++) {
 			data = READ_VPP_REG(data_port);
@@ -3108,8 +3238,8 @@ hdr_dump:
 			pr_err("\t[%d] = 0x%04x 0x%04x 0x%04x\n",
 				i, r_map[i], g_map[i], b_map[i]);
 		}
-		pr_err("\n");
-		pr_err("\n----dump hdr_osd_reg----\n");
+
+		pr_err("----dump hdr_osd_reg----\n");
 
 		pr_err("\tviu_osd1_matrix_ctrl = 0x%04x\n",
 				hdr_osd_reg.viu_osd1_matrix_ctrl);
@@ -3169,5 +3299,7 @@ hdr_dump:
 		pr_err("\n");
 	}
 	/*********************dump reg end*********************/
+dbg_end:
+
 	return 0;
 }
diff --git a/drivers/amlogic/amvecm/amcsc.h b/drivers/amlogic/amvecm/amcsc.h
index 59397bb..482a855 100644
--- a/drivers/amlogic/amvecm/amcsc.h
+++ b/drivers/amlogic/amvecm/amcsc.h
@@ -19,6 +19,10 @@
 #ifndef AM_CSC_H
 #define AM_CSC_H
 
+/* white balance value */
+extern void ve_ogo_param_update(void);
+extern struct tcon_rgb_ogo_s video_rgb_ogo;
+
 enum vpp_matrix_sel_e {
 	VPP_MATRIX_0 = 0,	/* OSD convert matrix - new from GXL */
 	VPP_MATRIX_1,		/* vd1 matrix before post-blend */
@@ -95,7 +99,7 @@ extern unsigned int vecm_latch_flag;
 extern signed int vd1_contrast_offset;
 
 extern void amvecm_matrix_process(struct vframe_s *vf);
-extern int amvecm_hdr_dbg(void);
+extern int amvecm_hdr_dbg(u32 sel);
 
 /* use osd rdma w/r */
 u32 VSYNCOSD_RD_MPEG_REG(u32 reg);
diff --git a/drivers/amlogic/amvecm/amve.c b/drivers/amlogic/amvecm/amve.c
index 622e791..000b96d 100644
--- a/drivers/amlogic/amvecm/amve.c
+++ b/drivers/amlogic/amvecm/amve.c
@@ -149,6 +149,10 @@ static int ve_dnlp_hghrange = 18;
 module_param(ve_dnlp_hghrange, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_hghrange, "ve_dnlp_hghrange");
 
+static int ve_dnlp_auto_rng;
+module_param(ve_dnlp_auto_rng, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_auto_rng, "ve_dnlp_auto_rng");
+
 static int ve_dnlp_lowalpha = 24;
 module_param(ve_dnlp_lowalpha, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_lowalpha, "ve_dnlp_lowalpha");
@@ -203,7 +207,7 @@ module_param(ve_dnlp_gmma_rate, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_gmma_rate,
 		"ve_dnlp_gmma_rate");
 
-static int ve_dnlp_lowalpha_new = 20;
+static int ve_dnlp_lowalpha_new = 40;
 module_param(ve_dnlp_lowalpha_new, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_lowalpha_new,
 		"ve_dnlp_lowalpha_new");
@@ -213,7 +217,7 @@ module_param(ve_dnlp_hghalpha_new, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_hghalpha_new,
 		"ve_dnlp_hghalpha_new");
 
-static int ve_dnlp_cliprate_new = 6;
+static int ve_dnlp_cliprate_new = 36;
 module_param(ve_dnlp_cliprate_new, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_cliprate_new,
 		"ve_dnlp_cliprate_new");
@@ -238,9 +242,15 @@ static int ve_mtdbld_rate = 53;
 module_param(ve_mtdbld_rate, int, 0664);
 MODULE_PARM_DESC(ve_mtdbld_rate, "ve_mtdbld_rate");
 
+/*
 static int ve_blkgma_rate = 16;
 module_param(ve_blkgma_rate, int, 0664);
 MODULE_PARM_DESC(ve_blkgma_rate, "ve_blkgma_rate");
+*/
+
+static int ve_dnlp_pst_gmarat = 65;
+module_param(ve_dnlp_pst_gmarat, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_pst_gmarat, "ve_dnlp_pst_gmarat");
 
 /*dnlp method = 3, use this flag or no use*/
 bool ve_dnlp_respond_flag;
@@ -327,35 +337,103 @@ module_param(ve_dnlp_lownum, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_lownum, "the number of low bins");
 
 /* black gamma end point setting */
-static int ve_dnlp_bkgend = 20;
+static int ve_dnlp_bkgend;
 module_param(ve_dnlp_bkgend, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_bkgend, "black gamma end point setting");
 
 /* black gamma end point rate */
-static int ve_dnlp_bkgert = 4;
+static int ve_dnlp_bkgert = 64;
 module_param(ve_dnlp_bkgert, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_bkgert, "black gamma end point rate");
 
+static int ve_dnlp_pstgma_brghtrate = 8;
+module_param(ve_dnlp_pstgma_brghtrate, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_pstgma_brghtrate, "ve_dnlp_pstgma_brghtrate");
+
+static int ve_dnlp_pstgma_brghtrat1 = 15;
+module_param(ve_dnlp_pstgma_brghtrat1, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_pstgma_brghtrat1, "ve_dnlp_pstgma_brghtrat1");
+
 /* black extension when sum(hist) <  (ext*tAvg>>6) */
-static int ve_dnlp_blkext = 8;
+static int ve_dnlp_blkext = 4;
 module_param(ve_dnlp_blkext, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_blkext, "black extension: sum()");
 
 /* white extension when sum(hist) < (ext*tAvg>>6) */
-static int ve_dnlp_whtext = 8;
+static int ve_dnlp_whtext = 4;
 module_param(ve_dnlp_whtext, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_whtext, "white extension: sum()");
 
 /* black extension maximum bins */
-static int ve_dnlp_bextmx = 2;
+static int ve_dnlp_bextmx = 4;
 module_param(ve_dnlp_bextmx, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_bextmx, "black extension bins");
 
 /* white extension maximum bins */
-static int ve_dnlp_wextmx = 4;
+static int ve_dnlp_wextmx = 32;
 module_param(ve_dnlp_wextmx, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_wextmx, "white extension bins");
 
+static int ve_dnlp_wext_autorat = 16;
+module_param(ve_dnlp_wext_autorat, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_wext_autorat, "ve_dnlp_wext_autorat");
+
+/* adpative mtdrate low band */
+/* default=0 */
+static int ve_dnlp_adpmtd_lbnd = 19;
+module_param(ve_dnlp_adpmtd_lbnd, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_adpmtd_lbnd, "ve_dnlp_adpmtd_lbnd");
+
+/* adpative mtdrate high band */
+/* default=0 */
+static int ve_dnlp_adpmtd_hbnd = 20;
+module_param(ve_dnlp_adpmtd_hbnd, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_adpmtd_hbnd, "ve_dnlp_adpmtd_hbnd");
+
+static int ve_dnlp_adpalpha_lrate = 32;
+module_param(ve_dnlp_adpalpha_lrate, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_adpalpha_lrate, "ve_dnlp_adpalpha_lrate");
+
+static int ve_dnlp_adpalpha_hrate = 32;
+module_param(ve_dnlp_adpalpha_hrate, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_adpalpha_hrate, "ve_dnlp_adpalpha_hrate");
+
+static int ve_dnlp_set_bext;
+module_param(ve_dnlp_set_bext, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_set_bext, "ve_dnlp_set_bext");
+
+static int ve_dnlp_set_wext;
+module_param(ve_dnlp_set_wext, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_set_wext, "ve_dnlp_set_wext");
+
+static int ve_dnlp_satur_rat = 30;
+module_param(ve_dnlp_satur_rat, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_satur_rat, "ve_dnlp_satur_rat");
+
+static int ve_dnlp_satur_max = 40;
+module_param(ve_dnlp_satur_max, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_satur_max, "ve_dnlp_satur_max");
+
+static int ve_blk_prct_rng = 2;
+module_param(ve_blk_prct_rng, int, 0664);
+MODULE_PARM_DESC(ve_blk_prct_rng, "ve_blk_prct_rng");
+
+static int ve_blk_prct_max = 16;
+module_param(ve_blk_prct_max, int, 0664);
+MODULE_PARM_DESC(ve_blk_prct_max, "ve_blk_prct_max");
+
+static unsigned int ve_dnlp_set_saturtn;
+module_param(ve_dnlp_set_saturtn, uint, 0664);
+MODULE_PARM_DESC(ve_dnlp_set_saturtn, "ve_dnlp_set_saturtn");
+
+static int ve_dnlp_bin0_absmax = 16;
+module_param(ve_dnlp_bin0_absmax, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_bin0_absmax, "ve_dnlp_bin0_absmax");
+
+static int ve_dnlp_bin0_sbtmax = 128;
+module_param(ve_dnlp_bin0_sbtmax, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_bin0_sbtmax, "ve_dnlp_bin0_sbtmax");
+
 static int ve_dnlp_lrate00 = 32;
 module_param(ve_dnlp_lrate00, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_lrate00, "Clash Local Clip rate 00");
@@ -505,7 +583,7 @@ static bool ve_dnlp_limit_rng;
 module_param(ve_dnlp_limit_rng, bool, 0664);
 MODULE_PARM_DESC(ve_dnlp_limit_rng, "input limit range");
 
-static bool ve_dnlp_range_det = 1;
+static bool ve_dnlp_range_det;
 module_param(ve_dnlp_range_det, bool, 0664);
 MODULE_PARM_DESC(ve_dnlp_range_det,
 "input limit or full range detection");
@@ -523,7 +601,7 @@ MODULE_PARM_DESC(ve_dnlp_cuvbld_min,
 		"ve_dnlp_cuvbld_min");
 
 /* curveblend minimmum level */
-static int ve_dnlp_cuvbld_max = 8;
+static int ve_dnlp_cuvbld_max = 17;
 module_param(ve_dnlp_cuvbld_max, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_cuvbld_max,
 		"ve_dnlp_cuvbld_max");
@@ -540,6 +618,31 @@ module_param(ve_dnlp_dbg_map, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_dbg_map,
 		"ve_dnlp_dbg_map");
 
+static int ve_dnlp_scv_dbg;
+module_param(ve_dnlp_scv_dbg, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_scv_dbg,
+		"ve_dnlp_scv_dbg");
+
+static int ve_dnlp_cliprate_min = 19;
+module_param(ve_dnlp_cliprate_min, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_cliprate_min,
+		"ve_dnlp_cliprate_min");
+
+static int ve_dnlp_adpcrat_lbnd = 10;
+module_param(ve_dnlp_adpcrat_lbnd, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_adpcrat_lbnd,
+		"ve_dnlp_adpcrat_lbnd");
+
+static int ve_dnlp_adpcrat_hbnd = 20;
+module_param(ve_dnlp_adpcrat_hbnd, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_adpcrat_hbnd,
+		"ve_dnlp_adpcrat_hbnd");
+
+/* print log once */
+static int ve_dnlp_ponce = 1;
+module_param(ve_dnlp_ponce, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_ponce, "ve_dnlp_ponce");
+
 /* global variable */
 unsigned int iRgnBgn = 0; /* i>=iRgnBgn */
 unsigned int iRgnEnd = 64;/* i<iRgnEnd */
@@ -553,7 +656,6 @@ static bool hist_sel = 1; /*1->vpp , 0->vdin*/
 module_param(hist_sel, bool, 0664);
 MODULE_PARM_DESC(hist_sel, "hist_sel");
 
-
 static unsigned int assist_cnt;/* ASSIST_SPARE8_REG1; */
 static unsigned int assist_cnt2;/* ASSIST_SPARE8_REG2; */
 
@@ -641,6 +743,16 @@ MODULE_PARM_DESC(contrast_adj_sel, "\n contrast_adj_sel\n");
 /* *********************************************************************** */
 /* *** VPP_FIQ-oriented functions **************************************** */
 /* *********************************************************************** */
+static void ve_dnlp_add_cm(unsigned int value)
+{
+	unsigned int reg_value;
+	VSYNC_WR_MPEG_REG(VPP_CHROMA_ADDR_PORT, 0x207);
+	reg_value = VSYNC_RD_MPEG_REG(VPP_CHROMA_DATA_PORT);
+	reg_value = (reg_value & 0xf000ffff) | (value << 16);
+	VSYNC_WR_MPEG_REG(VPP_CHROMA_ADDR_PORT, 0x207);
+	VSYNC_WR_MPEG_REG(VPP_CHROMA_DATA_PORT, reg_value);
+}
+
 static void ve_hist_gamma_tgt(struct vframe_s *vf)
 {
 	int ave_luma;
@@ -1010,6 +1122,8 @@ static unsigned int pre_0_gamma[65];
 static unsigned int pst_0_gamma[65];
 
 bool dnlp_scn_chg = 0; /* scene change */
+int dnlp_bld_lvl = 0; /* blend level */
+int RBASE = 1;
 
 /*rGmIn[0:64]   ==>0:4:256, gamma*/
 /*rGmOt[0:pwdth]==>0-0, 0~1024*/
@@ -1045,6 +1159,8 @@ void GetSubCurve(unsigned int *rGmOt,
 		/* rst = ((rst + 128)>>8); */
 		rst = ((rst + 32)>>6);
 
+		if (nT0 == 0)
+			rst = rGmIn[0];
 		if (rst > (pwdth << 4))
 			rst = (pwdth << 4);
 
@@ -1058,12 +1174,12 @@ void GetSubCurve(unsigned int *rGmOt,
 void GetGmBlkCvs(unsigned int *rGmOt, unsigned int *rGmIn,
 		unsigned int Bgn, unsigned int End)
 {
-	static unsigned int pgmma0[7][65];
+	static unsigned int pgmma0[65];
 	int nT0 = 0;
 	int pwdth = End - Bgn; /* 64 */
 	int pLst[65];
 	int i = 0;
-	int j = 0;
+	int nTmp0 = 0;
 
 	GetSubCurve(pLst, rGmIn, pwdth); /*0~1024*/
 
@@ -1072,26 +1188,26 @@ void GetGmBlkCvs(unsigned int *rGmOt, unsigned int *rGmIn,
 			rGmOt[nT0] = (nT0 << 4);
 		else if (nT0 >= End)
 			rGmOt[nT0] = (nT0 << 4);
-		else
-			rGmOt[nT0] = (Bgn << 4) + pLst[nT0 - Bgn];
+		else {
+			if (ve_dnlp_pst_gmarat > 64)
+				rGmOt[nT0] = (Bgn << 4) +
+				(1024 - pLst[64 + Bgn - nT0]);
+			else
+				rGmOt[nT0] = (Bgn << 4) + pLst[nT0 - Bgn];
+		}
 	}
 
 	if (!dnlp_scn_chg)
 		for (i = 0; i < 65; i++) {
-			for (j = 0; j < 7; j++)
-				rGmOt[i] += pgmma0[j][i];
+			nTmp0 = dnlp_bld_lvl * rGmOt[i] + (RBASE >> 1);
+			nTmp0 = nTmp0 + (RBASE - dnlp_bld_lvl) * pgmma0[i];
+			nTmp0 = (nTmp0 >> ve_dnlp_mvreflsh); /* 0 ~1024 */
 
-			rGmOt[i] = ((rGmOt[i] + 4)>>3);
-
-			for (j = 0; j < 6; j++)
-				pgmma0[j][i] = pgmma0[j + 1][i];
-
-			pgmma0[6][i] = rGmOt[i]; /* 0 ~1024 */
+			rGmOt[i] = nTmp0;
 		}
-	else
-		for (i = 0; i < 65; i++)
-			for (j = 0; j < 7; j++)
-				pgmma0[j][i] = rGmOt[i];
+
+	for (i = 0; i < 65; i++)
+		pgmma0[i] = rGmOt[i];
 }
 
 
@@ -1192,22 +1308,14 @@ void GetGmCurves(unsigned int *rGmOt, unsigned int *rGmIn,
 
 unsigned int cal_hist_avg(unsigned int pval)
 {
-	static unsigned int ppval[7];
-	int i = 0;
+	static unsigned int ppval;
 
 	if (!dnlp_scn_chg) {
-		for (i = 0; i < 7; i++)
-			pval += ppval[i];
-
-		pval = ((pval + 4) >> 3);
-	} else
-		for (i = 0; i < 7; i++)
-			ppval[i] = pval;
-
-	for (i = 0; i < 6; i++)
-		ppval[i] = ppval[i + 1];
-
-	ppval[6] = pval;
+		pval = dnlp_bld_lvl * pval + (RBASE >> 1);
+		pval = pval + (RBASE - dnlp_bld_lvl) * ppval;
+		pval = (pval >> ve_dnlp_mvreflsh);
+	}
+	ppval = pval;
 
 	return pval;
 }
@@ -1215,24 +1323,55 @@ unsigned int cal_hist_avg(unsigned int pval)
 /* history */
 unsigned int cal_hst_shft_avg(unsigned int pval)
 {
-	static unsigned int ppval[7];
-	int i = 0;
+	static unsigned int ppval;
 
 	if (!dnlp_scn_chg) {
-		for (i = 0; i < 7; i++)
-			pval += ppval[i];
+		pval = dnlp_bld_lvl * pval + (RBASE >> 1);
+		pval = pval + (RBASE - dnlp_bld_lvl) * ppval;
+		pval = (pval >> ve_dnlp_mvreflsh);
+	}
+	ppval = pval;
 
-		pval = ((pval + 4) >> 3);
-	} else
-		for (i = 0; i < 7; i++)
-			ppval[i] = pval;
+	return pval;
+}
 
-	for (i = 0; i < 6; i++)
-		ppval[i] = ppval[i + 1];
+/* mtdrate: mtdrate in the mid-tone*/
+/* luma_avg: 0~64 */
+static int dnlp_adp_mtdrate(int mtdrate, int luma_avg)
+{
+	int np = 0;
+	int nt = mtdrate;
+	if (ve_dnlp_adpmtd_lbnd > 0 &&
+		luma_avg < ve_dnlp_adpmtd_lbnd) {
+		nt = mtdrate * luma_avg + (ve_dnlp_adpmtd_lbnd >> 1);
+		nt /= ve_dnlp_adpmtd_lbnd;
+
+		np = 4 * (ve_dnlp_adpmtd_lbnd - luma_avg);
+		if (np < mtdrate)
+			np = mtdrate - np;
+		else
+			np = 0;
+
+		if (np > nt)
+			nt = np;
+	} else if (ve_dnlp_adpmtd_hbnd > 0 &&
+		(luma_avg > 64 - ve_dnlp_adpmtd_hbnd)) {
+		nt = mtdrate * (64 - luma_avg);
+		nt += (ve_dnlp_adpmtd_hbnd >> 1);
+		nt /= ve_dnlp_adpmtd_hbnd;
+
+		np = luma_avg - (64 - ve_dnlp_adpmtd_hbnd);
+		np = 4 * np;
+		if (np < mtdrate)
+			np = mtdrate - np;
+		else
+			np = 0;
 
-	ppval[6] = pval;
+		if (np > nt)
+			nt = np;
+	}
 
-	return pval;
+	return nt;
 }
 
 unsigned int AdjHistAvg(unsigned int pval, unsigned int ihstEnd)
@@ -1253,15 +1392,18 @@ unsigned int AdjHistAvg(unsigned int pval, unsigned int ihstEnd)
 	return pval;
 }
 
-int blk_wht_extsn(int *blk_wht_ext, unsigned int *iHst, int hstSum)
+int blk_wht_extsn(int *blk_wht_ext, unsigned int *iHst,
+	int hstSum, unsigned int luma_avg)
 {
 	int tAvg = ((hstSum + 32) >> 6);
 	int nStp = 0;
 	int nT0 = 0;
+	int nT1 = 0;
 	int i = 0;
+	int dnlp_wextmx = ve_dnlp_wextmx;
 
 	/* black / white extension */
-	static int pblk_wht_ext[7][2];
+	static int pblk_wht_ext[2];
 
 	/* black extension */
 	nStp = tAvg * ve_dnlp_blkext + 32;
@@ -1279,40 +1421,71 @@ int blk_wht_extsn(int *blk_wht_ext, unsigned int *iHst, int hstSum)
 	/* white extension */
 	nStp = tAvg * ve_dnlp_whtext + 32;
 	nStp = (nStp >> 6);
-	blk_wht_ext[1] = 0;
+
+	if (ve_dnlp_wext_autorat > 0)
+		dnlp_wextmx = iRgnEnd - 1;
+	else
+		dnlp_wextmx = ve_dnlp_wextmx;
+
 	nT0 = 0;
-	for (i = 0; i < ve_dnlp_wextmx; i++) {
+	nT1 = 0;
+	for (i = 0; i < dnlp_wextmx; i++) {
 		nT0 += iHst[iRgnEnd - 1 - i];
 		if (nT0 > nStp)
 			break;
 		else if (i >= (64 - iRgnEnd))
-			blk_wht_ext[1] = ((i + iRgnEnd - 63) << 4);
+			nT1 = (i + iRgnEnd - 63);
 	}
 
-	if (!dnlp_scn_chg) {
-		for (i = 0; i < 7; i++) {
-			blk_wht_ext[0] += pblk_wht_ext[i][0];
-			blk_wht_ext[1] += pblk_wht_ext[i][1];
-		}
-		blk_wht_ext[0] = ((blk_wht_ext[0] + 4) >> 3);
-		blk_wht_ext[1] = ((blk_wht_ext[1] + 4) >> 3);
-	} else {
-		for (i = 0; i < 7; i++) {
-			pblk_wht_ext[i][0] = blk_wht_ext[0];
-			pblk_wht_ext[i][1] = blk_wht_ext[1];
+	if (ve_dnlp_wext_autorat > 0) {
+		if (luma_avg > 32) /* baby face */
+			nT1 = 0;
+		else {
+			nT1 = (32 - luma_avg) * nT1 * ve_dnlp_wext_autorat;
+			nT1 = ((nT1 + 512) >> 10);
+			if (nT1 > ve_dnlp_wextmx)
+				nT1 = ve_dnlp_wextmx;
 		}
 	}
+	blk_wht_ext[1] = (nT1 << 4);
+
+	if (!dnlp_scn_chg) {
+		nT0 = dnlp_bld_lvl * blk_wht_ext[0] + (RBASE >> 1);
+		nT0 = nT0 + (RBASE - dnlp_bld_lvl) * pblk_wht_ext[0];
+		blk_wht_ext[0] = (nT0 >> ve_dnlp_mvreflsh);
 
-	for (i = 0; i < 6; i++) {
-		pblk_wht_ext[i][0] = pblk_wht_ext[i + 1][0];
-		pblk_wht_ext[i][1] = pblk_wht_ext[i + 1][1];
+		nT1 = dnlp_bld_lvl * blk_wht_ext[1] + (RBASE >> 1);
+		nT1 = nT1 + (RBASE - dnlp_bld_lvl) * pblk_wht_ext[1];
+		blk_wht_ext[1] = (nT1 >> ve_dnlp_mvreflsh);
 	}
-	pblk_wht_ext[6][0] = blk_wht_ext[0];
-	pblk_wht_ext[6][1] = blk_wht_ext[1];
+
+	pblk_wht_ext[0] = blk_wht_ext[0];
+	pblk_wht_ext[1] = blk_wht_ext[1];
 
 	return 0;
 }
 
+static unsigned int dnlp_adp_cliprate(unsigned int clip_rate,
+	unsigned int clip_rmin, unsigned int luma_avg)
+{
+	unsigned int nt = clip_rate;
+	if (luma_avg < ve_dnlp_adpcrat_lbnd) {
+		nt = clip_rate * (ve_dnlp_adpcrat_lbnd - luma_avg) +
+			luma_avg * clip_rmin;
+
+		nt = (nt << 4) + (ve_dnlp_adpcrat_lbnd >> 1);
+		nt /= ve_dnlp_adpcrat_lbnd;
+	} else if (luma_avg > 64 - ve_dnlp_adpcrat_hbnd) {
+		nt = clip_rmin * (64 - luma_avg) +
+			clip_rate * (luma_avg + ve_dnlp_adpcrat_hbnd - 64);
+		nt += (nt << 4) + (ve_dnlp_adpcrat_hbnd >> 1);
+		nt /= ve_dnlp_adpcrat_hbnd;
+	} else
+		nt = (clip_rmin << 4);
+
+	return nt;
+}
+
 int old_dnlp_lrate[32];
 
 /*iHst[0:63]: [0,4)->iHst[0], [252,256)->iHst[63]*/
@@ -1327,6 +1500,8 @@ void clash_fun(unsigned int *oMap, unsigned int *iHst,
 	unsigned int cLmt = 0;
 	unsigned int tLen = (hstEnd - hstBgn);
 	unsigned int tAvg = 0;
+	unsigned int lAvg4 = 0;
+	unsigned int lAvg1 = 0;
 	unsigned int nStp = 0;
 	/*unsigned int uLmt = 0;*/
 	/*unsigned int stp = 0;*/
@@ -1334,6 +1509,8 @@ void clash_fun(unsigned int *oMap, unsigned int *iHst,
 	unsigned int tHst[64];
 	unsigned int nT0 = 0;
 	unsigned int clip_rate = ve_dnlp_cliprate_new;
+	unsigned int clip_rmin  = ve_dnlp_cliprate_min;
+	unsigned int adp_crate = clip_rate;
 
 	int nNum = 0;
 	int nExc = 0;
@@ -1343,6 +1520,18 @@ void clash_fun(unsigned int *oMap, unsigned int *iHst,
 	/* local limit 64-bin*/
 	unsigned int lcl_lmt[64];
 
+	if (clip_rmin > clip_rate)
+		clip_rmin = clip_rate;
+	if (ve_dnlp_adpcrat_lbnd < 2)
+		ve_dnlp_adpcrat_lbnd = 2;
+	else if (ve_dnlp_adpcrat_lbnd > 30)
+		ve_dnlp_adpcrat_lbnd = 30;
+
+	if (ve_dnlp_adpcrat_hbnd < 2)
+		ve_dnlp_adpcrat_hbnd = 2;
+	else if (ve_dnlp_adpcrat_hbnd > 30)
+		ve_dnlp_adpcrat_hbnd = 30;
+
 	if (hstBgn > 16)
 		hstBgn = 16;
 
@@ -1353,6 +1542,8 @@ void clash_fun(unsigned int *oMap, unsigned int *iHst,
 
 	oMap[64] = 1024; /* 0~1024 */
 	/*64 bins, max, ave*/
+	lAvg4 = 0;
+	lAvg1 = 0;
 	for (i = 0; i < 64; i++) {
 		oHst[i] = iHst[i];
 		oMap[i] = (i << 4); /* 0~1024 */
@@ -1364,16 +1555,24 @@ void clash_fun(unsigned int *oMap, unsigned int *iHst,
 			if (tmax < iHst[i])
 				tmax = iHst[i];
 			tsum += iHst[i];
+			lAvg4 += (iHst[i] * i);
 		} else {
 			oHst[i] = 0;
 		}
 
 		lcl_lmt[i] = old_dnlp_lrate[(i>>1)];
 	}
+	lAvg4 = (lAvg4 << 2) + tsum / 2;
+	lAvg4 = lAvg4 / tsum;
+	lAvg1 = (lAvg4 + 2) >> 2;
+
+	/* << 4 */
+	adp_crate = dnlp_adp_cliprate(clip_rate, clip_rmin, lAvg1);
 
 	prt_flg = ((dnlp_printk >> 9) & 0x1);
 	if (prt_flg)
-		pr_info("#CL: Range[%02d ~ %02d]\n", hstBgn, hstEnd);
+		pr_info("#CL: Range[%02d ~ %02d] lAvg4=%d(%d), (crate << 4)=%d\n",
+			hstBgn, hstEnd, lAvg4, lAvg1, adp_crate);
 
 	for (i = 1; i <= 61; i += 2)
 		lcl_lmt[i] = ((lcl_lmt[i-1] + lcl_lmt[i+1] + 1)>>1);
@@ -1381,7 +1580,12 @@ void clash_fun(unsigned int *oMap, unsigned int *iHst,
 	if (hstEnd <= hstBgn)
 		return;
 
-	cLmt = (clip_rate*tsum)>>8;
+	/*cLmt = (clip_rate*tsum) >> 10;
+		= (tsum >> 6) * (clip_rate>>4)
+	adp_crate >> 4*/
+	cLmt = (adp_crate * tsum) >> 2;
+	cLmt = (cLmt + 2048) >> 12;
+
 	tAvg = (tsum + tLen/2)/tLen;
 
 	/* sort histogram */
@@ -1430,6 +1634,29 @@ void clash_fun(unsigned int *oMap, unsigned int *iHst,
 			lcl_lmt[i] = nT0;
 	}
 
+	/* black protect */
+	nStp = tAvg * ve_blk_prct_max + 4;
+	nStp = (nStp >> 3);
+	for (i = 0; i < ve_blk_prct_rng; i++) {
+		nT0 = (ve_blk_prct_rng - i);
+		if (iHst[i] > nStp)
+			nT0 = nT0 * (iHst[i] - nStp);
+		else
+			nT0 = 0;
+
+		if (lcl_lmt[i] > (nT0 + tAvg))
+			nT0 = lcl_lmt[i] - nT0;
+		else
+			nT0 = tAvg;
+
+		if (nT0 < tAvg)
+			nT0 = tAvg;
+
+		if (prt_flg)
+			pr_info("clmt[%d]: %4d -> %4d\n",
+				i, lcl_lmt[i], nT0);
+	} /* black protect */
+
 	nExc = 0;
 	nNum = 0;
 	for (i = hstBgn; i < hstEnd; i++) {
@@ -1442,11 +1669,11 @@ void clash_fun(unsigned int *oMap, unsigned int *iHst,
 		}
 	}
 
-	if (clip_rate <= 4 || tAvg <= 2) {
+	if (clip_rate <= 8 || tAvg <= 2) {
 		cLmt = (tsum + tLen/2)/tLen;
 		tsum = cLmt*tLen;
 		for (i = hstBgn; i < hstEnd; i++)
-				oHst[i] = cLmt;
+			oHst[i] = cLmt;
 
 	} else {
 		while ((nNum > 0) && (nExc > 0)) {
@@ -1519,7 +1746,7 @@ int old_dnlp_cliprate_new;
 int old_dnlp_clashBgn;
 int old_dnlp_clashEnd;
 int old_mtdbld_rate;
-int old_blkgma_rate;
+int old_dnlp_pst_gmarat;
 int old_dnlp_blk_cctr;
 int old_dnlp_brgt_ctrl;
 int old_dnlp_brgt_range;
@@ -1534,10 +1761,13 @@ int old_dnlp_lowbin;
 int old_dnlp_lownum;
 int old_dnlp_bkgend;
 int old_dnlp_bkgert;
+int old_dnlp_pstgma_brghtrate;
+int old_dnlp_pstgma_brghtrat1;
 int old_dnlp_blkext;
 int old_dnlp_whtext;
 int old_dnlp_bextmx;
 int old_dnlp_wextmx;
+int old_dnlp_wext_autorat;
 int old_dnlp_lavg_cum;
 int old_dnlp_schg_sft;
 bool old_dnlp_smhist_ck;
@@ -1550,8 +1780,28 @@ int old_dnlp_dbg_i2r;
 int old_dnlp_slow_end;
 int old_dnlp_pavg_btsft;
 int old_dnlp_dbg0331;
+int old_dnlp_cliprate_min;
+int old_dnlp_adpcrat_lbnd;
+int old_dnlp_adpcrat_hbnd;
+int old_dnlp_adpmtd_lbnd;
+int	old_dnlp_adpmtd_hbnd;
+int	old_dnlp_set_bext;
+int	old_dnlp_set_wext;
 
-int dnlp_bld_lvl = 0; /* blend level */
+int old_dnlp_satur_rat;
+int old_dnlp_satur_max;
+int	old_blk_prct_rng;
+int	old_blk_prct_max;
+
+int old_dnlp_lowrange;
+int old_dnlp_hghrange;
+int old_dnlp_auto_rng;
+
+int old_dnlp_bin0_absmax;
+int old_dnlp_bin0_sbtmax;
+
+int old_dnlp_adpalpha_lrate;
+int old_dnlp_adpalpha_hrate;
 
 static int cal_brght_plus(int luma_avg4, int low_lavg4)
 {
@@ -1560,10 +1810,9 @@ static int cal_brght_plus(int luma_avg4, int low_lavg4)
 
 	int low_rng = 0;
 	int low_rat = 0;
-	int i = 0;
 
 	int dnlp_brightness = 0;
-	static int pbrtness[7];
+	static int pbrtness;
 
 	if (luma_avg4 > low_lavg4)
 		avg_dif = luma_avg4 - low_lavg4;
@@ -1580,22 +1829,17 @@ static int cal_brght_plus(int luma_avg4, int low_lavg4)
 		low_rat = ve_dnlp_brgt_range - low_rng;
 
 	/* <<2 */
-	dnlp_brightness  = (ve_dnlp_brght_max*dif_rat*low_rat + 64)>>5;
+	dnlp_brightness  = (ve_dnlp_brght_max*dif_rat*low_rat + 16)>>5;
 	/* add=32 => add 0 */
 	dnlp_brightness += ((ve_dnlp_brght_add - 32) << 2);
 
-	if (dnlp_scn_chg)
-		for (i = 0; i < 7; i++)
-			pbrtness[i] = dnlp_brightness;
-
-	for (i = 0; i < 7; i++)
-		dnlp_brightness += pbrtness[i];
-	dnlp_brightness = ((dnlp_brightness + 4) >> 3);
-
-	for (i = 0; i < 6; i++)
-		pbrtness[i] = pbrtness[i + 1];
-
-	pbrtness[6] = dnlp_brightness;
+	if (!dnlp_scn_chg) {
+		dnlp_brightness = dnlp_bld_lvl * dnlp_brightness + (RBASE >> 1);
+		dnlp_brightness = dnlp_brightness +
+				(RBASE - dnlp_bld_lvl) * pbrtness;
+		dnlp_brightness = (dnlp_brightness >> ve_dnlp_mvreflsh);
+	}
+	pbrtness = dnlp_brightness;
 
 	return dnlp_brightness; /* 0 ~ 1024 */
 }
@@ -1617,28 +1861,22 @@ static unsigned int premap0[64];
 
 static int pcurves[8][64];
 
-
 static void clash_blend(void)
 {
 	int i = 0;
-	int j = 0;
-	static unsigned int pgmma[7][65];
+	int nTmp0 = 0;
+	static unsigned int pgmma[65];
 
 	if (!dnlp_scn_chg && ((ve_dnlp_dbg_i2r >> 3) & 0x1))
 		for (i = 0; i < 65; i++) {
-			for (j = 0; j < 7; j++)
-				clash_curve[i] += pgmma[j][i];
-			clash_curve[i] = ((clash_curve[i] + 4)>>3);
-
-			for (j = 0; j < 6; j++)
-				pgmma[j][i] = pgmma[j + 1][i];
-
-			pgmma[6][i] = clash_curve[i]; /* 0 ~1024 */
+			nTmp0 = dnlp_bld_lvl * clash_curve[i] + (RBASE >> 1);
+			nTmp0 = nTmp0 + (RBASE - dnlp_bld_lvl) * pgmma[i];
+			nTmp0 = (nTmp0 >> ve_dnlp_mvreflsh);
+			clash_curve[i] = nTmp0;
 		}
-	else
-		for (i = 0; i < 65; i++)
-			for (j = 0; j < 7; j++)
-				pgmma[j][i] = clash_curve[i];
+
+	for (i = 0; i < 65; i++)
+		pgmma[i] = clash_curve[i];
 }
 
 int curve_rfrsh_chk(int hstSum, int rbase)
@@ -1660,7 +1898,8 @@ int curve_rfrsh_chk(int hstSum, int rbase)
 	tAvgDif[29] = (tLumAvg[29] > tLumAvg[28]) ?
 		(tLumAvg[29] - tLumAvg[28]) : (tLumAvg[28] - tLumAvg[29]);
 
-	prt_flg = ((dnlp_printk >> 7) & 0x1);
+	/* prt_flg = ((dnlp_printk >> 7) & 0x1); */
+	prt_flg = (dnlp_printk & 0x1);
 
 	lSby = 0;
 	for (i = 0; i < 8; i++)
@@ -1677,6 +1916,10 @@ int curve_rfrsh_chk(int hstSum, int rbase)
 	if (prt_flg)
 		pr_info("bld_lvl=%02d\n", bld_lvl);
 
+	/* play station: return with black scene intersection */
+	if (tAvgDif[29] > bld_lvl)
+		bld_lvl = tAvgDif[29];
+
 	if (bld_lvl > rbase)
 		bld_lvl = rbase;
 	else if (bld_lvl < ve_dnlp_cuvbld_min)
@@ -1712,7 +1955,7 @@ static void dnlp3_param_refrsh(void)
 			(old_dnlp_clashBgn != ve_dnlp_clashBgn) ||
 			(old_dnlp_clashEnd != ve_dnlp_clashEnd) ||
 			(old_mtdbld_rate != ve_mtdbld_rate) ||
-			(old_blkgma_rate != ve_blkgma_rate) ||
+			(old_dnlp_pst_gmarat != ve_dnlp_pst_gmarat) ||
 			(old_dnlp_blk_cctr != ve_dnlp_blk_cctr) ||
 			(old_dnlp_brgt_ctrl != ve_dnlp_brgt_ctrl) ||
 			(old_dnlp_brgt_range != ve_dnlp_brgt_range) ||
@@ -1760,10 +2003,15 @@ static void dnlp3_param_refrsh(void)
 			(old_dnlp_lownum != ve_dnlp_lownum) ||
 			(old_dnlp_bkgend != ve_dnlp_bkgend) ||
 			(old_dnlp_bkgert != ve_dnlp_bkgert) ||
+			(old_dnlp_pstgma_brghtrate !=
+				ve_dnlp_pstgma_brghtrate) ||
+			(old_dnlp_pstgma_brghtrat1 !=
+				ve_dnlp_pstgma_brghtrat1) ||
 			(old_dnlp_blkext != ve_dnlp_blkext) ||
 			(old_dnlp_whtext != ve_dnlp_whtext) ||
 			(old_dnlp_bextmx != ve_dnlp_bextmx) ||
 			(old_dnlp_wextmx != ve_dnlp_wextmx) ||
+			(old_dnlp_wext_autorat != ve_dnlp_wext_autorat) ||
 			(old_dnlp_schg_sft != ve_dnlp_schg_sft) ||
 			(old_dnlp_smhist_ck != ve_dnlp_smhist_ck) ||
 			(old_dnlp_cuvbld_min != ve_dnlp_cuvbld_min) ||
@@ -1772,7 +2020,25 @@ static void dnlp3_param_refrsh(void)
 			(old_dnlp_dbg_adjavg != ve_dnlp_dbg_adjavg) ||
 			(old_dnlp_dbg_i2r != ve_dnlp_dbg_i2r) ||
 			(old_dnlp_slow_end != ve_dnlp_slow_end) ||
-			(old_dnlp_pavg_btsft != ve_dnlp_pavg_btsft))
+			(old_dnlp_pavg_btsft != ve_dnlp_pavg_btsft) ||
+			(old_dnlp_cliprate_min != ve_dnlp_cliprate_min) ||
+			(old_dnlp_adpcrat_lbnd != ve_dnlp_adpcrat_lbnd) ||
+			(old_dnlp_adpcrat_hbnd != ve_dnlp_adpcrat_hbnd) ||
+			(old_dnlp_adpmtd_lbnd != ve_dnlp_adpmtd_lbnd) ||
+			(old_dnlp_adpmtd_hbnd != ve_dnlp_adpmtd_hbnd) ||
+			(old_dnlp_set_bext != ve_dnlp_set_bext) ||
+			(old_dnlp_set_wext != ve_dnlp_set_wext) ||
+			(old_dnlp_satur_rat != ve_dnlp_satur_rat) ||
+			(old_dnlp_satur_max != ve_dnlp_satur_max) ||
+			(old_blk_prct_rng != ve_blk_prct_rng) ||
+			(old_blk_prct_max != ve_blk_prct_max) ||
+			(old_dnlp_lowrange != ve_dnlp_lowrange) ||
+			(old_dnlp_hghrange != ve_dnlp_hghrange) ||
+			(old_dnlp_auto_rng != ve_dnlp_auto_rng) ||
+			(old_dnlp_bin0_absmax != ve_dnlp_bin0_absmax) ||
+			(old_dnlp_bin0_sbtmax != ve_dnlp_bin0_sbtmax) ||
+			(old_dnlp_adpalpha_lrate != ve_dnlp_adpalpha_lrate) ||
+			(old_dnlp_adpalpha_hrate != ve_dnlp_adpalpha_hrate))
 			ve_dnlp_respond_flag = 1;
 		else
 			ve_dnlp_respond_flag = 0;
@@ -1788,7 +2054,7 @@ static void dnlp3_param_refrsh(void)
 	old_dnlp_clashBgn = ve_dnlp_clashBgn;
 	old_dnlp_clashEnd = ve_dnlp_clashEnd;
 	old_mtdbld_rate = ve_mtdbld_rate;
-	old_blkgma_rate = ve_blkgma_rate;
+	old_dnlp_pst_gmarat = ve_dnlp_pst_gmarat;
 	old_dnlp_blk_cctr = ve_dnlp_blk_cctr;
 	old_dnlp_brgt_ctrl = ve_dnlp_brgt_ctrl;
 	old_dnlp_brgt_range = ve_dnlp_brgt_range;
@@ -1837,11 +2103,14 @@ static void dnlp3_param_refrsh(void)
 
 	old_dnlp_bkgend = ve_dnlp_bkgend;
 	old_dnlp_bkgert = ve_dnlp_bkgert;
+	old_dnlp_pstgma_brghtrate = ve_dnlp_pstgma_brghtrate;
+	old_dnlp_pstgma_brghtrat1 = ve_dnlp_pstgma_brghtrat1;
 
 	old_dnlp_blkext = ve_dnlp_blkext;
 	old_dnlp_whtext = ve_dnlp_whtext;
 	old_dnlp_bextmx = ve_dnlp_bextmx;
 	old_dnlp_wextmx = ve_dnlp_wextmx;
+	old_dnlp_wext_autorat = ve_dnlp_wext_autorat;
 
 	old_dnlp_schg_sft = ve_dnlp_schg_sft;
 
@@ -1853,81 +2122,89 @@ static void dnlp3_param_refrsh(void)
 	old_dnlp_dbg_i2r = ve_dnlp_dbg_i2r;
 	old_dnlp_slow_end = ve_dnlp_slow_end;
 	old_dnlp_pavg_btsft = ve_dnlp_pavg_btsft;
+	old_dnlp_pavg_btsft = ve_dnlp_pavg_btsft;
+	old_dnlp_cliprate_min = ve_dnlp_cliprate_min;
+	old_dnlp_adpcrat_lbnd = ve_dnlp_adpcrat_lbnd;
+	old_dnlp_adpcrat_hbnd = ve_dnlp_adpcrat_hbnd;
+
+	old_dnlp_adpmtd_lbnd = ve_dnlp_adpmtd_lbnd;
+	old_dnlp_adpmtd_hbnd = ve_dnlp_adpmtd_hbnd;
+	old_dnlp_set_bext = ve_dnlp_set_bext;
+	old_dnlp_set_wext = ve_dnlp_set_wext;
+
+	old_dnlp_satur_rat = ve_dnlp_satur_rat;
+	old_dnlp_satur_max = ve_dnlp_satur_max;
+	old_blk_prct_rng = ve_blk_prct_rng;
+	old_blk_prct_max = ve_blk_prct_max;
+
+	old_dnlp_lowrange = ve_dnlp_lowrange;
+	old_dnlp_hghrange = ve_dnlp_hghrange;
+	old_dnlp_auto_rng = ve_dnlp_auto_rng;
+
+	old_dnlp_bin0_absmax = ve_dnlp_bin0_absmax;
+	old_dnlp_bin0_sbtmax = ve_dnlp_bin0_sbtmax;
+	old_dnlp_adpalpha_hrate = ve_dnlp_adpalpha_hrate;
+	old_dnlp_adpalpha_lrate = ve_dnlp_adpalpha_lrate;
 }
 
 static void dnlp_rfrsh_subgmma(void)
 {
 	int i = 0;
-	int j = 0;
-	static unsigned int pgmma0[7][65]; /* 0~4096*/
-	static unsigned int pgmma1[7][65];
+	static unsigned int pgmma0[65]; /* 0~4096*/
+	static unsigned int pgmma1[65];
 
 	if (!dnlp_scn_chg)
 		for (i = 0; i < 65; i++) {
-			gma_scurve0[i] = gma_scurve0[i] << 2;
-			gma_scurve1[i] = gma_scurve1[i] << 2;
+			gma_scurve0[i] = dnlp_bld_lvl *
+					(gma_scurve0[i] << 2) + (RBASE >> 1);
+			gma_scurve1[i] = dnlp_bld_lvl *
+					(gma_scurve1[i] << 2) + (RBASE >> 1);
 
-			for (j = 0; j < 7; j++) {
-				gma_scurve0[i] += pgmma0[j][i];
-				gma_scurve1[i] += pgmma1[j][i];
-			}
-			gma_scurve0[i] = ((gma_scurve0[i] + 4)>>3); /* 0~4096 */
-			gma_scurve1[i] = ((gma_scurve1[i] + 4)>>3);
+			gma_scurve0[i] = gma_scurve0[i] +
+					(RBASE - dnlp_bld_lvl) * pgmma0[i];
+			gma_scurve1[i] = gma_scurve1[i] +
+					(RBASE - dnlp_bld_lvl) * pgmma1[i];
 
-			for (j = 0; j < 6; j++) {
-				pgmma0[j][i] = pgmma0[j + 1][i];
-				pgmma1[j][i] = pgmma1[j + 1][i];
-			}
+			gma_scurve0[i] = (gma_scurve0[i] >> ve_dnlp_mvreflsh);
+			gma_scurve1[i] = (gma_scurve1[i] >> ve_dnlp_mvreflsh);
 
-			pgmma0[6][i] = gma_scurve0[i]; /* 0 ~4096 */
-			pgmma1[6][i] = gma_scurve1[i]; /* 0 ~4096 */
+			pgmma0[i] = gma_scurve0[i]; /* 0~ 4095 */
+			pgmma1[i] = gma_scurve1[i]; /* 0~ 4095 */
 
-			gma_scurve0[i] = (gma_scurve0[i] + 2) >> 2; /*1023*/
-			gma_scurve1[i] = (gma_scurve1[i] + 2) >> 2; /*1023*/
+			gma_scurve0[i] = (gma_scurve0[i] + 2) >> 2; /* 1023 */
+			gma_scurve1[i] = (gma_scurve1[i] + 2) >> 2; /* 1023 */
 		}
 	else
-		for (i = 0; i < 65; i++)
-			for (j = 0; j < 7; j++) {
-				pgmma0[j][i] = (gma_scurve0[i] << 2);
-				pgmma1[j][i] = (gma_scurve1[i] << 2);
-			}
+		for (i = 0; i < 65; i++) {
+			pgmma0[i] = (gma_scurve0[i] << 2);
+			pgmma1[i] = (gma_scurve1[i] << 2);
+		}
 }
 
 static void dnlp_inhist_lpf(void)
 {
 	int i = 0;
-	int j = 0;
-	static unsigned int pgmma0[7][65];
-	static unsigned int luma_sum[7];
+	int nTmp = 0;
+	static unsigned int pgmma0[65];
+	static unsigned int luma_sum;
 
 	if (!dnlp_scn_chg && (ve_dnlp_dbg_i2r & 0x1)) {
 		for (i = 0; i < 65; i++) {
-			for (j = 0; j < 7; j++)
-				pre_0_gamma[i] += pgmma0[j][i];
-
-			pre_0_gamma[i] = ((pre_0_gamma[i] + 4)>>3);
-
-			for (j = 0; j < 6; j++)
-				pgmma0[j][i] = pgmma0[j + 1][i];
-
-			pgmma0[6][i] = pre_0_gamma[i];
+			nTmp = dnlp_bld_lvl * pre_0_gamma[i] + (RBASE >> 1);
+			nTmp = nTmp + (RBASE - dnlp_bld_lvl) * pgmma0[i];
+			nTmp = (nTmp >> ve_dnlp_mvreflsh);
+			pre_0_gamma[i] = nTmp;
 		}
 
-		for (j = 0; j < 7; j++)
-			ve_dnlp_luma_sum += luma_sum[j];
-		ve_dnlp_luma_sum = ((ve_dnlp_luma_sum + 4) >> 3);
-
-		for (j = 0; j < 6; j++)
-			luma_sum[j] = luma_sum[j + 1];
-		luma_sum[6] = ve_dnlp_luma_sum;
-	} else {
-		for (i = 0; i < 65; i++)
-			for (j = 0; j < 7; j++)
-				pgmma0[j][i] = pre_0_gamma[i];
-
-		for (j = 0; j < 7; j++)
-			luma_sum[j] = ve_dnlp_luma_sum;
+		nTmp = dnlp_bld_lvl * ve_dnlp_luma_sum + (RBASE >> 1);
+		nTmp = nTmp + (RBASE - dnlp_bld_lvl) * luma_sum;
+		nTmp = (nTmp >> ve_dnlp_mvreflsh);
+		ve_dnlp_luma_sum = nTmp;
 	}
+
+	for (i = 0; i < 65; i++)
+		pgmma0[i] = pre_0_gamma[i];
+	luma_sum = ve_dnlp_luma_sum;
 }
 
 
@@ -1937,12 +2214,10 @@ static void dnlp_gmma_cuvs(unsigned int gmma_rate,
 	unsigned int lsft_avg)
 {
 	int i = 0;
-	int j = 0;
 	int nTmp = 0;
 	unsigned int luma_avg4 = (lsft_avg >> ve_dnlp_pavg_btsft);
 
-
-	static unsigned int pgmma[7][65];
+	static unsigned int pgmma[65];
 	bool prt_flg = ((dnlp_printk >> 10) & 0x1);
 
 	/* refresh sub gamma */
@@ -1959,10 +2234,10 @@ static void dnlp_gmma_cuvs(unsigned int gmma_rate,
 
 		if (nTmp <= (luma_avg4<<2))
 			nTmp = (nTmp*(64 - low_alpha) +
-				(low_alpha*i<<4) + 16)>>4; /*4096*/
+				(low_alpha*i<<4) + 8)>>4; /*4096*/
 		else
 			nTmp = (nTmp*(64 - hgh_alpha) +
-				(hgh_alpha*i<<4) + 16)>>4;
+				(hgh_alpha*i<<4) + 8)>>4;
 
 		if (nTmp < 0)
 			nTmp = 0;
@@ -1978,19 +2253,15 @@ static void dnlp_gmma_cuvs(unsigned int gmma_rate,
 
 	if (!dnlp_scn_chg && ((ve_dnlp_dbg_i2r >> 2) & 0x1))
 		for (i = 0; i < 65; i++) {
-			for (j = 0; j < 7; j++)
-				gma_scurvet[i] += pgmma[j][i];
-			gma_scurvet[i] = ((gma_scurvet[i] + 4)>>3);
-
-			for (j = 0; j < 6; j++)
-				pgmma[j][i] = pgmma[j + 1][i];
+			nTmp = dnlp_bld_lvl * gma_scurvet[i] + (RBASE >> 1);
+			nTmp = nTmp + (RBASE - dnlp_bld_lvl) * pgmma[i];
+			nTmp = (nTmp >> ve_dnlp_mvreflsh);
 
-			pgmma[6][i] = gma_scurvet[i]; /* 4095 */
+			gma_scurvet[i] = nTmp; /* 4095 */
 		}
-	else
-		for (i = 0; i < 65; i++)
-			for (j = 0; j < 7; j++)
-				pgmma[j][i] = gma_scurvet[i]; /* 4095 */
+
+	for (i = 0; i < 65; i++)
+		pgmma[i] = gma_scurvet[i]; /* 4095 */
 
 	for (i = 0; i < 65; i++)
 		gma_scurvet[i] = ((gma_scurvet[i] + 2) >> 2); /*1023*/
@@ -2000,10 +2271,9 @@ static void dnlp_gmma_cuvs(unsigned int gmma_rate,
 static void dnlp_clsh_sbld(unsigned int mtdbld_rate)
 {
 	int i = 0;
-	int j = 0;
 	int nTmp0 = 0;
 
-	static unsigned int pgmma[7][65];
+	static unsigned int pgmma[65];
 
 	for (i = 0; i < 65; i++) {
 		nTmp0 = gma_scurvet[i]; /* 0 ~1024 */
@@ -2014,19 +2284,15 @@ static void dnlp_clsh_sbld(unsigned int mtdbld_rate)
 
 	if (!dnlp_scn_chg && ((ve_dnlp_dbg_i2r >> 4) & 0x1))
 		for (i = 0; i < 65; i++) {
-			for (j = 0; j < 7; j++)
-				clsh_scvbld[i] += pgmma[j][i];
-			clsh_scvbld[i] = ((clsh_scvbld[i] + 4)>>3);
-
-			for (j = 0; j < 6; j++)
-				pgmma[j][i] = pgmma[j + 1][i];
+			nTmp0 = dnlp_bld_lvl * clsh_scvbld[i] + (RBASE >> 1);
+			nTmp0 = nTmp0 + (RBASE - dnlp_bld_lvl) * pgmma[i];
+			nTmp0 = (nTmp0 >> ve_dnlp_mvreflsh);
 
-			pgmma[6][i] = clsh_scvbld[i]; /* 1023 */
+			clsh_scvbld[i] = nTmp0;
 		}
-	else
-		for (i = 0; i < 65; i++)
-			for (j = 0; j < 7; j++)
-				pgmma[j][i] = clsh_scvbld[i]; /* 1023 */
+
+	for (i = 0; i < 65; i++)
+		pgmma[i] = clsh_scvbld[i]; /* 1023 */
 }
 
 /* blk_gma_rat[64] */
@@ -2036,8 +2302,7 @@ static void dnlp_blkgma_bld(unsigned int *blk_gma_rat)
 	int nT1 = 0;
 	int nTmp0 = 0;
 	int i = 0;
-	int j = 0;
-	static unsigned int pgmma[7][65];
+	static unsigned int pgmma[65];
 
 	for (i = 0; i < 64; i++) {
 		nT1 = blk_gma_rat[i];
@@ -2046,24 +2311,24 @@ static void dnlp_blkgma_bld(unsigned int *blk_gma_rat)
 		nTmp0 = blk_gma_crv[i]*nT1 + nTmp0*(64 - nT1);
 		nTmp0 = (nTmp0+32)>>6; /* 0~1024 */
 		blk_gma_bld[i] = nTmp0;
+
+		if ((dnlp_printk >> 2) & 0x1)
+			pr_info("sc%04d, gm%04d * rat%04d => %04d\n",
+				clsh_scvbld[i],  blk_gma_crv[i], nT1, nTmp0);
 	}
 	blk_gma_bld[64] = 1023;
 
 	if (!dnlp_scn_chg && ((ve_dnlp_dbg_i2r >> 5) & 0x1))
 		for (i = 0; i < 65; i++) {
-			for (j = 0; j < 7; j++)
-				blk_gma_bld[i] += pgmma[j][i];
-			blk_gma_bld[i] = ((blk_gma_bld[i] + 4)>>3);
-
-			for (j = 0; j < 6; j++)
-				pgmma[j][i] = pgmma[j + 1][i];
+			nTmp0 = dnlp_bld_lvl * blk_gma_bld[i] + (RBASE >> 1);
+			nTmp0 = nTmp0 + (RBASE - dnlp_bld_lvl) * pgmma[i];
+			nTmp0 = (nTmp0 >> ve_dnlp_mvreflsh);
 
-			pgmma[6][i] = blk_gma_bld[i]; /* 1023 */
+			blk_gma_bld[i] = nTmp0;
 		}
-	else
-		for (i = 0; i < 65; i++)
-			for (j = 0; j < 7; j++)
-				pgmma[j][i] = blk_gma_bld[i]; /* 1023 */
+
+	for (i = 0; i < 65; i++)
+		pgmma[i] = blk_gma_bld[i]; /* 1023 */
 }
 
 /* blkwht_ebld = blk_gma_bld + extension */
@@ -2075,8 +2340,7 @@ static void dnlp_blkwht_bld(int *blk_wht_ext, int bright,
 	int nT1 = 0;
 	int nTmp0 = 0;
 	int i = 0;
-	int j = 0;
-	static unsigned int pgmma[7][65];
+	static unsigned int pgmma[65];
 
 	/* black / white extension */
 	for (i = 0; i < 64; i++) {
@@ -2087,17 +2351,13 @@ static void dnlp_blkwht_bld(int *blk_wht_ext, int bright,
 			nT1 += (nT0 >> 1);
 			nT1 = nT1 / nT0;
 
-			/* sprintf(pLogs, "%s (-%02d)", pLogs, nT1); */
-
 			nT0 = nTmp0 - nT1;
 		} else if ((luma_avg4 < 4*(iRgnEnd - 1)) && (i >= luma_avg)) {
 			nT0 = 4*(iRgnEnd - 1) - luma_avg4;
 			nT1 = blk_wht_ext[1] * (4*i - luma_avg4) + (nT0 >> 1);
 			nT1 = nT1 / nT0;
 
-			/* sprintf(pLogs, "%s (+%02d)", pLogs, nT1); */
-
-			nT0 = nTmp0 + nT1 / nT0;
+			nT0 = nTmp0 + nT1;
 		} else
 			nT0 = nTmp0;
 
@@ -2113,23 +2373,20 @@ static void dnlp_blkwht_bld(int *blk_wht_ext, int bright,
 
 		blkwht_ebld[i] = nT0;
 	}
+	blkwht_ebld[0]  = 0;
 	blkwht_ebld[64] = 1023;
 
 	if (!dnlp_scn_chg && ((ve_dnlp_dbg_i2r >> 6) & 0x1))
 		for (i = 0; i < 65; i++) {
-			for (j = 0; j < 7; j++)
-				blkwht_ebld[i] += pgmma[j][i];
-			blkwht_ebld[i] = ((blkwht_ebld[i] + 4)>>3);
+			nTmp0 = dnlp_bld_lvl * blkwht_ebld[i] + (RBASE >> 1);
+			nTmp0 = nTmp0 + (RBASE - dnlp_bld_lvl) * pgmma[i];
+			nTmp0 = (nTmp0 >> ve_dnlp_mvreflsh);
 
-			for (j = 0; j < 6; j++)
-				pgmma[j][i] = pgmma[j + 1][i];
-
-			pgmma[6][i] = blkwht_ebld[i]; /* 1023 */
+			blkwht_ebld[i] = nTmp0;
 		}
-	else
-		for (i = 0; i < 65; i++)
-			for (j = 0; j < 7; j++)
-				pgmma[j][i] = blkwht_ebld[i]; /* 1023 */
+
+	for (i = 0; i < 65; i++)
+		pgmma[i] = blkwht_ebld[i]; /* 1023 */
 }
 
 static void dnlp_params_hist(unsigned int *gmma_rate,
@@ -2197,9 +2454,177 @@ static void dnlp_params_hist(unsigned int *gmma_rate,
 	*mtdbld_rate = tmrat;
 }
 
+/* black bord detection, and histogram clipping */
+static void dnlp_refine_bin0(int hstSum)
+{
+	static unsigned int tmp_sum[7];
+	unsigned int nTmp = 0;
+	unsigned int nTmp0 = 0;
+	unsigned int nsum = 0;
+	int j = 0;
+
+	nTmp = (hstSum * ve_dnlp_bin0_absmax + 128) >> 8;
+	nTmp0 = pre_0_gamma[1] + pre_0_gamma[2];
+	if (nTmp0 > nTmp)
+		nTmp = nTmp0;
+
+	if (pre_0_gamma[0] > nTmp) {
+		if (pre_0_gamma[1] > nTmp)
+			nTmp = pre_0_gamma[1];
+		if (pre_0_gamma[2] > nTmp)
+			nTmp = pre_0_gamma[2];
+
+		nsum = pre_0_gamma[0] - nTmp;
+
+		nTmp = (hstSum * ve_dnlp_bin0_sbtmax + 128) >> 8;
+		if (nsum > nTmp)
+			nsum = nTmp;
+	}
+
+	if (!dnlp_scn_chg) {
+		for (j = 0; j < 7; j++)
+			nsum += tmp_sum[j];
+		nsum = ((nsum + 4) >> 3);
+
+		for (j = 0; j < 6; j++)
+			tmp_sum[j] = tmp_sum[j + 1];
+		tmp_sum[6] = nsum;
+	} else {
+		for (j = 0; j < 7; j++)
+			tmp_sum[j] = nsum;
+	}
+
+	if (dnlp_printk & 0x1)
+		pr_info("Bin0 Refine: -%4d\n", nsum);
+
+	if (nsum >= pre_0_gamma[0])
+		pre_0_gamma[0] = 0;
+	else
+		pre_0_gamma[0] = pre_0_gamma[0] - nsum;
+}
+
+static void dnlp_adp_alpharate(unsigned int *lmh_avg,
+	unsigned int *low_alpha, unsigned int *hgh_alpha,
+	unsigned int *pst_gmarat,
+	unsigned int dnlp_lowrange, unsigned int dnlp_hghrange)
+{
+	int nTmp = 0;
+	int ndif = 0;
+	int nlap = 0;
+	int nbrt0 = 0;
+	int nbrt1 = 0;
+
+	if (64 > dnlp_lowrange + lmh_avg[3]) { /* decrease low alpha */
+		nTmp = 64 - (dnlp_lowrange + lmh_avg[3]);
+		nTmp = (ve_dnlp_adpalpha_lrate * nTmp + 16) >> 5;
+		if (*low_alpha < nTmp)
+			*low_alpha = 0;
+		else
+			*low_alpha = *low_alpha - nTmp;
+
+		if (dnlp_printk)
+			pr_info("low alpha-- (%3d) -> %2d\n", nTmp, *low_alpha);
+	} else if (64 < lmh_avg[3]) { /* increase low alpha */
+		ndif = lmh_avg[3] - 64;
+		nlap = (ve_dnlp_adpalpha_lrate * ndif + 16) >> 5;
+		if ((nlap + *low_alpha) > 64)
+			*low_alpha = 64;
+		else
+			*low_alpha += nlap;
+
+		if (lmh_avg[4] < 16) {
+			nbrt0 = ve_dnlp_pstgma_brghtrat1 * (16 - lmh_avg[4]);
+			nbrt0 = (nbrt0 + 8) >> 4;
+		}
+		nbrt1 = (ve_dnlp_pstgma_brghtrate * ndif + 16) >> 6;
+
+		nTmp = nbrt0 + nbrt1;
+
+		if ((*pst_gmarat + nTmp) > 64)
+			*pst_gmarat = 64;
+		else
+			*pst_gmarat += nTmp;
+
+		if (dnlp_printk)
+			pr_info("low alpha++ (%3d) -> %2d pstgma(+%2d +%2d)(%2d)\n",
+			nlap, *low_alpha, nbrt0, nbrt1, *pst_gmarat);
+	}
+
+	/*
+	if (lmh_avg[1] > lmh_avg[0]) {
+		nTmp = (lmh_avg[1] - lmh_avg[0]) * ve_dnlp_adpalpha_lrate;
+		nTmp = (nTmp + 32) >> 6;
+		nTmp += *low_alpha;
+		if (nTmp < 0)
+			*low_alpha = 0;
+		else if (nTmp > 63)
+			*low_alpha = 64;
+		else
+			*low_alpha = nTmp;
+	}
+	*/
+
+	if (lmh_avg[2] < 64 - dnlp_hghrange) { /* decrease hgh alpha */
+		nTmp = 64 - dnlp_hghrange - lmh_avg[2];
+		nTmp = (ve_dnlp_adpalpha_hrate * nTmp + 16) >> 5;
+		if (*hgh_alpha < nTmp)
+			*hgh_alpha = 0;
+		else
+			*hgh_alpha = *hgh_alpha - nTmp;
+		if (dnlp_printk)
+			pr_info("hgh alpha-- (%3d) -> %2d\n", nTmp, *hgh_alpha);
+	} else if (lmh_avg[2] > 63) { /* increase hgh alpha */
+		nTmp = lmh_avg[2] - 63;
+		nTmp = (ve_dnlp_adpalpha_hrate * nTmp + 16) >> 5;
+		if ((nTmp + *hgh_alpha) > 64)
+			*hgh_alpha = 64;
+		else
+			*hgh_alpha += nTmp;
+
+		if (dnlp_printk)
+			pr_info("hgh alpha++ (%3d) -> %2d\n", nTmp, *hgh_alpha);
+	}
+
+	/*
+	if (lmh_avg[2] > lmh_avg[1]) {
+		nTmp = (lmh_avg[2] - lmh_avg[1]) * ve_dnlp_adpalpha_hrate;
+		nTmp = (nTmp + 32) >> 6;
+		nTmp += *hgh_alpha;
+		if (nTmp < 0)
+			*hgh_alpha = 0;
+		else if (nTmp > 63)
+			*hgh_alpha = 64;
+		else
+			*hgh_alpha = nTmp;
+	}
+	*/
+}
+
 static int PreTstDat[28];
 static int CrtTstDat[28];
 
+static void dnlp_tgt_sort(void)
+{
+	int i = 0;
+	int j = 0;
+	unsigned char t = 0;
+	int chk = 0;
+	/* unsigned char ve_dnlp_tgt[64]; */
+	for (j = 0; j < 63; j++) {
+		chk = 0;
+		for (i = 0; i < (63 - i); i++) {
+			if (ve_dnlp_tgt[i] > ve_dnlp_tgt[i+1]) {
+				t = ve_dnlp_tgt[i];
+				ve_dnlp_tgt[i] = ve_dnlp_tgt[i+1];
+				ve_dnlp_tgt[i+1] = t;
+				chk = chk+1;
+			}
+		}
+		if (chk == 0)
+			break;
+	}
+}
+
 static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 {
 	struct vframe_prop_s *p = &vf->prop;
@@ -2212,17 +2637,18 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	static unsigned int nTstCnt;
 
 	int i = 0;
-	static unsigned int sum_b;
+	/*static unsigned int sum_b;*/
 	unsigned int sum = 0, max = 0;
 	unsigned int nTmp = 0;
 	int nT0 = 0, nT1 = 0;
 	int nTmp0 = 0;
-	int RBASE = (1 << ve_dnlp_mvreflsh);
 
 	int dnlp_brightness = 0;
 	unsigned int mMaxLst[4];
 	unsigned int mMaxIdx[4];
 	int blk_wht_ext[2] = {0, 0};
+	static unsigned int pre_stur;
+	unsigned int dnlp_auto_rng = 0;
 
 	/*u4[0-8] smooth moving,reflesh the curve,0-refresh one frame*/
 	/*u8larger-->near to gamma1.8, smaller->gamma1.2 [0-256]dft60*/
@@ -2250,19 +2676,23 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	unsigned int mtdbld_rate = (unsigned int) ve_mtdbld_rate;
 
 	/*u6 dft32*/
-	unsigned int blkgma_rate = (unsigned int) ve_blkgma_rate;
+	unsigned int dnlp_pst_gmarat = (unsigned int) ve_dnlp_pst_gmarat;
+
+	unsigned int dnlp_lowrange = (unsigned int) ve_dnlp_lowrange;
+	unsigned int dnlp_hghrange = (unsigned int) ve_dnlp_hghrange;
+	unsigned int dnlp_bkgert   = (unsigned int) ve_dnlp_bkgert;
 
 	/*-------------------------------------------------*/
 	unsigned int lsft_avg = 0; /*luma shift average */
 	unsigned int luma_avg = 0;
 	unsigned int luma_avg4 = 0;
-	unsigned int tlma_avg4 = 0;
 	unsigned int low_lavg4 = 0; /*low luma average*/
+	unsigned int lmh_avg[5] = {0, 0, 0, 0, 0};
+	/* low/mid/hgh tone average */
 
 	unsigned int ihstBgn = 0;
 	unsigned int ihstEnd = 0;
 	bool prt_flg = 0;
-	/* char pLogs[256]; */
 
 	unsigned int rGm1p2[] = {0, 2, 4, 7, 9, 12, 15,
 					18, 21, 24, 28, 31, 34,
@@ -2289,6 +2719,11 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 		196, 203, 210, 218,
 		225, 233, 240, 248, 255};
 
+	if (ve_dnlp_mvreflsh < 1)
+		ve_dnlp_mvreflsh = 1;
+
+	RBASE = (1 << ve_dnlp_mvreflsh);
+
 	/* parameters refresh */
 	dnlp3_param_refrsh();
 	dnlp_scn_chg = 0;
@@ -2303,8 +2738,9 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 		clashEnd = 64;
 	if (clashEnd < 49)
 		clashEnd = 49;
+
 	/* old historic luma sum*/
-	sum_b = ve_dnlp_luma_sum;
+	/*sum_b = ve_dnlp_luma_sum;*/
 	/* new historic luma sum*/
 	if (hist_sel)
 		ve_dnlp_luma_sum = p->hist.vpp_luma_sum;
@@ -2316,10 +2752,6 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	if (nTstCnt > 240)
 		nTstCnt = 0;
 
-	if (!ve_dnlp_luma_sum)
-		/*new luma sum is 0,something is wrong,freeze dnlp curve*/
-		return;
-
 	nT0 = 0; /* counter the same histogram */
 	hstSum = 0;
 	for (i = 0; i < 64; i++) {
@@ -2341,8 +2773,15 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	}
 
 	if (dnlp_printk)
-		pr_info("\nRflsh%03d: %02d same bins\n",
-			nTstCnt, nT0);
+		pr_info("\nRflsh%03d: %02d same bins hstSum(%d)\n",
+			nTstCnt, nT0, hstSum);
+
+	if (!ve_dnlp_luma_sum) {
+		/*new luma sum is 0,something is wrong,freeze dnlp curve*/
+		dnlp_scn_chg = 1;
+		return;
+	}
+
 	for (i = 0; i < 28; i++)
 		PreTstDat[i] = CrtTstDat[i];
 
@@ -2356,17 +2795,27 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 		dnlp_bld_lvl = RBASE;
 		dnlp_scn_chg = 1;
 	}
-	if (dnlp_bld_lvl > RBASE)
-		dnlp_bld_lvl = RBASE;
+	/* if (dnlp_bld_lvl > RBASE)
+		dnlp_bld_lvl = RBASE; */
 	CrtTstDat[1] = dnlp_bld_lvl;
 
+	/*
+	hstSum = 0;
+	for (i = 0; i < 64; i++) {
+		hstSum += pre_0_gamma[i];
+	}
+	*/
+
+	/* black bord detection, and histogram clipping */
+	dnlp_refine_bin0(hstSum);
+
 	/* histogram and luma_sum filters */
 	dnlp_inhist_lpf();
 
 	hstSum = 0;
 	for (i = 0; i < 64; i++) {
 		if (pre_0_gamma[i] != 0) {
-			if (ihstBgn == 0)
+			if (ihstBgn == 0 && pre_0_gamma[0] == 0)
 				ihstBgn = i;
 			if (ihstEnd != 64)
 				ihstEnd = i+1;
@@ -2377,27 +2826,6 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	}
 	clash_curve[64] = 1024;
 
-	CrtTstDat[2] = clashBgn;
-	CrtTstDat[3] = clashEnd;
-	clash_fun(clash_curve, pre_0_gamma, clashBgn, clashEnd); /* 0~1024 */
-	clash_blend();
-
-	blk_wht_extsn(blk_wht_ext, pre_0_gamma, hstSum); /* 0~1024 */
-	CrtTstDat[4] = blk_wht_ext[0];
-	CrtTstDat[5] = blk_wht_ext[1];
-
-	if (dnlp_printk)
-		pr_info("BlkWhtExt: (%d %d), bldlvl=%02d\n",
-			blk_wht_ext[0], blk_wht_ext[1], dnlp_bld_lvl);
-
-	/* all the same */
-	if (nT0 == 64 && ve_dnlp_smhist_ck && (!ve_dnlp_respond_flag))
-		return;
-
-	sum = 0;
-	max = 0;
-	luma_avg = 0;
-
 	if (ve_dnlp_limit_rng) {
 		iRgnBgn = 4; /* i=ihstBgn, i<ihstEnd */
 		iRgnEnd = 59;
@@ -2418,6 +2846,14 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	CrtTstDat[8] = iRgnBgn;
 	CrtTstDat[9] = iRgnEnd;
 
+	/* all the same */
+	if (nT0 == 64 && ve_dnlp_smhist_ck && (!ve_dnlp_respond_flag))
+		return;
+
+	sum = 0;
+	max = 0;
+	luma_avg = 0;
+
 	/*Get the maximum4*/
 	mMaxLst[0] = 0;
 	mMaxLst[1] = 0;
@@ -2437,7 +2873,8 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 			max = nTmp;
 
 		/*lower extension [0-63]*/
-		luma_avg += nTmp*i;
+		nTmp0 = nTmp*i;
+		luma_avg += nTmp0;
 
 		if (i == 31)
 			low_lavg4 = luma_avg; /*low luma average*/
@@ -2464,15 +2901,8 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 					4*i, 4*(i+1), pre_1_gamma[i],
 					pre_0_gamma[i]);
 	    /* new historic luma sum*/
-		pr_info("luma b=%x, s=%x\n", sum_b, ve_dnlp_luma_sum);
-	    pr_info("hist-sum=%d max=%d\n", sum, max);
-	}
-
-	prt_flg = ((dnlp_printk >> 6) & 0x1);
-	if (prt_flg) {
-		pr_info("Max: %04d(%d) > %04d(%d) > %04d(%d) > %04d(%d)\n",
-		mMaxLst[0], mMaxIdx[0], mMaxLst[1], mMaxIdx[1],
-		mMaxLst[2], mMaxIdx[2], mMaxLst[3], mMaxIdx[3]);
+		pr_info("luma s=%x, hist-sum=%d max=%d\n",
+			ve_dnlp_luma_sum, sum, max);
 	}
 
 	/*invalid histgram: freeze dnlp curve*/
@@ -2484,20 +2914,42 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	luma_avg4 = (lsft_avg >> ve_dnlp_pavg_btsft);
 	luma_avg  = (luma_avg4>>2);
 
+	if (mMaxIdx[0] == 0)
+		nTmp = (mMaxIdx[1] * 2) + mMaxIdx[2] + mMaxIdx[3];
+	else {
+		if (mMaxIdx[1] == 0)
+			nTmp = mMaxIdx[0] + mMaxIdx[2] + mMaxIdx[3];
+		else if (mMaxIdx[2] == 0)
+			nTmp = mMaxIdx[0] + mMaxIdx[1] + mMaxIdx[3];
+		else if (mMaxIdx[3] == 0)
+			nTmp = mMaxIdx[0] + mMaxIdx[1] + mMaxIdx[2];
+		else
+			nTmp = mMaxIdx[1] + mMaxIdx[2] + mMaxIdx[3];
+
+		nTmp += mMaxIdx[0];
+	}
+	lmh_avg[4] = nTmp;
+
+	prt_flg = (dnlp_printk & 0x1);
+	if (prt_flg) {
+		pr_info("Max: %04d(%d) > %04d(%d) > %04d(%d) > %04d(%d) => %d\n",
+		mMaxLst[0], mMaxIdx[0], mMaxLst[1], mMaxIdx[1],
+		mMaxLst[2], mMaxIdx[2], mMaxLst[3], mMaxIdx[3], nTmp);
+		pr_info("%d => %d (%d)\n", luma_avg, lsft_avg, luma_avg4);
+	}
+
 	CrtTstDat[10] = lsft_avg;
 	CrtTstDat[11] = luma_avg4;
 
 	low_lavg4 = 4*low_lavg4/sum;
-	tlma_avg4 = (ve_dnlp_luma_sum + (hstSum >> 1)) / hstSum;
 	if (dnlp_printk)
-		pr_info("[avg1]= (%02d %02d) (%4d, %4d) (%3d, %3d)\n",
-			luma_avg, luma_avg4, lsft_avg, tlma_avg4,
+		pr_info("[avg1]= (%02d %02d) (%4d) (%3d, %3d)\n",
+			luma_avg, luma_avg4, lsft_avg,
 			gmma_rate, low_alpha);
 
 	dnlp_brightness = cal_brght_plus(luma_avg4, low_lavg4);
 
 	CrtTstDat[12] = low_lavg4;
-	CrtTstDat[13] = tlma_avg4;
 	CrtTstDat[14] = dnlp_brightness;
 
 	/*150918 for 32-step luma pattern*/
@@ -2507,6 +2959,109 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	luma_avg4 = cal_hist_avg(luma_avg4);
 	luma_avg = (luma_avg4>>2);
 
+	if (luma_avg < ve_dnlp_auto_rng)
+		dnlp_auto_rng = luma_avg;
+	else if (64 < luma_avg + ve_dnlp_auto_rng)
+		dnlp_auto_rng = 64 - luma_avg;
+	else
+		dnlp_auto_rng = ve_dnlp_auto_rng;
+
+	if (dnlp_auto_rng < 2)
+		dnlp_auto_rng = 2;
+	else if (dnlp_auto_rng > 10)
+		dnlp_auto_rng = 10;
+
+	if (ve_dnlp_auto_rng > 0) {
+		if (luma_avg <= dnlp_auto_rng + 2) {
+			dnlp_lowrange = 2;
+			dnlp_hghrange = 64 - (luma_avg + dnlp_auto_rng);
+		} else if (luma_avg >= 61 - dnlp_auto_rng) {
+			dnlp_lowrange = luma_avg - dnlp_auto_rng;
+			dnlp_hghrange = 2;
+		} else {
+			dnlp_lowrange = luma_avg - dnlp_auto_rng;
+			dnlp_hghrange = (63 - (luma_avg + dnlp_auto_rng));
+		}
+	} else {
+		dnlp_lowrange = ve_dnlp_lowrange;
+		dnlp_hghrange = ve_dnlp_hghrange;
+	}
+	if (dnlp_lowrange > 31)
+		dnlp_lowrange = 31;
+	else if (dnlp_lowrange < 2)
+		dnlp_lowrange = 2;
+	if (dnlp_hghrange > 31)
+		dnlp_hghrange = 31;
+	else if (dnlp_hghrange < 2)
+		dnlp_hghrange = 2;
+
+	for (i = iRgnBgn; i < iRgnEnd; i++) {
+		nTmp0 = pre_0_gamma[i] * i;
+
+		if (i < dnlp_lowrange) {/* low tone */
+			lmh_avg[0] += nTmp0;
+			lmh_avg[3] += pre_0_gamma[i] * (64 - i);
+		} else if (i > (63 - dnlp_hghrange))  /* hgh tone */
+			lmh_avg[2] += nTmp0;
+		else /* mid tone */
+			lmh_avg[1] += nTmp0;
+	}
+
+	/* low/mid/high tone average */
+	lmh_avg[0] = (lmh_avg[0] << 6) / dnlp_lowrange;
+	lmh_avg[3] = (lmh_avg[3] << 6) / dnlp_lowrange;
+	lmh_avg[1] = (lmh_avg[1] << 6) / (64 - dnlp_lowrange - dnlp_hghrange);
+	lmh_avg[2] = (lmh_avg[2] << 6) / dnlp_hghrange;
+
+	lmh_avg[0] = (lmh_avg[0] + (sum >> 1)) / (sum + 1);
+	lmh_avg[3] = (lmh_avg[3] + (sum >> 1)) / (sum + 1);
+	lmh_avg[1] = (lmh_avg[1] + (sum >> 1)) / (sum + 1);
+	lmh_avg[2] = (lmh_avg[2] + (sum >> 1)) / (sum + 1);
+	/*lmh_avg[3] = 64 - lmh_avg[3];*/
+
+	/* adaptive method rate */
+	if (dnlp_printk)
+		pr_info("Adp Mtd/PostGm Rate: %d %d gm(%d)",
+			luma_avg, mtdbld_rate, dnlp_pst_gmarat);
+
+	mtdbld_rate = dnlp_adp_mtdrate(mtdbld_rate, luma_avg);
+
+	/* post gamma rate: global -> auto local */
+	if (ve_dnlp_pst_gmarat > 64)
+		dnlp_pst_gmarat = ve_dnlp_pst_gmarat - 64;
+	else
+		dnlp_pst_gmarat = 64 - ve_dnlp_pst_gmarat;
+
+	dnlp_adp_alpharate(lmh_avg, &low_alpha, &hgh_alpha,
+		&dnlp_pst_gmarat, dnlp_lowrange, dnlp_hghrange);
+
+	if (ve_dnlp_pst_gmarat < 64) /* no adp dnlp_pst_gmarat */
+		dnlp_pst_gmarat = 64 - ve_dnlp_pst_gmarat;
+
+	if (dnlp_printk) {
+		pr_info("mtdbld: %2d (%2d %2d) => %2d (%2d %2d)\n",
+			ve_mtdbld_rate, ve_dnlp_lowalpha_new,
+			ve_dnlp_hghalpha_new,
+			mtdbld_rate, low_alpha, hgh_alpha);
+		pr_info("avg: l[ 0~%2d]=%2d(%2d) m=%2d h[%2d~63]=%2d\n",
+			dnlp_lowrange - 1, lmh_avg[0],
+			64 - lmh_avg[3], lmh_avg[1],
+			64 - dnlp_hghrange, lmh_avg[2]);
+	}
+
+	CrtTstDat[2] = clashBgn;
+	CrtTstDat[3] = clashEnd;
+	clash_fun(clash_curve, pre_0_gamma, clashBgn, clashEnd); /* 0~1024 */
+	clash_blend();
+
+	blk_wht_extsn(blk_wht_ext, pre_0_gamma, hstSum, luma_avg); /* 0~1024 */
+	CrtTstDat[4] = blk_wht_ext[0];
+	CrtTstDat[5] = blk_wht_ext[1];
+
+	if (dnlp_printk)
+		pr_info("BlkWhtExt: (%d %d), bldlvl=%02d\n",
+			blk_wht_ext[0], blk_wht_ext[1], dnlp_bld_lvl);
+
 	/*patch for black+white stripe*/
 	if (mMaxIdx[1] > mMaxIdx[0]) {
 		nT0 = mMaxIdx[0];
@@ -2536,10 +3091,10 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	dnlp_params_hist(&gmma_rate, &low_alpha, &hgh_alpha,
 		&mtdbld_rate, luma_avg, luma_avg4);
 
-	if (dnlp_printk)
-		pr_info("[avg2]= (%02d %02d) (%4d, %4d) (%3d, %3d)\n",
-			luma_avg, luma_avg4, lsft_avg, tlma_avg4,
-			gmma_rate, low_alpha);
+	if (dnlp_printk & 0x1)
+		pr_info("[avg2]= (%3d %3d) (%3d %3d) (%3d %3d)\n",
+			luma_avg, luma_avg4, gmma_rate, mtdbld_rate,
+			low_alpha, hgh_alpha);
 
 	CrtTstDat[15] = luma_avg4;
 	CrtTstDat[16] = luma_avg;
@@ -2547,27 +3102,29 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	CrtTstDat[18] = gmma_rate;
 	CrtTstDat[19] = low_alpha;
 
-	prt_flg = ((dnlp_printk >> 3) & 0x1);
+	prt_flg = (dnlp_printk & 0x1);
 	if (prt_flg) {
 		pr_info("Rflsh-check: %03u\n", nTstCnt);
 		pr_info("BldLvl= %02d\n", dnlp_bld_lvl);
 	}
 
-	/* Black gamma rate: global -> auto local */
+	if (dnlp_bkgert > dnlp_pst_gmarat)
+		dnlp_bkgert = dnlp_pst_gmarat;
+
 	for (i = 0; i < 64; i++) {
-		nT1 = blkgma_rate;
+		nT1 = dnlp_pst_gmarat;
 
 		if (i > ve_dnlp_bkgend)
-			nT1 = ve_dnlp_bkgert;
+			nT1 = dnlp_bkgert;
 		else if (ve_dnlp_bkgend > 0) {
-			nT1 = blkgma_rate - ve_dnlp_bkgert;
+			nT1 = dnlp_pst_gmarat - dnlp_bkgert;
 			nT1 = nT1 * i + (ve_dnlp_bkgend >> 1);
 			nT1 = nT1 / ve_dnlp_bkgend;
-			nT1 = blkgma_rate - nT1;
+			nT1 = dnlp_pst_gmarat - nT1;
 		}
 
 		if (ve_dnlp_limit_rng && (i <= 4)) {
-			nT1 = i * blkgma_rate;
+			nT1 = i * dnlp_pst_gmarat;
 			nT1 = ((nT1 + 2) >> 2);
 		}
 
@@ -2580,9 +3137,17 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	}
 
 	/* 0~1024 */
-	if (dnlp_printk)
+	if (dnlp_printk & 0x1)
 		pr_info("[avg3]= %02d %02d => %4d\n",
 			luma_avg, luma_avg4, lsft_avg);
+
+	if (ve_dnlp_scv_dbg != 0) {
+		nTmp0 = lsft_avg + 16 * ve_dnlp_scv_dbg;
+		if (nTmp0 < 0)
+			lsft_avg = 0;
+		else
+			lsft_avg = nTmp0;
+	}
 	GetGmCurves(gma_scurve0, rGm1p2, lsft_avg, sBgnBnd, sEndBnd);
 	GetGmCurves(gma_scurve1, rGm1p8, lsft_avg, sBgnBnd, sEndBnd);
 	GetGmBlkCvs(blk_gma_crv, rGm1p8, sBgnBnd, iRgnEnd);
@@ -2592,18 +3157,14 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	CrtTstDat[22] = lsft_avg;
 	CrtTstDat[23] = iRgnEnd;
 
-	prt_flg = ((dnlp_printk >> 4) & 0x1);
+	prt_flg = (dnlp_printk & 0x1);
 	if (prt_flg) {
 		pr_info("paramets: %d %d %d %d %d\n",
 			luma_avg, gmma_rate, low_alpha, hgh_alpha, mtdbld_rate);
-
-		pr_info("blk/wht ext: %d %d\n",
-			blk_wht_ext[0], blk_wht_ext[1]);
 	}
 
 	/*=========================================================*/
-	prt_flg = ((dnlp_printk >> 2) & 0x1);
-	if (prt_flg) {
+	if (dnlp_printk & 0x1) {
 		pr_info("dnlp blend curve:\n");
 		pr_info("[luma_sum] = %d\n", ve_dnlp_luma_sum);
 	}
@@ -2632,9 +3193,18 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 	dnlp_blkgma_bld(blk_gma_rat);
 
 	/* blkwht_ebld = blk_gma_bld + extension */
+	blk_wht_ext[0] +=  (ve_dnlp_set_bext << 4);
+	blk_wht_ext[1] +=  (ve_dnlp_set_wext << 4);
 	dnlp_blkwht_bld(blk_wht_ext, dnlp_brightness,
 		luma_avg4, luma_avg, iRgnBgn, iRgnEnd);
 
+	if (prt_flg) {
+		pr_info("blk/wht ext: [%d %d] + %d\n",
+			blk_wht_ext[0], blk_wht_ext[1],
+			dnlp_brightness);
+	}
+
+	prt_flg = ((dnlp_printk >> 2) & 0x1);
 	for (i = 0; i < 64; i++) {
 		premap0[i] = ve_dnlp_tgt[i];
 
@@ -2676,7 +3246,7 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 			nTmp0 = 0;
 
 		if (prt_flg)
-			pr_info("[%02d]: (%4d %4d)%4d %4d %4d (%4d) %4d %4d => %3d",
+			pr_info("[%02d]: (%4d %4d)%4d c%4d cs%4d gm%4d-%4d %4d => %3d\n",
 				i, gma_scurve0[i], gma_scurve1[i],
 				gma_scurvet[i], clash_curve[i],
 				clsh_scvbld[i], blk_gma_crv[i],
@@ -2686,17 +3256,57 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 		ve_dnlp_tgt[i] = nTmp0;
 	}
 
-	prt_flg = ((dnlp_printk >> 1) & 0x1);
+	/* 0~255 sort */
+	dnlp_tgt_sort();
+
+	prt_flg = ((dnlp_printk >> 3) & 0x1);
 	if (prt_flg) {
-		for (i = 0; i < 64; i++)
-			pr_info("%02d: %03d=>%03d\n",
-				i, 4*i, ve_dnlp_tgt[i]);
+		for (i = 0; i < 64; i++) {
+			nT0 = ve_dnlp_tgt[i] - 4*i;
+			pr_info("%02d: %03d=>%03d (%3d)\n",
+				i, 4*i, ve_dnlp_tgt[i], nT0);
+		}
 		pr_info("\n");
 	}
 
+	nT0 = 0;
+	nT1 = 0;
+	for (i = 1; i < 64; i++) {
+		if (ve_dnlp_tgt[i] > 4*i) {
+			nT0 += (ve_dnlp_tgt[i] - 4*i) * (65 - i);
+			nT1 += (65 - i);
+		}
+	}
+	nTmp0 = nT0 * ve_dnlp_satur_rat + (nT1 >> 1);
+	nTmp0 = nTmp0 / (nT1 + 1);
+	nTmp0 = ((nTmp0 + 4) >> 3);
+
+	nTmp =  (ve_dnlp_satur_max << 3);
+	if (nTmp0 < nTmp)
+		nTmp = nTmp0;
+
+	if (dnlp_printk)
+		pr_info("#Statu: pre(%3d) => %5d / %3d => %3d cur(%3d)\n",
+			pre_stur, nT0, nT1, nTmp0, nTmp);
+
+	if (ve_dnlp_set_saturtn == 0) {
+		if (nTmp != pre_stur) {
+			ve_dnlp_add_cm(nTmp + 512);
+			pre_stur = nTmp;
+		}
+	} else {
+		if (pre_stur != ve_dnlp_set_saturtn) {
+			if (ve_dnlp_set_saturtn < 512)
+				ve_dnlp_add_cm(ve_dnlp_set_saturtn + 512);
+			else
+				ve_dnlp_add_cm(ve_dnlp_set_saturtn);
+			pre_stur = ve_dnlp_set_saturtn;
+		}
+	}
+
 	if (dnlp_printk)
-		pr_info("#Dbg: [%02d < %02d(%03d vs %03d) < %02d] %03d\n",
-			iRgnBgn, luma_avg, luma_avg4, tlma_avg4,
+		pr_info("#Dbg: [%02d < %02d(%03d) < %02d] %03d\n",
+			iRgnBgn, luma_avg, luma_avg4,
 			iRgnEnd, dnlp_brightness);
 
 	nT0 = 0;
@@ -2713,39 +3323,22 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 			pr_info("#mrate=%02d brt=%02d\n",
 				mtdbld_rate, dnlp_brightness);
 			for (i = 0; i < 64; i++)
-				if ((premap0[i] != ve_dnlp_tgt[i]) ||
-					(pcurves[0][i] != gma_scurve0[i]) ||
-					(pcurves[1][i] != gma_scurve1[i]) ||
-					(pcurves[2][i] != gma_scurvet[i]) ||
-					(pcurves[3][i] != clash_curve[i]) ||
-					(pcurves[4][i] != clsh_scvbld[i]) ||
-					(pcurves[5][i] != blk_gma_crv[i]) ||
-					(pcurves[6][i] != blk_gma_bld[i]) ||
-					(pcurves[7][i] != blkwht_ebld[i])) {
-					pr_info("[%02d]%5d=>%5d:(%4d=>%4d)",
-						i, pre_1_gamma[i],
-						pre_0_gamma[i], pcurves[0][i],
-						gma_scurve0[i]);
-					pr_info(" (%4d=>%4d) (%4d=>%4d)",
-						pcurves[1][i], gma_scurve1[i],
-						pcurves[2][i], gma_scurvet[i]);
-					pr_info(" (%4d=>%4d) (%4d=>%4d)",
-						pcurves[3][i], clash_curve[i],
-						pcurves[4][i], clsh_scvbld[i]);
-					pr_info(" (%4d=>%4d) (%4d=>%4d)",
-						pcurves[5][i], blk_gma_crv[i],
-						pcurves[6][i], blk_gma_bld[i]);
-					pr_info(" (%4d=>%4d) (%4d=>%4d)",
-						pcurves[7][i], blkwht_ebld[i],
+				if (premap0[i] != ve_dnlp_tgt[i])
+					pr_info("[%02d]%5d=>%5d:(%4d=>%4d)\n",
+						i,
+						pre_1_gamma[i], pre_0_gamma[i],
 						premap0[i], ve_dnlp_tgt[i]);
-					}
-			pr_info("\n");
 
 			for (i = 0; i < 28; i++)
 				if (PreTstDat[i] != CrtTstDat[i])
 					pr_info("[%02d] %5d=>%5d\n",
 						i, PreTstDat[i], CrtTstDat[i]);
 			pr_info("\n");
+
+			if (ve_dnlp_ponce >= 2)
+				ve_dnlp_ponce--;
+			else
+				ve_dnlp_ponce = 1;
 		}
 	}
 
@@ -2755,6 +3348,10 @@ static void ve_dnlp_calculate_tgtx_new(struct vframe_s *vf)
 			pr_info("[%02d] %5d=>%5d\n",
 				i, pre_0_gamma[i], ve_dnlp_tgt[i]);
 
+	/* print debug log once */
+	if (ve_dnlp_ponce == 1 && dnlp_printk)
+		dnlp_printk = 0;
+
 	return;
 }
 
@@ -3189,7 +3786,7 @@ void ve_set_new_dnlp(struct ve_dnlp_table_s *p)
 	ve_dnlp_clashBgn  = p->new_clashBgn;
 	ve_dnlp_clashEnd  = p->new_clashEnd;
 	ve_mtdbld_rate    = p->new_mtdbld_rate;
-	ve_blkgma_rate    = p->new_blkgma_rate;
+	ve_dnlp_pst_gmarat    = p->new_dnlp_pst_gmarat;
 
 	dnlp_sel = p->dnlp_sel;
 	ve_dnlp_blk_cctr = p->dnlp_blk_cctr;
@@ -3212,6 +3809,28 @@ void ve_set_new_dnlp(struct ve_dnlp_table_s *p)
 	ve_dnlp_smhist_ck = p->dnlp_smhist_ck;
 	ve_dnlp_glb_crate = p->dnlp_glb_crate;
 
+	ve_dnlp_pstgma_brghtrate = p->dnlp_pstgma_brghtrate;
+	ve_dnlp_pstgma_brghtrat1 = p->dnlp_pstgma_brghtrat1;
+	ve_dnlp_wext_autorat = p->dnlp_wext_autorat;
+	ve_dnlp_cliprate_min = p->dnlp_cliprate_min;
+	ve_dnlp_adpcrat_lbnd = p->dnlp_adpcrat_lbnd;
+	ve_dnlp_adpcrat_hbnd = p->dnlp_adpcrat_hbnd;
+	ve_dnlp_adpmtd_lbnd = p->dnlp_adpmtd_lbnd;
+	ve_dnlp_adpmtd_hbnd = p->dnlp_adpmtd_hbnd;
+	ve_dnlp_set_bext = p->dnlp_set_bext;
+	ve_dnlp_set_wext = p->dnlp_set_wext;
+	ve_dnlp_satur_rat = p->dnlp_satur_rat;
+	ve_dnlp_satur_max = p->dnlp_satur_max;
+	ve_blk_prct_rng = p->blk_prct_rng;
+	ve_blk_prct_max = p->blk_prct_max;
+	ve_dnlp_lowrange = p->dnlp_lowrange;
+	ve_dnlp_hghrange = p->dnlp_hghrange;
+	ve_dnlp_auto_rng = p->dnlp_auto_rng;
+	ve_dnlp_bin0_absmax = p->dnlp_bin0_absmax;
+	ve_dnlp_bin0_sbtmax = p->dnlp_bin0_sbtmax;
+	ve_dnlp_adpalpha_lrate = p->dnlp_adpalpha_lrate;
+	ve_dnlp_adpalpha_hrate = p->dnlp_adpalpha_hrate;
+
 	ve_dnlp_lrate00 = p->dnlp_lrate00;
 	ve_dnlp_lrate02 = p->dnlp_lrate02;
 	ve_dnlp_lrate04 = p->dnlp_lrate04;
@@ -3694,10 +4313,16 @@ void ve_ogo_param_update(void)
 		video_rgb_ogo.b_pre_offset = -1024;
 	if (video_rgb_ogo.r_gain > 2047)
 		video_rgb_ogo.r_gain = 2047;
+	if (video_rgb_ogo.r_gain < 0)
+		video_rgb_ogo.r_gain = 0;
 	if (video_rgb_ogo.g_gain > 2047)
 		video_rgb_ogo.g_gain = 2047;
+	if (video_rgb_ogo.g_gain < 0)
+		video_rgb_ogo.g_gain = 0;
 	if (video_rgb_ogo.b_gain > 2047)
 		video_rgb_ogo.b_gain = 2047;
+	if (video_rgb_ogo.b_gain < 0)
+		video_rgb_ogo.b_gain = 0;
 	if (video_rgb_ogo.r_post_offset > 1023)
 		video_rgb_ogo.r_post_offset = 1023;
 	if (video_rgb_ogo.r_post_offset < -1024)
@@ -4026,7 +4651,7 @@ void vpp_vd1_mtx_rgb_contrast(signed int cont_val)
 }
 
 /*for gxbbtv contrast adj in vadj1*/
-void vpp_vd_adj1_contrast(signed int cont_val, struct vframe_s *vf)
+void vpp_vd_adj1_contrast(signed int cont_val)
 {
 	unsigned int vd1_contrast;
 	unsigned int vdj1_ctl;
@@ -4035,19 +4660,14 @@ void vpp_vd_adj1_contrast(signed int cont_val, struct vframe_s *vf)
 	cont_val = ((cont_val + 1024) >> 3);
 	/*VPP_VADJ_CTRL bit 1 off for contrast adj*/
 	vdj1_ctl = READ_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 1);
-	if (vf->source_type == VFRAME_SOURCE_TYPE_OTHERS) {
-		if (!vdj1_ctl)
-			WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 1, 1);
-	} else {
-		if (vdj1_ctl)
-			WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 0, 1, 1);
-	}
+	if (vdj1_ctl)
+		WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 0, 1, 1);
 
 	if (get_cpu_type() > MESON_CPU_MAJOR_ID_GXTVBB) {
-		vd1_contrast = (READ_VPP_REG(VPP_VADJ1_Y) & 0x1ff00) |
+		vd1_contrast = (READ_VPP_REG(VPP_VADJ1_Y) & 0x3ff00) |
 						(cont_val << 0);
 	} else {
-		vd1_contrast = (READ_VPP_REG(VPP_VADJ1_Y) & 0xff00) |
+		vd1_contrast = (READ_VPP_REG(VPP_VADJ1_Y) & 0x1ff00) |
 						(cont_val << 0);
 	}
 	WRITE_VPP_REG(VPP_VADJ1_Y, vd1_contrast);
@@ -4201,7 +4821,7 @@ void amvecm_bricon_process(unsigned int bri_val,
 		if (contrast_adj_sel)
 			vpp_vd1_mtx_rgb_contrast(cont_val);
 		else
-			vpp_vd_adj1_contrast(cont_val, vf);
+			vpp_vd_adj1_contrast(cont_val);
 		pr_amve_dbg("\n[amve..] set vd1_contrast OK!!!\n");
 	}
 
diff --git a/drivers/amlogic/amvecm/amve.h b/drivers/amlogic/amvecm/amve.h
index 39fa5e3..4842a87 100644
--- a/drivers/amlogic/amvecm/amve.h
+++ b/drivers/amlogic/amvecm/amve.h
@@ -120,6 +120,10 @@ extern unsigned int sync_3d_out_inv;
 
 extern void __iomem *amvecm_hiu_reg_base;
 
+#ifdef CONFIG_VSYNC_RDMA
+extern int VSYNC_WR_MPEG_REG(u32 adr, u32 val);
+extern u32 VSYNC_RD_MPEG_REG(u32 adr);
+#endif
 
 /* #if defined(CONFIG_ARCH_MESON2) */
 /* unsigned long long ve_get_vs_cnt(void); */
diff --git a/drivers/amlogic/amvecm/amvecm.c b/drivers/amlogic/amvecm/amvecm.c
index 31a008b..cdf3170 100644
--- a/drivers/amlogic/amvecm/amvecm.c
+++ b/drivers/amlogic/amvecm/amvecm.c
@@ -73,6 +73,8 @@ unsigned int sr1_reg_val[101];
 unsigned int sr1_ret_val[101];
 struct vpp_hist_param_s vpp_hist_param;
 static unsigned int pre_hist_height, pre_hist_width;
+static unsigned int pc_mode = 0xff;
+static unsigned int pc_mode_last = 0xff;
 
 void __iomem *amvecm_hiu_reg_base;/* = *ioremap(0xc883c000, 0x2000); */
 
@@ -737,6 +739,7 @@ void vpp_get_vframe_hist_info(struct vframe_s *vf)
 
 void amvecm_video_latch(void)
 {
+	pc_mode_process();
 	cm_latch_process();
 	amvecm_size_patch();
 	ve_dnlp_latch_process();
@@ -754,7 +757,6 @@ void amvecm_on_vs(struct vframe_s *vf)
 {
 	if (probe_ok == 0)
 		return;
-	amvecm_video_latch();
 
 	if (vf != NULL) {
 		/* matrix ajust */
@@ -762,10 +764,13 @@ void amvecm_on_vs(struct vframe_s *vf)
 
 		amvecm_bricon_process(
 			vd1_brightness,
-			vd1_contrast  + vd1_contrast_offset, vf);
+			vd1_contrast + vd1_contrast_offset, vf);
 	} else
 		amvecm_matrix_process(NULL);
 
+	/* pq latch process */
+	amvecm_video_latch();
+
 	pq_enable_disable();
 }
 EXPORT_SYMBOL(amvecm_on_vs);
@@ -1891,7 +1896,7 @@ static ssize_t amvecm_hdr_dbg_show(struct class *cla,
 {
 	int ret;
 
-	ret = amvecm_hdr_dbg();
+	ret = amvecm_hdr_dbg(0);
 
 	return 0;
 }
@@ -1903,11 +1908,29 @@ static ssize_t amvecm_hdr_dbg_store(struct class *cla,
 	return 0;
 }
 
+static ssize_t amvecm_hdr_reg_show(struct class *cla,
+			struct class_attribute *attr, char *buf)
+{
+	int ret;
+
+	ret = amvecm_hdr_dbg(1);
+
+	return 0;
+}
+
+static ssize_t amvecm_hdr_reg_store(struct class *cla,
+			struct class_attribute *attr,
+			const char *buf, size_t count)
+{
+	return 0;
+}
+
 static ssize_t amvecm_pc_mode_show(struct class *cla,
 			struct class_attribute *attr, char *buf)
 {
 	pr_info("pc:echo 0x0 > /sys/class/amvecm/pc_mode\n");
 	pr_info("other:echo 0x1 > /sys/class/amvecm/pc_mode\n");
+	pr_info("pc_mode:%d,pc_mode_last:%d\n", pc_mode, pc_mode_last);
 	return 0;
 }
 
@@ -1916,12 +1939,26 @@ static ssize_t amvecm_pc_mode_store(struct class *cla,
 			const char *buf, size_t count)
 {
 	size_t r;
-	int val, reg_val;
-	r = sscanf(buf, "0x%x", &val);
+	int val;
+	r = sscanf(buf, "%x", &val);
 	if ((r != 1))
 		return -EINVAL;
 
 	if (val == 1) {
+		pc_mode = 1;
+		pc_mode_last = 0xff;
+	} else if (val == 0) {
+		pc_mode = 0;
+		pc_mode_last = 0xff;
+	}
+
+	return count;
+}
+
+void pc_mode_process(void)
+{
+	unsigned int reg_val;
+	if ((pc_mode == 1) && (pc_mode != pc_mode_last)) {
 		/* open dnlp clock gate */
 		dnlp_en = 1;
 		ve_enable_dnlp();
@@ -1960,7 +1997,8 @@ static ssize_t amvecm_pc_mode_store(struct class *cla,
 				reg_val | 0x4000);
 
 		WRITE_VPP_REG(VPP_VADJ_CTRL, 0xd);
-	} else if (val == 0) {
+		pc_mode_last = pc_mode;
+	} else if ((pc_mode == 0) && (pc_mode != pc_mode_last)) {
 		dnlp_en = 0;
 		ve_disable_dnlp();
 		cm_en = 0;
@@ -1997,9 +2035,8 @@ static ssize_t amvecm_pc_mode_store(struct class *cla,
 				reg_val & 0xffffbfff);
 
 		WRITE_VPP_REG(VPP_VADJ_CTRL, 0x0);
+		pc_mode_last = pc_mode;
 	}
-
-	return count;
 }
 
 /* #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV) */
@@ -2148,6 +2185,8 @@ static struct class_attribute amvecm_class_attrs[] = {
 		amvecm_dump_vpp_hist_show, amvecm_dump_vpp_hist_store),
 	__ATTR(hdr_dbg, S_IRUGO | S_IWUSR,
 			amvecm_hdr_dbg_show, amvecm_hdr_dbg_store),
+	__ATTR(hdr_reg, S_IRUGO | S_IWUSR,
+			amvecm_hdr_reg_show, amvecm_hdr_reg_store),
 	__ATTR(gamma_pattern, S_IRUGO | S_IWUSR,
 		set_gamma_pattern_show, set_gamma_pattern_store),
 	__ATTR(pc_mode, S_IRUGO | S_IWUSR,
diff --git a/drivers/amlogic/canvas/canvas_mgr.c b/drivers/amlogic/canvas/canvas_mgr.c
index e088826..58be5f9 100644
--- a/drivers/amlogic/canvas/canvas_mgr.c
+++ b/drivers/amlogic/canvas/canvas_mgr.c
@@ -507,7 +507,7 @@ static void canvas_pool_config(void)
 	canvas_pool_register_const_canvas(0x60, 0x65, "display");
 	canvas_pool_register_const_canvas(0x70, 0x77, "ppmgr");
 	canvas_pool_register_const_canvas(0xe4, 0xef, "encoder");
-	canvas_pool_register_const_canvas(0x40, 0x44, "osd");
+	canvas_pool_register_const_canvas(0x40, 0x48, "osd");
 	canvas_pool_register_const_canvas(0x4e, 0x5f, "vm");
 	canvas_pool_register_const_canvas(0xc0, 0xd7, "amlvideo2");
 	/*please add static canvas later. */
diff --git a/drivers/amlogic/cec/hdmi_ao_cec.c b/drivers/amlogic/cec/hdmi_ao_cec.c
index a046e32..79632e0 100644
--- a/drivers/amlogic/cec/hdmi_ao_cec.c
+++ b/drivers/amlogic/cec/hdmi_ao_cec.c
@@ -80,23 +80,6 @@ static struct early_suspend aocec_suspend_handler;
 #define CEC_EARLY_SUSPEND	(1 << 0)
 #define CEC_DEEP_SUSPEND	(1 << 1)
 
-#define NONE (-1)
-#define KEY_VOLUME_UP   (1)
-#define KEY_VOLUME_DOWN (2)
-#define RUNNING   		(1)
-#define STOP   			(0)
-
-struct hrtimer	key_repeat_timer;
-static struct work_struct key_repeat_wq;
-static ktime_t ktime;
-static unsigned int interval=280000; /* unit: us */ 
-
-static int key_value = NONE;
-static int timer_status = STOP;
-
-void no_work(void){};
-void (*pFunc)(void) = no_work;
-
 
 /* global struct for tx and rx */
 struct ao_cec_dev {
@@ -1074,6 +1057,7 @@ static void cec_rx_process(void)
 	int initiator, follower;
 	int opcode;
 	unsigned char msg[MAX_MSG] = {};
+	int dest_phy_addr;
 
 	if (len < 2 || !new_msg)		/* ignore ping message */
 		return;
@@ -1099,6 +1083,14 @@ static void cec_rx_process(void)
 		}
 		break;
 
+	case CEC_OC_ROUTING_CHANGE:
+		dest_phy_addr = msg[4] << 8 | msg[5];
+		if (dest_phy_addr == cec_dev->phy_addr) {
+			CEC_INFO("wake up by ROUTING_CHANGE\n");
+			cec_key_report(0);
+		}
+		break;
+
 	case CEC_OC_GET_CEC_VERSION:
 		cec_give_version(initiator);
 		break;
@@ -1170,8 +1162,8 @@ static void cec_task(struct work_struct *work)
 	struct delayed_work *dwork;
 
 	dwork = &cec_dev->cec_work;
-	if (cec_dev && !wake_ok &&
-	   !(cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL))) {
+	if (cec_dev && (!wake_ok ||
+	   !(cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL)))) {
 		cec_rx_process();
 	}
 	if (!ee_cec && !cec_late_check_rx_buffer())
@@ -1448,156 +1440,6 @@ static ssize_t fun_cfg_show(struct class *cla,
 
 	return sprintf(buf, "0x%x\n", reg & 0xff);
 }
-//add by yipie support cec audio volume adjust 2016.08.08 begin
-enum hrtimer_restart key_repeat( struct hrtimer *timer )  
-{  
-    schedule_work(&key_repeat_wq);	
-    return HRTIMER_NORESTART;  
-} 
-
-void key_volume_up(void){
-	unsigned char msg[5];
-	unsigned char index;
-	if(NULL ==cec_dev)
-	{
-		return;
-	}
-	index = cec_dev->cec_info.log_addr;
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_USER_CONTROL_PRESSED;
-	msg[2] = 0x41;
-	cec_ll_tx(msg, 3);
-	printk("volume up\n");
-}
-
-void cec_pass_volume_up(void){
-	if(key_value != KEY_VOLUME_UP){		
-		if(timer_status == RUNNING){
-			hrtimer_cancel(&key_repeat_timer);
-		}
-		key_repeat_timer.function = key_repeat;   
-		ktime = ktime_set( interval/1000000, (interval%1000000)*1000 );  
-		hrtimer_start(&key_repeat_timer, ktime, HRTIMER_MODE_REL );
-		timer_status = RUNNING;
-		key_value = KEY_VOLUME_UP;
-		pFunc = key_volume_up;
-		pFunc();
-	}
-}
-
-
-void key_volume_down(void){
-	unsigned char msg[5];
-	unsigned char index;
-	if(NULL ==cec_dev)
-	{
-		return;
-	}	
-	index = cec_dev->cec_info.log_addr;
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_USER_CONTROL_PRESSED;
-	msg[2] = 0x42;
-	cec_ll_tx(msg, 3);
-	printk("volume down\n");
-}
-
-void cec_pass_volume_down(void){
-	if(key_value != KEY_VOLUME_DOWN){		
-		if(timer_status == RUNNING){
-			hrtimer_cancel(&key_repeat_timer);
-		}
-		key_repeat_timer.function = key_repeat;   
-		ktime = ktime_set( interval/1000000, (interval%1000000)*1000 );  
-		hrtimer_start(&key_repeat_timer, ktime, HRTIMER_MODE_REL );
-		timer_status = RUNNING;
-		key_value = KEY_VOLUME_DOWN;
-		pFunc = key_volume_down;
-		pFunc();
-	}
-}
-
-void cec_pass_key_release(void){
-	unsigned char msg[5];
-	unsigned char index;
-	if(NULL ==cec_dev)
-	{
-		return;
-	}
-	index = cec_dev->cec_info.log_addr;
-	if(timer_status == RUNNING){
-		hrtimer_cancel(&key_repeat_timer);
-	}
-	pFunc = no_work;
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_USER_CONTROL_RELEASED;
-	cec_ll_tx(msg, 2);
-	timer_status = STOP;
-	key_value = NONE;
-	printk("release key\n");
-}
-
-static ssize_t store_cec_key(struct class *cla,
-	struct class_attribute *attr, const char *buf, size_t count)
-{
-	if(!strncmp(buf,"rls",3)){
-		cec_pass_key_release();
-	}else if(!strncmp(buf,"up",2)){
-		cec_pass_volume_up();
-	}else if(!strncmp(buf,"down",4)){
-		cec_pass_volume_down();
-	}
-	return count;	
-}
-
-static void key_reapt_func(struct work_struct *work){
-	key_repeat_timer.function = key_repeat;   
-    ktime = ktime_set( interval/1000000, (interval%1000000)*1000 );  
-    hrtimer_start(&key_repeat_timer, ktime, HRTIMER_MODE_REL ); 
-	pFunc();
-}
-#if 0
-void cec_polling_online_dev(int log_addr, int *bool)
-{
-	unsigned int r;
-	unsigned char msg[1];
-	int retry = 5;
-
-	msg[0] = (log_addr<<4) | log_addr;
-	/* set broadcast address first */
-	cec_logicaddr_set(0xf);
-	if (cec_msg_dbg_en == 1)
-		hdmi_print(INF, CEC "CEC_LOGICAL_ADDR0:0x%lx\n",
-			   aocec_rd_reg(CEC_LOGICAL_ADDR0));
-	while (retry) {
-		r = cec_ll_tx_polling(msg, 1);
-		if (r == TX_BUSY) {
-			retry--;
-			hdmi_print(INF, CEC "try log addr %x busy, retry:%d\n",
-				   log_addr, retry);
-			/*
-			 * try to reset CEC if tx busy is found
-			 */
-			cec_hw_reset();
-		} else
-			break;
-	}
-
-	if (r == TX_ERROR) {
-		*bool = 0;
-	} else if (r == TX_DONE) {
-		memset(&(cec_dev->cec_info.cec_node_info[log_addr]),
-			0, sizeof(struct cec_node_info_t));
-		cec_global_info.cec_node_info[log_addr].dev_type =
-			cec_log_addr_to_dev_type(log_addr);
-		*bool = 1;
-	}
-	hdmi_print(LOW, CEC "CEC: poll online logic device: 0x%x BOOL: %d\n",
-		log_addr, *bool);
-
-}
-#endif
-
-//add by yipie support cec audio volume adjust 2016.08.08 end
 
 static struct class_attribute aocec_class_attr[] = {
 	__ATTR_WO(cmd),
@@ -1613,8 +1455,7 @@ static struct class_attribute aocec_class_attr[] = {
 	__ATTR(menu_language, 0664, menu_language_show, menu_language_store),
 	__ATTR(device_type, 0664, device_type_show, device_type_store),
 	__ATTR(dbg_en, 0664, dbg_en_show, dbg_en_store),
-	__ATTR(fun_cfg, 0664, fun_cfg_show, fun_cfg_store),	
-	__ATTR(cec_key, 0666, NULL, store_cec_key),
+	__ATTR(fun_cfg, 0664, fun_cfg_show, fun_cfg_store),
 	__ATTR_NULL
 };
 
@@ -2199,9 +2040,6 @@ static int aml_cec_probe(struct platform_device *pdev)
 	/* for init */
 	cec_pre_init();
 	queue_delayed_work(cec_dev->cec_thread, &cec_dev->cec_work, 0);
-	hrtimer_init(&key_repeat_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	key_repeat_timer.function = key_repeat;
-	INIT_WORK(&key_repeat_wq, key_reapt_func); 
 	return 0;
 }
 
@@ -2218,7 +2056,6 @@ static int aml_cec_remove(struct platform_device *pdev)
 	unregister_chrdev(cec_dev->cec_info.dev_no, CEC_DEV_NAME);
 	class_unregister(&aocec_class);
 	kfree(cec_dev);
-	hrtimer_cancel(&key_repeat_timer);
 	return 0;
 }
 
diff --git a/drivers/amlogic/clk/Makefile b/drivers/amlogic/clk/Makefile
index 751d3d4..896a94f 100644
--- a/drivers/amlogic/clk/Makefile
+++ b/drivers/amlogic/clk/Makefile
@@ -3,9 +3,10 @@
 #
 
 
-obj-$(CONFIG_AMLOGIC_CLK)	+= clk.o clk-pll.o clk_measure.o \
-				   clk-meson8m2.o hdmi-clk.o rstc.o \
-				   clk_sys.o gp0_pll.o clk_mpll_clock.o \
-				   clk-gxbb.o clk-gxtvbb.o clk-gxl.o \
-				   gpu_clk.o gxbb_hdmi_clk.o gxtvbb_hdmi_clk.o \
-				   gp0_pll_gxl.o
+obj-$(CONFIG_AMLOGIC_CLK) += clk.o clk-pll.o clk_measure.o \
+                             clk-meson8m2.o hdmi-clk.o rstc.o \
+                             clk_sys.o gp0_pll.o clk_mpll_clock.o \
+                             clk-gxbb.o clk-gxtvbb.o \
+                             clk-gxl.o clk-txl.o \
+                             gpu_clk.o gxbb_hdmi_clk.o gxtvbb_hdmi_clk.o \
+                             gp0_pll_gxl.o
diff --git a/drivers/amlogic/clk/clk-gxbb.c b/drivers/amlogic/clk/clk-gxbb.c
index cf9d6f5..8f855af 100644
--- a/drivers/amlogic/clk/clk-gxbb.c
+++ b/drivers/amlogic/clk/clk-gxbb.c
@@ -54,6 +54,7 @@ static void __iomem *reg_base_aobus;
 #define	HHI_AUD_CLK_CNTL2		OFFSET(0x64)
 #define	HHI_BT656_CLK_CNTL		OFFSET(0xf5)
 #define	HHI_VID_LOCK_CLK_CNTL		OFFSET(0xf2)
+#define	HHI_PCM_CLK_CNTL		OFFSET(0x96)
 
 #define GXBB_RSTC_N_REGS	6
 #define GXBB_AO_OFF		((GXBB_RSTC_N_REGS - 1) * BITS_PER_LONG + 4)
@@ -68,6 +69,11 @@ PNAME(cts_am_p) = {"ddr_pll_clk", "mpll_clk_out0", "mpll_clk_out1",
 							"mpll_clk_out2"};
 PNAME(cts_i958_p) = {"NULL", "mpll_clk_out0", "mpll_clk_out1", "mpll_clk_out2"};
 PNAME(cts_spdif_p) = {"cts_amclk", "cts_i958"};
+
+PNAME(mux_pcm_0_p) = {"mpll_clk_out0", "fclk_div4", "fclk_div3", "fclk_div5"};
+PNAME(mux_pcm_1_p) = {"mux_pcm_0_p"};
+
+
 PNAME(mux_vapb_0_p) = {"fclk_div4", "fclk_div3", "fclk_div5", "fclk_div7"};
 PNAME(mux_vapb_1_p) = {"fclk_div4", "fclk_div3", "fclk_div5", "fclk_div7"};
 
@@ -154,6 +160,20 @@ static struct amlogic_clk_branch clk_branches[] __initdata = {
 			CLK_DIVIDER_ROUND_CLOSEST,
 			HHI_AUD_CLK_CNTL2, 24, 0),
 
+	COMPOSITE(CLK_PCM_MCLK, "clk_pcm_mclk", mux_pcm_0_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_PCM_CLK_CNTL, 10, 2, 0,
+			HHI_PCM_CLK_CNTL, 0, 9,
+			CLK_DIVIDER_ROUND_CLOSEST,
+			HHI_PCM_CLK_CNTL, 9, 0),
+
+	COMPOSITE_NOMUX(CLK_PCM_SCLK, "clk_pcm_sclk", mux_pcm_1_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_PCM_CLK_CNTL,
+			HHI_PCM_CLK_CNTL, 16, 5,
+			CLK_DIVIDER_ROUND_CLOSEST,
+			HHI_PCM_CLK_CNTL, 22, 0),
+
 	COMPOSITE(CLK_BT656_CLK0, "cts_bt656_clk0", cts_bt656_clk0_p,
 			CLK_SET_RATE_NO_REPARENT,
 			HHI_BT656_CLK_CNTL, 9, 2, 0,
diff --git a/drivers/amlogic/clk/clk-gxl.c b/drivers/amlogic/clk/clk-gxl.c
index 8d269c4..b747751 100644
--- a/drivers/amlogic/clk/clk-gxl.c
+++ b/drivers/amlogic/clk/clk-gxl.c
@@ -53,6 +53,7 @@ static void __iomem *reg_base_aobus;
 #define	HHI_AUD_CLK_CNTL2		OFFSET(0x64)
 #define	HHI_BT656_CLK_CNTL		OFFSET(0xf5)
 #define	HHI_VID_LOCK_CLK_CNTL		OFFSET(0xf2)
+#define	HHI_PCM_CLK_CNTL		OFFSET(0x96)
 
 #define gxl_RSTC_N_REGS	6
 #define gxl_AO_OFF		((gxl_RSTC_N_REGS - 1) * BITS_PER_LONG + 4)
@@ -67,6 +68,11 @@ PNAME(cts_am_p) = {"ddr_pll_clk", "mpll_clk_out0", "mpll_clk_out1",
 							"mpll_clk_out2"};
 PNAME(cts_i958_p) = {"NULL", "mpll_clk_out0", "mpll_clk_out1", "mpll_clk_out2"};
 PNAME(cts_spdif_p) = {"cts_amclk", "cts_i958"};
+
+PNAME(mux_pcm_0_p) = {"mpll_clk_out0", "fclk_div4", "fclk_div3", "fclk_div5"};
+PNAME(mux_pcm_1_p) = {"mux_pcm_0_p"};
+
+
 PNAME(mux_vapb_0_p) = {"fclk_div4", "fclk_div3", "fclk_div5", "fclk_div7"};
 PNAME(mux_vapb_1_p) = {"fclk_div4", "fclk_div3", "fclk_div5", "fclk_div7"};
 
@@ -148,6 +154,20 @@ static struct amlogic_clk_branch clk_branches[] __initdata = {
 			CLK_DIVIDER_ROUND_CLOSEST,
 			HHI_AUD_CLK_CNTL2, 24, 0),
 
+	COMPOSITE(CLK_PCM_MCLK, "clk_pcm_mclk", mux_pcm_0_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_PCM_CLK_CNTL, 10, 2, 0,
+			HHI_PCM_CLK_CNTL, 0, 9,
+			CLK_DIVIDER_ROUND_CLOSEST,
+			HHI_PCM_CLK_CNTL, 9, 0),
+
+	COMPOSITE_NOMUX(CLK_PCM_SCLK, "clk_pcm_sclk", mux_pcm_1_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_PCM_CLK_CNTL,
+			HHI_PCM_CLK_CNTL, 16, 5,
+			CLK_DIVIDER_ROUND_CLOSEST,
+			HHI_PCM_CLK_CNTL, 22, 0),
+
 	COMPOSITE(CLK_BT656_CLK0, "cts_bt656_clk0", cts_bt656_clk0_p,
 			CLK_SET_RATE_NO_REPARENT,
 			HHI_BT656_CLK_CNTL, 9, 2, 0,
diff --git a/drivers/amlogic/clk/clk-txl.c b/drivers/amlogic/clk/clk-txl.c
new file mode 100644
index 0000000..81dd02d
--- /dev/null
+++ b/drivers/amlogic/clk/clk-txl.c
@@ -0,0 +1,320 @@
+/*
+ * drivers/amlogic/clk/clk-txl.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <dt-bindings/clock/txl.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include "mpll_clk.h"
+
+#include "clk.h"
+
+#undef pr_fmt
+#define pr_fmt(fmt) "txl_clk: " fmt
+
+static void __iomem *reg_base_hiubus;
+static void __iomem *reg_base_aobus;
+
+
+#define	OFFSET(x)	(x << 2)
+#undef	HHI_GCLK_MPEG0
+#undef	HHI_MALI_CLK_CNTL
+#undef	HHI_VAPBCLK_CNTL
+#undef	HHI_XTAL_DIVN_CNTL
+
+#define	HHI_GCLK_MPEG0			OFFSET(0x50)
+#define	HHI_MALI_CLK_CNTL		OFFSET(0x6c)
+#define	HHI_VAPBCLK_CNTL		OFFSET(0x7d)
+#define	HHI_XTAL_DIVN_CNTL		OFFSET(0x2f)
+
+#undef HHI_MPLL_CNTL
+#define	HHI_MPLL_CNTL			OFFSET(0xa0)
+#define	HHI_MPLL_CNTL7			OFFSET(0xa6)
+#define	HHI_MPLL_CNTL8			OFFSET(0xa7)
+#define	HHI_MPLL_CNTL9			OFFSET(0xa8)
+#define	HHI_AUD_CLK_CNTL3		OFFSET(0x69)
+#define	HHI_AUD_CLK_CNTL		OFFSET(0x5e)
+#define	HHI_AUD_CLK_CNTL2		OFFSET(0x64)
+#define	HHI_BT656_CLK_CNTL		OFFSET(0xf5)
+#define	HHI_VID_LOCK_CLK_CNTL		OFFSET(0xf2)
+#define	HHI_VDIN_MEAS_CLK_CNTL	OFFSET(0x94)
+/* hdmirx */
+#define HHI_HDMIRX_CLK_CNTL		OFFSET(0x80)
+#define HHI_HDMIRX_AUD_CLK_CNTL	OFFSET(0x81)
+
+#define TXL_RSTC_N_REGS	6
+#define TXL_AO_OFF		((TXL_RSTC_N_REGS - 1) * BITS_PER_LONG + 4)
+PNAME(mux_mali_0_p) = {"xtal", "gp0_pll", "mpll_clk_out1", "mpll_clk_out2",
+		"fclk_div7", "fclk_div4", "fclk_div3", "fclk_div5"};
+PNAME(mux_mali_1_p) = {"xtal", "gp0_pll", "mpll_clk_out1", "mpll_clk_out2",
+		"fclk_div7", "fclk_div4", "fclk_div3", "fclk_div5"};
+PNAME(mux_mali_p)   = {"clk_mali_0", "clk_mali_1"};
+PNAME(mpll) = {"fixed_pll"};
+PNAME(cts_pdm_p) = {"amclk", "mpll_clk_out0", "mpll_clk_out1", "mpll_clk_out2"};
+PNAME(cts_am_p) = {"ddr_pll_clk", "mpll_clk_out0", "mpll_clk_out1",
+							"mpll_clk_out2"};
+PNAME(cts_i958_p) = {"NULL", "mpll_clk_out0", "mpll_clk_out1", "mpll_clk_out2"};
+PNAME(cts_spdif_p) = {"cts_amclk", "cts_i958"};
+PNAME(mux_vapb_0_p) = {"fclk_div4", "fclk_div3", "fclk_div5", "fclk_div7"};
+PNAME(mux_vapb_1_p) = {"fclk_div4", "fclk_div3", "fclk_div5", "fclk_div7"};
+
+PNAME(mux_ge2d_p) = {"clk_vapb_0", "clk_vapb_1"};
+
+PNAME(cts_bt656_clk0_p) = {"fclk_div2", "fclk_div3", "fclk_div5", "fclk_div7"};
+
+PNAME(cts_vid_lock_clk_p) = {"xtal", "cts_encl_clk", "cts_enci_clk",
+							"cts_encp_clk"};
+PNAME(cts_vdin_meas_clk_p) = {"xtal", "fclk_div4", "fclk_div3", "fclk_div5",
+		"vid_pll_clk", "vid2_pll_clk"};
+/* hdmirx */
+PNAME(clk_modet_clk_p) = {"xtal", "fclk_div4", "fclk_div3", "fclk_div5"};
+PNAME(clk_cfg_clk_p) = {"xtal", "fclk_div4", "fclk_div3", "fclk_div5"};
+PNAME(clk_acr_ref_clk_p) = {"fclk_div4", "fclk_div3", "fclk_div5", "fclk_div7"};
+PNAME(clk_audmeas_clk_p) = {"fclk_div4", "fclk_div3", "fclk_div5", "fclk_div7"};
+/* fixed rate clocks generated outside the soc */
+static struct amlogic_fixed_rate_clock txl_fixed_rate_ext_clks[] __initdata = {
+/*obtain the clock speed of external fixed clock sources from device tree*/
+	FRATE(CLK_XTAL, "xtal", NULL, CLK_IS_ROOT, 24000000),
+	FRATE(0, "32Khz", NULL, CLK_IS_ROOT, 32000),
+	FRATE(CLK_81, "clk81", NULL, CLK_IS_ROOT, 166666666),
+	FRATE(CLK_FIXED_PLL, "fixed_pll", NULL, CLK_IS_ROOT, 2000000000),
+	FRATE(CLK_FPLL_DIV2, "fclk_div2", NULL, CLK_IS_ROOT, 1000000000),
+	FRATE(CLK_FPLL_DIV3, "fclk_div3", NULL, CLK_IS_ROOT,  666666666),
+	FRATE(CLK_FPLL_DIV4, "fclk_div4", NULL, CLK_IS_ROOT,  500000000),
+	FRATE(CLK_FPLL_DIV5, "fclk_div5", NULL, CLK_IS_ROOT,  400000000),
+	FRATE(CLK_FPLL_DIV7, "fclk_div7", NULL, CLK_IS_ROOT,  285714285),
+};
+static struct amlogic_mux_clock mux_clks[] __initdata = {
+	MUX(CLK_MALI, "clk_mali", mux_mali_p, HHI_MALI_CLK_CNTL, 31, 1, 0),
+	MUX(CLK_SPDIF, "clk_spdif", cts_spdif_p, HHI_AUD_CLK_CNTL2, 27, 1, 0)
+};
+
+
+static struct of_device_id ext_clk_match[] __initdata = {
+	{ .compatible = "amlogic,clock-xtal", .data = (void *)0, },
+	{},
+};
+static struct amlogic_clk_branch clk_branches[] __initdata = {
+	COMPOSITE(CLK_MALI_0, "clk_mali_0", mux_mali_0_p,
+		   CLK_SET_RATE_NO_REPARENT,
+		   HHI_MALI_CLK_CNTL, 9, 3, 0,
+		   HHI_MALI_CLK_CNTL, 0, 7,
+		   CLK_DIVIDER_ROUND_CLOSEST,
+		   HHI_MALI_CLK_CNTL, 8, 0),
+	COMPOSITE(CLK_MALI_1, "clk_mali_1", mux_mali_1_p,
+		   CLK_SET_RATE_NO_REPARENT,
+		   HHI_MALI_CLK_CNTL, 25, 3, 0,
+		   HHI_MALI_CLK_CNTL, 16, 7,
+		   CLK_DIVIDER_ROUND_CLOSEST,
+		   HHI_MALI_CLK_CNTL, 24, 0),
+	COMPOSITE(CLK_VAPB_0, "clk_vapb_0", mux_vapb_0_p,
+		   CLK_SET_RATE_NO_REPARENT,
+		   HHI_VAPBCLK_CNTL, 9, 3, 0,
+		   HHI_VAPBCLK_CNTL, 0, 7, 0,
+		   HHI_VAPBCLK_CNTL, 8, 0),
+	COMPOSITE(CLK_VAPB_1, "clk_vapb_1", mux_vapb_1_p,
+		   CLK_SET_RATE_NO_REPARENT,
+		   HHI_VAPBCLK_CNTL, 25, 3, 0,
+		   HHI_VAPBCLK_CNTL, 16, 7, 0,
+		   HHI_VAPBCLK_CNTL, 24, 0),
+	COMPOSITE_NODIV(CLK_GE2D, "clk_ge2d", mux_ge2d_p,
+		   CLK_SET_RATE_NO_REPARENT,
+		   HHI_VAPBCLK_CNTL, 31, 1, 0,
+		   HHI_VAPBCLK_CNTL, 30, 0),
+
+	COMPOSITE(CLK_AMCLK, "cts_amclk", cts_am_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_AUD_CLK_CNTL, 9, 2, 0,
+			HHI_AUD_CLK_CNTL, 0, 8,
+			CLK_DIVIDER_ROUND_CLOSEST,
+			HHI_AUD_CLK_CNTL, 8, 0),
+
+	COMPOSITE(CLK_PDM, "cts_pdm", cts_pdm_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_AUD_CLK_CNTL3, 17, 2, 0,
+			HHI_AUD_CLK_CNTL3, 0, 16, 0,
+			HHI_AUD_CLK_CNTL3, 16, 0),
+
+	COMPOSITE(CLK_I958, "cts_i958", cts_i958_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_AUD_CLK_CNTL2, 25, 2, 0,
+			HHI_AUD_CLK_CNTL2, 16, 8,
+			CLK_DIVIDER_ROUND_CLOSEST,
+			HHI_AUD_CLK_CNTL2, 24, 0),
+
+	COMPOSITE(CLK_BT656_CLK0, "cts_bt656_clk0", cts_bt656_clk0_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_BT656_CLK_CNTL, 9, 2, 0,
+			HHI_BT656_CLK_CNTL, 0, 7,
+			CLK_DIVIDER_ROUND_CLOSEST,
+			HHI_BT656_CLK_CNTL, 7, 0),
+
+	COMPOSITE(CLK_BT656_CLK1, "cts_bt656_clk1", cts_bt656_clk0_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_BT656_CLK_CNTL, 25, 2, 0,
+			HHI_BT656_CLK_CNTL, 16, 7,
+			CLK_DIVIDER_ROUND_CLOSEST,
+			HHI_BT656_CLK_CNTL, 23, 0),
+
+	COMPOSITE(CLK_VID_LOCK_CLK, "cts_vid_lock_clk", cts_vid_lock_clk_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_VID_LOCK_CLK_CNTL, 8, 2, 0,
+			HHI_VID_LOCK_CLK_CNTL, 0, 7, 0,
+			HHI_VID_LOCK_CLK_CNTL, 7, 0),
+	COMPOSITE(CLK_VDIN_MEAS_CLK, "cts_vdin_meas_clk", cts_vdin_meas_clk_p,
+			CLK_SET_RATE_NO_REPARENT,
+			HHI_VDIN_MEAS_CLK_CNTL, 9, 3, 0,
+			HHI_VDIN_MEAS_CLK_CNTL, 0, 7, 0,
+			HHI_VDIN_MEAS_CLK_CNTL, 8, 0),
+	/* hdmirx_modet clk */
+	COMPOSITE(CLK_HDMIRX_MODET_CLK, "clk_hdmirx_modet_clk", clk_modet_clk_p,
+					CLK_SET_RATE_NO_REPARENT,
+					HHI_HDMIRX_CLK_CNTL, 25, 2, 0,
+					HHI_HDMIRX_CLK_CNTL, 16, 7,
+					CLK_DIVIDER_ROUND_CLOSEST,
+					HHI_HDMIRX_CLK_CNTL, 24, 1),
+	COMPOSITE(CLK_HDMIRX_CFG_CLK, "clk_hdmirx_cfg_clk", clk_cfg_clk_p,
+					CLK_SET_RATE_NO_REPARENT,
+					HHI_HDMIRX_CLK_CNTL, 9, 2, 0,
+					HHI_HDMIRX_CLK_CNTL, 0, 7,
+					CLK_DIVIDER_ROUND_CLOSEST,
+					HHI_HDMIRX_CLK_CNTL, 8, 1),
+	/* hdmirx_config clk */
+	COMPOSITE(CLK_HDMIRX_ACR_REF_CLK, "clk_hdmirx_acr_ref_clk",
+					clk_acr_ref_clk_p,
+					CLK_SET_RATE_NO_REPARENT,
+					HHI_HDMIRX_AUD_CLK_CNTL, 25, 2, 0,
+					HHI_HDMIRX_AUD_CLK_CNTL, 16, 7,
+					CLK_DIVIDER_ROUND_CLOSEST,
+					HHI_HDMIRX_AUD_CLK_CNTL, 24, 0),
+	/* hdmirx_config clk */
+	COMPOSITE(CLK_HDMIRX_AUDMEAS_CLK, "clk_hdmirx_audmeas_clk",
+					clk_audmeas_clk_p,
+					CLK_SET_RATE_NO_REPARENT,
+					HHI_HDMIRX_AUD_CLK_CNTL, 9, 2, 0,
+					HHI_HDMIRX_AUD_CLK_CNTL, 0, 7,
+					CLK_DIVIDER_ROUND_CLOSEST,
+					HHI_HDMIRX_AUD_CLK_CNTL, 8, 1),
+};
+static struct mpll_clk_tab mpll_tab[] __initdata = {
+	MPLL("mpll_clk_out0", mpll, HHI_MPLL_CNTL7, HHI_MPLL_CNTL,
+			CLK_MPLL0, CLK_SET_RATE_NO_REPARENT),
+	MPLL("mpll_clk_out1", mpll, HHI_MPLL_CNTL8, 0,
+			CLK_MPLL1, CLK_SET_RATE_NO_REPARENT),
+	MPLL("mpll_clk_out2", mpll, HHI_MPLL_CNTL9, 0,
+			CLK_MPLL2, CLK_SET_RATE_NO_REPARENT),
+
+};
+
+static struct amlogic_gate_clock clk_gates[] __initdata = {
+	GATE(CLK_CAMERA_12M, "clk_camera_12", "xtal",
+	HHI_XTAL_DIVN_CNTL, 11, CLK_SET_RATE_NO_REPARENT,
+	0, 0),
+	GATE(CLK_CAMERA_24M, "clk_camera_24", "xtal",
+	HHI_XTAL_DIVN_CNTL, 10, CLK_SET_RATE_NO_REPARENT,
+	0, 0),
+};
+
+/* register gxl clocks */
+static void __init txl_clk_init(struct device_node *np)
+{
+
+	reg_base_hiubus = of_iomap(np, 0);
+	reg_base_aobus = of_iomap(np, 1);
+	if ((!reg_base_hiubus) || (!reg_base_aobus))
+		panic("%s: failed to map registers\n", __func__);
+
+	pr_debug("HIU base is 0x%p\n", reg_base_hiubus);
+	pr_debug("ao base is 0x%p\n", reg_base_aobus);
+
+	amlogic_clk_init(np, reg_base_hiubus, reg_base_aobus,
+			CLK_NR_CLKS, NULL, 0, NULL, 0);
+	amlogic_clk_of_register_fixed_ext(txl_fixed_rate_ext_clks,
+		  ARRAY_SIZE(txl_fixed_rate_ext_clks), ext_clk_match);
+	mpll_clk_init(reg_base_hiubus, mpll_tab, ARRAY_SIZE(mpll_tab));
+	amlogic_clk_register_mux(mux_clks,
+			ARRAY_SIZE(mux_clks));
+	amlogic_clk_register_branches(clk_branches,
+		  ARRAY_SIZE(clk_branches));
+	amlogic_clk_register_gate(clk_gates,
+	  ARRAY_SIZE(clk_gates));
+	meson_register_rstc(np, TXL_RSTC_N_REGS, reg_base_aobus,
+		reg_base_hiubus + HHI_GCLK_MPEG0, TXL_AO_OFF, 0);
+	sys_pll_init(reg_base_hiubus, np, CLK_SYS_PLL);
+	gp0_clk_gxl_init(reg_base_hiubus, GP0_PLL);
+
+	{
+		/* Dump clocks */
+		char *clks[] = {
+				"xtal",
+				"32Khz",
+				"clk81",
+				"fixed_pll",
+				"fclk_div2",
+				"fclk_div3",
+				"fclk_div4",
+				"fclk_div5",
+				"fclk_div7",
+		};
+		int i;
+		int count = ARRAY_SIZE(clks);
+		struct clk *vapb;
+		struct clk *fixdiv5;
+
+		struct clk *clk_mali_0;
+		struct clk *clk_mali;
+
+		for (i = 0; i < count; i++) {
+			char *clk_name = clks[i];
+			pr_info("[ %s \t] ->clockrate: %luHz\n", clk_name,
+				_get_rate(clk_name));
+		}
+
+		/* Force set vapb clock as 400MHZ and enable it */
+		fixdiv5 = clk_get_sys("fclk_div5", "fclk_div5");
+		vapb = clk_get_sys("clk_vapb_0", "clk_vapb_0");
+		if ((!IS_ERR(vapb)) && (!IS_ERR(fixdiv5))) {
+			clk_set_parent(vapb, fixdiv5);
+			clk_set_rate(vapb, 400000000);
+			clk_prepare_enable(vapb);
+		}
+		if (!IS_ERR(fixdiv5))
+			clk_put(fixdiv5);
+		if (!IS_ERR(vapb))
+			clk_put(vapb);
+
+		/*Force set mali clock to 400M"*/
+		clk_mali_0 = clk_get_sys("clk_mali_0", "clk_mali_0");
+		clk_mali = clk_get_sys("clk_mali_0", "clk_mali_0");
+		if ((!IS_ERR(clk_mali_0)) && (!IS_ERR(clk_mali))) {
+			clk_set_parent(clk_mali_0, fixdiv5);
+			clk_set_parent(clk_mali, clk_mali_0);
+			clk_prepare_enable(clk_mali);
+		}
+		if (!IS_ERR(clk_mali_0))
+			clk_put(clk_mali_0);
+		if (!IS_ERR(clk_mali))
+			clk_put(clk_mali);
+		if (!IS_ERR(fixdiv5))
+			clk_put(fixdiv5);
+
+	}
+	pr_info("clock initialization complete\n");
+}
+CLK_OF_DECLARE(txl, "amlogic, txl-clock", txl_clk_init);
diff --git a/drivers/amlogic/clk/clk.h b/drivers/amlogic/clk/clk.h
index a848f1a..769bfa7 100644
--- a/drivers/amlogic/clk/clk.h
+++ b/drivers/amlogic/clk/clk.h
@@ -300,7 +300,7 @@ enum amlogic_clk_branch_type {
 		.id		= _id,				\
 		.branch_type	= branch_composite,		\
 		.name		= cname,			\
-		.parent_names	= (const char *[]){ pname },	\
+		.parent_names	= pname,	\
 		.num_parents	= 1,				\
 		.flags		= f,				\
 		.mux_offset	= mo,				\
diff --git a/drivers/amlogic/clk/clk_measure.c b/drivers/amlogic/clk/clk_measure.c
index e88662b..58f2009 100644
--- a/drivers/amlogic/clk/clk_measure.c
+++ b/drivers/amlogic/clk/clk_measure.c
@@ -533,6 +533,107 @@ int gxm_clk_measure(struct seq_file *s, void *what, unsigned int index)
 	return 0;
 }
 
+int txl_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	const char *clk_table[] = {
+		[82] = "Cts_ge2d_clk       ",
+		[81] = "Cts_vapbclk        ",
+		[80] = "Rng_ring_osc_clk[3]",
+		[79] = "Rng_ring_osc_clk[2]",
+		[78] = "Rng_ring_osc_clk[1]",
+		[77] = "Rng_ring_osc_clk[0]",
+		[76] = "cts_aoclk_int      ",
+		[75] = "cts_aoclkx2_int    ",
+		[74] = "cts_atv_dmd_vdac_clk ",
+		[73] = "cts_pwm_C_clk      ",
+		[72] = "cts_pwm_D_clk      ",
+		[71] = "cts_pwm_E_clk      ",
+		[70] = "cts_pwm_F_clk      ",
+		[69] = "Cts_hdcp22_skp     ",
+		[68] = "Cts_hdcp22_esm     ",
+		[67] = "tvfe_sample_clk      ",
+		[66] = "cts_vid_lock_clk   ",
+		[65] = "0                  ",
+		[64] = "Cts_hdmirx_cfg_clk ",
+		[63] = "0                  ",
+		[62] = "cts_hevc_clk       ",
+		[61] = "gpio_clk_msr       ",
+		[60] = "alt_32k_clk        ",
+		[59] = "cts_hcodec_clk     ",
+		[58] = "Hdmirx_aud_clk     ",
+		[57] = "Cts_hdmirx_audmeas ",
+		[56] = "Cts_hdmirx_modet_clk",
+		[55] = "vid_pll_div_clk_out	",
+		[54] = "Cts_hdmirx_arc_ref_clk",
+		[53] = "Sd_emmc_clk_A		",
+		[52] = "Sd_emmc_clk_B		",
+		[51] = "Cts_nand_core_clk	",
+		[50] = "Mp3_clk_out			",
+		[49] = "mp2_clk_out			",
+		[48] = "mp1_clk_out			",
+		[47] = "ddr_dpll_pt_clk		",
+		[46] = "cts_vpu_clk			",
+		[45] = "cts_pwm_A_clk		",
+		[44] = "cts_pwm_B_clk		",
+		[43] = "fclk_div5			",
+		[42] = "mp0_clk_out			",
+		[41] = "eth_rx_clk_or_clk_rmii",
+		[40] = "cts_pcm_mclk			",
+		[39] = "cts_pcm_sclk			",
+		[38] = "Cts_vdin_meas_clk		",
+		[37] = "cts_clk_i958			",
+		[36] = "cts_hdmi_tx_pixel_clk ",
+		[35] = "cts_mali_clk			",
+		[34] = "0					",
+		[33] = "0					",
+		[32] = "cts_vdec_clk			",
+		[31] = "MPLL_CLK_TEST_OUT	",
+		[30] = "Hdmirx_audmeas_clk	",
+		[29] = "Hdmirx_pix_clk		",
+		[28] = "Cts_sar_adc_clk		",
+		[27] = "Hdmirx_mpll_div_clk		",
+		[26] = "sc_clk_int			   ",
+		[25] = "Hdmirx_tmds_clk			",
+		[24] = "Hdmirx_aud_pll_clk		",
+		[23] = "HDMI_CLK_TODIG		   ",
+		[22] = "eth_phy_ref_clk		   ",
+		[21] = "i2s_clk_in_src0		   ",
+		[20] = "rtc_osc_clk_out		   ",
+		[19] = "cts_hdmitx_sys_clk	   ",
+		[18] = "sys_cpu_clk_div16		   ",
+		[17] = "sys_pll_div16					   ",
+		[16] = "cts_FEC_CLK_2		   ",
+		[15] = "cts_FEC_CLK_1		   ",
+		[14] = "cts_FEC_CLK_0		   ",
+		[13] = "cts_amclk			   ",
+		[12] = "Cts_pdm_clk			   ",
+		[11] = "mac_eth_tx_clk	   ",
+		[10] = "cts_vdac_clk			   ",
+		[9] = "cts_encl_clk			  " ,
+		[8] = "cts_encp_clk			  " ,
+		[7] = "clk81					  " ,
+		[6] = "cts_enci_clk			  " ,
+		[5] = "gp1_pll_clk			  " ,
+		[4] = "gp0_pll_clk			  " ,
+		[3] = "A53_ring_osc_clk		  " ,
+		[2] = "am_ring_osc_clk_out_ee[2]" ,
+		[1] = "am_ring_osc_clk_out_ee[1]" ,
+		[0] = "am_ring_osc_clk_out_ee[0]" ,
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, gxbb_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", gxbb_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+	return 0;
+}
 
 int gxtvbb_clk_measure(struct seq_file *s, void *what, unsigned int index)
 {
@@ -635,11 +736,28 @@ int gxtvbb_clk_measure(struct seq_file *s, void *what, unsigned int index)
 	clk_msr_index = 0xff;
 	return 0;
 }
-
-void meson_clk_measure(unsigned int clk_mux)
+int  meson_clk_measure(unsigned int clk_mux)
 {
-	if (is_meson_m8m2_cpu())
-		m8m2_clk_measure(clk_mux);
+	int clk_val;
+	switch (get_cpu_type()) {
+	case MESON_CPU_MAJOR_ID_M8M2:
+		clk_val = m8m2_clk_measure(clk_mux);
+	break;
+	case MESON_CPU_MAJOR_ID_GXBB:
+	case MESON_CPU_MAJOR_ID_GXL:
+	case MESON_CPU_MAJOR_ID_GXM:
+	case MESON_CPU_MAJOR_ID_TXL:
+		clk_val = gxbb_clk_util_clk_msr(clk_mux);
+	break;
+	case MESON_CPU_MAJOR_ID_GXTVBB:
+		clk_val = gxtvbb_clk_util_clk_msr(clk_mux);
+	break;
+	default:
+		pr_info("Unsupported chip clk measure\n");
+		clk_val = 0;
+	break;
+	}
+	return clk_val;
 
 }
 EXPORT_SYMBOL(meson_clk_measure);
@@ -654,6 +772,8 @@ static int dump_clk(struct seq_file *s, void *what)
 		gxl_clk_measure(s, what, clk_msr_index);
 	else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
 		gxm_clk_measure(s, what, clk_msr_index);
+	else if (get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)
+		txl_clk_measure(s, what, clk_msr_index);
 	return 0;
 }
 
@@ -718,6 +838,25 @@ static void __init gxl_clock_msr_init(struct device_node *np)
 		msr_clk_reg0, msr_clk_reg2);
 }
 CLK_OF_DECLARE(gxl_clk_msr, "amlogic, gxl_measure", gxl_clock_msr_init);
+static void __init txl_clock_msr_init(struct device_node *np)
+{
+	static struct dentry *debugfs_root;
+	debugfs_root = debugfs_create_dir("aml_clkmsr", NULL);
+	if (IS_ERR(debugfs_root) || !debugfs_root) {
+		pr_warn("failed to create debugfs directory\n");
+		debugfs_root = NULL;
+		return;
+	}
+
+	debugfs_create_file("clkmsr", S_IFREG | S_IRUGO,
+			    debugfs_root, NULL, &clkmsr_file_ops);
+
+	msr_clk_reg0 = of_iomap(np, 0);
+	msr_clk_reg2 = of_iomap(np, 1);
+	pr_info("Txl msr_clk_reg0=%p,msr_clk_reg2=%p\n",
+		msr_clk_reg0, msr_clk_reg2);
+}
+CLK_OF_DECLARE(txl_clk_msr, "amlogic, txl_measure", txl_clock_msr_init);
 
 static void __init gxbb_clock_msr_init(struct device_node *np)
 {
diff --git a/drivers/amlogic/clk/clk_mpll_clock.c b/drivers/amlogic/clk/clk_mpll_clock.c
index a769b12..5fee72d 100644
--- a/drivers/amlogic/clk/clk_mpll_clock.c
+++ b/drivers/amlogic/clk/clk_mpll_clock.c
@@ -39,6 +39,8 @@
 #define N2_MIN		4
 #define SDM_MAX	16384
 #define ERROR		10000000
+#define SDM_EN      15
+#define EN_DDS      14
 
 static int mpll_enable(struct clk_hw *hw)
 {
@@ -51,6 +53,9 @@ static int mpll_enable(struct clk_hw *hw)
 		writel(val, mpll->con_reg2);
 	}
 
+	val = readl(mpll->con_reg);
+	val = val | (1 << SDM_EN) | (1 << EN_DDS);
+	writel(val, mpll->con_reg);
 	return 0;
 }
 
@@ -63,6 +68,10 @@ static void mpll_disable(struct clk_hw *hw)
 		val &= ~(1 <<  mpll->SSEN_shift);
 		writel(val, mpll->con_reg2);
 	}
+
+	val = readl(mpll->con_reg);
+	val = val & (~((1 << SDM_EN) | (1 << EN_DDS)));
+	writel(val, mpll->con_reg);
 }
 
 static unsigned long mpll_recalc_rate(struct clk_hw *hw,
@@ -114,7 +123,7 @@ static int mpll_set_rate(struct clk_hw *hw, unsigned long drate,
 	val &=  ~(n_mask(mpll) << mpll->n_in_shift);
 	val |= mpll->n_in <<  mpll->n_in_shift;
 	writel(val, mpll->con_reg);
-
+	pr_debug("readl con_reg=%x\n", readl(mpll->con_reg));
 	return 0;
 }
 
diff --git a/drivers/amlogic/clocksource/Kconfig b/drivers/amlogic/clocksource/Kconfig
index 2568009..01a23a9 100644
--- a/drivers/amlogic/clocksource/Kconfig
+++ b/drivers/amlogic/clocksource/Kconfig
@@ -1,6 +1,22 @@
-config MESON_TIMER
-	bool "meson timer support"
+menuconfig MESON_TIMER
+    boolean "Amlogic Meson timer driver"
+    default n
+    help
+      This is the Amlogic Meson driver interface driver
+if MESON_TIMER
+config MESON_LOCAL_TIMER
+	boolean "meson local timer support"
 	def_bool n
+	depends on MESON_TIMER
 	select CLKSRC_OF if OF
 	help
 	  This is a new clocksource driver for amlogic timer
+
+config MESON_BC_TIMER
+	boolean "meson broadcast timer support"
+	def_bool n
+	depends on MESON_TIMER
+	select CLKSRC_OF if OF
+	help
+	  This is a new clocksource driver for amlogic timer
+endif
diff --git a/drivers/amlogic/clocksource/Makefile b/drivers/amlogic/clocksource/Makefile
index 1a8f9cf..8d839af 100644
--- a/drivers/amlogic/clocksource/Makefile
+++ b/drivers/amlogic/clocksource/Makefile
@@ -1 +1,2 @@
-obj-$(CONFIG_MESON_TIMER)	+= meson_timer.o
+obj-$(CONFIG_MESON_LOCAL_TIMER)	+= meson_timer.o
+obj-$(CONFIG_MESON_BC_TIMER)	+= meson_bc_timer.o
diff --git a/drivers/amlogic/clocksource/meson_bc_timer.c b/drivers/amlogic/clocksource/meson_bc_timer.c
new file mode 100644
index 0000000..76bb6b4
--- /dev/null
+++ b/drivers/amlogic/clocksource/meson_bc_timer.c
@@ -0,0 +1,273 @@
+/*
+ * drivers/amlogic/clocksource/meson_timer.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/stat.h>
+#include <asm/memory.h>
+#include <linux/sched_clock.h>
+#include <linux/of.h>
+#include <asm/smp_plat.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/cpu.h>
+
+#undef pr_fmt
+#define pr_fmt(fmt) "meson_bc_timer: " fmt
+
+/***********************************************************************
+ * System timer
+ **********************************************************************/
+#define TIMER_E_RESOLUTION_BIT         8
+#define TIMER_E_ENABLE_BIT        20
+#define TIMER_E_RESOLUTION_MASK       (7UL << TIMER_E_RESOLUTION_BIT)
+#define TIMER_E_RESOLUTION_SYS           0
+#define TIMER_E_RESOLUTION_1us           1
+#define TIMER_E_RESOLUTION_10us          2
+#define TIMER_E_RESOLUTION_100us         3
+#define TIMER_E_RESOLUTION_1ms           4
+
+#define TIMER_DI_RESOLUTION_BIT         6
+#define TIMER_CH_RESOLUTION_BIT         4
+#define TIMER_BG_RESOLUTION_BIT         2
+#define TIMER_AF_RESOLUTION_BIT         0
+
+#define TIMER_DI_ENABLE_BIT         19
+#define TIMER_CH_ENABLE_BIT         18
+#define TIMER_BG_ENABLE_BIT         17
+#define TIMER_AF_ENABLE_BIT         16
+
+#define TIMER_DI_MODE_BIT         15
+#define TIMER_CH_MODE_BIT         14
+#define TIMER_BG_MODE_BIT         13
+#define TIMER_AF_MODE_BIT         12
+
+#define TIMER_RESOLUTION_1us            0
+#define TIMER_RESOLUTION_10us           1
+#define TIMER_RESOLUTION_100us          2
+#define TIMER_RESOLUTION_1ms            3
+
+
+static struct clock_event_device bc_clock_event;
+void __iomem *timer_ctrl_base;
+
+static inline void aml_set_reg32_mask(void __iomem *_reg, const uint32_t _mask)
+{
+	uint32_t _val;
+
+	_val = readl_relaxed(_reg) | _mask;
+
+	writel_relaxed(_val , _reg);
+}
+
+static inline void aml_write_reg32(void __iomem *_reg, const uint32_t _value)
+{
+	writel_relaxed(_value, _reg);
+}
+
+static inline void aml_clr_reg32_mask(void __iomem *_reg, const uint32_t _mask)
+{
+	writel_relaxed((readl_relaxed(_reg) & (~(_mask))), _reg);
+}
+
+static inline void
+aml_set_reg32_bits(void __iomem *_reg, const uint32_t _value,
+		const uint32_t _start, const uint32_t _len)
+{
+	writel_relaxed(((readl_relaxed(_reg) &
+					~(((1L << (_len))-1) << (_start))) |
+				(((_value)&((1L<<(_len))-1)) << (_start))),
+				_reg);
+}
+
+
+
+/********** Clock Event Device, Timer-ABCD/FGHI *********/
+
+struct meson_clock {
+	struct irqaction	irq;
+	const char *name;	/*A,B,C,D,F,G,H,I*/
+	int	bit_enable;
+	int	bit_mode;
+	int	bit_resolution;
+	void __iomem *mux_reg;
+	void __iomem *reg;
+	unsigned int init_flag;
+};
+static struct meson_clock bc_clock;
+static irqreturn_t meson_timer_interrupt(int irq, void *dev_id);
+static int meson_set_next_event(unsigned long evt,
+				struct clock_event_device *dev);
+static void meson_clkevt_set_mode(enum clock_event_mode mode,
+				  struct clock_event_device *dev);
+
+
+static DEFINE_SPINLOCK(time_lock);
+
+static void meson_clkevt_set_mode(enum clock_event_mode mode,
+				  struct clock_event_device *dev)
+{
+	struct meson_clock *clk = &bc_clock;
+
+	spin_lock(&time_lock);
+	switch (mode) {
+	case CLOCK_EVT_MODE_RESUME:
+		/* printk(KERN_INFO"Resume timer%s\n", dev->name); */
+		aml_set_reg32_bits(clk->mux_reg, 1,
+				clk->bit_enable, 1);
+	break;
+
+	case CLOCK_EVT_MODE_PERIODIC:
+		aml_set_reg32_bits(clk->mux_reg, 1, clk->bit_mode, 1);
+		aml_set_reg32_bits(clk->mux_reg, 1,
+				clk->bit_enable, 1);
+		/* printk("Periodic timer %s!,mux_reg=%x\n", \
+		 dev->name,readl_relaxed(clk->mux_reg)); */
+	break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		aml_set_reg32_bits(clk->mux_reg, 0, clk->bit_mode, 1);
+		aml_set_reg32_bits(clk->mux_reg, 1,
+				clk->bit_enable, 1);
+		/* pr_info("One shot timer %s!mux_reg=%x\n", \
+		  dev->name,readl_relaxed(clk->mux_reg)); */
+	break;
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_UNUSED:
+		/* pr_info("Disable timer %p %s\n",dev,dev->name); */
+		aml_set_reg32_bits(clk->mux_reg, 0,
+				clk->bit_enable, 1);
+	break;
+	}
+	spin_unlock(&time_lock);
+}
+static int meson_set_next_event(unsigned long evt,
+				struct clock_event_device *dev)
+{
+	struct meson_clock *clk =  &bc_clock;
+	/* use a big number to clear previous trigger cleanly */
+	aml_set_reg32_mask(clk->reg, evt & 0xffff);
+	/* then set next event */
+	aml_set_reg32_bits(clk->reg, evt, 0, 16);
+	return 0;
+}
+
+
+/* Clock event timer interrupt handler */
+static irqreturn_t meson_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = dev_id;
+	if (evt == NULL || evt->event_handler == NULL) {
+		WARN_ONCE(evt == NULL || evt->event_handler == NULL,
+			"%p %s %p %d",
+			evt, evt?evt->name:NULL,
+			evt?evt->event_handler:NULL, irq);
+		return IRQ_HANDLED;
+	}
+	evt->event_handler(evt);
+	return IRQ_HANDLED;
+
+}
+static void  meson_timer_init_device(struct clock_event_device *evt)
+{
+	evt->mult = div_sc(1000000, NSEC_PER_SEC, 20);
+	evt->max_delta_ns =
+		clockevent_delta2ns(0xfffe, evt);
+	evt->min_delta_ns = clockevent_delta2ns(1, evt);
+	evt->cpumask = cpu_all_mask;
+}
+
+/*
+ * This sets up the system timers, clock source and clock event.
+ */
+void  clockevent_init_and_register(struct device_node *np)
+{
+	struct device_node *timer;
+	struct meson_clock *mclk = &bc_clock;
+	struct clock_event_device *clock_evt = &bc_clock_event;
+
+	timer = np;
+	if (!timer) {
+		pr_info(" * %s missing timer phandle\n",
+				     timer->full_name);
+		return;
+	}
+	if (of_property_read_string(timer, "timer_name", &clock_evt->name))
+		return;
+
+	if (of_property_read_u32(timer, "clockevent-rating",
+				&clock_evt->rating))
+		return;
+
+	if (of_property_read_u32(timer, "clockevent-shift",
+				&clock_evt->shift))
+		return;
+
+	if (of_property_read_u32(timer, "clockevent-features",
+				&clock_evt->features))
+		return;
+
+	if (of_property_read_u32(timer, "bit_enable", &mclk->bit_enable))
+		return;
+
+	if (of_property_read_u32(timer, "bit_mode", &mclk->bit_mode))
+		return;
+
+	if (of_property_read_u32(timer, "bit_resolution",
+				&mclk->bit_resolution))
+		return;
+
+
+	mclk->mux_reg = timer_ctrl_base;
+	mclk->reg = of_iomap(timer, 1);
+	pr_info("mclk->mux_reg =%p,mclk->reg =%p\n", mclk->mux_reg, mclk->reg);
+	mclk->irq.irq = irq_of_parse_and_map(timer, 0);
+
+	aml_set_reg32_mask(mclk->mux_reg,
+		((1 << mclk->bit_mode)
+		|(TIMER_RESOLUTION_1us << mclk->bit_resolution)));
+
+	meson_timer_init_device(clock_evt);
+
+	clock_evt->set_next_event = meson_set_next_event;
+	clock_evt->set_mode = meson_clkevt_set_mode;
+
+	mclk->irq.dev_id = clock_evt;
+	mclk->irq.handler = meson_timer_interrupt;
+	mclk->irq.name = clock_evt->name;
+	mclk->irq.flags =
+		IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL|IRQF_TRIGGER_RISING;
+	/* Set up the IRQ handler */
+	clock_evt->irq = mclk->irq.irq;
+	clockevents_register_device(clock_evt);
+	setup_irq(mclk->irq.irq, &mclk->irq);
+	return;
+}
+void __init meson_timer_init(struct device_node *np)
+{
+	timer_ctrl_base = of_iomap(np, 0);
+	clockevent_init_and_register(np);
+}
+CLOCKSOURCE_OF_DECLARE(meson_timer, "arm, meson-bc-timer", meson_timer_init);
diff --git a/drivers/amlogic/crypto/aml-sha-dma.c b/drivers/amlogic/crypto/aml-sha-dma.c
index 7225006..0e973f0 100644
--- a/drivers/amlogic/crypto/aml-sha-dma.c
+++ b/drivers/amlogic/crypto/aml-sha-dma.c
@@ -348,7 +348,7 @@ static int aml_sha_update_dma_slow(struct aml_sha_dev *dd)
 static int aml_sha_update_dma_start(struct aml_sha_dev *dd)
 {
 	struct aml_sha_reqctx *ctx = ahash_request_ctx(dd->req);
-	unsigned int length, final, tail = 0;
+	unsigned int length = 0, final = 0, tail = 0;
 	struct scatterlist *sg;
 	struct dma_dsc *dsc = dd->descriptor;
 
diff --git a/drivers/amlogic/deinterlace/Makefile b/drivers/amlogic/deinterlace/Makefile
index bf3ee39..437540c 100644
--- a/drivers/amlogic/deinterlace/Makefile
+++ b/drivers/amlogic/deinterlace/Makefile
@@ -1,8 +1,12 @@
 #
 # Makefile for the Post Process Manager device
 #
+ifeq ($(TARGET_BUILD_VARIANT),userdebug)
+ccflags-y := -D DEBUG_SUPPORT
+else
 ccflags-y := -DDEBUG
+endif
 obj-$(CONFIG_DEINTERLACE) += di.o
-di-objs = deinterlace.o deinterlace_hw.o deinterlace_pd.o dnr.o vof_soft_top.o film_fw1.o flm_mod_xx.o detect3d.o
+di-objs = deinterlace.o deinterlace_hw.o deinterlace_pd.o dnr.o vof_soft_top.o film_fw1.o flm_mod_xx.o detect3d.o tffbff_check.o
 
 
diff --git a/drivers/amlogic/deinterlace/deinterlace.c b/drivers/amlogic/deinterlace/deinterlace.c
index 1c67361..9e28011 100644
--- a/drivers/amlogic/deinterlace/deinterlace.c
+++ b/drivers/amlogic/deinterlace/deinterlace.c
@@ -151,8 +151,10 @@ MODULE_PARM_DESC(dnr_en, "enable/disable dnr in pre");
 
 #endif
 static unsigned int di_pre_rdma_enable;
-module_param(di_pre_rdma_enable, uint, 0664);
-MODULE_PARM_DESC(di_pre_rdma_enable, "enable/disable rdma in pre");
+
+static bool full_422_pack;
+static bool tff_bff_enable;
+
 #define CHECK_VDIN_BUF_ERROR
 
 #define DEVICE_NAME "deinterlace"
@@ -167,7 +169,7 @@ static dev_t di_devno;
 static struct class *di_clsp;
 
 #define INIT_FLAG_NOT_LOAD 0x80
-static const char version_s[] = "2016-06-17a";
+static const char version_s[] = "2016-09-13a";
 static unsigned char boot_init_flag;
 static int receiver_is_amvideo = 1;
 
@@ -647,22 +649,48 @@ store_dbg(struct device *dev,
 		pre_run_flag = DI_RUN_FLAG_STEP;
 	} else if (strncmp(buf, "dumpreg", 7) == 0) {
 		unsigned int i = 0;
-		pr_dbg("----dump di reg----\n");
-		for (i = 0; i < 255; i++)
-			pr_dbg("[0x%x][0x%x]=0x%x\n",
+		pr_info("----dump di reg----\n");
+		for (i = 0; i < 255; i++) {
+			if (i == 0x45)
+				pr_info("----nr reg----");
+			if (i == 0x80)
+				pr_info("----3d reg----");
+			if (i == 0x9e)
+				pr_info("---nr reg done---");
+			if (i == 0x9c)
+				pr_info("---3d reg done---");
+			pr_info("[0x%x][0x%x]=0x%x\n",
 				0xd0100000 + ((0x1700 + i) << 2),
 				0x1700 + i, Rd(0x1700 + i));
-		pr_dbg("----dump mcdi reg----\n");
+		}
+		pr_info("----dump mcdi reg----\n");
 		for (i = 0; i < 201; i++)
-			pr_dbg("[0x%x][0x%x]=0x%x\n",
+			pr_info("[0x%x][0x%x]=0x%x\n",
 				0xd0100000 + ((0x2f00 + i) << 2),
 				0x2f00 + i, Rd(0x2f00 + i));
-		pr_dbg("----dump pulldown reg----\n");
+		pr_info("----dump pulldown reg----\n");
 		for (i = 0; i < 26; i++)
-			pr_dbg("[0x%x][0x%x]=0x%x\n",
+			pr_info("[0x%x][0x%x]=0x%x\n",
 				0xd0100000 + ((0x2fd0 + i) << 2),
 				0x2fd0 + i, Rd(0x2fd0 + i));
-		pr_dbg("----dump reg done----\n");
+		pr_info("----dump bit mode reg----\n");
+		for (i = 0; i < 4; i++)
+			pr_info("[0x%x][0x%x]=0x%x\n",
+				0xd0100000 + ((0x20a7 + i) << 2),
+				0x20a7 + i, Rd(0x20a7 + i));
+		pr_info("[0x%x][0x%x]=0x%x\n",
+			0xd0100000 + (0x2022 << 2),
+			0x2022, Rd(0x2022));
+		pr_info("[0x%x][0x%x]=0x%x\n",
+			0xd0100000 + (0x17c1 << 2),
+			0x17c1, Rd(0x17c1));
+		pr_info("[0x%x][0x%x]=0x%x\n",
+			0xd0100000 + (0x17c2 << 2),
+			0x17c2, Rd(0x17c2));
+		pr_info("[0x%x][0x%x]=0x%x\n",
+			0xd0100000 + (0x1aa7 << 2),
+			0x1aa7, Rd(0x1aa7));
+		pr_info("----dump reg done----\n");
 	} else if (strncmp(buf, "robust_test", 11) == 0) {
 		recovery_flag = 1;
 	} else if (strncmp(buf, "recycle_buf", 11) == 0) {
@@ -1870,6 +1898,7 @@ static void dump_di_pre_stru(void)
 struct di_post_stru_s {
 	struct DI_MIF_s	di_buf0_mif;
 	struct DI_MIF_s	di_buf1_mif;
+	struct DI_MIF_s	di_buf2_mif;
 	struct DI_SIM_MIF_s di_diwr_mif;
 	struct DI_SIM_MIF_s	di_mtnprd_mif;
 	struct DI_MC_MIF_s	di_mcvecrd_mif;
@@ -2461,7 +2490,7 @@ static int di_get_canvas(void)
 		/* mem/chan2/nr/mtn/contrd/contrd2/
 		 * contw/mcinfrd/mcinfow/mcvecw */
 		pre_num = 10;
-		/* buf0/buf1/mtnp/mcvec */
+		/* buf0/buf1/buf2/mtnp/mcvec */
 		post_num = 6;
 	}
 	if (canvas_pool_alloc_canvas_table("di_pre",
@@ -2958,28 +2987,29 @@ static void log_buffer_state(unsigned char *tag)
 
 static void dump_di_buf(struct di_buf_s *di_buf)
 {
-	pr_dbg("di_buf %p vframe %p:\n", di_buf, di_buf->vframe);
-	pr_dbg("index %d, post_proc_flag %d, new_format_flag %d, type %d,",
+	pr_info("di_buf %p vframe %p:\n", di_buf, di_buf->vframe);
+	pr_info("index %d, post_proc_flag %d, new_format_flag %d, type %d,",
 		di_buf->index, di_buf->post_proc_flag,
 		di_buf->new_format_flag, di_buf->type);
-	pr_dbg("seq %d, pre_ref_count %d,post_ref_count %d, queue_index %d,",
+	pr_info("seq %d, pre_ref_count %d,post_ref_count %d, queue_index %d,",
 		di_buf->seq, di_buf->pre_ref_count, di_buf->post_ref_count,
 		di_buf->queue_index);
-	pr_dbg("pulldown_mode %d process_fun_index %d\n",
+	pr_info("pulldown_mode %d process_fun_index %d\n",
 		di_buf->pulldown_mode, di_buf->process_fun_index);
-	pr_dbg("di_buf: %p, %p, di_buf_dup_p: %p, %p, %p, %p, %p\n",
+	pr_info("di_buf: %p, %p, di_buf_dup_p: %p, %p, %p, %p, %p\n",
 		di_buf->di_buf[0], di_buf->di_buf[1], di_buf->di_buf_dup_p[0],
 		di_buf->di_buf_dup_p[1], di_buf->di_buf_dup_p[2],
 		di_buf->di_buf_dup_p[3], di_buf->di_buf_dup_p[4]);
-	pr_dbg(
+	pr_info(
 	"nr_adr 0x%lx, nr_canvas_idx 0x%x, mtn_adr 0x%lx, mtn_canvas_idx 0x%x",
 		di_buf->nr_adr, di_buf->nr_canvas_idx, di_buf->mtn_adr,
 		di_buf->mtn_canvas_idx);
 #ifdef NEW_DI_V1
-	pr_dbg("cnt_adr 0x%lx, cnt_canvas_idx 0x%x\n",
+	pr_info("cnt_adr 0x%lx, cnt_canvas_idx 0x%x\n",
 		di_buf->cnt_adr, di_buf->cnt_canvas_idx);
 #endif
-	pr_dbg("di_cnt %d\n", atomic_read(&di_buf->di_cnt));
+	pr_info("di_cnt %d, priveated %u.\n",
+			atomic_read(&di_buf->di_cnt), di_buf->privated);
 }
 
 static void dump_pool(int index)
@@ -2987,42 +3017,42 @@ static void dump_pool(int index)
 	int j;
 	queue_t *q = &queue[index];
 
-	pr_dbg("queue[%d]: in_idx %d, out_idx %d, num %d, type %d\n",
+	pr_info("queue[%d]: in_idx %d, out_idx %d, num %d, type %d\n",
 		index, q->in_idx, q->out_idx, q->num, q->type);
 	for (j = 0; j < MAX_QUEUE_POOL_SIZE; j++) {
-		pr_dbg("0x%x ", q->pool[j]);
+		pr_info("0x%x ", q->pool[j]);
 		if (((j + 1) % 16) == 0)
 			pr_debug("\n");
 	}
-	pr_debug("\n");
+	pr_info("\n");
 }
 
 static void dump_vframe(vframe_t *vf)
 {
-	pr_dbg("vframe %p:\n", vf);
-	pr_dbg("index %d, type 0x%x, type_backup 0x%x, blend_mode %d bitdepth %d\n",
+	pr_info("vframe %p:\n", vf);
+	pr_info("index %d, type 0x%x, type_backup 0x%x, blend_mode %d bitdepth %d\n",
 		vf->index, vf->type, vf->type_backup,
 		vf->blend_mode, (vf->bitdepth&BITDEPTH_Y10)?10:8);
-	pr_dbg("duration %d, duration_pulldown %d, pts %d, flag 0x%x\n",
+	pr_info("duration %d, duration_pulldown %d, pts %d, flag 0x%x\n",
 		vf->duration, vf->duration_pulldown, vf->pts, vf->flag);
-	pr_dbg("canvas0Addr 0x%x, canvas1Addr 0x%x, bufWidth %d\n",
+	pr_info("canvas0Addr 0x%x, canvas1Addr 0x%x, bufWidth %d\n",
 		vf->canvas0Addr, vf->canvas1Addr, vf->bufWidth);
-	pr_dbg("width %d, height %d, ratio_control 0x%x, orientation 0x%x\n",
+	pr_info("width %d, height %d, ratio_control 0x%x, orientation 0x%x\n",
 		vf->width, vf->height, vf->ratio_control, vf->orientation);
-	pr_dbg("source_type %d, phase %d, soruce_mode %d, sig_fmt %d\n",
+	pr_info("source_type %d, phase %d, soruce_mode %d, sig_fmt %d\n",
 		vf->source_type, vf->phase, vf->source_mode, vf->sig_fmt);
-	pr_dbg(
+	pr_info(
 		"trans_fmt 0x%x, lefteye(%d %d %d %d), righteye(%d %d %d %d)\n",
 		vf->trans_fmt, vf->left_eye.start_x, vf->left_eye.start_y,
 		vf->left_eye.width, vf->left_eye.height,
 		vf->right_eye.start_x, vf->right_eye.start_y,
 		vf->right_eye.width, vf->right_eye.height);
-	pr_dbg("mode_3d_enable %d, use_cnt %d,",
+	pr_info("mode_3d_enable %d, use_cnt %d,",
 		vf->mode_3d_enable, atomic_read(&vf->use_cnt));
-	pr_dbg("early_process_fun 0x%p, process_fun 0x%p, private_data %p\n",
+	pr_info("early_process_fun 0x%p, process_fun 0x%p, private_data %p\n",
 		vf->early_process_fun,
 		vf->process_fun, vf->private_data);
-	pr_dbg("pixel_ratio %d list %p\n",
+	pr_info("pixel_ratio %d list %p\n",
 		vf->pixel_ratio, &vf->list);
 }
 
@@ -3263,7 +3293,11 @@ config_di_wr_mif(struct DI_SIM_MIF_s *di_nrwr_mif,
 	di_nrwr_mif->start_x = 0;
 	di_nrwr_mif->end_x = in_vframe->width - 1;
 	di_nrwr_mif->start_y = 0;
-	di_nrwr_mif->bit_mode = (di_buf->vframe->bitdepth & BITDEPTH_Y10)?1:0;
+	if (di_buf->vframe->bitdepth & BITDEPTH_Y10)
+		di_nrwr_mif->bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:1;
+	else
+		di_nrwr_mif->bit_mode = 0;
 	if (di_pre_stru.prog_proc_type == 0)
 		di_nrwr_mif->end_y = in_vframe->height / 2 - 1;
 	else
@@ -3287,10 +3321,17 @@ static void config_di_mif(struct DI_MIF_s *di_mif, struct di_buf_s *di_buf)
 		(di_buf->vframe->canvas0Addr >> 8) & 0xff;
 	di_mif->canvas0_addr2 =
 		(di_buf->vframe->canvas0Addr >> 16) & 0xff;
-	di_mif->bit_mode = (di_buf->vframe->bitdepth & BITDEPTH_Y10)?1:0;
-	if ((di_buf->vframe->type & VIDTYPE_VIU_444) &&
-		(di_buf->vframe->bitdepth & BITDEPTH_Y10))
-		di_mif->bit_mode = 2;
+
+	if (di_buf->vframe->bitdepth & BITDEPTH_Y10) {
+		if (di_buf->vframe->type & VIDTYPE_VIU_444)
+			di_mif->bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:2;
+		else if (di_buf->vframe->type & VIDTYPE_VIU_422)
+			di_mif->bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:1;
+	} else {
+		di_mif->bit_mode = 0;
+	}
 	if (di_buf->vframe->type & VIDTYPE_VIU_422) {
 		/* from vdin or local vframe */
 		if ((!is_progressive(di_buf->vframe))
@@ -3322,8 +3363,10 @@ static void config_di_mif(struct DI_MIF_s *di_mif, struct di_buf_s *di_buf)
 				(di_buf->vframe->canvas0Addr >> 16) & 0xff;
 		}
 	} else {
-		/* from decoder */
-		di_mif->video_mode = 0;
+		if (di_buf->vframe->type & VIDTYPE_VIU_444)
+			di_mif->video_mode = 1;
+		else
+			di_mif->video_mode = 0;
 		if (di_buf->vframe->type & VIDTYPE_VIU_NV21)
 			di_mif->set_separate_en = 2;
 		else
@@ -3364,7 +3407,8 @@ static void config_di_mif(struct DI_MIF_s *di_mif, struct di_buf_s *di_buf)
 					di_buf->vframe->width / 2 - 1;
 				di_mif->chroma_y_start0 = 0;
 				di_mif->chroma_y_end0 =
-					di_buf->vframe->height / 2 - 1;
+					di_buf->vframe->height / 2
+						- (di_mif->src_prog?1:2);
 			} else {
 				di_mif->output_field_num = 1;
 				/* bottom */
@@ -3377,7 +3421,8 @@ static void config_di_mif(struct DI_MIF_s *di_mif, struct di_buf_s *di_buf)
 				di_mif->chroma_x_start0 = 0;
 				di_mif->chroma_x_end0 =
 					di_buf->vframe->width / 2 - 1;
-				di_mif->chroma_y_start0 = 0;
+				di_mif->chroma_y_start0 =
+					(di_mif->src_prog?0:1);
 				di_mif->chroma_y_end0 =
 					di_buf->vframe->height / 2 - 1;
 			}
@@ -3743,7 +3788,7 @@ static unsigned int combing_setting_masks[MAX_NUM_DI_REG] = {
 };
 
 static unsigned int combing_pure_still_setting[MAX_NUM_DI_REG] = {
-	0x00202018,
+	0x00141410,
 	0x1A1A3A62,
 	0x15200A0A,
 	0x01800880,
@@ -3752,8 +3797,8 @@ static unsigned int combing_pure_still_setting[MAX_NUM_DI_REG] = {
 	0x0A800480,
 	0x1A1A2662,
 	0x0D200302,
-	0x02020606,
-	0x05080304,
+	0x02020202,
+	0x06090708,
 	0x40020A04,
 	0x0001FF0C,
 	0x00400204,
@@ -3762,7 +3807,7 @@ static unsigned int combing_pure_still_setting[MAX_NUM_DI_REG] = {
 };
 
 static unsigned int combing_bias_static_setting[MAX_NUM_DI_REG] = {
-	0x00202015,
+	0x00141410,
 	0x1A1A3A62,
 	0x15200A0A,
 	0x01800880,
@@ -3771,8 +3816,8 @@ static unsigned int combing_bias_static_setting[MAX_NUM_DI_REG] = {
 	0x0A800480,
 	0x1A1A2662,
 	0x0D200302,
-	0x02020606,
-	0x05080304,
+	0x02020202,
+	0x06090708,
 	0x40020A04,
 	0x0001FF0C,
 	0x00400204,
@@ -3782,18 +3827,18 @@ static unsigned int combing_bias_static_setting[MAX_NUM_DI_REG] = {
 
 
 static unsigned int combing_normal_setting[MAX_NUM_DI_REG] = {
-	0x00141410,
-	0x141A2062,
-	0x15200101,
-	0x01200440,
-	0x52000000,
+	0x00202015,
+	0x1A1A3A62,
+	0x15200a0a,
+	0x01000880,
+	0x74000D0D,
 	0x0D5A1520,
 	0x0A0A0201,
 	0x1A1A2662,
 	0x0D200302,
-	0x020A060C,
-	0x03040508,
-	0x60000404,
+	0x02020606,
+	0x05080304,
+	0x40020a04,
 	0x0001FF0C,
 	0x00400204,
 	0x00016404,
@@ -3801,18 +3846,18 @@ static unsigned int combing_normal_setting[MAX_NUM_DI_REG] = {
 };
 
 static unsigned int combing_bias_motion_setting[MAX_NUM_DI_REG] = {
-	0x00141410,
-	0x141A2022,
+	0x00202015,
+	0x1A1A3A62,
 	0x15200101,
 	0x01200440,
-	0x52000000,
+	0x74000D0D,
 	0x0D5A1520,
 	0x0A0A0201,
 	0x1A1A2662,
 	0x0D200302,
-	0x020A060C,
-	0x03040508,
-	0x60000404,
+	0x02020606,
+	0x05080304,
+	0x40020a04,
 	0x0001ff0c, /* 0x0001FF12 */
 	0x00400204, /* 0x00200204 */
 	0x00016404, /* 0x00012002 */
@@ -3820,30 +3865,50 @@ static unsigned int combing_bias_motion_setting[MAX_NUM_DI_REG] = {
 };
 
 static unsigned int combing_very_motion_setting[MAX_NUM_DI_REG] = {
-	0x00101010,
-	0x10101022,
+	0x00202015,
+	0x1A1A3A62,
 	0x15200101,
 	0x01200440,
-	0x52000000,
+	0x74000D0D,
 	0x0D5A1520,
 	0x0A0A0201,
 	0x1A1A2662,
 	0x0D200302,
-	0x020A060C,
-	0x03040508,
-	0x60000404,
+	0x02020606,
+	0x05080304,
+	0x40020a04,  /* 0x60000404,*/
 	0x0001ff0c, /* 0x0001FF12 */
 	0x00400204, /* 0x00200204 */
 	0x00016404, /* 0x00012002 */
 	0x00000131
 };
+/*special for resolution test file*/
+static unsigned int combing_resolution_setting[MAX_NUM_DI_REG] = {
+	0x00202015,
+	0x141a3a62,
+	0x15200a0a,
+	0x01800880,
+	0x74000d0d,
+	0x0d5a1520,
+	0x0a800480,
+	0x1a1a2662,
+	0x0d200302,
+	0x01010101,
+	0x06090708,
+	0x40020a04,
+	0x0001ff0c,
+	0x00400204,
+	0x00016404,
+	0x00000131
+};
 
-static unsigned int (*combing_setting_values[5])[MAX_NUM_DI_REG] = {
+static unsigned int (*combing_setting_values[6])[MAX_NUM_DI_REG] = {
 	&combing_pure_still_setting,
 	&combing_bias_static_setting,
 	&combing_normal_setting,
 	&combing_bias_motion_setting,
-	&combing_very_motion_setting
+	&combing_very_motion_setting,
+	&combing_resolution_setting
 };
 
 /* decide the levels based on glb_mot[0:4]
@@ -3925,16 +3990,36 @@ static void combing_threshold_config(unsigned int  width)
 	}
 	combing_glb_mot_thr_LH[3] = width*13;
 }
-unsigned int adp_set_mtn_ctrl3(unsigned int diff)
+
+unsigned int adp_set_level(unsigned int diff)
+{
+	unsigned int rst = 0;
+	char tlog[] = "LHM";
+	if (diff <= combing_glb_mot_thr_LH[0])
+		rst = 0;
+	else if (diff >= combing_glb_mot_thr_LH[3])
+		rst = 1;
+	else
+		rst = 2;
+
+	if (cmb_adpset_cnt > 0) {
+		pr_info("\ndiff=%d lvl=%c\n", diff, tlog[rst]);
+		cmb_adpset_cnt--;
+	}
+
+	return rst;
+}
+
+unsigned int adp_set_mtn_ctrl3(unsigned int diff, unsigned int dlvel)
 {
 	int istp = 0;
 	int idats = 0;
 	int idatm = 0;
 	int idatr = 0;
 	unsigned int rst = 0;
-	if (diff <= combing_glb_mot_thr_LH[0])
+	if (dlvel == 0)
 		rst = combing_pure_still_setting[2];
-	else if (diff >= combing_glb_mot_thr_LH[3])
+	else if (dlvel == 1)
 		rst = combing_very_motion_setting[2];
 	else {
 		rst = 0x1520;
@@ -3952,24 +4037,36 @@ unsigned int adp_set_mtn_ctrl3(unsigned int diff)
 		idatm = (combing_very_motion_setting[2]) & 0xff;
 
 		idatr = ((idats - idatm) * istp >> 6) + idatm;
-		rst = rst | (idatr & 0xff);
-	}
-
-	if (cmb_adpset_cnt > 0) {
-		pr_info("diff=%d, mtn_ctrl3=%8x\n", diff, rst);
-		cmb_adpset_cnt--;
+		rst = (rst<<8) | (idatr & 0xff);
 	}
+/*
+	if (cmb_adpset_cnt > 0)
+		pr_info("mtn_ctrl3=%8x\n", rst); */
 
 	return rst;
 }
 
-unsigned int adp_set_mtn_ctrl4(unsigned int diff)
+int di_debug_new_en = 1;
+module_param(di_debug_new_en, int, 0644);
+MODULE_PARM_DESC(di_debug_new_en, "di_debug_new_en");
+
+int cmb_num_rat_ctl4 = 64; /* 0~255 */
+module_param(cmb_num_rat_ctl4, int, 0644);
+MODULE_PARM_DESC(cmb_num_rat_ctl4, "cmb_num_rat_ctl4");
+
+int cmb_rat_ctl4_minthd = 64;
+module_param(cmb_rat_ctl4_minthd, int, 0644);
+MODULE_PARM_DESC(cmb_rat_ctl4_minthd, "cmb_rat_ctl4_minthd");
+
+int tTCNm = 0; /* combing rows */
+unsigned int adp_set_mtn_ctrl4(unsigned int diff, unsigned int dlvel)
 {
+	int hHeight = di_pre_stru.di_nrwr_mif.end_y;
 	int istp = 0, idats = 0, idatm = 0, idatr = 0;
 	unsigned int rst = 0;
-	if (diff <= combing_glb_mot_thr_LH[0])
+	if (dlvel == 0)
 		rst = combing_pure_still_setting[3];
-	else if (diff >= combing_glb_mot_thr_LH[3])
+	else if (dlvel == 1)
 		rst = combing_very_motion_setting[3];
 	else {
 			rst = 1;
@@ -3981,6 +4078,8 @@ unsigned int adp_set_mtn_ctrl4(unsigned int diff)
 			idatm = (combing_very_motion_setting[3] >> 16) & 0xff;
 
 			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			if (di_debug_new_en)
+				idatr = idatr >> 1;
 			rst = (rst<<8) | (idatr & 0xff);
 
 			idats = (combing_pure_still_setting[3] >> 8) & 0xff;
@@ -3993,16 +4092,177 @@ unsigned int adp_set_mtn_ctrl4(unsigned int diff)
 			idatm = (combing_very_motion_setting[3]) & 0xff;
 
 			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst << 8) | (idatr & 0xff);
+	}
+
+	if (di_debug_new_en == 1) {
+		istp = ((cmb_num_rat_ctl4 * hHeight + 128) >> 8);
+		if (cmb_adpset_cnt > 0)
+			pr_info("mtn_ctrl4=%8x %03d (%03d)\n",
+				rst, istp, tTCNm);
+	if (tTCNm > istp) {
+		istp = 64 * (hHeight - tTCNm) / (hHeight - istp + 1);
+		if (istp < 4)
+			istp = 4;
+
+		idatm = 1;
+		idats = (rst >> 16) & 0xff;
+		idatr = ((idats * istp + 32) >> 6);
+				idatr = idatr >> 1; /*color*/
+		if (idatr < (cmb_rat_ctl4_minthd >> 1))
+			idatr = (cmb_rat_ctl4_minthd >> 1);
+		idatm = (idatm<<8) | (idatr & 0xff);
+
+		idats = (rst >> 8) & 0xff;
+		idatr = ((idats * istp + 32) >> 6);
+		if (idatr < 4)
+			idatr = 4;
+		idatm = (idatm<<8) | (idatr & 0xff);
+
+		idats = rst & 0xff;
+		idatr = ((idats * istp + 32) >> 6);
+		if (idatr < cmb_rat_ctl4_minthd)
+			idatr = cmb_rat_ctl4_minthd;
+		idatm = (idatm<<8) | (idatr & 0xff);
+
+		rst = idatm;
+
+		if (cmb_adpset_cnt > 0)
+			pr_info("%03d (%03d)=%8x\n",
+				tTCNm, hHeight, rst);
+	}
+	}
+	return rst;
+}
+
+unsigned int adp_set_mtn_ctrl7(unsigned int diff, unsigned int dlvel)
+{
+	int istp = 0, idats = 0, idatm = 0, idatr = 0;
+	unsigned int rst = 0;
+	if (dlvel == 0)
+		rst = combing_pure_still_setting[6];
+	else if (dlvel == 1)
+		rst = combing_very_motion_setting[6];
+	else {
+			rst = 10;
+			istp = 64 * (diff - combing_glb_mot_thr_LH[0]) /
+				(combing_glb_mot_thr_LH[3] -
+				combing_glb_mot_thr_LH[0] + 1);
+
+			idats = (combing_pure_still_setting[6] >> 16) & 0xff;
+			idatm = (combing_very_motion_setting[6] >> 16) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+
+			idats = (combing_pure_still_setting[6] >> 8) & 0xff;
+			idatm = (combing_very_motion_setting[6] >> 8) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+
+			idats = (combing_pure_still_setting[6]) & 0xff;
+			idatm = (combing_very_motion_setting[6]) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
 			rst = (rst<<8) | (idatr & 0xff);
 	}
+	/*
 	if (cmb_adpset_cnt > 0) {
-		pr_info("diff=%d, mtn_ctrl4=%8x\n", diff, rst);
-		cmb_adpset_cnt--;
+		pr_info("mtn_ctrl7=%8x\n", rst);
+	}*/
+	return rst;
+}
+
+unsigned int adp_set_mtn_ctrl10(unsigned int diff, unsigned int dlvel)
+{
+	int istp = 0, idats = 0, idatm = 0, idatr = 0;
+	unsigned int rst = 0;
+	if (dlvel == 0)
+		rst = combing_pure_still_setting[9];
+	else if (dlvel == 1)
+		rst = combing_very_motion_setting[9];
+	else {
+			istp = 64 * (diff - combing_glb_mot_thr_LH[0]) /
+				(combing_glb_mot_thr_LH[3] -
+				combing_glb_mot_thr_LH[0] + 1);
+
+			idats = (combing_very_motion_setting[9] >> 24) & 0xff;
+			idatm = (combing_pure_still_setting[9] >> 24) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+
+			idats = (combing_very_motion_setting[9] >> 16) & 0xff;
+			idatm = (combing_pure_still_setting[9] >> 16) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+
+			idats = (combing_very_motion_setting[9] >> 8) & 0xff;
+			idatm = (combing_pure_still_setting[9] >> 8) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+
+			idats = (combing_very_motion_setting[9]) & 0xff;
+			idatm = (combing_pure_still_setting[9]) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+	}
+	/*
+	if (cmb_adpset_cnt > 0) {
+		pr_info("mtn_ctr10=%8x\n", rst);
+	}*/
+	return rst;
+}
+
+unsigned int adp_set_mtn_ctrl11(unsigned int diff, unsigned int dlvel)
+{
+	int istp = 0, idats = 0, idatm = 0, idatr = 0;
+	unsigned int rst = 0;
+	if (dlvel == 0)
+		rst = combing_pure_still_setting[10];
+	else if (dlvel == 1)
+		rst = combing_very_motion_setting[10];
+	else {
+			istp = 64 * (diff - combing_glb_mot_thr_LH[0]) /
+				(combing_glb_mot_thr_LH[3] -
+				combing_glb_mot_thr_LH[0] + 1);
+
+			idats = (combing_pure_still_setting[10] >> 24) & 0xff;
+			idatm = (combing_very_motion_setting[10] >> 24) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+
+			idats = (combing_pure_still_setting[10] >> 16) & 0xff;
+			idatm = (combing_very_motion_setting[10] >> 16) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+
+			idats = (combing_pure_still_setting[10] >> 8) & 0xff;
+			idatm = (combing_very_motion_setting[10] >> 8) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
+
+			idats = (combing_pure_still_setting[10]) & 0xff;
+			idatm = (combing_very_motion_setting[10]) & 0xff;
+
+			idatr = ((idats - idatm) * istp >> 6) + idatm;
+			rst = (rst<<8) | (idatr & 0xff);
 	}
+	/*
+	if (cmb_adpset_cnt > 0) {
+		pr_info("mtn_ctr11=%8x\n", rst);
+	}*/
 	return rst;
 }
 
-void set_combing_regs(int lvl, unsigned int diff)
+void set_combing_regs(int lvl)
 {
 	int i;
 	unsigned int ndat = 0;
@@ -4023,17 +4283,7 @@ void set_combing_regs(int lvl, unsigned int diff)
 			/* TODO: need change to check if
 			register only in GCTVBB */
 			ndat = (*combing_setting_values[lvl])[i];
-			if (i == 2)
-				ndat = adp_set_mtn_ctrl3(diff);
-			else if (i == 3)
-				ndat = adp_set_mtn_ctrl4(diff);
-
-			DI_Wr(combing_setting_registers[i],
-				(ndat &
-				combing_setting_masks[i]) |
-				(Rd(
-					combing_setting_registers[i])
-				& ~combing_setting_masks[i]));
+			DI_Wr(combing_setting_registers[i], ndat);
 		} else if (is_meson_gxtvbb_cpu())
 			DI_Wr(combing_setting_registers[i],
 				((*combing_setting_values[lvl])[i] &
@@ -4044,16 +4294,58 @@ void set_combing_regs(int lvl, unsigned int diff)
 	}
 }
 
-int like_pulldown22_flag = 0;
+static int like_pulldown22_flag;
+
+int di_debug_readreg = 0;
+module_param(di_debug_readreg, int, 0644);
+MODULE_PARM_DESC(di_debug_readreg, "di_debug_readreg");
+
+static unsigned int field_diff_rate;
 
 static void adaptive_combing_fixing(
 	pulldown_detect_info_t *field_pd_info,
-	int frame_type)
+	int frame_type, int wWidth)
 {
 	unsigned int glb_mot_avg2;
 	unsigned int glb_mot_avg3;
 	unsigned int glb_mot_avg5;
 
+	unsigned int diff = 0;
+	unsigned int wt_dat = 0;
+	unsigned int dlvl = 0;
+	static unsigned int pre_dat[5];
+	bool prt_flg = (cmb_adpset_cnt > 0);
+	unsigned int i = 0;
+
+	static unsigned int pre_num;
+	unsigned int crt_num = field_pd_info->field_diff_num;
+	unsigned int drat = 0;
+	if (pre_num > crt_num)
+		diff = pre_num - crt_num;
+	else
+		diff = crt_num - pre_num;
+
+	if (diff >= wWidth)
+		field_diff_rate = 0;
+	else {
+		drat = (diff << 8) / (wWidth + 1);
+		if (drat > 255)
+			field_diff_rate = 0;
+		else
+			field_diff_rate = 256 - drat;
+	}
+	pre_num = crt_num;
+
+	if (di_debug_readreg > 1) {
+		for (i = 0; i < 12; i++) {
+			wt_dat = Rd(combing_setting_registers[i]);
+			pr_info("mtn_ctrl%02d = 0x%08x\n",
+				i+1, wt_dat);
+		}
+		pr_info("\n");
+		di_debug_readreg--;
+	}
+
 	if (!combing_fix_en)
 		return;
 
@@ -4085,10 +4377,10 @@ static void adaptive_combing_fixing(
 				cur_lev = max(cur_lev - 1, 1);
 		}
 	}
-	if ((force_lev >= 0) & (force_lev < 5))
+	if ((force_lev >= 0) & (force_lev < 6))
 		cur_lev = force_lev;
 	if (cur_lev != last_lev) {
-		set_combing_regs(cur_lev, glb_mot[0]);
+		set_combing_regs(cur_lev);
 		if (pr_pd & 0x400)
 			pr_dbg("\t%5d: from %d to %d: di_mtn_1_ctrl1 = %08x\n",
 				field_count, last_lev, cur_lev, di_mtn_1_ctrl1);
@@ -4096,6 +4388,58 @@ static void adaptive_combing_fixing(
 		last_lev = cur_lev;
 	}
 
+	if ((force_lev > 5) && (di_debug_new_en == 1) &&
+		(glb_mot[1] != glb_mot[0])) {
+		dlvl = adp_set_level(glb_mot[0]);
+		diff = glb_mot[0];
+		pre_dat[0] = Rd(DI_MTN_1_CTRL3);
+		wt_dat = adp_set_mtn_ctrl3(diff, dlvl);
+		if (pre_dat[0] != wt_dat) {
+			DI_Wr(DI_MTN_1_CTRL3, wt_dat);
+			pre_dat[0] = wt_dat;
+			if (prt_flg)
+				pr_info("set mtn03 0x%08x.\n", wt_dat);
+		}
+
+		pre_dat[1] = Rd(DI_MTN_1_CTRL4);
+		wt_dat = adp_set_mtn_ctrl4(diff, dlvl);
+		if (pre_dat[1] != wt_dat) {
+			DI_Wr(DI_MTN_1_CTRL4, wt_dat);
+			if (prt_flg)
+				pr_info("set mtn04 %08x -> %08x (%d).\n",
+				pre_dat[1], wt_dat,
+				field_pd_info->field_diff_num);
+			pre_dat[1] = wt_dat;
+		}
+
+		pre_dat[2] = Rd(DI_MTN_1_CTRL7);
+		wt_dat = adp_set_mtn_ctrl7(diff, dlvl);
+		if (pre_dat[2] != wt_dat) {
+			DI_Wr(DI_MTN_1_CTRL7, wt_dat);
+			pre_dat[2] = wt_dat;
+			if (prt_flg)
+				pr_info("set mtn07 0x%08x.\n", wt_dat);
+		}
+
+		pre_dat[3] = Rd(DI_MTN_1_CTRL10);
+		wt_dat = adp_set_mtn_ctrl10(diff, dlvl);
+		if (pre_dat[3] != wt_dat) {
+			DI_Wr(DI_MTN_1_CTRL10, wt_dat);
+			pre_dat[3] = wt_dat;
+			if (prt_flg)
+				pr_info("set mtn10 0x%08x.\n", wt_dat);
+		}
+
+		pre_dat[4] = Rd(DI_MTN_1_CTRL11);
+		wt_dat = adp_set_mtn_ctrl11(diff, dlvl);
+		if (pre_dat[4] != wt_dat) {
+			DI_Wr(DI_MTN_1_CTRL11, wt_dat);
+			pre_dat[4] = wt_dat;
+			if (prt_flg)
+				pr_info("set mtn11 0x%08x.\n\n", wt_dat);
+		}
+	}
+
 	if (is_meson_gxtvbb_cpu() && dejaggy_enable) {
 		/* only enable dejaggy for interlace */
 		if ((frame_type & VIDTYPE_TYPEMASK) == VIDTYPE_PROGRESSIVE &&
@@ -4162,8 +4506,6 @@ static void adaptive_combing_fixing(
 }
 
 static unsigned int flm22_sure_num = 100;
-module_param(flm22_sure_num, uint, 0644);
-MODULE_PARM_DESC(flm22_sure_num, "ture film-22/n");
 
 /*
 static unsigned int flmxx_sure_num = 50;
@@ -4177,14 +4519,38 @@ static unsigned int flmxx_sure_num[7] = {20, 20, 20, 20, 20, 20, 20};
 static unsigned int flmxx_snum_adr = 7;
 module_param_array(flmxx_sure_num, uint, &flmxx_snum_adr, 0664);
 
+static unsigned int flm22_glbpxlnum_rat = 4; /* 4/256 = 64 */
+
+static unsigned int flm22_glbpxl_maxrow = 16; /* 16/256 = 16 */
+module_param(flm22_glbpxl_maxrow, uint, 0644);
+MODULE_PARM_DESC(flm22_glbpxl_maxrow, "flm22_glbpxl_maxrow/n");
+
+static unsigned int flm22_glbpxl_minrow = 3; /* 4/256 = 64 */
+module_param(flm22_glbpxl_minrow, uint, 0644);
+MODULE_PARM_DESC(flm22_glbpxl_minrow, "flm22_glbpxl_minrow/n");
+
+static unsigned int cmb_3point_rnum;
+module_param(cmb_3point_rnum, uint, 0644);
+MODULE_PARM_DESC(cmb_3point_rnum, "cmb_3point_rnum/n");
+
+static unsigned int cmb_3point_rrat = 32;
+module_param(cmb_3point_rrat, uint, 0644);
+MODULE_PARM_DESC(cmb_3point_rrat, "cmb_3point_rrat/n");
+
 static void pre_de_done_buf_config(void)
 {
 	ulong flags = 0, fiq_flag = 0, irq_flag2 = 0;
 	bool dynamic_flag = false;
 	int hHeight = di_pre_stru.di_nrwr_mif.end_y;
+	int wWidth  = di_pre_stru.di_nrwr_mif.end_x;
+
 	bool flm32 = false;
 	bool flm22 = false;
 	bool flmxx = false;
+	int tb_chk_ret = 0;
+	unsigned int glb_mot = 0;
+	unsigned int mot_row = 0;
+	unsigned int mot_max = 0;
 
 	if (di_pre_stru.di_wr_buf) {
 		if (di_pre_stru.pre_throw_flag > 0) {
@@ -4202,6 +4568,16 @@ static void pre_de_done_buf_config(void)
 					di_pre_stru.di_wr_buf->vframe);
 		}
 #endif
+		if (!di_pre_rdma_enable)
+			di_pre_stru.di_post_wr_buf = di_pre_stru.di_wr_buf;
+
+		if (di_pre_stru.cur_source_type == VFRAME_SOURCE_TYPE_OTHERS &&
+				tff_bff_enable) {
+			tb_chk_ret = tff_bff_check((di_pre_stru.cur_height>>1),
+					di_pre_stru.cur_width);
+			di_pre_stru.di_post_wr_buf->privated &= (~0x3);
+			di_pre_stru.di_post_wr_buf->privated |=	tb_chk_ret;
+		}
 		if (di_pre_stru.di_post_wr_buf) {
 			dynamic_flag = read_pulldown_info(
 				&(di_pre_stru.di_post_wr_buf->field_pd_info),
@@ -4219,11 +4595,14 @@ static void pre_de_done_buf_config(void)
 				di_pre_stru.di_post_wr_buf->pulldown_mode =
 					PULL_DOWN_NORMAL;
 			}
-			adaptive_combing_fixing(&(di_pre_stru.di_post_wr_buf->
-				field_pd_info), di_pre_stru.cur_inp_type);
+			adaptive_combing_fixing(
+				&(di_pre_stru.di_post_wr_buf->field_pd_info),
+				di_pre_stru.cur_inp_type,
+				wWidth + 1);
 		}
 
-		if (is_meson_gxtvbb_cpu() && !di_pre_stru.cur_prog_flag) {
+		tTCNm = 0;
+		if (!di_pre_stru.cur_prog_flag) {
 			/* always read and print data */
 			read_new_pulldown_info(&flmreg);
 
@@ -4241,10 +4620,16 @@ static void pre_de_done_buf_config(void)
 					&(dectres.rFlmPstMod),
 					flmreg.rROFldDif01,
 					flmreg.rROFrmDif02,
-					flmreg.rROCmbInf, &pd_param,
+					flmreg.rROCmbInf,
+					&tTCNm,
+					&pd_param,
 					hHeight + 1,
-					di_pre_stru.di_nrwr_mif.end_x +
-					1);
+					wWidth  + 1);
+
+				if (hHeight >= 289) /*full hd */
+					tTCNm = tTCNm << 1;
+				if (tTCNm > hHeight)
+					tTCNm = hHeight;
 
 				prt_flg = ((pr_pd >> 1) & 0x1);
 				if (prt_flg) {
@@ -4257,7 +4642,8 @@ static void pre_de_done_buf_config(void)
 					dectres.rF22Flag);
 
 					sprintf(debug_str + strlen(debug_str),
-					"Wnd[%d~%d], [%d~%d], [%d~%d], [%d~%d]\n",
+					"N%03d: nd[%d~%d], [%d~%d], [%d~%d], [%d~%d]\n",
+					tTCNm,
 					dectres.rPstCYWnd0[0],
 					dectres.rPstCYWnd0[1],
 					dectres.rPstCYWnd1[0],
@@ -4296,10 +4682,51 @@ static void pre_de_done_buf_config(void)
 			else
 				like_pulldown22_flag = 0;
 
+			if (di_debug_new_en) {
+				if ((pr_pd >> 1) & 0x1)
+					pr_info("fld_dif_rat=%d\n",
+					field_diff_rate);
+
+				if ((dectres.rF22Flag >=
+					(cmb_3point_rnum + field_diff_rate)) &&
+					(tTCNm >
+					(hHeight * cmb_3point_rrat >> 8))) {
+					if ((pr_pd >> 1) & 0x1)
+						pr_info("coeff-3-point enabled\n");
+				}
+			}
 			if (pulldown_enable == 1 && dectres.rFlmPstMod != 0
 				&& di_pre_stru.di_post_wr_buf) {
 				flm32 = (dectres.rFlmPstMod == 2 &&
 					dectres.rFlmPstGCm == 0);
+
+				if (di_debug_new_en &&
+					(dectres.rFlmPstMod == 1)) {
+					glb_mot = di_pre_stru.di_post_wr_buf->
+						field_pd_info.frame_diff_num;
+					mot_row = glb_mot *
+					flm22_glbpxlnum_rat / (wWidth + 1);
+					mot_max = (flm22_glbpxl_maxrow *
+						hHeight + 128) >> 8;
+					if ((pr_pd >> 1) & 0x1)
+						pr_info("dejaggies level=%3d - (%02d - %02d)\n",
+							dectres.rF22Flag,
+							mot_max, mot_row);
+
+				if (mot_row < mot_max) {
+					if (dectres.rF22Flag >
+						(mot_max - mot_row))
+							dectres.rF22Flag -=
+							(mot_max - mot_row);
+					else
+							dectres.rF22Flag = 0;
+
+				if (mot_row <=
+							flm22_glbpxl_minrow)
+							dectres.rFlmPstMod = 0;
+					}
+				}
+
 				flm22 = (dectres.rFlmPstMod == 1  &&
 					dectres.rF22Flag >= flm22_sure_num);
 				if (dectres.rFlmPstMod >= 4)
@@ -4315,10 +4742,11 @@ static void pre_de_done_buf_config(void)
 						di_pre_stru.di_post_wr_buf
 						->pulldown_mode =
 							PULL_DOWN_BLEND_0;
-					else
+					else {
 						di_pre_stru.di_post_wr_buf
 						->pulldown_mode =
 							PULL_DOWN_BLEND_2;
+						}
 				} else if (pldn_mod == 1) {
 					if (dectres.rFlmSltPre == 1)
 						di_pre_stru.di_post_wr_buf
@@ -4507,7 +4935,7 @@ static void pre_de_done_buf_config(void)
 		}
 		field_count++;
 		if (field_count == 0x7fffffff)
-			field_count = 1;
+			field_count = 3;
 
 		if (di_pre_stru.cur_prog_flag) {
 			if (di_pre_stru.prog_proc_type == 0) {
@@ -4572,8 +5000,11 @@ static void pre_de_done_buf_config(void)
 				vframe_type_name[di_pre_stru.di_wr_buf->type],
 				di_pre_stru.di_wr_buf->index);
 			if (di_pre_stru.di_wr_buf) {
-				di_pre_stru.di_post_wr_buf =
-					di_pre_stru.di_wr_buf;
+				if (di_pre_rdma_enable)
+					di_pre_stru.di_post_wr_buf =
+				di_pre_stru.di_wr_buf;
+				else
+					di_pre_stru.di_post_wr_buf = NULL;
 				di_pre_stru.di_wr_buf = NULL;
 			}
 		} else {
@@ -4644,25 +5075,38 @@ static void pre_de_done_buf_config(void)
 				di_pre_stru.di_wr_buf->index);
 
 			if (di_pre_stru.di_wr_buf) {
-				di_pre_stru.di_post_wr_buf =
-					di_pre_stru.di_wr_buf;
+				if (di_pre_rdma_enable)
+					di_pre_stru.di_post_wr_buf =
+				di_pre_stru.di_wr_buf;
+				else
+					di_pre_stru.di_post_wr_buf = NULL;
 				di_pre_stru.di_wr_buf = NULL;
 			}
 		}
 	}
 
-	if (di_pre_stru.di_post_inp_buf) {
+	if (di_pre_stru.di_post_inp_buf && di_pre_rdma_enable) {
 		di_print("%s: %s[%d] => recycle_list\n", __func__,
-			vframe_type_name[di_pre_stru.di_inp_buf->type],
-			di_pre_stru.di_inp_buf->index);
+			vframe_type_name[di_pre_stru.di_post_inp_buf->type],
+			di_pre_stru.di_post_inp_buf->index);
 		di_lock_irqfiq_save(irq_flag2, fiq_flag);
 		queue_in(di_pre_stru.di_post_inp_buf, QUEUE_RECYCLE);
 		di_pre_stru.di_post_inp_buf = NULL;
 		di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 	}
 	if (di_pre_stru.di_inp_buf) {
-		di_pre_stru.di_post_inp_buf = di_pre_stru.di_inp_buf;
-		di_pre_stru.di_inp_buf = NULL;
+		if (!di_pre_rdma_enable) {
+			di_print("%s: %s[%d] => recycle_list\n", __func__,
+			vframe_type_name[di_pre_stru.di_inp_buf->type],
+			di_pre_stru.di_inp_buf->index);
+			di_lock_irqfiq_save(irq_flag2, fiq_flag);
+			queue_in(di_pre_stru.di_inp_buf, QUEUE_RECYCLE);
+			di_pre_stru.di_inp_buf = NULL;
+			di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
+		} else {
+			di_pre_stru.di_post_inp_buf = di_pre_stru.di_inp_buf;
+			di_pre_stru.di_inp_buf = NULL;
+		}
 	}
 }
 
@@ -5165,6 +5609,14 @@ static unsigned char pre_de_buf_config(void)
 
 			top_bot_config(di_buf);
 			queue_in(di_buf, QUEUE_PRE_READY);
+			/*if previous isn't bypass post_wr_buf not recycled */
+			if (di_pre_stru.di_post_wr_buf && di_pre_rdma_enable) {
+				queue_in(
+					di_pre_stru.di_post_inp_buf,
+					QUEUE_RECYCLE);
+				di_pre_stru.di_post_inp_buf = NULL;
+			}
+
 			if (
 				(bypass_pre & 0x2) &&
 				!di_pre_stru.cur_prog_flag)
@@ -5316,9 +5768,12 @@ static unsigned char pre_de_buf_config(void)
 	di_buf->vframe->canvas1Addr = di_buf->nr_canvas_idx;
 	/* set vframe bit info */
 	di_buf->vframe->bitdepth &= ~(BITDEPTH_YMASK);
-	if (di_force_bit_mode == 10)
+	di_buf->vframe->bitdepth &= ~(FULL_PACK_422_MODE);
+	if (di_force_bit_mode == 10) {
 		di_buf->vframe->bitdepth |= (BITDEPTH_Y10);
-	else
+		if (full_422_pack)
+			di_buf->vframe->bitdepth |= (FULL_PACK_422_MODE);
+	} else
 		di_buf->vframe->bitdepth |= (BITDEPTH_Y8);
 
 	if (di_pre_stru.prog_proc_type) {
@@ -5733,10 +6188,9 @@ static void inc_post_ref_count(struct di_buf_s *di_buf)
 	if (di_buf->di_buf_dup_p[1])
 		di_buf->di_buf_dup_p[1]->post_ref_count++;
 
-	if (di_buf->pulldown_mode != PULL_DOWN_BLEND_2) {
-		if (di_buf->di_buf_dup_p[0])
-			di_buf->di_buf_dup_p[0]->post_ref_count++;
-	}
+	if (di_buf->di_buf_dup_p[0])
+		di_buf->di_buf_dup_p[0]->post_ref_count++;
+
 	if (di_buf->di_buf_dup_p[2])
 		di_buf->di_buf_dup_p[2]->post_ref_count++;
 }
@@ -5755,11 +6209,10 @@ static void dec_post_ref_count(struct di_buf_s *di_buf)
 	if (di_buf->di_buf_dup_p[1])
 		di_buf->di_buf_dup_p[1]->post_ref_count--;
 
-	if (di_buf->pulldown_mode != PULL_DOWN_BLEND_2) {
-		if (di_buf->di_buf_dup_p[0] &&
-		    di_buf->di_buf_dup_p[0]->post_proc_flag != -2)
-			di_buf->di_buf_dup_p[0]->post_ref_count--;
-	}
+	if (di_buf->di_buf_dup_p[0] &&
+	    di_buf->di_buf_dup_p[0]->post_proc_flag != -2)
+		di_buf->di_buf_dup_p[0]->post_ref_count--;
+
 	if (di_buf->di_buf_dup_p[2])
 		di_buf->di_buf_dup_p[2]->post_ref_count--;
 }
@@ -5922,6 +6375,56 @@ static int do_pre_only_fun(void *arg, vframe_t *disp_vf)
 	return 0;
 }
 
+static void config_fftffb_mode(struct di_buf_s *di_buf,
+	unsigned int *post_field_type, char fftffb_mode)
+{
+	switch (fftffb_mode) {
+	case 1:
+		*post_field_type =
+		(di_buf->di_buf_dup_p[0]->vframe->type &
+		 VIDTYPE_TYPEMASK)
+		== VIDTYPE_INTERLACE_TOP ? 0 : 1;
+		di_post_stru.di_buf0_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[0]->nr_canvas_idx;
+		di_post_stru.di_buf1_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[1]->nr_canvas_idx;
+		di_post_stru.di_buf2_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[2]->nr_canvas_idx;
+		di_post_stru.di_mtnprd_mif.canvas_num =
+		di_buf->di_buf_dup_p[1]->mtn_canvas_idx;
+		break;
+	case 2:
+		*post_field_type =
+		(di_buf->di_buf_dup_p[2]->vframe->type &
+		 VIDTYPE_TYPEMASK)
+		== VIDTYPE_INTERLACE_TOP ? 0 : 1;
+		di_post_stru.di_buf0_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[2]->nr_canvas_idx;
+		di_post_stru.di_buf1_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[0]->nr_canvas_idx;
+		di_post_stru.di_buf2_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[1]->nr_canvas_idx;
+		di_post_stru.di_mtnprd_mif.canvas_num =
+		di_buf->di_buf_dup_p[1]->mtn_canvas_idx;
+		break;
+	default:
+		*post_field_type =
+		(di_buf->di_buf_dup_p[1]->vframe->type &
+		 VIDTYPE_TYPEMASK)
+		== VIDTYPE_INTERLACE_TOP ? 0 : 1;
+		di_post_stru.di_buf0_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[1]->nr_canvas_idx;
+		di_post_stru.di_buf1_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[0]->nr_canvas_idx;
+		di_post_stru.di_buf2_mif.canvas0_addr0 =
+		di_buf->di_buf_dup_p[2]->nr_canvas_idx;
+		di_post_stru.di_mtnprd_mif.canvas_num =
+		di_buf->di_buf_dup_p[2]->mtn_canvas_idx;
+		break;
+	}
+
+}
+
 static void get_vscale_skip_count(unsigned par)
 {
 	di_vscale_skip_count_real = (par >> 24) & 0xff;
@@ -5930,8 +6433,7 @@ static void get_vscale_skip_count(unsigned par)
 #define get_vpp_reg_update_flag(par) ((par >> 16) & 0x1)
 
 static unsigned int pldn_dly = 1;
-module_param(pldn_dly, uint, 0644);
-MODULE_PARM_DESC(pldn_dly, "/n pulldonw field delay result./n");
+static unsigned int tbbtff_dly;
 
 static unsigned int pldn_wnd_flsh = 1;
 module_param(pldn_wnd_flsh, uint, 0644);
@@ -6030,17 +6532,34 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 			return 0;
 		/* bit mode config */
 		if (di_buf->vframe->bitdepth & BITDEPTH_Y10) {
-			if ((di_buf->vframe->type & VIDTYPE_VIU_444) &&
-				(di_buf->vframe->bitdepth & BITDEPTH_Y10)) {
-				di_post_stru.di_buf0_mif.bit_mode = 2;
-				di_post_stru.di_buf1_mif.bit_mode = 2;
+			if (di_buf->vframe->type & VIDTYPE_VIU_444) {
+				di_post_stru.di_buf0_mif.bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:2;
+				di_post_stru.di_buf1_mif.bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:2;
+				di_post_stru.di_buf2_mif.bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:2;
 			} else {
-				di_post_stru.di_buf0_mif.bit_mode = 1;
-				di_post_stru.di_buf1_mif.bit_mode = 1;
+				di_post_stru.di_buf0_mif.bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:1;
+				di_post_stru.di_buf1_mif.bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:1;
+				di_post_stru.di_buf2_mif.bit_mode =
+			(di_buf->vframe->bitdepth & FULL_PACK_422_MODE)?3:1;
 			}
 		} else {
 			di_post_stru.di_buf0_mif.bit_mode = 0;
 			di_post_stru.di_buf1_mif.bit_mode = 0;
+			di_post_stru.di_buf2_mif.bit_mode = 0;
+		}
+		if (di_buf->vframe->type & VIDTYPE_VIU_444) {
+			di_post_stru.di_buf0_mif.video_mode = 1;
+			di_post_stru.di_buf1_mif.video_mode = 1;
+			di_post_stru.di_buf2_mif.video_mode = 1;
+		} else {
+			di_post_stru.di_buf0_mif.video_mode = 0;
+			di_post_stru.di_buf1_mif.video_mode = 0;
+			di_post_stru.di_buf2_mif.video_mode = 0;
 		}
 		if (di_post_stru.buf_type == VFRAME_TYPE_IN &&
 		    !(di_buf->di_buf_dup_p[0]->vframe->type &
@@ -6048,27 +6567,34 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 			if (di_buf->vframe->type & VIDTYPE_VIU_NV21) {
 				di_post_stru.di_buf0_mif.set_separate_en = 1;
 				di_post_stru.di_buf1_mif.set_separate_en = 1;
+				di_post_stru.di_buf2_mif.set_separate_en = 1;
 			} else {
 				di_post_stru.di_buf0_mif.set_separate_en = 0;
 				di_post_stru.di_buf1_mif.set_separate_en = 0;
+				di_post_stru.di_buf2_mif.set_separate_en = 0;
 			}
 			di_post_stru.di_buf0_mif.luma_y_start0 = di_start_y;
 			di_post_stru.di_buf0_mif.luma_y_end0 = di_end_y;
 		} else { /* from vdin or local vframe process by di pre */
 			di_post_stru.di_buf0_mif.set_separate_en = 0;
-			di_post_stru.di_buf0_mif.luma_y_start0 = di_start_y >>
-								 1;
+			di_post_stru.di_buf0_mif.luma_y_start0 =
+				di_start_y >> 1;
 			di_post_stru.di_buf0_mif.luma_y_end0 = di_end_y >> 1;
-
 			di_post_stru.di_buf1_mif.set_separate_en = 0;
-			di_post_stru.di_buf1_mif.luma_y_start0 = di_start_y >>
-								 1;
+			di_post_stru.di_buf1_mif.luma_y_start0 =
+				di_start_y >> 1;
 			di_post_stru.di_buf1_mif.luma_y_end0 = di_end_y >> 1;
+			di_post_stru.di_buf2_mif.set_separate_en = 0;
+			di_post_stru.di_buf2_mif.luma_y_end0 = di_end_y >> 1;
+			di_post_stru.di_buf2_mif.luma_y_start0 =
+				di_start_y >> 1;
 		}
 		di_post_stru.di_buf0_mif.luma_x_start0 = di_start_x;
 		di_post_stru.di_buf0_mif.luma_x_end0 = di_end_x;
 		di_post_stru.di_buf1_mif.luma_x_start0 = di_start_x;
 		di_post_stru.di_buf1_mif.luma_x_end0 = di_end_x;
+		di_post_stru.di_buf2_mif.luma_x_start0 = di_start_x;
+		di_post_stru.di_buf2_mif.luma_x_end0 = di_end_x;
 
 		if ((post_wr_en && post_wr_surpport)) {
 			di_post_stru.di_diwr_mif.start_x = di_start_x;
@@ -6097,13 +6623,6 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 		if (di_buf->pulldown_mode != PULL_DOWN_BUF1)
 			di_buf->pulldown_mode = PULL_DOWN_EI;
 	}
-	/* if post size < MIN_POST_WIDTH, force ei */
-	if ((di_width < MIN_BLEND_WIDTH) &&
-		(di_buf->pulldown_mode == PULL_DOWN_BLEND_0 ||
-		di_buf->pulldown_mode == PULL_DOWN_BLEND_2 ||
-		di_buf->pulldown_mode == PULL_DOWN_NORMAL
-		))
-		di_buf->pulldown_mode = PULL_DOWN_BUF1;
 
 #ifdef DI_USE_FIXED_CANVAS_IDX
 #ifdef CONFIG_VSYNC_RDMA
@@ -6129,18 +6648,24 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 		config_canvas_idx(
 			di_buf->di_buf_dup_p[0],
 			di_post_idx[di_post_stru.canvas_id][1], -1);
+		config_canvas_idx(
+			di_buf->di_buf_dup_p[2],
+			di_post_idx[di_post_stru.canvas_id][3], -1);
 		if (mcpre_en)
 			config_mcvec_canvas_idx(
 				di_buf->di_buf_dup_p[2],
-				di_post_idx[di_post_stru.canvas_id][3]);
+				di_post_idx[di_post_stru.canvas_id][4]);
 
 		/* for post_wr_en */
 		if ((post_wr_en && post_wr_surpport))
 			config_canvas_idx(
-di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
+			di_buf, di_post_idx[di_post_stru.canvas_id][5], -1);
 		break;
 	case PULL_DOWN_BLEND_2:
 		config_canvas_idx(
+			di_buf->di_buf_dup_p[0],
+			di_post_idx[di_post_stru.canvas_id][3], -1);
+		config_canvas_idx(
 			di_buf->di_buf_dup_p[1],
 			di_post_idx[di_post_stru.canvas_id][0], -1);
 		config_canvas_idx(
@@ -6152,10 +6677,10 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 		if (mcpre_en)
 			config_mcvec_canvas_idx(
 				di_buf->di_buf_dup_p[2],
-				di_post_idx[di_post_stru.canvas_id][3]);
+				di_post_idx[di_post_stru.canvas_id][4]);
 		if ((post_wr_en && post_wr_surpport))
 			config_canvas_idx(
-di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
+			di_buf, di_post_idx[di_post_stru.canvas_id][5], -1);
 		break;
 	case PULL_DOWN_MTN:
 		config_canvas_idx(
@@ -6207,16 +6732,8 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 	switch (di_buf->pulldown_mode) {
 	case PULL_DOWN_BLEND_0:
 	case PULL_DOWN_NORMAL:
-		post_field_num =
-			(di_buf->di_buf_dup_p[1]->vframe->type &
-			 VIDTYPE_TYPEMASK)
-			== VIDTYPE_INTERLACE_TOP ? 0 : 1;
-		di_post_stru.di_buf0_mif.canvas0_addr0 =
-			di_buf->di_buf_dup_p[1]->nr_canvas_idx;
-		di_post_stru.di_buf1_mif.canvas0_addr0 =
-			di_buf->di_buf_dup_p[0]->nr_canvas_idx;
-		di_post_stru.di_mtnprd_mif.canvas_num =
-			di_buf->di_buf_dup_p[2]->mtn_canvas_idx;
+		config_fftffb_mode(di_buf, &post_field_num,
+			(di_buf->di_buf_dup_p[tbbtff_dly]->privated&0x3));
 		if (mcpre_en)
 			di_post_stru.di_mcvecrd_mif.canvas_num =
 				di_buf->di_buf_dup_p[2]->mcvec_canvas_idx;
@@ -6237,6 +6754,8 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 			di_buf->di_buf_dup_p[1]->nr_canvas_idx;
 		di_post_stru.di_buf1_mif.canvas0_addr0 =
 			di_buf->di_buf_dup_p[2]->nr_canvas_idx;
+		di_post_stru.di_buf2_mif.canvas0_addr0 =
+			di_buf->di_buf_dup_p[0]->nr_canvas_idx;
 		di_post_stru.di_mtnprd_mif.canvas_num =
 			di_buf->di_buf_dup_p[2]->mtn_canvas_idx;
 		if (mcpre_en)
@@ -6326,6 +6845,18 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 		di_ddr_en = 0;
 	}
 
+	/* if post size < MIN_POST_WIDTH, force ei */
+	if ((di_width < MIN_BLEND_WIDTH) &&
+		(di_buf->pulldown_mode == PULL_DOWN_BLEND_0 ||
+		di_buf->pulldown_mode == PULL_DOWN_BLEND_2 ||
+		di_buf->pulldown_mode == PULL_DOWN_NORMAL
+		)) {
+		post_blend_mode = 1;
+		blend_mtn_en = 0;
+		post_ei = ei_en = 0;
+		post_blend_en = 0;
+	}
+
 	if (mcpre_en)
 		di_post_stru.di_mcvecrd_mif.blend_mode = post_blend_mode;
 
@@ -6334,6 +6865,7 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 		enable_di_post_2(
 			&di_post_stru.di_buf0_mif,
 			&di_post_stru.di_buf1_mif,
+			&di_post_stru.di_buf2_mif,
 			((post_wr_en && post_wr_surpport) ?
 				(&di_post_stru.di_diwr_mif):NULL),
 			&di_post_stru.di_mtnprd_mif,
@@ -6351,12 +6883,13 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 			enable_mc_di_post(
 				&di_post_stru.di_mcvecrd_mif, post_urgent,
 				overturn);
-		else if (is_meson_gxtvbb_cpu())
+		else if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu())
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 0, 2);
 	} else {
 		di_post_switch_buffer(
 			&di_post_stru.di_buf0_mif,
 			&di_post_stru.di_buf1_mif,
+			&di_post_stru.di_buf2_mif,
 ((post_wr_en && post_wr_surpport) ? (&di_post_stru.di_diwr_mif):NULL),
 			&di_post_stru.di_mtnprd_mif,
 			&di_post_stru.di_mcvecrd_mif,
@@ -6377,19 +6910,19 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 		di_apply_reg_cfg(1);
 
 #endif
-	if (is_meson_gxtvbb_cpu())
+	if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu())
 		di_post_read_reverse_irq(overturn);
 	if (mcpre_en) {
 		if (di_buf->di_buf_dup_p[2])
 			set_post_mcinfo(&di_buf->di_buf_dup_p[2]
 				->curr_field_mcinfo);
-	} else if (is_meson_gxtvbb_cpu())
+	} else if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu())
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 0, 2);
 
 
 /* set pull down region (f(t-1) */
 
-	if (is_meson_gxtvbb_cpu() && pulldown_enable &&
+	if (di_pldn_buf && pulldown_enable &&
 		!di_pre_stru.cur_prog_flag) {
 		if (pldn_wnd_flsh == 1) {
 			DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_REG0_Y,
@@ -6766,8 +7299,6 @@ static int pulldown_mode;
 static int debug_blend_mode = -1;
 
 static unsigned int pldn_dly1 = 1;
-module_param(pldn_dly1, uint, 0644);
-MODULE_PARM_DESC(pldn_dly1, "/n pulldonw field delay result./n");
 
 static unsigned int pldn_pst_wver = 5;
 module_param(pldn_pst_wver, uint, 0644);
@@ -6776,7 +7307,7 @@ MODULE_PARM_DESC(pldn_pst_wver, "/n pulldonw post-weaver for test./n");
 int set_pulldown_mode(int buffer_keep_count, struct di_buf_s *di_buf)
 {
 	int pulldown_mode_hise = 0;
-	if (is_meson_gxtvbb_cpu()) {
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXTVBB)) {
 		if (pulldown_enable && !di_pre_stru.cur_prog_flag)
 			di_buf->pulldown_mode =
 				di_buf->di_buf_dup_p[pldn_dly1]->pulldown_mode;
@@ -7394,7 +7925,7 @@ static void di_unreg_process_irq(void)
 /* stop rdma */
 	rdma_clear(de_devp->rdma_handle);
 #endif
-	if (is_meson_gxtvbb_cpu())
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXTVBB))
 		if (dejaggy_enable) {
 			dejaggy_flag = -1;
 			DI_Wr_reg_bits(SRSHARP0_SHARP_DEJ1_MISC, 0, 3, 1);
@@ -7405,8 +7936,7 @@ static void di_unreg_process_irq(void)
 	DI_Wr(DI_CLKG_CTRL, 0xff0000);
 /* di enable nr clock gate */
 #else
-	if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() ||
-		is_meson_gxm_cpu())
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXTVBB))
 		DI_Wr(DI_CLKG_CTRL, 0x80f60000);
 	else
 		DI_Wr(DI_CLKG_CTRL, 0xf60000);
@@ -7535,23 +8065,21 @@ static void di_reg_process_irq(void)
 			spin_lock_irqsave(&plist_lock, flags);
 #endif
 			di_lock_irqfiq_save(irq_flag2, fiq_flag);
-			if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() ||
-				is_meson_gxm_cpu()) {
-				/* di_init_buf(vframe->width,
-				 * vframe->height, 1); */
-				 /*
-				 * 10 bit mode need 1.5 times buffer size of
-				 * 8 bit mode, init the buffer size as 10 bit
-				 * mode size, to make sure can switch bit mode
-				 * smoothly.
-				 */
-				if (nr10bit_surpport)
-					di_init_buf(default_width * 3 / 2,
+			/* di_init_buf(vframe->width,
+			 * vframe->height, 1); */
+			 /*
+			 * 10 bit mode need 1.5 times buffer size of
+			 * 8 bit mode, init the buffer size as 10 bit
+			 * mode size, to make sure can switch bit mode
+			 * smoothly.
+			 */
+			if (nr10bit_surpport) {
+				if (full_422_pack)
+					di_init_buf(default_width * 5 / 4,
 						default_height, 1);
 				else
-					di_init_buf(default_width,
+					di_init_buf(default_width * 3 / 2,
 						default_height, 1);
-
 			} else
 				di_init_buf(default_width, default_height, 1);
 
@@ -7565,21 +8093,20 @@ static void di_reg_process_irq(void)
 			spin_lock_irqsave(&plist_lock, flags);
 #endif
 			di_lock_irqfiq_save(irq_flag2, fiq_flag);
-			if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() ||
-				is_meson_gxm_cpu()) {
-				/*
-				 * 10 bit mode need 1.5 times buffer size of
-				 * 8 bit mode, init the buffer size as 10 bit
-				 * mode size, to make sure can switch bit mode
-				 * smoothly.
-				 */
-				if (nr10bit_surpport)
-					di_init_buf(default_width * 3 / 2,
-						default_height, 0);
+			/*
+			 * 10 bit mode need 1.5 times buffer size of
+			 * 8 bit mode, init the buffer size as 10 bit
+			 * mode size, to make sure can switch bit mode
+			 * smoothly.
+			 */
+			if (nr10bit_surpport) {
+				if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL) &&
+					full_422_pack)
+					di_init_buf(
+				default_width * 3 / 2, default_height, 0);
 				else
-					di_init_buf(default_width,
-						default_height, 0);
-
+					di_init_buf(
+				default_width * 3 / 2, default_height, 0);
 			} else
 				di_init_buf(default_width, default_height, 0);
 
@@ -7592,6 +8119,11 @@ static void di_reg_process_irq(void)
 
 		reset_pulldown_state();
 		combing_threshold_config(vframe->width);
+		if (is_meson_txl_cpu()) {
+			combing_pd22_window_config(vframe->width,
+				(vframe->height>>1));
+			tbff_init();
+		}
 		init_flag = 1;
 		di_pre_stru.reg_req_flag_irq = 1;
 	}
@@ -8006,6 +8538,7 @@ light_unreg:
 #endif
 	} else if (type == VFRAME_EVENT_PROVIDER_REG) {
 		char *provider_name = (char *)data;
+		char *receiver_name = NULL;
 		bypass_state = 0;
 		di_pre_stru.reg_req_flag = 1;
 		pr_dbg("%s: vframe provider reg\n", __func__);
@@ -8024,14 +8557,19 @@ light_unreg:
 			vdin_source_flag = 0;
 			pre_urgent = 0;
 		}
-		if (strcmp(vf_get_receiver_name(VFM_NAME), "amvideo") == 0) {
-			di_post_stru.run_early_proc_fun_flag = 0;
-			receiver_is_amvideo = 1;
-			/* pr_info("set run_early_proc_fun_flag to 1\n"); */
+		receiver_name = vf_get_receiver_name(VFM_NAME);
+		if (receiver_name) {
+			if (strcmp(receiver_name, "amvideo") == 0) {
+				di_post_stru.run_early_proc_fun_flag = 0;
+				receiver_is_amvideo = 1;
+		/* pr_info("set run_early_proc_fun_flag to 1\n"); */
+			} else {
+				di_post_stru.run_early_proc_fun_flag = 1;
+				receiver_is_amvideo = 0;
+		/* pr_dbg("set run_early_proc_fun_flag to 1\n"); */
+			}
 		} else {
-			di_post_stru.run_early_proc_fun_flag = 1;
-			receiver_is_amvideo = 0;
-/* pr_dbg("set run_early_proc_fun_flag to 1\n"); */
+			pr_info("%s error receiver is null.\n", __func__);
 		}
 	}
 #ifdef DET3D
@@ -8473,9 +9011,11 @@ unsigned int RDMA_WR_BITS(unsigned int adr, unsigned int val,
 
 static void set_di_flag(void)
 {
-	if (is_meson_gxtvbb_cpu()) {
+	if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) {
 		mcpre_en = true;
 		pulldown_mode = 1;
+		pulldown_enable = 1;
+		di_pre_rdma_enable = false;
 		di_vscale_skip_enable = 4;
 		use_2_interlace_buff = 1;
 		pre_hold_line = 12;
@@ -8483,13 +9023,31 @@ static void set_di_flag(void)
 			di_force_bit_mode = 10;
 		else
 			di_force_bit_mode = 8;
+		if (is_meson_txl_cpu()) {
+			full_422_pack = true;
+			tff_bff_enable = true;
+			dejaggy_enable = 0;
+		}
 	} else {
 		mcpre_en = false;
 		pulldown_mode = 0;
+		pulldown_enable = 0;
+		di_pre_rdma_enable = false;
 		di_vscale_skip_enable = 4;
 		use_2_interlace_buff = 0;
 		di_force_bit_mode = 8;
 	}
+
+	if (di_pre_rdma_enable) {
+		pldn_dly = 1;
+		pldn_dly1 = 1;
+		tbbtff_dly = 1;
+	} else {
+		pldn_dly = 2;
+		pldn_dly1 = 2;
+		tbbtff_dly = 0;
+	}
+
 	return;
 }
 
@@ -8653,7 +9211,7 @@ static int di_probe(struct platform_device *pdev)
 	init_pd_para();
 	di_hw_init();
 
-	if (is_meson_gxtvbb_cpu() && pulldown_enable)
+	if (pulldown_enable)
 		FlmVOFSftInt(&pd_param);
 
 	set_di_flag();
@@ -9150,3 +9708,19 @@ vframe_t *get_di_inp_vframe(void)
 		vframe = di_pre_stru.di_inp_buf->vframe;
 	return vframe;
 }
+
+module_param_named(full_422_pack, full_422_pack, bool, 0644);
+#ifdef DEBUG_SUPPORT
+module_param_named(di_pre_rdma_enable, di_pre_rdma_enable, uint, 0664);
+module_param_named(pldn_dly, pldn_dly, uint, 0644);
+module_param_named(tbbtff_dly, tbbtff_dly, uint, 0644);
+
+module_param(pldn_dly1, uint, 0644);
+MODULE_PARM_DESC(pldn_dly1, "/n pulldonw field delay result./n");
+
+module_param(flm22_sure_num, uint, 0644);
+MODULE_PARM_DESC(flm22_sure_num, "ture film-22/n");
+
+module_param(flm22_glbpxlnum_rat, uint, 0644);
+MODULE_PARM_DESC(flm22_glbpxlnum_rat, "flm22_glbpxlnum_rat/n");
+#endif
diff --git a/drivers/amlogic/deinterlace/deinterlace.h b/drivers/amlogic/deinterlace/deinterlace.h
index 8673d13..554cf27 100644
--- a/drivers/amlogic/deinterlace/deinterlace.h
+++ b/drivers/amlogic/deinterlace/deinterlace.h
@@ -156,7 +156,7 @@ struct di_buf_s {
 	int cnt_canvas_idx;
 #endif
 #ifdef NEW_DI_V3
-	unsigned int mcinfo_adr;
+	unsigned long mcinfo_adr;
 	int mcinfo_canvas_idx;
 	unsigned long mcvec_adr;
 	int mcvec_canvas_idx;
@@ -166,7 +166,7 @@ struct di_buf_s {
 	unsigned int regs[26];/* reg 0x2fb0~0x2fc9 */
 	} curr_field_mcinfo;
 #endif
-
+	/* blend window */
 	unsigned short reg0_s;
 	unsigned short reg0_e;
 	unsigned short reg0_bmode;
@@ -179,7 +179,8 @@ struct di_buf_s {
 	unsigned short reg3_s;
 	unsigned short reg3_e;
 	unsigned short reg3_bmode;
-
+	/* tff bff check result bit[1:0]*/
+	unsigned int privated;
 	unsigned int canvas_config_flag;
 	/* 0,configed; 1,config type 1 (prog);
 	2, config type 2 (interlace) */
@@ -344,6 +345,7 @@ void initial_di_post_2(int hsize_post, int vsize_post, int hold_line);
 void enable_di_post_2(
 	struct DI_MIF_s		*di_buf0_mif,
 	struct DI_MIF_s		*di_buf1_mif,
+	struct DI_MIF_s		*di_buf2_mif,
 	struct DI_SIM_MIF_s	*di_diwr_mif,
 	#ifndef NEW_DI_V2
 	struct DI_SIM_MIF_s	*di_mtncrd_mif,
@@ -360,6 +362,7 @@ void enable_di_post_2(
 void di_post_switch_buffer(
 	struct DI_MIF_s		*di_buf0_mif,
 	struct DI_MIF_s		*di_buf1_mif,
+	struct DI_MIF_s		*di_buf2_mif,
 	struct DI_SIM_MIF_s	*di_diwr_mif,
 	#ifndef NEW_DI_V2
 	struct DI_SIM_MIF_s	*di_mtncrd_mif,
@@ -438,8 +441,9 @@ void diwr_set_power_control(unsigned char enable);
 
 unsigned char di_get_power_control(unsigned char type);
 void config_di_bit_mode(vframe_t *vframe, unsigned int bypass_flag);
-void di_bit_mode_bypass_cfg(vframe_t *vframe, unsigned int bypass_flag);
-
+void combing_pd22_window_config(unsigned int width, unsigned int height);
+int tff_bff_check(int height, int width);
+void tbff_init(void);
 #ifdef CONFIG_AM_ATVDEMOD
 extern int aml_atvdemod_get_snr_ex(void);
 #endif
diff --git a/drivers/amlogic/deinterlace/deinterlace_hw.c b/drivers/amlogic/deinterlace/deinterlace_hw.c
index 8cdd872..0957aa6 100644
--- a/drivers/amlogic/deinterlace/deinterlace_hw.c
+++ b/drivers/amlogic/deinterlace/deinterlace_hw.c
@@ -76,6 +76,10 @@ unsigned int di_force_bit_mode = 10;
 module_param(di_force_bit_mode, uint, 0664);
 MODULE_PARM_DESC(di_force_bit_mode, "force DI bit mode to 8 or 10 bit");
 
+static unsigned short mc_pre_flag = 2;
+MODULE_PARM_DESC(mc_pre_flag, "\n mc per/forward flag\n");
+module_param(mc_pre_flag, ushort, 0664);
+
 #ifdef DET3D
 static unsigned int det3d_cfg;
 module_param(det3d_cfg, uint, 0664);
@@ -176,20 +180,19 @@ static void mc_di_param_init(void)
 
 static void init_field_mode(void)
 {
-	if (is_meson_gxtvbb_cpu()) {
-		DI_Wr(DIPD_COMB_CTRL0, 0x02400210);
-		DI_Wr(DIPD_COMB_CTRL1, 0x88080808);
-		DI_Wr(DIPD_COMB_CTRL2, 0x41041008);
-		DI_Wr(DIPD_COMB_CTRL3, 0x00008053);
-		DI_Wr(DIPD_COMB_CTRL4, 0x20070002);
-		DI_Wr(DIPD_COMB_CTRL5, 0x04040804);
-	}
+	DI_Wr(DIPD_COMB_CTRL0, 0x02400210);
+	DI_Wr(DIPD_COMB_CTRL1, 0x88080808);
+	DI_Wr(DIPD_COMB_CTRL2, 0x41041008);
+	DI_Wr(DIPD_COMB_CTRL3, 0x00008053);
+	DI_Wr(DIPD_COMB_CTRL4, 0x20070002);
+	DI_Wr(DIPD_COMB_CTRL5, 0x04040804);
 }
 
 void di_hw_init(void)
 {
 #ifdef NEW_DI_V1
-	unsigned short fifo_size = 0xc0;
+	unsigned short fifo_size_vpp = 0xc0;
+	unsigned short fifo_size_di = 0xc0;
 #endif
 
 #ifdef NEW_DI_V1
@@ -199,18 +202,22 @@ void di_hw_init(void)
 	else
 		DI_Wr(DI_CLKG_CTRL, 0x1); /* di no clock gate */
 
-	/* fifo size setting from 0x1be60 to 0x1bf20 */
-	DI_Wr(VD1_IF0_LUMA_FIFO_SIZE,	fifo_size);
-	/* 1a63 is vd1_if0_luma_fifo_size */
-	DI_Wr(VD2_IF0_LUMA_FIFO_SIZE,	fifo_size);
+	if (is_meson_txl_cpu()) {
+		/* vpp fifo max size on txl :128*3=384[0x180] */
+		/* di fifo max size on txl :96*3=288[0x120] */
+		fifo_size_vpp = 0x180;
+		fifo_size_di = 0x120;
+	}
+	DI_Wr(VD1_IF0_LUMA_FIFO_SIZE, fifo_size_vpp);
+	DI_Wr(VD2_IF0_LUMA_FIFO_SIZE, fifo_size_vpp);
 	/* 1a83 is vd2_if0_luma_fifo_size */
-	DI_Wr(DI_INP_LUMA_FIFO_SIZE,	fifo_size);
+	DI_Wr(DI_INP_LUMA_FIFO_SIZE,	fifo_size_di);
 	/* 17d8 is DI_INP_luma_fifo_size */
-	DI_Wr(DI_MEM_LUMA_FIFO_SIZE,	fifo_size);
+	DI_Wr(DI_MEM_LUMA_FIFO_SIZE,	fifo_size_di);
 	/* 17e5 is DI_MEM_luma_fifo_size */
-	DI_Wr(DI_IF1_LUMA_FIFO_SIZE,	fifo_size);
+	DI_Wr(DI_IF1_LUMA_FIFO_SIZE,	fifo_size_di);
 	/* 17f2 is  DI_IF1_luma_fifo_size */
-	DI_Wr(DI_CHAN2_LUMA_FIFO_SIZE, fifo_size);
+	DI_Wr(DI_CHAN2_LUMA_FIFO_SIZE, fifo_size_di);
 	/* 17b3 is DI_chan2_luma_fifo_size */
 #endif
 	DI_Wr(DI_PRE_HOLD, (1 << 31) | (31 << 16) | 31);
@@ -227,7 +234,7 @@ void di_hw_init(void)
 	ma_di_init();
 #endif
 
-	if (is_meson_gxtvbb_cpu() && pulldown_enable)
+	if (pulldown_enable)
 		init_field_mode();
 
 	if (mcpre_en)
@@ -244,14 +251,15 @@ void di_hw_uninit(void)
 static void pre_bit_mode_config(unsigned char inp,
 	unsigned char mem, unsigned char chan2, unsigned char nrwr)
 {
-	if (!is_meson_gxtvbb_cpu() && !is_meson_gxl_cpu() &&
-		!is_meson_gxm_cpu())
+	if (!cpu_after_eq(MESON_CPU_MAJOR_ID_GXTVBB))
 		return;
 
 	RDMA_WR_BITS(DI_INP_GEN_REG3, inp&0x3, 8, 2);
 	RDMA_WR_BITS(DI_MEM_GEN_REG3, mem&0x3, 8, 2);
 	RDMA_WR_BITS(DI_CHAN2_GEN_REG3, chan2&0x3, 8, 2);
 	RDMA_WR_BITS(DI_NRWR_Y, nrwr&0x1, 14, 1);
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL) && ((nrwr&0x3) == 0x3))
+		RDMA_WR_BITS(DI_NRWR_CTRL, 0x3, 22, 2);
 }
 
 unsigned int nr2_en = 0x1;
@@ -350,7 +358,7 @@ void enable_di_pre_aml(
 	nr_h = (di_nrwr_mif->end_y - di_nrwr_mif->start_y + 1);
 	RDMA_WR(NR2_FRM_SIZE, (nr_h<<16)|nr_w);
 	/*gate for nr*/
-	if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() || is_meson_gxm_cpu())
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXTVBB))
 		RDMA_WR_BITS(NR2_SW_EN, nr2_en, 4, 1);
 	else {
 		/*only process sd,avoid affecting sharp*/
@@ -526,11 +534,16 @@ void enable_mc_di_post(struct DI_MC_MIF_s *di_mcvecrd_mif,
 						(0x31<<16));
 	DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, di_mcvecrd_mif->vecrd_offset,
 		12, 3);
+
 	if (di_mcvecrd_mif->blend_mode == 3)
 		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcen_mode, 0, 2);
 	else
 		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 0, 2);
-	DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcuv_en, 9, 1);
+	if (is_meson_txl_cpu()) {
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcuv_en, 10, 1);
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 1, 11, 3);
+	} else
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcuv_en, 9, 1);
 	DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcdebug_mode, 2, 3);
 }
 
@@ -590,12 +603,21 @@ static void set_di_inp_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
 		luma0_rpt_loop_pat = 0x80;
 		chroma0_rpt_loop_pat = mif->src_prog?0:0x80;
 
-		if (mif->output_field_num == 0) {
-			vt_ini_phase = 0xc;
-			vfmt_rpt_first = 1;
-		} else {
-			vt_ini_phase = 0x4;
-		}
+		vfmt_rpt_first = 1;
+		if (mif->output_field_num == 0)
+			vt_ini_phase = 0xa;
+		else
+			vt_ini_phase = 0xe;
+
+		if (mif->src_prog) {
+			if (mif->output_field_num == 0) {
+				vt_ini_phase = 0x4;
+			} else {
+				vt_ini_phase = 0xc;
+				vfmt_rpt_first = 0;
+			}
+		 }
+
 	} else if (mif->set_separate_en != 0 && mif->src_field_mode == 0) {
 		chro_rpt_lastl_ctrl = 1;
 		luma0_rpt_loop_start = 0;
@@ -995,9 +1017,138 @@ static void set_di_if1_fmt_more(int hfmt_en,
 	DI_VSYNC_WR_MPEG_REG(DI_IF1_FMT_W, (y_length << 16) |
 							 (c_length << 0));
 }
+static void set_di_if2_fmt_more(int hfmt_en,
+				int hz_yc_ratio,/* 2bit */
+				int hz_ini_phase,/* 4bit */
+				int vfmt_en,
+				int vt_yc_ratio,/* 2bit */
+				int vt_ini_phase,/* 4bit */
+				int y_length,
+				int c_length,
+				int hz_rpt	/* 1bit */
+				)
+{
+	int vt_phase_step = (16 >> vt_yc_ratio);
+
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_FMT_CTRL,
+	(hz_rpt << 28)|/* hz rpt pixel */
+	(hz_ini_phase << 24)|/* hz ini phase */
+	(0 << 23)|/* repeat p0 enable */
+	(hz_yc_ratio << 21)|/* hz yc ratio */
+	(hfmt_en << 20)|/* hz enable */
+	(1 << 17)|/* nrpt_phase0 enable */
+	(0 << 16)|/* repeat l0 enable */
+	(0 << 12)|/* skip line num */
+	(vt_ini_phase << 8)|/* vt ini phase */
+	(vt_phase_step << 1)|/* vt phase step (3.4) */
+	(vfmt_en << 0) /* vt enable */
+					);
+
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_FMT_W, (y_length << 16) |
+							 (c_length << 0));
+}
 
 static const u32 vpat[] = {0, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
 
+static void set_di_if2_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
+{
+	unsigned int bytes_per_pixel, demux_mode;
+	unsigned int pat, loop = 0, chro_rpt_lastl_ctrl = 0;
+
+	if (mif->set_separate_en == 1) {
+		pat = vpat[(di_vscale_skip_count_real<<1)+1];
+		/*top*/
+		if (mif->src_field_mode == 0) {
+			chro_rpt_lastl_ctrl = 1;
+			loop = 0x11;
+			pat <<= 4;
+		}
+	} else {
+		loop = 0;
+		pat = vpat[di_vscale_skip_count_real];
+	}
+
+	bytes_per_pixel = mif->set_separate_en ? 0 : (mif->video_mode ? 2 : 1);
+	demux_mode = mif->video_mode;
+
+
+	/* ---------------------- */
+	/* General register */
+	/* ---------------------- */
+
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_GEN_REG, (0 << 29) | /* reset on go field */
+			(urgent << 28)	|/* urgent */
+			(urgent << 27)	|/* luma urgent */
+			(1 << 25)|/* no dummy data. */
+			(hold_line << 19)|/* hold lines */
+			(1 << 18)|/* push dummy pixel */
+			(demux_mode << 16)|/* demux_mode */
+			(bytes_per_pixel << 14)|
+			(1 << 12)|/*burst_size_cr*/
+			(1 << 10)|/*burst_size_cb*/
+			(3 << 8)|/*burst_size_y*/
+			(chro_rpt_lastl_ctrl << 6)|
+			((mif->set_separate_en != 0) << 1)|
+			(1 << 0)/* cntl_enable */
+		);
+	/* post bit mode config, if0 config in video.c
+	DI_VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG3, mif->bit_mode, 8, 2);
+	*/
+	/* ---------------------- */
+	/* Canvas */
+	/* ---------------------- */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_CANVAS0, (mif->canvas0_addr2 << 16) |
+		(mif->canvas0_addr1 << 8) | (mif->canvas0_addr0 << 0));
+
+	/* ---------------------- */
+	/* Picture 0 X/Y start,end */
+	/* ---------------------- */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_LUMA_X0, (mif->luma_x_end0 << 16) |
+		(mif->luma_x_start0 << 0));
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_LUMA_Y0, (mif->luma_y_end0 << 16) |
+		(mif->luma_y_start0 << 0));
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_CHROMA_X0, (mif->chroma_x_end0 << 16) |
+		(mif->chroma_x_start0 << 0));
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_CHROMA_Y0, (mif->chroma_y_end0 << 16) |
+		(mif->chroma_y_start0 << 0));
+
+	/* ---------------------- */
+	/* Repeat or skip */
+	/* ---------------------- */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_RPT_LOOP, (loop << 24) |
+							   (loop << 16) |
+							   (loop << 8) |
+							   (loop << 0)
+					 );
+
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_LUMA0_RPT_PAT, pat);
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_CHROMA0_RPT_PAT, pat);
+
+	/* Dummy pixel value */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_DUMMY_PIXEL, 0x00808000);
+	if (mif->set_separate_en != 0) { /* 4:2:0 block mode. */
+		set_di_if2_fmt_more(1, /* hfmt_en */
+		1,/* hz_yc_ratio */
+		0,/* hz_ini_phase */
+		1,	/* vfmt_en */
+		1, /* vt_yc_ratio */
+		0, /* vt_ini_phase */
+		mif->luma_x_end0 - mif->luma_x_start0 + 1,
+		mif->chroma_x_end0 - mif->chroma_x_start0 + 1,
+							 0); /* hz repeat. */
+	} else {
+		set_di_if2_fmt_more(1,	/* hfmt_en */
+		1, /* hz_yc_ratio */
+		0, /* hz_ini_phase */
+		0,	/* vfmt_en */
+		0,	/* vt_yc_ratio */
+		0, /* vt_ini_phase */
+			mif->luma_x_end0 - mif->luma_x_start0 + 1,
+			((mif->luma_x_end0 >> 1) - (mif->luma_x_start0>>1) + 1),
+							 0); /* hz repeat */
+	}
+}
+
 static void set_di_if1_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
 {
 	unsigned int bytes_per_pixel, demux_mode;
@@ -1347,7 +1498,7 @@ void initial_di_post_2(int hsize_post, int vsize_post, int hold_line)
 	else
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_EI_CTRL3, 1, 31, 1);
 
-	if (is_meson_gxtvbb_cpu() && pulldown_enable) {
+	if (pulldown_enable) {
 		/* DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG0_Y, (vsize_post>>2)-1 ); */
 		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG0_Y, (vsize_post-1));
 		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG1_Y,
@@ -1395,6 +1546,7 @@ MODULE_PARM_DESC(pldn_ctrl_rflsh, "/n post blend reflesh./n");
 void di_post_switch_buffer(
 	struct DI_MIF_s		   *di_buf0_mif,
 	struct DI_MIF_s		   *di_buf1_mif,
+	struct DI_MIF_s		   *di_buf2_mif,
 	struct DI_SIM_MIF_s    *di_diwr_mif,
 	struct DI_SIM_MIF_s    *di_mtnprd_mif,
 	struct DI_MC_MIF_s	   *di_mcvecrd_mif,
@@ -1413,13 +1565,24 @@ void di_post_switch_buffer(
 
 	if (!ei_only && (di_ddr_en || di_vpp_en)) {
 		DI_VSYNC_WR_MPEG_REG(DI_IF1_CANVAS0,
-(di_buf1_mif->canvas0_addr2 << 16) |
-(di_buf1_mif->canvas0_addr1 << 8) | (di_buf1_mif->canvas0_addr0 << 0));
+			(di_buf1_mif->canvas0_addr2 << 16) |
+			(di_buf1_mif->canvas0_addr1 << 8) |
+			(di_buf1_mif->canvas0_addr0 << 0));
+		if (is_meson_txl_cpu())
+			DI_VSYNC_WR_MPEG_REG(DI_IF2_CANVAS0,
+				(di_buf2_mif->canvas0_addr2 << 16) |
+				(di_buf2_mif->canvas0_addr1 << 8) |
+				(di_buf2_mif->canvas0_addr0 << 0));
+	#if 0
 	/* post bit mode config, if0 config in video.c */
 		if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() ||
 			is_meson_gxm_cpu())
 			DI_VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3,
 						di_buf1_mif->bit_mode, 8, 2);
+		if (is_meson_txl_cpu())
+			DI_VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG3,
+				di_buf2_mif->bit_mode, 8, 2);
+	#endif
 	}
 
 	/* motion for current display field. */
@@ -1442,8 +1605,7 @@ void di_post_switch_buffer(
 			di_diwr_mif->canvas_num | (urgent << 16)); /* urgent. */
 		}
 	}
-	if (is_meson_gxtvbb_cpu() && (pldn_ctrl_rflsh == 1)
-		&& pulldown_enable) {
+	if ((pldn_ctrl_rflsh == 1) && pulldown_enable) {
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, blend_en, 31, 1);
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, 7, 22, 3);
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, blend_mode, 20, 2);
@@ -1492,6 +1654,7 @@ void di_post_switch_buffer(
 void enable_di_post_2(
 	struct DI_MIF_s		   *di_buf0_mif,
 	struct DI_MIF_s		   *di_buf1_mif,
+	struct DI_MIF_s		   *di_buf2_mif,
 	struct DI_SIM_MIF_s    *di_diwr_mif,
 	struct DI_SIM_MIF_s    *di_mtnprd_mif,
 	int ei_en, int blend_en, int blend_mtn_en, int blend_mode,
@@ -1510,6 +1673,8 @@ void enable_di_post_2(
 
 	/* if (!ei_only && (di_ddr_en || di_vpp_en)) */
 		set_di_if1_mif(di_buf1_mif, di_vpp_en, hold_line);
+		if (is_meson_txl_cpu())
+			set_di_if2_mif(di_buf2_mif, di_vpp_en, hold_line);
 
 	/* printk("%s: ei_only %d,buf1_en %d,ei_en %d,di_vpp_en %d,
 di_ddr_en %d,blend_mtn_en %d,blend_mode %d.\n",
@@ -1581,6 +1746,8 @@ void disable_post_deinterlace_2(void)
 	DI_VSYNC_WR_MPEG_REG(DI_POST_CTRL, 0x3 << 30);
 	DI_VSYNC_WR_MPEG_REG(DI_POST_SIZE, (32-1) | ((128-1) << 16));
 	DI_VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG, 0x3 << 30);
+	if (is_meson_txl_cpu())
+		DI_VSYNC_WR_MPEG_REG(DI_IF2_GEN_REG, 0x3 << 30);
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 		/* disable ma,enable if0 to vpp,enable afbc to vpp */
 		if (Rd_reg_bits(VIU_MISC_CTRL0, 16, 4) != 0)
@@ -1765,7 +1932,12 @@ void di_post_read_reverse_irq(bool reverse)
 		if (mcpre_en) {
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_X, 0, 30, 1);
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_Y, 0, 30, 1);
-			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 1, 8, 1);
+			if (is_meson_txl_cpu())
+				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+					mc_pre_flag, 8, 2);
+			else
+				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+					1, 8, 1);
 		}
 	}
 }
@@ -1813,6 +1985,7 @@ unsigned char di_get_power_control(unsigned char type)
 
 static void di_nr_init(void)
 {
+#if 0
 	DI_Wr(DI_NR_CTRL0, 0xc60c0804);
 	DI_Wr(DI_NR_CTRL1, 0x403e3c3a);
 	DI_Wr(DI_NR_CTRL2, 0x08010a01);
@@ -1824,12 +1997,14 @@ static void di_nr_init(void)
 	DI_Wr(NR2_MATNR_MTN_CRTL2, 0x32020);
 	DI_Wr(NR2_MATNR_MTN_COR, 0x3333);
 	DI_Wr(NR2_MATNR_DEGHOST, 0x133);
-	DI_Wr(NR2_MATNR_ALPHALP_LUT1, 0x80805040);
+	DI_Wr(NR2_MATNR_ALPHALP_LUT0, 0x99999a9a);
+	DI_Wr(NR2_MATNR_ALPHALP_LUT1, 0x9aa0a6e3);
 	DI_Wr(NR2_MATNR_ALPHALP_LUT2, 0x90808080);
 	DI_Wr(NR2_MATNR_ALPHALP_LUT3, 0xffe0c0a4);
 	DI_Wr(NR2_MATNR_ALPHAHP_LUT1, 0x80805040);
 	DI_Wr(NR2_MATNR_ALPHAHP_LUT2, 0x90808080);
 	DI_Wr(NR2_MATNR_ALPHAHP_LUT3, 0xffe0c0a4);
+#endif
 	DI_Wr(NR3_MODE, 0x3);
 	DI_Wr(NR3_COOP_PARA, 0x28ff00);
 	DI_Wr(NR3_CNOOP_GAIN, 0x881900);
@@ -1837,6 +2012,68 @@ static void di_nr_init(void)
 	DI_Wr(NR3_CMOT_PARA, 0x08140f);
 	DI_Wr(NR3_SUREMOT_YGAIN, 0x100c4014);
 	DI_Wr(NR3_SUREMOT_CGAIN, 0x22264014);
+
+	DI_Wr(0x1745, 0x5056410);
+	DI_Wr(0x1746, 0x45056410);
+	DI_Wr(0x1747, 0x45056410);
+	DI_Wr(0x1748, 0x1);
+	DI_Wr(0x1749, 0x7c3a);
+	DI_Wr(0x174a, 0x29e77);
+	DI_Wr(0x174b, 0x9f1a);
+	DI_Wr(0x174c, 0x2822c);
+	DI_Wr(0x174d, 0x77);
+	DI_Wr(0x174e, 0x3030);
+	DI_Wr(0x174f, 0x20030);
+	DI_Wr(0x1750, 0xf002d0);
+	DI_Wr(0x1751, 0x132f);
+	DI_Wr(0x1752, 0x8d);
+	DI_Wr(0x1753, 0x40ff00);
+	DI_Wr(0x1754, 0x4);
+	DI_Wr(0x1755, 0xc2b64);
+	DI_Wr(0x1756, 0x0);
+	DI_Wr(0x1757, 0x3608);
+	DI_Wr(0x1758, 0x420);
+	DI_Wr(0x1759, 0xa06664);
+	DI_Wr(0x175a, 0xe0000);
+	DI_Wr(0x175b, 0x991c00);
+	DI_Wr(0x175c, 0x991000);
+	DI_Wr(0x175d, 0xf9f3e);
+	DI_Wr(0x175e, 0x7292abcd);
+	DI_Wr(0x175f, 0x1c23314f);
+	DI_Wr(0x1760, 0xf111317);
+	DI_Wr(0x1761, 0x8090a0c);
+	DI_Wr(0x1762, 0x80a0e0ff);
+	DI_Wr(0x1763, 0x4102050);
+	DI_Wr(0x1764, 0x2);
+	DI_Wr(0x1765, 0x0);
+	DI_Wr(0x1766, 0x20100400);
+	DI_Wr(0x1767, 0xc4804030);
+	DI_Wr(0x1768, 0xfffff0e0);
+	DI_Wr(0x1769, 0xffffffff);
+	DI_Wr(0x176a, 0x1132);
+	DI_Wr(0x176b, 0x32020);
+	DI_Wr(0x176c, 0x3333);
+	DI_Wr(0x176d, 0x4b4e4b4d);
+	DI_Wr(0x176e, 0x111);
+	DI_Wr(0x176f, 0x32181818);
+	DI_Wr(0x1770, 0x80644032);
+	DI_Wr(0x1771, 0x9e808080);
+	DI_Wr(0x1772, 0xffffffff);
+	DI_Wr(0x1773, 0x32181818);
+	DI_Wr(0x1774, 0x80644032);
+	DI_Wr(0x1775, 0xa5808080);
+	DI_Wr(0x1776, 0xffffffff);
+	DI_Wr(0x1777, 0xa06663);
+	DI_Wr(0x1778, 0x372);
+	DI_Wr(0x1779, 0x14141414);
+	DI_Wr(0x177a, 0x1400);
+	DI_Wr(0x177b, 0x80064);
+	DI_Wr(0x177c, 0x80064);
+	DI_Wr(0x177d, 0x80a0a);
+	DI_Wr(0x177e, 0x4281e);
+	DI_Wr(0x177f, 0x0);
+	DI_Wr(0x179c, 0x11b);
+	DI_Wr(0x179d, 0x202220);
 }
 
 void enable_di_pre_mif(int en)
@@ -1887,3 +2124,31 @@ void enable_di_pre_mif(int en)
 		DI_Wr(DI_INP_GEN_REG, Rd(DI_INP_GEN_REG) & ~0x1);
 	}
 }
+
+void combing_pd22_window_config(unsigned int width, unsigned int height)
+{
+	unsigned short y1 = 39, y2 = height - 41;
+	if (width == 1080) {
+		y1 = 79;
+		y2 = height - 81;
+	}
+
+	DI_Wr_reg_bits(DECOMB_WIND00, 0, 16, 13);/* dcomb x0 */
+	DI_Wr_reg_bits(DECOMB_WIND00, (width-1), 0, 13);/* dcomb x1 */
+	DI_Wr_reg_bits(DECOMB_WIND01, 0, 16, 13);/* dcomb y0 */
+	DI_Wr_reg_bits(DECOMB_WIND01, y1, 0, 13);/* dcomb y1 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND0_X, 0, 0, 13);/* pd22 x0 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND0_X, (width-1), 16, 13);/* pd22 x1 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND0_Y, 0, 0, 13);/* pd22 y0 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND0_Y, y1, 16, 13);/* pd y1 */
+
+	DI_Wr_reg_bits(DECOMB_WIND10, 0, 16, 13);/* dcomb x0 */
+	DI_Wr_reg_bits(DECOMB_WIND10, (width-1), 0, 13);/* dcomb x1 */
+	DI_Wr_reg_bits(DECOMB_WIND11, (y1+1), 16, 13);/* dcomb y0 */
+	DI_Wr_reg_bits(DECOMB_WIND11, y2, 0, 13);/* dcomb y1 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND1_X, 0, 0, 13);/* pd x0 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND1_X , (width-1), 16, 13);/* pd x1 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND1_Y, (y1+1), 0, 13);/* pd y0 */
+	DI_Wr_reg_bits(DECOMB_WIND11, y2, 16, 13);/* pd y1 */
+
+}
diff --git a/drivers/amlogic/deinterlace/dnr.c b/drivers/amlogic/deinterlace/dnr.c
index b3440ac..e0baa63 100644
--- a/drivers/amlogic/deinterlace/dnr.c
+++ b/drivers/amlogic/deinterlace/dnr.c
@@ -13,7 +13,7 @@ static bool dnr_pr;
 module_param(dnr_pr, bool, 0644);
 MODULE_PARM_DESC(dnr_pr, "/n print dnr debug information /n");
 
-static bool dnr_dm_en;/*gxtvbb can't work normal,must set to 0*/
+bool dnr_dm_en;/*gxtvbb can't work normal,must set to 0*/
 module_param(dnr_dm_en, bool, 0644);
 MODULE_PARM_DESC(dnr_dm_en, "/n dnr dm enable debug /n");
 
@@ -296,7 +296,8 @@ reg_dnr_stat_yst=0,reg_dnr_stat_yed=0; */
 	if (dnr_reg_update == 0)
 		return;
 	DI_Wr(DNR_CTRL, 0x1df00);
-	DI_Wr(DNR_DM_CTRL, Rd(DNR_DM_CTRL)|(dnr_dm_en << 9)|(1 << 11));
+	DI_Wr(DNR_DM_CTRL, Rd(DNR_DM_CTRL)|(1 << 11));
+	DI_Wr_reg_bits(DNR_DM_CTRL, dnr_dm_en, 9, 1);
 	DI_Wr(DNR_HVSIZE, nCol<<16|nRow);
 	DI_Wr(DNR_STAT_X_START_END, (((8*dnr_stat_coef)&0x3fff) << 16)
 		|((nCol-(8*dnr_stat_coef+1))&0x3fff));
diff --git a/drivers/amlogic/deinterlace/film_fw1.c b/drivers/amlogic/deinterlace/film_fw1.c
index 49d0790..1265911 100644
--- a/drivers/amlogic/deinterlace/film_fw1.c
+++ b/drivers/amlogic/deinterlace/film_fw1.c
@@ -40,6 +40,8 @@ UINT8 FlmVOFSftInt(struct sFlmSftPar *pPar)
 	pPar->sF32Dif02M0 = 4096;	/* mpeg-4096, cvbs-8192 */
 	pPar->sF32Dif02M1 = 4096;
 
+	field_count = 0;
+
 	return 0;
 }
 
@@ -172,6 +174,7 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 		 unsigned short *rPstCYWnd3, unsigned short *rPstCYWnd4,
 		 UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 		 UINT32 *rROFldDif01, UINT32 *rROFrmDif02, UINT32 *rROCmbInf,
+		 int *tTCNm,
 		 struct sFlmSftPar *pPar, int nROW, int nCOL)
 {
 	static UINT32 DIF01[HISDIFNUM]; /* Last one is global */
@@ -206,11 +209,11 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 	debug_str[0] = '\0';
 
 	/* Initialization */
-	if (field_count == 0) {
+	if (field_count < 3) {
 		for (nT1 = 0; nT1 < HISDIFNUM; nT1++) {
-			DIF01[nT1] = 0;
-			DIF02[nT1] = 0;
-			DifW5[nT1] = 0;
+			DIF01[nT1] = 0xffffffff;
+			DIF02[nT1] = 0xffffffff;
+			DifW5[nT1] = 0xffffffff;
 		}
 
 		for (nT1 = 0; nT1 < HISDETNUM; nT1++) {
@@ -234,7 +237,6 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 			pRDat.pFlgXx[nT1] = 0; /* pre-1, nxt-0 */
 			pRDat.pLvlXx[nT1] = 0;  /* mode level */
 		}
-		field_count = 1;
 	} else {
 		for (nT1 = 1; nT1 < HISDETNUM; nT1++) {
 			pRDat.mNum32[nT1 - 1] = pRDat.mNum32[nT1];
@@ -382,6 +384,7 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 		nS1 = pRDat.pLvlXx[HISDETNUM - 1 - mDly];
 	}
 
+	*tTCNm = pRDat.TCNm[HISCMBNUM - 1];
 	return nS1;
 }
 
diff --git a/drivers/amlogic/deinterlace/film_vof_soft.h b/drivers/amlogic/deinterlace/film_vof_soft.h
index b5b8dde..7c6d4a3 100644
--- a/drivers/amlogic/deinterlace/film_vof_soft.h
+++ b/drivers/amlogic/deinterlace/film_vof_soft.h
@@ -58,6 +58,8 @@ struct sFlmDatSt {
 	UINT8 pFlgXx[HISDETNUM]; /* pre-1, nxt-0 */
 	UINT8 pLvlXx[HISDETNUM]; /* mode level */
 
+	int TCNm[HISCMBNUM];/* history: the number of combing-rows */
+
 	UINT32 *rROFrmDif02;
 
 	/* size of the image */
@@ -132,6 +134,7 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, UShort *rPstCYWnd0, UShort *rPstCYWnd1,
 		 UShort *rPstCYWnd2, UShort *rPstCYWnd3, UShort *rPstCYWnd4,
 		 UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 		 UINT32 *rROFldDif01, UINT32 *rROFrmDif02, UINT32 *rROCmbInf,
+		 int *tTCNm,
 		 struct sFlmSftPar *pPar, int nROW, int nCOL);
 
 /* length of pFlm01/nDif01: [0:5]; */
diff --git a/drivers/amlogic/deinterlace/register.h b/drivers/amlogic/deinterlace/register.h
index ac64c02..f6b2bfa 100644
--- a/drivers/amlogic/deinterlace/register.h
+++ b/drivers/amlogic/deinterlace/register.h
@@ -29,6 +29,16 @@ force enable of the alpha for dejaggy2 */
 /* Bit 2: 0	sr2_dejaggy2_alpha_value,
   forced value of alpha for dejaggy2     */
 
+#define SRSHARP0_DEJ_CTRL             0x3264  /*<< 2) + 0xd0100000)*/
+/*Bit 31:4    reserved
+*Bit 3:2,    reg_sr3_dejaggy_sameside_prtct
+*u2:  enable of sr3 dejaggy same side curve protect from filter,
+*[0] for proc, [1] for ctrl path,  default=3
+*Bit 1,      reg_sr3_dejaggy_sameside_mode
+*u1: mode of the sameside flag decision: default =1
+*Bit 0,      reg_sr3_dejaggy_enable
+u1: enable of sr3 dejaggy: default =0*/
+
 #define SRSHARP0_SHARP_DEJ2_PRC     ((0x3261)) /* << 2) + 0xd0100000) */
 /* Bit 31:24,  reg_dejaggy2_hcon_thrd             : .
 unsigned, default =5,hcon threshold, only pixels with hcon equal or
@@ -278,6 +288,28 @@ meaning always */
 		/* 0xd0106818 */
 #define VIUB_MISC_CTRL0					0x2006
 		/* 0xd0108018 */
+/*txl new add begin*/
+#define DI_IF2_GEN_REG					0x2010
+#define DI_IF2_CANVAS0					0x2011
+#define DI_IF2_LUMA_X0					0x2012
+#define DI_IF2_LUMA_Y0					0x2013
+#define DI_IF2_CHROMA_X0				0x2014
+#define DI_IF2_CHROMA_Y0				0x2015
+#define DI_IF2_RPT_LOOP					0x2016
+#define DI_IF2_LUMA0_RPT_PAT			0x2017
+#define DI_IF2_CHROMA0_RPT_PAT			0x2018
+#define DI_IF2_DUMMY_PIXEL				0x2019
+#define DI_IF2_LUMA_FIFO_SIZE			0x201a
+#define DI_IF2_RANGE_MAP_Y				0x201b
+#define DI_IF2_RANGE_MAP_CB				0x201c
+#define DI_IF2_RANGE_MAP_CR				0x201d
+#define DI_IF2_GEN_REG2					0x201e
+#define DI_IF2_FMT_CTRL					0x201f
+#define DI_IF2_FMT_W					0x2020
+#define DI_IF2_URGENT_CTRL				0x2021
+#define DI_IF2_GEN_REG3					0x2022
+/*txl new add end*/
+
 /* di */
 #define DI_IF1_URGENT_CTRL                  (0x20a3)  /*  << 2 + 0xd0100000*/
 /* bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 ,
@@ -2207,20 +2239,54 @@ normally 0-16               . unsigned  , default = 1 */
 /* Bit 31: 0,        ro_dm_gms_stat_cnt  . unsigned  , default = 0 */
 #define DNR_RO_DM_GMS_STAT_MS                      ((0x2d78))
 /* Bit 31: 0,        ro_dm_gms_stat_ms  . unsigned  , default = 0 */
+/* txl added */
+#define DECOMB_DET_VERT_CON0				(0x2d80)
+#define DECOMB_DET_VERT_CON1				(0x2d81)
+#define DECOMB_DET_EDGE_CON0				(0x2d82)
+#define DECOMB_DET_EDGE_CON1				(0x2d83)
+#define DECOMB_PARA							(0x2d84)
+#define DECOMB_BLND_CON0					(0x2d85)
+#define DECOMB_BLND_CON1					(0x2d86)
+#define DECOMB_YC_THRD						(0x2d87)
+#define DECOMB_MTN_GAIN_OFST				(0x2d88)
+#define DECOMB_CMB_SEL_GAIN_OFST			(0x2d89)
+#define DECOMB_WIND00						(0x2d8a)
+#define DECOMB_WIND01						(0x2d8b)
+#define DECOMB_WIND10						(0x2d8c)
+#define DECOMB_WIND11						(0x2d8d)
+#define DECOMB_MODE							(0x2d8e)
+#define DECOMB_FRM_SIZE						(0x2d8f)
+#define DECOMB_HV_BLANK						(0x2d90)
+#define NR2_POLAR3_MODE						(0x2d98)
+#define NR2_POLAR3_THRD						(0x2d99)
+#define NR2_POLAR3_PARA0					(0x2d9a)
+#define NR2_POLAR3_PARA1					(0x2d9b)
+#define NR2_POLAR3_CTRL						(0x2d9c)
+#define NR2_RO_POLAR3_NUMOFPIX				(0x2d9d)
+#define NR2_RO_POLAR3_SMOOTHMV				(0x2d9e)
+#define NR2_RO_POLAR3_M1					(0x2d9f)
+#define NR2_RO_POLAR3_P1					(0x2da0)
+#define NR2_RO_POLAR3_M2					(0x2da1)
+#define NR2_RO_POLAR3_P2					(0x2da2)
+#define NR2_RO_POLAR3_32					(0x2da3)
+/* txl end */
 
 
+#define VPU_VD1_MMC_CTRL					(0x2703)
+#define VPU_VD2_MMC_CTRL					(0x2704)
+#define VPU_DI_IF1_MMC_CTRL					(0x2705)
+#define VPU_DI_MEM_MMC_CTRL					(0x2706)
+#define VPU_DI_INP_MMC_CTRL					(0x2707)
+#define VPU_DI_MTNRD_MMC_CTRL				(0x2708)
+#define VPU_DI_CHAN2_MMC_CTRL				(0x2709)
+#define VPU_DI_MTNWR_MMC_CTRL				(0x270a)
+#define VPU_DI_NRWR_MMC_CTRL				(0x270b)
+#define VPU_DI_DIWR_MMC_CTRL				(0x270c)
 
-#define VPU_VD1_MMC_CTRL				0x2703
-#define VPU_VD2_MMC_CTRL				0x2704
-#define VPU_DI_IF1_MMC_CTRL				0x2705
-#define VPU_DI_MEM_MMC_CTRL				0x2706
-#define VPU_DI_INP_MMC_CTRL				0x2707
-#define VPU_DI_MTNRD_MMC_CTRL			0x2708
-#define VPU_DI_CHAN2_MMC_CTRL			0x2709
-#define VPU_DI_MTNWR_MMC_CTRL			0x270a
-#define VPU_DI_NRWR_MMC_CTRL			0x270b
-#define VPU_DI_DIWR_MMC_CTRL			0x270c
-
+#define MCDI_PD_22_CHK_WND0_X				(0x2f59)
+#define MCDI_PD_22_CHK_WND0_Y				(0x2f5a)
+#define MCDI_PD_22_CHK_WND1_X				(0x2f5b)
+#define MCDI_PD_22_CHK_WND1_Y				(0x2f5c)
 /* mc di */
 /* //=================================================================//// */
 /* // memc di core 0 */
diff --git a/drivers/amlogic/deinterlace/tffbff_check.c b/drivers/amlogic/deinterlace/tffbff_check.c
new file mode 100644
index 0000000..7ee96df
--- /dev/null
+++ b/drivers/amlogic/deinterlace/tffbff_check.c
@@ -0,0 +1,210 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include "deinterlace.h"
+#include "register.h"
+
+/* define the lenght of history */
+#define TBFF_DLEN 20
+
+/* parameters */
+/* valid data: only pixel_num > size*rat >> 8 */
+/* u8: [0,255] */
+static int tbff_pixel_minnum = 16;
+
+/* x3 / row > rat */
+/* => x3 > (row * rat >> 5) */
+/* u10: [0 ~ 1023] => [0, 16] */
+static int tbff_x3_minrow = 64;
+
+/* m1/p1/m2/p2 changing 0/1/0/1... as 2-2 mode */
+/* (max)/ min > (rat): define it max, else min */
+/* u8: [0,31] */
+static int tbff_mp_lgrat[4] = {16, 16, 16, 16};
+
+/* tbff check length */
+/* [0, 31] */
+static int tbff_chk_len[4] = {4, 4, 4, 4};
+
+static int calc_tbff_pixel_minnum = 16;
+static int calc_tbff_x3_minrow = 64;
+static int calc_tbff_mp_lgrat[4] = {16, 16, 16, 16};
+
+static int nTmp0;
+static bool tbff_pr, tffbff_en = true;
+static int mode_count;
+
+void tbff_init(void)
+{
+	int i = 0;
+	mode_count = 0;
+	calc_tbff_pixel_minnum = tbff_pixel_minnum;
+	calc_tbff_x3_minrow = tbff_x3_minrow;
+	for (i = 0; i < 4; i++)
+		calc_tbff_mp_lgrat[i] = tbff_mp_lgrat[i];
+}
+static int tbff_get_rate(int t0, int t1)
+{
+	int nmax = t1;
+	int nmin = t0;
+	int nrst = 0;
+
+	if (t0 > t1) {
+		nmax = t0;
+		nmin = t1;
+	}
+
+	nrst = (8 * nmax) + (nmin >> 1);
+	nrst /= (nmin+1);
+	if (nrst > 31)
+		nrst = 31;
+
+	if (nmax == t1) /* current is small */
+		nrst = 0;
+
+	return nrst;
+}
+
+static int tbff_get_minrate(int *pLen)
+{
+	int iT0 = 0;
+	int aTLn[4] = {0, 0, 0, 0};
+	int nrst = 255;
+
+	int nP0 = pLen[TBFF_DLEN - 1];
+	int nP1 = pLen[TBFF_DLEN - 2];
+
+	if (nP0 < nP1) {
+		for (iT0 = 0; iT0 < 4; (iT0 += 2)) {
+			aTLn[iT0] = 31 - pLen[TBFF_DLEN - iT0 - 1];
+			aTLn[iT0 + 1] = pLen[TBFF_DLEN - iT0 - 2];
+		}
+	} else {
+		for (iT0 = 0; iT0 < 4; (iT0 += 2)) {
+			aTLn[iT0] = pLen[TBFF_DLEN - iT0 - 1];
+			aTLn[iT0 + 1] = 31 - pLen[TBFF_DLEN - iT0 - 2];
+		}
+	}
+
+	for (iT0 = 0; iT0 < 4; iT0++) {
+		if (aTLn[iT0] < nrst)
+			nrst = aTLn[iT0];
+	}
+
+	return nrst;
+}
+
+/* update param according to detection count */
+static void calc_tbff_param(int mode_cnt, int step_max)
+{
+	int delt_num, delt_row, delt_lgrat, i;
+
+	delt_num = tbff_pixel_minnum - 4;
+	delt_row = tbff_x3_minrow;
+	delt_lgrat = tbff_mp_lgrat[0] - 6;
+
+	calc_tbff_pixel_minnum =
+		tbff_pixel_minnum - (delt_num * mode_cnt)/step_max;
+	calc_tbff_x3_minrow = tbff_x3_minrow - (delt_row * mode_cnt)/step_max;
+	calc_tbff_mp_lgrat[0] =
+		tbff_mp_lgrat[0] - (delt_lgrat * mode_cnt)/step_max;
+
+	for (i = 1; i < 4; i++)
+		calc_tbff_mp_lgrat[i] = calc_tbff_mp_lgrat[0];
+}
+/* TFF / BFF error check */
+/* polar3[0]: num of pixels */
+/* polar3[1]: smooth motion vector */
+/* polar3[2]: m1 */
+/* polar3[3]: p1 */
+/* polar3[4]: m2 */
+/* polar3[5]: p2 */
+/* polar3[6]: x3 */
+
+int tff_bff_check(int nROW, int nCOL)
+{
+	int iT0 = 0, iT1 = 0, nTmp1 = 0;
+	int nTmp2 = 0, tbfalse = 0, nSIZE = nROW * nCOL;
+    /* int nMin0 = 0; */
+	unsigned int uTp0 = 0;
+
+	int polar3[7];
+     /* top/bot field first error */
+	static int pPolar3[7]; /* previous polar3 */
+	static int sDat[4][TBFF_DLEN]; /* history infor */
+	static unsigned int stc_pp3[4];
+	for (iT0 = 0; iT0 < 7; iT0++)
+		polar3[iT0] = Rd_reg_bits(NR2_RO_POLAR3_NUMOFPIX+iT0, 0, 24);
+
+	if (tbff_pr)
+		pr_info("polar3=%8d %8d %8d %8d %8d %8d %8d.\n",
+				polar3[0], polar3[1], polar3[2], polar3[3],
+				polar3[4], polar3[5], polar3[6]);
+	/* history */
+	for (iT0 = 0; iT0 < 4; iT0++) {
+		for (iT1 = 0; iT1 < (TBFF_DLEN - 1); iT1++)
+			sDat[iT0][iT1] = sDat[iT0][iT1 + 1];
+
+		stc_pp3[iT0] = (stc_pp3[iT0] << 1);
+		sDat[iT0][TBFF_DLEN - 1] = 0;
+	}
+
+	/* only valid pixel is enough */
+	nTmp0 = ((nSIZE * calc_tbff_pixel_minnum + 128) >> 8);
+	if (polar3[0] > nTmp0) {
+		/* only x3 pixel is enough */
+		nTmp1 = ((nROW * calc_tbff_x3_minrow + 16) >> 5);
+		if (polar3[6] > nTmp1) {
+			/* nMin0 = 255; */
+			for (iT1 = 0; iT1 < 4; iT1++) {
+				nTmp2 =
+			tbff_get_rate(polar3[iT1 + 2], pPolar3[iT1 + 2]);
+				sDat[iT1][TBFF_DLEN - 1] = nTmp2;
+			}
+		}
+	}
+
+	for (iT1 = 0; iT1 < 4; iT1++) {
+		nTmp2 = tbff_get_minrate(sDat[iT1]);
+		if (nTmp2 >= calc_tbff_mp_lgrat[iT1])
+			stc_pp3[iT1] |= 0x1;
+	}
+
+	for (iT1 = 0; iT1 < 4; iT1++) {
+		uTp0 = stc_pp3[iT1];
+		nTmp0 = 0;
+		for (iT0 = 0; iT0 < 31; iT0++) {
+			if (uTp0 & 0x1)
+				nTmp0++;
+			else
+				break;
+			uTp0 = (uTp0 >> 1);
+		}
+
+		if (nTmp0 >= tbff_chk_len[iT1])
+			tbfalse += 1;
+	}
+
+	/* m1/p1/m2/p2 all 2-2 mode */
+	/* return (tbfalse==4); */
+	nTmp0 = (tbfalse == 4);
+
+	if (nTmp0 == 1)
+		nTmp0 += (polar3[2] < pPolar3[2]);
+	if (nTmp0 != 0)
+		mode_count = mode_count > 32 ? 32 : (mode_count+1);
+	else
+		mode_count = mode_count > 0 ? (mode_count-1) : 0;
+	calc_tbff_param(mode_count, 32);
+	for (iT0 = 0; iT0 < 7; iT0++)
+		pPolar3[iT0] = polar3[iT0];
+	if (tbff_pr)
+		pr_info("num %d, x3 %d, lgrat %d, result is %d.\n",
+			calc_tbff_pixel_minnum, calc_tbff_x3_minrow,
+			calc_tbff_mp_lgrat[0], nTmp0);
+
+	return tffbff_en?nTmp0:0;
+}
+module_param_named(tffbff_en, tffbff_en, bool, 0664);
+module_param_named(tbff_pixel_minnum, tbff_pixel_minnum, int, 0664);
+module_param_named(tbff_x3_minrow, tbff_x3_minrow, int, 0664);
+module_param_named(tbff_pr, tbff_pr, bool, 0664);
diff --git a/drivers/amlogic/deinterlace/vof_soft_top.c b/drivers/amlogic/deinterlace/vof_soft_top.c
index 7b83ffd..6a1b65c 100644
--- a/drivers/amlogic/deinterlace/vof_soft_top.c
+++ b/drivers/amlogic/deinterlace/vof_soft_top.c
@@ -79,7 +79,8 @@ int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 	int mDly = pPar->mPstDlyPre;
 
 	/* UINT8 *PREWV = pRDat.pFlg32; or pRDat.pFlg22 */
-	static int TCNm[HISCMBNUM];/* history: the number of combing-rows */
+	/* static int TCNm[HISCMBNUM]; history: the number of combing-rows */
+	int *TCNm = pRDat->TCNm;
 	static int NWND[HISDETNUM];/* 6-history,the number of combing windows */
 	static int WGlb[HISDETNUM];	/* Global combing */
 	static unsigned int pFlgXx;
diff --git a/drivers/amlogic/display/backlight/aml_bl.c b/drivers/amlogic/display/backlight/aml_bl.c
index 6c77e06..0524242 100644
--- a/drivers/amlogic/display/backlight/aml_bl.c
+++ b/drivers/amlogic/display/backlight/aml_bl.c
@@ -63,6 +63,7 @@ static unsigned int bl_off_policy;
 module_param(bl_off_policy, uint, 0664);
 MODULE_PARM_DESC(bl_off_policy, "bl_off_policy");
 
+static unsigned int bl_level_uboot;
 static unsigned int brightness_bypass;
 module_param(brightness_bypass, uint, 0664);
 MODULE_PARM_DESC(brightness_bypass, "bl_brightness_bypass");
@@ -217,6 +218,9 @@ static int aml_bl_check_driver(void)
 			BLERR("no bl_pwm_combo_1 struct\n");
 		}
 		break;
+	case BL_CTRL_MAX:
+		ret = -1;
+		break;
 	default:
 		break;
 	}
@@ -1312,6 +1316,11 @@ static void aml_bl_config_print(struct bl_config_s *bconf)
 {
 	struct bl_pwm_config_s *bl_pwm;
 
+	if (bconf->method == BL_CTRL_MAX) {
+		BLPR("no backlight exist\n");
+		return;
+	}
+
 	BLPR("name              = %s\n", bconf->name);
 	BLPR("method            = %s(%d)\n",
 		bl_method_type_to_str(bconf->method), bconf->method);
@@ -1469,6 +1478,10 @@ static int aml_bl_config_load_from_dts(struct bl_config_s *bconf,
 	aml_lcd_notifier_call_chain(LCD_EVENT_BACKLIGHT_SEL, &index);
 #endif
 	bl_drv->index = index;
+	if (bl_drv->index == 0xff) {
+		bconf->method = BL_CTRL_MAX;
+		return -1;
+	}
 	sprintf(bl_propname, "backlight_%d", index);
 	BLPR("load: %s\n", bl_propname);
 	child = of_get_child_by_name(pdev->dev.of_node, bl_propname);
@@ -1488,8 +1501,10 @@ static int aml_bl_config_load_from_dts(struct bl_config_s *bconf,
 		&bl_para[0], 2);
 	if (ret) {
 		BLERR("failed to get bl_level_default_uboot_kernel\n");
+		bl_level_uboot = BL_LEVEL_DEFAULT;
 		bconf->level_default = BL_LEVEL_DEFAULT;
 	} else {
+		bl_level_uboot = bl_para[0];
 		bconf->level_default = bl_para[1];
 	}
 	ret = of_property_read_u32_array(child, "bl_level_attr",
@@ -1822,6 +1837,7 @@ static int aml_bl_config_load_from_unifykey(struct bl_config_s *bconf)
 	p += LCD_UKEY_BL_NAME;
 
 	/* level: 6byte */
+	bl_level_uboot = (*p | ((*(p + 1)) << 8));
 	p += LCD_UKEY_BL_LEVEL_UBOOT;
 	bconf->level_default = (*p | ((*(p + 1)) << 8));
 	p += LCD_UKEY_BL_LEVEL_KERNEL;  /* dummy pointer */
@@ -2044,7 +2060,7 @@ static int aml_bl_config_load_from_unifykey(struct bl_config_s *bconf)
 	return 0;
 }
 
-static void aml_bl_config_load(struct bl_config_s *bconf,
+static int aml_bl_config_load(struct bl_config_s *bconf,
 		struct platform_device *pdev)
 {
 	int load_id = 0;
@@ -2052,7 +2068,7 @@ static void aml_bl_config_load(struct bl_config_s *bconf,
 
 	if (pdev->dev.of_node == NULL) {
 		BLERR("no backlight of_node exist\n");
-		return;
+		return -1;
 	}
 	ret = of_property_read_u32(pdev->dev.of_node,
 			"key_valid", &bl_key_valid);
@@ -2073,12 +2089,12 @@ static void aml_bl_config_load(struct bl_config_s *bconf,
 	if (load_id) {
 		BLPR("%s from unifykey\n", __func__);
 		bl_config_load = 1;
-		aml_bl_config_load_from_unifykey(bconf);
+		ret = aml_bl_config_load_from_unifykey(bconf);
 	} else {
 #ifdef CONFIG_OF
 		BLPR("%s from dts\n", __func__);
 		bl_config_load = 0;
-		aml_bl_config_load_from_dts(bconf, pdev);
+		ret = aml_bl_config_load_from_dts(bconf, pdev);
 #endif
 	}
 	aml_bl_pinmux_load(bconf);
@@ -2093,6 +2109,7 @@ static void aml_bl_config_load(struct bl_config_s *bconf,
 	default:
 		break;
 	}
+	return ret;
 }
 
 /* ****************************************
@@ -2191,6 +2208,9 @@ static int aml_bl_lcd_update_notifier(struct notifier_block *nb,
 		unsigned long event, void *data)
 {
 	struct bl_pwm_config_s *bl_pwm = NULL;
+#ifdef CONFIG_AML_LOCAL_DIMMING
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+#endif
 
 	/* If we aren't interested in this event, skip it immediately */
 	if (event != LCD_EVENT_BACKLIGHT_UPDATE)
@@ -2202,25 +2222,39 @@ static int aml_bl_lcd_update_notifier(struct notifier_block *nb,
 		BLPR("bl_lcd_update_notifier for pwm_vs\n");
 	switch (bl_drv->bconf->method) {
 	case BL_CTRL_PWM:
-		if (bl_drv->bconf->bl_pwm->pwm_port == BL_PWM_VS)
+		if (bl_drv->bconf->bl_pwm->pwm_port == BL_PWM_VS) {
 			bl_pwm = bl_drv->bconf->bl_pwm;
+			if (bl_pwm) {
+				bl_pwm_config_init(bl_pwm);
+				if (brightness_bypass)
+					bl_set_duty_pwm(bl_pwm);
+				else
+					aml_bl_update_status(bl_drv->bldev);
+			}
+		}
 		break;
 	case BL_CTRL_PWM_COMBO:
 		if (bl_drv->bconf->bl_pwm_combo0->pwm_port == BL_PWM_VS)
 			bl_pwm = bl_drv->bconf->bl_pwm_combo0;
 		else if (bl_drv->bconf->bl_pwm_combo1->pwm_port == BL_PWM_VS)
 			bl_pwm = bl_drv->bconf->bl_pwm_combo1;
+		if (bl_pwm) {
+			bl_pwm_config_init(bl_pwm);
+			if (brightness_bypass)
+				bl_set_duty_pwm(bl_pwm);
+			else
+				aml_bl_update_status(bl_drv->bldev);
+		}
 		break;
-	default:
+#ifdef CONFIG_AML_LOCAL_DIMMING
+	case BL_CTRL_LOCAL_DIMING:
+		if (ldim_drv->pwm_vs_update)
+			ldim_drv->pwm_vs_update();
 		break;
-	}
+#endif
 
-	if (bl_pwm) {
-		bl_pwm_config_init(bl_pwm);
-		if (brightness_bypass)
-			bl_set_duty_pwm(bl_pwm);
-		else
-			aml_bl_update_status(bl_drv->bldev);
+	default:
+		break;
 	}
 
 	return NOTIFY_OK;
@@ -2312,6 +2346,7 @@ static ssize_t bl_status_read(struct class *class,
 		"name:               %s\n"
 		"state:              0x%x\n"
 		"level:              %d\n"
+		"level_uboot:        %d\n"
 		"brightness_bypass:  %d\n\n"
 		"level_max:          %d\n"
 		"level_min:          %d\n"
@@ -2325,7 +2360,7 @@ static ssize_t bl_status_read(struct class *class,
 		"power_off_delay:    %d\n\n",
 		bl_key_valid, bl_config_load,
 		bl_drv->index, bconf->name, bl_drv->state,
-		bl_drv->level, brightness_bypass,
+		bl_drv->level,  bl_level_uboot, brightness_bypass,
 		bconf->level_max, bconf->level_min,
 		bconf->level_mid, bconf->level_mid_mapping,
 		bl_method_type_to_str(bconf->method),
@@ -2804,7 +2839,9 @@ static int aml_bl_probe(struct platform_device *pdev)
 	bconf = &bl_config;
 	bl_drv->dev = &pdev->dev;
 	bl_drv->bconf = bconf;
-	aml_bl_config_load(bconf, pdev);
+	ret = aml_bl_config_load(bconf, pdev);
+	if (ret)
+		goto err;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
@@ -2849,7 +2886,11 @@ static int aml_bl_probe(struct platform_device *pdev)
 	/* update bl status */
 	bl_drv->state = (BL_STATE_LCD_ON |
 			BL_STATE_BL_POWER_ON | BL_STATE_BL_ON);
-	aml_bl_update_status(bl_drv->bldev);
+
+	if (brightness_bypass)
+		aml_bl_set_level(bl_level_uboot);
+	else
+		aml_bl_update_status(bl_drv->bldev);
 
 	BLPR("probe OK\n");
 	return 0;
diff --git a/drivers/amlogic/display/backlight/aml_ldim/Makefile b/drivers/amlogic/display/backlight/aml_ldim/Makefile
index 59da02b..fb8ca40 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/Makefile
+++ b/drivers/amlogic/display/backlight/aml_ldim/Makefile
@@ -1,6 +1,6 @@
 #
 # Makefile for LDIM.
 #
-obj-$(CONFIG_AML_LOCAL_DIMMING) = aml_ldim.o ldim_dev_drv.o iw7019_bl.o iw7019_lpf.o
+obj-$(CONFIG_AML_LOCAL_DIMMING) = aml_ldim.o ldim_dev_drv.o iw7019_bl.o iw7019_lpf.o ob3350_bl.o
 aml_ldim-objs := ldim_drv.o ldim_func.o
 
diff --git a/drivers/amlogic/display/backlight/aml_ldim/iw7019_bl.c b/drivers/amlogic/display/backlight/aml_ldim/iw7019_bl.c
index 52d7306..1ead7b2 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/iw7019_bl.c
+++ b/drivers/amlogic/display/backlight/aml_ldim/iw7019_bl.c
@@ -56,12 +56,17 @@
 #define IW7019_POWER_RESET    1
 static int iw7019_on_flag;
 static int iw7019_spi_op_flag;
+static int iw7019_wr_err_cnt;
 static int iw7019_spi_err_flag;
 static int iw7019_spi_force_err_flag;
+static unsigned char iw7019_chipid_check_vs_cnt;
 static unsigned short vsync_cnt;
 static unsigned short fault_cnt;
+static unsigned short check_id_cnt;
 static unsigned long reset_cnt;
 static int iw7019_spi_rw_test_flag;
+static int iw7019_static_pic_test_flag;
+static int iw7019_static_pic_test_count;
 
 static spinlock_t iw7019_spi_lock;
 static struct workqueue_struct  *iw7019_workqueue;
@@ -75,7 +80,6 @@ struct iw7019 {
 	unsigned char cmd_size;
 	unsigned char *init_data;
 	struct class cls;
-	unsigned char cur_addr;
 };
 struct iw7019 *bl_iw7019;
 
@@ -197,6 +201,7 @@ static unsigned char iw7019_ini_data[LDIM_SPI_INIT_ON_SIZE] = {
 static int test_brightness[] = {
 	0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff
 };
+static unsigned char static_pic_val[13];
 
 static int iw7019_rreg(struct spi_device *spi, u8 addr, u8 *val)
 {
@@ -308,7 +313,9 @@ iw7019_power_reset_p:
 			mdelay(bl_iw7019->init_data[i+3]);
 	}
 
+	iw7019_wr_err_cnt = 0;
 	iw7019_spi_err_flag = 0;
+	iw7019_chipid_check_vs_cnt = 0;
 	if (flag == IW7019_POWER_RESET)
 		return ret;
 
@@ -323,7 +330,8 @@ static int iw7019_hw_init_on(void)
 	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
 		ldim_drv->ldev_conf->en_gpio_on);
 	mdelay(2);
-	ldim_drv->pinmux_ctrl(1);
+	ldim_set_duty_pwm(&(ldim_drv->ldev_conf->pwm_config));
+	ldim_drv->pinmux_ctrl(ldim_drv->ldev_conf->pinmux_name, 1);
 	mdelay(100);
 	iw7019_power_on_init(IW7019_POWER_ON);
 
@@ -342,7 +350,7 @@ static int iw7019_hw_init_off(void)
 	if (iw7019_spi_op_flag == 1)
 		LDIMERR("%s: wait spi idle state failed\n", __func__);
 
-	ldim_drv->pinmux_ctrl(0);
+	ldim_drv->pinmux_ctrl(ldim_drv->ldev_conf->pinmux_name, 0);
 	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
 		ldim_drv->ldev_conf->en_gpio_off);
 
@@ -449,32 +457,45 @@ static void iw7019_spi_rw_test(struct work_struct *work)
 		spi_rw_test_en, iw7019_spi_rw_test_flag);
 }
 
-static void iw7019_spi_dump(void)
+static int iw7019_spi_dump(char *buf)
 {
+	int ret = 0;
 	unsigned char i, val;
 
 	for (i = 0; i <= 0x7f; i++) {
 		iw7019_rreg(bl_iw7019->spi, i, &val);
+		if (buf) {
+			int n = sprintf(buf+ret,
+					"iw7019 reg 0x%02x=0x%02x\n", i, val);
+			ret += n;
+		}
 		pr_info("iw7019 reg 0x%02x=0x%02x\n", i, val);
 	}
+	if (buf)
+		ret += sprintf(buf, "\n");
 	pr_info("\n");
+
+	return ret;
 }
 
 static int fault_cnt_save;
-static void iw7019_fault_handler(void)
+static int iw7019_fault_handler(void)
 {
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 	unsigned int val;
+	int ret = 0;
 
 	if (fault_cnt >= 35) {
 		if (ldim_debug_print >= 2) {
 			LDIMPR("%s: bypass fault check, fault_cnt=%d\n",
 				__func__, fault_cnt);
 		}
-		return;
+		return 0;
+	} else if (fault_cnt == 1) {
+		vsync_cnt = 0;
 	}
 
-	if (vsync_cnt >= 320) {
+	if (vsync_cnt >= 200) {
 		if (ldim_debug_print) {
 			LDIMPR("%s: vsync_cnt=%d, fault_cnt=%d\n",
 				__func__, vsync_cnt, fault_cnt);
@@ -496,13 +517,17 @@ static void iw7019_fault_handler(void)
 		fault_cnt++;
 		if (fault_cnt <= 35) {
 			if (ldim_debug_print) {
-				LDIMPR("%s: fault detected\n", __func__);
+				LDIMPR("%s: fault detected fault_cnt %d\n",
+					__func__, fault_cnt);
 				if (ldim_debug_print >= 2)
-					iw7019_spi_dump();
+					iw7019_spi_dump(NULL);
 			}
 			iw7019_wreg(bl_iw7019->spi, 0x35, 0x43);
+			ret = -1;
 		}
 	}
+
+	return ret;
 }
 
 static int iw7019_reset_handler(void)
@@ -523,6 +548,24 @@ static int iw7019_reset_handler(void)
 	return 0;
 }
 
+static int iw7019_short_reset_handler(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	/* disable BL_ON once */
+	LDIMPR("short reset iw7019 BL_ON\n");
+	reset_cnt++;
+	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
+		ldim_drv->ldev_conf->en_gpio_off);
+	mdelay(300);
+	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
+		ldim_drv->ldev_conf->en_gpio_on);
+	mdelay(2);
+	iw7019_power_on_init(IW7019_POWER_RESET);
+
+	return 0;
+}
+
 static unsigned int iw7019_get_value(unsigned int level)
 {
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
@@ -541,10 +584,12 @@ static int iw7019_smr(unsigned short *buf, unsigned char len)
 {
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 	int i, j, offset, cmd_len;
+	unsigned int value_flag = 0;
 	unsigned char val[13];
 	unsigned int br0, br1;
 	unsigned char bri_reg;
-	unsigned char temp, reg_chk, clk_sel;
+	unsigned char temp, reg_chk, clk_sel, wr_err_flag = 0;
+	int static_pic_err_flag = 0;
 
 	if (iw7019_spi_rw_test_flag)
 		return 0;
@@ -583,47 +628,85 @@ static int iw7019_smr(unsigned short *buf, unsigned char len)
 		cmd_len = 12;
 		bri_reg = IW7019_REG_BRIGHTNESS;
 	}
-	for (i = 0; i < 4; i++) {
-		if (bl_iw7019->test_mode) {
-			br0 = test_brightness[i*2+0];
-			br1 = test_brightness[i*2+1];
-		} else {
-			br0 = iw7019_get_value(buf[i*2+0]);
-			br1 = iw7019_get_value(buf[i*2+1]);
+
+	for (i = 0; i < 8; i++)
+		value_flag = value_flag || buf[i];
+
+	if (value_flag) {
+		for (i = 0; i < 4; i++) {
+			if (bl_iw7019->test_mode) {
+				br0 = test_brightness[i*2+0];
+				br1 = test_brightness[i*2+1];
+			} else {
+				br0 = iw7019_get_value(buf[i*2+0]);
+				br1 = iw7019_get_value(buf[i*2+1]);
+			}
+			/* br0[11~4] */
+			val[i*3 + offset] = (br0 >> 4) & 0xff;
+			/* br0[3~0]|br1[11~8] */
+			val[i*3 + offset + 1] = ((br0 & 0xf) << 4) |
+					((br1 >> 8) & 0xf);
+			/* br1[7~0] */
+			val[i*3 + offset + 2] = br1 & 0xff;
 		}
-		/* br0[11~4] */
-		val[i*3 + offset] = (br0 >> 4) & 0xff;
-		/* br0[3~0]|br1[11~8] */
-		val[i*3 + offset + 1] = ((br0 & 0xf) << 4) | ((br1 >> 8) & 0xf);
-		/* br1[7~0] */
-		val[i*3 + offset + 2] = br1 & 0xff;
+	} else {
+		for (i = 0; i < 12; i++)
+			val[i + offset] = 0;
 	}
 	iw7019_wregs(bl_iw7019->spi, bri_reg, val, cmd_len);
 
+	if (iw7019_static_pic_test_flag == 1) {
+		if (iw7019_static_pic_test_count == 1) {
+			for (i = 0; i < 13; i++)
+				static_pic_val[i] = val[i];
+			iw7019_static_pic_test_count = 0;
+		}
+		for (j = 0x01; j <= 0x0c; j++) {
+			iw7019_rreg(bl_iw7019->spi, j, &reg_chk);
+			if (static_pic_val[j] == reg_chk) {
+				ldim_drv->static_pic_flag = 0;
+				break;
+			} else if (val[j] != static_pic_val[j]) {
+				LDIMERR(
+			"wr_val 0x%02x=0x%02x, static_pic_val=0x%02x\n",
+			j, val[j], static_pic_val[j]);
+				static_pic_err_flag = 1;
+			} else {
+				LDIMERR(
+			"rd_val 0x%02x=0x%02x, static_pic_val=0x%02x\n",
+			j, reg_chk, static_pic_val[j]);
+					ldim_drv->static_pic_flag = 0;
+			}
+			if (j == 0x0c && static_pic_err_flag == 1)
+				ldim_drv->static_pic_flag = 1;
+		}
+	}
+
 	if (ldim_drv->ldev_conf->write_check) { /* brightness write check */
 		/* reg 0x00 check */
 		iw7019_rreg(bl_iw7019->spi, 0x00, &reg_chk);
 		for (i = 1; i < 3; i++) {
 			iw7019_rreg(bl_iw7019->spi, 0x00, &temp);
 			if (temp != reg_chk)
-				goto iw7019_smr_write_chk2;
+				goto iw7019_smr_end;
 		}
 		clk_sel = (reg_chk >> 1) & 0x3;
 		if ((reg_chk == 0xff) || (clk_sel == 0x1) || (clk_sel == 0x2) ||
 			(iw7019_spi_force_err_flag > 0)) {
 			iw7019_spi_err_flag = 1;
 			iw7019_spi_force_err_flag = 0;
-			LDIMERR("%s: spi write failed, 0x00=0x%02x\n",
+			LDIMERR("%s: reg check failed, 0x00=0x%02x\n",
 				__func__, reg_chk);
 			iw7019_reset_handler();
 			goto iw7019_smr_end;
 		}
-iw7019_smr_write_chk2:
+/*iw7019_smr_write_chk2:*/
 		/* reg brightness check */
 		for (j = 0x01; j <= 0x0c; j++) {
 			for (i = 1; i < 3; i++) {
 				iw7019_rreg(bl_iw7019->spi, j, &reg_chk);
 				if (val[j] == reg_chk) {
+					wr_err_flag = 0;
 					break;
 				} else {
 					LDIMERR("%s: brightness write failed\n",
@@ -631,8 +714,16 @@ iw7019_smr_write_chk2:
 					LDIMERR("0x%02x=0x%02x, w_val=0x%02x\n",
 						j, reg_chk, val[j]);
 					iw7019_wreg(bl_iw7019->spi, j, val[j]);
+					wr_err_flag = 1;
 				}
 			}
+			if (wr_err_flag)
+				iw7019_wr_err_cnt++;
+		}
+		if (iw7019_wr_err_cnt >= 60) {
+			LDIMERR("%s: spi write failed\n", __func__);
+			iw7019_short_reset_handler();
+			goto iw7019_smr_end;
 		}
 	}
 	if (ldim_drv->ldev_conf->fault_check) {
@@ -646,6 +737,71 @@ iw7019_smr_end:
 	return 0;
 }
 
+static int iw7019_chip_check(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	int ret = 0;
+	unsigned char chipid = 0;
+	/**/
+	if (ldim_drv->ldev_conf->fault_check) {
+		if (ldim_drv->ldev_conf->lamp_err_gpio >= BL_GPIO_NUM_MAX)
+			goto iw7019_chip_check_end;
+		ret = iw7019_fault_handler();
+	}
+	if (iw7019_chipid_check_vs_cnt++ > 5)
+		iw7019_chipid_check_vs_cnt = 0;
+	else
+		return 0;
+
+	if (iw7019_spi_rw_test_flag)
+		return 0;
+	if (iw7019_on_flag == 0) {
+		if (ldim_debug_print)
+			LDIMPR("%s: on_flag=%d\n", __func__, iw7019_on_flag);
+		return 0;
+	}
+	if (iw7019_spi_err_flag) {
+		if (ldim_debug_print) {
+			LDIMPR("%s: spi_err_flag=%d\n",
+				__func__, iw7019_spi_err_flag);
+		}
+		return 0;
+	}
+	if (iw7019_spi_op_flag) {
+		if (ldim_debug_print) {
+			LDIMPR("%s: spi_op_flag=%d\n",
+				__func__, iw7019_spi_op_flag);
+		}
+		return 0;
+	}
+
+	iw7019_spi_op_flag = 1;
+
+	if (ldim_drv->ldev_conf->write_check) {
+		iw7019_rreg(bl_iw7019->spi, IW7019_REG_CHIPID, &chipid);
+		if (chipid != IW7019_CHIPID) {
+			if (check_id_cnt >= 3) {
+				iw7019_spi_err_flag = 1;
+				LDIMERR("%s: read failed, 0x7f=0x%02x\n",
+					__func__, chipid);
+				LDIMPR("check_id_cnt=%d\n", check_id_cnt);
+				iw7019_short_reset_handler();
+				ret = -1;
+				check_id_cnt = 0;
+				goto iw7019_chip_check_end;
+			} else {
+				check_id_cnt++;
+			}
+		}
+	}
+
+
+iw7019_chip_check_end:
+	iw7019_spi_op_flag = 0;
+
+	return ret;
+}
+
 static int iw7019_power_on(void)
 {
 	if (iw7019_on_flag) {
@@ -674,21 +830,15 @@ static ssize_t iw7019_show(struct class *class,
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 	struct iw7019 *bl = container_of(class, struct iw7019, cls);
 	int ret = 0;
-	u8 val = 0;
 	int i;
 
-	if (!strcmp(attr->attr.name, "cur_addr"))
-		ret = sprintf(buf, "0x%02x\n", bl->cur_addr);
-	else if (!strcmp(attr->attr.name, "mode"))
+	if (!strcmp(attr->attr.name, "mode")) {
 		ret = sprintf(buf, "0x%02x\n", bl->spi->mode);
-	else if (!strcmp(attr->attr.name, "speed"))
+	} else if (!strcmp(attr->attr.name, "speed")) {
 		ret = sprintf(buf, "%d\n", bl->spi->max_speed_hz);
-	else if (!strcmp(attr->attr.name, "reg")) {
-		iw7019_rreg(bl->spi, bl->cur_addr, &val);
-		ret = sprintf(buf, "0x%02x\n", val);
-	} else if (!strcmp(attr->attr.name, "test"))
+	} else if (!strcmp(attr->attr.name, "test")) {
 		ret = sprintf(buf, "test mode=%d\n", bl->test_mode);
-	else if (!strcmp(attr->attr.name, "brightness")) {
+	} else if (!strcmp(attr->attr.name, "brightness")) {
 		ret = sprintf(buf, "0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x\n",
 				test_brightness[0],
 				test_brightness[1],
@@ -739,12 +889,12 @@ static ssize_t iw7019_show(struct class *class,
 		}
 		if (iw7019_spi_op_flag == 0) {
 			iw7019_spi_op_flag = 1;
-			iw7019_spi_dump();
+			ret = iw7019_spi_dump(buf);
 			iw7019_spi_op_flag = 0;
 		} else {
 			LDIMERR("%s: wait spi idle state failed\n", __func__);
 		}
-		ret = sprintf(buf, "\n");
+		ret += sprintf(buf, "\n");
 	} else if (!strcmp(attr->attr.name, "fault_cnt")) {
 		ret = sprintf(buf, "iw7019 fault_cnt = %d\n", fault_cnt);
 	} else if (!strcmp(attr->attr.name, "rw_test")) {
@@ -768,23 +918,44 @@ static ssize_t iw7019_store(struct class *class,
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 	struct iw7019 *bl = container_of(class, struct iw7019, cls);
 	unsigned int val, val2;
+	unsigned char reg_addr, reg_val;
 	int i;
 
-	if (!strcmp(attr->attr.name, "init"))
+	if (!strcmp(attr->attr.name, "init")) {
 		iw7019_hw_init_on();
-	else if (!strcmp(attr->attr.name, "cur_addr")) {
-		val = kstrtol(buf, 16, NULL);
-		bl->cur_addr = val;
 	} else if (!strcmp(attr->attr.name, "mode")) {
-		val = kstrtol(buf, 16, NULL);
-		bl->spi->mode = val;
+		i = sscanf(buf, "%d", &val);
+		if (i == 1)
+			bl->spi->mode = val;
+		else
+			LDIMERR("%s: invalid args\n", __func__);
 	} else if (!strcmp(attr->attr.name, "speed")) {
-		val = kstrtol(buf, 16, NULL);
-		bl->spi->max_speed_hz = val*1000;
+		i = sscanf(buf, "%d", &val);
+		if (i == 1)
+			bl->spi->max_speed_hz = val*1000;
+		else
+			LDIMERR("%s: invalid args\n", __func__);
 	} else if (!strcmp(attr->attr.name, "reg")) {
-		val = kstrtol(buf, 16, NULL);
-		iw7019_wreg(bl->spi, bl->cur_addr, val);
-		bl->cur_addr++;
+		if (buf[0] == 'w') {
+			i = sscanf(buf, "w %x %x", &val, &val2);
+			if (i == 2) {
+				reg_addr = (unsigned char)val;
+				reg_val = (unsigned char)val2;
+				iw7019_wreg(bl->spi, reg_addr, reg_val);
+			} else {
+				LDIMERR("%s: invalid args\n", __func__);
+			}
+		} else if (buf[0] == 'r') {
+			i = sscanf(buf, "r %x", &val);
+			if (i == 1) {
+				reg_addr = (unsigned char)val;
+				iw7019_rreg(bl->spi, reg_addr, &reg_val);
+				pr_info("reg 0x%02x = 0x%02x\n",
+					reg_addr, reg_val);
+			} else {
+				LDIMERR("%s: invalid args\n", __func__);
+			}
+		}
 	} else if (!strcmp(attr->attr.name, "test")) {
 		i = sscanf(buf, "%d", &val);
 		LDIMPR("set test mode to %d\n", val);
@@ -835,6 +1006,18 @@ static ssize_t iw7019_store(struct class *class,
 		} else {
 			spi_rw_test_en = 0;
 		}
+	} else if (!strcmp(attr->attr.name, "static_test")) {
+		i = sscanf(buf, "%d", &val);
+		if (val &&  bl_iw7019->test_mode == 0) {
+			iw7019_static_pic_test_flag = 1;
+			iw7019_static_pic_test_count = 1;
+			LDIMPR("static_test is already running\n");
+		} else {
+			if (bl_iw7019->test_mode)
+				LDIMERR("test mode open,please close it!\n");
+			iw7019_static_pic_test_flag = 0;
+			iw7019_static_pic_test_count = 0;
+		}
 	} else
 		LDIMERR("LDIM argment error!\n");
 	return count;
@@ -842,7 +1025,6 @@ static ssize_t iw7019_store(struct class *class,
 
 static struct class_attribute iw7019_class_attrs[] = {
 	__ATTR(init, S_IRUGO | S_IWUSR, iw7019_show, iw7019_store),
-	__ATTR(cur_addr, S_IRUGO | S_IWUSR, iw7019_show, iw7019_store),
 	__ATTR(mode, S_IRUGO | S_IWUSR, iw7019_show, iw7019_store),
 	__ATTR(speed, S_IRUGO | S_IWUSR, iw7019_show, iw7019_store),
 	__ATTR(reg, S_IRUGO | S_IWUSR, iw7019_show, iw7019_store),
@@ -856,6 +1038,7 @@ static struct class_attribute iw7019_class_attrs[] = {
 	__ATTR(reset, S_IRUGO | S_IWUSR, NULL, iw7019_store),
 	__ATTR(dump, S_IRUGO | S_IWUSR, iw7019_show, NULL),
 	__ATTR(rw_test, S_IRUGO | S_IWUSR, iw7019_show, iw7019_store),
+	__ATTR(static_test, S_IRUGO | S_IWUSR, iw7019_show, iw7019_store),
 	__ATTR_NULL
 };
 
@@ -866,9 +1049,44 @@ static int iw7019_ldim_driver_update(void)
 	ldim_drv->device_power_on = iw7019_power_on;
 	ldim_drv->device_power_off = iw7019_power_off;
 	ldim_drv->device_bri_update = iw7019_smr;
+	ldim_drv->device_bri_check = iw7019_chip_check;
+	return 0;
+}
+
+static int ldim_spi_dev_probe(struct spi_device *spi)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	int ret;
+
+	ldim_drv->spi = spi;
+
+	dev_set_drvdata(&spi->dev, ldim_drv->ldev_conf);
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret)
+		LDIMERR("spi setup failed\n");
+
+	/* LDIMPR("%s ok\n", __func__); */
+	return ret;
+}
+
+static int ldim_spi_dev_remove(struct spi_device *spi)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_drv->spi = NULL;
 	return 0;
 }
 
+static struct spi_driver ldim_spi_dev_driver = {
+	.probe = ldim_spi_dev_probe,
+	.remove = ldim_spi_dev_remove,
+	.driver = {
+		.name = "ldim_dev",
+		.owner = THIS_MODULE,
+	},
+};
+
 int ldim_dev_iw7019_probe(void)
 {
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
@@ -877,8 +1095,10 @@ int ldim_dev_iw7019_probe(void)
 	reset_cnt = 0;
 	iw7019_on_flag = 0;
 	iw7019_spi_op_flag = 0;
+	iw7019_wr_err_cnt = 0;
 	iw7019_spi_err_flag = 0;
 	iw7019_spi_force_err_flag = 0;
+	iw7019_chipid_check_vs_cnt = 0;
 	vsync_cnt = 0;
 	fault_cnt = 0;
 	iw7019_spi_rw_test_flag = 0;
@@ -890,6 +1110,14 @@ int ldim_dev_iw7019_probe(void)
 		pr_err("malloc bl_iw7019 failed\n");
 		return -1;
 	}
+
+	spi_register_board_info(ldim_drv->spi_dev, 1);
+	ret = spi_register_driver(&ldim_spi_dev_driver);
+	if (ret) {
+		LDIMERR("register ldim_dev spi driver failed\n");
+		return -1;
+	}
+
 	bl_iw7019->test_mode = 0;
 	bl_iw7019->spi = ldim_drv->spi;
 	bl_iw7019->cs_hold_delay = ldim_drv->ldev_conf->cs_hold_delay;
@@ -924,8 +1152,10 @@ int ldim_dev_iw7019_remove(void)
 	if (iw7019_workqueue)
 		destroy_workqueue(iw7019_workqueue);
 
+	spi_unregister_driver(&ldim_spi_dev_driver);
 	kfree(bl_iw7019);
 	bl_iw7019 = NULL;
+
 	return 0;
 }
 
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
index cea570e..939bf19 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
+++ b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
@@ -40,7 +40,7 @@
 
 struct bl_gpio_s ldim_gpio[BL_GPIO_NUM_MAX];
 
-struct spi_board_info ldim_spi_dev = {
+static struct spi_board_info ldim_spi_dev = {
 	.modalias = "ldim_dev",
 	.mode = SPI_MODE_0,
 	.max_speed_hz = 1000000, /* 1MHz */
@@ -53,6 +53,7 @@ static unsigned char ldim_ini_data_on[LDIM_SPI_INIT_ON_SIZE];
 static unsigned char ldim_ini_data_off[LDIM_SPI_INIT_OFF_SIZE];
 
 struct ldim_dev_config_s ldim_dev_config = {
+	.type = LDIM_DEV_TYPE_NORMAL,
 	.cs_hold_delay = 0,
 	.cs_clk_delay = 0,
 	.en_gpio = 0xff,
@@ -224,12 +225,14 @@ static unsigned int pwm_reg[6] = {
 	PWM_PWM_F,
 };
 
-static void ldim_set_duty_pwm(struct bl_pwm_config_s *ld_pwm)
+void ldim_set_duty_pwm(struct bl_pwm_config_s *ld_pwm)
 {
 	unsigned int pwm_hi = 0, pwm_lo = 0;
 	unsigned int port = ld_pwm->pwm_port;
 	unsigned int vs[4], ve[4], sw, n, i;
 
+	if (ld_pwm->pwm_port >= BL_PWM_MAX)
+		return;
 	ld_pwm->pwm_level = ld_pwm->pwm_cnt * ld_pwm->pwm_duty / 100;
 
 	if (ldim_debug_print) {
@@ -294,12 +297,15 @@ static void ldim_set_duty_pwm(struct bl_pwm_config_s *ld_pwm)
 }
 
 /* set ldim pwm_vs */
-static int ldim_pwm_pinmux_ctrl(int status)
+static int ldim_pwm_pinmux_ctrl(char *pin_str, int status)
 {
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 	struct bl_pwm_config_s *ld_pwm;
 	int ret = 0;
 
+	if (strcmp(pin_str, "invalid") == 0)
+		return 0;
+
 	ld_pwm = &ldim_drv->ldev_conf->pwm_config;
 	if (ld_pwm->pwm_port >= BL_PWM_MAX)
 		return 0;
@@ -307,13 +313,12 @@ static int ldim_pwm_pinmux_ctrl(int status)
 	LDIMPR("%s: %d\n", __func__, status);
 
 	if (status) {
-		ldim_set_duty_pwm(ld_pwm);
 		bl_pwm_ctrl(ld_pwm, 1);
 
 		/* request pinmux */
 		if (ld_pwm->pinmux_flag == 0) {
 			ldim_drv->pin = devm_pinctrl_get_select(
-				ldim_drv->dev, "ldim_pwm");
+				ldim_drv->dev, pin_str);
 			if (IS_ERR(ldim_drv->pin))
 				LDIMERR("set ldim_pwm pinmux error\n");
 			ld_pwm->pinmux_flag = 1;
@@ -331,6 +336,91 @@ static int ldim_pwm_pinmux_ctrl(int status)
 	return ret;
 }
 
+static int ldim_pwm_vs_update(void)
+{
+	struct bl_pwm_config_s *bl_pwm = NULL;
+	int ret = 0;
+
+	bl_pwm = &ldim_dev_config.pwm_config;
+	bl_pwm_config_init(bl_pwm);
+	ldim_set_duty_pwm(bl_pwm);
+
+	return ret;
+}
+
+static void ldim_config_print(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	struct bl_pwm_config_s *ld_pwm;
+
+	LDIMPR("%s:\n", __func__);
+	pr_info("valid_flag            = %d\n"
+		"dev_index             = %d\n",
+		ldim_drv->valid_flag,
+		ldim_drv->dev_index);
+	if (ldim_drv->ldev_conf) {
+		ld_pwm = &ldim_drv->ldev_conf->pwm_config;
+		pr_info("dev_name              = %s\n"
+			"type                  = %d\n"
+			"en_gpio               = %d\n"
+			"en_gpio_on            = %d\n"
+			"en_gpio_off           = %d\n"
+			"dim_min               = 0x%03x\n"
+			"dim_max               = 0x%03x\n\n",
+			ldim_drv->ldev_conf->name,
+			ldim_drv->ldev_conf->type,
+			ldim_drv->ldev_conf->en_gpio,
+			ldim_drv->ldev_conf->en_gpio_on,
+			ldim_drv->ldev_conf->en_gpio_off,
+			ldim_drv->ldev_conf->dim_min,
+			ldim_drv->ldev_conf->dim_max);
+		switch (ldim_drv->ldev_conf->type) {
+		case LDIM_DEV_TYPE_SPI:
+			pr_info("spi_modalias          = %s\n"
+				"spi_mode              = %d\n"
+				"spi_max_speed_hz      = %d\n"
+				"spi_bus_num           = %d\n"
+				"spi_chip_select       = %d\n"
+				"cs_hold_delay         = %d\n"
+				"cs_clk_delay          = %d\n"
+				"lamp_err_gpio         = %d\n"
+				"fault_check           = %d\n"
+				"write_check           = %d\n"
+				"cmd_size              = %d\n\n",
+				ldim_drv->spi_dev->modalias,
+				ldim_drv->spi_dev->mode,
+				ldim_drv->spi_dev->max_speed_hz,
+				ldim_drv->spi_dev->bus_num,
+				ldim_drv->spi_dev->chip_select,
+				ldim_drv->ldev_conf->cs_hold_delay,
+				ldim_drv->ldev_conf->cs_clk_delay,
+				ldim_drv->ldev_conf->lamp_err_gpio,
+				ldim_drv->ldev_conf->fault_check,
+				ldim_drv->ldev_conf->write_check,
+				ldim_drv->ldev_conf->cmd_size);
+			break;
+		case LDIM_DEV_TYPE_I2C:
+			break;
+		case LDIM_DEV_TYPE_NORMAL:
+			break;
+		default:
+			break;
+		}
+		if (ld_pwm->pwm_port < BL_PWM_MAX) {
+			pr_info("pwm_port              = %d\n"
+				"pwm_pol               = %d\n"
+				"pwm_freq              = %d\n"
+				"pwm_duty              = %d%%\n"
+				"pinmux_flag           = %d\n",
+				ld_pwm->pwm_port, ld_pwm->pwm_method,
+				ld_pwm->pwm_freq, ld_pwm->pwm_duty,
+				ld_pwm->pinmux_flag);
+		}
+	} else {
+		pr_info("device config is null\n");
+	}
+}
+
 static int ldim_dev_get_config_from_dts(struct device_node *np, int index)
 {
 	char ld_propname[20];
@@ -339,34 +429,13 @@ static int ldim_dev_get_config_from_dts(struct device_node *np, int index)
 	unsigned int temp[5], val;
 	int i, j;
 	int ret = 0;
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 
 	memset(ldim_dev_config.init_on, 0, LDIM_SPI_INIT_ON_SIZE);
 	memset(ldim_dev_config.init_off, 0, LDIM_SPI_INIT_OFF_SIZE);
 	ldim_dev_config.init_on[0] = 0xff;
 	ldim_dev_config.init_off[0] = 0xff;
 
-	/* get spi config */
-	ret = of_property_read_u32(np, "spi_bus_num", &val);
-	if (ret)
-		LDIMERR("failed to get spi_bus_num\n");
-	else
-		ldim_spi_dev.bus_num = val;
-	ret = of_property_read_u32(np, "spi_chip_select", &val);
-	if (ret)
-		LDIMERR("failed to get spi_chip_select\n");
-	else
-		ldim_spi_dev.chip_select = val;
-	ret = of_property_read_u32(np, "spi_max_frequency", &val);
-	if (ret)
-		LDIMERR("failed to get spi_max_frequency\n");
-	else
-		ldim_spi_dev.max_speed_hz = val;
-	ret = of_property_read_u32(np, "spi_mode", &val);
-	if (ret)
-		LDIMERR("failed to get spi_mode\n");
-	else
-		ldim_spi_dev.mode = val;
-
 	/* get device config */
 	sprintf(ld_propname, "ldim_dev_%d", index);
 	LDIMPR("load: %s\n", ld_propname);
@@ -383,6 +452,13 @@ static int ldim_dev_get_config_from_dts(struct device_node *np, int index)
 	}
 	strcpy(ldim_dev_config.name, str);
 
+	ret = of_property_read_string(child, "ldim_pwm_pinmux_sel", &str);
+	if (ret) {
+		LDIMERR("failed to get ldim_pwm_name\n");
+		str = "invalid";
+	}
+	strcpy(ldim_dev_config.pinmux_name, str);
+
 	ret = of_property_read_string(child, "ldim_pwm_port", &str);
 	if (ret) {
 		LDIMERR("failed to get ldim_pwm_port\n");
@@ -416,13 +492,14 @@ static int ldim_dev_get_config_from_dts(struct device_node *np, int index)
 		bl_pwm_config_init(&ldim_dev_config.pwm_config);
 	}
 
-	ret = of_property_read_u32_array(child, "spi_cs_delay", &temp[0], 2);
+	ret = of_property_read_u32_array(child, "dim_max_min", &temp[0], 2);
 	if (ret) {
-		ldim_dev_config.cs_hold_delay = 0;
-		ldim_dev_config.cs_clk_delay = 0;
+		LDIMERR("failed to get dim_max_min\n");
+		ldim_dev_config.dim_max = 0xfff;
+		ldim_dev_config.dim_min = 0x7f;
 	} else {
-		ldim_dev_config.cs_hold_delay = temp[0];
-		ldim_dev_config.cs_clk_delay = temp[1];
+		ldim_dev_config.dim_max = temp[0];
+		ldim_dev_config.dim_min = temp[1];
 	}
 
 	ret = of_property_read_u32_array(child, "en_gpio_on_off", temp, 3);
@@ -442,102 +519,163 @@ static int ldim_dev_get_config_from_dts(struct device_node *np, int index)
 		ldim_dev_config.en_gpio_off = temp[2];
 	}
 
-	ret = of_property_read_u32(child, "lamp_err_gpio", &val);
+	ret = of_property_read_u32(child, "type", &val);
 	if (ret) {
-		ldim_dev_config.lamp_err_gpio = BL_GPIO_NUM_MAX;
-		ldim_dev_config.fault_check = 0;
+		LDIMERR("failed to get type\n");
+		ldim_dev_config.type = LDIM_DEV_TYPE_NORMAL;
 	} else {
-		if (val >= BL_GPIO_NUM_MAX) {
-			ldim_dev_config.lamp_err_gpio = BL_GPIO_NUM_MAX;
-			ldim_dev_config.fault_check = 0;
+		ldim_dev_config.type = val;
+		LDIMPR("type: %d\n", ldim_dev_config.type);
+	}
+	if (ldim_dev_config.type >= LDIM_DEV_TYPE_MAX) {
+		LDIMERR("type num is out of support\n");
+		return -1;
+	}
+
+	switch (ldim_dev_config.type) {
+	case LDIM_DEV_TYPE_SPI:
+		/* get spi config */
+		ldim_drv->spi_dev = &ldim_spi_dev;
+
+		ret = of_property_read_u32(child, "spi_bus_num", &val);
+		if (ret) {
+			LDIMERR("failed to get spi_bus_num\n");
 		} else {
-			ldim_dev_config.lamp_err_gpio = val;
-			ldim_dev_config.fault_check = 1;
-			ldim_gpio_register(ldim_dev_config.lamp_err_gpio);
-			ldim_gpio_set(ldim_dev_config.lamp_err_gpio,
-				BL_GPIO_INPUT);
+			ldim_spi_dev.bus_num = val;
+			LDIMPR("bus_num: %d\n", ldim_spi_dev.bus_num);
 		}
-	}
 
-	ret = of_property_read_u32(child, "spi_write_check", &val);
-	if (ret)
-		ldim_dev_config.write_check = 0;
-	else
-		ldim_dev_config.write_check = (unsigned char)val;
+		ret = of_property_read_u32(child, "spi_chip_select", &val);
+		if (ret) {
+			LDIMERR("failed to get spi_chip_select\n");
+		} else {
+			ldim_spi_dev.chip_select = val;
+			LDIMPR("chip_select: %d\n", ldim_spi_dev.chip_select);
+		}
 
-	ret = of_property_read_u32_array(child, "dim_max_min", &temp[0], 2);
-	if (ret) {
-		LDIMERR("failed to get dim_max_min\n");
-		ldim_dev_config.dim_max = 0xfff;
-		ldim_dev_config.dim_min = 0x7f;
-	} else {
-		ldim_dev_config.dim_max = temp[0];
-		ldim_dev_config.dim_min = temp[1];
-	}
+		ret = of_property_read_u32(child, "spi_max_frequency", &val);
+		if (ret) {
+			LDIMERR("failed to get spi_chip_select\n");
+		} else {
+			ldim_spi_dev.max_speed_hz = val;
+			LDIMPR("max_speed_hz: %d\n", ldim_spi_dev.max_speed_hz);
+		}
 
-	/* get init_cmd */
-	ret = of_property_read_u32(child, "cmd_size", &val);
-	if (ret) {
-		LDIMPR("no cmd_size\n");
-		ldim_dev_config.cmd_size = 1;
-	} else {
-		if (val > 1)
-			ldim_dev_config.cmd_size = (unsigned char)val;
+		ret = of_property_read_u32(child, "spi_mode", &val);
+		if (ret) {
+			LDIMERR("failed to get spi_mode\n");
+		} else {
+			ldim_spi_dev.mode = val;
+			LDIMPR("mode: %d\n", ldim_spi_dev.mode);
+		}
+
+		ret = of_property_read_u32_array(child, "spi_cs_delay",
+			&temp[0], 2);
+		if (ret) {
+			ldim_dev_config.cs_hold_delay = 0;
+			ldim_dev_config.cs_clk_delay = 0;
+		} else {
+			ldim_dev_config.cs_hold_delay = temp[0];
+			ldim_dev_config.cs_clk_delay = temp[1];
+		}
+
+		ret = of_property_read_u32(child, "lamp_err_gpio", &val);
+		if (ret) {
+			ldim_dev_config.lamp_err_gpio = BL_GPIO_NUM_MAX;
+			ldim_dev_config.fault_check = 0;
+		} else {
+			if (val >= BL_GPIO_NUM_MAX) {
+				ldim_dev_config.lamp_err_gpio = BL_GPIO_NUM_MAX;
+				ldim_dev_config.fault_check = 0;
+			} else {
+				ldim_dev_config.lamp_err_gpio = val;
+				ldim_dev_config.fault_check = 1;
+				ldim_gpio_register(
+					ldim_dev_config.lamp_err_gpio);
+				ldim_gpio_set(ldim_dev_config.lamp_err_gpio,
+					BL_GPIO_INPUT);
+			}
+		}
+
+		ret = of_property_read_u32(child, "spi_write_check", &val);
+		if (ret)
+			ldim_dev_config.write_check = 0;
 		else
+			ldim_dev_config.write_check = (unsigned char)val;
+
+		/* get init_cmd */
+		ret = of_property_read_u32(child, "cmd_size", &val);
+		if (ret) {
+			LDIMPR("no cmd_size\n");
 			ldim_dev_config.cmd_size = 1;
-	}
-	ret = of_property_read_u32_index(child, "init_on", 0, &val);
-	if (ret) {
-		LDIMPR("no init_on\n");
-		ldim_dev_config.init_on[0] = 0xff;
-		goto ldim_get_init_off;
-	}
-	if (ldim_dev_config.cmd_size > 1) {
-		i = 0;
-		while (i < LDIM_SPI_INIT_ON_SIZE) {
-			for (j = 0; j < ldim_dev_config.cmd_size; j++) {
-				ret = of_property_read_u32_index(
-					child, "init_on", (i + j), &val);
-				if (ret) {
-					LDIMERR("failed to get init_on\n");
-					ldim_dev_config.init_on[i] = 0xff;
-					goto ldim_get_init_off;
-				}
-				ldim_dev_config.init_on[i + j] =
-					(unsigned char)val;
+		} else {
+			if (val > 1)
+				ldim_dev_config.cmd_size = (unsigned char)val;
+			else
+				ldim_dev_config.cmd_size = 1;
 			}
-			if (ldim_dev_config.init_on[i] == 0xff)
-				break;
-			i += ldim_dev_config.cmd_size;
+
+		ret = of_property_read_u32_index(child, "init_on", 0, &val);
+		if (ret) {
+			LDIMPR("no init_on\n");
+			ldim_dev_config.init_on[0] = 0xff;
+			goto ldim_get_init_off;
 		}
-	}
+		if (ldim_dev_config.cmd_size > 1) {
+			i = 0;
+			while (i < LDIM_SPI_INIT_ON_SIZE) {
+				for (j = 0; j < ldim_dev_config.cmd_size; j++) {
+					ret = of_property_read_u32_index(child,
+						"init_on", (i + j), &val);
+					if (ret) {
+						LDIMERR("failed init_on\n");
+						ldim_dev_config.init_on[i]
+							= 0xff;
+						goto ldim_get_init_off;
+					}
+					ldim_dev_config.init_on[i + j] =
+						(unsigned char)val;
+				}
+				if (ldim_dev_config.init_on[i] == 0xff)
+					break;
+					i += ldim_dev_config.cmd_size;
+				}
+			}
 ldim_get_init_off:
-	ret = of_property_read_u32_index(child, "init_off", 0, &val);
-	if (ret) {
-		LDIMPR("no init_off\n");
-		ldim_dev_config.init_off[0] = 0xff;
-		goto ldim_get_config_end;
-	}
-	if (ldim_dev_config.cmd_size > 1) {
-		i = 0;
-		while (i < LDIM_SPI_INIT_OFF_SIZE) {
-			for (j = 0; j < ldim_dev_config.cmd_size; j++) {
-				ret = of_property_read_u32_index(
-					child, "init_off", (i + j), &val);
-				if (ret) {
-					LDIMERR("failed to get init_on\n");
-					ldim_dev_config.init_off[i] = 0xff;
-					goto ldim_get_config_end;
+		ret = of_property_read_u32_index(child, "init_off", 0, &val);
+		if (ret) {
+			LDIMPR("no init_off\n");
+			ldim_dev_config.init_off[0] = 0xff;
+			goto ldim_get_config_end;
+		}
+		if (ldim_dev_config.cmd_size > 1) {
+			i = 0;
+			while (i < LDIM_SPI_INIT_OFF_SIZE) {
+				for (j = 0; j < ldim_dev_config.cmd_size; j++) {
+					ret = of_property_read_u32_index(child,
+						"init_off", (i + j), &val);
+					if (ret) {
+						LDIMERR("failed init_on\n");
+						ldim_dev_config.init_off[i]
+							= 0xff;
+						goto ldim_get_config_end;
+					}
+					ldim_dev_config.init_off[i + j] =
+						(unsigned char)val;
 				}
-				ldim_dev_config.init_off[i + j] =
-					(unsigned char)val;
+				if (ldim_dev_config.init_off[i] == 0xff)
+					break;
+					i += ldim_dev_config.cmd_size;
 			}
-			if (ldim_dev_config.init_off[i] == 0xff)
-				break;
-			i += ldim_dev_config.cmd_size;
 		}
-	}
 ldim_get_config_end:
+		break;
+	case LDIM_DEV_TYPE_I2C:
+		break;
+	case LDIM_DEV_TYPE_NORMAL:
+	default:
+		break;
+	}
 	return 0;
 }
 
@@ -547,10 +685,16 @@ static int ldim_dev_add_driver(struct ldim_dev_config_s *ldev_conf, int index)
 
 	if (strcmp(ldev_conf->name, "iw7019") == 0) {
 		ret = ldim_dev_iw7019_probe();
+		goto ldim_dev_add_driver_next;
+	} else if (strcmp(ldev_conf->name, "ob3350") == 0) {
+		ret = ldim_dev_ob3350_probe();
+		goto ldim_dev_add_driver_next;
 	} else {
 		LDIMERR("invalid device name: %s\n", ldev_conf->name);
 		ret = -1;
 	}
+
+ldim_dev_add_driver_next:
 	if (ret) {
 		LDIMERR("add device driver failed %s(%d)\n",
 			ldev_conf->name, index);
@@ -568,10 +712,16 @@ static int ldim_dev_remove_driver(struct ldim_dev_config_s *ldev_conf,
 
 	if (strcmp(ldev_conf->name, "iw7019") == 0) {
 		ret = ldim_dev_iw7019_remove();
+		goto ldim_dev_remove_driver_next;
+	} else if (strcmp(ldev_conf->name, "ob3350") == 0) {
+		ret = ldim_dev_ob3350_remove();
+		goto ldim_dev_remove_driver_next;
 	} else {
 		LDIMERR("invalid device name: %s\n", ldev_conf->name);
 		ret = -1;
 	}
+
+ldim_dev_remove_driver_next:
 	if (ret) {
 		LDIMERR("remove device driver failed %s(%d)\n",
 			ldev_conf->name, index);
@@ -582,40 +732,6 @@ static int ldim_dev_remove_driver(struct ldim_dev_config_s *ldev_conf,
 	return ret;
 }
 
-static int ldim_spi_dev_probe(struct spi_device *spi)
-{
-	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
-	int ret;
-
-	ldim_drv->spi = spi;
-
-	dev_set_drvdata(&spi->dev, ldim_drv->ldev_conf);
-	spi->bits_per_word = 8;
-	ret = spi_setup(spi);
-	if (ret)
-		LDIMERR("spi setup failed\n");
-
-	/* LDIMPR("%s ok\n", __func__); */
-	return ret;
-}
-
-static int ldim_spi_dev_remove(struct spi_device *spi)
-{
-	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
-
-	ldim_drv->spi = NULL;
-	return 0;
-}
-
-static struct spi_driver ldim_spi_dev_driver = {
-	.probe = ldim_spi_dev_probe,
-	.remove = ldim_spi_dev_remove,
-	.driver = {
-		.name = "ldim_dev",
-		.owner = THIS_MODULE,
-	},
-};
-
 static int ldim_dev_probe(struct platform_device *pdev)
 {
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
@@ -625,16 +741,10 @@ static int ldim_dev_probe(struct platform_device *pdev)
 	ldim_drv->dev = &pdev->dev;
 	ldim_drv->ldev_conf = &ldim_dev_config;
 	ldim_drv->pinmux_ctrl = ldim_pwm_pinmux_ctrl;
+	ldim_drv->pwm_vs_update = ldim_pwm_vs_update;
+	ldim_drv->config_print = ldim_config_print,
 	ldim_dev_get_config_from_dts(pdev->dev.of_node, ldim_drv->dev_index);
 
-	/* register spi */
-	spi_register_board_info(&ldim_spi_dev, 1);
-	ret = spi_register_driver(&ldim_spi_dev_driver);
-	if (ret) {
-		LDIMERR("register ldim_dev spi driver failed\n");
-		return -1;
-	}
-
 	ldim_dev_add_driver(ldim_drv->ldev_conf, ldim_drv->dev_index);
 
 	/* init ldim function */
@@ -651,7 +761,6 @@ static int __exit ldim_dev_remove(struct platform_device *pdev)
 	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 
 	ldim_dev_remove_driver(ldim_drv->ldev_conf, ldim_drv->dev_index);
-	spi_unregister_driver(&ldim_spi_dev_driver);
 
 	LDIMPR("%s OK\n", __func__);
 	return ret;
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.h b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.h
index 1a5aa88..e556d0f 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.h
+++ b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.h
@@ -23,6 +23,10 @@ extern unsigned int ldim_gpio_get(int index);
 
 extern int ldim_dev_iw7019_probe(void);
 extern int ldim_dev_iw7019_remove(void);
+extern int ldim_dev_ob3350_probe(void);
+extern int ldim_dev_ob3350_remove(void);
+extern void ldim_set_duty_pwm(struct bl_pwm_config_s *ld_pwm);
+
 
 #endif /* __LDIM_DEV_DRV_H */
 
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ldim_drv.c b/drivers/amlogic/display/backlight/aml_ldim/ldim_drv.c
index 62d6e9b..6436b5f 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/ldim_drv.c
+++ b/drivers/amlogic/display/backlight/aml_ldim/ldim_drv.c
@@ -100,23 +100,57 @@ static struct workqueue_struct *ldim_read_queue;
 static struct work_struct   ldim_read_work;
 
 #if 1
+#define FRM_NUM_DBG 5
 static unsigned long fw_LD_ThSF_l = 1600;
 static unsigned long fw_LD_ThTF_l = 256;
 
-static unsigned long avg_gain_sf = 128;  /* [1~128~256] */
+static unsigned long cal_cur_en;  /* [1~128~256] */
 
 static unsigned long avg_gain_sf_l = 128;  /* [1~128~256] */
 unsigned long dif_gain_sf_l = 0;  /* [0~128] */
 
 unsigned long Debug = 0;
 static unsigned long LPF = 1;  /* [0~128] */
-
-static unsigned long  rgb_base = 128;  /* [1~128], norm 128 as 1 */
+/* static unsigned long slp_gain = 28;*/
+static unsigned long  transmit_gain = 1;
 static unsigned long  lpf_gain = 128;  /* [0~128~256], norm 128 as 1*/
 static unsigned long  lpf_res = 41;    /* 1024/9 = 113*/
-static unsigned long bl_remap_curve[16] = {272, 317, 392, 497, 632,
-	797, 991, 1216, 1471, 1756, 2071, 2416, 2791, 3195, 3630, 4095};
-		/*BL_matrix remap curve*/
+unsigned long  rgb_base = 127;
+unsigned long boost_gain = 380; /*256;*/
+unsigned long Dbprint_lv = 0;
+/* static unsigned long bl_remap_curve[16] = {272, 317, 392, 497, 632,
+	797, 991, 1216, 1471, 1756, 2071, 2416, 2791, 3195, 3630, 4095};*/
+static unsigned int bl_remap_curve[16] = {
+				436, 479, 551, 651, 780, 938, 1125, 1340,
+				1584, 1856, 2158, 2488, 2847, 3234, 3650, 4095
+				};/*BL_matrix remap curve*/
+static unsigned long Sf_bypass, Boost_light_bypass;
+static unsigned long Lpf_bypass, Ld_remap_bypass, Tf_bypass;
+static unsigned int  Tf_luma_avg_frm[FRM_NUM_DBG] = {0, 0, 0, 0, 0};
+static unsigned int  Tf_blkLuma_avg[FRM_NUM_DBG][8] = {
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0} };
+static unsigned int  Tf_bl_matrix[FRM_NUM_DBG][8] = {
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0} };
+static unsigned int  Map_bl_matrix[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+static unsigned int  Tf_bl_matrix_map[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+static unsigned int  Tf_diff_frm_luma[FRM_NUM_DBG] = {0, 0, 0, 0, 0};
+static unsigned int  Tf_diff_blk_luma[FRM_NUM_DBG][8] = {
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0},
+				{0, 0, 0, 0, 0, 0, 0, 0} };
+static unsigned int  Map_bl_matrix_Compensate;
+static unsigned int  Map_bl_matrix_AVG;
+unsigned int  db_cnt = 0;
 #endif
 
 unsigned long ldim_frm_time = 0;
@@ -132,8 +166,10 @@ unsigned long ld_fw_alg_frm_start_time = 0;
 unsigned long ld_fw_alg_frm_end_time = 0;
 long ld_fw_alg_frm_time = 0;
 
+#define LD_DATA_MIN    10
+static unsigned int ldim_data_min;
+static unsigned int ldim_brightness_level;
 unsigned long litgain = LD_DATA_DEPTH; /* 0xfff */
-unsigned long boost_gain = 280; /*256;*/
 unsigned long avg_gain = LD_DATA_DEPTH; /* 0xfff */
 /*unsigned long Backlit_coeff_l = 4096;*/
 
@@ -196,12 +232,41 @@ static unsigned int ldim_top_en;
 module_param(ldim_top_en, uint, 0664);
 MODULE_PARM_DESC(ldim_top_en, "ldim_top_en");
 
+static unsigned int slp_gain = 28;
+module_param(slp_gain, uint, 0664);
+MODULE_PARM_DESC(slp_gain, "slp_gain");
+
+static unsigned int incr_con_en;
+module_param(incr_con_en, uint, 0664);
+MODULE_PARM_DESC(incr_con_en, "incr_con_en");
+
+static unsigned int ov_gain = 16;
+module_param(ov_gain, uint, 0664);
+MODULE_PARM_DESC(ov_gain, "ov_gain");
+
+static unsigned int incr_dif_gain = 16;
+module_param(incr_dif_gain, uint, 0664);
+MODULE_PARM_DESC(incr_dif_gain, "incr_dif_gain");
+
+
+static unsigned int logo_en;
+module_param(logo_en, uint, 0664);
+MODULE_PARM_DESC(logo_en, "logo_en");
+
+static unsigned int test_static_pic;
+module_param(test_static_pic, uint, 0664);
+MODULE_PARM_DESC(test_static_pic, "test_static_pic");
+
+
 static unsigned long  vs_time_record;
 
 static struct aml_ldim_driver_s ldim_driver;
 static void ldim_on_vs_arithmetic(void);
 static void ldim_update_setting(void);
-
+static void ldim_get_matrix_info_6(void);
+static void ldim_print_debug(void);
+static void ldim_bl_remap_curve(int slop_gain);
+static void ldim_bl_remap_curve_print(void);
 static struct ldim_config_s ldim_config = {
 	.hsize = 3840,
 	.vsize = 2160,
@@ -210,7 +275,8 @@ static struct ldim_config_s ldim_config = {
 
 static void ldim_stts_read_region(struct work_struct *work)
 {
-	ldim_read_region(ldim_hist_row, ldim_hist_col);
+	if (test_static_pic == 0)
+		ldim_read_region(ldim_hist_row, ldim_hist_col);
 	ldim_on_vs_arithmetic();
 	return;
 }
@@ -330,11 +396,39 @@ void LDIM_RD_BASE_LUT_2(unsigned int base, unsigned int *pData,
 		data = Rd(LDIM_BL_DATA_PORT);
 }
 
+
+static void ldim_bl_remap_curve(int slop_gain)
+{
+	int i = 0 , ii = 0;
+	int t_bl_remap_curve[16] = {0};
+	int bl_max = 0, mid_value = 0;
+	LDIMPR("%s:\n", __func__);
+	for (i = 0; i < 16; i++) {
+		ii = (i+1) * 256;
+		mid_value = ii*ii>>17;
+		t_bl_remap_curve[i] = mid_value*slop_gain + 512;
+	}
+	bl_max = t_bl_remap_curve[15];
+
+	for (i = 0; i < 16; i++)
+		bl_remap_curve[i] = t_bl_remap_curve[i]*4095/bl_max;
+}
+
+void ldim_bl_remap_curve_print(void)
+{
+	int i = 0;
+	LDIMPR("%s:\n", __func__);
+	pr_info("bl_remap_curve:");
+	for (i = 0; i < 16; i++)
+		pr_info("[%4d]\n", bl_remap_curve[i]);
+}
+
+
 static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 	unsigned int *max_matrix, unsigned int *hist_matrix)
 {
 	/* Notes, nPRM will be set here in SW algorithm too */
-	int dif, blkRow, blkCol, k, m, n;
+	int dif, blkRow, blkCol, k, m, n, i;
 	unsigned long sum;
 	unsigned int avg, adpt_alp, dif_RGB, alpha, Bmin, Bmax;
 	unsigned int bl_value, bl_valuex128;
@@ -367,7 +461,13 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
     kmalloc(Bsize*sizeof(unsigned int),GFP_KERNEL); */
 	int int_x, rmd_x, norm;
 	int left,  right, bl_value_map;
-
+	int Luma_avg = 0, blkLuma_avg = 0, lmh_avg = 0, blk_sum = 0;
+	int diff_frm_luma = 0, diff_blk_luma = 0;
+	int diff_blk_matrix = 0, remap_value = 0;
+	int dif_r = 0, dif_g = 0, dif_b = 0;
+	int tvalue = 0, min_diff = 0;
+	int Bmax_lpf = 0;
+	int frm_rgbmax = 0, black_blk_num = 0;
 	#if 1
 	int SF_avg = 0;
 	unsigned int SF_dif = 0;
@@ -375,39 +475,92 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 	fw_LD_ThSF = fw_LD_ThSF_l;
 	fw_LD_ThTF = fw_LD_ThTF_l;
 #endif
+	diff_frm_luma = 0;
+	diff_blk_luma = 0;
+	diff_blk_matrix = 0;
+	remap_value = 0;
 
 	tBL_matrix = FDat->TF_BL_matrix_2;
+	/* Luma_avg transmit */
+	for (i = 0; i < (FRM_NUM_DBG - 1); i++) {
+		for (blkRow = 0; blkRow < Vnum; blkRow++) {
+			for (blkCol = 0; blkCol < Hnum; blkCol++) {
+				Tf_blkLuma_avg[i][blkRow*Hnum + blkCol]   =
+				Tf_blkLuma_avg[i+1][blkRow*Hnum + blkCol];
+				Tf_bl_matrix[i][blkRow*Hnum + blkCol]     =
+				Tf_bl_matrix[i+1][blkRow*Hnum + blkCol];
+				Tf_diff_blk_luma[i][blkRow*Hnum + blkCol] =
+				Tf_diff_blk_luma[i+1][blkRow*Hnum + blkCol];
+			}
+		}
+		Tf_luma_avg_frm[i] = Tf_luma_avg_frm[i+1];
+		Tf_diff_frm_luma[i] = Tf_diff_frm_luma[i+1];
+	}
 
-	/* calculate the current frame */
+	frm_rgbmax = 0; black_blk_num = 0;
 	for (blkRow = 0; blkRow < Vnum; blkRow++) {
 		for (blkCol = 0; blkCol < Hnum; blkCol++) {
-			RGBmax = MAX(MAX(max_matrix[blkRow*3*stride +
-				blkCol*3 + 0],
-			max_matrix[blkRow*3*stride + blkCol*3 + 1]),
-			max_matrix[blkRow*3*stride + blkCol*3 + 2]);
-
-			if (RGBmax < rgb_base)
-				RGBmax = rgb_base;
+			RGBmax =
+			MAX(MAX(max_matrix[blkRow*3*stride + blkCol*3 + 0],
+				max_matrix[blkRow*3*stride + blkCol*3 + 1]),
+				max_matrix[blkRow*3*stride + blkCol*3 + 2]);
+			if ((RGBmax == 0) &&
+			(hist_matrix[blkRow*LD_STA_BIN_NUM*stride +
+			blkCol*LD_STA_BIN_NUM + 0] >= 1030800))
+				black_blk_num++;
+			frm_rgbmax = MAX(frm_rgbmax, RGBmax);
+		}
+	}
 
+	/* calculate the current frame */
+	sum = 0; Luma_avg = 0;
+	for (blkRow = 0; blkRow < Vnum; blkRow++) {
+		for (blkCol = 0; blkCol < Hnum; blkCol++) {
+			RGBmax =
+			MAX(MAX(max_matrix[blkRow*3*stride + blkCol*3 + 0],
+				max_matrix[blkRow*3*stride + blkCol*3 + 1]),
+				max_matrix[blkRow*3*stride + blkCol*3 + 2]);
+			if (frm_rgbmax != 0) {
+				if (RGBmax < rgb_base)
+					RGBmax = rgb_base;
+			}
 			/* Consider the sitrogram */
 			Histmx = 0;
+			blkLuma_avg = 0;
+			blk_sum = 0;
 			for (k = 0; k < 16; k++) {
-				Histmx += (hist_matrix[blkRow*LD_STA_BIN_NUM*
-					stride + blkCol*LD_STA_BIN_NUM + k] *
-					fw_LD_Whist[k]);
+				Histmx +=
+				(hist_matrix[blkRow*LD_STA_BIN_NUM*stride
+				+ blkCol*LD_STA_BIN_NUM + k] * fw_LD_Whist[k]);
+				blk_sum +=
+				hist_matrix[blkRow*LD_STA_BIN_NUM*stride
+				+ blkCol*LD_STA_BIN_NUM + k];
+				blkLuma_avg +=
+				hist_matrix[blkRow*LD_STA_BIN_NUM*stride
+				+ blkCol*LD_STA_BIN_NUM + k] * k * 32;
+				/*16-->512grads*/
 				a = 0;
 			}
+			/* sum += blk_sum;
+			Luma_avg += blkLuma_avg; */
+			Tf_blkLuma_avg[FRM_NUM_DBG - 1][blkRow*Hnum + blkCol] =
+			((blkLuma_avg + (blk_sum >> 1)) / (blk_sum + 1));
+			Luma_avg +=
+			Tf_blkLuma_avg[FRM_NUM_DBG - 1][blkRow*Hnum + blkCol];
 			fw_hist_mx =
 				((Histmx>>8)*fw_LD_Thist*2/(fw_pic_size>>8));
 			/* further debug */
 			tBL_matrix[blkRow*Hnum + blkCol] =
 				((BLmax*MIN(fw_hist_mx, RGBmax))>>10);
-			nPRM->BL_matrix[blkCol*Vnum + blkRow] =
-				tBL_matrix[blkRow*Hnum + blkCol];
+
 			a = 0;
 		}
 	}
 
+	/*To solve black/white woman flicker*/
+	lmh_avg = (Luma_avg  / (Vnum * Hnum));
+	Tf_luma_avg_frm[FRM_NUM_DBG - 1] = lmh_avg;
+
 	/* Spatial Filter the BackLits */
 	sum = 0;
 	for (blkRow = 0; blkRow < Vnum; blkRow++) {
@@ -417,21 +570,26 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 				for (n =  -1; n < 2; n++) {
 					if ((m == 0) && (n == 0)) {
 						curNB =
-						tBL_matrix[blkRow*Hnum +
-						blkCol];
+					tBL_matrix[blkRow*Hnum + blkCol];
 					} else if (((blkRow+m) >= 0) &&
 						((blkRow+m) < Vnum) &&
-						((blkCol+n) >= 0) &&
+						((blkCol + n) >= 0) &&
 						((blkCol+n) < Hnum)) {
-						maxNB = MAX(maxNB,
-						tBL_matrix[(blkRow+m)*Hnum +
-						blkCol+n]);
+						maxNB =
+					MAX(maxNB, tBL_matrix[(blkRow+m)*Hnum
+					+ blkCol + n]);
 					}
 				}
 			}
 			/* SF matrix */
-			FDat->SF_BL_matrix[blkRow*Hnum + blkCol] =
-					MAX(curNB, (maxNB-fw_LD_ThSF));
+			if (Sf_bypass == 1) {
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol] =
+				tBL_matrix[blkRow*Hnum + blkCol];
+			} else {
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol] =
+				MAX(curNB, (maxNB-fw_LD_ThSF));
+			}
+
 			sum += FDat->SF_BL_matrix[blkRow*Hnum + blkCol];
 			/* for SF_BL_matrix average calculation */
 		}
@@ -442,25 +600,28 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 	for (blkRow = 0; blkRow < Vnum; blkRow++) {
 		for (blkCol = 0; blkCol < Hnum; blkCol++) {
 			dif = (FDat->SF_BL_matrix[blkRow*Hnum + blkCol] - avg);
-			#if 0
-			if (dif > 0)
-				FDat->SF_BL_matrix[blkRow*Hnum + blkCol] +=
-							(4*dif);
-			#endif
 
 			#if 1
 			FDat->SF_BL_matrix[blkRow*Hnum + blkCol] += (0*dif);
-			FDat->SF_BL_matrix[blkRow*Hnum + blkCol]  =
-				(FDat->SF_BL_matrix[blkRow*Hnum + blkCol] *
-				boost_gain + 64)>>7;
+			if (Boost_light_bypass == 1) {
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol]  =
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol];
+			} else {
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol]  =
+	(FDat->SF_BL_matrix[blkRow*Hnum + blkCol] * boost_gain + 64)>>7;
+			}
+
 			#endif
 
 			if (FDat->SF_BL_matrix[blkRow*Hnum + blkCol] > 4095)
-				FDat->SF_BL_matrix[blkRow*Hnum + blkCol] = 4095;
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol] =
+				4095;
 		}
 	}
 
 #if 1
+	SF_sum = 0;
+	TF_sum = 0;
 	for (blkRow = 0; blkRow < Vnum; blkRow++) {
 		for (blkCol = 0; blkCol < Hnum; blkCol++) {
 			SF_sum += FDat->SF_BL_matrix[blkRow*Hnum + blkCol];
@@ -480,14 +641,14 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 				if (FDat->SF_BL_matrix[blkRow*Hnum
 					+ blkCol] <= SF_avg) {
 					FDat->SF_BL_matrix[blkRow*Hnum + blkCol]
-						= ((SF_avg * avg_gain_sf + 64)
+						= ((SF_avg  + 64)
 						>> 7);
 					dif_gain_sf_l = 0;
 					avg_gain_sf_l = 0;
 				} else {
 					FDat->SF_BL_matrix[blkRow*Hnum
-						+ blkCol] = ((SF_avg *
-						avg_gain_sf + 64) >> 7)
+						+ blkCol] = ((SF_avg
+						 + 64) >> 7)
 						+ SF_dif; /* need optimize */
 				}
 				if (FDat->SF_BL_matrix[blkRow*Hnum
@@ -500,6 +661,7 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 #endif
 
 	/* LPF  Only for Xiaomi 8 Led ,here Vnum = 1;*/
+	Bmin = 4096; Bmax_lpf = 0;
 	if (LPF == 1) {
 		for (blkRow = 0; blkRow < Vnum; blkRow++) {
 			for (blkCol = 0; blkCol < Hnum; blkCol++) {
@@ -516,16 +678,108 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 						sum += FDat->SF_BL_matrix[num];
 					}
 				}
-				FDat->SF_BL_matrix[blkRow*Hnum + blkCol] =
-					(((sum * lpf_res >> 10) *
-					lpf_gain) >> 7); /*1024/9 = 113*/
+				if (Lpf_bypass == 1) {
+					FDat->SF_BL_matrix[blkRow*Hnum +
+					blkCol] =
+	FDat->SF_BL_matrix[blkRow*Hnum + blkCol]; /*1024/9 = 113*/
+				} else {
+					FDat->SF_BL_matrix[blkRow*Hnum +
+					blkCol] =
+		(((sum * lpf_res >> 10) * lpf_gain) >> 7); /*1024/9 = 113*/
+				}
+
+				tvalue =
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol];
+				tvalue = (tvalue * ov_gain + 16) >> 4;
+				/*ov_gain[16, 32, 64, 128, 256]norm 16 as "1"*/
+				min_diff =
+			tvalue - FDat->SF_BL_matrix[blkRow*Hnum + blkCol];
+				Bmin = MIN(Bmin, min_diff);
+
+				Bmax_lpf =
+				MAX(Bmax_lpf,
+			Tf_bl_matrix[FRM_NUM_DBG-2][blkRow*Hnum + blkCol]);
+
 				if (FDat->SF_BL_matrix[blkRow*Hnum + blkCol] >
-					4095) {
+									4095) {
+					FDat->SF_BL_matrix[blkRow*Hnum +
+							blkCol] = 4095;
+				}
+			}
+		}
+	}
+
+
+	if (incr_con_en == 1) {
+		for (blkRow = 0; blkRow < Vnum; blkRow++) {
+			for (blkCol = 0; blkCol < Hnum; blkCol++) {
+				tvalue =
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol];
+				tvalue = (tvalue * ov_gain + 16) >> 4;
+				/*ov_gain[16, 32, 64, 128, 256]norm 16 as "1"*/
+				tvalue =
+				tvalue - ((Bmin * incr_dif_gain + 8) >> 4);
+				/* incr_dif_gain [1~16]*/
+
+				FDat->SF_BL_matrix[blkRow*Hnum +
+					blkCol] = tvalue;
+
+				if (FDat->SF_BL_matrix[blkRow*Hnum +
+							blkCol] > 4095)
+					FDat->SF_BL_matrix[blkRow*Hnum +
+							blkCol] = 4095;
+
+			}
+		}
+	}
+
+
+
+	if (logo_en == 1) {
+		/*
+		for (blkRow = 0; blkRow < Vnum; blkRow++) {
+			for (blkCol = 0; blkCol < Hnum; blkCol++) {
+				if (Dbprint_lv == 1) {
+					if ((db_cnt%4) == 0) {
+						pr_info(
+				"0_FDat->SF_BL_matrix[%4d] = [%4d]\n",
+				(blkRow*Hnum + blkCol),
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol]);
+					}
+				}
+
+				maxNB = 0;
+				for (m =  -1; m < 2; m++) {
+					for (n =  -1; n < 2; n++) {
+						if ((m == 0) && (n == 0)) {
+							curNB =
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol];
+						} else if (((blkRow+m) >= 0)
+						&& ((blkRow+m) < Vnum)
+						&& ((blkCol+n) >= 0)
+						&& ((blkCol+n) < Hnum)) {
+							maxNB =
+		MAX(maxNB, FDat->SF_BL_matrix[(blkRow+m)*Hnum + blkCol+n]);
+						}
+					}
+				}
+				dif = maxNB - curNB;
+				tvalue = ((curNB + 1) > 1);
+				if (dif > 500)
 					FDat->SF_BL_matrix[blkRow*Hnum +
-						blkCol] = 4095;
+					blkCol] = ((maxNB * 3 + 2) >> 2);
+
+				if (Dbprint_lv == 1) {
+					if ((db_cnt%4) == 0) {
+						pr_info(
+				"1_FDat->SF_BL_matrix[%4d] = [%4d]\n",
+				(blkRow*Hnum + blkCol),
+				FDat->SF_BL_matrix[blkRow*Hnum + blkCol]);
+					}
 				}
 			}
 		}
+		*/
 	}
 
 	/* Temperary filter */
@@ -533,48 +787,65 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 	for (blkRow = 0; blkRow < Vnum; blkRow++) {
 		for (blkCol = 0; blkCol < Hnum; blkCol++) {
 			/* Optimization needed here */
-			dif_RGB = MAX(MAX(ABS(FDat->last_STA1_MaxRGB
-				[blkRow*3*stride + blkCol*3 + 0] -
-				max_matrix[blkRow*3*stride + blkCol*3 + 0]),
-				ABS(FDat->last_STA1_MaxRGB[blkRow*3*
-				stride + blkCol*3 + 1] -
-				max_matrix[blkRow*3*stride +
-				blkCol*3 + 1])),
-				ABS(FDat->last_STA1_MaxRGB
-				[blkRow*3*stride + blkCol*3 + 2] -
-				max_matrix[blkRow*3*stride +
-				blkCol*3 + 2]));
-
-			adpt_alp = ABS((FDat->SF_BL_matrix[blkRow*Hnum +
-					blkCol]) -
-				(FDat->TF_BL_matrix[blkRow*Hnum + blkCol]));
+			/* dif_RGB =
+MAX(MAX(ABS(FDat->last_STA1_MaxRGB[blkRow*3*stride + blkCol*3 + 0] -
+max_matrix[blkRow*3*stride + blkCol*3 + 0]),
+ABS(FDat->last_STA1_MaxRGB[blkRow*3*stride + blkCol*3 + 1] -
+max_matrix[blkRow*3*stride + blkCol*3 + 1])),
+ABS(FDat->last_STA1_MaxRGB[blkRow*3*stride + blkCol*3 + 2] -
+max_matrix[blkRow*3*stride + blkCol*3 + 2]));*/
+			dif_r =
+			FDat->last_STA1_MaxRGB[blkRow*3*stride + blkCol*3 + 0] -
+				max_matrix[blkRow*3*stride + blkCol*3 + 0];
+			dif_r = ABS(dif_r);
+			dif_g =
+			FDat->last_STA1_MaxRGB[blkRow*3*stride + blkCol*3 + 1] -
+				max_matrix[blkRow*3*stride + blkCol*3 + 1];
+			dif_g = ABS(dif_g);
+			dif_b =
+			FDat->last_STA1_MaxRGB[blkRow*3*stride + blkCol*3 + 2] -
+				max_matrix[blkRow*3*stride + blkCol*3 + 2];
+			dif_b = ABS(dif_b);
+			dif_RGB = MAX(MAX(dif_r, dif_g), dif_b);
+			adpt_alp =
+			(FDat->SF_BL_matrix[blkRow*Hnum + blkCol]) -
+				(FDat->TF_BL_matrix[blkRow*Hnum + blkCol]);
+			adpt_alp = ABS(adpt_alp);
+
 			#if 0
-			alpha = MIN(256, fw_LD_ThTF +
-				(MAX(adpt_alp, dif_RGB)));
+			alpha = MIN(256, fw_LD_ThTF + (MAX(adpt_alp, dif_RGB)));
+			SF_sum = 0;
+			TF_sum = 0;
+			dif_sum = 0;
+			bl_valuex128 = 0;
 			#endif
 
 			#if 1
-			dif_sum = ABS(SF_sum - TF_sum);
+			dif_sum = SF_sum - TF_sum;
+			dif_sum = ABS(dif_sum);
 			if (dif_sum > 32760)
 				alpha = 256;
 			else
 				alpha = MIN(256, fw_LD_ThTF);
+			bl_valuex128 = 0;
 			#endif
 
 			FDat->TF_BL_alpha[blkRow*Hnum + blkCol] = alpha;
 			/* 256 normalized as "1" */
 
 			/* get the temporary filtered BL_value */
-			/* bl_value = (((256-alpha) * (FDat->TF_BL_matrix
-				[blkRow*Hnum + blkCol]) + alpha*
-				(FDat->SF_BL_matrix[blkRow*Hnum
-				+ blkCol]) + 128) >> 8); */
-			bl_valuex128 = (FDat->TF_BL_matrix[blkRow*Hnum +
-				blkCol]) + (alpha*((
-				FDat->SF_BL_matrix[blkRow*Hnum + blkCol]<<7) -
-				FDat->TF_BL_matrix[blkRow*Hnum + blkCol] + 128)
-				>>8);  /* 7 more bits precison kept */
-			bl_value = (bl_valuex128 + 64)>>7;  /* u12 */
+			 bl_value =
+			(((256-alpha) *
+			(FDat->TF_BL_matrix[blkRow*Hnum + blkCol]) +
+			alpha *
+			(FDat->SF_BL_matrix[blkRow*Hnum + blkCol]) + 128) >> 8);
+			/* bl_valuex128 =
+			(FDat->TF_BL_matrix[blkRow*Hnum +blkCol]) +
+			(alpha*
+			((FDat->SF_BL_matrix[blkRow*Hnum + blkCol]<<7) -
+			FDat->TF_BL_matrix[blkRow*Hnum + blkCol] + 128)>>8); */
+			/* 7 more bits precison kept */
+			/* bl_value = (bl_valuex128 + 64)>>7;*//* u12 */
 			if (bl_value > 4095)
 				bl_value = 4095;
 
@@ -589,24 +860,134 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 
 			right = bl_remap_curve[int_x];
 
-			bl_value_map = left + (((right-left)*rmd_x + 128)>>8);
+			if (Ld_remap_bypass == 1) {
+				bl_value_map = bl_value;
+			} else {
+				bl_value_map = left +
+				(((right-left)*rmd_x + 128)>>8);
+			}
 			bl_value_map = (bl_value_map > 4095) ? 4095 :
 				bl_value_map;
 				/*clip to u12: debug 20150728  output u12*/
 
-			if (bl_value_map < 127)
-				bl_value_map = 127;
+			Tf_bl_matrix_map[blkRow*Hnum + blkCol] = bl_value_map;
+
+			diff_frm_luma = Tf_luma_avg_frm[FRM_NUM_DBG - 1] -
+					Tf_luma_avg_frm[FRM_NUM_DBG - 2];
+			diff_frm_luma = ABS(diff_frm_luma);
+			Tf_diff_frm_luma[FRM_NUM_DBG - 1] = diff_frm_luma;
+
+
+			 /* if (Tf_luma_avg_frm[FRM_NUM_DBG - 1] == 0)
+				bl_value_map =
+				Tf_bl_matrix[FRM_NUM_DBG -
+				3][blkRow*Hnum + blkCol];
+
+			if (diff_frm_luma > 20 &&
+				(Tf_luma_avg_frm[FRM_NUM_DBG - 1] == 0))
+				bl_value_map =
+				Tf_bl_matrix[FRM_NUM_DBG -
+				3][blkRow*Hnum + blkCol];
+			*/
+
+			if (Tf_luma_avg_frm[FRM_NUM_DBG - 1] <= 1) {
+				Tf_bl_matrix[FRM_NUM_DBG - 2][blkRow*Hnum +
+							blkCol] = Bmax_lpf>>1;
+			}
+
+
+			if (diff_frm_luma < 10) {/*same video scene*/
+				diff_blk_luma =
+			Tf_blkLuma_avg[FRM_NUM_DBG - 1][blkRow*Hnum + blkCol] -
+			Tf_blkLuma_avg[FRM_NUM_DBG - 2][blkRow*Hnum + blkCol];
+
+				diff_blk_matrix =
+				bl_value_map -
+			Tf_bl_matrix[FRM_NUM_DBG-2][blkRow*Hnum + blkCol];
+				diff_blk_matrix = ABS(diff_blk_matrix);
+				Tf_diff_blk_luma[FRM_NUM_DBG -
+				1][blkRow*Hnum + blkCol] = diff_blk_matrix;
+
+				/*Debug print local value*/
+				if (Dbprint_lv == 1) {
+					if ((db_cnt%4) == 0) {
+						/*4 frames print once*/
+						pr_info(
+"diff_blk_matrix[%4d], bl_value_map[%4d], Tf_bl_matrix[%4d], frm_luma[%4d]\n",
+			diff_blk_matrix,
+			bl_value_map,
+			Tf_bl_matrix[FRM_NUM_DBG-2][blkRow*Hnum + blkCol],
+			Tf_luma_avg_frm[FRM_NUM_DBG - 1]);
+					}
+				}
+				if ((diff_blk_matrix > 50)) {
+					/*
+					if (Dbprint_lv == 1) {
+						if ((db_cnt%4) == 0) {
+							pr_info(
+			"if(diff_blk_matrix > 20){...}\n");
+						}
+					}
+					*/
+					if (bl_value_map >=
+			Tf_bl_matrix[FRM_NUM_DBG-2][blkRow*Hnum + blkCol]) {
+						bl_value_map =
+			Tf_bl_matrix[FRM_NUM_DBG-2][blkRow*Hnum + blkCol] +
+			((diff_blk_matrix + 16) >> 5); /*1/32*/
+
+						/*if (Dbprint_lv == 1) {
+							if ((db_cnt%4) == 0) {
+								pr_info(
+		"bl_value_map[%4d]((diff_blk_matrix + 16) >> 5)[%4d]\n",
+		bl_value_map, ((diff_blk_matrix + 16) >> 5));
+								}
+							}*/
+
+					} else {
+							bl_value_map =
+			Tf_bl_matrix[FRM_NUM_DBG-2][blkRow*Hnum + blkCol] -
+						((diff_blk_matrix + 16) >> 5);
+					}
+				} else {
+					bl_value_map = bl_value_map;
+				}
+				 if (bl_value_map > 4095)
+					bl_value_map = 4095;
+				 if (bl_value_map <= 0)
+					bl_value_map = 0;
+			}
+
+			/*Debug print local value*/
+			if (Dbprint_lv == 1) {
+				if ((db_cnt%4) == 0) {  /*4 frames print once*/
+					pr_info("Aftert bl_value_map[%4d]\n",
+						bl_value_map);
+				}
+			}
+
+			/* if (Tf_luma_avg_frm[FRM_NUM_DBG - 1] == 0)
+					bl_value_map = 0;
+			if (bl_value_map <= lit_base)
+				bl_value_map = lit_base; *//*default 127*/
+
+			remap_value = bl_value_map;
+			if (remap_value > 4095)
+				remap_value = 4095;
+			if (nPRM->reg_LD_BackLit_mode == 1) {
+				nPRM->BL_matrix[blkCol*Vnum + blkRow]  =
+								bl_value_map;
+			    Map_bl_matrix[blkCol*Vnum + blkRow] = remap_value;
+			} else {
+				nPRM->BL_matrix[blkRow*Hnum + blkCol]  =
+								bl_value_map;
+			    Map_bl_matrix[blkRow*Hnum + blkCol] = remap_value;
+			}
 
-			if (nPRM->reg_LD_BackLit_mode == 1)
-				nPRM->BL_matrix[blkCol*Vnum + blkRow]
-					= bl_value_map;
-			else
-				nPRM->BL_matrix[blkRow*Hnum + blkCol]
-					= bl_value_map;
 
 			/* Get the TF_BL_matrix */
-			FDat->TF_BL_matrix[blkRow*Hnum + blkCol]
-				= bl_value_map;
+			FDat->TF_BL_matrix[blkRow*Hnum + blkCol] = bl_value_map;
+			Tf_bl_matrix[FRM_NUM_DBG-1][blkRow*Hnum + blkCol] =
+								bl_value_map;
 
 			/* leave the Delayed version for next frame */
 			for (k = 0; k < 3; k++) {
@@ -621,14 +1002,31 @@ static void ld_fw_alg_frm(struct LDReg *nPRM, struct FW_DAT *FDat,
 			Bmax = MAX(Bmax, bl_value_map);
 		}
 	}
+	/*Debug print local value*/
+	if (Dbprint_lv == 1) {
+		if ((db_cnt%4) == 0) {  /*5 frames print once*/
+			for (i = 0; i < 8; i++)
+				pr_info("Tf_bl_matrix[blk_%d][%4d]\n", i,
+					Tf_bl_matrix[FRM_NUM_DBG-1][i]);
+				ldim_print_debug();
+		}
+	}
+	db_cnt++;
+	if (db_cnt > 4095)
+		db_cnt = 0;
 
 	/* set the DC reduction for the BL_modeling */
 	if (fw_LD_BLEst_ACmode == 0)
 		nPRM->reg_BL_matrix_AVG = 0;
-	else if (fw_LD_BLEst_ACmode == 1)
+	else if (fw_LD_BLEst_ACmode == 1) {
 		/*nPRM->reg_BL_matrix_AVG = (sum/fw_blk_num);*/
 		nPRM->reg_BL_matrix_AVG = ((sum/fw_blk_num) *
 			avg_gain + 2048)>>12;
+		Map_bl_matrix_AVG = ((sum/fw_blk_num) *
+			avg_gain + 2048)>>12;
+		Map_bl_matrix_Compensate = ((sum/fw_blk_num) *
+			avg_gain + 2048)>>12;
+	}
 	else if (fw_LD_BLEst_ACmode == 2)
 		nPRM->reg_BL_matrix_AVG = Bmin;
 	else if (fw_LD_BLEst_ACmode == 3)
@@ -1176,13 +1574,13 @@ static void ldim_update_matrix(unsigned int mode)
 
 static unsigned short ldim_test_matrix[LD_BLKREGNUM];
 static unsigned short local_ldim_matrix[LD_BLKREGNUM] = {0};
-/*static unsigned short local_ldim_matrix_2_spi[LD_BLKREGNUM] = {0};*/
 
 static void ldim_on_vs_spi(unsigned long data)
 {
 	unsigned int size;
 	unsigned short *mapping;
 	unsigned int i;
+	int ret;
 
 	if (ldim_on_flag == 0)
 		return;
@@ -1200,7 +1598,7 @@ static void ldim_on_vs_spi(unsigned long data)
 				local_ldim_matrix[i] =
 					(unsigned short)
 					nPRM.BL_matrix[mapping[i]];
-				ldim_driver.ldim_matrix_2_spi[i] =
+				ldim_driver.ldim_matrix_buf[i] =
 					ldim_test_matrix[mapping[i]];
 			}
 		} else {
@@ -1208,7 +1606,7 @@ static void ldim_on_vs_spi(unsigned long data)
 				local_ldim_matrix[i] =
 					(unsigned short)
 					nPRM.BL_matrix[mapping[i]];
-				ldim_driver.ldim_matrix_2_spi[i] =
+				ldim_driver.ldim_matrix_buf[i] =
 					(unsigned short)
 					(((nPRM.BL_matrix[mapping[i]] * litgain)
 					+ (LD_DATA_MAX / 2)) >> LD_DATA_DEPTH);
@@ -1221,20 +1619,37 @@ static void ldim_on_vs_spi(unsigned long data)
 				LDIMPR("%s: level update: 0x%lx\n",
 					__func__, litgain);
 			}
-		} else
+			for (i = 0; i < size; i++) {
+				local_ldim_matrix[i] =
+					(unsigned short)
+					nPRM.BL_matrix[mapping[i]];
+				ldim_driver.ldim_matrix_buf[i] =
+					(unsigned short)(litgain);
+			}
+		} else {
+			if (ldim_driver.device_bri_check) {
+				ret = ldim_driver.device_bri_check();
+				if (ret) {
+					if (ldim_debug_print) {
+						LDIMERR(
+						"%s: device_bri_check error\n",
+						__func__);
+					}
+					ldim_level_update = 1;
+				}
+			}
 			return;
-		for (i = 0; i < size; i++) {
-			local_ldim_matrix[i] =
-				(unsigned short)nPRM.BL_matrix[mapping[i]];
-			ldim_driver.ldim_matrix_2_spi[i] =
-				(unsigned short)(litgain);
 		}
 	}
 
-	/* set_bri_for_channels(ldim_driver.ldim_matrix_2_spi); */
+	/* set_bri_for_channels(ldim_driver.ldim_matrix_buf); */
 	if (ldim_driver.device_bri_update) {
-		ldim_driver.device_bri_update(ldim_driver.ldim_matrix_2_spi,
+		ldim_driver.device_bri_update(ldim_driver.ldim_matrix_buf,
 			size);
+		if (ldim_driver.static_pic_flag == 1) {
+			ldim_get_matrix_info_6();
+			ldim_dump_histgram();
+		}
 	} else {
 		LDIMERR("%s: device_bri_update is null\n", __func__);
 	}
@@ -1380,7 +1795,7 @@ static void ldim_on_vs(void)
 		for (i = 0; i < (ldim_blk_row * ldim_blk_col); i++) {
 			local_ldim_matrix[i] = nPRM.BL_matrix[
 				ldim_config.bl_mapping[i]];
-			ldim_driver.ldim_matrix_2_spi[i] = (unsigned short)
+			ldim_driver.ldim_matrix_buf[i] = (unsigned short)
 				(((nPRM.BL_matrix[ldim_config.bl_mapping[i]] *
 				litgain) + 2048) >> 12);
 		}
@@ -1388,7 +1803,7 @@ static void ldim_on_vs(void)
 		/* set_bri_for_channels(local_ldim_matrix_2_spi); */
 		if (ldim_driver.device_bri_update) {
 			ldim_driver.device_bri_update(
-				ldim_driver.ldim_matrix_2_spi,
+				ldim_driver.ldim_matrix_buf,
 				(ldim_blk_row * ldim_blk_col));
 		} else {
 			LDIMPR("%s: device_bri_update is null\n", __func__);
@@ -1403,23 +1818,46 @@ static void ldim_on_vs(void)
 }
 #endif
 
-static void ldim_get_matrix_info_1(void)
+static void ldim_print_debug(void)
 {
-	unsigned int i, j;
+	unsigned int k, i, j;
 	unsigned int local_ldim_matrix_t[LD_BLKREGNUM] = {0};
 
 	LDIMPR("%s:\n", __func__);
+	pr_info("512step:[luma_avg_frm][Diff_avg_frm:]\n");
+	for (i = 0; i < FRM_NUM_DBG; i++)
+		pr_info("Tf_luma_avg_frm[%4d] =[%4d][%4d]\n", i,
+			Tf_luma_avg_frm[i], Tf_diff_frm_luma[i]);
+
 	memcpy(&local_ldim_matrix_t[0], &FDat.TF_BL_matrix_2[0],
 		ldim_blk_col*ldim_blk_row*sizeof(unsigned int));
 
-	for (i = 0; i < ldim_blk_row; i++) {
-		for (j = 0; j < ldim_blk_col; j++) {
-			pr_info("0x%x\t",
-				local_ldim_matrix_t[ldim_blk_col*i+j]);
+	pr_info("512step: ");
+	for (k = 0; k < FRM_NUM_DBG; k++) {
+		pr_info("Frame[%d][Luma_avg][Diff_blk_luma][bl_matrix]:\n", k);
+		for (i = 0; i < ldim_blk_row; i++) {
+			for (j = 0; j < ldim_blk_col; j++) {
+				pr_info("[%4d][%4d][%4d]\n",
+					Tf_blkLuma_avg[k][ldim_blk_col*i+j],
+					Tf_diff_blk_luma[k][ldim_blk_col*i+j],
+					Tf_bl_matrix[k][ldim_blk_col*i+j]);
+			}
+			pr_info("\n");
+			udelay(10000);
 		}
-		pr_info("\n");
-		udelay(10000);
 	}
+	/* for (k = 0; k < FRM_NUM_DBG; k++) {
+		pr_info("Frame[%d][bl_matrix_map][bl_matrix]:\n", k);
+		for (i = 0; i < ldim_blk_row; i++) {
+			for (j = 0; j < ldim_blk_col; j++) {
+				pr_info("[%4d][%4d]\n",
+					Tf_bl_matrix_map[k][ldim_blk_col*i+j],
+					Tf_bl_matrix[k][ldim_blk_col*i+j]);
+			 }
+			pr_info("\n");
+			udelay(10000);
+		 }
+	 }*/
 }
 static void ldim_get_matrix_info_2(void)
 {
@@ -1527,7 +1965,7 @@ static void ldim_get_matrix(unsigned int *data, unsigned int reg_sel)
 	if (reg_sel == 0)
 		LDIM_RD_BASE_LUT(REG_LD_BLK_VIDX_BASE, data , 16, 32);
 	else if (reg_sel == 2)
-		ldim_get_matrix_info_1();
+		ldim_print_debug();
 	else if (reg_sel == 3)
 		ldim_get_matrix_info_2();
 	else if (reg_sel == 4)
@@ -1553,13 +1991,10 @@ static void ldim_get_matrix_info(void)
 	unsigned short local_ldim_matrix_spi_t[LD_BLKREGNUM] = {0};
 
 	memcpy(&local_ldim_matrix_t[0], &local_ldim_matrix[0],
-		ldim_blk_col*ldim_blk_row*sizeof(unsigned int));
-	/*memcpy(&local_ldim_matrix_spi_t[0],
-		&local_ldim_matrix_2_spi[0],
-		ldim_blk_col*ldim_blk_row*sizeof(unsigned int));*/
+		ldim_blk_col*ldim_blk_row*sizeof(unsigned short));
 	memcpy(&local_ldim_matrix_spi_t[0],
-		&ldim_driver.ldim_matrix_2_spi[0],
-		ldim_blk_col*ldim_blk_row*sizeof(unsigned int));
+		&ldim_driver.ldim_matrix_buf[0],
+		ldim_blk_col*ldim_blk_row*sizeof(unsigned short));
 	/*printk("%s and spi info:\n", __func__);*/
 	LDIMPR("%s and spi info:\n", __func__);
 	for (i = 0; i < ldim_blk_row; i++) {
@@ -1570,7 +2005,15 @@ static void ldim_get_matrix_info(void)
 		pr_info("\n");
 		udelay(10000);
 	}
-	pr_info("\n");
+	LDIMPR("%s: transfer_matrix:\n", __func__);
+	for (i = 0; i < ldim_blk_row; i++) {
+		for (j = 0; j < ldim_blk_col; j++) {
+			pr_info("0x%x\t", local_ldim_matrix_spi_t
+				[ldim_blk_col*i+j]);
+		}
+		pr_info("\n");
+		udelay(10000);
+	}
 	pr_info("\n");
 
 	/*printk("ldim_stts_start_time = %d, ldim_stts_end_time = %d, :\n",);*/
@@ -1624,12 +2067,16 @@ static void ldim_func_ctrl(int status)
 		ldim_alg_en = 0;
 		/* disable remap */
 		/*ldim_remap_ctrl(0);*/
+
+		/* refresh system brightness */
+		ldim_level_update = 1;
 	}
 }
 
 static int ldim_on_init(void)
 {
 	int ret = 0;
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
 
 	LDIMPR("%s\n", __func__);
 
@@ -1642,7 +2089,7 @@ static int ldim_on_init(void)
 	ldim_func_ctrl(0); /* default disable ldim function */
 
 	if (ldim_driver.pinmux_ctrl)
-		ldim_driver.pinmux_ctrl(1);
+		ldim_driver.pinmux_ctrl(ldim_drv->ldev_conf->pinmux_name, 1);
 	ldim_on_flag = 1;
 	ldim_level_update = 1;
 
@@ -1685,73 +2132,19 @@ static int ldim_set_level(unsigned int level)
 	struct aml_bl_drv_s *bl_drv = aml_bl_get_driver();
 	unsigned int level_max, level_min;
 
+	ldim_brightness_level = level;
 	level_max = bl_drv->bconf->level_max;
 	level_min = bl_drv->bconf->level_min;
 
-	level = ((level - level_min) * LD_DATA_MAX) / (level_max - level_min);
-	level &= LD_DATA_MAX;
+	level = ((level - level_min) * (LD_DATA_MAX - ldim_data_min)) /
+		(level_max - level_min) + ldim_data_min;
+	level &= 0xfff;
 	litgain = (unsigned long)level;
 	ldim_level_update = 1;
 
 	return ret;
 }
 
-static void ldim_config_print(void)
-{
-	struct bl_pwm_config_s *ld_pwm;
-
-	LDIMPR("%s:\n", __func__);
-	pr_info("valid_flag            = %d\n"
-		"dev_index             = %d\n",
-		ldim_driver.valid_flag,
-		ldim_driver.dev_index);
-	if (ldim_driver.ldev_conf) {
-		ld_pwm = &ldim_driver.ldev_conf->pwm_config;
-		pr_info("dev_name              = %s\n"
-			"cs_hold_delay         = %d\n"
-			"cs_clk_delay          = %d\n"
-			"en_gpio               = %d\n"
-			"en_gpio_on            = %d\n"
-			"en_gpio_off           = %d\n"
-			"lamp_err_gpio         = %d\n"
-			"fault_check           = %d\n"
-			"write_check           = %d\n"
-			"dim_min               = 0x%03x\n"
-			"dim_max               = 0x%03x\n"
-			"cmd_size              = %d\n",
-			ldim_driver.ldev_conf->name,
-			ldim_driver.ldev_conf->cs_hold_delay,
-			ldim_driver.ldev_conf->cs_clk_delay,
-			ldim_driver.ldev_conf->en_gpio,
-			ldim_driver.ldev_conf->en_gpio_on,
-			ldim_driver.ldev_conf->en_gpio_off,
-			ldim_driver.ldev_conf->lamp_err_gpio,
-			ldim_driver.ldev_conf->fault_check,
-			ldim_driver.ldev_conf->write_check,
-			ldim_driver.ldev_conf->dim_min,
-			ldim_driver.ldev_conf->dim_max,
-			ldim_driver.ldev_conf->cmd_size);
-		if (ld_pwm->pwm_port < BL_PWM_MAX) {
-			pr_info("pwm_port              = %d\n"
-				"pwm_pol               = %d\n"
-				"pwm_freq              = %d\n"
-				"pwm_duty              = %d%%\n"
-				"pinmux_flag           = %d\n",
-				ld_pwm->pwm_port, ld_pwm->pwm_method,
-				ld_pwm->pwm_freq, ld_pwm->pwm_duty,
-				ld_pwm->pinmux_flag);
-		}
-	} else {
-		pr_info("device config is null\n");
-	}
-	pr_info("ldim_on_flag          = %d\n"
-		"ldim_func_en          = %d\n"
-		"ldim_remap_en         = %d\n"
-		"ldim_test_en          = %d\n\n",
-		ldim_on_flag, ldim_func_en,
-		ldim_matrix_update_en, ldim_test_en);
-}
-
 static void ldim_test_ctrl(int flag)
 {
 	if (flag) /* when enable lcd bist pattern, bypass ldim function */
@@ -1764,18 +2157,21 @@ static void ldim_test_ctrl(int flag)
 static struct aml_ldim_driver_s ldim_driver = {
 	.valid_flag = 0, /* default invalid, active when bl_ctrl_method=ldim */
 	.dev_index = 0,
+	.static_pic_flag = 0,
 	.ldev_conf = NULL,
-	.ldim_matrix_2_spi = NULL,
+	.ldim_matrix_buf = NULL,
 	.init = ldim_on_init,
 	.power_on = ldim_power_on,
 	.power_off = ldim_power_off,
 	.set_level = ldim_set_level,
-	.config_print = ldim_config_print,
 	.test_ctrl = ldim_test_ctrl,
+	.config_print = NULL,
 	.pinmux_ctrl = NULL,
+	.pwm_vs_update = NULL,
 	.device_power_on = NULL,
 	.device_power_off = NULL,
 	.device_bri_update = NULL,
+	.device_bri_check = NULL,
 };
 
 struct aml_ldim_driver_s *aml_ldim_get_driver(void)
@@ -1817,11 +2213,19 @@ static ssize_t ldim_attr_show(struct class *cla,
 	len += sprintf(buf+len,
 	"echo fw_LD_ThTF_l 32 > /sys/class/aml_ldim/attr\n");
 	len += sprintf(buf+len,
-	"echo avg_gain_sf 128 > /sys/class/aml_ldim/attr\n");
+	"echo cal_cur_en 0 > /sys/class/aml_ldim/attr\n");
+	len += sprintf(buf+len,
+	"echo transmit_gain 1 > /sys/class/aml_ldim/attr\n");
+	/* len += sprintf(buf+len,
+	"echo slp_gain 28 > /sys/class/aml_ldim/attr\n");*/
+
 	len += sprintf(buf+len,
 	"echo rgb_base 128 > /sys/class/aml_ldim/attr\n");
 
 	len += sprintf(buf+len,
+	"echo Dbprint_lv 128 > /sys/class/aml_ldim/attr\n");
+
+	len += sprintf(buf+len,
 	"echo avg_gain_sf_l 128 > /sys/class/aml_ldim/attr\n");
 	len += sprintf(buf+len,
 	"echo dif_gain_sf_l 0 > /sys/class/aml_ldim/attr\n");
@@ -1833,6 +2237,19 @@ static ssize_t ldim_attr_show(struct class *cla,
 	"echo lpf_gain 0 > /sys/class/aml_ldim/attr\n");
 	len += sprintf(buf+len,
 	"echo lpf_res 0 > /sys/class/aml_ldim/attr\n");
+
+	len += sprintf(buf+len,
+	"echo Sf_bypass 0 > /sys/class/aml_ldim/attr\n");
+	len += sprintf(buf+len,
+	"echo Boost_light_bypass 0 > /sys/class/aml_ldim/attr\n");
+	len += sprintf(buf+len,
+	"echo Lpf_bypass 0 > /sys/class/aml_ldim/attr\n");
+	len += sprintf(buf+len,
+	"echo Tf_bypass 0 > /sys/class/aml_ldim/attr\n");
+	len += sprintf(buf+len,
+	"echo Ld_remap_bypass 0 > /sys/class/aml_ldim/attr\n");
+
+
 #endif
 	len += sprintf(buf+len,
 	"echo litgain 4096 > /sys/class/aml_ldim/attr\n");
@@ -2018,6 +2435,14 @@ static ssize_t ldim_attr_store(struct class *cla,
 		ldim_func_en = 0;
 		ldim_func_ctrl(0);
 		pr_info("**************ldim disable ok*************\n");
+	} else if (!strcmp(parm[0], "data_min")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &val1) < 0)
+				return -EINVAL;
+		}
+		ldim_data_min = (unsigned int)val1;
+		ldim_set_level(ldim_brightness_level);
+		pr_info("**********ldim brightness data_min update*********\n");
 	} else if (!strcmp(parm[0], "ldim_info")) {
 		pr_info("ldim_on_flag          = %d\n"
 			"ldim_func_en          = %d\n"
@@ -2026,10 +2451,13 @@ static ssize_t ldim_attr_store(struct class *cla,
 			"ldim_matrix_update_en = %d\n"
 			"ldim_alg_en           = %d\n"
 			"ldim_top_en           = %d\n"
-			"ldim_hist_en          = %d\n",
+			"ldim_hist_en          = %d\n"
+			"ldim_data_min         = %d\n"
+			"ldim_data_max         = %d\n",
 			ldim_on_flag, ldim_func_en, ldim_test_en,
 			ldim_avg_update_en, ldim_matrix_update_en,
-			ldim_alg_en, ldim_top_en, ldim_hist_en);
+			ldim_alg_en, ldim_top_en, ldim_hist_en,
+			ldim_data_min, LD_DATA_MAX);
 		pr_info("nPRM.reg_LD_BLK_Hnum   = %d\n"
 			"nPRM.reg_LD_BLK_Vnum   = %d\n"
 			"nPRM.reg_LD_pic_RowMax = %d\n"
@@ -2121,12 +2549,18 @@ static ssize_t ldim_attr_store(struct class *cla,
 				return -EINVAL;
 		}
 		pr_info("set fw_LD_ThTF_l=%ld\n", fw_LD_ThTF_l);
-	} else if (!strcmp(parm[0], "avg_gain_sf")) {
+	} else if (!strcmp(parm[0], "cal_cur_en")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &cal_cur_en) < 0)
+				return -EINVAL;
+		}
+		pr_info("set cal_cur_en=%ld\n", cal_cur_en);
+	} else if (!strcmp(parm[0], "transmit_gain")) {
 		if (parm[1] != NULL) {
-			if (kstrtoul(parm[1], 10, &avg_gain_sf) < 0)
+			if (kstrtoul(parm[1], 10, &transmit_gain) < 0)
 				return -EINVAL;
 		}
-		pr_info("set avg_gain_sf=%ld\n", avg_gain_sf);
+		pr_info("set transmit_gain=%ld\n", transmit_gain);
 	} else if (!strcmp(parm[0], "rgb_base")) {
 		if (parm[1] != NULL) {
 			if (kstrtoul(parm[1], 10, &rgb_base) < 0)
@@ -2169,8 +2603,82 @@ static ssize_t ldim_attr_store(struct class *cla,
 				return -EINVAL;
 		}
 		pr_info("set lpf_res=%ld\n", lpf_res);
+	} else if (!strcmp(parm[0], "Sf_bypass")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &Sf_bypass) < 0)
+				return -EINVAL;
+		}
+		pr_info("set Sf_bypass=%ld\n", Sf_bypass);
+	} else if (!strcmp(parm[0], "Boost_light_bypass")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &Boost_light_bypass) < 0)
+				return -EINVAL;
+		}
+		pr_info("set Boost_light_bypass=%ld\n", Boost_light_bypass);
+	} else if (!strcmp(parm[0], "Lpf_bypass")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &Lpf_bypass) < 0)
+				return -EINVAL;
+		}
+		pr_info("set Lpf_bypass=%ld\n", Lpf_bypass);
+	} else if (!strcmp(parm[0], "Tf_bypass")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &Tf_bypass) < 0)
+				return -EINVAL;
+		}
+		pr_info("set Tf_bypass=%ld\n", Tf_bypass);
+	} else if (!strcmp(parm[0], "Ld_remap_bypass")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &Ld_remap_bypass) < 0)
+				return -EINVAL;
+		}
+		pr_info("set Ld_remap_bypass=%ld\n", Ld_remap_bypass);
+	} else if (!strcmp(parm[0], "slp_gain")) {
+		unsigned int slop_gain;
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &val1) < 0)
+				return -EINVAL;
+		}
+		slop_gain = (unsigned int)val1;
+		ldim_bl_remap_curve(slop_gain);
+		ldim_bl_remap_curve_print();
+		pr_info("set slp_gain=%d\n", slop_gain);
+	} else if (!strcmp(parm[0], "incr_con_en")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &val1) < 0)
+				return -EINVAL;
+		}
+		incr_con_en = (unsigned int)val1;
+		pr_info("set incr_con_en=%d\n", incr_con_en);
+	} else if (!strcmp(parm[0], "ov_gain")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &val1) < 0)
+				return -EINVAL;
+		}
+		ov_gain = (unsigned int)val1;
+		pr_info("set ov_gain=%d\n", ov_gain);
+	} else if (!strcmp(parm[0], "incr_dif_gain")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &val1) < 0)
+				return -EINVAL;
+		}
+		incr_dif_gain = (unsigned int)val1;
+		pr_info("set incr_dif_gain=%d\n", incr_dif_gain);
+	} else if (!strcmp(parm[0], "logo_en")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &val1) < 0)
+				return -EINVAL;
+		}
+		logo_en = (unsigned int)val1;
+		pr_info("set logo_en=%d\n", logo_en);
+	} else if (!strcmp(parm[0], "test_static_pic")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &val1) < 0)
+				return -EINVAL;
+		}
+		test_static_pic = (unsigned int)val1;
+		pr_info("set test_static_pic=%d\n", test_static_pic);
 	}
-
 #endif
 	else if (!strcmp(parm[0], "litgain")) {
 		if (parm[1] != NULL) {
@@ -2184,6 +2692,12 @@ static ssize_t ldim_attr_store(struct class *cla,
 				return -EINVAL;
 		}
 		pr_info("set boost_gain=%ld\n", boost_gain);
+	} else if (!strcmp(parm[0], "Dbprint_lv")) {
+		if (parm[1] != NULL) {
+			if (kstrtoul(parm[1], 10, &Dbprint_lv) < 0)
+				return -EINVAL;
+		}
+		pr_info("set Dbprint_lv=%ld\n", Dbprint_lv);
 	} else if (!strcmp(parm[0], "avg_gain")) {
 		if (parm[1] != NULL) {
 			if (kstrtoul(parm[1], 10, &avg_gain) < 0)
@@ -2580,7 +3094,13 @@ static ssize_t ldim_attr_store(struct class *cla,
 		LDIM_Initial(3840, 2160, 16, 24, 2, 1, 0);
 		pr_info("**************ldim curve_15 ok*************\n");
 	} else if (!strcmp(parm[0], "info")) {
-		ldim_config_print();
+		ldim_driver.config_print();
+		pr_info("ldim_on_flag          = %d\n"
+			"ldim_func_en          = %d\n"
+			"ldim_remap_en         = %d\n"
+			"ldim_test_en          = %d\n\n",
+			ldim_on_flag, ldim_func_en,
+			ldim_matrix_update_en, ldim_test_en);
 	} else
 		pr_info("no support cmd!!!\n");
 
@@ -2708,6 +3228,8 @@ int aml_ldim_probe(struct platform_device *pdev)
 	unsigned int ret = 0;
 	unsigned int i;
 
+	ldim_brightness_level = 0;
+	ldim_data_min = LD_DATA_MIN;
 	ldim_on_flag = 0;
 	ldim_func_en = 0;
 	ldim_func_bypass = 0;
@@ -2728,10 +3250,10 @@ int aml_ldim_probe(struct platform_device *pdev)
 	nPRM.bin_2 = &bin_2[0];
 	aml_ldim_get_config(&ldim_config, &pdev->dev);
 
-	ldim_driver.ldim_matrix_2_spi = kzalloc(
-		(sizeof(unsigned char) * LD_BLKREGNUM), GFP_KERNEL);
-	if (ldim_driver.ldim_matrix_2_spi == NULL) {
-		LDIMERR("ldim_driver ldim_matrix_2_spi malloc error\n");
+	ldim_driver.ldim_matrix_buf = kzalloc(
+		(sizeof(unsigned short) * LD_BLKREGNUM), GFP_KERNEL);
+	if (ldim_driver.ldim_matrix_buf == NULL) {
+		LDIMERR("ldim_driver ldim_matrix_buf malloc error\n");
 		return -1;
 	}
 
@@ -2834,7 +3356,7 @@ int aml_ldim_remove(void)
 	kfree(FDat.TF_BL_matrix_2);
 	kfree(FDat.last_STA1_MaxRGB);
 	kfree(FDat.TF_BL_alpha);
-	kfree(ldim_driver.ldim_matrix_2_spi);
+	kfree(ldim_driver.ldim_matrix_buf);
 
 	free_irq(RDMA_LDIM_INT, (void *)"rdma_ldim");
 	free_irq(VIU_VSYNC_INT, (void *)"ldim_vsync");
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ldim_func.c b/drivers/amlogic/display/backlight/aml_ldim/ldim_func.c
index b481e6a..40a9ea3 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/ldim_func.c
+++ b/drivers/amlogic/display/backlight/aml_ldim/ldim_func.c
@@ -678,62 +678,179 @@ void LD_LUTInit(struct LDReg *Reg)
 }
 #endif
 
+
+
+
+
+#if 1
+
 static int Remap_lut[][32] = {
-	{128, 256, 384, 512, 640, 768, 896, 1024, 1152, 1280, 1408, 1536,
-		1664, 1792, 1920, 2048, 2176, 2304, 2432, 2560, 2688, 2816,
-		2944, 3072, 3200, 3328, 3456, 3584, 3712, 3840, 3968, 4095,},
-	{137, 273, 410, 546, 683, 819, 956, 1092, 1229, 1365, 1502, 1638,
-		1775, 1911, 2048, 2185, 2321, 2458, 2594, 2731, 2867, 3004,
-		3140, 3277, 3413, 3550, 3686, 3775, 3855, 3935, 4015, 4095,},
-	{146, 293, 439, 585, 731, 878, 1024, 1170, 1317, 1463, 1609, 1755,
-		1902, 2048, 2194, 2341, 2487, 2633, 2779, 2926, 3072, 3218,
-		3365, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
-	{158, 315, 473, 630, 788, 945, 1103, 1260, 1418, 1575, 1733, 1890,
-		2048, 2206, 2363, 2521, 2678, 2836, 2993, 3135, 3215, 3295,
-		3375, 3455, 3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095,},
+{ 128,  256,  384,  512,  640,  768,  896, 1024,
+1152, 1280, 1408, 1536, 1664, 1792, 1920, 2048,
+2176, 2304, 2432, 2560, 2688, 2816, 2944, 3072,
+3200, 3328, 3456, 3584, 3712, 3840, 3968, 4095, },
+{ 137,  273,  410,  546,  683,  819,  956, 1092,
+1229, 1365, 1502, 1638, 1775, 1911, 2048, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 146,  293,  439,  585,  731,  878, 1024, 1170,
+1317, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 158,  315,  473,  630,  788,  945, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 171,  341,  512,  683,  853,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 186,  372,  559,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 205,  410,  614,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 228,  455,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 256,  495,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 293,  495,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 341,  495,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 375,  495,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 375,  495,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 375,  495,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 375,  495,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
+{ 375,  495,  615,  735,  855,  975, 1095, 1215,
+1335, 1455, 1575, 1695, 1815, 1935, 2055, 2175,
+2295, 2415, 2535, 2655, 2775, 2895, 3015, 3135,
+3255, 3375, 3495, 3615, 3735, 3855, 3975, 4095, },
 };
+	/*
+	{ 128,  256,  384,  512,  640,  768,  896, 1024,
+	  1152, 1280, 1408, 1536, 1664, 1792, 1920, 2048,
+	  2176, 2304, 2432, 2560, 2688, 2816, 2944, 3072,
+	  3200, 3328, 3456, 3584, 3712, 3840, 3968, 4095, },
+	{ 137,  273,  410,  546,  683,  819,  956, 1092,
+	  1229, 1365, 1502, 1638, 1775, 1911, 2048, 2185,
+	  2321, 2458, 2594, 2731, 2867, 3004, 3140, 3277,
+	  3413, 3550, 3686, 3775, 3855, 3935, 4015, 4095, },
+	{ 146,  293,  439,  585,  731,  878, 1024, 1170,
+	  1317, 1463, 1609, 1755, 1902, 2048, 2194, 2341,
+	  2487, 2633, 2779, 2926, 3072, 3218, 3365, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+	{ 158,  315,  473,  630,  788,  945, 1103, 1260,
+	  1418, 1575, 1733, 1890, 2048, 2206, 2363, 2521,
+	  2678, 2836, 2993, 3135, 3215, 3295, 3375, 3455,
+	  3535, 3615, 3695, 3775, 3855, 3935, 4015, 4095, },
+};*/
+
+#if 0
+void LD_LUTInit(struct LDReg *Reg)
+{
+	int k = 0;
+	int t = 0;
+	int tmp = 0;
+
+	/* Emulate the FW to set the LUTs */
+	for (k = 0; k < 16; k++) {
+		/*set the LUT to be inverse of the Lit_value,*/
+		/* lit_idx distribute equal space, set by FW */
+		Reg->X_idx[0][k] = 4095 - 256*k;
+		Reg->X_nrm[0][k] = 8;
+		for (t = 0; t < 32; t++) {
+			/* May be different from Matlab when (16-k)
+			is an odd integer */
+			tmp = Round(64*(t + 1)*32, (16 - k));
+			if (tmp > 4095)
+				tmp = 4095;
+
+			Reg->X_lut[0][k][t] = tmp;
+			Reg->X_lut[1][k][t] = tmp;
+			Reg->X_lut[2][k][t] = tmp;
+		}
+	}
+}
+#else
 
 void LD_LUTInit(struct LDReg *Reg)
 {
 	int k = 0;
 	int t = 0;
 
+
 	/* Emulate the FW to set the LUTs */
 	for (k = 0; k < 16; k++) {
 		/*set the LUT to be inverse of the Lit_value,*/
@@ -745,9 +862,19 @@ void LD_LUTInit(struct LDReg *Reg)
 			Reg->X_lut[0][k][t] = Remap_lut[k][t];
 			Reg->X_lut[1][k][t] = Remap_lut[k][t];
 			Reg->X_lut[2][k][t] = Remap_lut[k][t];
+
 		}
 	}
 }
+#endif
+
+#endif
+
+
+
+
+
+
 
 #if 1
 void LD_ConLDReg(struct LDReg *Reg)
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ob3350_bl.c b/drivers/amlogic/display/backlight/aml_ldim/ob3350_bl.c
new file mode 100644
index 0000000..e10b895
--- /dev/null
+++ b/drivers/amlogic/display/backlight/aml_ldim/ob3350_bl.c
@@ -0,0 +1,206 @@
+/*
+ * drivers/amlogic/display/backlight/aml_ldim/ob3350_bl.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/amlogic/vout/aml_ldim.h>
+#include <linux/amlogic/vout/aml_bl.h>
+#include "ldim_drv.h"
+#include "ldim_dev_drv.h"
+
+static int ob3350_on_flag;
+
+struct ob3350 {
+	struct class cls;
+	unsigned char cur_addr;
+};
+
+struct ob3350 *bl_ob3350;
+
+static int ob3350_hw_init_on(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
+		ldim_drv->ldev_conf->en_gpio_on);
+	mdelay(2);
+	ldim_set_duty_pwm(&(ldim_drv->ldev_conf->pwm_config));
+	ldim_drv->pinmux_ctrl(ldim_drv->ldev_conf->pinmux_name, 1);
+	mdelay(20);
+
+	return 0;
+}
+
+static int ob3350_hw_init_off(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_drv->pinmux_ctrl(ldim_drv->ldev_conf->pinmux_name, 0);
+	mdelay(100);
+	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
+		ldim_drv->ldev_conf->en_gpio_off);
+
+	return 0;
+}
+
+static unsigned int ob3350_get_value(unsigned int level)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	unsigned int val;
+	unsigned int dim_max, dim_min;
+
+	dim_max = ldim_drv->ldev_conf->dim_max;
+	dim_min = ldim_drv->ldev_conf->dim_min;
+
+	val = dim_min + ((level * (dim_max - dim_min)) / LD_DATA_MAX);
+
+	return val;
+}
+
+static int ob3350_smr(unsigned short *buf, unsigned char len)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	unsigned short val;
+
+	if (ob3350_on_flag == 0) {
+		if (ldim_debug_print)
+			LDIMPR("%s: on_flag=%d\n", __func__, ob3350_on_flag);
+		return 0;
+		}
+
+	if (len != 1) {
+		LDIMERR("%s: data len %d invalid\n", __func__, len);
+		return -1;
+	}
+
+	val = ob3350_get_value(buf[0]);
+
+	ldim_drv->ldev_conf->pwm_config.pwm_duty = val;
+	ldim_set_duty_pwm(&(ldim_drv->ldev_conf->pwm_config));
+
+	return 0;
+}
+
+static int ob3350_power_on(void)
+{
+	if (ob3350_on_flag) {
+		LDIMPR("%s: ob3350 is already on, exit\n", __func__);
+		return 0;
+	}
+
+	ob3350_hw_init_on();
+	ob3350_on_flag = 1;
+
+	LDIMPR("%s: ok\n", __func__);
+	return 0;
+}
+
+static int ob3350_power_off(void)
+{
+	ob3350_on_flag = 0;
+	ob3350_hw_init_off();
+
+	LDIMPR("%s: ok\n", __func__);
+	return 0;
+}
+
+static ssize_t ob3350_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	int ret = 0;
+
+	if (!strcmp(attr->attr.name, "status")) {
+		ret = sprintf(buf, "ob3350 status:\n"
+				"dev_index      = %d\n"
+				"on_flag        = %d\n"
+				"en_on          = %d\n"
+				"en_off         = %d\n"
+				"dim_max        = %d\n"
+				"dim_min        = %d\n"
+				"pwm_duty       = %d%%\n\n",
+				ldim_drv->dev_index, ob3350_on_flag,
+				ldim_drv->ldev_conf->en_gpio_on,
+				ldim_drv->ldev_conf->en_gpio_off,
+				ldim_drv->ldev_conf->dim_max,
+				ldim_drv->ldev_conf->dim_min,
+				ldim_drv->ldev_conf->pwm_config.pwm_duty);
+	}
+
+	return ret;
+}
+
+static struct class_attribute ob3350_class_attrs[] = {
+	__ATTR(status, S_IRUGO | S_IWUSR, ob3350_show, NULL),
+	__ATTR_NULL
+};
+
+static int ob3350_ldim_driver_update(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_drv->device_power_on = ob3350_power_on;
+	ldim_drv->device_power_off = ob3350_power_off;
+	ldim_drv->device_bri_update = ob3350_smr;
+
+	return 0;
+}
+
+int ldim_dev_ob3350_probe(void)
+{
+	int ret;
+
+	ob3350_on_flag = 0;
+	bl_ob3350 = kzalloc(sizeof(struct ob3350), GFP_KERNEL);
+	if (bl_ob3350 == NULL) {
+		pr_err("malloc bl_ob3350 failed\n");
+		return -1;
+	}
+
+	ob3350_ldim_driver_update();
+
+	bl_ob3350->cls.name = kzalloc(10, GFP_KERNEL);
+	sprintf((char *)bl_ob3350->cls.name, "ob3350");
+	bl_ob3350->cls.class_attrs = ob3350_class_attrs;
+	ret = class_register(&bl_ob3350->cls);
+	if (ret < 0)
+		pr_err("register ob3350 class failed\n");
+
+	ob3350_on_flag = 1; /* default enable in uboot */
+	LDIMPR("%s ok\n", __func__);
+
+	return ret;
+}
+
+int ldim_dev_ob3350_remove(void)
+{
+	kfree(bl_ob3350);
+	bl_ob3350 = NULL;
+
+	return 0;
+}
+
diff --git a/drivers/amlogic/display/ge2d/ge2d_main.c b/drivers/amlogic/display/ge2d/ge2d_main.c
index 3b0b585..9094cc7 100644
--- a/drivers/amlogic/display/ge2d/ge2d_main.c
+++ b/drivers/amlogic/display/ge2d/ge2d_main.c
@@ -19,7 +19,6 @@
 /* Linux Headers */
 #include <linux/types.h>
 #include <linux/interrupt.h>
-#include <linux/compat.h>
 #include <linux/fb.h>
 #include <linux/list.h>
 #include <linux/uaccess.h>
@@ -32,7 +31,9 @@
 #include <linux/of_fdt.h>
 #include <linux/reset.h>
 #include <linux/clk.h>
-
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
 /* Amlogic Headers */
 #include <linux/amlogic/ge2d/ge2d.h>
 #include <linux/amlogic/ge2d/ge2d_cmd.h>
@@ -123,10 +124,13 @@ static ssize_t log_level_store(struct class *cla,
 static bool command_valid(unsigned int cmd)
 {
 	bool ret = false;
-
-	ret = (cmd <= GE2D_STRETCHBLIT_NOALPHA_NOBLOCK &&
+#ifdef CONFIG_COMPAT
+	ret = (cmd <= GE2D_CONFIG_EX32 &&
 		cmd >= GE2D_ANTIFLICKER_ENABLE);
-
+#else
+	ret = (cmd <= GE2D_CONFIG_EX &&
+		cmd >= GE2D_ANTIFLICKER_ENABLE);
+#endif
 	return ret;
 }
 
@@ -149,22 +153,61 @@ static int ge2d_open(struct inode *inode, struct file *file)
 static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 {
 	struct ge2d_context_s *context = NULL;
-	void __user *argp = (void __user *)args;
 	struct config_para_s ge2d_config;
 	struct ge2d_para_s para;
 	struct config_para_ex_s ge2d_config_ex;
 	int ret = 0;
+#ifdef CONFIG_COMPAT
+	struct compat_config_para_s __user *uf;
+	int r = 0;
+	int i, j;
+#endif
+	void __user *argp = (void __user *)args;
 
 	if (!command_valid(cmd))
 		return -1;
 
 	context = (struct ge2d_context_s *)filp->private_data;
+	memset(&ge2d_config, 0, sizeof(struct config_para_s));
 	switch (cmd) {
 	case GE2D_CONFIG:
 	case GE2D_SRCCOLORKEY:
 		ret = copy_from_user(&ge2d_config,
 				argp, sizeof(struct config_para_s));
 		break;
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG32:
+		uf = (struct compat_config_para_s *)argp;
+		r = get_user(ge2d_config.src_dst_type, &uf->src_dst_type);
+		r |= get_user(ge2d_config.alu_const_color,
+			&uf->alu_const_color);
+		r |= get_user(ge2d_config.src_format, &uf->src_format);
+		r |= get_user(ge2d_config.dst_format, &uf->dst_format);
+		for (i = 0; i < 4; i++) {
+			r |= get_user(ge2d_config.src_planes[i].addr,
+				&uf->src_planes[i].addr);
+			r |= get_user(ge2d_config.src_planes[i].w,
+				&uf->src_planes[i].w);
+			r |= get_user(ge2d_config.src_planes[i].h,
+				&uf->src_planes[i].h);
+		}
+		for (j = 0; j < 4; j++) {
+			r |= get_user(ge2d_config.dst_planes[j].addr,
+				&uf->dst_planes[j].addr);
+			r |= get_user(ge2d_config.dst_planes[j].w,
+				&uf->dst_planes[j].w);
+			r |= get_user(ge2d_config.dst_planes[j].h,
+				&uf->dst_planes[j].h);
+		}
+		r |= copy_from_user(&ge2d_config.src_key, &uf->src_key,
+			sizeof(struct src_key_ctrl_s));
+		if (r) {
+			pr_err("GE2D_CONFIG32 get parameter failed .\n");
+			return -EFAULT;
+		}
+
+		break;
+#endif
 	case GE2D_CONFIG_EX:
 		ret = copy_from_user(&ge2d_config_ex, argp,
 				sizeof(struct config_para_ex_s));
@@ -177,8 +220,12 @@ static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 		break;
 
 	}
+
 	switch (cmd) {
 	case GE2D_CONFIG:
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG32:
+#endif
 		ret = ge2d_context_config(context, &ge2d_config);
 		break;
 	case GE2D_CONFIG_EX:
diff --git a/drivers/amlogic/display/ge2d/ge2d_wq.c b/drivers/amlogic/display/ge2d/ge2d_wq.c
index 484723c..f29d5d1 100644
--- a/drivers/amlogic/display/ge2d/ge2d_wq.c
+++ b/drivers/amlogic/display/ge2d/ge2d_wq.c
@@ -493,7 +493,7 @@ static void build_ge2d_config(struct config_para_s *cfg,
 			dst->canvas_index = index;
 			canvas_config(index++ & 0xff,
 				      cfg->dst_planes[0].addr,
-				      cfg->dst_planes[0].w * dst->bpp / 8,
+				      cfg->dst_planes[0].w,
 				      cfg->dst_planes[0].h,
 				      CANVAS_ADDR_NOWRAP,
 				      CANVAS_BLKMODE_LINEAR);
@@ -504,7 +504,7 @@ static void build_ge2d_config(struct config_para_s *cfg,
 			dst->canvas_index |= index << 8;
 			canvas_config(index++,
 				      cfg->dst_planes[1].addr,
-				      cfg->dst_planes[1].w * dst->bpp / 8,
+				      cfg->dst_planes[1].w,
 				      cfg->dst_planes[1].h,
 				      CANVAS_ADDR_NOWRAP,
 				      CANVAS_BLKMODE_LINEAR);
@@ -513,7 +513,7 @@ static void build_ge2d_config(struct config_para_s *cfg,
 			dst->canvas_index |= index << 16;
 			canvas_config(index++,
 				      cfg->dst_planes[2].addr,
-				      cfg->dst_planes[2].w * dst->bpp / 8,
+				      cfg->dst_planes[2].w,
 				      cfg->dst_planes[2].h,
 				      CANVAS_ADDR_NOWRAP,
 				      CANVAS_BLKMODE_LINEAR);
@@ -522,7 +522,7 @@ static void build_ge2d_config(struct config_para_s *cfg,
 			dst->canvas_index |= index << 24;
 			canvas_config(index++,
 				      cfg->dst_planes[3].addr,
-				      cfg->dst_planes[3].w * dst->bpp / 8,
+				      cfg->dst_planes[3].w,
 				      cfg->dst_planes[3].h,
 				      CANVAS_ADDR_NOWRAP,
 				      CANVAS_BLKMODE_LINEAR);
diff --git a/drivers/amlogic/display/lcd/lcd_clk_config.c b/drivers/amlogic/display/lcd/lcd_clk_config.c
index 0abee11..27a0350 100644
--- a/drivers/amlogic/display/lcd/lcd_clk_config.c
+++ b/drivers/amlogic/display/lcd/lcd_clk_config.c
@@ -29,6 +29,8 @@
 
 static spinlock_t lcd_clk_lock;
 
+static const unsigned int od_fb_table[2] = {1, 2};
+
 static const unsigned int od_table[4] = {
 	1, 2, 4, 8
 };
@@ -99,6 +101,14 @@ static char *lcd_pll_ss_table_gxtvbb[] = {
 	"4, +/-1.2%",
 };
 
+static char *lcd_pll_ss_table_txl[] = {
+	"0, disable",
+	"1, +/-0.3%",
+	"2, +/-0.5%",
+	"3, +/-0.9%",
+	"4, +/-1.2%",
+};
+
 static struct lcd_clk_config_s clk_conf = { /* unit: kHz */
 	/* IN-OUT parameters */
 	.fin = FIN_FREQ,
@@ -187,9 +197,7 @@ static void lcd_clk_config_init_print(void)
 			clk_conf.div_pre_in_fmax, clk_conf.div_pre_out_fmax,
 			clk_conf.div_post_out_fmax, clk_conf.xd_out_fmax);
 		break;
-	case LCD_CHIP_G9TV:
-	case LCD_CHIP_G9BB:
-	case LCD_CHIP_GXTVBB:
+	default:
 		LCDPR("lcd clk config:\n"
 			"pll_m_max:         %d\n"
 			"pll_m_min:         %d\n"
@@ -217,8 +225,6 @@ static void lcd_clk_config_init_print(void)
 			clk_conf.div_in_fmax, clk_conf.div_out_fmax,
 			clk_conf.xd_out_fmax);
 		break;
-	default:
-		break;
 	}
 }
 
@@ -248,9 +254,7 @@ void lcd_clk_config_print(void)
 			clk_conf.div_pre, clk_conf.div_post,
 			clk_conf.xd, clk_conf.fout, clk_conf.ss_level);
 		break;
-	case LCD_CHIP_G9TV:
-	case LCD_CHIP_G9BB:
-	case LCD_CHIP_GXTVBB:
+	default:
 		LCDPR("lcd clk config:\n"
 			"pll_m:        %d\n"
 			"pll_n:        %d\n"
@@ -272,8 +276,6 @@ void lcd_clk_config_print(void)
 			clk_conf.div_sel, clk_conf.xd,
 			clk_conf.fout, clk_conf.ss_level);
 		break;
-	default:
-		break;
 	}
 }
 
@@ -338,8 +340,7 @@ static void lcd_clk_config_chip_init(void)
 		cConf->pll_vco_fmax = PLL_VCO_MAX_G9TV;
 		cConf->pll_vco_fmin = PLL_VCO_MIN_G9TV;
 		cConf->pll_out_fmax = CLK_DIV_IN_MAX_G9TV;
-		cConf->pll_out_fmin = cConf->pll_vco_fmin /
-			od_table[cConf->pll_od_sel_max - 1];
+		cConf->pll_out_fmin = cConf->pll_vco_fmin / 16;
 		cConf->div_in_fmax = CLK_DIV_IN_MAX_G9TV;
 		cConf->div_out_fmax = CRT_VID_CLK_IN_MAX_G9TV;
 		cConf->xd_out_fmax = ENCL_CLK_IN_MAX_G9TV;
@@ -357,8 +358,7 @@ static void lcd_clk_config_chip_init(void)
 		cConf->pll_vco_fmax = PLL_VCO_MAX_G9BB;
 		cConf->pll_vco_fmin = PLL_VCO_MIN_G9BB;
 		cConf->pll_out_fmax = CLK_DIV_IN_MAX_G9BB;
-		cConf->pll_out_fmin = cConf->pll_vco_fmin /
-			od_table[cConf->pll_od_sel_max - 1];
+		cConf->pll_out_fmin = cConf->pll_vco_fmin / 16;
 		cConf->div_in_fmax = CLK_DIV_IN_MAX_G9BB;
 		cConf->div_out_fmax = CRT_VID_CLK_IN_MAX_G9BB;
 		cConf->xd_out_fmax = ENCL_CLK_IN_MAX_G9BB;
@@ -376,12 +376,29 @@ static void lcd_clk_config_chip_init(void)
 		cConf->pll_vco_fmax = PLL_VCO_MAX_GXTVBB;
 		cConf->pll_vco_fmin = PLL_VCO_MIN_GXTVBB;
 		cConf->pll_out_fmax = CLK_DIV_IN_MAX_GXTVBB;
-		cConf->pll_out_fmin = cConf->pll_vco_fmin /
-			od_table[cConf->pll_od_sel_max - 1];
+		cConf->pll_out_fmin = cConf->pll_vco_fmin / 16;
 		cConf->div_in_fmax = CLK_DIV_IN_MAX_GXTVBB;
 		cConf->div_out_fmax = CRT_VID_CLK_IN_MAX_GXTVBB;
 		cConf->xd_out_fmax = ENCL_CLK_IN_MAX_GXTVBB;
 		break;
+	case LCD_CHIP_TXL:
+		cConf->ss_level_max = SS_LEVEL_MAX_TXL;
+		cConf->pll_m_max = PLL_M_MAX_TXL;
+		cConf->pll_m_min = PLL_M_MIN_TXL;
+		cConf->pll_n_max = PLL_N_MAX_TXL;
+		cConf->pll_n_min = PLL_N_MIN_TXL;
+		cConf->pll_frac_range = PLL_FRAC_RANGE_TXL;
+		cConf->pll_od_sel_max = PLL_OD_SEL_MAX_TXL;
+		cConf->pll_ref_fmax = PLL_FREF_MAX_TXL;
+		cConf->pll_ref_fmin = PLL_FREF_MIN_TXL;
+		cConf->pll_vco_fmax = PLL_VCO_MAX_TXL;
+		cConf->pll_vco_fmin = PLL_VCO_MIN_TXL;
+		cConf->pll_out_fmax = CLK_DIV_IN_MAX_TXL;
+		cConf->pll_out_fmin = cConf->pll_vco_fmin / 16;
+		cConf->div_in_fmax = CLK_DIV_IN_MAX_TXL;
+		cConf->div_out_fmax = CRT_VID_CLK_IN_MAX_TXL;
+		cConf->xd_out_fmax = ENCL_CLK_IN_MAX_TXL;
+		break;
 	default:
 		LCDPR("%s invalid chip type\n", __func__);
 		break;
@@ -905,13 +922,54 @@ static void lcd_update_pll_frac_gxtvbb(struct lcd_clk_config_s *cConf)
 	if (lcd_debug_print_flag == 2)
 		LCDPR("%s\n", __func__);
 
-	if (cConf->pll_frac > 0) {
-		lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, 1, 14, 1);
-		lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, cConf->pll_frac, 0, 12);
-	} else {
-		lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, 0, 14, 1);
-		lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, 0, 0, 12);
-	}
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, cConf->pll_frac, 0, 12);
+}
+
+static void lcd_set_pll_ss_txl(struct lcd_clk_config_s *cConf)
+{
+	/* to do */
+}
+
+static void lcd_set_pll_txl(struct lcd_clk_config_s *cConf)
+{
+	unsigned int pll_ctrl, pll_ctrl2, pll_ctrl3;
+	int ret;
+
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s\n", __func__);
+	pll_ctrl = ((1 << LCD_PLL_EN_TXL) |
+		(cConf->pll_n << LCD_PLL_N_TXL) |
+		(cConf->pll_m << LCD_PLL_M_TXL));
+	pll_ctrl2 = 0x800ca000;
+	pll_ctrl2 |= ((1 << 12) | (cConf->pll_frac << 0));
+	pll_ctrl3 = 0x860730c4;
+	pll_ctrl3 |= ((cConf->pll_od3_sel << LCD_PLL_OD3_TXL) |
+		(cConf->pll_od2_sel << LCD_PLL_OD2_TXL) |
+		(cConf->pll_od1_sel << LCD_PLL_OD1_TXL));
+
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL, pll_ctrl);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL2, pll_ctrl2);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL3, pll_ctrl3);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL5, 0x001fa729);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL6, 0x01a31500);
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 1, LCD_PLL_RST_TXL, 1);
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 0, LCD_PLL_RST_TXL, 1);
+
+	ret = lcd_pll_wait_lock(HHI_HDMI_PLL_CNTL, LCD_PLL_LOCK_TXL);
+	if (ret)
+		LCDERR("hpll lock failed\n");
+
+	if (cConf->ss_level > 0)
+		lcd_set_pll_ss_txl(cConf);
+}
+
+static void lcd_update_pll_frac_txl(struct lcd_clk_config_s *cConf)
+{
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s\n", __func__);
+
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL2, cConf->pll_frac, 0, 12);
 }
 
 static void lcd_set_clk_div_m8(int lcd_type, struct lcd_clk_config_s *cConf)
@@ -1074,15 +1132,10 @@ static void lcd_set_vclk_crt(int lcd_type, struct lcd_clk_config_s *cConf)
 		/* select vid_pll2_clk */
 		lcd_hiu_setb(HHI_VIID_CLK_CNTL, 4, VCLK2_CLK_IN_SEL, 3);
 		break;
-	case LCD_CHIP_M8B:
-	case LCD_CHIP_G9TV:
-	case LCD_CHIP_G9BB:
-	case LCD_CHIP_GXTVBB:
+	default:
 		/* select vid_pll_clk */
 		lcd_hiu_setb(HHI_VIID_CLK_CNTL, 0, VCLK2_CLK_IN_SEL, 3);
 		break;
-	default:
-		break;
 	}
 	lcd_hiu_setb(HHI_VIID_CLK_CNTL, 1, VCLK2_EN, 1);
 	udelay(2);
@@ -1106,6 +1159,7 @@ static void lcd_set_vclk_crt(int lcd_type, struct lcd_clk_config_s *cConf)
 	case LCD_CHIP_G9TV:
 	case LCD_CHIP_G9BB:
 	case LCD_CHIP_GXTVBB:
+	case LCD_CHIP_TXL:
 		lcd_hiu_setb(HHI_VID_CLK_CNTL2, 1, ENCL_GATE_VCLK, 1);
 		break;
 	default:
@@ -1159,7 +1213,7 @@ static int check_pll_m8(struct lcd_clk_config_s *cConf,
 		}
 		cConf->pll_fvco = pll_fvco;
 		n = 1;
-		pll_fvco = pll_fvco / (od_fb + 1);
+		pll_fvco = pll_fvco / od_fb_table[od_fb];
 		m = pll_fvco / cConf->fin;
 		pll_frac = (pll_fvco % cConf->fin) * 4096 / cConf->fin;
 		cConf->pll_m = m;
@@ -1237,7 +1291,6 @@ static void lcd_clk_generate_m8(struct lcd_config_s *pconf)
 {
 	unsigned int pll_fout;
 	unsigned int edp_phy_out;
-	unsigned int div_pre_max;
 	unsigned int div_pre_in, div_pre_out, div_post_out;
 	unsigned int m, n, od_sel, pll_level, pll_frac;
 	unsigned int edp_div0, edp_div1, edp_div0_sel, edp_div1_sel;
@@ -1261,7 +1314,6 @@ static void lcd_clk_generate_m8(struct lcd_config_s *pconf)
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_MIPI:
 		cConf->div_pre_sel_max = DIV_PRE_SEL_MAX;
-		div_pre_max = DIV_PRE_SEL_MAX;
 		div_post = 1;
 		cConf->xd_max = CRT_VID_DIV_MAX;
 		tmp = pconf->lcd_control.mipi_config->bit_rate_max;
@@ -1270,26 +1322,22 @@ static void lcd_clk_generate_m8(struct lcd_config_s *pconf)
 		break;
 	case LCD_EDP:
 		cConf->div_pre_sel_max = 1;
-		div_pre_max = DIV_PRE_SEL_MAX;
 		div_post = 1;
 		cConf->xd_max = 1;
 		cConf->err_fmin = 30 * 1000;
 		break;
 	case LCD_LVDS:
 		cConf->div_pre_sel_max = DIV_PRE_SEL_MAX;
-		div_pre_max = DIV_PRE_SEL_MAX;
 		div_post = 7;
 		cConf->xd_max = 1;
 		break;
 	case LCD_TTL:
 		cConf->div_pre_sel_max = DIV_PRE_SEL_MAX;
-		div_pre_max = DIV_PRE_SEL_MAX;
 		div_post = 1;
 		cConf->xd_max = CRT_VID_DIV_MAX;
 		break;
 	default:
 		cConf->div_pre_sel_max = DIV_PRE_SEL_MAX;
-		div_pre_max = DIV_PRE_SEL_MAX;
 		div_post = 1;
 		cConf->xd_max = 1;
 		break;
@@ -1619,7 +1667,7 @@ static int check_pll_g9_gxtvbb(struct lcd_clk_config_s *cConf,
 				cConf->pll_fvco = pll_fvco;
 				n = 1;
 				od_fb = 0; /* pll default */
-				pll_fvco = pll_fvco / ((od_fb + 1) * 2);
+				pll_fvco = pll_fvco / od_fb_table[od_fb + 1];
 				m = pll_fvco / cConf->fin;
 				pll_frac = (pll_fvco % cConf->fin) *
 					cConf->pll_frac_range / cConf->fin;
@@ -1843,7 +1891,7 @@ static void lcd_pll_frac_generate_g9_gxtvbb(struct lcd_config_s *pconf)
 
 	cConf->pll_fvco = pll_fvco;
 	od_fb = 0; /* pll default */
-	pll_fvco = pll_fvco / ((od_fb + 1) * 2);
+	pll_fvco = pll_fvco / od_fb_table[od_fb + 1];
 	temp = cConf->fin * m / n;
 	if (pll_fvco >= temp) {
 		temp = pll_fvco - temp;
@@ -1863,6 +1911,262 @@ static void lcd_pll_frac_generate_g9_gxtvbb(struct lcd_config_s *pconf)
 		LCDPR("lcd_pll_frac_generate frac=%d\n", frac);
 }
 
+static int check_pll_txl(struct lcd_clk_config_s *cConf,
+		unsigned int pll_fout)
+{
+	unsigned int m, n;
+	unsigned int od1_sel, od2_sel, od3_sel, od1, od2, od3;
+	unsigned int pll_fod2_in, pll_fod3_in, pll_fvco;
+	unsigned int od_fb = 0, pll_frac;
+	int done;
+
+	done = 0;
+	if ((pll_fout > cConf->pll_out_fmax) ||
+		(pll_fout < cConf->pll_out_fmin)) {
+		return done;
+	}
+	for (od3_sel = cConf->pll_od_sel_max; od3_sel > 0; od3_sel--) {
+		od3 = od_table[od3_sel - 1];
+		pll_fod3_in = pll_fout * od3;
+		for (od2_sel = od3_sel; od2_sel > 0; od2_sel--) {
+			od2 = od_table[od2_sel - 1];
+			pll_fod2_in = pll_fod3_in * od2;
+			for (od1_sel = od2_sel; od1_sel > 0; od1_sel--) {
+				od1 = od_table[od1_sel - 1];
+				pll_fvco = pll_fod2_in * od1;
+				if ((pll_fvco < cConf->pll_vco_fmin) ||
+					(pll_fvco > cConf->pll_vco_fmax)) {
+					continue;
+				}
+				cConf->pll_od1_sel = od1_sel - 1;
+				cConf->pll_od2_sel = od2_sel - 1;
+				cConf->pll_od3_sel = od3_sel - 1;
+				cConf->pll_fout = pll_fout;
+				if (lcd_debug_print_flag == 2) {
+					LCDPR("od1=%d, od2=%d, od3=%d\n",
+						(od1_sel - 1), (od2_sel - 1),
+						(od3_sel - 1));
+					LCDPR("pll_fvco=%d\n", pll_fvco);
+				}
+				cConf->pll_fvco = pll_fvco;
+				n = 1;
+				od_fb = 0; /* pll default */
+				pll_fvco = pll_fvco / od_fb_table[od_fb];
+				m = pll_fvco / cConf->fin;
+				pll_frac = (pll_fvco % cConf->fin) *
+					cConf->pll_frac_range / cConf->fin;
+				cConf->pll_m = m;
+				cConf->pll_n = n;
+				cConf->pll_frac = pll_frac;
+				if (lcd_debug_print_flag == 2) {
+					LCDPR("m=%d, n=%d, frac=%d\n",
+						m, n, pll_frac);
+				}
+				done = 1;
+				break;
+			}
+		}
+	}
+	return done;
+}
+
+static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
+{
+	unsigned int pll_fout;
+	unsigned int clk_div_in, clk_div_out;
+	unsigned int clk_div_sel, xd;
+	struct lcd_clk_config_s *cConf;
+	int done;
+
+	done = 0;
+	cConf = get_lcd_clk_config();
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	cConf->err_fmin = MAX_ERROR;
+
+	if (cConf->fout > cConf->xd_out_fmax) {
+		LCDERR("%s: wrong lcd_clk value %dkHz\n",
+			__func__, cConf->fout);
+		goto generate_clk_done_txl;
+	}
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_LVDS:
+		clk_div_sel = CLK_DIV_SEL_7;
+		xd = 1;
+		clk_div_out = cConf->fout * xd;
+		if (clk_div_out > cConf->div_out_fmax)
+			goto generate_clk_done_txl;
+		if (lcd_debug_print_flag == 2) {
+			LCDPR("fout=%d, xd=%d, clk_div_out=%d\n",
+				cConf->fout, xd, clk_div_out);
+		}
+		clk_div_in = clk_div_calc_g9_gxtvbb(clk_div_out,
+				clk_div_sel, CLK_DIV_O2I);
+		if (clk_div_in > cConf->div_in_fmax)
+			goto generate_clk_done_txl;
+		cConf->xd = xd;
+		cConf->div_sel = clk_div_sel;
+		pll_fout = clk_div_in;
+		if (lcd_debug_print_flag == 2) {
+			LCDPR("clk_div_sel=%s(index %d), pll_fout=%d\n",
+				lcd_clk_div_sel_table[clk_div_sel],
+				clk_div_sel, pll_fout);
+		}
+		done = check_pll_txl(cConf, pll_fout);
+		if (done)
+			goto generate_clk_done_txl;
+		break;
+	case LCD_VBYONE:
+		cConf->div_sel_max = CLK_DIV_SEL_MAX;
+		cConf->xd_max = CRT_VID_DIV_MAX;
+		pll_fout = pconf->lcd_control.vbyone_config->bit_rate / 1000;
+		clk_div_in = pll_fout;
+		if (clk_div_in > cConf->div_in_fmax)
+			goto generate_clk_done_txl;
+		if (lcd_debug_print_flag == 2)
+			LCDPR("pll_fout=%d\n", pll_fout);
+		if ((clk_div_in / cConf->fout) > 15)
+			cConf->xd = 4;
+		else
+			cConf->xd = 1;
+		clk_div_out = cConf->fout * cConf->xd;
+		if (lcd_debug_print_flag == 2) {
+			LCDPR("clk_div_in=%d, fout=%d, xd=%d, clk_div_out=%d\n",
+				clk_div_in, cConf->fout,
+				clk_div_out, cConf->xd);
+		}
+		if (clk_div_out > cConf->div_out_fmax)
+			goto generate_clk_done_txl;
+		clk_div_sel = clk_div_get_g9_gxtvbb(
+				clk_div_in * 100 / clk_div_out);
+		cConf->div_sel = clk_div_sel;
+		if (lcd_debug_print_flag == 2) {
+			LCDPR("clk_div_sel=%s(index %d)\n",
+				lcd_clk_div_sel_table[clk_div_sel],
+				cConf->div_sel);
+		}
+		done = check_pll_txl(cConf, pll_fout);
+		break;
+	default:
+		break;
+	}
+
+generate_clk_done_txl:
+	if (done) {
+		pconf->lcd_timing.pll_ctrl =
+			(cConf->pll_od1_sel << PLL_CTRL_OD1) |
+			(cConf->pll_od2_sel << PLL_CTRL_OD2) |
+			(cConf->pll_od3_sel << PLL_CTRL_OD3) |
+			(cConf->pll_n << PLL_CTRL_N)         |
+			(cConf->pll_m << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl =
+			(cConf->div_sel << DIV_CTRL_DIV_SEL) |
+			(cConf->xd << DIV_CTRL_XD);
+		pconf->lcd_timing.clk_ctrl =
+			(cConf->pll_frac << CLK_CTRL_FRAC);
+	} else {
+		pconf->lcd_timing.pll_ctrl =
+			(1 << PLL_CTRL_OD1) |
+			(1 << PLL_CTRL_OD2) |
+			(1 << PLL_CTRL_OD3) |
+			(1 << PLL_CTRL_N)   |
+			(50 << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl =
+			(CLK_DIV_SEL_1 << DIV_CTRL_DIV_SEL) |
+			(7 << DIV_CTRL_XD);
+		pconf->lcd_timing.clk_ctrl = (0 << CLK_CTRL_FRAC);
+		LCDERR("Out of clock range, reset to default setting\n");
+	}
+}
+
+static void lcd_pll_frac_generate_txl(struct lcd_config_s *pconf)
+{
+	unsigned int pll_fout;
+	unsigned int clk_div_in, clk_div_out, clk_div_sel;
+	unsigned int od1, od2, od3, pll_fvco;
+	unsigned int m, n, od_fb, frac, offset, temp;
+	struct lcd_clk_config_s *cConf;
+
+	cConf = get_lcd_clk_config();
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	clk_div_sel = cConf->div_sel;
+	od1 = od_table[cConf->pll_od1_sel];
+	od2 = od_table[cConf->pll_od2_sel];
+	od3 = od_table[cConf->pll_od3_sel];
+	m = cConf->pll_m;
+	n = cConf->pll_n;
+
+	if (lcd_debug_print_flag == 2) {
+		LCDPR("m=%d, n=%d, od1=%d, od2=%d, od3=%d\n",
+			m, n, cConf->pll_od1_sel, cConf->pll_od2_sel,
+			cConf->pll_od3_sel);
+		LCDPR("clk_div_sel=%s(index %d), xd=%d\n",
+			lcd_clk_div_sel_table[clk_div_sel],
+			clk_div_sel, cConf->xd);
+	}
+	if (cConf->fout > cConf->xd_out_fmax) {
+		LCDERR("%s: wrong lcd_clk value %dkHz\n",
+			__func__, cConf->fout);
+		return;
+	}
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s pclk=%d\n", __func__, cConf->fout);
+
+	clk_div_out = cConf->fout * cConf->xd;
+	if (clk_div_out > cConf->div_out_fmax) {
+		LCDERR("%s: wrong clk_div_out value %dkHz\n",
+			__func__, clk_div_out);
+		return;
+	}
+
+	clk_div_in =
+		clk_div_calc_g9_gxtvbb(clk_div_out, clk_div_sel, CLK_DIV_O2I);
+	if (clk_div_in > cConf->div_in_fmax) {
+		LCDERR("%s: wrong clk_div_in value %dkHz\n",
+			__func__, clk_div_in);
+		return;
+	}
+
+	pll_fout = clk_div_in;
+	if ((pll_fout > cConf->pll_out_fmax) ||
+		(pll_fout < cConf->pll_out_fmin)) {
+		LCDERR("%s: wrong pll_fout value %dkHz\n", __func__, pll_fout);
+		return;
+	}
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s pll_fout=%d\n", __func__, pll_fout);
+
+	pll_fvco = pll_fout * od1 * od2 * od3;
+	if ((pll_fvco < cConf->pll_vco_fmin) ||
+		(pll_fvco > cConf->pll_vco_fmax)) {
+		LCDERR("%s: wrong pll_fvco value %dkHz\n", __func__, pll_fvco);
+		return;
+	}
+	if (lcd_debug_print_flag == 2)
+		LCDPR("%s pll_fvco=%d\n", __func__, pll_fvco);
+
+	cConf->pll_fvco = pll_fvco;
+	od_fb = 0; /* pll default */
+	pll_fvco = pll_fvco / od_fb_table[od_fb];
+	temp = cConf->fin * m / n;
+	if (pll_fvco >= temp) {
+		temp = pll_fvco - temp;
+		offset = 0;
+	} else {
+		temp = temp - pll_fvco;
+		offset = 1;
+	}
+	if (temp >= (2 * cConf->fin)) {
+		LCDERR("%s: pll changing %dkHz is too much\n",
+			__func__, temp);
+		return;
+	}
+	frac = temp * cConf->pll_frac_range * n / cConf->fin;
+	cConf->pll_frac = frac | (offset << 11);
+	if (lcd_debug_print_flag)
+		LCDPR("lcd_pll_frac_generate: frac=0x%x\n", frac);
+}
+
 void lcd_clk_generate_parameter(struct lcd_config_s *pconf)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
@@ -1878,6 +2182,9 @@ void lcd_clk_generate_parameter(struct lcd_config_s *pconf)
 	case LCD_CHIP_GXTVBB:
 		lcd_clk_generate_g9_gxtvbb(pconf);
 		break;
+	case LCD_CHIP_TXL:
+		lcd_clk_generate_txl(pconf);
+		break;
 	default:
 		break;
 	}
@@ -1908,6 +2215,9 @@ char *lcd_get_spread_spectrum(void)
 	case LCD_CHIP_GXTVBB:
 		ss_str = lcd_pll_ss_table_gxtvbb[ss_level];
 		break;
+	case LCD_CHIP_TXL:
+		ss_str = lcd_pll_ss_table_txl[ss_level];
+		break;
 	default:
 		ss_str = "unknown";
 		break;
@@ -1946,6 +2256,9 @@ void lcd_set_spread_spectrum(void)
 	case LCD_CHIP_GXTVBB:
 		lcd_set_pll_ss_gxtvbb(&clk_conf);
 		break;
+	case LCD_CHIP_TXL:
+		lcd_set_pll_ss_txl(&clk_conf);
+		break;
 	default:
 		break;
 	}
@@ -1957,11 +2270,6 @@ void lcd_clk_update(struct lcd_config_s *pconf)
 {
 	unsigned long flags = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned int pclk = pconf->lcd_timing.lcd_clk_dft;
-
-	/* check if clk frac need update */
-	if (pconf->lcd_timing.lcd_clk == pclk)
-		return;
 
 	spin_lock_irqsave(&lcd_clk_lock, flags);
 	LCDPR("%s\n", __func__);
@@ -1988,6 +2296,10 @@ void lcd_clk_update(struct lcd_config_s *pconf)
 		lcd_pll_frac_generate_g9_gxtvbb(pconf);
 		lcd_update_pll_frac_gxtvbb(&clk_conf);
 		break;
+	case LCD_CHIP_TXL:
+		lcd_pll_frac_generate_txl(pconf);
+		lcd_update_pll_frac_txl(&clk_conf);
+		break;
 	default:
 		break;
 	}
@@ -2028,6 +2340,10 @@ void lcd_clk_set(struct lcd_config_s *pconf)
 		lcd_set_pll_gxtvbb(&clk_conf);
 		lcd_set_clk_div_g9_gxtvbb(&clk_conf);
 		break;
+	case LCD_CHIP_TXL:
+		lcd_set_pll_txl(&clk_conf);
+		lcd_set_clk_div_g9_gxtvbb(&clk_conf);
+		break;
 	default:
 		break;
 	}
@@ -2050,6 +2366,7 @@ void lcd_clk_disable(void)
 	case LCD_CHIP_G9TV:
 	case LCD_CHIP_G9BB:
 	case LCD_CHIP_GXTVBB:
+	case LCD_CHIP_TXL:
 		lcd_hiu_setb(HHI_VID_CLK_CNTL2, 0, ENCL_GATE_VCLK, 1);
 		break;
 	default:
@@ -2089,6 +2406,10 @@ void lcd_clk_disable(void)
 		lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 0, LCD_PLL_EN_GXTVBB, 1);
 		lcd_hiu_setb(HHI_HDMI_PLL_CNTL5, 0, 30, 1); /* bandgap */
 		break;
+	case LCD_CHIP_TXL:
+		/* disable hdmi_pll: 0x10c8[30] */
+		lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 0, LCD_PLL_EN_TXL, 1);
+		break;
 	default:
 		break;
 	}
diff --git a/drivers/amlogic/display/lcd/lcd_clk_config.h b/drivers/amlogic/display/lcd/lcd_clk_config.h
index 2933b5b..be110c3 100644
--- a/drivers/amlogic/display/lcd/lcd_clk_config.h
+++ b/drivers/amlogic/display/lcd/lcd_clk_config.h
@@ -281,6 +281,40 @@ enum div_sel_e {
 #define CRT_VID_CLK_IN_MAX_GXTVBB   (3100 * 1000)
 #define ENCL_CLK_IN_MAX_GXTVBB      (620 * 1000)
 
+/* **********************************
+ * TXL
+ * ********************************** */
+/* ******** register bit ******** */
+/* PLL_CNTL 0x10c8 */
+#define LCD_PLL_LOCK_TXL            31
+#define LCD_PLL_EN_TXL              30
+#define LCD_PLL_RST_TXL             28
+#define LCD_PLL_N_TXL               9
+#define LCD_PLL_M_TXL               0
+
+#define LCD_PLL_OD3_TXL             19
+#define LCD_PLL_OD2_TXL             23
+#define LCD_PLL_OD1_TXL             21
+
+/* ******** frequency limit (unit: kHz) ******** */
+/* pll */
+#define SS_LEVEL_MAX_TXL            5
+#define PLL_M_MIN_TXL               2
+#define PLL_M_MAX_TXL               511
+#define PLL_N_MIN_TXL               1
+#define PLL_N_MAX_TXL               1
+#define PLL_FRAC_RANGE_TXL          (1 << 10)
+#define PLL_OD_SEL_MAX_TXL          3
+#define PLL_FREF_MIN_TXL            (5 * 1000)
+#define PLL_FREF_MAX_TXL            (25 * 1000)
+#define PLL_VCO_MIN_TXL             (3000 * 1000)
+#define PLL_VCO_MAX_TXL             (6000 * 1000)
+
+/* video */
+#define CLK_DIV_IN_MAX_TXL          (3100 * 1000)
+#define CRT_VID_CLK_IN_MAX_TXL      (3100 * 1000)
+#define ENCL_CLK_IN_MAX_TXL         (620 * 1000)
+
 
 extern struct lcd_clk_config_s *get_lcd_clk_config(void);
 extern void lcd_clk_config_print(void);
diff --git a/drivers/amlogic/display/lcd/lcd_common.c b/drivers/amlogic/display/lcd/lcd_common.c
index 68eeb66..5f916a5 100644
--- a/drivers/amlogic/display/lcd/lcd_common.c
+++ b/drivers/amlogic/display/lcd/lcd_common.c
@@ -27,6 +27,7 @@
 #include <linux/of.h>
 #include <linux/reset.h>
 #include <linux/amlogic/vout/lcd_vout.h>
+#include <linux/amlogic/vout/lcd_notify.h>
 #include <linux/amlogic/vout/lcd_unifykey.h>
 #include "lcd_common.h"
 #include "lcd_reg.h"
@@ -237,20 +238,32 @@ void lcd_ttl_pinmux_set(int status)
 		index = 4;
 
 	if (status) {
-		switch (pconf->lcd_control.ttl_config->sync_valid) {
-		case 1: /* hvsync */
-			num = index + 0;
-			break;
-		case 2: /* DE */
-			num = index + 1;
-			break;
-		default:
-		case 3: /* DE + hvsync */
-			num = index + 2;
-			break;
+		if (pconf->pinmux_flag == 0) {
+			pconf->pinmux_flag = 1;
+			switch (pconf->lcd_control.ttl_config->sync_valid) {
+			case 1: /* hvsync */
+				num = index + 0;
+				break;
+			case 2: /* DE */
+				num = index + 1;
+				break;
+			default:
+			case 3: /* DE + hvsync */
+				num = index + 2;
+				break;
+			}
+		} else {
+			LCDPR("ttl pinmux is already selected\n");
+			return;
 		}
 	} else {
-		num = index + 3;
+		if (pconf->pinmux_flag) {
+			pconf->pinmux_flag = 0;
+			num = index + 3;
+		} else {
+			LCDPR("ttl pinmux is already released\n");
+			return;
+		}
 	}
 
 	/* request pinmux */
@@ -260,6 +273,48 @@ void lcd_ttl_pinmux_set(int status)
 		LCDERR("set ttl pinmux error\n");
 }
 
+/* set VX1_LOCKN && VX1_HTPDN */
+void lcd_vbyone_pinmux_set(int status)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+
+	if (lcd_debug_print_flag)
+		LCDPR("%s: %d\n", __func__, status);
+
+#if 1
+	pconf = lcd_drv->lcd_config;
+	if (status) {
+		if (pconf->pinmux_flag == 0) {
+			pconf->pinmux_flag = 1;
+			/* request pinmux */
+			pconf->pin = devm_pinctrl_get_select(lcd_drv->dev,
+				"vbyone");
+			if (IS_ERR(pconf->pin))
+				LCDERR("set vbyone pinmux error\n");
+		} else {
+			LCDPR("vbyone pinmux is already selected\n");
+		}
+	} else {
+		if (pconf->pinmux_flag) {
+			pconf->pinmux_flag = 0;
+			/* release pinmux */
+			devm_pinctrl_put(pconf->pin);
+		} else {
+			LCDPR("vbyone pinmux is already released\n");
+		}
+	}
+#else
+	if (status) {
+		lcd_pinmux_clr_mask(7,
+			((1 << 1) | (1 << 2) | (1 << 9) | (1 << 10)));
+		lcd_pinmux_set_mask(7, ((1 << 11) | (1 << 12)));
+	} else {
+		lcd_pinmux_clr_mask(7, ((1 << 11) | (1 << 12)));
+	}
+#endif
+}
+
 int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 		struct device_node *child)
 {
@@ -378,7 +433,7 @@ int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 	ret = of_property_read_u32(child, "backlight_index", &para[0]);
 	if (ret) {
 		LCDPR("failed to get backlight_index\n");
-		pconf->backlight_index = 0;
+		pconf->backlight_index = 0xff;
 	} else {
 		pconf->backlight_index = para[0];
 	}
@@ -557,6 +612,7 @@ void lcd_tcon_config(struct lcd_config_s *pconf)
 	}
 }
 
+#if 0
 /* change frame_rate for different vmode */
 int lcd_vmode_change(struct lcd_config_s *pconf)
 {
@@ -615,6 +671,162 @@ int lcd_vmode_change(struct lcd_config_s *pconf)
 
 	return 0;
 }
+#else
+int lcd_vmode_change(struct lcd_config_s *pconf)
+{
+	unsigned char type = pconf->lcd_timing.fr_adjust_type;
+	 /* use default value to avoid offset */
+	unsigned int pclk = pconf->lcd_timing.lcd_clk_dft;
+	unsigned int h_period = pconf->lcd_timing.h_period_dft;
+	unsigned int v_period = pconf->lcd_timing.v_period_dft;
+	unsigned int pclk_min = pconf->lcd_basic.lcd_clk_min;
+	unsigned int pclk_max = pconf->lcd_basic.lcd_clk_max;
+	unsigned int duration_num = pconf->lcd_timing.sync_duration_num;
+	unsigned int duration_den = pconf->lcd_timing.sync_duration_den;
+	char str[100];
+	int len = 0;
+
+	pconf->lcd_timing.clk_change = 0; /* clear clk flga */
+	switch (type) {
+	case 0: /* pixel clk adjust */
+		pclk = (h_period * v_period) / duration_den * duration_num;
+		if (pconf->lcd_timing.lcd_clk != pclk)
+			pconf->lcd_timing.clk_change = LCD_CLK_PLL_CHANGE;
+		break;
+	case 1: /* htotal adjust */
+		h_period = ((pclk / v_period) * duration_den * 10) /
+				duration_num;
+		h_period = (h_period + 5) / 10; /* round off */
+		if (pconf->lcd_basic.h_period != h_period) {
+			/* check clk frac update */
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk) {
+				pconf->lcd_timing.clk_change =
+					LCD_CLK_FRAC_UPDATE;
+			}
+		}
+		break;
+	case 2: /* vtotal adjust */
+		v_period = ((pclk / h_period) * duration_den * 10) /
+				duration_num;
+		v_period = (v_period + 5) / 10; /* round off */
+		if (pconf->lcd_basic.v_period != v_period) {
+			/* check clk frac update */
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk) {
+				pconf->lcd_timing.clk_change =
+					LCD_CLK_FRAC_UPDATE;
+			}
+		}
+		break;
+	case 3: /* free adjust, use min/max range to calculate */
+	default:
+		v_period = ((pclk / h_period) * duration_den * 10) /
+			duration_num;
+		v_period = (v_period + 5) / 10; /* round off */
+		if (v_period > pconf->lcd_basic.v_period_max) {
+			v_period = pconf->lcd_basic.v_period_max;
+			h_period = ((pclk / v_period) * duration_den * 10) /
+				duration_num;
+			h_period = (h_period + 5) / 10; /* round off */
+			if (h_period > pconf->lcd_basic.h_period_max) {
+				h_period = pconf->lcd_basic.h_period_max;
+				pclk = (h_period * v_period) / duration_den *
+					duration_num;
+				if (pconf->lcd_timing.lcd_clk != pclk) {
+					if (pclk > pclk_max) {
+						pclk = pclk_max;
+						LCDERR("invalid vmode\n");
+						return -1;
+					}
+					pconf->lcd_timing.clk_change =
+						LCD_CLK_PLL_CHANGE;
+				}
+			}
+		} else if (v_period < pconf->lcd_basic.v_period_min) {
+			v_period = pconf->lcd_basic.v_period_min;
+			h_period = ((pclk / v_period) * duration_den * 10) /
+				duration_num;
+			h_period = (h_period + 5) / 10; /* round off */
+			if (h_period < pconf->lcd_basic.h_period_min) {
+				h_period = pconf->lcd_basic.h_period_min;
+				pclk = (h_period * v_period) / duration_den *
+					duration_num;
+				if (pconf->lcd_timing.lcd_clk != pclk) {
+					if (pclk < pclk_min) {
+						pclk = pclk_min;
+						LCDERR("invalid vmode\n");
+						return -1;
+					}
+					pconf->lcd_timing.clk_change =
+						LCD_CLK_PLL_CHANGE;
+				}
+			}
+		}
+		/* check clk frac update */
+		if ((pconf->lcd_timing.clk_change & LCD_CLK_PLL_CHANGE) == 0) {
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk) {
+				pconf->lcd_timing.clk_change =
+					LCD_CLK_FRAC_UPDATE;
+			}
+		}
+		break;
+	}
+
+	if (pconf->lcd_basic.v_period != v_period) {
+		len += sprintf(str+len, "v_period %u->%u",
+			pconf->lcd_basic.v_period, v_period);
+		/* update v_period */
+		pconf->lcd_basic.v_period = v_period;
+	}
+	if (pconf->lcd_basic.h_period != h_period) {
+		if (len > 0)
+			len += sprintf(str+len, ", ");
+		len += sprintf(str+len, "h_period %u->%u",
+			pconf->lcd_basic.h_period, h_period);
+		/* update h_period */
+		pconf->lcd_basic.h_period = h_period;
+	}
+	if (pconf->lcd_timing.lcd_clk != pclk) {
+		if (len > 0)
+			len += sprintf(str+len, ", ");
+		len += sprintf(str+len, "pclk %u.%03uMHz->%u.%03uMHz",
+			(pconf->lcd_timing.lcd_clk / 1000000),
+			((pconf->lcd_timing.lcd_clk / 1000) % 1000),
+			(pclk / 1000000), ((pclk / 1000) % 1000));
+		pconf->lcd_timing.lcd_clk = pclk;
+	}
+	if (len > 0)
+		LCDPR("%s: %s\n", __func__, str);
+
+	return 0;
+}
+#endif
+
+void lcd_venc_change(struct lcd_config_s *pconf)
+{
+	unsigned int htotal, vtotal;
+
+	htotal = lcd_vcbus_read(ENCL_VIDEO_MAX_PXCNT) + 1;
+	vtotal = lcd_vcbus_read(ENCL_VIDEO_MAX_LNCNT) + 1;
+	if (pconf->lcd_basic.h_period != htotal) {
+		lcd_vcbus_write(ENCL_VIDEO_MAX_PXCNT,
+			pconf->lcd_basic.h_period - 1);
+	}
+	if (pconf->lcd_basic.v_period != vtotal) {
+		lcd_vcbus_write(ENCL_VIDEO_MAX_LNCNT,
+			pconf->lcd_basic.v_period - 1);
+	}
+	LCDPR("venc changed: %d,%d\n",
+		pconf->lcd_basic.h_period, pconf->lcd_basic.v_period);
+
+	if (pconf->lcd_basic.v_period != vtotal)
+		aml_lcd_notifier_call_chain(LCD_EVENT_BACKLIGHT_UPDATE, NULL);
+}
 
 void lcd_clk_gate_switch(int status)
 {
diff --git a/drivers/amlogic/display/lcd/lcd_common.h b/drivers/amlogic/display/lcd/lcd_common.h
index 357eaed..01f014c 100644
--- a/drivers/amlogic/display/lcd/lcd_common.h
+++ b/drivers/amlogic/display/lcd/lcd_common.h
@@ -35,6 +35,7 @@ extern void lcd_cpu_gpio_register(unsigned int index);
 extern void lcd_cpu_gpio_set(unsigned int index, int value);
 extern unsigned int lcd_cpu_gpio_get(unsigned int index);
 extern void lcd_ttl_pinmux_set(int status);
+extern void lcd_vbyone_pinmux_set(int status);
 extern int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 		struct device_node *child);
 extern int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
@@ -42,6 +43,7 @@ extern int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
 
 extern void lcd_tcon_config(struct lcd_config_s *pconf);
 extern int lcd_vmode_change(struct lcd_config_s *pconf);
+extern void lcd_venc_change(struct lcd_config_s *pconf);
 extern void lcd_clk_gate_switch(int status);
 
 /* lcd debug */
@@ -50,11 +52,14 @@ extern int lcd_class_remove(void);
 
 /* lcd driver */
 #ifdef CONFIG_AML_LCD_TV
+extern void lcd_vbyone_interrupt_enable(int flag);
+extern void lcd_tv_clk_update(struct lcd_config_s *pconf);
 extern void lcd_tv_vout_server_init(void);
 extern int lcd_tv_probe(struct device *dev);
 extern int lcd_tv_remove(struct device *dev);
 #endif
 #ifdef CONFIG_AML_LCD_TABLET
+extern void lcd_tablet_clk_update(struct lcd_config_s *pconf);
 extern void lcd_tablet_vout_server_init(void);
 extern int lcd_tablet_probe(struct device *dev);
 extern int lcd_tablet_remove(struct device *dev);
diff --git a/drivers/amlogic/display/lcd/lcd_debug.c b/drivers/amlogic/display/lcd/lcd_debug.c
index b14f84f..0d4216d 100644
--- a/drivers/amlogic/display/lcd/lcd_debug.c
+++ b/drivers/amlogic/display/lcd/lcd_debug.c
@@ -156,8 +156,9 @@ static void lcd_info_print(void)
 	LCDPR("panel_type: %s\n", pconf->lcd_propname);
 	LCDPR("key_valid: %d, config_load: %d\n",
 		lcd_drv->lcd_key_valid, lcd_drv->lcd_config_load);
-	LCDPR("mode  : %s, status: %d\n",
-		lcd_mode_mode_to_str(lcd_drv->lcd_mode), lcd_drv->lcd_status);
+	LCDPR("chip: %d, mode : %s, status: %d, fr_auto_policy: %d\n",
+		lcd_drv->chip_type, lcd_mode_mode_to_str(lcd_drv->lcd_mode),
+		lcd_drv->lcd_status, lcd_drv->fr_auto_policy);
 
 	LCDPR("%s, %s %ubit, %ux%u@%u.%02uHz\n",
 		pconf->lcd_basic.model_name,
@@ -187,10 +188,19 @@ static void lcd_info_print(void)
 		pconf->lcd_timing.hsync_pol,
 		pconf->lcd_timing.vsync_width, pconf->lcd_timing.vsync_bp,
 		pconf->lcd_timing.vsync_pol);
+	pr_info("h_period_min      %d\n"
+		"h_period_max      %d\n"
+		"v_period_min      %d\n"
+		"v_period_max      %d\n"
+		"pclk_min          %d\n"
+		"pclk_max          %d\n\n",
+		pconf->lcd_basic.h_period_min, pconf->lcd_basic.h_period_max,
+		pconf->lcd_basic.v_period_min, pconf->lcd_basic.v_period_max,
+		pconf->lcd_basic.lcd_clk_min, pconf->lcd_basic.lcd_clk_max);
 
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_TTL:
-		pr_info("clk_pol          %u\n"
+		pr_info("clk_pol           %u\n"
 			"hvsync_valid      %u\n"
 			"de_valid          %u\n"
 			"rb_swap           %u\n"
@@ -536,77 +546,125 @@ static void lcd_test(unsigned int num)
 
 static void lcd_debug_config_update(void)
 {
-	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
-	mdelay(200);
-	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	lcd_drv->module_reset();
+}
+
+static void lcd_debug_clk_change(unsigned int pclk)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+	unsigned int sync_duration;
+
+	pconf = lcd_drv->lcd_config;
+	sync_duration = pclk / pconf->lcd_basic.h_period;
+	sync_duration = sync_duration * 100 / pconf->lcd_basic.v_period;
+	pconf->lcd_timing.lcd_clk = pclk;
+	pconf->lcd_timing.sync_duration_num = sync_duration;
+	pconf->lcd_timing.sync_duration_den = 100;
+
+	/* update vinfo */
+	lcd_drv->lcd_info->sync_duration_num = sync_duration;
+	lcd_drv->lcd_info->sync_duration_den = 100;
+	lcd_drv->lcd_info->video_clk = pclk;
+
+	switch (lcd_drv->lcd_mode) {
+#ifdef CONFIG_AML_LCD_TV
+	case LCD_MODE_TV:
+		lcd_tv_clk_update(pconf);
+		break;
+#endif
+#ifdef CONFIG_AML_LCD_TABLET
+	case LCD_MODE_TABLET:
+		lcd_tablet_clk_update(pconf);
+		break;
+#endif
+	default:
+		LCDPR("invalid lcd mode\n");
+		break;
+	}
+
+	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,
+		&lcd_drv->lcd_info->mode);
 }
 
 static ssize_t lcd_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	unsigned int temp, val[6];
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
 
+	pconf = lcd_drv->lcd_config;
 	switch (buf[0]) {
 	case 'c':
-		temp = lcd_drv->lcd_config->lcd_timing.lcd_clk;
 		ret = sscanf(buf, "clk %d", &temp);
-		if (temp > 200) {
-			pr_info("set clk: %dHz\n", temp);
-			temp = temp / lcd_drv->lcd_config->lcd_basic.h_period;
-			temp *= 100;
-			temp = temp / lcd_drv->lcd_config->lcd_basic.v_period;
+		if (ret == 1) {
+			if (temp > 200) {
+				pr_info("set clk: %dHz\n", temp);
+			} else {
+				pr_info("set frame_rate: %dHz\n", temp);
+				temp = pconf->lcd_basic.h_period *
+					pconf->lcd_basic.v_period * temp;
+			}
+			pr_info("set frame rate: %d.%02dHz\n",
+				(temp / 100), (temp % 100));
+			lcd_debug_clk_change(temp);
 		} else {
-			temp *= 100;
+			LCDERR("invalid data\n");
+			return -EINVAL;
 		}
-		pr_info("set frame rate: %d.%02dHz\n",
-			(temp / 100), (temp % 100));
-		aml_lcd_notifier_call_chain(LCD_EVENT_FRAME_RATE_ADJUST, &temp);
-		lcd_debug_config_update();
 		break;
 	case 'b':
-		val[0] = lcd_drv->lcd_config->lcd_basic.h_active;
-		val[1] = lcd_drv->lcd_config->lcd_basic.v_active;
-		val[2] = lcd_drv->lcd_config->lcd_basic.h_period;
-		val[3] = lcd_drv->lcd_config->lcd_basic.v_period;
 		ret = sscanf(buf, "basic %d %d %d %d",
 			&val[0], &val[1], &val[2], &val[3]);
-		lcd_drv->lcd_config->lcd_basic.h_active = val[0];
-		lcd_drv->lcd_config->lcd_basic.v_active = val[1];
-		lcd_drv->lcd_config->lcd_basic.h_period = val[2];
-		lcd_drv->lcd_config->lcd_basic.v_period = val[3];
-		pr_info("set h_active=%d, v_active=%d\n", val[0], val[1]);
-		pr_info("set h_period=%d, v_period=%d\n", val[2], val[3]);
-		lcd_tcon_config(lcd_drv->lcd_config);
-		lcd_debug_config_update();
+		if (ret == 4) {
+			pconf->lcd_basic.h_active = val[0];
+			pconf->lcd_basic.v_active = val[1];
+			pconf->lcd_basic.h_period = val[2];
+			pconf->lcd_basic.v_period = val[3];
+			pr_info("set h_active=%d, v_active=%d\n",
+				val[0], val[1]);
+			pr_info("set h_period=%d, v_period=%d\n",
+				val[2], val[3]);
+			lcd_tcon_config(pconf);
+			lcd_debug_config_update();
+		} else {
+			LCDERR("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	case 's':
-		val[0] = lcd_drv->lcd_config->lcd_timing.hsync_width;
-		val[1] = lcd_drv->lcd_config->lcd_timing.hsync_bp;
-		val[2] = lcd_drv->lcd_config->lcd_timing.hsync_pol;
-		val[3] = lcd_drv->lcd_config->lcd_timing.vsync_width;
-		val[4] = lcd_drv->lcd_config->lcd_timing.vsync_bp;
-		val[5] = lcd_drv->lcd_config->lcd_timing.vsync_pol;
 		ret = sscanf(buf, "sync %d %d %d %d %d %d",
 			&val[0], &val[1], &val[2], &val[3], &val[4], &val[5]);
-		lcd_drv->lcd_config->lcd_timing.hsync_width = val[0];
-		lcd_drv->lcd_config->lcd_timing.hsync_bp =    val[1];
-		lcd_drv->lcd_config->lcd_timing.hsync_pol =   val[2];
-		lcd_drv->lcd_config->lcd_timing.vsync_width = val[3];
-		lcd_drv->lcd_config->lcd_timing.vsync_bp =    val[4];
-		lcd_drv->lcd_config->lcd_timing.vsync_pol =   val[5];
-		pr_info("set hsync width=%d, bp=%d, pol=%d\n",
-			val[0], val[1], val[2]);
-		pr_info("set vsync width=%d, bp=%d, pol=%d\n",
-			val[3], val[4], val[5]);
-		lcd_tcon_config(lcd_drv->lcd_config);
-		lcd_debug_config_update();
+		if (ret == 6) {
+			pconf->lcd_timing.hsync_width = val[0];
+			pconf->lcd_timing.hsync_bp =    val[1];
+			pconf->lcd_timing.hsync_pol =   val[2];
+			pconf->lcd_timing.vsync_width = val[3];
+			pconf->lcd_timing.vsync_bp =    val[4];
+			pconf->lcd_timing.vsync_pol =   val[5];
+			pr_info("set hsync width=%d, bp=%d, pol=%d\n",
+				val[0], val[1], val[2]);
+			pr_info("set vsync width=%d, bp=%d, pol=%d\n",
+				val[3], val[4], val[5]);
+			lcd_tcon_config(pconf);
+			lcd_debug_config_update();
+		} else {
+			LCDERR("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	case 't':
-		temp = 0;
 		ret = sscanf(buf, "test %d", &temp);
-		lcd_test(temp);
+		if (ret == 1) {
+			lcd_test(temp);
+		} else {
+			LCDERR("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	case 'i':
 		LCDPR("driver version: %s\n", lcd_drv->version);
@@ -617,9 +675,31 @@ static ssize_t lcd_debug_store(struct class *class,
 			LCDPR("driver version: %s\n", lcd_drv->version);
 			lcd_reg_print();
 		} else if (buf[2] == 's') {
-			aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
-			mdelay(200);
-			aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+			lcd_drv->module_reset();
+		} else if (buf[2] == 'a') {
+			ret = sscanf(buf, "range %d %d %d %d %d %d",
+				&val[0], &val[1], &val[2], &val[3],
+				&val[4], &val[5]);
+			if (ret == 6) {
+				pconf->lcd_basic.h_period_min = val[0];
+				pconf->lcd_basic.h_period_max = val[1];
+				pconf->lcd_basic.h_period_min = val[2];
+				pconf->lcd_basic.v_period_max = val[3];
+				pconf->lcd_basic.lcd_clk_min  = val[4];
+				pconf->lcd_basic.lcd_clk_max  = val[5];
+				pr_info("set h_period min=%d, max=%d\n",
+					pconf->lcd_basic.h_period_min,
+					pconf->lcd_basic.h_period_max);
+				pr_info("set v_period min=%d, max=%d\n",
+					pconf->lcd_basic.v_period_min,
+					pconf->lcd_basic.v_period_max);
+				pr_info("set pclk min=%d, max=%d\n",
+					pconf->lcd_basic.lcd_clk_min,
+					pconf->lcd_basic.lcd_clk_max);
+			} else {
+				LCDERR("invalid data\n");
+				return -EINVAL;
+			}
 		}
 		break;
 	case 'd':
@@ -629,36 +709,40 @@ static ssize_t lcd_debug_store(struct class *class,
 		lcd_reg_print();
 		break;
 	case 'p':
-		temp = 0;
 		ret = sscanf(buf, "power %d", &temp);
-		LCDPR("power: %d\n", temp);
-		LCDPR("to do\n");
+		if (ret == 1) {
+			LCDPR("power: %d\n", temp);
+			LCDPR("to do\n");
+		} else {
+			LCDERR("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	default:
 		LCDERR("wrong command\n");
+		return -EINVAL;
 		break;
 	}
 
-	if (ret != 1 || ret != 2)
-		return -EINVAL;
-
 	return count;
 }
 
 static ssize_t lcd_debug_enable_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	unsigned int temp = 1;
 
 	ret = sscanf(buf, "%d", &temp);
-	if (temp)
-		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
-	else
-		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
-
-	if (ret != 1 || ret != 2)
+	if (ret == 1) {
+		if (temp)
+			aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+		else
+			aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
+	} else {
+		LCDERR("invalid data\n");
 		return -EINVAL;
+	}
 
 	return count;
 }
@@ -682,31 +766,64 @@ static ssize_t lcd_debug_frame_rate_show(struct class *class,
 static ssize_t lcd_debug_frame_rate_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
-	unsigned int temp;
+	int ret = 0;
+	unsigned int temp = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
 	switch (buf[0]) {
 	case 't':
-		temp = 0;
 		ret = sscanf(buf, "type %d", &temp);
-		lcd_drv->lcd_config->lcd_timing.fr_adjust_type = temp;
-		pr_info("set fr_adjust_type: %d\n", temp);
+		if (ret == 1) {
+			lcd_drv->lcd_config->lcd_timing.fr_adjust_type = temp;
+			pr_info("set fr_adjust_type: %d\n", temp);
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	case 's':
-		temp = 60 * 100;
 		ret = sscanf(buf, "set %d", &temp);
-		pr_info("set frame rate(*100): %d\n", temp);
-		aml_lcd_notifier_call_chain(LCD_EVENT_FRAME_RATE_ADJUST, &temp);
-		lcd_debug_config_update();
+		if (ret == 1) {
+			pr_info("set frame rate(*100): %d\n", temp);
+			aml_lcd_notifier_call_chain(
+				LCD_EVENT_FRAME_RATE_ADJUST, &temp);
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	default:
 		pr_info("wrong command\n");
+		return -EINVAL;
 		break;
 	}
 
-	if (ret != 1 || ret != 2)
+	return count;
+}
+
+static ssize_t lcd_debug_fr_policy_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	return sprintf(buf, "fr_auto_policy: %d\n", lcd_drv->fr_auto_policy);
+}
+
+static ssize_t lcd_debug_fr_policy_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	int ret = 0;
+	unsigned int temp = 0;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	ret = sscanf(buf, "%d", &temp);
+	if (ret == 1) {
+		lcd_drv->fr_auto_policy = (unsigned char)temp;
+		pr_info("set fr_auto_policy: %d\n", temp);
+	} else {
+		pr_info("invalid data\n");
 		return -EINVAL;
+	}
 
 	return count;
 }
@@ -721,16 +838,18 @@ static ssize_t lcd_debug_ss_show(struct class *class,
 static ssize_t lcd_debug_ss_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	unsigned int temp = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
 	ret = sscanf(buf, "%d", &temp);
-	lcd_drv->lcd_config->lcd_timing.ss_level = temp;
-	lcd_set_spread_spectrum();
-
-	if (ret != 1 || ret != 2)
+	if (ret == 1) {
+		lcd_drv->lcd_config->lcd_timing.ss_level = temp;
+		lcd_set_spread_spectrum();
+	} else {
+		pr_info("invalid data\n");
 		return -EINVAL;
+	}
 
 	return count;
 }
@@ -745,14 +864,16 @@ static ssize_t lcd_debug_clk_show(struct class *class,
 static ssize_t lcd_debug_test_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	unsigned int temp = 0;
 
 	ret = sscanf(buf, "%d", &temp);
-	lcd_test(temp);
-
-	if (ret != 1 || ret != 2)
+	if (ret == 1) {
+		lcd_test(temp);
+	} else {
+		pr_info("invalid data\n");
 		return -EINVAL;
+	}
 
 	return count;
 }
@@ -863,7 +984,7 @@ static void lcd_debug_reg_dump(unsigned int reg, unsigned int num,
 static ssize_t lcd_debug_reg_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	unsigned int bus = 0;
 	unsigned int reg32, data32;
 
@@ -883,7 +1004,12 @@ static ssize_t lcd_debug_reg_store(struct class *class,
 			ret = sscanf(buf, "wp %x %x", &reg32, &data32);
 			bus = 3;
 		}
-		lcd_debug_reg_write(reg32, data32, bus);
+		if (ret == 2) {
+			lcd_debug_reg_write(reg32, data32, bus);
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	case 'r':
 		reg32 = 0;
@@ -900,7 +1026,12 @@ static ssize_t lcd_debug_reg_store(struct class *class,
 			ret = sscanf(buf, "rp %x", &reg32);
 			bus = 3;
 		}
-		lcd_debug_reg_read(reg32, bus);
+		if (ret == 1) {
+			lcd_debug_reg_read(reg32, bus);
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	case 'd':
 		reg32 = 0;
@@ -917,15 +1048,19 @@ static ssize_t lcd_debug_reg_store(struct class *class,
 			ret = sscanf(buf, "dp %x %d", &reg32, &data32);
 			bus = 3;
 		}
-		lcd_debug_reg_dump(reg32, data32, bus);
+		if (ret == 2) {
+			lcd_debug_reg_dump(reg32, data32, bus);
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
 		break;
 	default:
+		pr_info("wrong command\n");
+		return -EINVAL;
 		break;
 	}
 
-	if (ret != 1 || ret != 2)
-		return -EINVAL;
-
 	return count;
 }
 
@@ -938,15 +1073,17 @@ static ssize_t lcd_debug_print_show(struct class *class,
 static ssize_t lcd_debug_print_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	unsigned int temp = 0;
 
 	ret = sscanf(buf, "%d", &temp);
-	lcd_debug_print_flag = temp;
-	LCDPR("set debug print flag: %d\n", lcd_debug_print_flag);
-
-	if (ret != 1 || ret != 2)
+	if (ret == 1) {
+		lcd_debug_print_flag = temp;
+		LCDPR("set debug print flag: %d\n", lcd_debug_print_flag);
+	} else {
+		pr_info("invalid data\n");
 		return -EINVAL;
+	}
 
 	return count;
 }
@@ -980,6 +1117,8 @@ static struct class_attribute lcd_debug_class_attrs[] = {
 	__ATTR(enable,      S_IRUGO | S_IWUSR, NULL, lcd_debug_enable_store),
 	__ATTR(frame_rate,  S_IRUGO | S_IWUSR,
 		lcd_debug_frame_rate_show, lcd_debug_frame_rate_store),
+	__ATTR(fr_policy,   S_IRUGO | S_IWUSR,
+		lcd_debug_fr_policy_show, lcd_debug_fr_policy_store),
 	__ATTR(ss,          S_IRUGO | S_IWUSR,
 		lcd_debug_ss_show, lcd_debug_ss_store),
 	__ATTR(clk,         S_IRUGO | S_IWUSR, lcd_debug_clk_show, NULL),
@@ -1018,7 +1157,6 @@ static const char *lcd_lvds_debug_usage_str = {
 "data format:\n"
 "    <vswing> : vswing level, support 0~7\n"
 "    <preem>  : preemphasis level, support 0~7\n"
-"    <byte_mode>  : 3/4/5\n"
 "\n"
 };
 
@@ -1080,6 +1218,13 @@ static ssize_t lcd_vx1_debug_show(struct class *class,
 	return sprintf(buf, "%s\n", lcd_vbyone_debug_usage_str);
 }
 
+static int lcd_vx1_intr_enable = 1;
+static ssize_t lcd_vx1_intr_debug_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", lcd_vx1_intr_enable);
+}
+
 static ssize_t lcd_mipi_debug_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
@@ -1095,20 +1240,23 @@ static ssize_t lcd_edp_debug_show(struct class *class,
 static ssize_t lcd_ttl_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct ttl_config_s *ttl_conf;
 
 	ttl_conf = lcd_drv->lcd_config->lcd_control.ttl_config;
 	ret = sscanf(buf, "%d %d %d", &ttl_conf->clk_pol,
 		&ttl_conf->sync_valid, &ttl_conf->swap_ctrl);
-	pr_info("set ttl config:\n"
-		"clk_pol=%d, sync_valid=0x%x, swap_ctrl=0x%x\n",
-		ttl_conf->clk_pol, ttl_conf->sync_valid, ttl_conf->swap_ctrl);
-	lcd_debug_config_update();
-
-	if (ret != 1 || ret != 2)
+	if (ret == 3) {
+		pr_info("set ttl config:\n"
+			"clk_pol=%d, sync_valid=0x%x, swap_ctrl=0x%x\n",
+			ttl_conf->clk_pol, ttl_conf->sync_valid,
+			ttl_conf->swap_ctrl);
+		lcd_debug_config_update();
+	} else {
+		pr_info("invalid data\n");
 		return -EINVAL;
+	}
 
 	return count;
 }
@@ -1116,7 +1264,7 @@ static ssize_t lcd_ttl_debug_store(struct class *class,
 static ssize_t lcd_lvds_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lvds_config_s *lvds_conf;
 
@@ -1124,14 +1272,16 @@ static ssize_t lcd_lvds_debug_store(struct class *class,
 	ret = sscanf(buf, "%d %d %d %d",
 		&lvds_conf->lvds_repack, &lvds_conf->dual_port,
 		&lvds_conf->pn_swap, &lvds_conf->port_swap);
-	pr_info("set lvds config:\n"
-		"repack=%d, dual_port=%d, pn_swap=%d, port_swap=%d\n",
-		lvds_conf->lvds_repack, lvds_conf->dual_port,
-		lvds_conf->pn_swap, lvds_conf->port_swap);
-	lcd_debug_config_update();
-
-	if (ret != 1 || ret != 2)
+	if (ret == 4) {
+		pr_info("set lvds config:\n"
+			"repack=%d, dual_port=%d, pn_swap=%d, port_swap=%d\n",
+			lvds_conf->lvds_repack, lvds_conf->dual_port,
+			lvds_conf->pn_swap, lvds_conf->port_swap);
+		lcd_debug_config_update();
+	} else {
+		pr_info("invalid data\n");
 		return -EINVAL;
+	}
 
 	return count;
 }
@@ -1139,21 +1289,45 @@ static ssize_t lcd_lvds_debug_store(struct class *class,
 static ssize_t lcd_vx1_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
+	int ret = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vbyone_config_s *vx1_conf;
 
 	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
 	ret = sscanf(buf, "%d %d %d", &vx1_conf->lane_count,
 		&vx1_conf->region_num, &vx1_conf->byte_mode);
-	pr_info("set vbyone config:\n"
-		"lane_count=%d, region_num=%d, byte_mode=%d\n",
-		vx1_conf->lane_count, vx1_conf->region_num,
-		vx1_conf->byte_mode);
-	lcd_debug_config_update();
+	if (ret == 3) {
+		pr_info("set vbyone config:\n"
+			"lane_count=%d, region_num=%d, byte_mode=%d\n",
+			vx1_conf->lane_count, vx1_conf->region_num,
+			vx1_conf->byte_mode);
+		lcd_debug_config_update();
+	} else {
+		pr_info("invalid data\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
 
-	if (ret != 1 || ret != 2)
+static ssize_t lcd_vx1_intr_debug_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	int ret = 0;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vbyone_config_s *vx1_conf;
+	int val;
+
+	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
+	ret = sscanf(buf, "%d", &val);
+	if (ret == 1) {
+		pr_info("set vbyone interrupt enable: %d\n", val);
+		lcd_vbyone_interrupt_enable(val);
+		lcd_vx1_intr_enable = val;
+	} else {
+		pr_info("invalid data\n");
 		return -EINVAL;
+	}
 
 	return count;
 }
@@ -1161,26 +1335,16 @@ static ssize_t lcd_vx1_debug_store(struct class *class,
 static ssize_t lcd_mipi_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
-
 	pr_info("to do\n");
 
-	if (ret != 1 || ret != 2)
-		return -EINVAL;
-
 	return count;
 }
 
 static ssize_t lcd_edp_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
-
 	pr_info("to do\n");
 
-	if (ret != 1 || ret != 2)
-		return -EINVAL;
-
 	return count;
 }
 
@@ -1312,20 +1476,22 @@ static ssize_t lcd_phy_debug_show(struct class *class,
 static ssize_t lcd_phy_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	ssize_t ret = 0;
+	int ret = 0;
 	unsigned int para[4];
 
 	ret = sscanf(buf, "%d %d %d %d",
 		&para[0], &para[1], &para[2], &para[3]);
 
-	if (ret == 4)
+	if (ret == 4) {
 		lcd_phy_config_update(para, 4);
-	else if (ret == 2)
+	} else if (ret == 2) {
 		lcd_phy_config_update(para, 2);
-	else
+	} else {
+		pr_info("invalid data\n");
 		return -EINVAL;
+	}
 
-	return ret;
+	return count;
 }
 
 static struct class_attribute lcd_interface_debug_class_attrs[] = {
@@ -1335,6 +1501,8 @@ static struct class_attribute lcd_interface_debug_class_attrs[] = {
 		lcd_lvds_debug_show, lcd_lvds_debug_store),
 	__ATTR(vbyone, S_IRUGO | S_IWUSR,
 		lcd_vx1_debug_show, lcd_vx1_debug_store),
+	__ATTR(vbyone_intr, S_IRUGO | S_IWUSR,
+		lcd_vx1_intr_debug_show, lcd_vx1_intr_debug_store),
 	__ATTR(mipi,   S_IRUGO | S_IWUSR,
 		lcd_mipi_debug_show, lcd_mipi_debug_store),
 	__ATTR(edp,    S_IRUGO | S_IWUSR,
diff --git a/drivers/amlogic/display/lcd/lcd_tablet/lcd_drv.c b/drivers/amlogic/display/lcd/lcd_tablet/lcd_drv.c
index 2610736..99a4f71 100644
--- a/drivers/amlogic/display/lcd/lcd_tablet/lcd_drv.c
+++ b/drivers/amlogic/display/lcd/lcd_tablet/lcd_drv.c
@@ -201,20 +201,12 @@ static void lcd_ttl_control_set(struct lcd_config_s *pconf)
 
 static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 {
-	unsigned int fifo_mode, phy_div, dual_port;
+	unsigned int phy_div;
 
-	dual_port = pconf->lcd_control.lvds_config->dual_port;
-	if (dual_port) {
-		fifo_mode = 0x3;
+	if (pconf->lcd_control.lvds_config->dual_port)
 		phy_div = 2;
-	} else {
-		fifo_mode = 0x1;
+	else
 		phy_div = 1;
-	}
-
-	lcd_vcbus_write(LVDS_GEN_CNTL,
-		(lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
-	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 
 	/* set fifo_clk_sel: div 7 */
 	lcd_hiu_write(HHI_LVDS_TX_PHY_CNTL0, (1 << 6));
@@ -231,10 +223,9 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 {
 	unsigned int bit_num = 1;
-	unsigned int pn_swap = 0;
-	unsigned int dual_port = 1;
+	unsigned int pn_swap, port_swap;
+	unsigned int dual_port, fifo_mode;
 	unsigned int lvds_repack = 1;
-	unsigned int port_swap = 0;
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
@@ -263,6 +254,10 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		bit_num = 1;
 		break;
 	}
+	if (dual_port)
+		fifo_mode = 0x3;
+	else
+		fifo_mode = 0x1;
 
 	lcd_vcbus_write(LVDS_PACK_CNTL_ADDR,
 		(lvds_repack << 0) | /* repack */
@@ -276,6 +271,15 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		(0 << 10) |	/* r_select  //0:R, 1:G, 2:B, 3:0 */
 		(1 << 12) |	/* g_select  //0:R, 1:G, 2:B, 3:0 */
 		(2 << 14));	/* b_select  //0:R, 1:G, 2:B, 3:0 */
+
+	lcd_vcbus_write(LVDS_GEN_CNTL,
+		(lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
+	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
+}
+
+static void lcd_lvds_disable(void)
+{
+	lcd_vcbus_setb(LVDS_GEN_CNTL, 0, 3, 1); /* disable lvds fifo */
 }
 
 static void lcd_venc_set(struct lcd_config_s *pconf)
@@ -314,14 +318,17 @@ static void lcd_venc_set(struct lcd_config_s *pconf)
 
 	lcd_vcbus_write(ENCL_VIDEO_EN, 1);
 
-	/* update backlight parameters for pwm_vs */
-	switch (pconf->lcd_timing.fr_adjust_type) {
-	case 2: /* vtotal adjust */
-		aml_lcd_notifier_call_chain(LCD_EVENT_BACKLIGHT_UPDATE, NULL);
-		break;
-	default:
-		break;
-	}
+	aml_lcd_notifier_call_chain(LCD_EVENT_BACKLIGHT_UPDATE, NULL);
+}
+
+void lcd_tablet_clk_update(struct lcd_config_s *pconf)
+{
+#ifdef CONFIG_AML_VPU
+	request_vpu_clk_vmod(pconf->lcd_timing.lcd_clk, VPU_VENCL);
+#endif
+
+	lcd_clk_generate_parameter(pconf);
+	lcd_clk_set(pconf);
 }
 
 void lcd_tablet_driver_init_pre(void)
@@ -330,8 +337,9 @@ void lcd_tablet_driver_init_pre(void)
 	struct lcd_config_s *pconf;
 	int ret;
 
-	LCDPR("tablet driver init(ver: %s)\n", lcd_drv->version);
 	pconf = lcd_drv->lcd_config;
+	LCDPR("tablet driver init(ver %s): %s\n", lcd_drv->version,
+		lcd_type_type_to_str(pconf->lcd_basic.lcd_type));
 	ret = lcd_type_supported(pconf);
 	if (ret)
 		return;
@@ -398,7 +406,7 @@ void lcd_tablet_driver_disable(void)
 		break;
 	case LCD_LVDS:
 		lcd_lvds_phy_set(pconf, 0);
-		lcd_vcbus_setb(LVDS_GEN_CNTL, 0, 3, 1); /* disable lvds fifo */
+		lcd_lvds_disable();
 		break;
 	default:
 		break;
diff --git a/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.c b/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.c
index 6a261df..dc080b2 100644
--- a/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.c
+++ b/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.c
@@ -30,6 +30,9 @@
 #include <linux/reboot.h>
 #include <linux/of.h>
 #include <linux/reset.h>
+#ifdef CONFIG_AML_VPU
+#include <linux/amlogic/vpu.h>
+#endif
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/vout_notify.h>
 #include <linux/amlogic/vout/lcd_vout.h>
@@ -103,6 +106,148 @@ static int lcd_vout_disable(enum vmode_e cur_vmod)
 	return 0;
 }
 
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+struct lcd_vframe_match_s {
+	int fps;
+	int frame_rate; /* *100 */
+	unsigned int duration_num;
+	unsigned int duration_den;
+};
+
+static struct lcd_vframe_match_s lcd_vframe_match_table_1[] = {
+	{5000, 5000, 50, 1},
+	{2500, 5000, 50, 1},
+	{6000, 6000, 60, 1},
+	{3000, 6000, 60, 1},
+	{2400, 6000, 60, 1},
+	{2397, 5994, 5994, 100},
+	{2997, 5994, 5994, 100},
+	{5994, 5994, 5994, 100},
+};
+
+static struct lcd_vframe_match_s lcd_vframe_match_table_2[] = {
+	{5000, 5000, 50, 1},
+	{2500, 5000, 50, 1},
+	{6000, 6000, 60, 1},
+	{3000, 6000, 60, 1},
+	{2400, 4800, 48, 1},
+	{2397, 5994, 5994, 100},
+	{2997, 5994, 5994, 100},
+	{5994, 5994, 5994, 100},
+};
+
+static int lcd_framerate_automation_set_mode(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	/* update lcd config sync_duration, for calculate */
+	lcd_drv->lcd_config->lcd_timing.sync_duration_num =
+		lcd_drv->lcd_info->sync_duration_num;
+	lcd_drv->lcd_config->lcd_timing.sync_duration_den =
+		lcd_drv->lcd_info->sync_duration_den;
+
+	/* update clk & timing config */
+	lcd_vmode_change(lcd_drv->lcd_config);
+	lcd_drv->lcd_info->video_clk = lcd_drv->lcd_config->lcd_timing.lcd_clk;
+	/* update interface timing if needed, current no need */
+#ifdef CONFIG_AML_VPU
+	request_vpu_clk_vmod(
+		lcd_drv->lcd_config->lcd_timing.lcd_clk, VPU_VENCL);
+#endif
+
+	/* change clk parameter */
+	switch (lcd_drv->lcd_config->lcd_timing.clk_change) {
+	case LCD_CLK_PLL_CHANGE:
+		lcd_clk_generate_parameter(lcd_drv->lcd_config);
+		lcd_clk_set(lcd_drv->lcd_config);
+		break;
+	case LCD_CLK_FRAC_UPDATE:
+		lcd_clk_update(lcd_drv->lcd_config);
+		break;
+	default:
+		break;
+	}
+	lcd_venc_change(lcd_drv->lcd_config);
+
+	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,
+		&lcd_drv->lcd_info->mode);
+
+	return 0;
+}
+#endif
+
+static int lcd_set_vframe_rate_hint(int duration)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vinfo_s *info;
+	unsigned char fr_policy;
+	unsigned int frame_rate = 6000;
+	unsigned int duration_num = 60, duration_den = 1;
+	struct lcd_vframe_match_s *vtable = lcd_vframe_match_table_1;
+	int fps, i, n;
+
+	info = lcd_drv->lcd_info;
+
+	fr_policy = lcd_drv->fr_auto_policy;
+	switch (fr_policy) {
+	case 1:
+		vtable = lcd_vframe_match_table_1;
+		n = ARRAY_SIZE(lcd_vframe_match_table_1);
+		break;
+	case 2:
+		vtable = lcd_vframe_match_table_2;
+		n = ARRAY_SIZE(lcd_vframe_match_table_2);
+		break;
+	default:
+		LCDPR("%s: fr_auto_policy = %d, disabled\n",
+			__func__, fr_policy);
+		return 0;
+		break;
+	}
+	fps = get_vsource_fps(duration);
+	for (i = 0; i < n; i++) {
+		if (fps == vtable[i].fps) {
+			frame_rate = vtable[i].frame_rate;
+			duration_num = vtable[i].duration_num;
+			duration_den = vtable[i].duration_den;
+		}
+	}
+	LCDPR("%s: policy = %d, duration = %d, fps = %d, frame_rate = %d\n",
+		__func__, fr_policy, duration, fps, frame_rate);
+
+	/* update vinfo */
+	info->sync_duration_num = duration_num;
+	info->sync_duration_den = duration_den;
+
+	lcd_framerate_automation_set_mode();
+#endif
+	return 0;
+}
+
+static int lcd_set_vframe_rate_end_hint(void)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vinfo_s *info;
+
+	if (lcd_debug_print_flag)
+		LCDPR("fr_auto_policy = %d\n", lcd_drv->fr_auto_policy);
+	if (lcd_drv->fr_auto_policy) {
+		info = lcd_drv->lcd_info;
+		LCDPR("%s: return mode = %s, policy = %d\n", __func__,
+			info->name, lcd_drv->fr_auto_policy);
+
+		/* update vinfo */
+		info->sync_duration_num = lcd_drv->std_duration.duration_num;
+		info->sync_duration_den = lcd_drv->std_duration.duration_den;
+
+		lcd_framerate_automation_set_mode();
+	}
+#endif
+	return 0;
+}
+
 #ifdef CONFIG_PM
 static int lcd_suspend(void)
 {
@@ -126,6 +271,8 @@ static struct vout_server_s lcd_vout_server = {
 		.validate_vmode = lcd_validate_vmode,
 		.vmode_is_supported = lcd_vmode_is_supported,
 		.disable = lcd_vout_disable,
+		.set_vframe_rate_hint = lcd_set_vframe_rate_hint,
+		.set_vframe_rate_end_hint = lcd_set_vframe_rate_end_hint,
 #ifdef CONFIG_PM
 		.vout_suspend = lcd_suspend,
 		.vout_resume = lcd_resume,
@@ -139,10 +286,6 @@ static void lcd_tablet_vinfo_update(void)
 	struct vinfo_s *vinfo;
 	struct lcd_config_s *pconf;
 
-	if (lcd_drv->lcd_info == NULL) {
-		LCDERR("no lcd_info exist\n");
-		return;
-	}
 	vinfo = lcd_drv->lcd_info;
 	pconf = lcd_drv->lcd_config;
 	if (vinfo) {
@@ -198,16 +341,7 @@ static void lcd_tablet_vinfo_update_default(void)
 
 void lcd_tablet_vout_server_init(void)
 {
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
-	lcd_drv->lcd_info = kmalloc(sizeof(struct vinfo_s), GFP_KERNEL);
-	if (!lcd_drv->lcd_info) {
-		LCDERR("tablet_probe: Not enough memory\n");
-		return;
-	}
-
 	lcd_tablet_vinfo_update_default();
-
 	vout_register_server(&lcd_vout_server);
 }
 
@@ -230,6 +364,13 @@ static void lcd_config_print(struct lcd_config_s *pconf)
 	LCDPR("screen_width = %d\n", pconf->lcd_basic.screen_width);
 	LCDPR("screen_height = %d\n", pconf->lcd_basic.screen_height);
 
+	LCDPR("h_period_min = %d\n", pconf->lcd_basic.h_period_min);
+	LCDPR("h_period_max = %d\n", pconf->lcd_basic.h_period_max);
+	LCDPR("v_period_min = %d\n", pconf->lcd_basic.v_period_min);
+	LCDPR("v_period_max = %d\n", pconf->lcd_basic.v_period_max);
+	LCDPR("pclk_min = %d\n", pconf->lcd_basic.lcd_clk_min);
+	LCDPR("pclk_max = %d\n", pconf->lcd_basic.lcd_clk_max);
+
 	LCDPR("hsync_width = %d\n", pconf->lcd_timing.hsync_width);
 	LCDPR("hsync_bp = %d\n", pconf->lcd_timing.hsync_bp);
 	LCDPR("hsync_pol = %d\n", pconf->lcd_timing.hsync_pol);
@@ -329,6 +470,23 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 		pconf->lcd_basic.screen_width = para[5];
 		pconf->lcd_basic.screen_height = para[6];
 	}
+	ret = of_property_read_u32_array(child, "range_setting", &para[0], 6);
+	if (ret) {
+		LCDERR("failed to get range_setting\n");
+		pconf->lcd_basic.h_period_min = pconf->lcd_basic.h_period;
+		pconf->lcd_basic.h_period_max = pconf->lcd_basic.h_period;
+		pconf->lcd_basic.v_period_min = pconf->lcd_basic.v_period;
+		pconf->lcd_basic.v_period_max = pconf->lcd_basic.v_period;
+		pconf->lcd_basic.lcd_clk_min = 0;
+		pconf->lcd_basic.lcd_clk_max = 0;
+	} else {
+		pconf->lcd_basic.h_period_min = para[0];
+		pconf->lcd_basic.h_period_max = para[1];
+		pconf->lcd_basic.v_period_min = para[2];
+		pconf->lcd_basic.v_period_max = para[3];
+		pconf->lcd_basic.lcd_clk_min = para[4];
+		pconf->lcd_basic.lcd_clk_max = para[5];
+	}
 
 	ret = of_property_read_u32_array(child, "lcd_timing", &para[0], 6);
 	if (ret) {
@@ -385,6 +543,7 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 			pconf->lcd_control.ttl_config->swap_ctrl =
 				((para[3] << 1) | (para[4] << 0));
 		}
+		break;
 	case LCD_LVDS:
 		lvdsconf = pconf->lcd_control.lvds_config;
 		ret = of_property_read_u32_array(child, "lvds_attr",
@@ -524,11 +683,21 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 	pconf->lcd_timing.lcd_clk = (*p | ((*(p + 1)) << 8) |
 		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
 	p += LCD_UKEY_PCLK;
+	pconf->lcd_basic.h_period_min = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_H_PERIOD_MIN;
+	pconf->lcd_basic.h_period_max = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_H_PERIOD_MAX;
+	pconf->lcd_basic.v_period_min = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_V_PERIOD_MIN;
+	pconf->lcd_basic.v_period_max = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_V_PERIOD_MAX;
+	pconf->lcd_basic.lcd_clk_min = (*p | ((*(p + 1)) << 8) |
+		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
+	p += LCD_UKEY_PCLK_MIN;
+	pconf->lcd_basic.lcd_clk_max = (*p | ((*(p + 1)) << 8) |
+		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
+	p += LCD_UKEY_PCLK_MAX;
 	/* dummy pointer */
-	p += LCD_UKEY_CUST_VAL_4;
-	p += LCD_UKEY_CUST_VAL_5;
-	p += LCD_UKEY_CUST_VAL_6;
-	p += LCD_UKEY_CUST_VAL_7;
 	p += LCD_UKEY_CUST_VAL_8;
 	p += LCD_UKEY_CUST_VAL_9;
 
@@ -625,12 +794,16 @@ static void lcd_config_init(struct lcd_config_s *pconf)
 	}
 	pconf->lcd_timing.sync_duration_num = sync_duration;
 	pconf->lcd_timing.sync_duration_den = 100;
-
 	pconf->lcd_timing.lcd_clk_dft = pconf->lcd_timing.lcd_clk;
+	pconf->lcd_timing.h_period_dft = pconf->lcd_basic.h_period;
+	pconf->lcd_timing.v_period_dft = pconf->lcd_basic.v_period;
+
 	lcd_tcon_config(pconf);
 	lcd_clk_generate_parameter(pconf);
 	ss_level = pconf->lcd_timing.ss_level;
 	cconf->ss_level = (ss_level >= cconf->ss_level_max) ? 0 : ss_level;
+
+	lcd_tablet_vinfo_update();
 }
 
 static int lcd_get_config(struct lcd_config_s *pconf, struct device *dev)
@@ -661,8 +834,6 @@ static int lcd_get_config(struct lcd_config_s *pconf, struct device *dev)
 	}
 	lcd_init_load_from_dts(pconf, dev);
 	lcd_config_print(pconf);
-	lcd_tablet_vinfo_update();
-
 	lcd_config_init(pconf);
 
 	return 0;
@@ -679,21 +850,38 @@ static void lcd_set_vinfo(unsigned int sync_duration)
 	LCDPR("%s: sync_duration=%d\n", __func__, sync_duration);
 
 	/* update vinfo */
-	if (lcd_drv->lcd_info) {
-		lcd_drv->lcd_info->sync_duration_num = sync_duration;
-		lcd_drv->lcd_info->sync_duration_den = 100;
-	} else {
-		LCDERR("no lcd_info exist\n");
-	}
-	/* update lcd config sync_duration */
+	lcd_drv->lcd_info->sync_duration_num = sync_duration;
+	lcd_drv->lcd_info->sync_duration_den = 100;
+
+	/* update lcd config sync_duration, for calculate */
 	lcd_drv->lcd_config->lcd_timing.sync_duration_num = sync_duration;
 	lcd_drv->lcd_config->lcd_timing.sync_duration_den = 100;
 
 	/* update clk & timing config */
 	lcd_vmode_change(lcd_drv->lcd_config);
+	lcd_drv->lcd_info->video_clk = lcd_drv->lcd_config->lcd_timing.lcd_clk;
 	/* update interface timing if needed, current no need */
-	/* update clk parameter */
-	lcd_clk_generate_parameter(lcd_drv->lcd_config);
+#ifdef CONFIG_AML_VPU
+	request_vpu_clk_vmod(
+		lcd_drv->lcd_config->lcd_timing.lcd_clk, VPU_VENCL);
+#endif
+
+	/* change clk parameter */
+	switch (lcd_drv->lcd_config->lcd_timing.clk_change) {
+	case LCD_CLK_PLL_CHANGE:
+		lcd_clk_generate_parameter(lcd_drv->lcd_config);
+		lcd_clk_set(lcd_drv->lcd_config);
+		break;
+	case LCD_CLK_FRAC_UPDATE:
+		lcd_clk_update(lcd_drv->lcd_config);
+		break;
+	default:
+		break;
+	}
+	lcd_venc_change(lcd_drv->lcd_config);
+
+	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,
+		&lcd_drv->lcd_info->mode);
 }
 
 static int lcd_frame_rate_adjust_notifier(struct notifier_block *nb,
diff --git a/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.h b/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.h
index f8b7f50..610a4ac 100644
--- a/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.h
+++ b/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.h
@@ -19,7 +19,7 @@
 #ifndef __AML_LCD_TABLET_H__
 #define __AML_LCD_TABLET_H__
 
-#define LCD_DRV_VERSION    "20160623"
+#define LCD_DRV_VERSION    "20160630"
 
 extern void lcd_tablet_driver_init_pre(void);
 extern int lcd_tablet_driver_init(void);
diff --git a/drivers/amlogic/display/lcd/lcd_tv/lcd_drv.c b/drivers/amlogic/display/lcd/lcd_tv/lcd_drv.c
index 9ff5c17..b36adc7 100644
--- a/drivers/amlogic/display/lcd/lcd_tv/lcd_drv.c
+++ b/drivers/amlogic/display/lcd/lcd_tv/lcd_drv.c
@@ -64,37 +64,6 @@ static int lcd_type_supported(struct lcd_config_s *pconf)
 	return ret;
 }
 
-/* set VX1_LOCKN && VX1_HTPDN */
-static void lcd_vbyone_pinmux_set(int status)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct lcd_config_s *pconf;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-#if 1
-	pconf = lcd_drv->lcd_config;
-	if (status) {
-		/* request pinmux */
-		pconf->pin = devm_pinctrl_get_select(lcd_drv->dev, "vbyone");
-		if (IS_ERR(pconf->pin))
-			LCDERR("set vbyone pinmux error\n");
-	} else {
-		/* release pinmux */
-		devm_pinctrl_put(pconf->pin);
-	}
-#else
-	if (status) {
-		lcd_pinmux_clr_mask(7,
-			((1 << 1) | (1 << 2) | (1 << 9) | (1 << 10)));
-		lcd_pinmux_set_mask(7, ((1 << 11) | (1 << 12)));
-	} else {
-		lcd_pinmux_clr_mask(7, ((1 << 11) | (1 << 12)));
-	}
-#endif
-}
-
 static void lcd_vbyone_phy_set(struct lcd_config_s *pconf, int status)
 {
 	unsigned int vswing, preem;
@@ -207,20 +176,12 @@ static void lcd_tcon_set(struct lcd_config_s *pconf)
 
 static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 {
-	unsigned int fifo_mode, phy_div, dual_port;
+	unsigned int phy_div;
 
-	dual_port = pconf->lcd_control.lvds_config->dual_port;
-	if (dual_port) {
-		fifo_mode = 0x3;
+	if (pconf->lcd_control.lvds_config->dual_port)
 		phy_div = 2;
-	} else {
-		fifo_mode = 0x1;
+	else
 		phy_div = 1;
-	}
-
-	lcd_vcbus_write(LVDS_GEN_CNTL,
-		(lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
-	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 
 	/* set fifo_clk_sel: div 7 */
 	lcd_hiu_write(HHI_LVDS_TX_PHY_CNTL0, (1 << 6));
@@ -237,10 +198,9 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 {
 	unsigned int bit_num = 1;
-	unsigned int pn_swap = 0;
-	unsigned int dual_port = 1;
+	unsigned int pn_swap, port_swap;
+	unsigned int dual_port, fifo_mode;
 	unsigned int lvds_repack = 1;
-	unsigned int port_swap = 0;
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
@@ -269,6 +229,10 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		bit_num = 1;
 		break;
 	}
+	if (dual_port)
+		fifo_mode = 0x3;
+	else
+		fifo_mode = 0x1;
 
 	lcd_vcbus_write(LVDS_PACK_CNTL_ADDR,
 		(lvds_repack << 0) | /* repack */
@@ -282,6 +246,10 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		(0 << 10) |	/* r_select  //0:R, 1:G, 2:B, 3:0 */
 		(1 << 12) |	/* g_select  //0:R, 1:G, 2:B, 3:0 */
 		(2 << 14));	/* b_select  //0:R, 1:G, 2:B, 3:0 */
+
+	lcd_vcbus_write(LVDS_GEN_CNTL,
+		(lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
+	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 }
 
 static void lcd_lvds_disable(void)
@@ -540,7 +508,7 @@ static void lcd_vbyone_disable(void)
 }
 
 #define VBYONE_INTR_UNMASK    0x2a00 /* enable htpdn_fail,lockn_fail,acq_hold */
-static void lcd_vbyone_interrupt_enable(int flag)
+void lcd_vbyone_interrupt_enable(int flag)
 {
 	if (lcd_debug_print_flag)
 		LCDPR("%s: %d\n", __func__, flag);
@@ -586,7 +554,7 @@ static void lcd_vbyone_interrupt_init(void)
 		LCDPR("%s\n", __func__);
 }
 
-static void lcd_vbyone_wait_stable(void)
+void lcd_vbyone_wait_stable(void)
 {
 	int i = 5000;
 
@@ -599,6 +567,23 @@ static void lcd_vbyone_wait_stable(void)
 	lcd_vbyone_interrupt_enable(1);
 }
 
+static void lcd_vx1_wait_hpd(void)
+{
+	int i = 0;
+	LCDPR("vx1 wait hpd to low ...\n");
+	while (lcd_vcbus_read(VBO_STATUS_L) & 0x40) {
+		if (i++ >= 10000)
+			break;
+		udelay(50);
+	}
+	if (lcd_vcbus_read(VBO_STATUS_L) & 0x40)
+		LCDPR("%s: hpd=%d\n", __func__,
+			((lcd_vcbus_read(VBO_STATUS_L) >> 6) & 0x1));
+	else
+		LCDPR("%s: hpd=%d, i=%d\n", __func__,
+			((lcd_vcbus_read(VBO_STATUS_L) >> 6) & 0x1), i);
+}
+
 static irqreturn_t lcd_vbyone_vsync_isr(int irq, void *dev_id)
 {
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 0, 1);
@@ -607,6 +592,8 @@ static irqreturn_t lcd_vbyone_vsync_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+#define VX1_LOCKN_WAIT_TIMEOUT    100
+static int vx1_lockn_wait_cnt;
 static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 {
 	unsigned int data32, data32_1;
@@ -642,6 +629,21 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 		LCDPR("vx1 lockn fall edge occurred\n");
 		vx1_fsm_acq_st = 0;
 		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
+		if (vx1_lockn_wait_cnt++ > VX1_LOCKN_WAIT_TIMEOUT) {
+			LCDPR("vx1 sw reset for lockn timeout\n");
+			/* force PHY to 0 */
+			lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
+			lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
+			udelay(5);
+			/* clear lockn raising flag */
+			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 7, 1);
+			/* realease PHY */
+			lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 0, 8, 2);
+			/* clear lockn raising flag */
+			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 7, 1);
+			lcd_vcbus_write(VBO_SOFT_RST, 0);
+			vx1_lockn_wait_cnt = 0;
+		}
 	}
 #if 0
 	if (data32 & 0x1000) {
@@ -652,8 +654,10 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 #endif
 	if (data32 & 0x2000) {
 		LCDPR("vx1 fsm_acq wait end\n");
-		LCDPR("vx1 status 0: 0x%x, fsm_acq_st: %d\n",
-			lcd_vcbus_read(VBO_STATUS_L), vx1_fsm_acq_st);
+		if (lcd_debug_print_flag) {
+			LCDPR("vx1 status 0: 0x%x, fsm_acq_st: %d\n",
+				lcd_vcbus_read(VBO_STATUS_L), vx1_fsm_acq_st);
+		}
 		if (vx1_fsm_acq_st == 0) {
 			/* clear FSM_continue */
 			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
@@ -679,6 +683,8 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 			lcd_vcbus_read(VBO_STATUS_L), vx1_fsm_acq_st);
 	}
 	udelay(20);
+	if ((lcd_vcbus_read(VBO_STATUS_L) & 0x3f) == 0x20)
+		vx1_lockn_wait_cnt = 0;
 
 	/* enable interrupt */
 	lcd_vcbus_setb(VBO_INTR_UNMASK, VBYONE_INTR_UNMASK, 0, 15);
@@ -732,14 +738,6 @@ static void lcd_venc_set(struct lcd_config_s *pconf)
 	lcd_vcbus_write(ENCL_VIDEO_RGBIN_CTRL, 3);
 
 	lcd_vcbus_write(ENCL_VIDEO_EN, 1);
-}
-
-static void lcd_venc_change(struct lcd_config_s *pconf)
-{
-	lcd_vcbus_write(ENCL_VIDEO_MAX_PXCNT, pconf->lcd_basic.h_period - 1);
-	lcd_vcbus_write(ENCL_VIDEO_MAX_LNCNT, pconf->lcd_basic.v_period - 1);
-	LCDPR("venc changed: %d,%d\n",
-		pconf->lcd_basic.h_period, pconf->lcd_basic.v_period);
 
 	aml_lcd_notifier_call_chain(LCD_EVENT_BACKLIGHT_UPDATE, NULL);
 }
@@ -814,17 +812,38 @@ static void lcd_vbyone_config_set(struct lcd_config_s *pconf)
 	}
 }
 
+void lcd_tv_clk_update(struct lcd_config_s *pconf)
+{
+#ifdef CONFIG_AML_VPU
+	request_vpu_clk_vmod(pconf->lcd_timing.lcd_clk, VPU_VENCL);
+#endif
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_VBYONE:
+		lcd_vbyone_config_set(pconf);
+		lcd_vbyone_interrupt_enable(0);
+		break;
+	default:
+		break;
+	}
+	lcd_clk_generate_parameter(pconf);
+	lcd_clk_set(pconf);
+	if (pconf->lcd_basic.lcd_type == LCD_VBYONE)
+		lcd_vbyone_wait_stable();
+}
+
 void lcd_tv_config_update(struct lcd_config_s *pconf)
 {
-	const struct vinfo_s *info;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vinfo_s *info;
 
 	/* update lcd config sync_duration */
-	info = lcd_tv_get_vinfo();
+	info = lcd_drv->lcd_info;
 	pconf->lcd_timing.sync_duration_num = info->sync_duration_num;
 	pconf->lcd_timing.sync_duration_den = info->sync_duration_den;
 
 	/* update clk & timing config */
 	lcd_vmode_change(pconf);
+	info->video_clk = pconf->lcd_timing.lcd_clk;
 	/* update interface timing */
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_VBYONE:
@@ -841,8 +860,9 @@ void lcd_tv_driver_init_pre(void)
 	struct lcd_config_s *pconf;
 	int ret;
 
-	LCDPR("tv driver init(ver: %s)\n", lcd_drv->version);
 	pconf = lcd_drv->lcd_config;
+	LCDPR("tv driver init(ver %s): %s\n", lcd_drv->version,
+		lcd_type_type_to_str(pconf->lcd_basic.lcd_type));
 	ret = lcd_type_supported(pconf);
 	if (ret)
 		return;
@@ -889,25 +909,25 @@ int lcd_tv_driver_init(void)
 		case LCD_VBYONE:
 			lcd_vbyone_pinmux_set(1);
 			lcd_vbyone_control_set(pconf);
+			lcd_vx1_wait_hpd();
 			lcd_vbyone_phy_set(pconf, 1);
 			break;
 		default:
 			break;
 		}
 	} else { /* change */
-		switch (pconf->lcd_timing.fr_adjust_type) {
-		case 0: /* clk adjust */
+		switch (pconf->lcd_timing.clk_change) {
+		case LCD_CLK_PLL_CHANGE:
 			lcd_clk_generate_parameter(pconf);
 			lcd_clk_set(pconf);
 			break;
-		case 1: /* htotal adjust */
-		case 2: /* vtotal adjust */
+		case LCD_CLK_FRAC_UPDATE:
 			lcd_clk_update(pconf);
-			lcd_venc_change(pconf);
 			break;
 		default:
 			break;
 		}
+		lcd_venc_change(pconf);
 	}
 	if (pconf->lcd_basic.lcd_type == LCD_VBYONE)
 		lcd_vbyone_wait_stable();
@@ -964,6 +984,7 @@ void lcd_tv_driver_disable(void)
 void lcd_vbyone_interrupt_up(void)
 {
 	lcd_vbyone_interrupt_init();
+	vx1_lockn_wait_cnt = 0;
 
 	if (request_irq(INT_VIU_VSYNC, &lcd_vbyone_vsync_isr,
 		IRQF_SHARED, "vbyone_vsync", (void *)"vbyone_vsync")) {
diff --git a/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.c b/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.c
index 764e09b..a34dcd7 100644
--- a/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.c
+++ b/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.c
@@ -30,6 +30,9 @@
 #include <linux/reboot.h>
 #include <linux/of.h>
 #include <linux/reset.h>
+#ifdef CONFIG_AML_VPU
+#include <linux/amlogic/vpu.h>
+#endif
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/vout_notify.h>
 #include <linux/amlogic/vout/lcd_vout.h>
@@ -39,215 +42,190 @@
 #include "../lcd_reg.h"
 #include "../lcd_common.h"
 
-static unsigned int lcd_output_mode;
+static unsigned int lcd_output_vmode;
+static char lcd_output_name[30];
+
 static DEFINE_MUTEX(lcd_vout_mutex);
 
-enum {
-	LCD_OUTPUT_MODE_768P60HZ = 0,
-	LCD_OUTPUT_MODE_768P50HZ,
-	LCD_OUTPUT_MODE_1080P60HZ,
-	LCD_OUTPUT_MODE_1080P50HZ,
-	LCD_OUTPUT_MODE_4K2K60HZ420,
-	LCD_OUTPUT_MODE_4K2K50HZ420,
-	LCD_OUTPUT_MODE_4K2K60HZ,
-	LCD_OUTPUT_MODE_4K2K50HZ,
-	LCD_OUTPUT_MODE_MAX,
+/* ************************************************** *
+   lcd mode function
+ * ************************************************** */
+static unsigned int lcd_std_frame_rate[] = {
+	50,
+	60,
+	48,
 };
 
-static struct vinfo_s lcd_info[] = {
+struct lcd_vmode_info_s {
+	char *name;
+	enum vmode_e mode;
+	unsigned int width;
+	unsigned int height;
+	unsigned int frame_rate;
+};
+
+enum lcd_vmode_e {
+	LCD_VMODE_600P = 0,
+	LCD_VMODE_768P,
+	LCD_VMODE_1080P,
+	LCD_VMODE_2160P,
+	LCD_VMODE_MAX,
+};
+
+static struct lcd_vmode_info_s lcd_vmode_info[] = {
 	{
-		.name              = "768p60hz",
-		.mode              = VMODE_768P,
-		.width             = 1366,
-		.height            = 768,
-		.field_height      = 768,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
+		.name              = "600p",
+		.mode              = VMODE_LCD,
+		.width             = 1024,
+		.height            = 600,
+		.frame_rate        = 60,
 	},
 	{
-		.name              = "768p50hz",
-		.mode              = VMODE_768P_50HZ,
+		.name              = "768p",
+		.mode              = VMODE_LCD,
 		.width             = 1366,
 		.height            = 768,
-		.field_height      = 768,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
+		.frame_rate        = 60,
 	},
 	{
-		.name              = "1080p60hz",
-		.mode              = VMODE_1080P,
+		.name              = "1080p",
+		.mode              = VMODE_LCD,
 		.width             = 1920,
 		.height            = 1080,
-		.field_height      = 1080,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
+		.frame_rate        = 60,
 	},
 	{
-		.name              = "1080p50hz",
-		.mode              = VMODE_1080P_50HZ,
-		.width             = 1920,
-		.height            = 1080,
-		.field_height      = 1080,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
-	},
-	{
-		.name              = "2160p60hz420",
-		.mode              = VMODE_4K2K_60HZ_Y420,
+		.name              = "2160p",
+		.mode              = VMODE_LCD,
 		.width             = 3840,
 		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
-	},
-	{
-		.name              = "2160p50hz420",
-		.mode              = VMODE_4K2K_50HZ_Y420,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
-	},
-	{
-		.name              = "2160p60hz",
-		.mode              = VMODE_4K2K_60HZ,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
-	},
-	{
-		.name              = "2160p50hz",
-		.mode              = VMODE_4K2K_50HZ,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
+		.frame_rate        = 60,
 	},
 	{
 		.name              = "invalid",
 		.mode              = VMODE_INIT_NULL,
 		.width             = 1920,
 		.height            = 1080,
-		.field_height      = 1080,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-		.viu_color_fmt     = TVIN_RGB444,
+		.frame_rate        = 60,
 	},
 };
 
-static int lcd_get_vmode(enum vmode_e mode)
-{
-	int lcd_vmode = LCD_OUTPUT_MODE_MAX;
-	int i, count = ARRAY_SIZE(lcd_info) - 1;
-
-	for (i = 0; i < count; i++) {
-		if (mode == lcd_info[i].mode) {
-			lcd_vmode = i;
-			break;
-		}
-	}
-	return lcd_vmode;
-}
-
 static int lcd_vmode_is_mached(int index)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lcd_config_s *pconf;
 
 	pconf = lcd_drv->lcd_config;
-	if ((pconf->lcd_basic.h_active == lcd_info[index].width) &&
-		(pconf->lcd_basic.v_active == lcd_info[index].height))
+	if ((pconf->lcd_basic.h_active == lcd_vmode_info[index].width) &&
+		(pconf->lcd_basic.v_active == lcd_vmode_info[index].height))
 		return 0;
 	else
 		return -1;
 }
 
-static const struct vinfo_s *lcd_get_valid_vinfo(char *mode)
+static int lcd_get_vmode(enum vmode_e mode)
 {
-	const struct vinfo_s *vinfo = NULL;
-	int i, count = ARRAY_SIZE(lcd_info);
-	int name_len = 0;
+	int lcd_vmode = LCD_VMODE_MAX;
+	int i, count = ARRAY_SIZE(lcd_vmode_info) - 1;
 	int ret;
 
 	for (i = 0; i < count; i++) {
-		if (strncmp(lcd_info[i].name, mode,
-			strlen(lcd_info[i].name)) == 0) {
-			if ((vinfo == NULL) ||
-				(strlen(lcd_info[i].name) > name_len)) {
-				ret = lcd_vmode_is_mached(i);
-				if (ret == 0) {
-					vinfo = &lcd_info[i];
-					name_len = strlen(lcd_info[i].name);
-				}
+		if (mode == lcd_vmode_info[i].mode) {
+			ret = lcd_vmode_is_mached(i);
+			if (ret == 0) {
+				lcd_vmode = i;
+				break;
 			}
 		}
 	}
-	return vinfo;
+	return lcd_vmode;
 }
 
-struct vinfo_s *lcd_tv_get_vinfo(void)
+static int lcd_outputmode_to_lcd_vmode(const char *mode)
 {
-	struct vinfo_s *info;
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	int lcd_vmode = LCD_VMODE_MAX;
+	int i, count = ARRAY_SIZE(lcd_vmode_info) - 1;
+	char temp[30], *p;
+	int n;
+
+	p = strchr(mode, 'p');
+	if (p == NULL)
+		return LCD_VMODE_MAX;
+	n = p - mode + 1;
+	strncpy(temp, mode, n);
+	temp[n] = '\0';
+	if (lcd_debug_print_flag)
+		LCDPR("outputmode=%s, lcd_vmode=%s\n", mode, temp);
 
-	info = &lcd_info[lcd_output_mode];
-	if (lcd_drv->lcd_info == NULL)
-		LCDERR("no lcd_info exist\n");
-	else
-		info = lcd_drv->lcd_info;
-	return info;
+	for (i = 0; i < count; i++) {
+		if (strcmp(temp, lcd_vmode_info[i].name) == 0) {
+			lcd_vmode = i;
+			break;
+		}
+	}
+	return lcd_vmode;
+}
+
+static int lcd_outputmode_to_lcd_frame_rate(const char *mode)
+{
+	int frame_rate = 0;
+	char temp[30], *p;
+	int n, i, ret = 0;
+
+	p = strchr(mode, 'p');
+	if (p == NULL)
+		return 0;
+	n = p - mode + 1;
+	strncpy(temp, mode+n, (strlen(mode)-n));
+	p = strchr(temp, 'h');
+	if (p == NULL)
+		return 0;
+	*p = '\0';
+	ret = sscanf(temp, "%d", &n);
+	if (lcd_debug_print_flag)
+		LCDPR("outputmode=%s, frame_rate=%d\n", mode, n);
+
+	for (i = 0; i < ARRAY_SIZE(lcd_std_frame_rate); i++) {
+		if (n == lcd_std_frame_rate[i]) {
+			frame_rate = n;
+			break;
+		}
+	}
+	return frame_rate;
 }
 
 static void lcd_vmode_vinfo_update(enum vmode_e mode)
 {
-	const struct vinfo_s *info;
+	struct lcd_vmode_info_s *info;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
 
-	lcd_output_mode = lcd_get_vmode(mode);
-	if (lcd_output_mode >= LCD_OUTPUT_MODE_MAX)
-		lcd_output_mode = LCD_OUTPUT_MODE_MAX;
-	info = &lcd_info[lcd_output_mode];
+	lcd_output_vmode = lcd_get_vmode(mode);
+	info = &lcd_vmode_info[lcd_output_vmode];
+	sprintf(lcd_output_name, "%s%dhz", info->name, info->frame_rate);
 	if (lcd_debug_print_flag) {
-		LCDPR("%s vmode = %d, lcd_mode = %d\n",
-			__func__, mode, lcd_output_mode);
+		LCDPR("%s vmode = %d, lcd_vmode = %d, outputmode = %s\n",
+			__func__, mode, lcd_output_vmode, lcd_output_name);
 	}
 
+	/* store standard duration */
+	lcd_drv->std_duration.duration_num = info->frame_rate;
+	lcd_drv->std_duration.duration_den = 1;
+
 	/* update vinfo */
-	if (lcd_drv->lcd_info == NULL) {
-		LCDERR("no lcd_info exist\n");
-		return;
-	}
-	memcpy(lcd_drv->lcd_info, info, sizeof(struct vinfo_s));
+	pconf = lcd_drv->lcd_config;
+	lcd_drv->lcd_info->name = lcd_output_name;
+	lcd_drv->lcd_info->mode = info->mode;
+	lcd_drv->lcd_info->width = info->width;
+	lcd_drv->lcd_info->height = info->height;
+	lcd_drv->lcd_info->field_height = info->height;
+	lcd_drv->lcd_info->aspect_ratio_num = pconf->lcd_basic.screen_width;
+	lcd_drv->lcd_info->aspect_ratio_den = pconf->lcd_basic.screen_height;
+	lcd_drv->lcd_info->screen_real_width = pconf->lcd_basic.screen_width;
+	lcd_drv->lcd_info->screen_real_height = pconf->lcd_basic.screen_height;
+	lcd_drv->lcd_info->sync_duration_num = info->frame_rate;
+	lcd_drv->lcd_info->sync_duration_den = 1;
+	lcd_drv->lcd_info->video_clk = pconf->lcd_timing.lcd_clk;
 }
 
 /* ************************************************** *
@@ -255,28 +233,44 @@ static void lcd_vmode_vinfo_update(enum vmode_e mode)
  * ************************************************** */
 static enum vmode_e lcd_validate_vmode(char *mode)
 {
-	const struct vinfo_s *info;
+	int lcd_vmode, frame_rate;
+	int ret;
 
 	if (mode == NULL)
 		return VMODE_MAX;
 
-	info = lcd_get_valid_vinfo(mode);
-	if (info)
-		return info->mode;
+	lcd_vmode = lcd_outputmode_to_lcd_vmode(mode);
+	ret = lcd_vmode_is_mached(lcd_vmode);
+	if (ret) {
+		LCDERR("%s: outputmode is not support\n", __func__);
+		return VMODE_MAX;
+	}
+	frame_rate = lcd_outputmode_to_lcd_frame_rate(mode);
+	if (frame_rate == 0) {
+		LCDERR("%s: frame_rate is not support\n", __func__);
+		return VMODE_MAX;
+	} else {
+		lcd_vmode_info[lcd_vmode].frame_rate = frame_rate;
+		if (lcd_vmode < LCD_VMODE_MAX)
+			return lcd_vmode_info[lcd_vmode].mode;
+		else
+			return VMODE_MAX;
+	}
 
 	return VMODE_MAX;
 }
 
 static struct vinfo_s *lcd_get_current_info(void)
 {
-	return lcd_tv_get_vinfo();
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	return lcd_drv->lcd_info;
 }
 
 static int lcd_set_current_vmode(enum vmode_e mode)
 {
 	int ret = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	const struct vinfo_s *info;
 
 	mutex_lock(&lcd_vout_mutex);
 
@@ -285,14 +279,7 @@ static int lcd_set_current_vmode(enum vmode_e mode)
 
 	if (!(mode & VMODE_INIT_BIT_MASK)) {
 		switch (mode & VMODE_MODE_BIT_MASK) {
-		case VMODE_768P:
-		case VMODE_768P_50HZ:
-		case VMODE_1080P:
-		case VMODE_1080P_50HZ:
-		case VMODE_4K2K_60HZ_Y420:
-		case VMODE_4K2K_50HZ_Y420:
-		case VMODE_4K2K_60HZ:
-		case VMODE_4K2K_50HZ:
+		case VMODE_LCD:
 			lcd_drv->driver_init_pre();
 			ret = lcd_drv->driver_init();
 			break;
@@ -301,8 +288,7 @@ static int lcd_set_current_vmode(enum vmode_e mode)
 		}
 	}
 
-	info = lcd_tv_get_vinfo();
-	lcd_vcbus_write(VPP_POSTBLEND_H_SIZE, info->width);
+	lcd_vcbus_write(VPP_POSTBLEND_H_SIZE, lcd_drv->lcd_info->width);
 
 	mutex_unlock(&lcd_vout_mutex);
 	return ret;
@@ -310,31 +296,159 @@ static int lcd_set_current_vmode(enum vmode_e mode)
 
 static int lcd_vmode_is_supported(enum vmode_e mode)
 {
-	int m;
+	int lcd_vmode;
 
 	mode &= VMODE_MODE_BIT_MASK;
-	m = lcd_get_vmode(mode);
-	LCDPR("%s vmode = %d, lcd_mode = %d(%s)\n",
-		__func__, mode, m, lcd_info[m].name);
-
-	switch (mode) {
-	case VMODE_768P:
-	case VMODE_768P_50HZ:
-	case VMODE_1080P:
-	case VMODE_1080P_50HZ:
-	case VMODE_4K2K_60HZ_Y420:
-	case VMODE_4K2K_50HZ_Y420:
-	case VMODE_4K2K_60HZ:
-	case VMODE_4K2K_50HZ:
+	lcd_vmode = lcd_get_vmode(mode);
+	LCDPR("%s vmode = %d, lcd_vmode = %d(%s)\n",
+		__func__, mode, lcd_vmode, lcd_vmode_info[lcd_vmode].name);
+
+	if (lcd_vmode < LCD_VMODE_MAX)
 		return true;
+	else
+		return false;
+}
+
+static int lcd_vout_disable(enum vmode_e cur_vmod)
+{
+	return 0;
+}
+
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+struct lcd_vframe_match_s {
+	int fps;
+	int frame_rate; /* *100 */
+	unsigned int duration_num;
+	unsigned int duration_den;
+};
+
+static struct lcd_vframe_match_s lcd_vframe_match_table_1[] = {
+	{5000, 5000, 50, 1},
+	{2500, 5000, 50, 1},
+	{6000, 6000, 60, 1},
+	{3000, 6000, 60, 1},
+	{2400, 6000, 60, 1},
+	{2397, 5994, 5994, 100},
+	{2997, 5994, 5994, 100},
+	{5994, 5994, 5994, 100},
+};
+
+static struct lcd_vframe_match_s lcd_vframe_match_table_2[] = {
+	{5000, 5000, 50, 1},
+	{2500, 5000, 50, 1},
+	{6000, 6000, 60, 1},
+	{3000, 6000, 60, 1},
+	{2400, 4800, 48, 1},
+	{2397, 5994, 5994, 100},
+	{2997, 5994, 5994, 100},
+	{5994, 5994, 5994, 100},
+};
+
+static int lcd_framerate_automation_set_mode(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	/* update interface timing */
+	lcd_tv_config_update(lcd_drv->lcd_config);
+#ifdef CONFIG_AML_VPU
+	request_vpu_clk_vmod(
+		lcd_drv->lcd_config->lcd_timing.lcd_clk, VPU_VENCL);
+#endif
+
+	if (lcd_drv->lcd_config->lcd_basic.lcd_type == LCD_VBYONE)
+		lcd_vbyone_interrupt_enable(0);
+	/* change clk parameter */
+	switch (lcd_drv->lcd_config->lcd_timing.clk_change) {
+	case LCD_CLK_PLL_CHANGE:
+		lcd_clk_generate_parameter(lcd_drv->lcd_config);
+		lcd_clk_set(lcd_drv->lcd_config);
+		break;
+	case LCD_CLK_FRAC_UPDATE:
+		lcd_clk_update(lcd_drv->lcd_config);
 		break;
 	default:
-		return false;
+		break;
 	}
+	lcd_venc_change(lcd_drv->lcd_config);
+	if (lcd_drv->lcd_config->lcd_basic.lcd_type == LCD_VBYONE)
+		lcd_vbyone_wait_stable();
+
+	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,
+		&lcd_drv->lcd_info->mode);
+
+	return 0;
 }
+#endif
 
-static int lcd_vout_disable(enum vmode_e cur_vmod)
+static int lcd_set_vframe_rate_hint(int duration)
 {
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vinfo_s *info;
+	unsigned char fr_policy;
+	unsigned int frame_rate = 6000;
+	unsigned int duration_num = 60, duration_den = 1;
+	struct lcd_vframe_match_s *vtable = lcd_vframe_match_table_1;
+	int fps, i, n;
+
+	info = lcd_drv->lcd_info;
+
+	fr_policy = lcd_drv->fr_auto_policy;
+	switch (fr_policy) {
+	case 1:
+		vtable = lcd_vframe_match_table_1;
+		n = ARRAY_SIZE(lcd_vframe_match_table_1);
+		break;
+	case 2:
+		vtable = lcd_vframe_match_table_2;
+		n = ARRAY_SIZE(lcd_vframe_match_table_2);
+		break;
+	default:
+		LCDPR("%s: fr_auto_policy = %d, disabled\n",
+			__func__, fr_policy);
+		return 0;
+		break;
+	}
+	fps = get_vsource_fps(duration);
+	for (i = 0; i < n; i++) {
+		if (fps == vtable[i].fps) {
+			frame_rate = vtable[i].frame_rate;
+			duration_num = vtable[i].duration_num;
+			duration_den = vtable[i].duration_den;
+		}
+	}
+	LCDPR("%s: policy = %d, duration = %d, fps = %d, frame_rate = %d\n",
+		__func__, fr_policy, duration, fps, frame_rate);
+
+	/* update vinfo */
+	info->sync_duration_num = duration_num;
+	info->sync_duration_den = duration_den;
+
+	lcd_framerate_automation_set_mode();
+#endif
+	return 0;
+}
+
+static int lcd_set_vframe_rate_end_hint(void)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vinfo_s *info;
+
+	if (lcd_debug_print_flag)
+		LCDPR("fr_auto_policy = %d\n", lcd_drv->fr_auto_policy);
+	if (lcd_drv->fr_auto_policy) {
+		info = lcd_drv->lcd_info;
+		LCDPR("%s: return mode = %s, policy = %d\n", __func__,
+			info->name, lcd_drv->fr_auto_policy);
+
+		/* update vinfo */
+		info->sync_duration_num = lcd_drv->std_duration.duration_num;
+		info->sync_duration_den = lcd_drv->std_duration.duration_den;
+
+		lcd_framerate_automation_set_mode();
+	}
+#endif
 	return 0;
 }
 
@@ -361,6 +475,8 @@ static struct vout_server_s lcd_vout_server = {
 		.validate_vmode = lcd_validate_vmode,
 		.vmode_is_supported = lcd_vmode_is_supported,
 		.disable = lcd_vout_disable,
+		.set_vframe_rate_hint = lcd_set_vframe_rate_hint,
+		.set_vframe_rate_end_hint = lcd_set_vframe_rate_end_hint,
 #ifdef CONFIG_PM
 		.vout_suspend = lcd_suspend,
 		.vout_resume = lcd_resume,
@@ -368,14 +484,45 @@ static struct vout_server_s lcd_vout_server = {
 	},
 };
 
-void lcd_tv_vout_server_init(void)
+static void lcd_vinfo_update_default(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vinfo_s *vinfo;
+	unsigned int h_active, v_active;
+	char *mode;
 
-	lcd_drv->lcd_info = kmalloc(sizeof(struct vinfo_s), GFP_KERNEL);
-	if (!lcd_drv->lcd_info)
-		LCDERR("tv_probe: Not enough memory\n");
+	if (lcd_drv->lcd_info == NULL) {
+		LCDERR("no lcd_info exist\n");
+		return;
+	}
 
+	mode = get_vout_mode_uboot();
+	h_active = lcd_vcbus_read(ENCL_VIDEO_HAVON_END)
+			- lcd_vcbus_read(ENCL_VIDEO_HAVON_BEGIN) + 1;
+	v_active = lcd_vcbus_read(ENCL_VIDEO_VAVON_ELINE)
+			- lcd_vcbus_read(ENCL_VIDEO_VAVON_BLINE) + 1;
+
+	vinfo = lcd_drv->lcd_info;
+	if (vinfo) {
+		vinfo->name = mode;
+		vinfo->mode = VMODE_LCD;
+		vinfo->width = h_active;
+		vinfo->height = v_active;
+		vinfo->field_height = v_active;
+		vinfo->aspect_ratio_num = h_active;
+		vinfo->aspect_ratio_den = v_active;
+		vinfo->screen_real_width = h_active;
+		vinfo->screen_real_height = v_active;
+		vinfo->sync_duration_num = 60;
+		vinfo->sync_duration_den = 1;
+		vinfo->video_clk = 0;
+		vinfo->viu_color_fmt = TVIN_RGB444;
+	}
+}
+
+void lcd_tv_vout_server_init(void)
+{
+	lcd_vinfo_update_default();
 	vout_register_server(&lcd_vout_server);
 }
 
@@ -398,6 +545,13 @@ static void lcd_config_print(struct lcd_config_s *pconf)
 	LCDPR("screen_width = %d\n", pconf->lcd_basic.screen_width);
 	LCDPR("screen_height = %d\n", pconf->lcd_basic.screen_height);
 
+	LCDPR("h_period_min = %d\n", pconf->lcd_basic.h_period_min);
+	LCDPR("h_period_max = %d\n", pconf->lcd_basic.h_period_max);
+	LCDPR("v_period_min = %d\n", pconf->lcd_basic.v_period_min);
+	LCDPR("v_period_max = %d\n", pconf->lcd_basic.v_period_max);
+	LCDPR("pclk_min = %d\n", pconf->lcd_basic.lcd_clk_min);
+	LCDPR("pclk_max = %d\n", pconf->lcd_basic.lcd_clk_max);
+
 	LCDPR("hsync_width = %d\n", pconf->lcd_timing.hsync_width);
 	LCDPR("hsync_bp = %d\n", pconf->lcd_timing.hsync_bp);
 	LCDPR("hsync_pol = %d\n", pconf->lcd_timing.hsync_pol);
@@ -438,12 +592,8 @@ static int lcd_init_load_from_dts(struct lcd_config_s *pconf,
 
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_VBYONE:
-		if (lcd_drv->lcd_status) { /* lock pinmux if lcd in on */
-			pconf->pin = devm_pinctrl_get_select(dev,
-				"vbyone");
-			if (IS_ERR(pconf->pin))
-				LCDERR("get vbyone pinmux error\n");
-		}
+		if (lcd_drv->lcd_status) /* lock pinmux if lcd in on */
+			lcd_vbyone_pinmux_set(1);
 		break;
 	default:
 		break;
@@ -501,6 +651,23 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 		pconf->lcd_basic.screen_width = para[5];
 		pconf->lcd_basic.screen_height = para[6];
 	}
+	ret = of_property_read_u32_array(child, "range_setting", &para[0], 6);
+	if (ret) {
+		LCDERR("failed to get range_setting\n");
+		pconf->lcd_basic.h_period_min = pconf->lcd_basic.h_period;
+		pconf->lcd_basic.h_period_max = pconf->lcd_basic.h_period;
+		pconf->lcd_basic.v_period_min = pconf->lcd_basic.v_period;
+		pconf->lcd_basic.v_period_max = pconf->lcd_basic.v_period;
+		pconf->lcd_basic.lcd_clk_min = 0;
+		pconf->lcd_basic.lcd_clk_max = 0;
+	} else {
+		pconf->lcd_basic.h_period_min = para[0];
+		pconf->lcd_basic.h_period_max = para[1];
+		pconf->lcd_basic.v_period_min = para[2];
+		pconf->lcd_basic.v_period_max = para[3];
+		pconf->lcd_basic.lcd_clk_min = para[4];
+		pconf->lcd_basic.lcd_clk_max = para[5];
+	}
 
 	ret = of_property_read_u32_array(child, "lcd_timing", &para[0], 6);
 	if (ret) {
@@ -687,10 +854,21 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 	p += LCD_UKEY_CLK_AUTO_GEN;
 	/* dummy pointer */
 	p += LCD_UKEY_PCLK;
-	p += LCD_UKEY_CUST_VAL_4;
-	p += LCD_UKEY_CUST_VAL_5;
-	p += LCD_UKEY_CUST_VAL_6;
-	p += LCD_UKEY_CUST_VAL_7;
+	pconf->lcd_basic.h_period_min = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_H_PERIOD_MIN;
+	pconf->lcd_basic.h_period_max = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_H_PERIOD_MAX;
+	pconf->lcd_basic.v_period_min = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_V_PERIOD_MIN;
+	pconf->lcd_basic.v_period_max = (*p | ((*(p + 1)) << 8));
+	p += LCD_UKEY_V_PERIOD_MAX;
+	pconf->lcd_basic.lcd_clk_min = (*p | ((*(p + 1)) << 8) |
+		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
+	p += LCD_UKEY_PCLK_MIN;
+	pconf->lcd_basic.lcd_clk_max = (*p | ((*(p + 1)) << 8) |
+		((*(p + 2)) << 16) | ((*(p + 3)) << 24));
+	p += LCD_UKEY_PCLK_MAX;
+	/* dummy pointer */
 	p += LCD_UKEY_CUST_VAL_8;
 	p += LCD_UKEY_CUST_VAL_9;
 
@@ -773,10 +951,17 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 
 static void lcd_vmode_init(struct lcd_config_s *pconf)
 {
-	enum vmode_e mode;
-
-	mode = get_logo_vmode();
-	lcd_vmode_vinfo_update(mode & VMODE_MODE_BIT_MASK);
+	char *mode;
+	enum vmode_e vmode;
+
+	mode = get_vout_mode_uboot();
+	LCDPR("%s mode: %s\n", __func__, mode);
+	vmode = lcd_validate_vmode(mode);
+	if (vmode >= VMODE_MAX) {
+		LCDERR("%s: invalid vout_init_mode: %s\n", __func__, mode);
+		vmode = VMODE_LCD;
+	}
+	lcd_vmode_vinfo_update(vmode & VMODE_MODE_BIT_MASK);
 	lcd_tv_config_update(pconf);
 }
 
@@ -788,12 +973,13 @@ static void lcd_config_init(struct lcd_config_s *pconf)
 
 	clk = pconf->lcd_basic.h_period * pconf->lcd_basic.v_period * 60;
 	pconf->lcd_timing.lcd_clk = clk;
-	pconf->lcd_timing.sync_duration_num = 60;
-	pconf->lcd_timing.sync_duration_den = 1;
-
 	pconf->lcd_timing.lcd_clk_dft = pconf->lcd_timing.lcd_clk;
-	lcd_tcon_config(pconf);
+	pconf->lcd_timing.h_period_dft = pconf->lcd_basic.h_period;
+	pconf->lcd_timing.v_period_dft = pconf->lcd_basic.v_period;
+
 	lcd_vmode_init(pconf);
+
+	lcd_tcon_config(pconf);
 	lcd_clk_generate_parameter(pconf);
 	ss_level = pconf->lcd_timing.ss_level;
 	cconf->ss_level = (ss_level >= cconf->ss_level_max) ? 0 : ss_level;
@@ -842,14 +1028,38 @@ static void lcd_set_vinfo(unsigned int sync_duration)
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
 	LCDPR("%s: sync_duration=%d\n", __func__, sync_duration);
-	if (lcd_drv->lcd_info == NULL) {
-		LCDERR("no lcd_info exist\n");
-		return;
-	}
 
 	/* update vinfo */
 	lcd_drv->lcd_info->sync_duration_num = sync_duration;
 	lcd_drv->lcd_info->sync_duration_den = 100;
+
+	/* update interface timing */
+	lcd_tv_config_update(lcd_drv->lcd_config);
+#ifdef CONFIG_AML_VPU
+	request_vpu_clk_vmod(
+		lcd_drv->lcd_config->lcd_timing.lcd_clk, VPU_VENCL);
+#endif
+
+	if (lcd_drv->lcd_config->lcd_basic.lcd_type == LCD_VBYONE)
+		lcd_vbyone_interrupt_enable(0);
+	/* change clk parameter */
+	switch (lcd_drv->lcd_config->lcd_timing.clk_change) {
+	case LCD_CLK_PLL_CHANGE:
+		lcd_clk_generate_parameter(lcd_drv->lcd_config);
+		lcd_clk_set(lcd_drv->lcd_config);
+		break;
+	case LCD_CLK_FRAC_UPDATE:
+		lcd_clk_update(lcd_drv->lcd_config);
+		break;
+	default:
+		break;
+	}
+	lcd_venc_change(lcd_drv->lcd_config);
+	if (lcd_drv->lcd_config->lcd_basic.lcd_type == LCD_VBYONE)
+		lcd_vbyone_wait_stable();
+
+	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,
+		&lcd_drv->lcd_info->mode);
 }
 
 static int lcd_frame_rate_adjust_notifier(struct notifier_block *nb,
@@ -879,6 +1089,7 @@ int lcd_tv_probe(struct device *dev)
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	int ret;
 
+	memset(lcd_output_name, 0, sizeof(lcd_output_name));
 	lcd_drv->version = LCD_DRV_VERSION;
 	lcd_drv->vout_server_init = lcd_tv_vout_server_init;
 	lcd_drv->driver_init_pre = lcd_tv_driver_init_pre;
diff --git a/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.h b/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.h
index 9ccd73e..e5bc48a 100644
--- a/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.h
+++ b/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.h
@@ -20,15 +20,14 @@
 #define __AML_LCD_TV_H__
 #include <linux/amlogic/vout/lcd_vout.h>
 
-#define LCD_DRV_VERSION    "20160623"
-
-extern struct vinfo_s *lcd_tv_get_vinfo(void);
+#define LCD_DRV_VERSION    "20160630"
 
 extern void lcd_tv_config_update(struct lcd_config_s *pconf);
 extern void lcd_tv_driver_init_pre(void);
 extern int lcd_tv_driver_init(void);
 extern void lcd_tv_driver_disable(void);
 
+extern void lcd_vbyone_wait_stable(void);
 extern void lcd_vbyone_interrupt_up(void);
 extern void lcd_vbyone_interrupt_down(void);
 
diff --git a/drivers/amlogic/display/lcd/lcd_vout.c b/drivers/amlogic/display/lcd/lcd_vout.c
index 6a6ba32..d480ce1 100644
--- a/drivers/amlogic/display/lcd/lcd_vout.c
+++ b/drivers/amlogic/display/lcd/lcd_vout.c
@@ -167,6 +167,12 @@ static struct lcd_config_s lcd_config_dft = {
 	.lcd_power = &lcd_power_config,
 };
 
+static struct vinfo_s lcd_vinfo = {
+	.name = "panel",
+	.mode = VMODE_LCD,
+	.viu_color_fmt = TVIN_RGB444,
+};
+
 struct aml_lcd_drv_s *aml_lcd_get_driver(void)
 {
 	return lcd_driver;
@@ -246,7 +252,7 @@ static void lcd_power_ctrl(int status)
 
 static void lcd_module_enable(void)
 {
-	LCDPR("driver version: %s\n", lcd_driver->version);
+	/*LCDPR("driver version: %s\n", lcd_driver->version);*/
 	lcd_driver->driver_init_pre();
 	lcd_driver->power_ctrl(1);
 	lcd_driver->lcd_status = 1;
@@ -258,6 +264,13 @@ static void lcd_module_disable(void)
 	lcd_driver->power_ctrl(0);
 }
 
+static void lcd_module_reset(void)
+{
+	lcd_module_disable();
+	mdelay(200);
+	lcd_module_enable();
+}
+
 /* ****************************************
  * lcd notify
  * **************************************** */
@@ -323,6 +336,9 @@ static void lcd_chip_detect(void)
 	case MESON_CPU_MAJOR_ID_GXTVBB:
 		lcd_driver->chip_type = LCD_CHIP_GXTVBB;
 		break;
+	case MESON_CPU_MAJOR_ID_TXL:
+		lcd_driver->chip_type = LCD_CHIP_TXL;
+		break;
 	default:
 		lcd_driver->chip_type = LCD_CHIP_MAX;
 	}
@@ -444,6 +460,22 @@ static void lcd_config_probe_delayed(struct work_struct *work)
 	}
 }
 
+static void lcd_config_default(void)
+{
+	struct lcd_config_s *pconf;
+
+	pconf = lcd_driver->lcd_config;
+	pconf->lcd_basic.h_active = lcd_vcbus_read(ENCL_VIDEO_HAVON_END)
+			- lcd_vcbus_read(ENCL_VIDEO_HAVON_BEGIN) + 1;
+	pconf->lcd_basic.v_active = lcd_vcbus_read(ENCL_VIDEO_VAVON_ELINE)
+			- lcd_vcbus_read(ENCL_VIDEO_VAVON_BLINE) + 1;
+	if (lcd_vcbus_read(ENCL_VIDEO_EN))
+		lcd_driver->lcd_status = 1;
+	else
+		lcd_driver->lcd_status = 0;
+	LCDPR("status: %d\n", lcd_driver->lcd_status);
+}
+
 static int lcd_config_probe(void)
 {
 	const char *str;
@@ -464,6 +496,15 @@ static int lcd_config_probe(void)
 		return -1;
 	}
 	lcd_driver->lcd_mode = lcd_mode_str_to_mode(str);
+	ret = of_property_read_u32(lcd_driver->dev->of_node,
+		"fr_auto_policy", &val);
+	if (ret) {
+		if (lcd_debug_print_flag)
+			LCDPR("failed to get fr_auto_policy\n");
+		lcd_driver->fr_auto_policy = 0;
+	} else {
+		lcd_driver->fr_auto_policy = (unsigned char)val;
+	}
 	ret = of_property_read_u32(lcd_driver->dev->of_node, "key_valid", &val);
 	if (ret) {
 		if (lcd_debug_print_flag)
@@ -472,19 +513,18 @@ static int lcd_config_probe(void)
 	} else {
 		lcd_driver->lcd_key_valid = (unsigned char)val;
 	}
-	LCDPR("detect mode: %s, key_valid: %d\n", str, val);
+	LCDPR("detect mode: %s, fr_auto_policy: %d, key_valid: %d\n",
+		str, lcd_driver->fr_auto_policy, lcd_driver->lcd_key_valid);
 
-	lcd_driver->lcd_info = NULL;
+	lcd_driver->lcd_info = &lcd_vinfo;
 	lcd_driver->lcd_config = &lcd_config_dft;
+	lcd_driver->lcd_config->pinmux_flag = 0;
 	lcd_driver->vpp_sel = 1;
 	lcd_driver->power_ctrl = lcd_power_ctrl;
-	if (lcd_vcbus_read(ENCL_VIDEO_EN))
-		lcd_driver->lcd_status = 1;
-	else
-		lcd_driver->lcd_status = 0;
-	LCDPR("status: %d\n", lcd_driver->lcd_status);
-
+	lcd_driver->module_reset = lcd_module_reset;
+	lcd_config_default();
 	lcd_init_vout();
+
 	if (lcd_driver->lcd_key_valid) {
 		if (lcd_driver->workqueue) {
 			queue_delayed_work(lcd_driver->workqueue,
diff --git a/drivers/amlogic/display/osd/osd_debug.c b/drivers/amlogic/display/osd/osd_debug.c
index 6f7b588..741ac63 100644
--- a/drivers/amlogic/display/osd/osd_debug.c
+++ b/drivers/amlogic/display/osd/osd_debug.c
@@ -150,6 +150,8 @@ static void osd_debug_dump_register_all(void)
 		osd_log_info("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
 		reg = offset + VIU_OSD1_CTRL_STAT;
 		osd_log_info("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
+		reg = offset + VIU_OSD1_CTRL_STAT2;
+		osd_log_info("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
 		reg = offset + VIU_OSD1_BLK0_CFG_W0;
 		osd_log_info("reg[0x%x]: 0x%08x\n", reg, osd_reg_read(reg));
 		reg = offset + VIU_OSD1_BLK0_CFG_W1;
@@ -163,6 +165,14 @@ static void osd_debug_dump_register_all(void)
 			reg = VIU_OSD2_BLK0_CFG_W4;
 		osd_log_info("reg[0x%x]: 0x%08x\n\n", reg, osd_reg_read(reg));
 	}
+
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+		(get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)) {
+		for (reg = OSD1_AFBCD_ENABLE;
+			reg <= OSD1_AFBCD_PIXEL_VSCOPE; reg++)
+			osd_log_info("reg[0x%x]: 0x%08x\n",
+				reg, osd_reg_read(reg));
+	}
 }
 
 static void osd_debug_dump_register_region(u32 start, u32 end)
diff --git a/drivers/amlogic/display/osd/osd_hw.c b/drivers/amlogic/display/osd/osd_hw.c
index 22a1376..7d5d9ed 100644
--- a/drivers/amlogic/display/osd/osd_hw.c
+++ b/drivers/amlogic/display/osd/osd_hw.c
@@ -76,8 +76,6 @@
 
 #define WAIT_AFBC_READY_COUNT 100
 
-#define OSD_REG_BACKUP_COUNT 15
-
 struct hw_para_s osd_hw;
 static DEFINE_MUTEX(osd_mutex);
 static DEFINE_SPINLOCK(osd_onoff_lock);
@@ -248,13 +246,18 @@ static unsigned int *filter_table[] = {
 	osd_filter_coefs_3point_bspline
 };
 
-static const u16 osd_reg_backup[OSD_REG_BACKUP_COUNT] = {
+/* should be same as osd rdma backup addr */
+const u16 osd_reg_backup[OSD_REG_BACKUP_COUNT] = {
 	0x1a10, 0x1a11, 0x1a12, 0x1a13,
 	0x1a17, 0x1a18, 0x1a19, 0x1a1a, 0x1a1b, 0x1a1c, 0x1a1d, 0x1a1e,
 	0x1a2b, 0x1a2c, 0x1a2d,
 };
 
-static u32 osd_value_backup[OSD_REG_BACKUP_COUNT];
+const u16 osd_afbc_reg_backup[OSD_AFBC_REG_BACKUP_COUNT] = {
+	0x31aa, 0x31a9,
+	0x31a7, 0x31a6, 0x31a5, 0x31a4, 0x31a3, 0x31a2, 0x31a1, 0x31a0
+};
+
 static bool osd_hdr_on;
 static u32 osd_reset_status;
 
@@ -461,6 +464,7 @@ static const struct vframe_operations_s osd_vf_provider = {
 
 void osd_update_3d_mode(void)
 {
+	/* only called by vsync irq or rdma irq */
 	if (osd_hw.mode_3d[OSD1].enable)
 		osd1_update_disp_3d_mode();
 	if (osd_hw.mode_3d[OSD2].enable)
@@ -486,6 +490,7 @@ void osd_update_vsync_hit(void)
 
 static void osd_update_interlace_mode(void)
 {
+	/* only called by vsync irq or rdma irq */
 	unsigned int fb0_cfg_w0, fb1_cfg_w0;
 	unsigned int scan_line_number = 0;
 	unsigned int odd_even;
@@ -531,15 +536,15 @@ static void osd_update_interlace_mode(void)
 	fb1_cfg_w0 &= ~1;
 	fb0_cfg_w0 |= odd_even;
 	fb1_cfg_w0 |= odd_even;
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, fb0_cfg_w0);
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0, fb1_cfg_w0);
+	VSYNCOSD_IRQ_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, fb0_cfg_w0);
+	VSYNCOSD_IRQ_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0, fb1_cfg_w0);
 	spin_unlock_irqrestore(&osd_lock, lock_flags);
 }
 
 void osd_update_scan_mode(void)
 {
+	/* only called by vsync irq or rdma irq */
 	unsigned int output_type = 0;
-
 	output_type = osd_reg_read(VPU_VIU_VENC_MUX_CTRL) & 0x3;
 	osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
 	switch (output_type) {
@@ -575,156 +580,6 @@ static inline void walk_through_update_list(void)
 	}
 }
 
-static void osd1_update_afbcd_color_mode(void)
-{
-	if (osd_hw.osd_afbcd[OSD1].enable) {
-		/* only the RGBA32 mode */
-		VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_MODE,
-				(3 << 24) |
-				(4 << 16) | /* hold_line_num */
-				(0xe4 << 8) |
-				(1 << 6) |
-				(1 << 5) |
-				(0x15 << 0)); /* pixel_packing_fmt */
-		/* TODO: add pixel_packing_fmt setting */
-		VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_CONV_CTRL,
-				(osd_hw.osd_afbcd[OSD1].conv_lbuf_len
-				& 0xffff));
-		/* afbc mode RGBA32 -> RGB24
-		VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_CHROMA_PTR,
-				0x1b, 24, 8);
-		*/
-		VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_CHROMA_PTR,
-				0xe4, 24, 8);
-	}
-}
-
-static void osd1_basic_update_afbcd_disp_geometry(void)
-{
-	u32 data32;
-	/* enable osd 2x scale */
-	if (osd_hw.osd_afbcd[OSD1].enable)
-		VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_SIZE_IN,
-			((osd_hw.osd_afbcd[OSD1].frame_width
-			& 0xffff) << 16) |
-			((osd_hw.osd_afbcd[OSD1].frame_height
-			& 0xffff) << 0));
-
-	if (osd_hw.scale[OSD1].h_enable || osd_hw.scale[OSD1].v_enable) {
-		if (osd_hw.osd_afbcd[OSD1].enable) {
-			data32 = (osd_hw.scaledata[OSD1].x_end & 0x1fff) |
-				(osd_hw.scaledata[OSD1].x_start & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_HSCOPE, data32);
-			data32 = (osd_hw.scaledata[OSD1].y_end & 0x1fff) |
-				(osd_hw.scaledata[OSD1].y_start & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_VSCOPE, data32);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_HDR_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
-		}
-	} else if (osd_hw.free_scale_enable[OSD1]
-		   && (osd_hw.free_scale_data[OSD1].x_end > 0)
-		   && (osd_hw.free_scale_data[OSD1].y_end > 0)
-		   && (!osd_hw.rotate[OSD1].on_off)) {
-		/* enable osd free scale */
-		if (osd_hw.osd_afbcd[OSD1].enable) {
-			data32 =
-				(osd_hw.free_scale_data[OSD1].x_end & 0x1fff) |
-				(osd_hw.free_scale_data[OSD1].x_start & 0x1fff)
-				<< 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_HSCOPE, data32);
-			data32 =
-				(osd_hw.free_scale_data[OSD1].y_end & 0x1fff) |
-				(osd_hw.free_scale_data[OSD1].y_start & 0x1fff)
-				<< 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_VSCOPE, data32);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_HDR_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(
-				OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
-		}
-	} else if (osd_hw.free_scale_enable[OSD1]
-		   && (osd_hw.free_scale_data[OSD1].x_end > 0)
-		   && (osd_hw.free_scale_data[OSD1].y_end > 0)
-		   && (osd_hw.rotate[OSD1].on_off
-			   && osd_hw.rotate[OSD1].angle > 0)) {
-		if (osd_hw.osd_afbcd[OSD1].enable) {
-			data32 = (osd_hw.rotation_pandata[OSD1].x_end
-					& 0x1fff) |
-					(osd_hw.rotation_pandata[OSD1].x_start
-					& 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_HSCOPE, data32);
-			data32 = (osd_hw.rotation_pandata[OSD1].y_end
-				& 0x1fff) |
-				(osd_hw.rotation_pandata[OSD1].y_start
-				& 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_VSCOPE, data32);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_HDR_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(
-				OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
-		}
-	} else if (osd_hw.rotate[OSD1].on_off
-		   && osd_hw.rotate[OSD1].angle > 0) {
-		/* enable osd rotation */
-		if (osd_hw.osd_afbcd[OSD1].enable) {
-			data32 = (osd_hw.rotation_pandata[OSD1].x_end
-					& 0x1fff) |
-					(osd_hw.rotation_pandata[OSD1].x_start
-					& 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_HSCOPE, data32);
-			data32 = (osd_hw.rotation_pandata[OSD1].y_end
-				& 0x1fff) |
-				(osd_hw.rotation_pandata[OSD1].y_start
-				& 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_VSCOPE, data32);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_HDR_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(
-				OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
-		}
-	} else {
-		/* normal mode */
-		if (osd_hw.osd_afbcd[OSD1].enable) {
-			u32 virtual_y_start, virtual_y_end;
-			data32 = (osd_hw.pandata[OSD1].x_end & 0x1fff)
-				| (osd_hw.pandata[OSD1].x_start & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_HSCOPE, data32);
-			virtual_y_start = osd_hw.pandata[OSD1].y_start %
-				osd_hw.osd_afbcd[OSD1].frame_height;
-			virtual_y_end = osd_hw.pandata[OSD1].y_end -
-				osd_hw.pandata[OSD1].y_start + virtual_y_start;
-			data32 = (virtual_y_end & 0x1fff) |
-				 (virtual_y_start & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_VSCOPE, data32);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_HDR_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(
-				OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
-		}
-	}
-}
-
 /*************** for GXL/GXM hardware alpha bug workaround ***************/
 #ifdef CONFIG_AM_VECM
 static void hdr_load_osd_csc(void)
@@ -737,31 +592,44 @@ static void hdr_load_osd_csc(void)
 	/* check osd matrix enable status */
 	if ((hdr_osd_reg.viu_osd1_matrix_ctrl & 0x00000001) != 0x0) {
 		/* osd matrix, VPP_MATRIX_0 */
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_PRE_OFFSET0_1,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_PRE_OFFSET0_1,
 			hdr_osd_reg.viu_osd1_matrix_pre_offset0_1);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_PRE_OFFSET0_1,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_PRE_OFFSET0_1,
 			hdr_osd_reg.viu_osd1_matrix_pre_offset0_1);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_COEF00_01,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_COEF00_01,
 			hdr_osd_reg.viu_osd1_matrix_coef00_01);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_COEF02_10,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_COEF02_10,
 			hdr_osd_reg.viu_osd1_matrix_coef02_10);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_COEF11_12,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_COEF11_12,
 			hdr_osd_reg.viu_osd1_matrix_coef11_12);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_COEF20_21,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_COEF20_21,
 			hdr_osd_reg.viu_osd1_matrix_coef20_21);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_COEF22_30,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_COEF22_30,
 			hdr_osd_reg.viu_osd1_matrix_coef22_30);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_COEF31_32,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_COEF31_32,
 			hdr_osd_reg.viu_osd1_matrix_coef31_32);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_COEF40_41,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_COEF40_41,
 			hdr_osd_reg.viu_osd1_matrix_coef40_41);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_COLMOD_COEF42,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_COLMOD_COEF42,
 			hdr_osd_reg.viu_osd1_matrix_colmod_coef42);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_OFFSET0_1,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_OFFSET0_1,
 			hdr_osd_reg.viu_osd1_matrix_offset0_1);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_OFFSET2,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_OFFSET2,
 			hdr_osd_reg.viu_osd1_matrix_offset2);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_MATRIX_CTRL,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_MATRIX_CTRL,
 			hdr_osd_reg.viu_osd1_matrix_ctrl);
 	}
 
@@ -769,62 +637,69 @@ static void hdr_load_osd_csc(void)
 	if ((hdr_osd_reg.viu_osd1_eotf_ctl & 0x80000000) != 0) {
 		addr_port = VIU_OSD1_EOTF_LUT_ADDR_PORT;
 		data_port = VIU_OSD1_EOTF_LUT_DATA_PORT;
-		VSYNCOSD_WR_MPEG_REG(addr_port, 0);
+		VSYNCOSD_EX_WR_MPEG_REG(addr_port, 0);
 		for (i = 0; i < 16; i++)
-			VSYNCOSD_WR_MPEG_REG(data_port,
+			VSYNCOSD_EX_WR_MPEG_REG(data_port,
 				lut->r_map[i * 2]
 				| (lut->r_map[i * 2 + 1] << 16));
-		VSYNCOSD_WR_MPEG_REG(data_port,
+		VSYNCOSD_EX_WR_MPEG_REG(data_port,
 			lut->r_map[33 - 1]
 			| (lut->g_map[0] << 16));
 		for (i = 0; i < 16; i++)
-			VSYNCOSD_WR_MPEG_REG(data_port,
+			VSYNCOSD_EX_WR_MPEG_REG(data_port,
 				lut->g_map[i * 2 + 1]
 				| (lut->b_map[i * 2 + 2] << 16));
 		for (i = 0; i < 16; i++)
-			VSYNCOSD_WR_MPEG_REG(data_port,
+			VSYNCOSD_EX_WR_MPEG_REG(data_port,
 				lut->b_map[i * 2]
 				| (lut->b_map[i * 2 + 1] << 16));
-		VSYNCOSD_WR_MPEG_REG(data_port, lut->b_map[33 - 1]);
+		VSYNCOSD_EX_WR_MPEG_REG(data_port, lut->b_map[33 - 1]);
 
 		/* load eotf matrix */
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_EOTF_COEF00_01,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_EOTF_COEF00_01,
 			hdr_osd_reg.viu_osd1_eotf_coef00_01);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_EOTF_COEF02_10,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_EOTF_COEF02_10,
 			hdr_osd_reg.viu_osd1_eotf_coef02_10);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_EOTF_COEF11_12,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_EOTF_COEF11_12,
 			hdr_osd_reg.viu_osd1_eotf_coef11_12);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_EOTF_COEF20_21,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_EOTF_COEF20_21,
 			hdr_osd_reg.viu_osd1_eotf_coef20_21);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_EOTF_COEF22_RS,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_EOTF_COEF22_RS,
 			hdr_osd_reg.viu_osd1_eotf_coef22_rs);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_EOTF_CTL,
+		VSYNCOSD_EX_WR_MPEG_REG(
+			VIU_OSD1_EOTF_CTL,
 			hdr_osd_reg.viu_osd1_eotf_ctl);
 	}
 	/* restore oetf lut */
 	if ((hdr_osd_reg.viu_osd1_oetf_ctl & 0xe0000000) != 0) {
 		addr_port = VIU_OSD1_OETF_LUT_ADDR_PORT;
 		data_port = VIU_OSD1_OETF_LUT_DATA_PORT;
-		VSYNCOSD_WR_MPEG_REG(addr_port, 0);
+		VSYNCOSD_EX_WR_MPEG_REG(addr_port, 0);
 		for (i = 0; i < 20; i++)
-			VSYNCOSD_WR_MPEG_REG(data_port,
+			VSYNCOSD_EX_WR_MPEG_REG(data_port,
 				lut->or_map[i * 2]
 				| (lut->or_map[i * 2 + 1] << 16));
-		VSYNCOSD_WR_MPEG_REG(data_port,
+		VSYNCOSD_EX_WR_MPEG_REG(data_port,
 			lut->or_map[41 - 1]
 			| (lut->og_map[0] << 16));
 		for (i = 0; i < 20; i++)
-			VSYNCOSD_WR_MPEG_REG(data_port,
+			VSYNCOSD_EX_WR_MPEG_REG(data_port,
 				lut->og_map[i * 2 + 1]
 				| (lut->og_map[i * 2 + 2] << 16));
 		for (i = 0; i < 20; i++)
-			VSYNCOSD_WR_MPEG_REG(data_port,
+			VSYNCOSD_EX_WR_MPEG_REG(data_port,
 				lut->ob_map[i * 2]
 				| (lut->ob_map[i * 2 + 1] << 16));
-		VSYNCOSD_WR_MPEG_REG(data_port,
+		VSYNCOSD_EX_WR_MPEG_REG(data_port,
 			lut->ob_map[41 - 1]);
 
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_OETF_CTL,
+		VSYNCOSD_EX_WR_MPEG_REG
+			(VIU_OSD1_OETF_CTL,
 			hdr_osd_reg.viu_osd1_oetf_ctl);
 	}
 }
@@ -832,8 +707,13 @@ static void hdr_load_osd_csc(void)
 
 void osd_hw_reset(void)
 {
-	u32 i;
+	/* only called by vsync irq or rdma irq */
 	u32 reset_bit = 0;
+#ifndef CONFIG_FB_OSD_VSYNC_RDMA
+	u32 i;
+	u32 osd_value_backup[OSD_REG_BACKUP_COUNT];
+	u32 osd_afbc_value_backup[OSD_AFBC_REG_BACKUP_COUNT];
+#endif
 
 	/* check hw version */
 	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXTVBB)
@@ -843,7 +723,8 @@ void osd_hw_reset(void)
 		(get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)))
 		reset_bit = 1<<31;
 #ifdef CONFIG_AM_VECM
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		&& (get_cpu_type() <= MESON_CPU_MAJOR_ID_TXL)) {
 		if (((hdr_osd_reg.viu_osd1_matrix_ctrl & 0x00000001) != 0x0) ||
 			((hdr_osd_reg.viu_osd1_eotf_ctl & 0x80000000) != 0) ||
 			((hdr_osd_reg.viu_osd1_oetf_ctl & 0xe0000000) != 0)) {
@@ -860,37 +741,65 @@ void osd_hw_reset(void)
 	if (reset_bit == 0)
 		return;
 
+#ifndef CONFIG_FB_OSD_VSYNC_RDMA
+	spin_lock_irqsave(&osd_lock, lock_flags);
 	if (reset_bit & 1) {
-		spin_lock_irqsave(&osd_lock, lock_flags);
 		/* backup osd regs */
 		for (i = 0; i < OSD_REG_BACKUP_COUNT; i++)
 			osd_value_backup[i] =
-				VSYNCOSD_RD_MPEG_REG(osd_reg_backup[i]);
+				VSYNCOSD_RD_MPEG_REG(
+				osd_reg_backup[i]);
 	}
 
-	VSYNCOSD_SET_MPEG_REG_MASK(VIU_SW_RESET, reset_bit);
-	VSYNCOSD_CLR_MPEG_REG_MASK(VIU_SW_RESET, reset_bit);
+	if (reset_bit & 0x80000000) {
+		/* backup osd afbc regs */
+		for (i = 0; i < OSD_AFBC_REG_BACKUP_COUNT; i++)
+			osd_afbc_value_backup[i] =
+				VSYNCOSD_RD_MPEG_REG(
+				osd_afbc_reg_backup[i]);
+	}
 
+	VSYNCOSD_IRQ_SET_MPEG_REG_MASK(
+		VIU_SW_RESET, reset_bit);
+	VSYNCOSD_IRQ_CLR_MPEG_REG_MASK(
+		VIU_SW_RESET, reset_bit);
 
 	if (reset_bit & 1) {
 		/* restore osd regs */
 		for (i = 0; i < OSD_REG_BACKUP_COUNT; i++)
-			VSYNCOSD_WR_MPEG_REG(osd_reg_backup[i],
+			VSYNCOSD_IRQ_WR_MPEG_REG
+				(osd_reg_backup[i],
 				osd_value_backup[i]);
-		spin_unlock_irqrestore(&osd_lock, lock_flags);
 	}
 
 	if (reset_bit & 0x80000000) {
-		osd1_update_afbcd_color_mode();
-		osd1_basic_update_afbcd_disp_geometry();
-		VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_ENABLE, 1, 8, 1);
+		/* restore osd regs */
+		for (i = 0; i < OSD_AFBC_REG_BACKUP_COUNT; i++) {
+			if (osd_afbc_reg_backup[i]
+				== OSD1_AFBCD_ENABLE)
+				VSYNCOSD_IRQ_WR_MPEG_REG
+					(osd_afbc_reg_backup[i],
+					osd_afbc_value_backup[i] | 0x100);
+			else
+				VSYNCOSD_IRQ_WR_MPEG_REG
+					(osd_afbc_reg_backup[i],
+					osd_afbc_value_backup[i]);
+		}
 	}
-
+	spin_unlock_irqrestore(&osd_lock, lock_flags);
 #ifdef CONFIG_AM_VECM
 	/* write new osd hdr regs */
 	if (reset_bit & 1)
 		hdr_load_osd_csc();
 #endif
+#else
+	/* wrtie into rdma local buffer and flush into rdma table at last */
+	if (reset_bit & 1)
+		hdr_load_osd_csc();
+	spin_lock_irqsave(&osd_lock, lock_flags);
+	osd_rdma_reset_and_flush(reset_bit);
+	spin_unlock_irqrestore(&osd_lock, lock_flags);
+#endif
 	return;
 }
 
@@ -915,8 +824,7 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 	osd_update_3d_mode();
 	osd_update_vsync_hit();
 	osd_hw_reset();
-#endif
-#ifdef CONFIG_FB_OSD_VSYNC_RDMA
+#else
 	osd_rdma_interrupt_done_clear();
 #endif
 #ifndef FIQ_VSYNC
@@ -1469,8 +1377,8 @@ static void osd_set_free_scale_enable_mode1(u32 index, u32 enable)
 				osd_hw.free_scale_data[index].y_end -
 				osd_hw.free_scale_data[index].y_start + 1;
 		}
-		spin_lock_irqsave(&osd_lock, lock_flags);
 		ret = osd_set_scan_mode(index);
+		spin_lock_irqsave(&osd_lock, lock_flags);
 		if (ret)
 			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
 		osd_hw.reg[index][OSD_FREESCALE_COEF].update_func();
@@ -1479,8 +1387,8 @@ static void osd_set_free_scale_enable_mode1(u32 index, u32 enable)
 		osd_hw.reg[index][OSD_ENABLE].update_func();
 		spin_unlock_irqrestore(&osd_lock, lock_flags);
 	} else {
-		spin_lock_irqsave(&osd_lock, lock_flags);
 		ret = osd_set_scan_mode(index);
+		spin_lock_irqsave(&osd_lock, lock_flags);
 		if (ret)
 			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
 		osd_hw.reg[index][DISP_GEOMETRY].update_func();
@@ -1651,12 +1559,13 @@ void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 	osd_hw.cursor_dispdata[index].y_end = y1;
 #endif
 	if (osd_hw.free_dst_data[index].y_end >= 2159) {
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXM)
+		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
 			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00202000);
-		else if (!is_meson_gxtvbb_cpu())
-			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00808000);
-		else
+		else if (get_cpu_type() ==
+			MESON_CPU_MAJOR_ID_GXTVBB)
 			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0xff);
+		else
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00808000);
 	}
 	osd_update_window_axis = true;
 	mutex_unlock(&osd_mutex);
@@ -2056,28 +1965,12 @@ void osd_switch_free_scale(
 		if (i > 0)
 			osd_log_info("osd[%d]: wait %d vsync first buffer ready.\n",
 				next_index, i);
-		spin_lock_irqsave(&osd_lock, lock_flags);
-		if (next_index == OSD1
-			&& osd_hw.osd_afbcd[next_index].enable
-			&& next_enable) {
-			osd_reg_set_mask(VIU_SW_RESET, 1 << 31);
-			osd_reg_clr_mask(VIU_SW_RESET, 1 << 31);
-			osd_afbc_dec_enable = false;
-			osd_hw.reg[next_index][OSD_GBL_ALPHA].update_func();
-		}
 		h_enable = (pre_scale & 0xffff0000 ? 1 : 0);
 		v_enable = (pre_scale & 0xffff ? 1 : 0);
 		osd_hw.free_scale[pre_index].h_enable = h_enable;
 		osd_hw.free_scale[pre_index].v_enable = v_enable;
 		osd_hw.free_scale_enable[pre_index] = pre_scale;
 		osd_hw.enable[pre_index] = pre_enable;
-		h_enable = (next_scale & 0xffff0000 ? 1 : 0);
-		v_enable = (next_scale & 0xffff ? 1 : 0);
-		osd_hw.free_scale[next_index].h_enable = h_enable;
-		osd_hw.free_scale[next_index].v_enable = v_enable;
-		osd_hw.free_scale_enable[next_index] = next_scale;
-		osd_hw.enable[next_index] = next_enable;
-
 		if ((osd_hw.free_scale_data[pre_index].x_end > 0)
 			&& h_enable && pre_scale) {
 			osd_hw.free_scale_width[pre_index] =
@@ -2090,14 +1983,13 @@ void osd_switch_free_scale(
 			osd_hw.free_scale_data[pre_index].y_end -
 				osd_hw.free_scale_data[pre_index].y_start + 1;
 		}
-		osd_set_scan_mode(pre_index);
-		osd_hw.reg[pre_index][OSD_COLOR_MODE].update_func();
-		if (pre_scale)
-			osd_hw.reg[pre_index][OSD_FREESCALE_COEF].update_func();
-		osd_hw.reg[pre_index][DISP_GEOMETRY].update_func();
-		osd_hw.reg[pre_index][DISP_FREESCALE_ENABLE].update_func();
-		osd_hw.reg[pre_index][OSD_ENABLE].update_func();
 
+		h_enable = (next_scale & 0xffff0000 ? 1 : 0);
+		v_enable = (next_scale & 0xffff ? 1 : 0);
+		osd_hw.free_scale[next_index].h_enable = h_enable;
+		osd_hw.free_scale[next_index].v_enable = v_enable;
+		osd_hw.free_scale_enable[next_index] = next_scale;
+		osd_hw.enable[next_index] = next_enable;
 		if ((osd_hw.free_scale_data[next_index].x_end > 0)
 			&& h_enable && next_scale) {
 			osd_hw.free_scale_width[next_index] =
@@ -2111,6 +2003,23 @@ void osd_switch_free_scale(
 				osd_hw.free_scale_data[next_index].y_start + 1;
 		}
 		osd_set_scan_mode(next_index);
+		spin_lock_irqsave(&osd_lock, lock_flags);
+		if (next_index == OSD1
+			&& osd_hw.osd_afbcd[next_index].enable
+			&& next_enable) {
+			osd_reg_set_mask(VIU_SW_RESET, 1 << 31);
+			osd_reg_clr_mask(VIU_SW_RESET, 1 << 31);
+			osd_afbc_dec_enable = false;
+			osd_hw.reg[next_index][OSD_GBL_ALPHA].update_func();
+		}
+
+		osd_hw.reg[pre_index][OSD_COLOR_MODE].update_func();
+		if (pre_scale)
+			osd_hw.reg[pre_index][OSD_FREESCALE_COEF].update_func();
+		osd_hw.reg[pre_index][DISP_GEOMETRY].update_func();
+		osd_hw.reg[pre_index][DISP_FREESCALE_ENABLE].update_func();
+		osd_hw.reg[pre_index][OSD_ENABLE].update_func();
+
 		osd_hw.reg[next_index][OSD_COLOR_MODE].update_func();
 		if (next_scale)
 			osd_hw.reg[next_index]
@@ -2237,11 +2146,13 @@ static  void  osd1_update_disp_scale_enable(void)
 		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3 << 12);
 	if (osd_hw.scan_mode != SCAN_MODE_INTERLACE) {
 		if (osd_hw.scale[OSD1].v_enable)
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0,
-					1 << 14);
+			VSYNCOSD_SET_MPEG_REG_MASK(
+				VIU_OSD1_BLK0_CFG_W0,
+				1 << 14);
 		else
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0,
-					1 << 14);
+			VSYNCOSD_CLR_MPEG_REG_MASK(
+				VIU_OSD1_BLK0_CFG_W0,
+				1 << 14);
 	}
 }
 
@@ -2639,7 +2550,7 @@ static void osd1_update_color_mode(void)
 		data32 |= osd_hw.color_info[OSD1]->hw_colormat << 2;
 		if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXTVBB) {
 			if (osd_hw.color_info[OSD1]->color_index <
-					COLOR_INDEX_YUV_422)
+				COLOR_INDEX_YUV_422)
 				data32 |= 1 << 7; /* yuv enable */
 		}
 		/* osd_blk_mode */
@@ -2698,7 +2609,7 @@ static void osd2_update_color_mode(void)
 		data32 |= osd_hw.color_info[OSD2]->hw_colormat << 2;
 		if (get_cpu_type() != MESON_CPU_MAJOR_ID_GXTVBB) {
 			if (osd_hw.color_info[OSD2]->color_index <
-					COLOR_INDEX_YUV_422)
+				COLOR_INDEX_YUV_422)
 				data32 |= 1 << 7; /* yuv enable */
 		}
 		/* osd_blk_mode */
@@ -2748,11 +2659,11 @@ static void osd1_update_enable(void)
 						VPP_POSTBLEND_EN);
 				VSYNCOSD_SET_MPEG_REG_MASK(
 						VIU_OSD1_CTRL_STAT,
-						1 << 21);
+						1 << 0);
 			} else {
 				VSYNCOSD_CLR_MPEG_REG_MASK(
 						VIU_OSD1_CTRL_STAT,
-						1 << 21);
+						1 << 0);
 				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
 					VPP_OSD1_POSTBLEND);
 			}
@@ -2773,8 +2684,9 @@ static void osd1_update_enable(void)
 				0x90, 8, 8);
 		} else {
 			if (osd_afbc_dec_enable) {
-				VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_ENABLE,
-						0, 8, 1);
+				VSYNCOSD_WR_MPEG_REG_BITS(
+					OSD1_AFBCD_ENABLE,
+					0, 8, 1);
 				osd_afbc_dec_enable = false;
 			}
 			VSYNCOSD_WR_MPEG_REG_BITS(
@@ -2788,9 +2700,9 @@ static void osd1_update_enable(void)
 		if (osd_hw.enable[OSD1] == ENABLE) {
 			VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
 				VPP_OSD1_POSTBLEND | VPP_POSTBLEND_EN);
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 21);
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 0);
 		} else {
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 21);
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 0);
 			VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
 				VPP_OSD1_POSTBLEND);
 		}
@@ -2835,10 +2747,10 @@ static void osd2_update_enable(void)
 				VPP_OSD2_POSTBLEND
 				| VPP_POSTBLEND_EN);
 			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_CTRL_STAT,
-				1 << 21);
+				1 << 0);
 		} else {
 			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_CTRL_STAT,
-				1 << 21);
+				1 << 0);
 			VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
 				VPP_OSD2_POSTBLEND);
 		}
@@ -2847,26 +2759,26 @@ static void osd2_update_enable(void)
 		if (osd_hw.enable[OSD2] == ENABLE) {
 			if (osd_hw.free_scale_enable[OSD2]) {
 				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD2_POSTBLEND);
+					VPP_OSD2_POSTBLEND);
 				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD2_PREBLEND
-						| VPP_VD1_POSTBLEND);
+					VPP_OSD2_PREBLEND
+					| VPP_VD1_POSTBLEND);
 			} else {
 				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD2_PREBLEND);
+					VPP_OSD2_PREBLEND);
 				if (!video_enable)
 					VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-							VPP_VD1_POSTBLEND);
+						VPP_VD1_POSTBLEND);
 				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD2_POSTBLEND);
+					VPP_OSD2_POSTBLEND);
 			}
 		} else {
 			if (osd_hw.free_scale_enable[OSD2])
 				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD2_PREBLEND);
+					VPP_OSD2_PREBLEND);
 			else
 				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD2_POSTBLEND);
+					VPP_OSD2_POSTBLEND);
 		}
 	}
 	remove_from_update_list(OSD2, OSD_ENABLE);
@@ -3585,8 +3497,8 @@ static void osd1_basic_update_disp_geometry(void)
 	}
 
 	if (osd_hw.osd_afbcd[OSD1].enable &&
-			!osd_afbc_dec_enable &&
-			osd_hw.osd_afbcd[OSD1].phy_addr != 0) {
+		!osd_afbc_dec_enable &&
+		osd_hw.osd_afbcd[OSD1].phy_addr != 0) {
 		VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_ENABLE, 1, 8, 1);
 		osd_afbc_dec_enable = true;
 	}
@@ -3671,32 +3583,34 @@ static void osd2_update_disp_geometry(void)
 	}
 	remove_from_update_list(OSD2, DISP_GEOMETRY);
 }
-static  void  osd1_update_disp_3d_mode(void)
+static void osd1_update_disp_3d_mode(void)
 {
 	/*step 1 . set pan data */
+	/* only called by vsync irq or rdma irq */
 	u32  data32;
 	if (osd_hw.mode_3d[OSD1].left_right == OSD_LEFT) {
 		data32 = (osd_hw.mode_3d[OSD1].l_start & 0x1fff)
 			| (osd_hw.mode_3d[OSD1].l_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+		VSYNCOSD_IRQ_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
 	} else {
 		data32 = (osd_hw.mode_3d[OSD1].r_start & 0x1fff)
 			| (osd_hw.mode_3d[OSD1].r_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+		VSYNCOSD_IRQ_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
 	}
 	osd_hw.mode_3d[OSD1].left_right ^= 1;
 }
-static  void  osd2_update_disp_3d_mode(void)
+static void osd2_update_disp_3d_mode(void)
 {
+	/* only called by vsync irq or rdma irq */
 	u32  data32;
 	if (osd_hw.mode_3d[OSD2].left_right == OSD_LEFT) {
 		data32 = (osd_hw.mode_3d[OSD2].l_start & 0x1fff)
 			| (osd_hw.mode_3d[OSD2].l_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		VSYNCOSD_IRQ_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
 	} else {
 		data32 = (osd_hw.mode_3d[OSD2].r_start & 0x1fff)
 			| (osd_hw.mode_3d[OSD2].r_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		VSYNCOSD_IRQ_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
 	}
 	osd_hw.mode_3d[OSD2].left_right ^= 1;
 }
@@ -3792,7 +3706,6 @@ void osd_init_hw(u32 logo_loaded)
 		} else
 			data32 = 0x1 << 0;
 		data32 |= OSD_GLOBAL_ALPHA_DEF << 12;
-		data32 |= (1 << 21);
 		osd_reg_write(VIU_OSD1_CTRL_STAT , data32);
 		osd_reg_write(VIU_OSD2_CTRL_STAT , data32);
 	}
@@ -3837,8 +3750,11 @@ void osd_init_hw(u32 logo_loaded)
 		osd_hw.free_scale_data[OSD2].y_end = 0;
 		osd_hw.free_scale_mode[OSD1] = 0;
 		osd_hw.free_scale_mode[OSD2] = 1;
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXM)
+		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
 			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00202000);
+		else if (get_cpu_type() ==
+			MESON_CPU_MAJOR_ID_GXTVBB)
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0xff);
 		else
 			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00808000);
 	} else {
diff --git a/drivers/amlogic/display/osd/osd_hw.h b/drivers/amlogic/display/osd/osd_hw.h
index a11ab58..a46edf4 100644
--- a/drivers/amlogic/display/osd/osd_hw.h
+++ b/drivers/amlogic/display/osd/osd_hw.h
@@ -24,9 +24,14 @@
 #define OSD_RELATIVE_BITS 0x33370
 #ifdef CONFIG_FB_OSD_VSYNC_RDMA
 #include "osd_rdma.h"
-
 #endif
 
+#define OSD_REG_BACKUP_COUNT 15
+#define OSD_AFBC_REG_BACKUP_COUNT 10
+
+extern const u16 osd_reg_backup[OSD_REG_BACKUP_COUNT];
+extern const u16 osd_afbc_reg_backup[OSD_AFBC_REG_BACKUP_COUNT];
+
 #ifdef CONFIG_HIBERNATION
 extern void osd_freeze_hw(void);
 extern void osd_thaw_hw(void);
diff --git a/drivers/amlogic/display/osd/osd_io.h b/drivers/amlogic/display/osd/osd_io.h
index 6815e95..280230e 100644
--- a/drivers/amlogic/display/osd/osd_io.h
+++ b/drivers/amlogic/display/osd/osd_io.h
@@ -89,6 +89,13 @@ int VSYNCOSD_WR_MPEG_REG(u32 reg, u32 val);
 int VSYNCOSD_WR_MPEG_REG_BITS(u32 reg, u32 val, u32 start, u32 len);
 int VSYNCOSD_SET_MPEG_REG_MASK(u32 reg, u32 mask);
 int VSYNCOSD_CLR_MPEG_REG_MASK(u32 reg, u32 mask);
+
+int VSYNCOSD_IRQ_WR_MPEG_REG(u32 reg, u32 val);
+int VSYNCOSD_IRQ_WR_MPEG_REG_BITS(u32 reg, u32 val, u32 start, u32 len);
+int VSYNCOSD_IRQ_SET_MPEG_REG_MASK(u32 reg, u32 mask);
+int VSYNCOSD_IRQ_CLR_MPEG_REG_MASK(u32 reg, u32 mask);
+/* write to the rdma local buffer and flush into reg buffer at end */
+int VSYNCOSD_EX_WR_MPEG_REG(u32 reg, u32 val);
 #else
 #define VSYNCOSD_RD_MPEG_REG(reg) osd_reg_read(reg)
 #define VSYNCOSD_WR_MPEG_REG(reg, val) osd_reg_write(reg, val)
@@ -96,6 +103,13 @@ int VSYNCOSD_CLR_MPEG_REG_MASK(u32 reg, u32 mask);
 	osd_reg_set_bits(reg, val, start, len)
 #define VSYNCOSD_SET_MPEG_REG_MASK(reg, mask) osd_reg_set_mask(reg, mask)
 #define VSYNCOSD_CLR_MPEG_REG_MASK(reg, mask) osd_reg_clr_mask(reg, mask)
+
+#define VSYNCOSD_IRQ_WR_MPEG_REG(reg, val) osd_reg_write(reg, val)
+#define VSYNCOSD_IRQ_WR_MPEG_REG_BITS(reg, val, start, len) \
+	osd_reg_set_bits(reg, val, start, len)
+#define VSYNCOSD_IRQ_SET_MPEG_REG_MASK(reg, mask) osd_reg_set_mask(reg, mask)
+#define VSYNCOSD_IRQ_CLR_MPEG_REG_MASK(reg, mask) osd_reg_clr_mask(reg, mask)
+#define VSYNCOSD_EX_WR_MPEG_REG(reg, val) osd_reg_write(reg, val)
 #endif
 
 #endif
diff --git a/drivers/amlogic/display/osd/osd_rdma.c b/drivers/amlogic/display/osd/osd_rdma.c
index 1fe244f..520f6a8 100644
--- a/drivers/amlogic/display/osd/osd_rdma.c
+++ b/drivers/amlogic/display/osd/osd_rdma.c
@@ -39,9 +39,13 @@
 #include "osd_io.h"
 #include "osd_reg.h"
 #include "osd_rdma.h"
+#include "osd_hw.h"
+
+#define RDMA_TABLE_INTERNAL_COUNT 512
 
 static DEFINE_SPINLOCK(rdma_lock);
 static struct rdma_table_item *rdma_table;
+static struct rdma_table_item *rdma_table_internal;
 static struct device *osd_rdma_dev;
 static struct page *table_pages;
 static void *osd_rdma_table_virt;
@@ -50,11 +54,17 @@ static u32 table_paddr;
 static void *table_vaddr;
 static u32 rdma_enable;
 static u32 item_count;
+static u32 item_count_internal;
 static u32 rdma_debug;
 static bool osd_rdma_init_flag;
 static int ctrl_ahb_rd_burst_size = 3;
 static int ctrl_ahb_wr_burst_size = 3;
-#define OSD_RDMA_UPDATE_RETRY_COUNT 50
+#define OSD_RDMA_UPDATE_RETRY_COUNT 100
+static unsigned int debug_rdma_status;
+static unsigned int rdma_irq_count;
+static unsigned int rdma_lost_count;
+static unsigned int dump_reg_trigger;
+static unsigned int second_rdma_irq;
 
 static int osd_rdma_init(void);
 
@@ -108,6 +118,9 @@ EXPORT_SYMBOL(osd_rdma_update_config);
 static inline void reset_rdma_table(void)
 {
 	unsigned long flags;
+	u32 old_count;
+	u32 end_addr;
+	int i, j = 0;
 	struct rdma_table_item reset_item[2] = {
 		{
 			.addr = OSD_RDMA_FLAG_REG,
@@ -115,105 +128,192 @@ static inline void reset_rdma_table(void)
 		},
 		{
 			.addr = OSD_RDMA_FLAG_REG,
-			.val = OSD_RDMA_STATUS_MARK_COMPLETE,
+			.val = OSD_RDMA_STATUS_MARK_TBL_DONE,
 		}
 	};
 
 	spin_lock_irqsave(&rdma_lock, flags);
-	if (!OSD_RDMA_STAUS_IS_DIRTY) {
-		/*we reset rdma table only if table is clean.
-		if both two process want to reset table.and racing
-		here,double clean table is uncorrect.
-		1 clean table racing--------
-		2 the first one get spin lock ,do clean op
-		3 the first exit spin lock and adding one item
-		4 the second one get spin lock, clean table(!!wrong)*/
-		OSD_RDMA_STAUS_CLEAR_DONE;
+	if (!OSD_RDMA_STATUS_IS_REJECT) {
+		end_addr = osd_reg_read(END_ADDR) + 1;
+		if (end_addr > table_paddr)
+			old_count = (end_addr - table_paddr) >> 3;
+		else
+			old_count = 0;
 		osd_reg_write(END_ADDR, table_paddr - 1);
-		osd_rdma_mem_cpy(rdma_table, &reset_item[0], 16);
-		/*osd_rdma_mem_cpy(rdma_table, &reset_item[0], 16);*/
-		item_count = 1;
+		if (old_count < item_count) {
+			for (i = 0; i < item_count - old_count; i++) {
+				if (rdma_table[old_count + i].addr
+					== OSD_RDMA_FLAG_REG)
+					continue;
+				osd_rdma_mem_cpy(
+					&rdma_table[1 + j],
+					&rdma_table[old_count + i], 8);
+				j++;
+			}
+			item_count = j + 2;
+		} else {
+			item_count = 2;
+		}
+		osd_rdma_mem_cpy(rdma_table, &reset_item[0], 8);
+		osd_rdma_mem_cpy(&rdma_table[item_count - 1],
+			&reset_item[1], 8);
+		osd_reg_write(END_ADDR,
+			(table_paddr + item_count * 8 - 1));
 	}
 	spin_unlock_irqrestore(&rdma_lock, flags);
 }
 
-static int update_table_item(u32 addr, u32 val)
+static int update_table_item(u32 addr, u32 val, u8 irq_mode)
 {
 	unsigned long flags;
 	int retry_count = OSD_RDMA_UPDATE_RETRY_COUNT;
 	struct rdma_table_item request_item;
+	int reject1 = 0, reject2 = 0, ret = 0;
+	u32 paddr;
 
 	if (item_count > 500) {
-		/*rdma table is full*/
+		/* rdma table is full */
+		pr_info("update_table_item overflow!\n");
 		return -1;
 	}
-	trace_printk("%02dth, ctrl: 0x%02x, status: 0x%04x, auto:0x%08x, flag:0x%08x\n",
-			item_count, osd_reg_read(RDMA_CTRL),
-			osd_reg_read(RDMA_STATUS),
-			osd_reg_read(RDMA_ACCESS_AUTO),
-			osd_reg_read(OSD_RDMA_FLAG_REG));
+	/* pr_debug("%02dth, ctrl: 0x%x, status: 0x%x, auto:0x%x, flag:0x%x\n",
+		item_count, osd_reg_read(RDMA_CTRL),
+		osd_reg_read(RDMA_STATUS),
+		osd_reg_read(RDMA_ACCESS_AUTO),
+		osd_reg_read(OSD_RDMA_FLAG_REG)); */
 retry:
 	if (0 == (retry_count--)) {
-		trace_printk("OSD RDMA stuck .....%d,0x%x\n", retry_count,
-			osd_reg_read(RDMA_STATUS));
-		reset_rdma_table();
-		OSD_RDMA_STAUS_MARK_DIRTY;
+		pr_debug("OSD RDMA stuck: 0x%x = 0x%x, status: 0x%x\n",
+			addr, val, osd_reg_read(RDMA_STATUS));
+		pr_debug("::retry count: %d-%d, count: %d, flag: 0x%x\n",
+			reject1, reject2, item_count,
+			osd_reg_read(OSD_RDMA_FLAG_REG));
 		spin_lock_irqsave(&rdma_lock, flags);
-		item_count++;
 		request_item.addr = OSD_RDMA_FLAG_REG;
-		request_item.val = OSD_RDMA_STATUS_MARK_COMPLETE;
+		request_item.val = OSD_RDMA_STATUS_MARK_TBL_DONE;
 		osd_rdma_mem_cpy(
 			&rdma_table[item_count],
 			&request_item, 8);
-		osd_reg_write(END_ADDR, (table_paddr + item_count * 8 + 7));
 		request_item.addr = addr;
 		request_item.val = val;
 		osd_rdma_mem_cpy(
-			&rdma_table[item_count-1],
+			&rdma_table[item_count - 1],
 			&request_item, 8);
+		item_count++;
 		spin_unlock_irqrestore(&rdma_lock, flags);
 		return -1;
 	}
 
-	if (!OSD_RDMA_STAUS_IS_DIRTY) {
-		/*since last HW op,no new wirte request.
-		rdma HW op will clear DIRTY flag.*/
-		/*reset all pointer. set table start margin.*/
-		reset_rdma_table();
+	if ((OSD_RDMA_STATUS_IS_REJECT) && (irq_mode)) {
+		/* should not be here. Using the wrong write function
+			or rdma isr is block */
+		pr_info("update reg but rdma running, mode: %d\n",
+			irq_mode);
+		return -2;
+	}
+
+	if ((OSD_RDMA_STATUS_IS_REJECT) && (!irq_mode)) {
+		/* should not be here. Using the wrong write function
+			or rdma isr is block */
+		reject1++;
+		pr_debug("update reg but rdma running, mode: %d,",
+			irq_mode);
+		pr_debug("retry count:%d (%d), flag: 0x%x, status: 0x%x\n",
+			retry_count, reject1,
+			osd_reg_read(OSD_RDMA_FLAG_REG),
+			osd_reg_read(RDMA_STATUS));
+		goto retry;
 	}
+
 	/*atom_lock_start:*/
-	/*set write op aotmic lock flag.*/
-	OSD_RDMA_STAUS_MARK_DIRTY;
 	spin_lock_irqsave(&rdma_lock, flags);
-	item_count++;
 	request_item.addr = OSD_RDMA_FLAG_REG;
-	request_item.val = OSD_RDMA_STATUS_MARK_COMPLETE;
+	request_item.val = OSD_RDMA_STATUS_MARK_TBL_DONE;
 	osd_rdma_mem_cpy(&rdma_table[item_count], &request_item, 8);
-
-	if (OSD_RDMA_STATUS_IS_REJECT) {
-		trace_printk("rdma done detect +++++%d,0x%x\n",
-				retry_count, osd_reg_read(RDMA_STATUS));
+	request_item.addr = addr;
+	request_item.val = val;
+	osd_rdma_mem_cpy(&rdma_table[item_count - 1], &request_item, 8);
+	item_count++;
+	paddr = table_paddr + item_count * 8 - 1;
+	if (!OSD_RDMA_STATUS_IS_REJECT) {
+		osd_reg_write(END_ADDR, paddr);
+	} else if (!irq_mode) {
+		reject2++;
+		pr_debug("need update ---, but rdma running,");
+		pr_debug("retry count:%d (%d), flag: 0x%x, status: 0x%x\n",
+			retry_count, reject2,
+			osd_reg_read(OSD_RDMA_FLAG_REG),
+			osd_reg_read(RDMA_STATUS));
 		item_count--;
 		spin_unlock_irqrestore(&rdma_lock, flags);
 		goto retry;
-	} else {
-		osd_reg_write(END_ADDR, (table_paddr + item_count * 8 + 7));
+	} else
+		ret = -3;
+	/*atom_lock_end:*/
+	spin_unlock_irqrestore(&rdma_lock, flags);
+	return ret;
+}
+
+static inline int update_table_item_internal(u32 addr, u32 val)
+{
+	struct rdma_table_item request_item;
+	if (item_count_internal > 500) {
+		/* rdma table is full */
+		pr_info("update_table_item_internal overflow!\n");
+		return -1;
 	}
 	request_item.addr = addr;
 	request_item.val = val;
-	osd_rdma_mem_cpy(&rdma_table[item_count-1], &request_item, 8);
-	/*if dirty flag is cleared, then RDMA hw write and cpu
-	sw write is racing.if reject flag is true,then hw RDMA hw write
-	start when cpu write.*/
-	/*atom_lock_end:*/
-	if (!OSD_RDMA_STAUS_IS_DIRTY || OSD_RDMA_STATUS_IS_REJECT) {
-		item_count--;
-		spin_unlock_irqrestore(&rdma_lock, flags);
-		trace_printk("osd_rdma flag ++++++: %x\n",
-			osd_reg_read(OSD_RDMA_FLAG_REG));
-		goto retry;
+	memcpy(
+		&rdma_table_internal[item_count_internal],
+		&request_item, 8);
+	item_count_internal++;
+	return 0;
+}
+
+static inline u32 read_reg_internal(u32 addr)
+{
+	int  i;
+	u32 val = 0;
+	if (rdma_enable) {
+		for (i = (item_count - 1); i >= 0; i--) {
+			if (addr == rdma_table[i].addr) {
+				val = rdma_table[i].val;
+				break;
+			}
+		}
+		if (i >= 0)
+			return val;
 	}
-	spin_unlock_irqrestore(&rdma_lock, flags);
+	return osd_reg_read(addr);
+}
+
+static inline int wrtie_reg_internal(u32 addr, u32 val)
+{
+	struct rdma_table_item request_item;
+
+	if (!rdma_enable) {
+		osd_reg_write(addr, val);
+		return 0;
+	}
+
+	if (item_count > 500) {
+		/* rdma table is full */
+		pr_info("wrtie_reg_internal overflow!\n");
+		return -1;
+	}
+	/* TODO remove the Done write operation to save the time */
+	request_item.addr = OSD_RDMA_FLAG_REG;
+	request_item.val = OSD_RDMA_STATUS_MARK_TBL_DONE;
+	memcpy(
+		&rdma_table[item_count],
+		&request_item, 8);
+	request_item.addr = addr;
+	request_item.val = val;
+	memcpy(
+		&rdma_table[item_count - 1],
+		&request_item, 8);
+	item_count++;
 	return 0;
 }
 
@@ -241,11 +341,12 @@ EXPORT_SYMBOL(VSYNCOSD_RD_MPEG_REG);
 
 int VSYNCOSD_WR_MPEG_REG(u32 addr, u32 val)
 {
+	int ret = 0;
 	if (rdma_enable)
-		update_table_item(addr, val);
+		ret = update_table_item(addr, val, 0);
 	else
 		osd_reg_write(addr, val);
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(VSYNCOSD_WR_MPEG_REG);
 
@@ -253,14 +354,15 @@ int VSYNCOSD_WR_MPEG_REG_BITS(u32 addr, u32 val, u32 start, u32 len)
 {
 	unsigned long read_val;
 	unsigned long write_val;
+	int ret = 0;
 	if (rdma_enable) {
 		read_val = VSYNCOSD_RD_MPEG_REG(addr);
 		write_val = (read_val & ~(((1L << (len)) - 1) << (start)))
 			    | ((unsigned int)(val) << (start));
-		update_table_item(addr, write_val);
+		ret = update_table_item(addr, write_val, 0);
 	} else
 		osd_reg_set_bits(addr, val, start, len);
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(VSYNCOSD_WR_MPEG_REG_BITS);
 
@@ -268,13 +370,14 @@ int VSYNCOSD_SET_MPEG_REG_MASK(u32 addr, u32 _mask)
 {
 	unsigned long read_val;
 	unsigned long write_val;
+	int ret = 0;
 	if (rdma_enable) {
 		read_val = VSYNCOSD_RD_MPEG_REG(addr);
 		write_val = read_val | _mask;
-		update_table_item(addr, write_val);
+		ret = update_table_item(addr, write_val, 0);
 	} else
 		osd_reg_set_mask(addr, _mask);
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(VSYNCOSD_SET_MPEG_REG_MASK);
 
@@ -282,16 +385,90 @@ int VSYNCOSD_CLR_MPEG_REG_MASK(u32 addr, u32 _mask)
 {
 	unsigned long read_val;
 	unsigned long write_val;
+	int ret = 0;
 	if (rdma_enable) {
 		read_val = VSYNCOSD_RD_MPEG_REG(addr);
 		write_val = read_val & (~_mask);
-		update_table_item(addr, write_val);
+		ret = update_table_item(addr, write_val, 0);
 	} else
 		osd_reg_clr_mask(addr, _mask);
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(VSYNCOSD_CLR_MPEG_REG_MASK);
 
+int VSYNCOSD_IRQ_WR_MPEG_REG(u32 addr, u32 val)
+{
+	int ret = 0;
+	if (rdma_enable)
+		ret = update_table_item(addr, val, 1);
+	else
+		osd_reg_write(addr, val);
+	return ret;
+}
+EXPORT_SYMBOL(VSYNCOSD_IRQ_WR_MPEG_REG);
+
+int VSYNCOSD_IRQ_WR_MPEG_REG_BITS(u32 addr, u32 val, u32 start, u32 len)
+{
+	unsigned long read_val;
+	unsigned long write_val;
+	int ret = 0;
+	if (rdma_enable) {
+		read_val = VSYNCOSD_RD_MPEG_REG(addr);
+		write_val = (read_val & ~(((1L << (len)) - 1) << (start)))
+			    | ((unsigned int)(val) << (start));
+		ret = update_table_item(addr, write_val, 1);
+	} else
+		osd_reg_set_bits(addr, val, start, len);
+	return ret;
+}
+EXPORT_SYMBOL(VSYNCOSD_IRQ_WR_MPEG_REG_BITS);
+
+int VSYNCOSD_IRQ_SET_MPEG_REG_MASK(u32 addr, u32 _mask)
+{
+	unsigned long read_val;
+	unsigned long write_val;
+	int ret = 0;
+	if (rdma_enable) {
+		read_val = VSYNCOSD_RD_MPEG_REG(addr);
+		write_val = read_val | _mask;
+		ret = update_table_item(addr, write_val, 1);
+	} else
+		osd_reg_set_mask(addr, _mask);
+	return ret;
+}
+EXPORT_SYMBOL(VSYNCOSD_IRQ_SET_MPEG_REG_MASK);
+
+int VSYNCOSD_IRQ_CLR_MPEG_REG_MASK(u32 addr, u32 _mask)
+{
+	unsigned long read_val;
+	unsigned long write_val;
+	int ret = 0;
+	if (rdma_enable) {
+		read_val = VSYNCOSD_RD_MPEG_REG(addr);
+		write_val = read_val & (~_mask);
+		ret = update_table_item(addr, write_val, 1);
+	} else
+		osd_reg_clr_mask(addr, _mask);
+	return ret;
+}
+EXPORT_SYMBOL(VSYNCOSD_IRQ_CLR_MPEG_REG_MASK);
+
+int VSYNCOSD_EX_WR_MPEG_REG(u32 addr, u32 val)
+{
+	int ret = -1;
+	if (rdma_enable && rdma_table_internal)
+		ret = update_table_item_internal(addr, val);
+	if (ret != 0) {
+		ret = 0;
+		if (rdma_enable)
+			ret = update_table_item(addr, val, 1);
+		else
+			osd_reg_write(addr, val);
+	}
+	return ret;
+}
+EXPORT_SYMBOL(VSYNCOSD_EX_WR_MPEG_REG);
+
 static int start_osd_rdma(char channel)
 {
 	char intr_bit = 8 * channel;
@@ -362,28 +539,10 @@ int read_rdma_table(void)
 }
 EXPORT_SYMBOL(read_rdma_table);
 
-int reset_rdma(void)
-{
-	/*reset mechanism , to clear rdma status.*/
-	if (OSD_RDMA_STAUS_IS_DONE) { /*check if it is OSD rdma completed.*/
-		OSD_RDMA_STAUS_CLEAR_DONE;
-		/*check if no cpu write request since the latest hw rdma op.*/
-		if (!OSD_RDMA_STAUS_IS_DIRTY) {
-			/*since last HW op,no new wirte request.
-			rdma HW op will clear DIRTY flag.*/
-			/*reset all pointer. set table start margin.*/
-			pr_debug("reset from isr\n");
-			reset_rdma_table();
-			return 1;
-		}
-	}
-	return 0;
-}
-EXPORT_SYMBOL(reset_rdma);
-
 int osd_rdma_enable(u32 enable)
 {
 	int ret = 0;
+	unsigned long flags;
 
 	if (enable == rdma_enable)
 		return 0;
@@ -394,9 +553,13 @@ int osd_rdma_enable(u32 enable)
 
 	rdma_enable = enable;
 	if (enable) {
-		OSD_RDMA_STATUS_CLEAR_ALL;
-		reset_rdma_table();
+		spin_lock_irqsave(&rdma_lock, flags);
+		OSD_RDMA_STATUS_CLEAR_REJECT;
 		osd_reg_write(START_ADDR, table_paddr);
+		osd_reg_write(END_ADDR, table_paddr - 1);
+		item_count = 0;
+		spin_unlock_irqrestore(&rdma_lock, flags);
+		reset_rdma_table();
 		start_osd_rdma(OSD_RDMA_CHANNEL_INDEX);
 	} else {
 		stop_rdma(OSD_RDMA_CHANNEL_INDEX);
@@ -406,29 +569,126 @@ int osd_rdma_enable(u32 enable)
 }
 EXPORT_SYMBOL(osd_rdma_enable);
 
+int osd_rdma_reset_and_flush(u32 reset_bit)
+{
+	unsigned long read_val;
+	unsigned long write_val;
+	unsigned long flags;
+	u32 osd_backup[OSD_REG_BACKUP_COUNT];
+	u32 afbc_backup[OSD_AFBC_REG_BACKUP_COUNT];
+	struct rdma_table_item request_item;
+	int i, ret = 0;
+	spin_lock_irqsave(&rdma_lock, flags);
+	i = 0;
+	while ((reset_bit & 1)
+		&& (i < OSD_REG_BACKUP_COUNT)) {
+		osd_backup[i] = read_reg_internal(
+			osd_reg_backup[i]);
+		i++;
+	}
+	i = 0;
+	while ((reset_bit & 0x80000000)
+		&& (i < OSD_AFBC_REG_BACKUP_COUNT)) {
+		afbc_backup[i] = read_reg_internal(
+			osd_afbc_reg_backup[i]);
+		i++;
+	}
+	read_val = read_reg_internal(VIU_SW_RESET);
+	write_val = read_val | reset_bit;
+	wrtie_reg_internal(VIU_SW_RESET, write_val);
+
+	read_val = read_reg_internal(VIU_SW_RESET);
+	write_val = read_val & (~reset_bit);
+	wrtie_reg_internal(VIU_SW_RESET, write_val);
+
+	i = 0;
+	while ((reset_bit & 1)
+		&& (i < OSD_REG_BACKUP_COUNT)) {
+		wrtie_reg_internal(
+			osd_reg_backup[i], osd_backup[i]);
+		i++;
+	}
+	i = 0;
+	while ((reset_bit & 0x80000000)
+		&& (i < OSD_AFBC_REG_BACKUP_COUNT)) {
+		if (osd_afbc_reg_backup[i]
+			== OSD1_AFBCD_ENABLE)
+			wrtie_reg_internal(
+				osd_afbc_reg_backup[i],
+				afbc_backup[i] | 0x100);
+		else
+			wrtie_reg_internal(
+				osd_afbc_reg_backup[i],
+				afbc_backup[i]);
+		i++;
+	}
+	if (item_count + item_count_internal < 500) {
+		request_item.addr = OSD_RDMA_FLAG_REG;
+		request_item.val = OSD_RDMA_STATUS_MARK_TBL_DONE;
+		memcpy(
+			&rdma_table[item_count + item_count_internal - 1],
+			&request_item, 8);
+		memcpy(
+			&rdma_table[item_count - 1],
+			&rdma_table_internal[0],
+			8 * item_count_internal);
+		item_count = item_count + item_count_internal;
+		osd_reg_write(END_ADDR, (table_paddr + item_count * 8 - 1));
+	} else {
+		pr_info("osd_rdma_reset_and_flush item overflow %d + %d\n",
+			item_count, item_count_internal);
+		osd_reg_write(END_ADDR, (table_paddr + item_count * 8 - 1));
+		ret = -1;
+	}
+	if (dump_reg_trigger > 0) {
+		for (i = 0; i < item_count; i++)
+			pr_info("dump rdma reg[%d]:0x%x, data:0x%x\n",
+				i, rdma_table[i].addr,
+				rdma_table[i].val);
+		dump_reg_trigger--;
+	}
+	spin_unlock_irqrestore(&rdma_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(osd_rdma_reset_and_flush);
+
 static void osd_rdma_release(struct device *dev)
 {
 	kfree(dev);
 	osd_rdma_dev = NULL;
+	kfree(rdma_table_internal);
+	rdma_table_internal = NULL;
 }
 
 static irqreturn_t osd_rdma_isr(int irq, void *dev_id)
 {
-	int ret = 0;
-	ret = reset_rdma();
-
-	osd_update_scan_mode();
-	osd_update_3d_mode();
-	osd_update_vsync_hit();
-
-	osd_hw_reset();
-
-	if (ret) {
-		/*This is a memory barrier*/
-		wmb();
+	u32 rdma_status;
+	rdma_status = osd_reg_read(RDMA_STATUS);
+	debug_rdma_status = rdma_status;
+	if (rdma_status & (1 << (24+OSD_RDMA_CHANNEL_INDEX))) {
+		OSD_RDMA_STATUS_CLEAR_REJECT;
+		reset_rdma_table();
+		item_count_internal = 0;
+		osd_update_scan_mode();
+		osd_update_3d_mode();
+		osd_update_vsync_hit();
+		osd_hw_reset();
+		rdma_irq_count++;
+		{
+			/*This is a memory barrier*/
+			wmb();
+		}
+		osd_reg_write(RDMA_CTRL, 1 << (24+OSD_RDMA_CHANNEL_INDEX));
+	} else
+		rdma_lost_count++;
+	rdma_status = osd_reg_read(RDMA_STATUS);
+	if (rdma_status & 0xf7000000) {
+		if (!second_rdma_irq)
+			pr_info("osd rdma irq as first function call, status: 0x%x\n",
+				rdma_status);
+		pr_info("osd rdma miss done isr, status: 0x%x\n", rdma_status);
+		osd_reg_write(RDMA_CTRL, rdma_status & 0xf7000000);
 	}
-	osd_reg_write(RDMA_CTRL, 1 << (24+OSD_RDMA_CHANNEL_INDEX));
-
 	return IRQ_HANDLED;
 }
 
@@ -459,19 +719,35 @@ static int osd_rdma_init(void)
 		osd_log_err("osd rdma dma alloc failed!\n");
 		goto error2;
 	}
+
+	rdma_table_internal = kzalloc(
+		RDMA_TABLE_INTERNAL_COUNT * sizeof(struct rdma_table_item),
+		GFP_KERNEL);
+
+	if (!rdma_table_internal) {
+		osd_log_err("osd rdma dma alloc failed2!\n");
+		goto error2;
+	}
+	item_count_internal = 0;
+	second_rdma_irq = 0;
+	dump_reg_trigger = 0;
 	table_vaddr = osd_rdma_table_virt;
 	table_paddr = osd_rdma_table_phy;
-	osd_log_info("%s: rmda_table p=0x%x,op=0x%lx , v=0x%p\n", __func__,
-			table_paddr, (long unsigned int)osd_rdma_table_phy,
-		     table_vaddr);
+	osd_log_info("%s: rdma_table p=0x%x,op=0x%lx , v=0x%p\n", __func__,
+		table_paddr, (long unsigned int)osd_rdma_table_phy,
+		table_vaddr);
 	rdma_table = (struct rdma_table_item *)table_vaddr;
 	if (NULL == rdma_table) {
 		osd_log_err("%s: failed to remap rmda_table_addr\n", __func__);
 		goto error2;
 	}
 
+	if (rdma_mgr_irq_request) {
+		second_rdma_irq = 1;
+		pr_info("osd rdma request irq as second interrput function!\n");
+	}
 	if (request_irq(INT_RDMA, &osd_rdma_isr,
-			IRQF_SHARED, "osd_rdma", (void *)"osd_rdma")) {
+		IRQF_SHARED, "osd_rdma", (void *)"osd_rdma")) {
 		osd_log_err("can't request irq for rdma\n");
 		goto error2;
 	}
@@ -482,6 +758,8 @@ static int osd_rdma_init(void)
 error2:
 	kfree(osd_rdma_dev);
 	osd_rdma_dev = NULL;
+	kfree(rdma_table_internal);
+	rdma_table_internal = NULL;
 	return -1;
 }
 
@@ -493,3 +771,16 @@ module_param(table_paddr, uint, 0664);
 
 MODULE_PARM_DESC(rdma_debug, "\n rdma_debug\n");
 module_param(rdma_debug, uint, 0664);
+
+MODULE_PARM_DESC(debug_rdma_status, "\n debug_rdma_status\n");
+module_param(debug_rdma_status, uint, 0664);
+
+MODULE_PARM_DESC(rdma_irq_count, "\n rdma_irq_count\n");
+module_param(rdma_irq_count, uint, 0664);
+
+MODULE_PARM_DESC(rdma_lost_count, "\n rdma_lost_count\n");
+module_param(rdma_lost_count, uint, 0664);
+
+MODULE_PARM_DESC(dump_reg_trigger, "\n dump_reg_trigger\n");
+module_param(dump_reg_trigger, uint, 0664);
+
diff --git a/drivers/amlogic/display/osd/osd_rdma.h b/drivers/amlogic/display/osd/osd_rdma.h
index fbe21c6..fbbf6bb 100644
--- a/drivers/amlogic/display/osd/osd_rdma.h
+++ b/drivers/amlogic/display/osd/osd_rdma.h
@@ -35,59 +35,38 @@ struct rdma_table_item {
 
 #define OSD_RDMA_FLAG_REG	VIU_OSD2_TCOLOR_AG3
 
-#define OSD_RDMA_FLAG_DONE	(1<<0)
-/*hw rdma change it to 1 when rdma complete,
-	rdma isr chagne it to 0 to reset it.*/
-#define OSD_RDMA_FLAG_REJECT	(1<<1)
-/*hw rdma own this flag, change it to zero when s
-	tart rdma,change it to 0 when complete*/
-#define	OSD_RDMA_FLAG_DIRTY	(1<<2)
-/*hw rdma change it to 0 , cpu write change it to 1*/
+#define OSD_RDMA_FLAG_REJECT	(0x99 << 0)
+/* hw rdma own this flag, change it to zero when s
+	tart rdma,change it to 0 when complete */
 
-#define OSD_RDMA_FLAGS_ALL_ENABLE \
-	(OSD_RDMA_FLAG_DONE|OSD_RDMA_FLAG_REJECT|OSD_RDMA_FLAG_DIRTY)
-
-#define  OSD_RDMA_STATUS \
-	(osd_reg_read(OSD_RDMA_FLAG_REG)& \
-	(OSD_RDMA_FLAG_REJECT|OSD_RDMA_FLAG_DONE|OSD_RDMA_FLAG_DIRTY))
 #define  OSD_RDMA_STATUS_IS_REJECT \
-	(osd_reg_read(OSD_RDMA_FLAG_REG)& \
-		OSD_RDMA_FLAG_REJECT)
-#define  OSD_RDMA_STAUS_IS_DIRTY \
-		(osd_reg_read(OSD_RDMA_FLAG_REG)&OSD_RDMA_FLAG_DIRTY)
-#define  OSD_RDMA_STAUS_IS_DONE	\
-	(osd_reg_read(OSD_RDMA_FLAG_REG)&OSD_RDMA_FLAG_DONE)
+	(osd_reg_read(OSD_RDMA_FLAG_REG) & OSD_RDMA_FLAG_REJECT)
 
-/*hw rdma op, set DONE && clear DIRTY && clear REJECT*/
-#define  OSD_RDMA_STATUS_MARK_COMPLETE \
-	((osd_reg_read(OSD_RDMA_FLAG_REG)&~OSD_RDMA_FLAGS_ALL_ENABLE)|\
-		(OSD_RDMA_FLAG_DONE))
-/*hw rdma op,set REJECT && set DIRTY.*/
+/* hw rdma op, set REJECT */
 #define  OSD_RDMA_STATUS_MARK_TBL_RST \
-	((osd_reg_read(OSD_RDMA_FLAG_REG)&~OSD_RDMA_FLAGS_ALL_ENABLE)| \
-	(OSD_RDMA_FLAG_REJECT|OSD_RDMA_FLAG_DIRTY))
+	((osd_reg_read(OSD_RDMA_FLAG_REG) \
+	& ~OSD_RDMA_FLAG_REJECT) | \
+	(OSD_RDMA_FLAG_REJECT))
+
+#define  OSD_RDMA_STATUS_MARK_TBL_DONE \
+	((osd_reg_read(OSD_RDMA_FLAG_REG) \
+	& ~OSD_RDMA_FLAG_REJECT)) \
 
-/*cpu op*/
-#define  OSD_RDMA_STAUS_MARK_DIRTY \
-	(osd_reg_write(OSD_RDMA_FLAG_REG, osd_reg_read(OSD_RDMA_FLAG_REG)|\
-		OSD_RDMA_FLAG_DIRTY))
-/*isr op*/
-#define  OSD_RDMA_STAUS_CLEAR_DONE \
-	(osd_reg_write(OSD_RDMA_FLAG_REG, osd_reg_read(OSD_RDMA_FLAG_REG)& \
-	~(OSD_RDMA_FLAG_DONE)))
-/*cpu reset op.*/
-#define  OSD_RDMA_STATUS_CLEAR_ALL \
-	(osd_reg_write(OSD_RDMA_FLAG_REG, (osd_reg_read(OSD_RDMA_FLAG_REG)& \
-		~OSD_RDMA_FLAGS_ALL_ENABLE)))
+/* cpu op, clear REJECT */
+#define  OSD_RDMA_STATUS_CLEAR_REJECT \
+	(osd_reg_write(OSD_RDMA_FLAG_REG, \
+	(osd_reg_read(OSD_RDMA_FLAG_REG) & \
+	~OSD_RDMA_FLAG_REJECT)))
 
 extern void osd_update_scan_mode(void);
 extern void osd_update_3d_mode(void);
 extern void osd_update_vsync_hit(void);
 extern void osd_hw_reset(void);
 extern int read_rdma_table(void);
-extern int reset_rdma(void);
 extern int osd_rdma_enable(u32 enable);
+extern int osd_rdma_reset_and_flush(u32 reset_bit);
 extern int rdma_reset_tigger_flag;
+extern int rdma_mgr_irq_request;
 #ifdef CONFIG_VSYNC_RDMA
 extern void osd_rdma_interrupt_done_clear(void);
 #endif
diff --git a/drivers/amlogic/display/vout/enc_clk_config.c b/drivers/amlogic/display/vout/enc_clk_config.c
index 0dc658e..7b93be7 100644
--- a/drivers/amlogic/display/vout/enc_clk_config.c
+++ b/drivers/amlogic/display/vout/enc_clk_config.c
@@ -451,6 +451,7 @@ static void set_hpll_clk_out(unsigned clk)
 		break;
 	case MESON_CPU_MAJOR_ID_GXL:
 	case MESON_CPU_MAJOR_ID_GXM:
+	case MESON_CPU_MAJOR_ID_TXL:
 		set_hpll_clk_out_gxl(clk);
 		break;
 	default:
@@ -659,8 +660,7 @@ void set_vmode_clk(enum vmode_e mode)
 	int j = 0;
 
 	mutex_lock(&setclk_mutex);
-	if (is_meson_gxl_cpu() ||
-		is_meson_gxm_cpu()) {
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXL)) {
 		p_enc = &setting_enc_clk_val_gxl[0];
 		i = sizeof(setting_enc_clk_val_gxl)
 			/ sizeof(struct enc_clk_val_s);
@@ -685,6 +685,12 @@ void set_vmode_clk(enum vmode_e mode)
 		i = sizeof(setting_enc_clk_val_m6)
 			/ sizeof(struct enc_clk_val_s);
 	}
+
+	if (p_enc == NULL) {
+		vout_log_err("can't find clock table!\n");
+		return;
+	}
+
 	vout_log_info("mode is: %d\n", mode);
 	for (j = 0; j < i; j++) {
 		if (mode == p_enc[j].mode)
diff --git a/drivers/amlogic/display/vout/tv_vout.c b/drivers/amlogic/display/vout/tv_vout.c
index c5e69b8..16ee9b8 100644
--- a/drivers/amlogic/display/vout/tv_vout.c
+++ b/drivers/amlogic/display/vout/tv_vout.c
@@ -125,8 +125,7 @@ static void set_tvmode_misc(enum tvmode_e mode)
 	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_M8) ||
 	    (get_cpu_type() == MESON_CPU_MAJOR_ID_M8M2) ||
 	    (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) ||
-	    (get_cpu_type() == MESON_CPU_MAJOR_ID_GXL) ||
-	    (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)) {
+	    (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)) {
 		if ((mode == TVMODE_480CVBS) || (mode == TVMODE_576CVBS))
 			set_vmode_clk(mode);
 	} else
@@ -175,9 +174,8 @@ static void cvbs_cntl_output(unsigned int open)
 		/* must enable adc bandgap, the adc ref signal for demod */
 		vdac_enable(0, 0x8);
 	} else if (open == 1) { /* open */
-		if (is_meson_gxl_cpu() ||
-			is_meson_gxm_cpu())
-			cntl0 = 0xf0001;
+		if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXL))
+			cntl0 = 0xb0001;
 		else
 			cntl0 = 0x1;
 		cntl1 = (vdac_cfg_valid == 0) ? 0 : vdac_cfg_value;
@@ -229,8 +227,7 @@ static void cvbs_performance_enhancement(enum tvmode_e mode)
 		index = (index >= max) ? 0 : index;
 		s = tvregs_576cvbs_performance_m8[index];
 		type = 3;
-	} else if ((check_cpu_type(MESON_CPU_MAJOR_ID_GXBB)) ||
-			   (check_cpu_type(MESON_CPU_MAJOR_ID_GXM))) {
+	} else if (check_cpu_type(MESON_CPU_MAJOR_ID_GXBB)) {
 		max = sizeof(tvregs_576cvbs_performance_gxbb)
 			/ sizeof(struct reg_s *);
 		index = (index >= max) ? 0 : index;
@@ -242,19 +239,25 @@ static void cvbs_performance_enhancement(enum tvmode_e mode)
 		index = (index >= max) ? 0 : index;
 		s = tvregs_576cvbs_performance_gxtvbb[index];
 		type = 5;
-	} else if (is_meson_gxl_package_905X() ||
-		is_meson_gxm_cpu()) {
-		max = sizeof(tvregs_576cvbs_performance_905x)
-			/ sizeof(struct reg_s *);
-		index = (index >= max) ? 0 : index;
-		s = tvregs_576cvbs_performance_905x[index];
-		type = 6;
-	} else if (is_meson_gxl_package_905L()) {
-		max = sizeof(tvregs_576cvbs_performance_905l)
-			/ sizeof(struct reg_s *);
-		index = (index >= max) ? 0 : index;
-		s = tvregs_576cvbs_performance_905l[index];
-		type = 7;
+	} else if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXL)) {
+		if (is_meson_gxl_package_905L()) {
+			max = sizeof(tvregs_576cvbs_performance_905l)
+				/ sizeof(struct reg_s *);
+			index = (index >= max) ? 0 : index;
+			s = tvregs_576cvbs_performance_905l[index];
+			type = 7;
+		} else {
+			max = sizeof(tvregs_576cvbs_performance_905x)
+				/ sizeof(struct reg_s *);
+			index = (index >= max) ? 0 : index;
+			s = tvregs_576cvbs_performance_905x[index];
+			type = 6;
+		}
+	}
+
+	if (s == NULL) {
+		vout_log_err("can't find performance table!\n");
+		return;
 	}
 
 	vout_log_info("cvbs performance type = %d, table = %d\n", type, index);
@@ -829,42 +832,6 @@ static char *get_name_from_vmode(enum vmode_e mode)
 	return tv_info[i].name;
 }
 
-/* frame_rate = 9600/duration/100 hz */
-static int get_vsource_frame_rate(int duration)
-{
-	int frame_rate = 0;
-	switch (duration) {
-	case 1600:
-		frame_rate = 6000;
-		break;
-	case 1601:
-	case 1602:
-		frame_rate = 5994;
-		break;
-	case 1920:
-		frame_rate = 5000;
-		break;
-	case 3200:
-		frame_rate = 3000;
-		break;
-	case 3203:
-		frame_rate = 2997;
-		break;
-	case 3840:
-		frame_rate = 2500;
-		break;
-	case 4000:
-		frame_rate = 2400;
-		break;
-	case 4004:
-		frame_rate = 2397;
-		break;
-	default:
-		break;
-	}
-	return frame_rate;
-}
-
 static int (*hdmi_edid_supported_func)(char *mode_name);
 void register_hdmi_edid_supported_func(int (*pfunc)(char *mode_name))
 {
@@ -1116,7 +1083,7 @@ static int framerate_automation_process(int duration)
 		vout_log_info("vout frame rate automation disabled!\n");
 		return 1;
 	}
-	fr_vsource = get_vsource_frame_rate(duration);
+	fr_vsource = get_vsource_fps(duration);
 	fps_playing_flag = 0;
 	if ((fr_vsource == 5994)
 		|| (fr_vsource == 2997)
diff --git a/drivers/amlogic/display/vout/vdac_dev.c b/drivers/amlogic/display/vout/vdac_dev.c
index 6279685..796ff4f 100644
--- a/drivers/amlogic/display/vout/vdac_dev.c
+++ b/drivers/amlogic/display/vout/vdac_dev.c
@@ -31,6 +31,7 @@
 #include <linux/amlogic/cpu_version.h>
 #include <linux/amlogic/vout/vout_notify.h>
 #include <linux/io.h>
+#include <linux/mutex.h>
 
 #define AMVDAC_NAME               "amvdac"
 #define AMVDAC_DRIVER_NAME        "amvdac"
@@ -46,6 +47,7 @@ struct amvdac_dev_s {
 	struct class                *clsp;
 };
 static struct amvdac_dev_s amvdac_dev;
+static struct mutex vdac_mutex;
 
 #define HHI_VDAC_CNTL0 0x10bd
 #define HHI_VDAC_CNTL1 0x10be
@@ -54,6 +56,7 @@ static struct amvdac_dev_s amvdac_dev;
 #define VDAC_MODULE_DTV_DEMOD 0x2
 #define VDAC_MODULE_TVAFE     0x4
 #define VDAC_MODULE_CVBS_OUT  0x8
+#define VDAC_MODULE_AUDIO_OUT  0x10
 
 void __iomem *vdac_hiu_reg_base;/* = *ioremap(0xc883c000, 0x2000); */
 
@@ -128,7 +131,7 @@ void ana_ref_cntl0_bit9(bool on, unsigned int module_sel)
 {
 	bool enable = 0;
 
-	switch (module_sel & 0xf) {
+	switch (module_sel & 0x1f) {
 	case VDAC_MODULE_ATV_DEMOD: /* dtv demod */
 		if (on)
 			vdac_cntl0_bit9 |= VDAC_MODULE_ATV_DEMOD;
@@ -153,19 +156,27 @@ void ana_ref_cntl0_bit9(bool on, unsigned int module_sel)
 		else
 			vdac_cntl0_bit9 &= ~VDAC_MODULE_CVBS_OUT;
 		break;
+	case VDAC_MODULE_AUDIO_OUT: /* audio out ctrl*/
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+			if (on)
+				vdac_cntl0_bit9 |= VDAC_MODULE_AUDIO_OUT;
+			else
+				vdac_cntl0_bit9 &= ~VDAC_MODULE_AUDIO_OUT;
+		}
+		break;
 	default:
 		pr_err("module_sel: 0x%x wrong module index !! ", module_sel);
 		break;
 	}
 	/* pr_info("\nvdac_cntl0_bit9: 0x%x\n", vdac_cntl0_bit9); */
 
-	if ((vdac_cntl0_bit9 & 0xf) == 0)
+	if ((vdac_cntl0_bit9 & 0x1f) == 0)
 		enable = 0;
 	else
 		enable = 1;
 
-	if (is_meson_gxtvbb_cpu() &&
-		(0xa != get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR)))
+	if (is_meson_txl_cpu() || (is_meson_gxtvbb_cpu() &&
+		(0xa != get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR))))
 		vdac_hiu_reg_setb(HHI_VDAC_CNTL0, enable, 9, 1);
 	else
 		vdac_hiu_reg_setb(HHI_VDAC_CNTL0, ~enable, 9, 1);
@@ -317,8 +328,8 @@ void vdac_out_cntl1_bit3(bool on, unsigned int module_sel)
 	else
 		enable = 1;
 
-	if (is_meson_gxtvbb_cpu() &&
-		(0xa != get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR)))
+	if (is_meson_txl_cpu() || (is_meson_gxtvbb_cpu() &&
+		(0xa != get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR))))
 		vdac_hiu_reg_setb(HHI_VDAC_CNTL1, enable, 3, 1);
 	else
 		vdac_hiu_reg_setb(HHI_VDAC_CNTL1, ~enable, 3, 1);
@@ -341,6 +352,8 @@ EXPORT_SYMBOL(vdac_set_ctrl0_ctrl1);
 void vdac_enable(bool on, unsigned int module_sel)
 {
 	pr_info("\n%s: on:%d,module_sel:%x\n", __func__, on, module_sel);
+
+	mutex_lock(&vdac_mutex);
 	switch (module_sel) {
 	case VDAC_MODULE_ATV_DEMOD: /* atv demod */
 		if (on) {
@@ -397,10 +410,10 @@ void vdac_enable(bool on, unsigned int module_sel)
 			vdac_out_cntl1_bit3(1, VDAC_MODULE_CVBS_OUT);
 			vdac_out_cntl0_bit0(1, VDAC_MODULE_CVBS_OUT);
 			ana_ref_cntl0_bit9(1, VDAC_MODULE_CVBS_OUT);
-			vdac_out_cntl0_bit10(1, VDAC_MODULE_CVBS_OUT);
+			vdac_out_cntl0_bit10(0, VDAC_MODULE_CVBS_OUT);
 			pri_flag |= VDAC_MODULE_CVBS_OUT;
 		} else {
-			vdac_out_cntl0_bit10(0, VDAC_MODULE_CVBS_OUT);
+			/*vdac_out_cntl0_bit10(0, VDAC_MODULE_CVBS_OUT);*/
 			ana_ref_cntl0_bit9(0, VDAC_MODULE_CVBS_OUT);
 			vdac_out_cntl0_bit0(0, VDAC_MODULE_CVBS_OUT);
 			vdac_out_cntl1_bit3(0, VDAC_MODULE_CVBS_OUT);
@@ -415,11 +428,20 @@ void vdac_enable(bool on, unsigned int module_sel)
 			}
 		}
 		break;
+	case VDAC_MODULE_AUDIO_OUT: /* audio demod */
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+			if (on)
+				ana_ref_cntl0_bit9(1, VDAC_MODULE_AUDIO_OUT);
+			else
+				ana_ref_cntl0_bit9(0, VDAC_MODULE_AUDIO_OUT);
+		}
+		break;
 	default:
 		pr_err("%s:module_sel: 0x%x wrong module index !! "
 					, __func__, module_sel);
 		break;
 	}
+	mutex_unlock(&vdac_mutex);
 }
 EXPORT_SYMBOL(vdac_enable);
 
@@ -554,6 +576,7 @@ static int __init aml_vdac_init(void)
 
 	vdac_init_succ_flag = 0;
 
+	mutex_init(&vdac_mutex);
 	/* remap the hiu bus */
 	vdac_hiu_reg_base = ioremap(0xc883c000, 0x2000);
 
@@ -568,6 +591,7 @@ static int __init aml_vdac_init(void)
 
 static void __exit aml_vdac_exit(void)
 {
+	mutex_destroy(&vdac_mutex);
 	pr_info("%s: module exit\n", __func__);
 	platform_driver_unregister(&aml_vdac_driver);
 }
diff --git a/drivers/amlogic/display/vout/vout_notify.c b/drivers/amlogic/display/vout/vout_notify.c
index bde9370..6474ad3 100644
--- a/drivers/amlogic/display/vout/vout_notify.c
+++ b/drivers/amlogic/display/vout/vout_notify.c
@@ -115,6 +115,44 @@ enum vmode_e get_current_vmode(void)
 }
 EXPORT_SYMBOL(get_current_vmode);
 
+/* fps = 9600/duration/100 hz */
+int get_vsource_fps(int duration)
+{
+	int fps = 6000;
+
+	switch (duration) {
+	case 1600:
+		fps = 6000;
+		break;
+	case 1601:
+	case 1602:
+		fps = 5994;
+		break;
+	case 1920:
+		fps = 5000;
+		break;
+	case 3200:
+		fps = 3000;
+		break;
+	case 3203:
+		fps = 2997;
+		break;
+	case 3840:
+		fps = 2500;
+		break;
+	case 4000:
+		fps = 2400;
+		break;
+	case 4004:
+		fps = 2397;
+		break;
+	default:
+		break;
+	}
+	return fps;
+}
+EXPORT_SYMBOL(get_vsource_fps);
+
 /*
 *interface export to client who want to notify about source frame rate.
 */
diff --git a/drivers/amlogic/display/vout/vout_serve.c b/drivers/amlogic/display/vout/vout_serve.c
index 4cf9838..fae61b3 100644
--- a/drivers/amlogic/display/vout/vout_serve.c
+++ b/drivers/amlogic/display/vout/vout_serve.c
@@ -57,6 +57,7 @@ static int early_resume_flag;
 
 static struct class *vout_class;
 static DEFINE_MUTEX(vout_mutex);
+static char vout_mode_uboot[64] __nosavedata;
 static char vout_mode[64] __nosavedata;
 static char vout_axis[64] __nosavedata;
 static u32 vout_init_vmode = VMODE_INIT_NULL;
@@ -175,6 +176,8 @@ static int set_vout_mode(char *name)
 {
 	struct hdmitx_dev *hdmitx_device = get_hdmitx_device();
 	enum vmode_e mode;
+	int ret = 0;
+
 	vout_log_info("vmode set to %s\n", name);
 
 	if (strcmp(name, local_name)) {
@@ -192,10 +195,6 @@ static int set_vout_mode(char *name)
 		vout_log_info("no matched vout mode\n");
 		return -1;
 	}
-	if (mode == get_current_vmode()) {
-		vout_log_info("don't set the same mode as current\n");
-		return -1;
-	}
 next:
 	if (hdmitx_device->hdtx_dev) {
 		/*
@@ -214,19 +213,24 @@ next:
 		}
 	}
 	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE_PRE, &mode);
-	set_current_vmode(mode);
-	vout_log_info("new mode %s set ok\n", name);
+	ret = set_current_vmode(mode);
+	if (ret)
+		vout_log_info("new mode %s set error\n", name);
+	else
+		vout_log_info("new mode %s set ok\n", name);
 	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, &mode);
-	return 0;
+	return ret;
 }
 
 static int set_vout_init_mode(void)
 {
 	enum vmode_e vmode;
-	const char *name;
+	int ret = 0;
 
-	if (VMODE_MAX == vout_init_vmode) {
-		vout_log_info("no matched vout_init mode\n");
+	vout_init_vmode = validate_vmode(vout_mode_uboot);
+	if (vout_init_vmode >= VMODE_MAX) {
+		vout_log_info("no matched vout_init mode %s\n",
+			vout_mode_uboot);
 		return -1;
 	}
 #if 1
@@ -239,13 +243,12 @@ static int set_vout_init_mode(void)
 	vmode = vout_init_vmode;
 #endif
 
-	name = vmode_mode_to_name(vout_init_vmode);
 	memset(local_name, 0, sizeof(local_name));
-	strcpy(local_name, name);
-	set_current_vmode(vmode);
-	vout_log_info("init mode %s\n", name);
+	strcpy(local_name, vout_mode_uboot);
+	ret = set_current_vmode(vmode);
+	vout_log_info("init mode %s\n", vout_mode_uboot);
 
-	return 0;
+	return ret;
 }
 
 enum vmode_e get_logo_vmode(void)
@@ -285,6 +288,12 @@ char *get_vout_mode_internal(void)
 }
 EXPORT_SYMBOL(get_vout_mode_internal);
 
+char *get_vout_mode_uboot(void)
+{
+	return vout_mode_uboot;
+}
+EXPORT_SYMBOL(get_vout_mode_uboot);
+
 static void set_vout_axis(char *para)
 {
 #define OSD_COUNT 2
@@ -588,13 +597,11 @@ static int str2lower(char *str)
 
 static void vout_init_mode_parse(char *str)
 {
-	enum vmode_e vmode;
+	/*enum vmode_e vmode;*/
 
 	/* detect vout mode */
-	vmode = vmode_name_to_mode(str);
-	if (vmode < VMODE_MAX) {
-		vout_init_vmode = vmode;
-		vout_log_info("%s: %d\n", str, vout_init_vmode);
+	if (strlen(str) <= 1) {
+		vout_log_info("%s: error\n", str);
 		return;
 	}
 
@@ -608,6 +615,19 @@ static void vout_init_mode_parse(char *str)
 		vout_log_info("%s: %d\n", str, uboot_display);
 		return;
 	}
+
+	/* just save the vmode_name,
+	convert to vmode when vout sever registered */
+	strcpy(vout_mode_uboot, str);
+	vout_log_info("%s\n", str);
+	/*vmode = vmode_name_to_mode(str);
+	if (vmode < VMODE_MAX) {
+		vout_init_vmode = vmode;
+		vout_log_info("%s: %d\n", str, vout_init_vmode);
+		return;
+	}*/
+	return;
+
 	vout_log_info("%s: error\n", str);
 }
 
@@ -619,6 +639,9 @@ static int __init get_vout_init_mode(char *str)
 	int count = 3;
 	char find = 0;
 
+	/* init void vout_mode_uboot name */
+	memset(vout_mode_uboot, 0, sizeof(vout_mode_uboot));
+
 	if (NULL == str)
 		return -EINVAL;
 
diff --git a/drivers/amlogic/dvb_tv/aml_fe.c b/drivers/amlogic/dvb_tv/aml_fe.c
index ae159c6..6a31fb5 100644
--- a/drivers/amlogic/dvb_tv/aml_fe.c
+++ b/drivers/amlogic/dvb_tv/aml_fe.c
@@ -256,6 +256,8 @@ struct dvb_frontend *get_si2177_tuner(void)
 
 	for (i = 0; i < FE_DEV_COUNT; i++) {
 		dev = &fe_man.tuner[i];
+		if (dev == NULL || dev->drv == NULL || dev->fe == NULL)
+			continue;
 #if (defined CONFIG_AM_SI2177)
 		if (!strcmp(dev->drv->name, "si2177_tuner"))
 			return dev->fe->fe;
@@ -267,6 +269,8 @@ struct dvb_frontend *get_si2177_tuner(void)
 			return dev->fe->fe;
 #else
 #endif
+		if (!strcmp(dev->drv->name, "r842_tuner"))
+			return dev->fe->fe;
 		return dev->fe->fe;
 	}
 	pr_error("can not find out tuner drv\n");
@@ -669,7 +673,7 @@ static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe)
 					      p->frequency + ATV_AFC_500KHZ, 1)
 				== 0) {
 				try_ntsc = 0;
-				get_vfmt_maxcnt = 100;
+				get_vfmt_maxcnt = 200;
 				p->analog.std =
 					(V4L2_COLOR_STD_PAL | V4L2_STD_PAL_I);
 				p->frequency += 1;
@@ -685,7 +689,8 @@ static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe)
 						varify_cnt++;
 					if (varify_cnt > 3)
 						break;
-					if (i == (get_vfmt_maxcnt/2)) {
+					if (i == (get_vfmt_maxcnt/3) ||
+						(i == (get_vfmt_maxcnt/3)*2)) {
 						p->analog.std =
 							(V4L2_COLOR_STD_NTSC
 							| V4L2_STD_NTSC_M);
@@ -742,8 +747,10 @@ static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe)
 				audio = aml_audiomode_autodet(fe);
 				audio = demod_fmt_2_v4l2_std(audio);
 				if (audio == V4L2_STD_PAL_M) {
-					audio = V4L2_STD_PAL_BG;
-					pr_err("M near BG,should be BG\n");
+					audio = demod_fmt_2_v4l2_std(
+						broad_std_except_pal_m);
+					pr_err("select best audio mode 0x%x\n",
+						audio);
 				}
 			}
 			pr_err("%s,Manual freq:%d: std_bk:0x%x ,audmode:0x%x\n",
@@ -940,7 +947,7 @@ static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe)
 			if (aml_fe_afc_closer(fe, minafcfreq,
 				maxafcfreq + ATV_AFC_500KHZ, 1) == 0) {
 				try_ntsc = 0;
-				get_vfmt_maxcnt = 100;
+				get_vfmt_maxcnt = 200;
 			while (1) {
 				for (i = 0; i < get_vfmt_maxcnt; i++) {
 					if (aml_fe_hook_get_fmt == NULL)
@@ -954,7 +961,8 @@ static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe)
 				}
 					if (varify_cnt > 3)
 						break;
-					if (i == get_vfmt_maxcnt/2) {
+					if (i == (get_vfmt_maxcnt/3) ||
+						(i == (get_vfmt_maxcnt/3)*2)) {
 						p->analog.std =
 							(V4L2_COLOR_STD_NTSC
 							| V4L2_STD_NTSC_M);
@@ -963,6 +971,9 @@ static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe)
 					}
 					usleep_range(20*1000, 20*1000+100);
 				}
+				if (debug_fe & 0x2)
+					pr_err("get std_bk cnt:%d\n", i);
+
 				if (std_bk == 0) {
 					pr_err("%s, failed to get v fmt !!\n",
 						__func__);
@@ -1012,8 +1023,10 @@ static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe)
 				audio = aml_audiomode_autodet(fe);
 				audio = demod_fmt_2_v4l2_std(audio);
 				if (audio == V4L2_STD_PAL_M) {
-					audio = V4L2_STD_PAL_BG;
-					pr_err("M near BG,should be BG\n");
+					audio = demod_fmt_2_v4l2_std(
+						broad_std_except_pal_m);
+					pr_err("select the audio mode 0x%x\n",
+						audio);
 				}
 			}
 			pr_err("%s,Auto search freq:%d: std_bk:0x%x ,audmode:0x%x\n",
diff --git a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_frontend.c b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_frontend.c
index afcec18..dd06e24 100644
--- a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_frontend.c
+++ b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_frontend.c
@@ -30,6 +30,7 @@
 #include "atvdemod_func.h"
 #include "../aml_fe.h"
 #include <uapi/linux/dvb/frontend.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 #define ATVDEMOD_DEVICE_NAME                "amlatvdemod"
 #define ATVDEMOD_DRIVER_NAME	"amlatvdemod"
@@ -253,6 +254,8 @@ static int aml_atvdemod_enter_mode(struct aml_fe *fe, int mode)
 		amlatvdemod_devp->pin =
 			devm_pinctrl_get_select(amlatvdemod_devp->dev,
 				amlatvdemod_devp->pin_name);
+	/* printk("\n%s: set atvdemod pll...\n",__func__); */
+	adc_set_pll_cntl(1, 0x1);
 	atvdemod_clk_init();
 	err_code = atvdemod_init();
 	if (err_code) {
@@ -272,6 +275,10 @@ static int aml_atvdemod_leave_mode(struct aml_fe *fe, int mode)
 		devm_pinctrl_put(amlatvdemod_devp->pin);
 		amlatvdemod_devp->pin = NULL;
 	}
+	/* reset adc pll flag */
+	/* printk("\n%s: init atvdemod flag...\n",__func__); */
+	adc_set_pll_cntl(0, 0x1);
+
 	return 0;
 }
 
@@ -580,6 +587,11 @@ static void aml_atvdemod_dt_parse(struct platform_device *pdev)
 			pr_dbg("Can't find  audio_gain_val.\n");
 		else
 			set_audio_gain_val(val);
+		ret = of_property_read_u32(node, "video_gain_val", &val);
+		if (ret)
+			pr_dbg("Can't find  video_gain_val.\n");
+		else
+			set_video_gain_val(val);
 		/* agc pin mux */
 		ret = of_property_read_string(node, "pinctrl-names",
 			&amlatvdemod_devp->pin_name);
diff --git a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.c b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.c
index 31f6eb5..a19d1cd 100644
--- a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.c
+++ b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.c
@@ -43,6 +43,10 @@ static bool non_std_en;
 module_param(non_std_en, bool, 0644);
 MODULE_PARM_DESC(non_std__en, "\n non_std_en\n");
 
+static int atv_video_gain;
+module_param(atv_video_gain, int, 0644);
+MODULE_PARM_DESC(atv_video_gain, "\n atv_video_gain\n");
+
 static int audio_det_mode = AUDIO_AUTO_DETECT;
 module_param(audio_det_mode, int, 0644);
 MODULE_PARM_DESC(audio_det_mode, "\n audio_det_mode\n");
@@ -143,6 +147,7 @@ static unsigned int mix1_freq;
 static unsigned int timer_init_flag;
 struct timer_list atvdemod_timer;
 static int snr_val;
+int broad_std_except_pal_m = 0;
 
 int get_atvdemod_snr_val(void)
 {
@@ -303,6 +308,11 @@ void set_audio_gain_val(int val)
 	audio_gain_val = val;
 }
 
+void set_video_gain_val(int val)
+{
+	atv_video_gain = val;
+}
+
 void atv_dmd_soft_reset(void)
 {
 	atv_dmd_wr_byte(APB_BLOCK_ADDR_SYSTEM_MGT, 0x0, 0x0);
@@ -399,7 +409,10 @@ void atv_dmd_misc(void)
 			atv_dmd_wr_long(0x06, 0x24, 0x0c010801);
 		} else {
 			atv_dmd_wr_long(0x09, 0x00, 0x1030501);
-			atv_dmd_wr_long(0x0f, 0x44, 0xfc0808c1);
+			if (atv_video_gain)
+				atv_dmd_wr_long(0x0f, 0x44, atv_video_gain);
+			else
+				atv_dmd_wr_long(0x0f, 0x44, 0xfc0808c1);
 			atv_dmd_wr_long(0x06, 0x24, 0xc030901);
 		}
 
@@ -1456,16 +1469,56 @@ int atvdemod_clk_init(void)
 {
 	/* clocks_set_hdtv (); */
 	/* 1.set system clock */
-	W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca2a2110);
-	W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x2933800);
-	W_HIU_REG(HHI_ADC_PLL_CNTL, 0xe0644220);
-	W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x34e0bf84);
-	W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a2a2110);
+#if 0 /* now set pll in tvafe_general.c */
+	if (is_meson_txl_cpu()) {
+		amlatvdemod_hiu_reg_write(HHI_VDAC_CNTL0, 0x6e0201);
+		amlatvdemod_hiu_reg_write(HHI_VDAC_CNTL1, 0x8);
+		/* for TXL(T962)  */
+		pr_err("%s in TXL\n", __func__);
+
+		/* W_HIU_REG(HHI_ADC_PLL_CNTL,  0x30c54260); */
+	#if 0
+		W_HIU_REG(HHI_ADC_PLL_CNTL,  0x30f14250);
+		W_HIU_REG(HHI_ADC_PLL_CNTL1, 0x22000442);
+		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x5ba00380);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xac6a2114);
+		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02953004);
+		W_HIU_REG(HHI_ADC_PLL_CNTL5, 0x00030a00);
+		W_HIU_REG(HHI_ADC_PLL_CNTL6, 0x00005000);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x2c6a2114);
+	#else /* get from feijun 2015/07/19 */
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+		W_HIU_REG(HHI_ADC_PLL_CNTL, 0x30f14250);
+		W_HIU_REG(HHI_ADC_PLL_CNTL1, 0x22000442);
+		/*0x5ba00380 from pll;0x5ba00384 clk
+		form crystal*/
+		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x5ba00384);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02913004);
+		W_HIU_REG(HHI_ADC_PLL_CNTL5, 0x00034a00);
+		W_HIU_REG(HHI_ADC_PLL_CNTL6, 0x00005000);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca6a2110);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+	#endif
+		W_HIU_REG(HHI_DADC_CNTL,  0x00102038);
+		W_HIU_REG(HHI_DADC_CNTL2, 0x00000406);
+		W_HIU_REG(HHI_DADC_CNTL3, 0x00082183);
+
+	} else {
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca2a2110);
+		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x2933800);
+		W_HIU_REG(HHI_ADC_PLL_CNTL, 0xe0644220);
+		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x34e0bf84);
+		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a2a2110);
+
+		W_HIU_REG(HHI_ATV_DMD_SYS_CLK_CNTL, 0x80);
+		/* TVFE reset */
+		W_HIU_BIT(RESET1_REGISTER, 1, 7, 1);
+	}
+#endif
 	W_HIU_REG(HHI_ATV_DMD_SYS_CLK_CNTL, 0x80);
-	/* TVFE reset */
-	W_HIU_BIT(RESET1_REGISTER, 1, 7, 1);
 
-	read_version_register();
+	/* read_version_register(); */
 
 	/*2.set atv demod top page control register*/
 	atv_dmd_input_clk_32m();
@@ -1489,29 +1542,8 @@ int atvdemod_init(void)
 			timer_init_flag = 0;
 		}
 	}
-	#if 0
-	/* clocks_set_hdtv (); */
-	/* 1.set system clock */
-	W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca2a2110);
-	W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x2933800);
-	W_HIU_REG(HHI_ADC_PLL_CNTL, 0xe0644220);
-	W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x34e0bf84);
-	W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a2a2110);
-	W_HIU_REG(HHI_ATV_DMD_SYS_CLK_CNTL, 0x80);
-	/* TVFE reset */
-	/*W_HIU_BIT(RESET1_REGISTER, 1, 7, 1);*/
-
-	read_version_register();
 
-	/*2.set atv demod top page control register*/
-	atv_dmd_input_clk_32m();
-	atv_dmd_wr_long(APB_BLOCK_ADDR_TOP, ATV_DMD_TOP_CTRL, 0x1037);
-	atv_dmd_wr_long(APB_BLOCK_ADDR_TOP, (ATV_DMD_TOP_CTRL1 << 2), 0x1f);
-
-	/*3.configure atv demod*/
-	check_communication_interface();
-	power_on_receiver();
-	#endif
+	/* 1.set system clock when atv enter*/
 
 	configure_receiver(broad_std, if_freq, if_inv, gde_curve, sound_format);
 	atv_dmd_misc();
@@ -1742,7 +1774,34 @@ int aml_audiomode_autodet(struct dvb_frontend *fe)
 				__func__, broad_std, carrier_power_average_max);
 			if (carrier_power_average_max < 150)
 				pr_err("%s,carrier too low error\n", __func__);
-
+			if (broad_std == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M) {
+				/*the max except palm*/
+				carrier_power_average[final_id] = 0;
+				final_id = 0;
+				carrier_power_max = carrier_power_average[0];
+				for (i = 0; i < ID_MAX; i++) {
+					if (carrier_power_max
+						< carrier_power_average[i]) {
+						carrier_power_max =
+						carrier_power_average[i];
+						final_id = i;
+					}
+				}
+			switch (final_id) {
+			case ID_PAL_I:
+				broad_std_except_pal_m =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
+				break;
+			case ID_PAL_BG:
+				broad_std_except_pal_m =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
+				break;
+			case ID_PAL_DK:
+				broad_std_except_pal_m =
+					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
+				break;
+			}
+			}
 			if (p != NULL) {
 				p->analog.std = V4L2_COLOR_STD_PAL;
 				switch (broad_std) {
@@ -1905,7 +1964,6 @@ void aml_atvdemod_overmodule_det(void)
 			if (carrier_lock_count >= 1000)
 				return;
 	/* ------------whether need timer delays between the detect lock---- */
-	/* ------------------ */
 		}
 	/* -----------------enable auto_adjust_en------------- */
 		temp_data = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
@@ -1943,8 +2001,6 @@ void aml_atvdemod_overmodule_det(void)
 			carrier_lock_count++;
 			if (carrier_lock_count >= 1000)
 				return;
-	/* ------------whether need timer delays between the detect lock---- */
-	/* -------------------- */
 		}
 
 		/* -----------------begain to set ov_cnt_en enable---- */
diff --git a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.h b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.h
index 45e979b..0c1c9d9 100644
--- a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.h
+++ b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.h
@@ -28,7 +28,7 @@
 extern int atvdemod_debug_en;
 extern struct amlatvdemod_device_s *amlatvdemod_devp;
 extern unsigned int reg_23cf; /* IIR filter */
-
+extern int broad_std_except_pal_m;
 #undef pr_info
 #define pr_info(args...)\
 	do {\
@@ -163,6 +163,7 @@ extern void atv_dmd_wr_byte(unsigned long block_address,
 				unsigned long reg_addr,
 				unsigned long data);
 extern void set_audio_gain_val(int val);
+extern void set_video_gain_val(int val);
 extern void atv_dmd_soft_reset(void);
 extern void atv_dmd_input_clk_32m(void);
 extern void read_version_register(void);
diff --git a/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
index 02160d8..f58b2d4 100644
--- a/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
+++ b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
@@ -95,37 +95,88 @@ static ssize_t dvbc_auto_sym_store(struct class *cls,
 	return 0;
 }
 
-static ssize_t dvbc_para_show(struct class *cls, struct class_attribute *attr,
-			      char *buf)
-{
-/*	struct aml_demod_sts demod_sts;
-	struct aml_demod_i2c demod_i2c;
-	char *pbuf = buf;
-	int strength = 0;
+static unsigned dtmb_mode;
 
-	mutex_lock(&aml_lock);
+enum {
+	DTMB_READ_STRENGTH = 0,
+	DTMB_READ_SNR = 1,
+	DTMB_READ_LOCK = 2,
+	DTMB_READ_BCH = 3,
+};
 
-	dvbc_status(&demod_status, &demod_i2c, &demod_sts);
-	pbuf += sprintf(pbuf, "dvbc_para: ch_sts is %d", demod_sts.ch_sts);
-	pbuf += sprintf(pbuf, "snr %d dB\n", demod_sts.ch_snr / 100);
-	pbuf += sprintf(pbuf, "ber %d", demod_sts.ch_ber);
-	pbuf += sprintf(pbuf, "per %d\n", demod_sts.ch_per);
-	pbuf += sprintf(pbuf, "srate %d", demod_sts.symb_rate);
-	pbuf += sprintf(pbuf, "freqoff %d kHz\n", demod_sts.freq_off);
-	pbuf += sprintf(pbuf, "power is %d db", demod_sts.ch_pow);
-	pbuf += sprintf(pbuf, "tuner strength -%d db", (256 - strength));
-
-	mutex_unlock(&aml_lock);
-
-	return pbuf - buf;*/
-	return 0;
+
+
+int convert_snr(int in_snr)
+{
+	int out_snr;
+	static int calce_snr[40] = {
+		5, 6, 8, 10, 13,
+		16, 20, 25, 32, 40,
+		50, 63, 80, 100, 126,
+		159, 200, 252, 318, 400,
+		504, 634, 798, 1005, 1265,
+		1592, 2005, 2524, 3177, 4000,
+		5036, 6340, 7981, 10048, 12649,
+		15924, 20047, 25238, 31773, 40000};
+	for (out_snr = 1 ; out_snr <= 40; out_snr++)
+		if (in_snr <= calce_snr[out_snr])
+			break;
+
+	return out_snr;
 }
 
-static ssize_t dvbc_para_store(struct class *cls, struct class_attribute *attr,
-			       const char *buf, size_t count)
+
+static ssize_t dtmb_para_show(struct class *cls,
+				  struct class_attribute *attr, char *buf)
 {
+	int snr, lock_status, bch, agc_if_gain;
+	struct dvb_frontend *dvbfe;
+	int strength = 0;
+	if (dtmb_mode == DTMB_READ_STRENGTH) {
+		dvbfe = get_si2177_tuner();
+		if (dvbfe != NULL)
+			if (dvbfe->ops.tuner_ops.get_strength) {
+				strength =
+				dvbfe->ops.tuner_ops.get_strength(dvbfe);
+			}
+		if (strength <= -56) {
+			agc_if_gain =
+				((dtmb_read_reg(DTMB_TOP_FRONT_AGC))&0x3ff);
+			strength = dtmb_get_power_strength(agc_if_gain);
+		}
+		return sprintf(buf, "strength is %d\n", strength);
+	} else if (dtmb_mode == DTMB_READ_SNR) {
+		snr = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) & 0x3fff;
+		snr = convert_snr(snr);
+		return sprintf(buf, "snr is %d\n", snr);
+	} else if (dtmb_mode == DTMB_READ_LOCK) {
+		lock_status =
+			(dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) >> 14) & 0x1;
+		return sprintf(buf, "lock_status is %d\n", lock_status);
+	} else if (dtmb_mode == DTMB_READ_BCH) {
+		bch = dtmb_read_reg(DTMB_TOP_FEC_BCH_ACC);
+		return sprintf(buf, "bch is %d\n", bch);
+	} else {
+		return sprintf(buf, "dtmb_para_show can't match mode\n");
+	}
+}
 
-	return 0;
+
+
+static ssize_t dtmb_para_store(struct class *cls,
+				   struct class_attribute *attr,
+				   const char *buf, size_t count)
+{
+	if (buf[0] == '0')
+		dtmb_mode = DTMB_READ_STRENGTH;
+	else if (buf[0] == '1')
+		dtmb_mode = DTMB_READ_SNR;
+	else if (buf[0] == '2')
+		dtmb_mode = DTMB_READ_LOCK;
+	else if (buf[0] == '3')
+		dtmb_mode = DTMB_READ_BCH;
+
+	return count;
 }
 
 static int readregdata;
@@ -149,7 +200,7 @@ static ssize_t dvbc_reg_store(struct class *cls, struct class_attribute *attr,
 }
 
 static CLASS_ATTR(auto_sym, 0644, dvbc_auto_sym_show, dvbc_auto_sym_store);
-static CLASS_ATTR(dvbc_para, 0644, dvbc_para_show, dvbc_para_store);
+static CLASS_ATTR(dtmb_para, 0644, dtmb_para_show, dtmb_para_store);
 static CLASS_ATTR(dvbc_reg, 0666, dvbc_reg_show, dvbc_reg_store);
 
 #if 0
@@ -892,7 +943,10 @@ static int gxtv_demod_dtmb_read_status
 
 /*      s = amdemod_dtmb_stat_islock(dev);*/
 /*      if(s==1)*/
-	s = dtmb_read_snr(fe);
+	if (is_meson_txl_cpu())
+		s = dtmb_check_status_txl(fe);
+	else
+		s = dtmb_check_status_gxtv(fe);
 	s = amdemod_dtmb_stat_islock(dev);
 /*      s=1;*/
 	if (s == 1) {
@@ -1022,8 +1076,13 @@ int Gxtv_Demod_Dtmb_Init(struct aml_fe_dev *dev)
 	memset(&demod_status, 0, sizeof(demod_status));
 	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
 	demod_status.dvb_mode = Gxtv_Dtmb;
-	sys.adc_clk = Adc_Clk_25M;      /*Adc_Clk_26M;*/
-	sys.demod_clk = Demod_Clk_200M;
+	if (is_meson_txl_cpu()) {
+		sys.adc_clk = Adc_Clk_25M;      /*Adc_Clk_26M;*/
+		sys.demod_clk = Demod_Clk_225M;
+	} else {
+		sys.adc_clk = Adc_Clk_25M;      /*Adc_Clk_26M;*/
+		sys.demod_clk = Demod_Clk_200M;
+	}
 	demod_status.ch_if = Si2176_5M_If;
 	demod_status.tmp = Adc_mode;
 	demod_status.spectrum = dev->spectrum;
@@ -1158,6 +1217,9 @@ static int gxtv_demod_fe_enter_mode(struct aml_fe *fe, int mode)
 	struct aml_fe_dev *dev = fe->dtv_demod;
 	int memstart_dtmb;
 
+	/* must enable the adc ref signal for demod, */
+	vdac_enable(1, 0x2);
+
 	autoFlagsTrig = 1;
 	if (cci_thread)
 		if (dvbc_get_cci_task() == 1)
@@ -1174,15 +1236,12 @@ static int gxtv_demod_fe_enter_mode(struct aml_fe *fe, int mode)
 		Gxtv_Demod_Dvbc_Init(dev, Adc_mode);
 	}
 
-
-	/* must enable the adc ref signal for demod, */
-	vdac_enable(1, 0x2);
-
 	return 0;
 }
 
 static int gxtv_demod_fe_leave_mode(struct aml_fe *fe, int mode)
 {
+	dtvpll_init_flag(0);
 	/*dvbc_timer_exit();*/
 	if (cci_thread)
 		dvbc_kill_cci_task();
@@ -1215,6 +1274,7 @@ static int __init gxtvdemodfrontend_init(void)
 	pr_dbg("register gxtv_demod demod driver\n");
 	ret = 0;
 
+	dtvpll_lock_init();
 	mutex_init(&aml_lock);
 
 	gxtv_clsp = class_create(THIS_MODULE, DEMOD_DEVICE_NAME);
@@ -1226,7 +1286,7 @@ static int __init gxtvdemodfrontend_init(void)
 	if (ret)
 		pr_error("[gxtv demod]%s create class error.\n", __func__);
 
-	ret = class_create_file(gxtv_clsp, &class_attr_dvbc_para);
+	ret = class_create_file(gxtv_clsp, &class_attr_dtmb_para);
 	if (ret)
 		pr_error("[gxtv demod]%s create class error.\n", __func__);
 
@@ -1244,7 +1304,7 @@ static void __exit gxtvdemodfrontend_exit(void)
 	mutex_destroy(&aml_lock);
 
 	class_remove_file(gxtv_clsp, &class_attr_auto_sym);
-	class_remove_file(gxtv_clsp, &class_attr_dvbc_para);
+	class_remove_file(gxtv_clsp, &class_attr_dtmb_para);
 	class_remove_file(gxtv_clsp, &class_attr_dvbc_reg);
 	class_destroy(gxtv_clsp);
 	aml_unregister_fe_drv(AM_DEV_DTV_DEMOD, &gxtv_demod_dtv_demod_drv);
diff --git a/drivers/amlogic/dvb_tv/amldemod/demod_func.c b/drivers/amlogic/dvb_tv/amldemod/demod_func.c
index 24f2d81..4058861 100644
--- a/drivers/amlogic/dvb_tv/amldemod/demod_func.c
+++ b/drivers/amlogic/dvb_tv/amldemod/demod_func.c
@@ -19,7 +19,7 @@
 #define pr_dbg(fmt, args ...) \
 	do { \
 		if (debug_demod) \
-			printk("FE: " fmt, ## args); \
+			pr_info("FE: " fmt, ## args); \
 	} while (0)
 #define pr_error(fmt, args ...) printk("FE: " fmt, ## args)
 
@@ -51,6 +51,8 @@ module_param(demod_enable_performance, int, 0644);
 
 
 static struct mutex mp;
+static struct mutex dtvpll_init_lock;
+static int dtvpll_init;
 static int dtmb_spectrum = 2;
 
 
@@ -312,6 +314,30 @@ static struct atsc_cfg list_qam256[113] = {
 	{0x0000, 0x00, 1}
 };
 
+void dtvpll_lock_init(void)
+{
+	mutex_init(&dtvpll_init_lock);
+}
+
+void dtvpll_init_flag(int on)
+{
+	mutex_lock(&dtvpll_init_lock);
+	dtvpll_init = on;
+	mutex_unlock(&dtvpll_init_lock);
+	pr_err("%s %d\n", __func__, on);
+}
+
+int get_dtvpll_init_flag(void)
+{
+	int val;
+	mutex_lock(&dtvpll_init_lock);
+	val = dtvpll_init;
+	mutex_unlock(&dtvpll_init_lock);
+	if (!val)
+		pr_err("%s: %d\n", __func__, val);
+	return val;
+}
+
 void adc_dpll_setup(int clk_a, int clk_b, int clk_sys)
 {
 	int unit, found, ena, enb, div2;
@@ -358,10 +384,15 @@ void adc_dpll_setup(int clk_a, int clk_b, int clk_sys)
 	pll_n = 1;
 	for (pll_m = 1; pll_m < 512; pll_m++) {
 		/* for (pll_n=1; pll_n<=5; pll_n++) { */
-		freq_dco = freq_osc * pll_m / pll_n;
-		if (freq_dco < 750 * unit || freq_dco > 1550 * unit)
-			continue;
-
+		if (is_meson_txl_cpu()) {
+			freq_dco = freq_osc * pll_m / pll_n / 2;/*txl add div2*/
+			if (freq_dco < 700 * unit || freq_dco > 1000 * unit)
+				continue;
+		} else {
+			freq_dco = freq_osc * pll_m / pll_n;
+			if (freq_dco < 750 * unit || freq_dco > 1550 * unit)
+				continue;
+		}
 		pll_xd_a = freq_dco / (1 << pll_od_a) / freq_a;
 		pll_xd_b = freq_dco / (1 << pll_od_b) / freq_b;
 
@@ -380,9 +411,13 @@ void adc_dpll_setup(int clk_a, int clk_b, int clk_sys)
 		adc_pll_cntl.b.pll_od1 = pll_od_a;
 		adc_pll_cntl.b.pll_xd0 = pll_xd_b;
 		adc_pll_cntl.b.pll_xd1 = pll_xd_a;
-
-		adc_pll_cntl2.b.div2_ctrl = freq_dco > 1000 * unit ? 1 : 0;
-
+		if (is_meson_txl_cpu()) {
+			adc_pll_cntl4.b.pll_od3 = 0;
+			adc_pll_cntl.b.pll_od2 = 0;
+		} else {
+			adc_pll_cntl2.b.div2_ctrl =
+				freq_dco > 1000 * unit ? 1 : 0;
+		}
 		found = 1;
 		best_err = err_tmp;
 		/* } */
@@ -395,7 +430,10 @@ void adc_dpll_setup(int clk_a, int clk_b, int clk_sys)
 	pll_xd_b = adc_pll_cntl.b.pll_xd0;
 	pll_xd_a = adc_pll_cntl.b.pll_xd1;
 
-	div2 = adc_pll_cntl2.b.div2_ctrl;
+	if (is_meson_txl_cpu())
+		div2 = 1;
+	else
+		div2 = adc_pll_cntl2.b.div2_ctrl;
 	/*
 	 * p_adc_pll_cntl  =  adc_pll_cntl.d32;
 	 * p_adc_pll_cntl2 = adc_pll_cntl2.d32;
@@ -403,13 +441,15 @@ void adc_dpll_setup(int clk_a, int clk_b, int clk_sys)
 	 * p_adc_pll_cntl4 = adc_pll_cntl4.d32;
 	 */
 	adc_pll_cntl3.b.reset = 0;
-/* *p_adc_pll_cntl3 = adc_pll_cntl3.d32; */
-
+	/* *p_adc_pll_cntl3 = adc_pll_cntl3.d32; */
 	if (!found) {
 		pr_dbg(" ERROR can't setup %7ld kHz %7ld kHz\n",
 		       freq_b / (unit / 1000), freq_a / (unit / 1000));
 	} else {
-		freq_dco = freq_osc * pll_m / pll_n;
+		if (is_meson_txl_cpu())
+			freq_dco = freq_osc * pll_m / pll_n / 2;
+		else
+			freq_dco = freq_osc * pll_m / pll_n;
 		pr_dbg(" ADC PLL  M %3d   N %3d\n", pll_m, pll_n);
 		pr_dbg(" ADC PLL DCO %ld kHz\n", freq_dco / (unit / 1000));
 
@@ -446,39 +486,68 @@ void adc_dpll_setup(int clk_a, int clk_b, int clk_sys)
 
 		/* *p_demod_dig_clk = dig_clk_cfg.d32; */
 	}
-#ifdef GX_TV
-	demod_set_demod_reg(ADC_RESET_VALUE, ADC_REG3);	/* adc reset */
-	demod_set_demod_reg(adc_pll_cntl.d32, ADC_REG1);
-	/* demod_set_cbus_reg(adc_pll_cntl2.d32, ADC_REG2); */
-	/* demod_set_cbus_reg(adc_pll_cntl3.d32, ADC_REG3); */
-	/* demod_set_cbus_reg(adc_pll_cntl4.d32, ADC_REG4); */
-	/* demod_set_cbus_reg(dig_clk_cfg.d32, ADC_REG6); */
-	demod_set_demod_reg(dig_clk_cfg.d32, ADC_REG6);
-	demod_set_demod_reg(ADC_REG3_VALUE, ADC_REG3);
-	/* debug */
-	pr_dbg("[adc][%x]%x\n", ADC_REG1, demod_read_demod_reg(ADC_REG1));
-	pr_dbg("[adc][%x]%x\n", ADC_REG2, demod_read_demod_reg(ADC_REG2));
-	pr_dbg("[adc][%x]%x\n", ADC_REG3, demod_read_demod_reg(ADC_REG3));
-	pr_dbg("[adc][%x]%x\n", ADC_REG4, demod_read_demod_reg(ADC_REG4));
-	pr_dbg("[adc][%x]%x\n", ADC_REG6, demod_read_demod_reg(ADC_REG6));
-	pr_dbg("[demod][%x]%x\n", DEMOD_REG1, demod_read_demod_reg(DEMOD_REG1));
-	pr_dbg("[demod][%x]%x\n", DEMOD_REG2, demod_read_demod_reg(DEMOD_REG2));
-	pr_dbg("[demod][%x]%x\n", DEMOD_REG3, demod_read_demod_reg(DEMOD_REG3));
-#else
-	demod_set_cbus_reg(ADC_RESET_VALUE, ADC_REG3);	/* adc reset */
-	demod_set_cbus_reg(adc_pll_cntl.d32, ADC_REG1);
-	demod_set_cbus_reg(dig_clk_cfg.d32, ADC_REG6);
-	demod_set_cbus_reg(ADC_REG3_VALUE, ADC_REG3);
-	/* debug */
-	pr_dbg("[adc][%x]%x\n", ADC_REG1, demod_read_cbus_reg(ADC_REG1));
-	pr_dbg("[adc][%x]%x\n", ADC_REG2, demod_read_cbus_reg(ADC_REG2));
-	pr_dbg("[adc][%x]%x\n", ADC_REG3, demod_read_cbus_reg(ADC_REG3));
-	pr_dbg("[adc][%x]%x\n", ADC_REG4, demod_read_cbus_reg(ADC_REG4));
-	pr_dbg("[adc][%x]%x\n", ADC_REG6, demod_read_cbus_reg(ADC_REG6));
-	pr_dbg("[demod][%x]%x\n", DEMOD_REG1, demod_read_demod_reg(DEMOD_REG1));
-	pr_dbg("[demod][%x]%x\n", DEMOD_REG2, demod_read_demod_reg(DEMOD_REG2));
-	pr_dbg("[demod][%x]%x\n", DEMOD_REG3, demod_read_demod_reg(DEMOD_REG3));
-#endif
+	if (is_meson_txl_cpu()) {
+		demod_set_demod_reg(TXLTV_ADC_RESET_VALUE, ADC_REG3);
+		demod_set_demod_reg(adc_pll_cntl.d32, ADC_REG1);
+		demod_set_demod_reg(dig_clk_cfg.d32, ADC_REG6);
+		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
+		/* debug */
+		pr_dbg("[adc][%x]%x\n", ADC_REG1,
+				demod_read_demod_reg(ADC_REG1));
+		pr_dbg("[adc][%x]%x\n", ADC_REG2,
+				demod_read_demod_reg(ADC_REG2));
+		pr_dbg("[adc][%x]%x\n", ADC_REG3,
+				demod_read_demod_reg(ADC_REG3));
+		pr_dbg("[adc][%x]%x\n", ADC_REG4,
+				demod_read_demod_reg(ADC_REG4));
+		pr_dbg("[adc][%x]%x\n", ADC_REG5,
+				demod_read_demod_reg(ADC_REG5));
+		pr_dbg("[adc][%x]%x\n", ADC_REG6,
+				demod_read_demod_reg(ADC_REG6));
+		pr_dbg("[adc][%x]%x\n", ADC_REG7,
+				demod_read_demod_reg(ADC_REG7));
+		pr_dbg("[adc][%x]%x\n", ADC_REG8,
+				demod_read_demod_reg(ADC_REG8));
+		pr_dbg("[adc][%x]%x\n", ADC_REG9,
+				demod_read_demod_reg(ADC_REG9));
+		pr_dbg("[adc][%x]%x\n", ADC_REGB,
+				demod_read_demod_reg(ADC_REGB));
+		pr_dbg("[adc][%x]%x\n", ADC_REGC,
+				demod_read_demod_reg(ADC_REGC));
+		pr_dbg("[adc][%x]%x\n", ADC_REGD,
+				demod_read_demod_reg(ADC_REGD));
+		pr_dbg("[adc][%x]%x\n", ADC_REGE,
+				demod_read_demod_reg(ADC_REGE));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG1,
+				demod_read_demod_reg(DEMOD_REG1));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG2,
+				demod_read_demod_reg(DEMOD_REG2));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG3,
+				demod_read_demod_reg(DEMOD_REG3));
+	} else {
+		demod_set_demod_reg(ADC_RESET_VALUE, ADC_REG3);	/* adc reset */
+		demod_set_demod_reg(adc_pll_cntl.d32, ADC_REG1);
+		demod_set_demod_reg(dig_clk_cfg.d32, ADC_REG6);
+		demod_set_demod_reg(ADC_REG3_VALUE, ADC_REG3);
+		/* debug */
+		pr_dbg("[adc][%x]%x\n", ADC_REG1,
+				demod_read_demod_reg(ADC_REG1));
+		pr_dbg("[adc][%x]%x\n", ADC_REG2,
+				demod_read_demod_reg(ADC_REG2));
+		pr_dbg("[adc][%x]%x\n", ADC_REG3,
+				demod_read_demod_reg(ADC_REG3));
+		pr_dbg("[adc][%x]%x\n", ADC_REG4,
+				demod_read_demod_reg(ADC_REG4));
+		pr_dbg("[adc][%x]%x\n", ADC_REG6,
+				demod_read_demod_reg(ADC_REG6));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG1,
+				demod_read_demod_reg(DEMOD_REG1));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG2,
+				demod_read_demod_reg(DEMOD_REG2));
+		pr_dbg("[demod][%x]%x\n", DEMOD_REG3,
+				demod_read_demod_reg(DEMOD_REG3));
+	}
+	dtvpll_init_flag(1);
 }
 
 void demod_set_adc_core_clk(int adc_clk, int sys_clk, int dvb_mode)
@@ -577,14 +646,11 @@ void demod_power_switch(int pwr_cntl)
 		demod_set_demod_reg((demod_read_demod_reg(RESET0_LEVEL) &
 				     (~(0x1 << 8))), RESET0_LEVEL);
 	/*	msleep(20);*/
-#ifdef GX_TV
+
 		/* remove isolation */
-		demod_set_ao_reg((demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) &
+			demod_set_ao_reg(
+				(demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) &
 				  (~(0x3 << 14))), AO_RTI_GEN_PWR_ISO0);
-#else
-		demod_set_ao_reg((demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) &
-				  (~(0x3 << 12))), AO_RTI_GEN_PWR_ISO0);
-#endif
 		/* pull up reset */
 		demod_set_demod_reg((demod_read_demod_reg(RESET0_LEVEL) |
 				     (0x1 << 8)), RESET0_LEVEL);
@@ -592,13 +658,11 @@ void demod_power_switch(int pwr_cntl)
 	} else {
 		pr_dbg("[PWR]: Power off demod_comp\n");
 		/* add isolation */
-#ifdef GX_TV
-		demod_set_ao_reg((demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) |
+
+			demod_set_ao_reg(
+				(demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) |
 				  (0x3 << 14)), AO_RTI_GEN_PWR_ISO0);
-#else
-		demod_set_ao_reg((demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) |
-				  (0x3 << 12)), AO_RTI_GEN_PWR_ISO0);
-#endif
+
 		/* power down memory */
 		demod_set_demod_reg((demod_read_demod_reg(HHI_DEMOD_MEM_PD_REG)
 			 | 0x2fff), HHI_DEMOD_MEM_PD_REG);
@@ -617,19 +681,39 @@ static void clocks_set_sys_defaults(unsigned char dvb_mode)
 	union demod_cfg2 cfg2;
 
 	demod_power_switch(PWR_ON);
-#ifdef GX_TV
-	pr_dbg("GX_TV config\n");
-	demod_set_demod_reg(ADC_RESET_VALUE, ADC_REG3);	/* adc reset */
-	demod_set_demod_reg(ADC_REG1_VALUE, ADC_REG1);
-	demod_set_demod_reg(ADC_REG2_VALUE, ADC_REG2);
-	demod_set_demod_reg(ADC_REG4_VALUE, ADC_REG4);
-	demod_set_demod_reg(ADC_REG3_VALUE, ADC_REG3);
-	/* dadc */
-	demod_set_demod_reg(ADC_REG7_VALUE, ADC_REG7);
-	demod_set_demod_reg(ADC_REG8_VALUE, ADC_REG8);
-	demod_set_demod_reg(ADC_REG9_VALUE, ADC_REG9);
-	demod_set_demod_reg(ADC_REGA_VALUE, ADC_REGA);
-#endif
+
+	if (is_meson_gxtvbb_cpu()) {
+		pr_dbg("GX_TV config\n");
+		demod_set_demod_reg(ADC_RESET_VALUE, ADC_REG3);
+		demod_set_demod_reg(ADC_REG1_VALUE, ADC_REG1);
+		demod_set_demod_reg(ADC_REG2_VALUE, ADC_REG2);
+		demod_set_demod_reg(ADC_REG4_VALUE, ADC_REG4);
+		demod_set_demod_reg(ADC_REG3_VALUE, ADC_REG3);
+		/* dadc */
+		demod_set_demod_reg(ADC_REG7_VALUE, ADC_REG7);
+		demod_set_demod_reg(ADC_REG8_VALUE, ADC_REG8);
+		demod_set_demod_reg(ADC_REG9_VALUE, ADC_REG9);
+		demod_set_demod_reg(ADC_REGA_VALUE, ADC_REGA);
+	} else if (is_meson_txl_cpu()) {
+		pr_dbg("TXL_TV config\n");
+		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
+		demod_set_demod_reg(TXLTV_ADC_REG1_VALUE, ADC_REG1);
+		demod_set_demod_reg(TXLTV_ADC_REGB_VALUE, ADC_REGB);
+		demod_set_demod_reg(TXLTV_ADC_REG2_VALUE, ADC_REG2);
+		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
+		demod_set_demod_reg(TXLTV_ADC_REG4_VALUE, ADC_REG4);
+		demod_set_demod_reg(TXLTV_ADC_REGC_VALUE, ADC_REGC);
+		demod_set_demod_reg(TXLTV_ADC_REGD_VALUE, ADC_REGD);
+		demod_set_demod_reg(TXLTV_ADC_RESET_VALUE, ADC_REG3);
+		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
+
+		/* dadc */
+		demod_set_demod_reg(TXLTV_ADC_REG7_VALUE, ADC_REG7);
+		demod_set_demod_reg(TXLTV_ADC_REG8_VALUE, ADC_REG8);
+		demod_set_demod_reg(TXLTV_ADC_REG9_VALUE, ADC_REG9);
+		demod_set_demod_reg(TXLTV_ADC_REGE_VALUE, ADC_REGE);
+	}
+
 	demod_set_demod_reg(DEMOD_REG1_VALUE, DEMOD_REG1);
 	demod_set_demod_reg(DEMOD_REG2_VALUE, DEMOD_REG2);
 	demod_set_demod_reg(DEMOD_REG3_VALUE, DEMOD_REG3);
@@ -653,17 +737,23 @@ static void clocks_set_sys_defaults(unsigned char dvb_mode)
 
 void dtmb_write_reg(int reg_addr, int reg_data)
 {
+	if (!get_dtvpll_init_flag())
+		return;
 	demod_set_demod_reg(reg_data, reg_addr);
 /* apb_write_reg(reg_addr,reg_data); */
 }
 
 int dtmb_read_reg(int reg_addr)
 {
+	if (!get_dtvpll_init_flag())
+		return 0;
 	return demod_read_demod_reg(reg_addr);	/* apb_read_reg(reg_addr); */
 }
 
 void atsc_write_reg(int reg_addr, int reg_data)
 {
+	if (!get_dtvpll_init_flag())
+		return;
 	apb_write_reg(ATSC_BASE, (reg_addr & 0xffff) << 8 | (reg_data & 0xff));
 }
 
@@ -671,6 +761,8 @@ unsigned long atsc_read_reg(int reg_addr)
 {
 	unsigned long tmp;
 
+	if (!get_dtvpll_init_flag())
+		return 0;
 	apb_write_reg(ATSC_BASE + 4, (reg_addr & 0xffff) << 8);
 	tmp = apb_read_reg(ATSC_BASE);
 
@@ -907,67 +999,55 @@ static dtmb_cfg_t list_dtmb_v1[99] = {
 
 void dtmb_all_reset(void)
 {
-	int temp_data;
-/* union DTMB_FRONT_AFIFO_ADC_BITS afifo_adc; */
-/* afifo_adc.d32=dtmb_read_reg(DTMB_FRONT_AFIFO_ADC); */
-/* afifo_adc.b.afifo_data_format = 1;// 1,2 is complement;0 is offset binary */
-/* dtmb_write_reg(DTMB_FRONT_AFIFO_ADC,afifo_adc.d32); */
-	/* improve agc wave 47080137 */
-/* dtmb_write_reg(DTMB_FRONT_DEBUG_CFG,0xf00000); */
-/* dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG7,0xb39ab3cd); */
-	dtmb_write_reg(DTMB_FRONT_AGC_CONFIG1, 0x10127);
-	dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG6, 0x943228cc);
-	dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG7, 0xc09aa8cd);
-	dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, 0x0);
-	dtmb_write_reg(DTMB_CHE_EQ_CONFIG, 0x9dc59);/*snr avg ,0x269dc59*/
-	/*0x2 is auto,0x406 is  invert spectrum*/
-	if (dtmb_spectrum == 0)
-		dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x406);
-	else if (dtmb_spectrum == 1)
-		dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x402);
-	else
-		dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x2);
-
-	pr_dbg("dtmb_spectrum is %d\n", dtmb_spectrum);
-	dtmb_write_reg(DTMB_TOP_CTRL_FEC, 0x41444400);
-	dtmb_write_reg(DTMB_TOP_CTRL_INTLV_TIME, 0x180300);
-	dtmb_write_reg(DTMB_FRONT_DDC_BYPASS, 0x662ca0);
-	dtmb_write_reg(DTMB_FRONT_AFIFO_ADC, 0x29);
-	dtmb_write_reg(DTMB_FRONT_DC_HOLD, 0xa1066);
-	/*cci para*/
-	dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG3, 0x80201f6);
-	dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG2, 0x3f20080);
-	dtmb_write_reg(DTMB_CHE_TPS_CONFIG, 0xc00000);
-	dtmb_write_reg(DTMB_TOP_CTRL_AGC, 0x3);
-	dtmb_write_reg(DTMB_TOP_CTRL_TS_SFO_CFO, 0x20403006);
-	dtmb_write_reg(DTMB_FRONT_AGC_CONFIG2, 0x7200a16);
-	dtmb_write_reg(DTMB_FRONT_DEBUG_CFG, 0x1e00000);
-	dtmb_write_reg(DTMB_TOP_CTRL_ENABLE, 0x7fffff);
-	/*close ts3 timing loop*/
-	dtmb_write_reg(DTMB_TOP_CTRL_DAGC_CCI, 0x305);
-	if (demod_enable_performance) {
-		dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG1, 0x4040002);
-		temp_data = dtmb_read_reg(DTMB_CHE_FD_TD_COEFF);
-	    temp_data = (temp_data & ~0x3fff)|(0x241f & 0x3fff);
-	    temp_data = temp_data | (1<<21);
-		/*Set freeze_mode and reset coeff*/
-	    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
-	    temp_data = temp_data & ~(1<<21);
-		/*Set freeze_mode and reset coeff*/
-	    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
-
-
-		#if 0
-		/*Set freeze_mode and reset coeff*/
-		dtmb_write_reg(DTMB_CHE_FD_COEFF_FRZ, 0xf000000f);
-	    temp_data = dtmb_read_reg(DTMB_CHE_FD_TD_COEFF);
-	    temp_data = temp_data | (1<<24);
-		/*reset coeff*/
-	    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
-	    temp_data = temp_data & ~(1<<24);
-		/*reset coeff*/
-	    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
-		#endif
+	int temp_data = 0;
+	if (is_meson_txl_cpu()) {
+		dtmb_write_reg(DTMB_FRONT_AFIFO_ADC, 0x1f);
+		dtmb_write_reg(DTMB_CHE_TPS_CONFIG, 0xc00000);
+		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG1, 0x101a7);
+	} else {
+		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG1, 0x10127);
+		dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG6, 0x943228cc);
+		dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG7, 0xc09aa8cd);
+		dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, 0x0);
+		dtmb_write_reg(DTMB_CHE_EQ_CONFIG, 0x9dc59);
+		/*0x2 is auto,0x406 is  invert spectrum*/
+		if (dtmb_spectrum == 0)
+			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x406);
+		else if (dtmb_spectrum == 1)
+			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x402);
+		else
+			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x2);
+
+		pr_dbg("dtmb_spectrum is %d\n", dtmb_spectrum);
+		dtmb_write_reg(DTMB_TOP_CTRL_FEC, 0x41444400);
+		dtmb_write_reg(DTMB_TOP_CTRL_INTLV_TIME, 0x180300);
+		dtmb_write_reg(DTMB_FRONT_DDC_BYPASS, 0x662ca0);
+		dtmb_write_reg(DTMB_FRONT_AFIFO_ADC, 0x29);
+		dtmb_write_reg(DTMB_FRONT_DC_HOLD, 0xa1066);
+		/*cci para*/
+		dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG3, 0x80201f6);
+		dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG2, 0x3f20080);
+		dtmb_write_reg(DTMB_CHE_TPS_CONFIG, 0xc00000);
+		dtmb_write_reg(DTMB_TOP_CTRL_AGC, 0x3);
+		dtmb_write_reg(DTMB_TOP_CTRL_TS_SFO_CFO, 0x20403006);
+		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG2, 0x7200a16);
+		dtmb_write_reg(DTMB_FRONT_DEBUG_CFG, 0x1e00000);
+		dtmb_write_reg(DTMB_TOP_CTRL_ENABLE, 0x7fffff);
+		/*close ts3 timing loop*/
+		dtmb_write_reg(DTMB_TOP_CTRL_DAGC_CCI, 0x305);
+		/*dektec card issue,close f case snr drop*/
+		dtmb_write_reg(DTMB_CHE_MC_SC_TIMING_POWTHR, 0xc06100a);
+		if (demod_enable_performance) {
+			dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG1, 0x4040002);
+			temp_data = dtmb_read_reg(DTMB_CHE_FD_TD_COEFF);
+		    temp_data = (temp_data & ~0x3fff)|(0x241f & 0x3fff);
+		    temp_data = temp_data | (1<<21);
+			/*Set freeze_mode and reset coeff*/
+		    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
+		    temp_data = temp_data & ~(1<<21);
+			/*Set freeze_mode and reset coeff*/
+		    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
+		}
 	}
 }
 
@@ -1159,7 +1239,7 @@ int dtmb_v3_soft_sync(int cfo_init)
 
 }
 
-int dtmb_read_snr(struct dvb_frontend *fe)
+int dtmb_check_status_gxtv(struct dvb_frontend *fe)
 {
 	int local_state;
 	int time_cnt;/* cci_det, src_config;*/
@@ -1232,6 +1312,14 @@ int dtmb_read_snr(struct dvb_frontend *fe)
 	return 0;
 }
 
+
+int dtmb_check_status_txl(struct dvb_frontend *fe)
+{
+	dtmb_information();
+	return 0;
+}
+
+
 void dtmb_reset(void)
 {
 	union DTMB_TOP_CTRL_SW_RST_BITS sw_rst;
@@ -1356,6 +1444,8 @@ int demod_set_sys(struct aml_demod_sta *demod_sta,
 /* demod_sta->tmp=Adc_mode; */
 	unsigned char dvb_mode;
 	int clk_adc, clk_dem;
+	int gpioDV_2;
+	int gpiW_2;
 
 	dvb_mode = demod_sta->dvb_mode;
 	clk_adc = demod_sys->adc_clk;
@@ -1366,10 +1456,22 @@ int demod_set_sys(struct aml_demod_sta *demod_sta,
 	mutex_init(&mp);
 	clocks_set_sys_defaults(dvb_mode);
 	/* open dtv adc pinmux */
-/* demod_set_cbus_reg(0x10000,0x2034); */
-	demod_set_demod_reg(0x2c0f07e, 0xc88344c4);
-
-	pr_dbg("[R840]set adc pinmux\n");
+	if (is_meson_txl_cpu()) {
+		gpioDV_2 = demod_read_demod_reg(0xc8834400 + (0x2e << 2));
+		pr_dbg("[R840]set adc pinmux,gpioDV_2 %x\n", gpioDV_2);
+		gpioDV_2 = gpioDV_2 | (0x1 << 22);
+		gpioDV_2 = gpioDV_2 & ~(0x3 << 19);
+		gpioDV_2 = gpioDV_2 & ~(0x1 << 23);
+		gpioDV_2 = gpioDV_2 & ~(0x1 << 31);
+		demod_set_demod_reg(gpioDV_2, 0xc8834400 + (0x2e << 2));
+		pr_dbg("[R840]set adc pinmux,gpioDV_2 %x\n", gpioDV_2);
+	} else {
+		gpiW_2 = demod_read_demod_reg(0xc88344c4);
+		gpiW_2 = gpiW_2 | (0x1 << 25);
+		gpiW_2 = gpiW_2 & ~(0xd << 24);
+		demod_set_demod_reg(gpiW_2, 0xc88344c4);
+		pr_dbg("[R840]set adc pinmux,gpiW_2 %x\n", gpiW_2);
+	}
 	/* set adc clk */
 	demod_set_adc_core_clk(clk_adc, clk_dem, dvb_mode);
 	/* init for dtmb */
@@ -1384,22 +1486,32 @@ int demod_set_sys(struct aml_demod_sta *demod_sta,
 
 void demod_set_reg(struct aml_demod_reg *demod_reg)
 {
-	if (demod_reg->mode == 0) {
+	switch (demod_reg->mode) {
+	case 0:
 		demod_reg->addr = demod_reg->addr + QAM_BASE;
-	} else if ((demod_reg->mode == 1) || ((demod_reg->mode == 2))) {
+		break;
+	case 1:
+	case 2:
 		demod_reg->addr = DTMB_TOP_ADDR(demod_reg->addr);
-	} else if (demod_reg->mode == 3) {
+		break;
+	case 3:
 		/* demod_reg->addr=ATSC_BASE; */
-	} else if (demod_reg->mode == 4) {
+		break;
+	case 4:
 		demod_reg->addr = demod_reg->addr * 4 + DEMOD_CFG_BASE;
-	} else if (demod_reg->mode == 5) {
+		break;
+	case 5:
 		demod_reg->addr = demod_reg->addr + DEMOD_BASE;
-	} else if (demod_reg->mode == 6) {
+		break;
+	case 6:
 		/* demod_reg->addr=demod_reg->addr*4+DEMOD_CFG_BASE; */
-	} else if (demod_reg->mode == 11) {
+		break;
+	case 11:
 		demod_reg->addr = demod_reg->addr;
-	} else if (demod_reg->mode == 10) {
+		break;
+	case 10:
 		/* demod_reg->addr=(u32_t)phys_to_virt(demod_reg->addr); */
+		break;
 	}
 
 	if (demod_reg->mode == 3)
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/amlfrontend.h b/drivers/amlogic/dvb_tv/amldemod/include/amlfrontend.h
index 0062d4a..0114306 100644
--- a/drivers/amlogic/dvb_tv/amldemod/include/amlfrontend.h
+++ b/drivers/amlogic/dvb_tv/amldemod/include/amlfrontend.h
@@ -49,6 +49,7 @@ enum Gxtv_Demod_Dvb_Mode {
 #define Demod_Clk_100M    100000	/*  */
 #define Demod_Clk_180M    180000	/*  */
 #define Demod_Clk_200M    200000	/*  */
+#define Demod_Clk_225M    225000
 
 #define Adc_Clk_27M                     27777	/* atsc */
 #define Demod_Clk_83M     83333	/*  */
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/demod_func.h b/drivers/amlogic/dvb_tv/amldemod/include/demod_func.h
index 42fb5ce..4587b09 100644
--- a/drivers/amlogic/dvb_tv/amldemod/include/demod_func.h
+++ b/drivers/amlogic/dvb_tv/amldemod/include/demod_func.h
@@ -61,7 +61,48 @@
 #define ATSC_BASE  (DEMOD_BASE + 0x800)
 #define DEMOD_CFG_BASE  (DEMOD_BASE + 0xC00)
 
-#ifdef G9_TV
+/* #ifdef TXL_TV */
+#define TXLTV_ADC_RESET_VALUE          0xca6a2110	/* 0xce7a2110 */
+#define TXLTV_ADC_REG1_VALUE           0x5d414260
+#define TXLTV_ADC_REG2_VALUE           0x5ba00384	/* 0x34e0bf81 */
+#define TXLTV_ADC_REG2_VALUE_CRY       0x34e0bf81
+#define TXLTV_ADC_REG3_VALUE           0x4a6a2110	/* 0x4e7a2110 */
+#define TXLTV_ADC_REG4_VALUE           0x02913004
+#define TXLTV_ADC_REG4_CRY_VALUE 0x301
+#define TXLTV_ADC_REG7_VALUE           0x00102038
+#define TXLTV_ADC_REG8_VALUE           0x00000406
+#define TXLTV_ADC_REG9_VALUE           0x00082183
+#define TXLTV_ADC_REGA_VALUE           0x80480240
+#define TXLTV_ADC_REGB_VALUE           0x22000442
+#define TXLTV_ADC_REGC_VALUE           0x00034a00
+#define TXLTV_ADC_REGD_VALUE           0x00005000
+#define TXLTV_ADC_REGE_VALUE           0x00000200
+
+
+/* DADC DPLL */
+#define ADC_REG1         (IO_HIU_BASE + (0xaa << 2))
+#define ADC_REG2         (IO_HIU_BASE + (0xab << 2))
+#define ADC_REG3         (IO_HIU_BASE + (0xac << 2))
+#define ADC_REG4         (IO_HIU_BASE + (0xad << 2))
+
+#define ADC_REG5         (IO_HIU_BASE + (0x73 << 2))
+#define ADC_REG6         (IO_HIU_BASE + (0x74 << 2))
+
+#define ADC_REGB         (IO_HIU_BASE + (0xaf << 2))
+#define ADC_REGC         (IO_HIU_BASE + (0x9e << 2))
+#define ADC_REGD         (IO_HIU_BASE + (0x9f << 2))
+
+/* DADC REG */
+#define ADC_REG7         (IO_HIU_BASE + (0x27 << 2))
+#define ADC_REG8         (IO_HIU_BASE + (0x28 << 2))
+#define ADC_REG9         (IO_HIU_BASE + (0x2a << 2))
+#define ADC_REGA         (IO_HIU_BASE + (0x2b << 2))
+#define ADC_REGE         (IO_HIU_BASE + (0xbd << 2))
+
+/* #endif  */
+
+
+/* #ifdef GX_TV */
 
 #define ADC_RESET_VALUE          0x8a2a2110	/* 0xce7a2110 */
 #define ADC_REG1_VALUE           0x00100228
@@ -74,24 +115,25 @@
 #define ADC_REG8_VALUE           0x00000000
 #define ADC_REG9_VALUE           0x00430036
 #define ADC_REGA_VALUE           0x80480240
-
+#if 0
 /* DADC DPLL */
-#define ADC_REG1         0x10aa
-#define ADC_REG2         0x10ab
-#define ADC_REG3         0x10ac
-#define ADC_REG4         0x10ad
+#define ADC_REG1         (IO_HIU_BASE + (0xaa << 2))
+#define ADC_REG2         (IO_HIU_BASE + (0xab << 2))
+#define ADC_REG3         (IO_HIU_BASE + (0xac << 2))
+#define ADC_REG4         (IO_HIU_BASE + (0xad << 2))
 
-#define ADC_REG5         0x1073
-#define ADC_REG6         0x1074
+#define ADC_REG5         (IO_HIU_BASE + (0x73 << 2))
+#define ADC_REG6         (IO_HIU_BASE + (0x74 << 2))
 
 /* DADC REG */
-#define ADC_REG7         0x1027
-#define ADC_REG8         0x1028
-#define ADC_REG9         0x102a
-#define ADC_REGA         0x102b
+#define ADC_REG7         (IO_HIU_BASE + (0x27 << 2))
+#define ADC_REG8         (IO_HIU_BASE + (0x28 << 2))
+#define ADC_REG9         (IO_HIU_BASE + (0x2a << 2))
+#define ADC_REGA         (IO_HIU_BASE + (0x2b << 2))
 #endif
+/* #endif */
 
-#ifdef GX_TV
+#ifdef G9_TV
 
 #define ADC_RESET_VALUE          0x8a2a2110	/* 0xce7a2110 */
 #define ADC_REG1_VALUE           0x00100228
@@ -106,20 +148,19 @@
 #define ADC_REGA_VALUE           0x80480240
 
 /* DADC DPLL */
-#define ADC_REG1         (IO_HIU_BASE + (0xaa << 2))
-#define ADC_REG2         (IO_HIU_BASE + (0xab << 2))
-#define ADC_REG3         (IO_HIU_BASE + (0xac << 2))
-#define ADC_REG4         (IO_HIU_BASE + (0xad << 2))
+#define ADC_REG1         0x10aa
+#define ADC_REG2         0x10ab
+#define ADC_REG3         0x10ac
+#define ADC_REG4         0x10ad
 
-#define ADC_REG5         (IO_HIU_BASE + (0x73 << 2))
-#define ADC_REG6         (IO_HIU_BASE + (0x74 << 2))
+#define ADC_REG5         0x1073
+#define ADC_REG6         0x1074
 
 /* DADC REG */
-#define ADC_REG7         (IO_HIU_BASE + (0x27 << 2))
-#define ADC_REG8         (IO_HIU_BASE + (0x28 << 2))
-#define ADC_REG9         (IO_HIU_BASE + (0x2a << 2))
-#define ADC_REGA         (IO_HIU_BASE + (0x2b << 2))
-
+#define ADC_REG7         0x1027
+#define ADC_REG8         0x1028
+#define ADC_REG9         0x102a
+#define ADC_REGA         0x102b
 #endif
 
 #ifdef M6_TV
@@ -206,6 +247,8 @@ int get_fj2207_ch_power(void);
 int tuner_get_ch_power(struct aml_fe_dev *adap);
 int tda18273_tuner_set_frequncy(unsigned int dwFrequency,
 				unsigned int dwStandard);
+int dtmb_get_power_strength(int agc_gain);
+
 
 int tuner_set_ch(struct aml_demod_sta *demod_sta,
 		 struct aml_demod_i2c *demod_i2c);
@@ -275,7 +318,9 @@ int dtmb_set_ch(struct aml_demod_sta *demod_sta,
 
 void dtmb_reset(void);
 
-int dtmb_read_snr(struct dvb_frontend *fe);
+int dtmb_check_status_gxtv(struct dvb_frontend *fe);
+int dtmb_check_status_txl(struct dvb_frontend *fe);
+
 
 void dtmb_write_reg(int reg_addr, int reg_data);
 int dtmb_read_reg(int reg_addr);
@@ -546,7 +591,8 @@ struct dtmb_cfg {
 	int rw;
 };
 
-
+void dtvpll_lock_init(void);
+void dtvpll_init_flag(int on);
 void demod_set_irq_mask(void);
 void demod_clr_irq_stat(void);
 void demod_set_adc_core_clk(int, int, int);
diff --git a/drivers/amlogic/dvb_tv/amldemod/tuner_func.c b/drivers/amlogic/dvb_tv/amldemod/tuner_func.c
index 00b321f..20df299 100644
--- a/drivers/amlogic/dvb_tv/amldemod/tuner_func.c
+++ b/drivers/amlogic/dvb_tv/amldemod/tuner_func.c
@@ -7,14 +7,18 @@
 int tuner_get_ch_power(struct aml_fe_dev *adap)
 {
 	int strength = 0;
+	int agc_if_gain;
 
 	struct dvb_frontend *dvbfe;
 	dvbfe = get_si2177_tuner();
 	if (dvbfe != NULL)
 		if (dvbfe->ops.tuner_ops.get_strength)
 			strength = dvbfe->ops.tuner_ops.get_strength(dvbfe);
-	if (strength <= 0)
-		strength = 0-strength;
+	if (strength <= -56) {
+		agc_if_gain =
+			((dtmb_read_reg(DTMB_TOP_FRONT_AGC))&0x3ff);
+		strength = dtmb_get_power_strength(agc_if_gain);
+	 }
 
 	return strength;
 }
@@ -143,3 +147,23 @@ int agc_power_to_dbm(int agc_gain, int ad_power, int offset, int tuner)
 
 	return est_rf_power;
 }
+
+int dtmb_get_power_strength(int agc_gain)
+{
+	int strength;
+	int j;
+	static int calcE_R840[13] = {
+		1010, 969, 890, 840, 800,
+		760, 720, 680, 670, 660,
+		510, 440, 368};
+	for (j = 0; j < sizeof(calcE_R840)/sizeof(int); j++)
+		if (agc_gain >= calcE_R840[j])
+			break;
+	if (agc_gain >= 440)
+		strength = -90+j*3;
+	else
+		strength = -56;
+	return strength;
+}
+
+
diff --git a/drivers/amlogic/dvb_tv/c_stb_regs_define.h b/drivers/amlogic/dvb_tv/c_stb_regs_define.h
index be3819a..2612fa6 100644
--- a/drivers/amlogic/dvb_tv/c_stb_regs_define.h
+++ b/drivers/amlogic/dvb_tv/c_stb_regs_define.h
@@ -1069,6 +1069,19 @@
 #define HHI_GP_PLL_CNTL5 0x1014
 #define P_HHI_GP_PLL_CNTL5              CBUS_REG_ADDR(HHI_GP_PLL_CNTL5)
 /**/
+
+#define HHI_DADC_CNTL				0x1027
+#define P_HHI_DADC_CNTL             CBUS_REG_ADDR(HHI_DADC_CNTL)
+#define HHI_DADC_CNTL2				0x1028
+#define P_HHI_DADC_CNTL2             CBUS_REG_ADDR(HHI_DADC_CNTL2)
+#define HHI_DADC_RDBK0_I			0x1029
+#define P_HHI_DADC_RDBK0_I             CBUS_REG_ADDR(HHI_DADC_RDBK0_I)
+#define HHI_DADC_CNTL3				0x102a
+#define P_HHI_DADC_CNTL3             CBUS_REG_ADDR(HHI_DADC_CNTL3)
+#define HHI_DADC_CNTL4				0x102b
+#define P_HHI_DADC_CNTL4             CBUS_REG_ADDR(HHI_DADC_CNTL4)
+
+
 #define HARM_ASB_MB0 0x1030
 #define P_HARM_ASB_MB0          CBUS_REG_ADDR(HARM_ASB_MB0)
 #define HARM_ASB_MB1 0x1031
@@ -1260,14 +1273,24 @@
 #define P_HHI_MPLL_CNTL9                CBUS_REG_ADDR(HHI_MPLL_CNTL9)
 #define HHI_MPLL_CNTL10 0x10a9
 #define P_HHI_MPLL_CNTL10               CBUS_REG_ADDR(HHI_MPLL_CNTL10)
-#define HHI_ADC_PLL_CNTL 0x10aa
-#define P_HHI_ADC_PLL_CNTL              CBUS_REG_ADDR(HHI_ADC_PLL_CNTL)
-#define HHI_ADC_PLL_CNTL2 0x10ab
-#define P_HHI_ADC_PLL_CNTL2             CBUS_REG_ADDR(HHI_ADC_PLL_CNTL2)
-#define HHI_ADC_PLL_CNTL3 0x10ac
-#define P_HHI_ADC_PLL_CNTL3             CBUS_REG_ADDR(HHI_ADC_PLL_CNTL3)
-#define HHI_ADC_PLL_CNTL4 0x10ad
-#define P_HHI_ADC_PLL_CNTL4             CBUS_REG_ADDR(HHI_ADC_PLL_CNTL4)
+
+
+#define HHI_ADC_PLL_CNTL			0x10aa
+#define P_HHI_ADC_PLL_CNTL			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL)
+#define HHI_ADC_PLL_CNTL2			0x10ab
+#define P_HHI_ADC_PLL_CNTL2			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL2)
+#define HHI_ADC_PLL_CNTL3			0x10ac
+#define P_HHI_ADC_PLL_CNTL3			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL3)
+#define HHI_ADC_PLL_CNTL4			0x10ad
+#define P_HHI_ADC_PLL_CNTL4			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL4)
+#define HHI_ADC_PLL_CNTL5			0x109e
+#define P_HHI_ADC_PLL_CNTL5			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL5)
+#define HHI_ADC_PLL_CNTL6			0x109f
+#define P_HHI_ADC_PLL_CNTL6			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL6)
+#define HHI_ADC_PLL_CNTL1			0x10af
+#define P_HHI_ADC_PLL_CNTL1			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL1)
+
+
 #define HHI_AUDCLK_PLL_CNTL 0x10b0
 #define P_HHI_AUDCLK_PLL_CNTL           CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL)
 #define HHI_AUDCLK_PLL_CNTL2 0x10b1
diff --git a/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c b/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
index 21d20f5..352cc5f 100644
--- a/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
+++ b/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
@@ -1201,55 +1201,389 @@ void check_detail_fmt(void)
 	}
 }
 
+/* Recommended N and Expected CTS for 32kHz */
 struct hdmi_audio_fs_ncts aud_32k_para = {
 	.array[0] = {
-	.tmds_clk = 25174,
-	.n = 4576,
-	.cts = 28125,
+		.tmds_clk = 25175,
+		.n = 4576,
+		.cts = 28125,
+		.n_36bit = 9152,
+		.cts_36bit = 84375,
+		.n_48bit = 4576,
+		.cts_48bit = 56250,
 	},
 	.array[1] = {
-	.tmds_clk = 74176,
-	.n = 11648,
-	.cts = 210937,
+		.tmds_clk = 25200,
+		.n = 4096,
+		.cts = 25200,
+		.n_36bit = 4096,
+		.cts_36bit = 37800,
+		.n_48bit = 4096,
+		.cts_48bit = 50400,
 	},
 	.array[2] = {
-	.tmds_clk = 148352,
-	.n = 11648,
-	.cts = 421875,
+		.tmds_clk = 27000,
+		.n = 4096,
+		.cts = 27000,
+		.n_36bit = 4096,
+		.cts_36bit = 40500,
+		.n_48bit = 4096,
+		.cts_48bit = 54000,
 	},
 	.array[3] = {
-	.tmds_clk = 296703,
-	.n = 5824,
-	.cts = 421875,
+		.tmds_clk = 27027,
+		.n = 4096,
+		.cts = 27027,
+		.n_36bit = 8192,
+		.cts_36bit = 81081,
+		.n_48bit = 4096,
+		.cts_48bit = 54054,
 	},
 	.array[4] = {
-	.tmds_clk = 297000,
-	.n = 3072,
-	.cts = 222750,
+		.tmds_clk = 54000,
+		.n = 4096,
+		.cts = 54000,
+		.n_36bit = 4096,
+		.cts_36bit = 81000,
+		.n_48bit = 4096,
+		.cts_48bit = 108000,
+	},
+	.array[5] = {
+		.tmds_clk = 54054,
+		.n = 4096,
+		.cts = 54054,
+		.n_36bit = 4096,
+		.cts_36bit = 81081,
+		.n_48bit = 4096,
+		.cts_48bit = 108108,
+	},
+	.array[6] = {
+		.tmds_clk = 74176,
+		.n = 11648,
+		.cts = 210937,
+		.n_36bit = 11648,
+		.cts_36bit = 316406,
+		.n_48bit = 11648,
+		.cts_48bit = 421875,
+	},
+	.array[7] = {
+		.tmds_clk = 74250,
+		.n = 4096,
+		.cts = 74250,
+		.n_36bit = 4096,
+		.cts_36bit = 111375,
+		.n_48bit = 4096,
+		.cts_48bit = 148500,
+	},
+	.array[8] = {
+		.tmds_clk = 148352,
+		.n = 11648,
+		.cts = 421875,
+		.n_36bit = 11648,
+		.cts_36bit = 632812,
+		.n_48bit = 11648,
+		.cts_48bit = 843750,
+	},
+	.array[9] = {
+		.tmds_clk = 148500,
+		.n = 4096,
+		.cts = 148500,
+		.n_36bit = 4096,
+		.cts_36bit = 222750,
+		.n_48bit = 4096,
+		.cts_48bit = 297000,
+	},
+	.array[10] = {
+		.tmds_clk = 296703,
+		.n = 5824,
+		.cts = 421875,
+	},
+	.array[11] = {
+		.tmds_clk = 297000,
+		.n = 3072,
+		.cts = 222750,
 	},
 	.def_n = 4096,
 };
 
+/* Recommended N and Expected CTS for 44.1kHz and Multiples */
+struct hdmi_audio_fs_ncts aud_44k1_para = {
+	.array[0] = {
+		.tmds_clk = 25175,
+		.n = 7007,
+		.cts = 31250,
+		.n_36bit = 7007,
+		.cts_36bit = 46875,
+		.n_48bit = 7007,
+		.cts_48bit = 62500,
+	},
+	.array[1] = {
+		.tmds_clk = 25200,
+		.n = 6272,
+		.cts = 28000,
+		.n_36bit = 6272,
+		.cts_36bit = 42000,
+		.n_48bit = 6272,
+		.cts_48bit = 56000,
+	},
+	.array[2] = {
+		.tmds_clk = 27000,
+		.n = 6272,
+		.cts = 30000,
+		.n_36bit = 6272,
+		.cts_36bit = 45000,
+		.n_48bit = 6272,
+		.cts_48bit = 60000,
+	},
+	.array[3] = {
+		.tmds_clk = 27027,
+		.n = 6272,
+		.cts = 30030,
+		.n_36bit = 6272,
+		.cts_36bit = 45045,
+		.n_48bit = 6272,
+		.cts_48bit = 60060,
+	},
+	.array[4] = {
+		.tmds_clk = 54000,
+		.n = 6272,
+		.cts = 60000,
+		.n_36bit = 6272,
+		.cts_36bit = 90000,
+		.n_48bit = 6272,
+		.cts_48bit = 120000,
+	},
+	.array[5] = {
+		.tmds_clk = 54054,
+		.n = 6272,
+		.cts = 60060,
+		.n_36bit = 6272,
+		.cts_36bit = 90090,
+		.n_48bit = 6272,
+		.cts_48bit = 120120,
+	},
+	.array[6] = {
+		.tmds_clk = 74176,
+		.n = 17836,
+		.cts = 234375,
+		.n_36bit = 17836,
+		.cts_36bit = 351562,
+		.n_48bit = 17836,
+		.cts_48bit = 468750,
+	},
+	.array[7] = {
+		.tmds_clk = 74250,
+		.n = 6272,
+		.cts = 82500,
+		.n_36bit = 6272,
+		.cts_36bit = 123750,
+		.n_48bit = 6272,
+		.cts_48bit = 165000,
+	},
+	.array[8] = {
+		.tmds_clk = 148352,
+		.n = 8918,
+		.cts = 234375,
+		.n_36bit = 17836,
+		.cts_36bit = 703125,
+		.n_48bit = 8918,
+		.cts_48bit = 468750,
+	},
+	.array[9] = {
+		.tmds_clk = 148500,
+		.n = 6272,
+		.cts = 165000,
+		.n_36bit = 6272,
+		.cts_36bit = 247500,
+		.n_48bit = 6272,
+		.cts_48bit = 330000,
+	},
+	.array[10] = {
+		.tmds_clk = 296703,
+		.n = 4459,
+		.cts = 234375,
+	},
+	.array[11] = {
+		.tmds_clk = 297000,
+		.n = 4707,
+		.cts = 247500,
+	},
+	.def_n = 6272,
+};
+
+/* Recommended N and Expected CTS for 48kHz and Multiples */
+struct hdmi_audio_fs_ncts aud_48k_para = {
+	.array[0] = {
+		.tmds_clk = 25175,
+		.n = 6864,
+		.cts = 28125,
+		.n_36bit = 9152,
+		.cts_36bit = 58250,
+		.n_48bit = 6864,
+		.cts_48bit = 56250,
+	},
+	.array[1] = {
+		.tmds_clk = 25200,
+		.n = 6144,
+		.cts = 25200,
+		.n_36bit = 6144,
+		.cts_36bit = 37800,
+		.n_48bit = 6144,
+		.cts_48bit = 50400,
+	},
+	.array[2] = {
+		.tmds_clk = 27000,
+		.n = 6144,
+		.cts = 27000,
+		.n_36bit = 6144,
+		.cts_36bit = 40500,
+		.n_48bit = 6144,
+		.cts_48bit = 54000,
+	},
+	.array[3] = {
+		.tmds_clk = 27027,
+		.n = 6144,
+		.cts = 27027,
+		.n_36bit = 8192,
+		.cts_36bit = 54054,
+		.n_48bit = 6144,
+		.cts_48bit = 54054,
+	},
+	.array[4] = {
+		.tmds_clk = 54000,
+		.n = 6144,
+		.cts = 54000,
+		.n_36bit = 6144,
+		.cts_36bit = 81000,
+		.n_48bit = 6144,
+		.cts_48bit = 108000,
+	},
+	.array[5] = {
+		.tmds_clk = 54054,
+		.n = 6144,
+		.cts = 54054,
+		.n_36bit = 6144,
+		.cts_36bit = 81081,
+		.n_48bit = 6144,
+		.cts_48bit = 108108,
+	},
+	.array[6] = {
+		.tmds_clk = 74176,
+		.n = 11648,
+		.cts = 140625,
+		.n_36bit = 11648,
+		.cts_36bit = 210937,
+		.n_48bit = 11648,
+		.cts_48bit = 281250,
+	},
+	.array[7] = {
+		.tmds_clk = 74250,
+		.n = 6144,
+		.cts = 74250,
+		.n_36bit = 6144,
+		.cts_36bit = 111375,
+		.n_48bit = 6144,
+		.cts_48bit = 148500,
+	},
+	.array[8] = {
+		.tmds_clk = 148352,
+		.n = 5824,
+		.cts = 140625,
+		.n_36bit = 11648,
+		.cts_36bit = 421875,
+		.n_48bit = 5824,
+		.cts_48bit = 281250,
+	},
+	.array[9] = {
+		.tmds_clk = 148500,
+		.n = 6144,
+		.cts = 148500,
+		.n_36bit = 6144,
+		.cts_36bit = 222750,
+		.n_48bit = 6144,
+		.cts_48bit = 297000,
+	},
+	.array[10] = {
+		.tmds_clk = 296703,
+		.n = 5824,
+		.cts = 281250,
+	},
+	.array[11] = {
+		.tmds_clk = 297000,
+		.n = 5120,
+		.cts = 247500,
+	},
+	.def_n = 6144,
+};
+
 static struct hdmi_audio_fs_ncts *all_aud_paras[] = {
-	NULL,
 	&aud_32k_para,
+	&aud_44k1_para,
+	&aud_48k_para,
+	NULL,
 };
 
-unsigned int hdmi_get_aud_n_paras(enum hdmi_audio_fs fs, unsigned int tmds_clk)
+unsigned int hdmi_get_aud_n_paras(enum hdmi_audio_fs fs,
+	enum hdmi_color_depth cd, unsigned int tmds_clk)
 {
 	struct hdmi_audio_fs_ncts *p = NULL;
-	unsigned int i;
-
-	p = all_aud_paras[fs];
+	unsigned int i, n;
+	unsigned int N_multiples = 1;
+
+	pr_info("hdmitx: fs = %d, cd = %d, tmds_clk = %d\n", fs, cd, tmds_clk);
+	switch (fs) {
+	case FS_32K:
+		p = all_aud_paras[0];
+		N_multiples = 1;
+		break;
+	case FS_44K1:
+		p = all_aud_paras[1];
+		N_multiples = 1;
+		break;
+	case FS_88K2:
+		p = all_aud_paras[1];
+		N_multiples = 2;
+		break;
+	case FS_176K4:
+		p = all_aud_paras[1];
+		N_multiples = 4;
+		break;
+	case FS_48K:
+		p = all_aud_paras[2];
+		N_multiples = 1;
+		break;
+	case FS_96K:
+		p = all_aud_paras[2];
+		N_multiples = 2;
+		break;
+	case FS_192K:
+		p = all_aud_paras[2];
+		N_multiples = 4;
+		break;
+	default: /* Default as FS_48K */
+		p = all_aud_paras[2];
+		N_multiples = 1;
+		break;
+	}
 	for (i = 0; i < AUDIO_PARA_MAX_NUM; i++) {
 		if (tmds_clk == p->array[i].tmds_clk)
 			break;
 	}
 
-	if ((i < AUDIO_PARA_MAX_NUM) && (p->array[i].n))
-		return p->array[i].n;
+	if (i < AUDIO_PARA_MAX_NUM)
+		if ((cd == COLORDEPTH_24B) || (cd == COLORDEPTH_30B))
+			n = p->array[i].n ? p->array[i].n : p->def_n;
+		else if (cd == COLORDEPTH_36B)
+			n = p->array[i].n_36bit ?
+				p->array[i].n_36bit : p->def_n;
+		else if (cd == COLORDEPTH_48B)
+			n = p->array[i].n_48bit ?
+				p->array[i].n_48bit : p->def_n;
+		else
+			n = p->array[i].n ? p->array[i].n : p->def_n;
 	else
-		return p->def_n;
+		n = p->def_n;
+	return n * N_multiples;
 }
 /*--------------------------------------------------------------*/
 /* for csc coef */
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
index b644961..625aa19 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
@@ -1179,7 +1179,7 @@ static void hdcp22_hw_init(void)
 {
 	hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 1, 7, 1);
 	hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG1, 0x7);
-	hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG0, 0x73);
+	hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG0, 0x53);
 	hd_set_reg_bits(P_HHI_GCLK_MPEG2, 1, 3, 1);
 	hd_write_reg(P_HHI_HDCP22_CLK_CNTL, 0x01000100);
 	/* Enable skpclk to HDCP2.2 IP */
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
index 4724366..d4fdcb5 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
@@ -69,6 +69,7 @@
 #define EDID_DETAILED_TIMING_DES_BLOCK3_POS 0x6C
 
 static unsigned char __nosavedata edid_checkvalue[4] = {0};
+static unsigned int hdmitx_edid_check_valid_blocks(unsigned char *buf);
 
 static void edid_save_checkvalue(unsigned char *buf, unsigned int block_cnt)
 {
@@ -1749,6 +1750,10 @@ int hdmitx_edid_parse(struct hdmitx_dev *hdmitx_device)
 	hdmitx_device->tmp_buf[i] = 0;
 	hdmi_print(0, "\n");
 #endif
+	if (!hdmitx_edid_check_valid_blocks(&EDID_buf[0])) {
+		pRXCap->IEEEOUI = 0x0c03;
+		pr_info("hdmitx: Invalid edid, consider RX as HDMI device\n");
+	}
 	/* update RX HDR information */
 	info = get_current_vinfo();
 	if (info) {
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c
index 417411f..4c283ca 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c
@@ -86,20 +86,16 @@ static struct timer_list hdcp_monitor_timer;
 static void hdcp_monitor_func(unsigned long arg)
 {
 	/* static int hdcp_auth_flag = 0; */
-	struct hdmitx_dev *hdmitx_device =
-		(struct hdmitx_dev *)hdcp_monitor_timer.data;
-	if ((hdmitx_device->HWOp.Cntl) && (hdmitx_device->log &
-		(HDMI_LOG_HDCP))) {
-		hdmitx_device->HWOp.Cntl(hdmitx_device,
-		HDMITX_HDCP_MONITOR, 1);
-	}
+	struct hdmitx_dev *hdev = (struct hdmitx_dev *)hdcp_monitor_timer.data;
+	if ((hdev->HWOp.Cntl) && (hdev->log & (HDMI_LOG_HDCP)))
+		hdev->HWOp.Cntl(hdev, HDMITX_HDCP_MONITOR, 1);
 
 	mod_timer(&hdcp_monitor_timer, jiffies + 2 * HZ);
 }
 
 static int hdmitx_hdcp_task(void *data)
 {
-	struct hdmitx_dev *hdmitx_device = (struct hdmitx_dev *)data;
+	struct hdmitx_dev *hdev = (struct hdmitx_dev *)data;
 
 	init_timer(&hdcp_monitor_timer);
 	hdcp_monitor_timer.data = (ulong) data;
@@ -107,9 +103,10 @@ static int hdmitx_hdcp_task(void *data)
 	hdcp_monitor_timer.expires = jiffies + HZ;
 	add_timer(&hdcp_monitor_timer);
 
-	while (hdmitx_device->hpd_event != 0xff) {
-		hdmi_authenticated = hdmitx_device->HWOp.CntlDDC(
-			hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+	while (hdev->hpd_event != 0xff) {
+		hdmi_authenticated = hdev->HWOp.CntlDDC(hdev,
+			DDC_HDCP_GET_AUTH, 0);
+		switch_set_state(&hdcp_dev, hdmi_authenticated);
 		msleep_interruptible(200);
 	}
 
@@ -118,18 +115,18 @@ static int hdmitx_hdcp_task(void *data)
 
 static int __init hdmitx_hdcp_init(void)
 {
-	struct hdmitx_dev *hdmitx_device = get_hdmitx_device();
+	struct hdmitx_dev *hdev = get_hdmitx_device();
 
 	hdmi_print(IMP, SYS "hdmitx_hdcp_init\n");
-	if (hdmitx_device->hdtx_dev == NULL) {
+	if (hdev->hdtx_dev == NULL) {
 		hdmi_print(IMP, SYS "exit for null device of hdmitx!\n");
 		return -ENODEV;
 	}
 
 	switch_dev_register(&hdcp_dev);
 
-	hdmitx_device->task_hdcp = kthread_run(hdmitx_hdcp_task,
-		(void *)hdmitx_device, "kthread_hdcp");
+	hdev->task_hdcp = kthread_run(hdmitx_hdcp_task,	(void *)hdev,
+		"kthread_hdcp");
 
 	return 0;
 }
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
index 75b1a60..76d9f31 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
@@ -82,8 +82,8 @@ static int edid_rx_ext_data(unsigned char *ext, unsigned char regaddr,
 static void gpio_read_edid(unsigned char *rx_edid);
 static void hdmitx_get_edid(struct hdmitx_dev *hdev);
 static void hdmitx_set_drm_pkt(struct master_display_info_s *data);
+static int check_fbc_special(unsigned char *edid_dat);
 static int hdcp_tst_sig;
-static void hdmitx_rxsense_process(struct hdmitx_dev *hdev);
 
 #ifndef CONFIG_AM_TV_OUTPUT
 /* Fake vinfo */
@@ -117,10 +117,6 @@ static struct switch_dev sdev = { /* android ics switch device */
 static struct switch_dev hdmi_power = { /* android ics switch device */
 	.name = "hdmi_power",
 };
-static struct switch_dev hdmi_rxsense = {
-	.name = "hdmi_rxsense",
-};
-
 static int edid_read_flag __nosavedata;
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -261,7 +257,6 @@ static int hdmi_480p_force_clk; /* 200, 225, 250, 270 */
 static int hdmi_detect_when_booting = 1;
 /* 1: error  2: important  3: normal  4: detailed */
 static int debug_level = INF;
-static int hdmitx_param_rxsen = 1; /* default as disabled for rx sense*/
 
 /*****************************
 *	hdmitx attr management :
@@ -626,58 +621,6 @@ static unsigned char is_dispmode_valid_for_hdmi(void)
 	return vic != HDMI_Unkown;
 }
 
-/*------------------------------------------------------------------*/
-/* rx sense feature */
-
-static unsigned long time_point;
-static void time_base_reset(void)
-{
-	time_point = jiffies;
-	return;
-}
-
-static int time_expired(unsigned long period)
-{
-	if (time_after_eq(jiffies, time_point+period)) {
-		time_point = jiffies;
-		return 1;
-	}
-
-	return 0;
-}
-
-static void hdmitx_rxsense_update(struct hdmitx_dev *hdev)
-{
-	int sense;
-
-	if (hdev && hdev->HWOp.CntlMisc) {
-		sense = hdev->HWOp.CntlMisc(hdev, MISC_TMDS_RXSENSE, 0);
-		sense = (sense == 0)?0:1;
-		hdev->rxsense_state = sense;
-		if (sense != hdmi_rxsense.state)
-			switch_set_state(&hdmi_rxsense, sense);
-	}
-}
-
-static void hdmitx_rxsense_process(struct hdmitx_dev *hdev)
-{
-	static unsigned int sense_enable = 1;
-
-	if (hdev->hpd_state == 1)
-		sense_enable = 1;
-
-	if (time_expired(HZ) && (sense_enable == 1)) {
-		hdmitx_rxsense_update(hdev);
-		if (hdev->hpd_state == 0)
-			sense_enable = 0;
-	}
-
-	return;
-}
-
-
-/*------------------------------------------------------------------*/
-
 /*disp_mode attr*/
 static ssize_t show_disp_mode(struct device *dev,
 	struct device_attribute *attr, char *buf)
@@ -1132,16 +1075,6 @@ static ssize_t store_config(struct device *dev,
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
 			hdmitx_device.HWOp.SetPacket(HDMI_PACKET_DRM,
 				DRM_DB, DRM_HB);
-	} else if (strncmp(buf, "rxsen", 5) == 0) {
-		if (strncmp(buf+6, "get", 3) == 0) {
-			hdmi_print(INF, "RxSense: %d, %s\n",
-				hdmitx_device.rxsense_state,
-				(hdmitx_device.rxsense_state == 0)?"0V":"3.3V");
-		} else if (strncmp(buf+6, "start", 5) == 0) {
-			hdmitx_param_rxsen = 1;
-		} else if (strncmp(buf+6, "stop", 4) == 0) {
-			hdmitx_param_rxsen = 0;
-		}
 	}
 	return 16;
 }
@@ -1617,6 +1550,28 @@ static ssize_t store_hdcp_lstore(struct device *dev,
 	return count;
 }
 
+static unsigned int div40 = -1;
+static ssize_t show_div40(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+
+	if (div40 != -1)
+		pos += snprintf(buf + pos, PAGE_SIZE, "%d\n", div40);
+
+	return pos;
+}
+
+static ssize_t store_div40(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct hdmitx_dev *hdev = &hdmitx_device;
+
+	hdev->HWOp.CntlDDC(hdev, DDC_SCDC_DIV40_SCRAMB, buf[0] == '1');
+	div40 = (buf[0] == '1');
+
+	return count;
+}
 
 static ssize_t show_hdcp_mode(struct device *dev,
 	struct device_attribute *attr, char *buf)
@@ -1725,11 +1680,31 @@ static ssize_t show_hdcp_ksv_info(struct device *dev,
 	return pos;
 }
 
+/* Special FBC check */
+static int check_fbc_special(unsigned char *edid_dat)
+{
+	if ((edid_dat[250] == 0xfb) && (edid_dat[251] == 0x0c))
+		return 1;
+	else
+		return 0;
+}
+
 static ssize_t show_hdcp_ver(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	int pos = 0;
-	uint32_t ver;
+	uint32_t ver = 0;
+
+	if (check_fbc_special(&hdmitx_device.EDID_buf[0])
+	    || check_fbc_special(&hdmitx_device.EDID_buf1[0])) {
+		pos += snprintf(buf+pos, PAGE_SIZE, "00\n\r");
+		return pos;
+	}
+
+	/* if TX don't have HDCP22 key, skip RX hdcp22 ver */
+	if (hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
+		DDC_HDCP_22_LSTORE, 0) == 0)
+		goto next;
 
 	/* Detect RX support HDCP22 */
 	ver = hdcp_rd_hdcp22_ver();
@@ -1738,12 +1713,14 @@ static ssize_t show_hdcp_ver(struct device *dev,
 		pos += snprintf(buf+pos, PAGE_SIZE, "14\n\r");
 		return pos;
 	}
-	/* Detect RX support HDCP14 */
+next:	/* Detect RX support HDCP14 */
 	/* Here, must assume RX support HDCP14, otherwise affect 1A-03 */
 	if (ver == 0) {
+#if 0 /* No need BKSV any more */
 		ver = hdcp_rd_hdcp14_ver();
 		if (ver == 0)
 			pr_info("hdmitx: rx don't support HDCP14???\n");
+#endif
 		pos += snprintf(buf+pos, PAGE_SIZE, "14\n\r");
 		return pos;
 	}
@@ -1837,6 +1814,7 @@ static DEVICE_ATTR(hdcp_mode, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_mode,
 	store_hdcp_mode);
 static DEVICE_ATTR(hdcp_lstore, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_lstore,
 	store_hdcp_lstore);
+static DEVICE_ATTR(div40, S_IWUSR | S_IRUGO | S_IWGRP, show_div40, store_div40);
 static DEVICE_ATTR(hdcp_ctrl, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_ctrl,
 	store_hdcp_ctrl);
 static DEVICE_ATTR(disp_cap_3d, S_IRUGO, show_disp_cap_3d, NULL);
@@ -2136,9 +2114,13 @@ static void hdmitx_get_edid(struct hdmitx_dev *hdev)
 
 static int get_downstream_hdcp_ver(void)
 {
+	/* if TX don't have HDCP22 key, skip RX hdcp22 ver */
+	if (hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
+		DDC_HDCP_22_LSTORE, 0) == 0)
+		goto next;
 	if (hdcp_rd_hdcp22_ver())
 		return 22;
-	if (hdcp_rd_hdcp14_ver())
+next:	if (hdcp_rd_hdcp14_ver())
 		return 14;
 	return 0;
 }
@@ -2152,12 +2134,18 @@ void hdmitx_hpd_plugin_handler(struct work_struct *work)
 
 	if (!(hdev->hdmitx_event & (HDMI_TX_HPD_PLUGIN)))
 		return;
-	pr_info("hdmitx: plugin\n");
 	mutex_lock(&setclk_mutex);
+	pr_info("hdmitx: plugin\n");
+	hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGIN;
 	/* start reading E-EDID */
 	hdev->hpd_state = 1;
 	rx_repeat_hpd_state(1);
 	hdmitx_get_edid(hdev);
+	if (check_fbc_special(&hdev->EDID_buf[0])
+		|| check_fbc_special(&hdev->EDID_buf1[0]))
+		rx_set_repeater_support(0);
+	else
+		rx_set_repeater_support(1);
 	rx_repeat_hdcp_ver(get_downstream_hdcp_ver());
 	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_GET_BKSV,
 		(unsigned long int)bksv_buf);
@@ -2165,10 +2153,7 @@ void hdmitx_hpd_plugin_handler(struct work_struct *work)
 	set_disp_mode_auto();
 	hdmitx_set_audio(hdev, &(hdev->cur_audio_param), hdmi_ch);
 	switch_set_state(&sdev, 1);
-	if (hdmitx_param_rxsen != 0)
-		hdmitx_rxsense_update(hdev);
 
-	hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGIN;
 	mutex_unlock(&setclk_mutex);
 }
 
@@ -2192,11 +2177,17 @@ void hdmitx_hpd_plugout_handler(struct work_struct *work)
 
 	if (!(hdev->hdmitx_event & (HDMI_TX_HPD_PLUGOUT)))
 		return;
-	time_base_reset();
 	hdev->hdcp_mode = 0;
 	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_MUX_INIT, 1);
 	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_OP, HDCP14_OFF);
 	mutex_lock(&setclk_mutex);
+	pr_info("hdmitx: plugout\n");
+	if (!!(hdev->HWOp.CntlMisc(hdev, MISC_HPD_GPI_ST, 0))) {
+		pr_info("hdmitx: hpd gpi high\n");
+		hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGOUT;
+		mutex_unlock(&setclk_mutex);
+		return;
+	}
 	hdev->ready = 0;
 	hdev->hpd_state = 0;
 	rx_repeat_hpd_state(0);
@@ -2204,7 +2195,7 @@ void hdmitx_hpd_plugout_handler(struct work_struct *work)
 	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_MUX_INIT, 1);
 	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_OP, HDCP14_OFF);
 	hdev->HWOp.CntlMisc(hdev, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
-	pr_info("hdmitx: plugout\n");
+	hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGOUT;
 	hdev->HWOp.CntlMisc(hdev, MISC_ESM_RESET, 0);
 	if (hdev->gpio_i2c_enable) {
 		edid_read_flag = 0;
@@ -2215,7 +2206,6 @@ void hdmitx_hpd_plugout_handler(struct work_struct *work)
 	hdmitx_edid_clear(hdev);
 	hdmitx_edid_ram_buffer_clear(hdev);
 	switch_set_state(&sdev, 0);
-	hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGOUT;
 	mutex_unlock(&setclk_mutex);
 }
 
@@ -2287,14 +2277,6 @@ static int hdmi_task_handle(void *data)
 		HDMITX_HWCMD_MUX_HPD_IF_PIN_HIGH, 0);
 
 	hdmitx_device->HWOp.SetupIRQ(hdmitx_device);
-
-	while (1) {
-		if (hdmitx_param_rxsen != 0)
-			hdmitx_rxsense_process(hdmitx_device);
-
-		msleep_interruptible(200);
-	}
-
 	return 0;
 }
 
@@ -2674,6 +2656,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	ret = device_create_file(dev, &dev_attr_hdcp_byp);
 	ret = device_create_file(dev, &dev_attr_hdcp_mode);
 	ret = device_create_file(dev, &dev_attr_hdcp_lstore);
+	ret = device_create_file(dev, &dev_attr_div40);
 	ret = device_create_file(dev, &dev_attr_hdcp_ctrl);
 	ret = device_create_file(dev, &dev_attr_hpd_state);
 	ret = device_create_file(dev, &dev_attr_ready);
@@ -2816,11 +2799,6 @@ static int amhdmitx_probe(struct platform_device *pdev)
 
 	hdmitx_init_parameters(&hdmitx_device.hdmi_info);
 	HDMITX_Meson_Init(&hdmitx_device);
-
-	if (hdmitx_param_rxsen == 1) {
-		switch_dev_register(&hdmi_rxsense);
-	}
-
 	hdmitx_device.task = kthread_run(hdmi_task_handle,
 		&hdmitx_device, "kthread_hdmi");
 
@@ -2840,7 +2818,6 @@ static int amhdmitx_remove(struct platform_device *pdev)
 	struct device *dev = hdmitx_device.hdtx_dev;
 	switch_dev_unregister(&sdev);
 	switch_dev_unregister(&hdmi_power);
-	switch_dev_unregister(&hdmi_rxsense);
 
 	if (hdmitx_device.HWOp.UnInit)
 		hdmitx_device.HWOp.UnInit(&hdmitx_device);
@@ -2874,6 +2851,7 @@ static int amhdmitx_remove(struct platform_device *pdev)
 	device_remove_file(dev, &dev_attr_vic);
 	device_remove_file(dev, &dev_attr_hdcp_pwr);
 	device_remove_file(dev, &dev_attr_aud_output_chs);
+	device_remove_file(dev, &dev_attr_div40);
 
 	cdev_del(&hdmitx_device.cdev);
 
@@ -3196,7 +3174,3 @@ module_param(hdmi_prbs_mode, int, 0664);
 
 MODULE_PARM_DESC(debug_level, "\n debug_level\n");
 module_param(debug_level, int, 0664);
-
-MODULE_PARM_DESC(hdmitx_param_rxsen, "\n hdmitx_param_rxsen\n");
-module_param(hdmitx_param_rxsen, int, 0664);
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c
index d49f3bc..258d9e0 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c
@@ -26,9 +26,6 @@ static void tmds_config(unsigned long arg)
 	struct hdmitx_dev *hdev = (struct hdmitx_dev *)arg;
 	uint8_t st = 0;
 
-	hdev = hdev; /* prevent warning, TODO used */
-	scdc_wr_sink(SOURCE_VER, 0x1);
-	scdc_wr_sink(SOURCE_VER, 0x1);
 	/* TMDS 1/40 & Scramble */
 	scdc_wr_sink(TMDS_CFG, hdev->para->tmds_clk_div40 ? 0x3 : 0);
 	scdc_wr_sink(TMDS_CFG, hdev->para->tmds_clk_div40 ? 0x3 : 0);
@@ -39,7 +36,7 @@ static void tmds_config(unsigned long arg)
 		return;
 	} else {
 		if ((hdev->para->tmds_clk_div40) && (cnt < 3))
-			mod_timer(&scdc_tmds_cfg_timer, jiffies + HZ);
+			mod_timer(&scdc_tmds_cfg_timer, jiffies + HZ / 2);
 		else
 			cnt = 0;
 	}
@@ -54,11 +51,10 @@ void scdc_config(void *hdev)
 		init_timer(&scdc_tmds_cfg_timer);
 		scdc_tmds_cfg_timer.data = (ulong)hdev;
 		scdc_tmds_cfg_timer.function = tmds_config;
-		scdc_tmds_cfg_timer.expires = jiffies + HZ;
+		scdc_tmds_cfg_timer.expires = jiffies;
 		add_timer(&scdc_tmds_cfg_timer);
 		return;
 	}
-	scdc_tmds_cfg_timer.expires = jiffies + HZ;
-	mod_timer(&scdc_tmds_cfg_timer, jiffies + HZ);
+	mod_timer(&scdc_tmds_cfg_timer, jiffies);
 }
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
index f5c9f7d..5cb3010 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
@@ -648,6 +648,12 @@ int hdmitx_set_display(struct hdmitx_dev *hdmitx_device,
 			default:
 				break;
 			}
+			if (param->color == COLORSPACE_RGB444) {
+				hdmitx_device->para->cs =
+					hdmitx_device->cur_video_param->color;
+				pr_info("hdmitx: rx edid only support RGB format\n");
+			}
+
 		}
 		if (hdmitx_device->HWOp.SetDispMode(hdmitx_device) >= 0) {
 			/* HDMI CT 7-33 DVI Sink, no HDMI VSDB nor any
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_ddc.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_ddc.c
index 6b024fd..ac0557d 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_ddc.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_ddc.c
@@ -191,11 +191,11 @@ uint32_t hdcp_rd_hdcp22_ver(void)
 	hdmitx_ddc_hw_op(DDC_MUX_DDC);
 	ret = ddc_read_1byte(HDCP_SLAVE, HDCP2_VERSION, &ver);
 	if (ret)
-		return ver;
+		return ver == 0x04;
 	else {
 		ret = ddc_read_1byte(HDCP_SLAVE, HDCP2_VERSION, &ver);
 		if (ret)
-			return ver;
+			return ver == 0x04;
 	}
 
 	return 0;
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
index 457c3e3..eb2a260 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
@@ -105,6 +105,7 @@ static char rptx_ksv_prbuf[1271]; /* 127 * 5 * 2 + 1 */
 MODULE_PARM_DESC(rptx_ksvs, "\n downstream ksvs\n");
 module_param(rptx_ksvs, charp, 0444);
 static int rptx_ksv_no;
+static int rptx_ksvlist_retry;
 static char rptx_ksv_buf[635];
 
 /* static struct tasklet_struct EDID_tasklet; */
@@ -1727,11 +1728,11 @@ static void set_phy_by_mode(unsigned int mode)
 			hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2036315b);
 			break;
 		case 3: /* 1.485Gbps */
-			hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33303362);
+			hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33303042);
 			hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x2016315b);
 			break;
 		default: /* 742.5Mbps, and below */
-			hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33604142);
+			hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33604132);
 			hd_write_reg(P_HHI_HDMI_PHY_CNTL3, 0x0016315b);
 			break;
 		}
@@ -2358,29 +2359,12 @@ static void set_aud_acr_pkt(struct hdmitx_dev *hdev,
 	|| (audio_param->type == CT_DTS_HD_MA))
 		hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, 2);
 
-	switch (audio_param->type) {
-	case 0: /* padding only, unused */
-	case CT_PCM:
-	case CT_AC_3:
-	case CT_DTS:
-	case CT_DTS_HD:
-		aud_n_para = 6144;
-		if ((hdev->cur_VIC == HDMI_4k2k_24) ||
-			(hdev->cur_VIC == HDMI_4k2k_25) ||
-			(hdev->cur_VIC == HDMI_4k2k_30) ||
-			(hdev->cur_VIC == HDMI_4k2k_smpte_24) ||
-			(hdev->cur_VIC == HDMI_4096x2160p25_256x135) ||
-			(hdev->cur_VIC == HDMI_4096x2160p30_256x135) ||
-			(hdev->cur_VIC == HDMI_4k2k_50_y420) ||
-			(hdev->cur_VIC == HDMI_4k2k_60_y420) ||
-			(hdev->cur_VIC == HDMI_4k2k_smpte_50_y420) ||
-			(hdev->cur_VIC == HDMI_4k2k_smpte_60_y420))
-			aud_n_para = 5120;
-		break;
-	default:
-		aud_n_para = 6144 * 4;
-		break;
-	}
+	if (hdev->para->cs == COLORSPACE_YUV422)
+		aud_n_para = hdmi_get_aud_n_paras(audio_param->sample_rate,
+			COLORDEPTH_24B, hdev->para->timing.pixel_freq);
+	else
+		aud_n_para = hdmi_get_aud_n_paras(audio_param->sample_rate,
+			hdev->para->cd, hdev->para->timing.pixel_freq);
 	pr_info("hdmitx aud_n_para = %d\n", aud_n_para);
 
 	/* ACR packet configuration */
@@ -3360,7 +3344,7 @@ static void hdcp_ksv_sha1_calc(struct hdmitx_dev *hdev)
 		pr_info("hdcptx14: KSV List memory not valid\n");
 }
 
-static void hdcp_ksv_event(unsigned long arg)
+static void hdcptx_events_handle(unsigned long arg)
 {
 	struct hdmitx_dev *hdev = (struct hdmitx_dev *)arg;
 	unsigned char ksv[5] = {0};
@@ -3368,6 +3352,7 @@ static void hdcp_ksv_event(unsigned long arg)
 	unsigned int bcaps_6_rp;
 	static unsigned int st_flag = -1;
 
+	bcaps_6_rp = !!(hdmitx_rd_reg(HDMITX_DWC_A_HDCPOBS3) & (1 << 6));
 	if (st_flag != hdmitx_rd_reg(HDMITX_DWC_A_APIINTSTAT)) {
 		st_flag = hdmitx_rd_reg(HDMITX_DWC_A_APIINTSTAT);
 		pr_info("hdcp14: instat: 0x%x\n", st_flag);
@@ -3379,8 +3364,6 @@ static void hdcp_ksv_event(unsigned long arg)
 			ksv[i] = (unsigned char)
 				hdmitx_rd_reg(HDMITX_DWC_HDCPREG_BKSV0 + i);
 		hdcp_ksv_store(ksv, 5);
-		bcaps_6_rp =
-			!!(hdmitx_rd_reg(HDMITX_DWC_A_HDCPOBS3) & (1 << 6));
 		get_hdcp_bstatus();
 		rx_set_receive_hdcp(rptx_ksv_buf, (rptx_ksv_no + 1) / 5,
 			(bcaps_6_rp ? get_hdcp_depth() : 0) + 1,
@@ -3399,6 +3382,7 @@ static void hdcp_ksv_event(unsigned long arg)
 			hdcp_ksv_print();
 	}
 	if (st_flag & (1 << 1)) {
+		rptx_ksvlist_retry++;
 		hdmitx_wr_reg(HDMITX_DWC_A_APIINTCLR, (1 << 1));
 		hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x1);
 		hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1<<1), 2 * HZ);
@@ -3409,6 +3393,22 @@ static void hdcp_ksv_event(unsigned long arg)
 			return;
 		}
 		hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x4);
+		if (rptx_ksvlist_retry % 4 == 0) {
+			for (i = 0; i < 5; i++)
+				ksv[i] = (unsigned char)
+					hdmitx_rd_reg(HDMITX_DWC_HDCPREG_BKSV0
+						+ i);
+			hdcp_ksv_store(ksv, 5);
+			rx_set_receive_hdcp(&ksv[0], 1, 127, 1, 1);
+		}
+
+	}
+	if ((bcaps_6_rp) && (get_hdcp_max_devs() || get_hdcp_max_cascade())) {
+		for (i = 0; i < 5; i++)
+			ksv[i] = (unsigned char)
+				hdmitx_rd_reg(HDMITX_DWC_HDCPREG_BKSV0 + i);
+		hdcp_ksv_store(ksv, 5);
+		rx_set_receive_hdcp(&ksv[0], 1, 127, 1, 1);
 	}
 	if (hdev->hdcp_try_times)
 		mod_timer(&hdev->hdcp_timer, jiffies + HZ / 100);
@@ -3425,7 +3425,7 @@ static void hdcp_start_timer(struct hdmitx_dev *hdev)
 		init_flag = 1;
 		init_timer(&hdev->hdcp_timer);
 		hdev->hdcp_timer.data = (ulong)hdev;
-		hdev->hdcp_timer.function = hdcp_ksv_event;
+		hdev->hdcp_timer.function = hdcptx_events_handle;
 		hdev->hdcp_timer.expires = jiffies + HZ / 100;
 		add_timer(&hdev->hdcp_timer);
 		hdev->hdcp_try_times = 500;
@@ -3485,6 +3485,7 @@ static int hdmitx_cntl_ddc(struct hdmitx_dev *hdev, unsigned cmd,
 		break;
 	case DDC_HDCP_OP:
 		if (argv == HDCP14_ON) {
+			rptx_ksvlist_retry = 0;
 			rptx_ksv_no = 0;
 			memset(rptx_ksv_buf, 0, sizeof(rptx_ksv_buf));
 			hdmitx_ddc_hw_op(DDC_MUX_DDC);
@@ -3494,6 +3495,7 @@ static int hdmitx_cntl_ddc(struct hdmitx_dev *hdev, unsigned cmd,
 			hdcp_start_timer(hdev);
 		}
 		if (argv == HDCP14_OFF) {
+			rptx_ksvlist_retry = 0;
 			hdmitx_hdcp_opr(4);
 		}
 		if (argv == HDCP22_ON) {
@@ -3530,43 +3532,17 @@ static int hdmitx_cntl_ddc(struct hdmitx_dev *hdev, unsigned cmd,
 	case DDC_HDCP_BYP:
 		hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, 1, 6, 1);
 		break;
-#if 0
 	case DDC_SCDC_DIV40_SCRAMB:
-		argv = 0;
-		switch (hdev->cur_VIC) {
-		case HDMI_3840x2160p50_16x9:
-		case HDMI_3840x2160p60_16x9:
-		case HDMI_4096x2160p50_256x135:
-		case HDMI_4096x2160p60_256x135:
-		case HDMI_3840x2160p50_64x27:
-		case HDMI_3840x2160p60_64x27:
-			argv = 1;
-			break;
-		case HDMI_3840x2160p50_16x9_Y420:
-		case HDMI_3840x2160p60_16x9_Y420:
-		case HDMI_4096x2160p50_256x135_Y420:
-		case HDMI_4096x2160p60_256x135_Y420:
-		case HDMI_3840x2160p50_64x27_Y420:
-		case HDMI_3840x2160p60_64x27_Y420:
-			if (hdev->para->cd != COLORDEPTH_24B)
-				argv = 1;
-			break;
-		default:
-			argv = 0;
-			break;
-		}
 		if (argv == 1) {
-			scdc_config(hdev);
+			scdc_wr_sink(TMDS_CFG, 0x3); /* TMDS 1/40 & Scramble */
+			scdc_wr_sink(TMDS_CFG, 0x3); /* TMDS 1/40 & Scramble */
 			hdmitx_wr_reg(HDMITX_DWC_FC_SCRAMBLER_CTRL, 1);
 		} else {
-			scdc_wr_sink(SOURCE_VER, 0x1);
-			scdc_wr_sink(SOURCE_VER, 0x1);
 			scdc_wr_sink(TMDS_CFG, 0x0); /* TMDS 1/40 & Scramble */
 			scdc_wr_sink(TMDS_CFG, 0x0); /* TMDS 1/40 & Scramble */
 			hdmitx_wr_reg(HDMITX_DWC_FC_SCRAMBLER_CTRL, 0);
 		}
 		break;
-#endif
 	default:
 		hdmi_print(INF, "ddc: " "unknown cmd: 0x%x\n", cmd);
 	}
@@ -3801,48 +3777,6 @@ static int hdmitx_cntl_config(struct hdmitx_dev *hdev, unsigned cmd,
 	return ret;
 }
 
-static int hdmitx_tmds_rxsense(void)
-{
-	int ret = -1;
-
-	switch (get_cpu_type()) {
-	case MESON_CPU_MAJOR_ID_GXBB:
-		{
-			unsigned int curr0, curr3;
-
-			curr0 = hd_read_reg(P_HHI_HDMI_PHY_CNTL0);
-			curr3 = hd_read_reg(P_HHI_HDMI_PHY_CNTL3);
-			if (curr0 == 0)
-				hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33632122);
-			hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL3, 0x9a, 16, 8);
-			ret = hd_read_reg(P_HHI_HDMI_PHY_CNTL2) & 0x1;
-			hd_write_reg(P_HHI_HDMI_PHY_CNTL3, curr3);
-			if (curr0 == 0)
-				hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0);
-		}
-		break;
-	case MESON_CPU_MAJOR_ID_GXL:
-	case MESON_CPU_MAJOR_ID_GXM:
-		{
-			unsigned int curr0, curr3;
-			curr0 = hd_read_reg(P_HHI_HDMI_PHY_CNTL0);
-			curr3 = hd_read_reg(P_HHI_HDMI_PHY_CNTL3);
-			if (curr0 == 0)
-				hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x33604142);
-			hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL3, 0x1, 4, 1);
-			ret = hd_read_reg(P_HHI_HDMI_PHY_CNTL2) & 0x1;
-			hd_write_reg(P_HHI_HDMI_PHY_CNTL3, curr3);
-			if (curr0 == 0)
-				hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0);
-		}
-		break;
-	default:
-		break;
-	}
-
-	return ret;
-}
-
 static int hdmitx_cntl_misc(struct hdmitx_dev *hdev, unsigned cmd,
 	unsigned argv)
 {
@@ -3877,8 +3811,6 @@ static int hdmitx_cntl_misc(struct hdmitx_dev *hdev, unsigned cmd,
 		if (argv == TMDS_PHY_DISABLE)
 			hdmi_phy_suspend();
 		break;
-	case MISC_TMDS_RXSENSE:
-		return hdmitx_tmds_rxsense();
 	case MISC_ESM_RESET:
 		if (hdev->hdcp_hpd_stick == 1) {
 			pr_info("hdcp: stick mode\n");
@@ -3998,16 +3930,6 @@ static int hdmitx_get_state(struct hdmitx_dev *hdev, unsigned cmd,
 	return 0;
 }
 
-/* The following two functions should move to */
-/* static struct platform_driver amhdmitx_driver.suspend & .wakeup */
-/* For tempelet use only. */
-/* Later will change it. */
-struct hdmi_phy {
-	unsigned long reg;
-	unsigned long val_sleep;
-	unsigned long val_save;
-};
-
 static void hdmi_phy_suspend(void)
 {
 	hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x0);
@@ -4250,7 +4172,7 @@ static void config_hdmi20_tx(enum hdmi_vic vic,
 	data32 |= ((((input_color_format == COLORSPACE_YUV422) &&
 		(output_color_format != COLORSPACE_YUV422)) ? 2 : 0) << 4);
 	data32 |= ((((input_color_format != COLORSPACE_YUV422) &&
-		(output_color_format == COLORSPACE_YUV422)) ? 2 : 0) << 0);
+		(output_color_format == COLORSPACE_YUV422)) ? 1 : 0) << 0);
 	hdmitx_wr_reg(HDMITX_DWC_CSC_CFG, data32);
 	hdmitx_csc_config(input_color_format, output_color_format, color_depth);
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c
index e863402..24a610e 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c
@@ -63,7 +63,7 @@ static void set_gxb_hpll_clk_out(unsigned clk)
 	switch (clk) {
 	case 5940000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800027b);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4c00, 0, 16);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -71,10 +71,11 @@ static void set_gxb_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4c00, 0, 16);
 		break;
 	case 3712500:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800024d);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4580, 0, 16);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -82,20 +83,22 @@ static void set_gxb_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4580, 0, 16);
 		break;
 	case 3450000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000247);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4300, 0, 16);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4300, 0, 16);
 		break;
 	case 2970000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800023d);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -167,6 +170,7 @@ static void set_gxtvbb_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4e00, 0, 16);
 		break;
 	case 4320000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800025a);
@@ -274,6 +278,35 @@ static void set_hpll_clk_out(unsigned clk)
 	pr_info("config HPLL done\n");
 }
 
+static void set_hpll_sspll(enum hdmi_vic vic)
+{
+	switch (get_cpu_type()) {
+	case MESON_CPU_MAJOR_ID_GXBB:
+		break;
+	case MESON_CPU_MAJOR_ID_GXTVBB:
+		break;
+	case MESON_CPU_MAJOR_ID_GXL:
+	case MESON_CPU_MAJOR_ID_GXM:
+		switch (vic) {
+		case HDMI_1920x1080p60_16x9:
+		case HDMI_1920x1080p50_16x9:
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x868b48c4);
+			break;
+		case HDMI_1280x720p60_16x9:
+		case HDMI_1280x720p50_16x9:
+		case HDMI_1920x1080i60_16x9:
+		case HDMI_1920x1080i50_16x9:
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x864348c4);
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
 static void set_hpll_od1(unsigned div)
 {
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
@@ -629,6 +662,7 @@ void hdmitx_set_clk(enum hdmi_vic vic)
 next:
 	set_hdmitx_sys_clk();
 	set_hpll_clk_out(p_enc[j].hpll_clk_out);
+	set_hpll_sspll(vic);
 	set_hpll_od1(p_enc[j].od1);
 	set_hpll_od2(p_enc[j].od2);
 	set_hpll_od3(p_enc[j].od3);
diff --git a/drivers/amlogic/input/avin_detect/aml_avin_detect.c b/drivers/amlogic/input/avin_detect/aml_avin_detect.c
index c9572d9..cb18fd0 100644
--- a/drivers/amlogic/input/avin_detect/aml_avin_detect.c
+++ b/drivers/amlogic/input/avin_detect/aml_avin_detect.c
@@ -12,282 +12,308 @@
 #include <linux/uaccess.h>
 #include <linux/delay.h>
 #include "aml_avin_detect.h"
+#include <linux/gpio.h>
 
 #ifndef CONFIG_OF
 #define CONFIG_OF
 #endif
 
-#define DEBUG_DEF  0
+#undef pr_fmt
+#define pr_fmt(fmt)    "avin_detect: " fmt
+
+#define DEBUG_DEF  1
 #define INPUT_REPORT_SWITCH 0
+#define LOOP_DETECT_TIMES 3
 
+#define MAX_AVIN_DEVICE_NUM  3
 #define AVIN_NAME  "avin_detect"
 #define AVIN_NAME_CH1  "avin_detect_ch1"
 #define AVIN_NAME_CH2  "avin_detect_ch2"
-
-/* after request_irq, irq handler maybe into one time */
-char first_time_into_irqhandle1 = 0;
-char first_time_into_irqhandle2 = 0;
-
-/*#ifdef USE_INPUT_EVENT_REPORT*/
+#define AVIN_NAME_CH3  "avin_detect_ch3"
 #define ABS_AVIN_1 0
 #define ABS_AVIN_2 1
-/*#endif*/
+#define ABS_AVIN_3 2
+
+static char *avin_name_ch[3] = {AVIN_NAME_CH1, AVIN_NAME_CH2, AVIN_NAME_CH3};
+static char avin_ch[3] = {AVIN_CHANNEL1, AVIN_CHANNEL2, AVIN_CHANNEL3};
 
 static DECLARE_WAIT_QUEUE_HEAD(avin_waitq);
 
-#define avin_det_info(x...) dev_info(&pdev->dev, x)
-#define avin_det_dbg(x...) /* dev_info(&pdev->dev, x) */
-#define avin_det_err(x...) dev_err(&pdev->dev, x)
+#if 0
+#define MASK_AVIRQ(i)\
+	gpiod_mask_irq(avdev->hw_res.pin[i],\
+	AML_GPIO_IRQ((avdev->hw_res.irq_num[i] - INT_GPIO_0),\
+	FILTER_NUM7, GPIO_IRQ_FALLING))
 
-static irqreturn_t avin_detect_handler1(int irq, void *data)
+#define ENABLE_AVIRQ(i)\
+	gpiod_for_irq(avdev->hw_res.pin[i],\
+	AML_GPIO_IRQ((avdev->hw_res.irq_num[i] - INT_GPIO_0),\
+	FILTER_NUM7, GPIO_IRQ_FALLING))
+#endif
+
+static void MASK_AVIRQ(int i, struct avin_det_s *avdev)
 {
-	struct avin_det_s *avdev = (struct avin_det_s *)data;
-	avdev->irq1_falling_times[avdev->detect_channel1_times]++;
-	disable_irq_nosync(avdev->irq_num1);
-	first_time_into_irqhandle1 = 1;
-	return IRQ_HANDLED;
+	gpiod_mask_irq(avdev->hw_res.pin[i],
+		AML_GPIO_IRQ((avdev->hw_res.irq_num[i] - INT_GPIO_0),
+		FILTER_NUM7, GPIO_IRQ_FALLING));
 }
-static irqreturn_t avin_detect_handler2(int irq, void *data)
+
+static void ENABLE_AVIRQ(int i, struct avin_det_s *avdev)
 {
-	struct avin_det_s *avdev = (struct avin_det_s *)data;
-	avdev->irq2_falling_times[avdev->detect_channel2_times]++;
-	disable_irq_nosync(avdev->irq_num2);
-	first_time_into_irqhandle2 = 1;
-	return IRQ_HANDLED;
+	gpiod_for_irq(avdev->hw_res.pin[i],
+		AML_GPIO_IRQ((avdev->hw_res.irq_num[i] - INT_GPIO_0),
+		FILTER_NUM7, GPIO_IRQ_FALLING));
 }
 
-void avin_timer_sr(unsigned long data)
+static irqreturn_t avin_detect_handler(int irq, void *data)
 {
+	int i;
 	struct avin_det_s *avdev = (struct avin_det_s *)data;
-	if (avdev->first_time_into_loop == 0) {
-		avdev->first_time_into_loop = 1;
-		enable_irq(avdev->irq_num1);
-		enable_irq(avdev->irq_num2);
-	} else {
-		if (++avdev->detect_channel1_times <= avdev->set_detect_times) {
-			if (avdev->irq1_falling_times[
-			avdev->detect_channel1_times - 1] == 0) {
-				disable_irq_nosync(avdev->irq_num1);
-			}
 
-			if (avdev->detect_channel1_times !=
-					avdev->set_detect_times) {
-				enable_irq(avdev->irq_num1);
+	for (i = 0; i <= avdev->dts_param.dts_device_num; i++) {
+		if (irq == avdev->hw_res.irq_num[i])
+			break;
+		else if (i == avdev->dts_param.dts_device_num)
+			return IRQ_HANDLED;
+	}
 
-			} else {
-				avdev->detect_channel1_times = 0;
-				avdev->first_time_into_loop = 0;
-				schedule_work(&(avdev->work_update1));
-			}
-		}
+	if (avdev->code_variable.loop_detect_times[i]++
+		>= LOOP_DETECT_TIMES) {
+		avdev->code_variable.irq_falling_times[
+			i * avdev->dts_param.dts_detect_times +
+			avdev->code_variable.detect_channel_times[i]]++;
+		avdev->code_variable.pin_mask_irq_flag[i] = 1;
+		avdev->code_variable.loop_detect_times[i] = 0;
+		schedule_work(&(avdev->work_struct_maskirq));
+	}
+	return IRQ_HANDLED;
+}
 
-		if (++avdev->detect_channel2_times <=
-				avdev->set_detect_times) {
-			if (avdev->irq2_falling_times[
-				avdev->detect_channel2_times - 1] == 0) {
-				disable_irq_nosync(avdev->irq_num2);
+/* must open irq >100ms later,then into timer handler */
+static void avin_timer_sr(unsigned long data)
+{
+	int i;
+	struct avin_det_s *avdev = (struct avin_det_s *)data;
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++) {
+		if (avdev->code_variable.detect_channel_times[i] <
+			(avdev->dts_param.dts_detect_times-1)) {
+			avdev->code_variable.detect_channel_times[i]++;
+			if (avdev->code_variable.irq_falling_times[
+				i * avdev->dts_param.dts_detect_times +
+				avdev->code_variable.detect_channel_times[
+					i]-1] != 0) {
+				avdev->code_variable.loop_detect_times[i] = 0;
+				ENABLE_AVIRQ(i, avdev);
 			}
-
-			if (avdev->detect_channel2_times !=
-					avdev->set_detect_times) {
-				enable_irq(avdev->irq_num2);
-			} else {
-				avdev->detect_channel2_times = 0;
-				avdev->first_time_into_loop = 0;
-				schedule_work(&(avdev->work_update2));
+			if (avdev->code_variable.detect_channel_times[
+				i] == 1) {
+				avdev->code_variable.irq_falling_times[
+				(i+1) * avdev->dts_param.dts_detect_times
+				- 1] = 0;
+			} else if (avdev->code_variable.detect_channel_times[i]
+			== (avdev->dts_param.dts_detect_times-1)) {
+				schedule_work(&(avdev->work_struct_update));
 			}
+		} else {
+			avdev->code_variable.detect_channel_times[i] = 0;
+			avdev->code_variable.loop_detect_times[i] = 0;
+			if (avdev->code_variable.irq_falling_times[
+				(i+1) * avdev->dts_param.dts_detect_times
+				-1] != 0)
+				ENABLE_AVIRQ(i, avdev);
 		}
 	}
-
 	mod_timer(&avdev->timer,
-	jiffies+msecs_to_jiffies(avdev->detect_interval_length));
+	jiffies+msecs_to_jiffies(avdev->dts_param.dts_interval_length));
 }
 
-static void kp_work_channel1(struct avin_det_s *avin_data)
+static void kp_work_channel1(struct avin_det_s *avdev)
 {
-	int i = 0;
-	int num = 0;
-
-	#if 0
-	pr_info("av-in1 low times = ");
-	for (i = 0; i < avin_data->set_detect_times; i++)
-		pr_info("%d ", avin_data->irq1_falling_times[i]);
-	pr_info("\n");
-	#endif
-
-	for (i = 0; i < avin_data->set_detect_times; i++) {
-		if (avin_data->irq1_falling_times[i] == 0)
-			num++;
-		avin_data->irq1_falling_times[i] = 0;
-	}
-
-	if (num >= (avin_data->set_detect_times
-		 - avin_data->set_fault_tolerance)) {
-		if (avin_data->ch1_current_status != AVIN_STATUS_OUT) {
-			avin_data->ch1_current_status = AVIN_STATUS_OUT;
-			#if INPUT_REPORT_SWITCH
-			input_report_abs(avin_data->input_dev,
-			 ABS_AVIN_1, AVIN_STATUS_OUT);
-			input_sync(avin_data->input_dev);
-			#endif
-			avin_data->report_data_s[0].channel = AVIN_CHANNEL1;
-			avin_data->report_data_s[0].status = AVIN_STATUS_OUT;
-			avin_data->report_data_flag = 1;
-			wake_up_interruptible(&avin_waitq);
+	int i, j;
+	mutex_lock(&avdev->lock);
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++) {
+		for (j = 0; j < (avdev->dts_param.dts_detect_times-1); j++) {
+			if (avdev->code_variable.irq_falling_times[
+				i * avdev->dts_param.dts_detect_times + j] == 0)
+				avdev->code_variable.actual_into_irq_times[i]++;
+
+			avdev->code_variable.irq_falling_times[
+				i * avdev->dts_param.dts_detect_times + j] = 0;
 		}
-		#if DEBUG_DEF
-		pr_info("avin ch1_current_status out!\n");
-		#endif
-	} else if (num <= avin_data->set_fault_tolerance) {
-		if (avin_data->ch1_current_status != AVIN_STATUS_IN) {
-			avin_data->ch1_current_status = AVIN_STATUS_IN;
-			#if INPUT_REPORT_SWITCH
-			input_report_abs(avin_data->input_dev,
-			 ABS_AVIN_1, AVIN_STATUS_IN);
-			input_sync(avin_data->input_dev);
-			#endif
-			avin_data->report_data_s[0].channel = AVIN_CHANNEL1;
-			avin_data->report_data_s[0].status = AVIN_STATUS_IN;
-			avin_data->report_data_flag = 1;
-			wake_up_interruptible(&avin_waitq);
+
+		if (avdev->code_variable.actual_into_irq_times[i] >=
+			((avdev->dts_param.dts_detect_times - 1)
+			- avdev->dts_param.dts_fault_tolerance)) {
+			if (avdev->code_variable.ch_current_status[i]
+				!= AVIN_STATUS_OUT) {
+				avdev->code_variable.ch_current_status[i]
+					= AVIN_STATUS_OUT;
+				#if INPUT_REPORT_SWITCH
+				input_report_abs(avdev->input_dev,
+				 ABS_AVIN_1, AVIN_STATUS_OUT);
+				input_sync(avdev->input_dev);
+				#endif
+				avdev->code_variable.report_data_s[i].channel
+				= avin_ch[i];
+				avdev->code_variable.report_data_s[i].status
+					= AVIN_STATUS_OUT;
+				avdev->code_variable.report_data_flag = 1;
+				wake_up_interruptible(&avin_waitq);
+				#if DEBUG_DEF
+				pr_info("avin ch%d current_status out!\n", i);
+				#endif
+			}
+		} else if (avdev->code_variable.actual_into_irq_times[i] <=
+			avdev->dts_param.dts_fault_tolerance) {
+			if (avdev->code_variable.ch_current_status[i]
+				!= AVIN_STATUS_IN) {
+				avdev->code_variable.ch_current_status[i]
+					= AVIN_STATUS_IN;
+				#if INPUT_REPORT_SWITCH
+				input_report_abs(avdev->input_dev,
+				 ABS_AVIN_1, AVIN_STATUS_IN);
+				input_sync(avdev->input_dev);
+				#endif
+				avdev->code_variable.report_data_s[i].channel
+				= avin_ch[i];
+				avdev->code_variable.report_data_s[i].status
+					= AVIN_STATUS_IN;
+				avdev->code_variable.report_data_flag = 1;
+				wake_up_interruptible(&avin_waitq);
+				#if DEBUG_DEF
+				pr_info("avin ch%d current_status in!\n", i);
+				#endif
+			}
+		} else {
+			/*keep current status*/
 		}
-		#if DEBUG_DEF
-		pr_info("avin ch1_current_status in!\n");
-		#endif
-	} else {
-		/*keep current status*/
 	}
+	memset(avdev->code_variable.actual_into_irq_times, 0,
+		sizeof(avdev->code_variable.actual_into_irq_times[0]) *
+		avdev->dts_param.dts_device_num);
+
+	mutex_unlock(&avdev->lock);
 }
 
-static void update_work_func_channel1(struct work_struct *work)
+static void update_work_update_status(struct work_struct *work)
 {
 	struct avin_det_s *avin_data =
-	container_of(work, struct avin_det_s, work_update1);
+	container_of(work, struct avin_det_s, work_struct_update);
 	kp_work_channel1(avin_data);
 }
 
-static void kp_work_channel2(struct avin_det_s *avin_data)
+static void update_work_maskirq(struct work_struct *work)
 {
-	int i = 0;
-	int num = 0;
-
-	#if 0
-	pr_info("av-in2 low times = ");
-	for (i = 0; i < avin_data->set_detect_times; i++)
-		pr_info("%d ", avin_data->irq2_falling_times[i]);
-	pr_info("\n");
-	#endif
-
-	for (i = 0; i < avin_data->set_detect_times; i++) {
-		if (avin_data->irq2_falling_times[i] == 0)
-			num++;
-		avin_data->irq2_falling_times[i] = 0;
-	}
-
-	if (num >= (avin_data->set_detect_times
-		 - avin_data->set_fault_tolerance)) {
-		if (avin_data->ch2_current_status != AVIN_STATUS_OUT) {
-			avin_data->ch2_current_status = AVIN_STATUS_OUT;
-			#if INPUT_REPORT_SWITCH
-			input_report_abs(avin_data->input_dev,
-			 ABS_AVIN_2, AVIN_STATUS_OUT);
-			input_sync(avin_data->input_dev);
-			#endif
-			avin_data->report_data_s[1].channel = AVIN_CHANNEL2;
-			avin_data->report_data_s[1].status = AVIN_STATUS_OUT;
-			avin_data->report_data_flag = 1;
-			wake_up_interruptible(&avin_waitq);
-		}
-		#if DEBUG_DEF
-		pr_info("avin ch2_current_status out!\n");
-		#endif
-	} else if (num <= avin_data->set_fault_tolerance) {
-		if (avin_data->ch2_current_status != AVIN_STATUS_IN) {
-			avin_data->ch2_current_status = AVIN_STATUS_IN;
-			#if INPUT_REPORT_SWITCH
-			input_report_abs(avin_data->input_dev,
-			 ABS_AVIN_2, AVIN_STATUS_IN);
-			input_sync(avin_data->input_dev);
-			#endif
-			avin_data->report_data_s[1].channel = AVIN_CHANNEL2;
-			avin_data->report_data_s[1].status = AVIN_STATUS_IN;
-			avin_data->report_data_flag = 1;
-			wake_up_interruptible(&avin_waitq);
+	int i;
+	struct avin_det_s *avdev =
+	container_of(work, struct avin_det_s, work_struct_maskirq);
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++) {
+		if (avdev->code_variable.pin_mask_irq_flag[i] == 1) {
+			MASK_AVIRQ(i, avdev);
+			avdev->code_variable.pin_mask_irq_flag[i] = 0;
 		}
-		#if DEBUG_DEF
-		pr_info("avin ch2_current_status in!\n");
-		#endif
-	} else {
-		/*keep current status*/
 	}
 }
 
-static void update_work_func_channel2(struct work_struct *work)
-{
-	struct avin_det_s *avin_data =
-	container_of(work, struct avin_det_s, work_update2);
-	kp_work_channel2(avin_data);
-}
-
-static int aml_sysavin_dt_parse(struct platform_device *pdev)
+static int aml_sysavin_dts_parse(struct platform_device *pdev)
 {
-	int ret = 0;
+	int ret;
+	int i;
+	int state;
+	int value;
 	struct pinctrl *p;
-	const char *str = "none";
 	struct avin_det_s *avdev;
 
 	avdev = platform_get_drvdata(pdev);
+
+	ret = of_property_read_u32(pdev->dev.of_node,
+	"avin_device_num", &value);
+	avdev->dts_param.dts_device_num = value;
+	if (ret) {
+		pr_info("Failed to get dts_device_num.\n");
+		goto get_avin_param_failed;
+	} else {
+		if (avdev->dts_param.dts_device_num == 0) {
+			pr_info("avin device num is 0\n");
+			goto get_avin_param_failed;
+		} else if (avdev->dts_param.dts_device_num >
+		MAX_AVIN_DEVICE_NUM) {
+			pr_info("avin device num is > MAX NUM\n");
+			goto get_avin_param_failed;
+		}
+	}
+
 	ret = of_property_read_u32(pdev->dev.of_node,
-	"detect_interval_length", &(avdev->detect_interval_length));
+	"detect_interval_length", &value);
 	if (ret) {
-		avin_det_err("Failed to get detect_interval_length.\n");
+		pr_info("Failed to get dts_interval_length.\n");
 		goto get_avin_param_failed;
 	}
+	avdev->dts_param.dts_interval_length = value;
 
 	ret = of_property_read_u32(pdev->dev.of_node,
-	"set_detect_times", &(avdev->set_detect_times));
+	"set_detect_times", &value);
 	if (ret) {
-		avin_det_err("Failed to get detect_interval_length.\n");
+		pr_info("Failed to get dts_detect_times.\n");
 		goto get_avin_param_failed;
 	}
+	avdev->dts_param.dts_detect_times = value + 1;
 
 	ret = of_property_read_u32(pdev->dev.of_node,
-	"set_fault_tolerance", &(avdev->set_fault_tolerance));
+	"set_fault_tolerance", &value);
 	if (ret) {
-		avin_det_err("Failed to get detect_interval_length.\n");
+		pr_info("Failed to get dts_fault_tolerance.\n");
 		goto get_avin_param_failed;
 	}
+	avdev->dts_param.dts_fault_tolerance = value;
 
-	p = devm_pinctrl_get_select(&pdev->dev, "avin_gpio_disable_pullup");
+	p = devm_pinctrl_get_select(&pdev->dev,
+		"avin_gpio_disable_pullup");
 	if (IS_ERR(p)) {
-		avin_det_err("avin_gpio_disbale_pull init fail, %ld\n",
-			PTR_ERR(p));
+		pr_info("avin_gpio_disbale_pull init fail, %ld\n",
+		PTR_ERR(p));
 		return 1;
 	}
 
-	of_property_read_string(pdev->dev.of_node, "avin_pin", &str);
-	avdev->pin1 = of_get_named_gpiod_flags
-	(pdev->dev.of_node, "avin1_pin", 0, NULL);
-	avdev->pin2 = of_get_named_gpiod_flags
-	(pdev->dev.of_node, "avin2_pin", 0, NULL);
+	/* request resource of pin */
+	avdev->hw_res.pin =
+		kzalloc((sizeof(struct gpio_desc *)
+		* avdev->dts_param.dts_device_num), GFP_KERNEL);
+	if (!avdev->hw_res.pin) {
+		state = -ENOMEM;
+		goto get_avin_param_failed;
+	}
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++) {
+		avdev->hw_res.pin[i] = of_get_named_gpiod_flags
+		(pdev->dev.of_node, "avin_det_pin", i, NULL);
+	}
+
+	/* request resource of irq num */
+	avdev->hw_res.irq_num =
+		kzalloc((sizeof(avdev->hw_res.irq_num[0])
+		* avdev->dts_param.dts_device_num), GFP_KERNEL);
+	if (!avdev->hw_res.irq_num) {
+		state = -ENOMEM;
+		goto get_avin_param_failed;
+	}
 
-	avdev->irq_num1 = irq_of_parse_and_map(pdev->dev.of_node, 0);
-	avdev->irq_num2 = irq_of_parse_and_map(pdev->dev.of_node, 1);
-	return 0;
+	avdev->hw_res.irq_num[0] =
+		irq_of_parse_and_map(pdev->dev.of_node, 0);
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++)
+		avdev->hw_res.irq_num[i] =
+		irq_of_parse_and_map(pdev->dev.of_node, i);
 
+	return 0;
 get_avin_param_failed:
 	return -EINVAL;
 }
 
-
 static int avin_open(struct inode *inode, struct file *file)
 {
 	int ret = 0;
 	struct avin_det_s *avindev;
-
 	avindev = container_of(inode->i_cdev, struct avin_det_s, avin_cdev);
 	file->private_data = avindev;
-
 	return ret;
 }
 
@@ -298,9 +324,11 @@ static ssize_t avin_read(struct file *file, char __user *buf,
 	struct avin_det_s *avin_data = (struct avin_det_s *)file->private_data;
 
 	/*wait_event_interruptible(avin_waitq, avin_data->report_data_flag);*/
-	ret = copy_to_user(buf, (void *)(avin_data->report_data_s),
-		sizeof(avin_data->report_data_s[0]) * 2);
-	avin_data->report_data_flag = 0;
+	ret = copy_to_user(buf,
+		(void *)(avin_data->code_variable.report_data_s),
+		sizeof(avin_data->code_variable.report_data_s[0])
+		* avin_data->dts_param.dts_device_num);
+	avin_data->code_variable.report_data_flag = 0;
 	return 0;
 }
 
@@ -316,9 +344,8 @@ static unsigned avin_poll(struct file *file, poll_table *wait)
 	struct avin_det_s *avin_data = (struct avin_det_s *)file->private_data;
 	poll_wait(file, &avin_waitq, wait);
 
-	if (avin_data->report_data_flag)
+	if (avin_data->code_variable.report_data_flag)
 		mask |= POLLIN | POLLRDNORM;
-
 	return mask;
 }
 
@@ -359,8 +386,8 @@ static int register_avin_dev(struct avin_det_s *avin_data)
 	if (IS_ERR(avin_data->config_dev)) {
 		pr_err("avin: failed to create device node\n");
 		ret = PTR_ERR(avin_data->config_dev);
-	return ret;
-}
+		return ret;
+	}
 
 	return ret;
 }
@@ -368,94 +395,143 @@ static int register_avin_dev(struct avin_det_s *avin_data)
 static int init_resource(struct avin_det_s *avdev)
 {
 	int irq_ret;
-	/* request irq */
-	irq_ret = request_irq(avdev->irq_num1,
-	avin_detect_handler1, IRQF_DISABLED,
-	AVIN_NAME_CH1, (void *)avdev);
-	if (irq_ret)
-		return -EINVAL;
-
-	irq_ret = request_irq(avdev->irq_num2,
-	avin_detect_handler2, IRQF_DISABLED, AVIN_NAME_CH2,
-	(void *)avdev);
-	if (irq_ret) {
-		free_irq(avdev->irq_num1, (void *)avdev);
-		return -EINVAL;
-	}
-	msleep(25);
-
-	if (first_time_into_irqhandle1)
-		avdev->irq1_falling_times[avdev->detect_channel1_times] = 0;
-	else
-		disable_irq(avdev->irq_num1);
-
-	if (first_time_into_irqhandle2)
-		avdev->irq2_falling_times[avdev->detect_channel2_times] = 0;
-	else
-		disable_irq(avdev->irq_num2);
+	int i, j;
+	INIT_WORK(&(avdev->work_struct_update),  update_work_update_status);
+	INIT_WORK(&(avdev->work_struct_maskirq), update_work_maskirq);
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++) {
+		for (j = 0; j < avdev->dts_param.dts_detect_times; j++)
+			avdev->code_variable.irq_falling_times[
+			i * avdev->dts_param.dts_detect_times + j] = 0;
+
+		avdev->code_variable.loop_detect_times[i] = 0;
+	}
 
 	/* set timer */
 	setup_timer(&avdev->timer, avin_timer_sr, (unsigned long)avdev);
 	mod_timer(&avdev->timer, jiffies+msecs_to_jiffies(2000));
 
-	INIT_WORK(&(avdev->work_update1), update_work_func_channel1);
-	INIT_WORK(&(avdev->work_update2), update_work_func_channel2);
+	/* request irq num*/
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++) {
+		irq_ret = request_irq(avdev->hw_res.irq_num[i],
+		avin_detect_handler, IRQF_DISABLED,
+		avin_name_ch[i], (void *)avdev);
+		if (irq_ret)
+			return -EINVAL;
+	}
 	return 0;
 }
 
+static int request_mem_resource(struct platform_device *pdev)
+{
+	int i;
+	int state;
+	struct avin_det_s *avdev;
+	avdev = platform_get_drvdata(pdev);
+
+	avdev->code_variable.pin_mask_irq_flag =
+		kzalloc((sizeof(avdev->code_variable.pin_mask_irq_flag[0]) *
+		avdev->dts_param.dts_device_num), GFP_KERNEL);
+	if (!avdev->code_variable.pin_mask_irq_flag) {
+		state = -ENOMEM;
+		goto request_mem_failed;
+	}
+
+	avdev->code_variable.loop_detect_times =
+		kzalloc((sizeof(avdev->code_variable.loop_detect_times[0]) *
+		avdev->dts_param.dts_device_num), GFP_KERNEL);
+	if (!avdev->code_variable.loop_detect_times) {
+		state = -ENOMEM;
+		goto request_mem_failed;
+	}
+
+	avdev->code_variable.detect_channel_times =
+		kzalloc((sizeof(avdev->code_variable.detect_channel_times[0]) *
+		avdev->dts_param.dts_device_num), GFP_KERNEL);
+	if (!avdev->code_variable.detect_channel_times) {
+		state = -ENOMEM;
+		goto request_mem_failed;
+	}
+
+	avdev->code_variable.report_data_s =
+		kzalloc((sizeof(avdev->code_variable.report_data_s[0]) *
+		avdev->dts_param.dts_device_num), GFP_KERNEL);
+	if (!avdev->code_variable.report_data_s) {
+		state = -ENOMEM;
+		goto request_mem_failed;
+	}
+
+	avdev->code_variable.irq_falling_times =
+		kzalloc((sizeof(avdev->code_variable.irq_falling_times[0]) *
+		avdev->dts_param.dts_device_num
+		* (avdev->dts_param.dts_detect_times)), GFP_KERNEL);
+	if (!avdev->code_variable.irq_falling_times) {
+		state = -ENOMEM;
+		goto request_mem_failed;
+	}
+
+	avdev->code_variable.actual_into_irq_times =
+		kzalloc((sizeof(avdev->code_variable.actual_into_irq_times[0]) *
+		avdev->dts_param.dts_device_num), GFP_KERNEL);
+	if (!avdev->code_variable.actual_into_irq_times) {
+		state = -ENOMEM;
+		goto request_mem_failed;
+	}
+
+	avdev->code_variable.ch_current_status =
+		kzalloc((sizeof(avdev->code_variable.ch_current_status[0]) *
+		avdev->dts_param.dts_device_num), GFP_KERNEL);
+	if (!avdev->code_variable.ch_current_status) {
+		state = -ENOMEM;
+		goto request_mem_failed;
+	}
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++)
+		avdev->code_variable.ch_current_status[i] = AVIN_STATUS_UNKNOW;
+
+	return 0;
+request_mem_failed:
+	return -EINVAL;
+}
+
 int avin_detect_probe(struct platform_device *pdev)
 {
+	int i;
 	int ret;
 	int state = 0;
 	struct avin_det_s *avdev = NULL;
-
 	avdev = kzalloc(sizeof(struct avin_det_s), GFP_KERNEL);
 	if (!avdev) {
-		avin_det_err("kzalloc error\n");
+		pr_info("kzalloc error\n");
 		state = -ENOMEM;
 		goto get_param_mem_fail;
 	}
-	platform_set_drvdata(pdev, avdev);
 
-	avdev->ch1_current_status = AVIN_STATUS_UNKNOW;
-	avdev->ch2_current_status = AVIN_STATUS_UNKNOW;
+	platform_set_drvdata(pdev, avdev);
 
-	ret = aml_sysavin_dt_parse(pdev);
+	ret = aml_sysavin_dts_parse(pdev);
 	if (ret) {
 		state = ret;
 		goto get_dts_dat_fail;
 	}
 
-	/* init */
-	avdev->irq1_falling_times =
-	kzalloc((sizeof(unsigned int) * avdev->set_detect_times), GFP_KERNEL);
-	if (!avdev->irq1_falling_times) {
-		state = -ENOMEM;
-		goto get_param_mem_fail_1;
-	}
-	avdev->irq2_falling_times =
-	 kzalloc((sizeof(unsigned int) * avdev->set_detect_times), GFP_KERNEL);
-	if (!avdev->irq2_falling_times) {
-		state = -ENOMEM;
+	ret = request_mem_resource(pdev);
+	if (ret) {
+		state = ret;
 		goto get_param_mem_fail_1;
 	}
 
-	/* request irq */
-	gpio_for_irq(desc_to_gpio(avdev->pin1),
-	AML_GPIO_IRQ((avdev->irq_num1 - INT_GPIO_0),
-	 FILTER_NUM7, GPIO_IRQ_FALLING));
-
-	gpio_for_irq(desc_to_gpio(avdev->pin2),
-	 AML_GPIO_IRQ((avdev->irq_num2 - INT_GPIO_0),
-	  FILTER_NUM7, GPIO_IRQ_FALLING));
+	/* request irq: gpio for irq */
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++)
+		ENABLE_AVIRQ(i, avdev);
 
 	ret = init_resource(avdev);
 	if (ret < 0) {
-		avin_det_err("Unable to init iqr resource.\n");
+		pr_info("Unable to init irq resource.\n");
 		state = -EINVAL;
 		goto irq_request_fail;
 	}
 
+	mutex_init(&avdev->lock);
+
 	/* register input device */
 	avdev->input_dev = input_allocate_device();
 	if (avdev->input_dev == 0) {
@@ -477,7 +553,7 @@ int avin_detect_probe(struct platform_device *pdev)
 
 	ret = input_register_device(avdev->input_dev);
 	if (ret < 0) {
-		avin_det_err("Unable to register avin input device.\n");
+		pr_info("Unable to register avin input device.\n");
 		state = -EINVAL;
 		goto register_input_fail;
 	}
@@ -489,9 +565,16 @@ register_input_fail:
 	input_free_device(avdev->input_dev);
 allocate_input_fail:
 irq_request_fail:
-	kfree(avdev->irq1_falling_times);
-	kfree(avdev->irq2_falling_times);
+	kfree(avdev->code_variable.actual_into_irq_times);
+	kfree(avdev->code_variable.ch_current_status);
+	kfree(avdev->code_variable.report_data_s);
+	kfree(avdev->code_variable.detect_channel_times);
+	kfree(avdev->code_variable.irq_falling_times);
+	kfree(avdev->code_variable.pin_mask_irq_flag);
+	kfree(avdev->code_variable.loop_detect_times);
 get_param_mem_fail_1:
+	kfree(avdev->hw_res.pin);
+	kfree(avdev->hw_res.irq_num);
 get_dts_dat_fail:
 	kfree(avdev);
 get_param_mem_fail:
@@ -503,49 +586,55 @@ static int avin_detect_suspend(struct platform_device *pdev ,
 {
 	int i;
 	struct avin_det_s *avdev = platform_get_drvdata(pdev);
-	avdev->first_time_into_loop = 0;
 	del_timer_sync(&avdev->timer);
-	cancel_work_sync(&avdev->work_update1);
-	cancel_work_sync(&avdev->work_update2);
-	free_irq(avdev->irq_num1, (void *)avdev);
-	free_irq(avdev->irq_num2, (void *)avdev);
-	for (i = 0; i < avdev->set_detect_times; i++)
-		avdev->irq2_falling_times[i] = 0;
-	avdev->detect_channel1_times = 0;
-	avdev->detect_channel2_times = 0;
-	first_time_into_irqhandle1 = 0;
-	first_time_into_irqhandle2 = 0;
-
-	avin_det_info("avin_detect_suspend ok.\n");
+	cancel_work_sync(&avdev->work_struct_update);
+	cancel_work_sync(&avdev->work_struct_maskirq);
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++) {
+		free_irq(avdev->hw_res.irq_num[i], (void *)avdev);
+		avdev->code_variable.irq_falling_times[i] = 0;
+		avdev->code_variable.detect_channel_times[i] = 0;
+		avdev->code_variable.loop_detect_times[i] = 0;
+	}
+	pr_info("avin_detect_suspend ok.\n");
 	return 0;
 }
 
 static int avin_detect_resume(struct platform_device *pdev)
 {
+	int i;
 	struct avin_det_s *avdev = platform_get_drvdata(pdev);
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++)
+		ENABLE_AVIRQ(i, avdev);
 	init_resource(avdev);
-	avin_det_info("avin_detect_resume ok.\n");
+	pr_info("avin_detect_resume ok.\n");
 	return 0;
 }
 
 int avin_detect_remove(struct platform_device *pdev)
 {
+	int i;
 	struct avin_det_s *avdev = platform_get_drvdata(pdev);
 	input_unregister_device(avdev->input_dev);
 	input_free_device(avdev->input_dev);
 	cdev_del(&avdev->avin_cdev);
 	del_timer_sync(&avdev->timer);
-	cancel_work_sync(&avdev->work_update1);
-	cancel_work_sync(&avdev->work_update2);
-	free_irq(avdev->irq_num1, (void *)avdev);
-	free_irq(avdev->irq_num2, (void *)avdev);
-	gpio_free(desc_to_gpio(avdev->pin1));
-	gpio_free(desc_to_gpio(avdev->pin2));
-	kfree(avdev->irq1_falling_times);
-	kfree(avdev->irq2_falling_times);
+	cancel_work_sync(&avdev->work_struct_update);
+	cancel_work_sync(&avdev->work_struct_maskirq);
+	for (i = 0; i < avdev->dts_param.dts_device_num; i++) {
+		free_irq(avdev->hw_res.irq_num[i], (void *)avdev);
+		gpio_free(desc_to_gpio(avdev->hw_res.pin[i]));
+	}
+	kfree(avdev->code_variable.actual_into_irq_times);
+	kfree(avdev->code_variable.ch_current_status);
+	kfree(avdev->code_variable.report_data_s);
+	kfree(avdev->code_variable.detect_channel_times);
+	kfree(avdev->code_variable.irq_falling_times);
+	kfree(avdev->code_variable.pin_mask_irq_flag);
+	kfree(avdev->code_variable.loop_detect_times);
+	kfree(avdev->hw_res.pin);
+	kfree(avdev->hw_res.irq_num);
 	kfree(avdev);
-	first_time_into_irqhandle1 = 0;
-	first_time_into_irqhandle2 = 0;
+
 	return 0;
 }
 
diff --git a/drivers/amlogic/input/avin_detect/aml_avin_detect.h b/drivers/amlogic/input/avin_detect/aml_avin_detect.h
index 0b901d5..90acd60 100644
--- a/drivers/amlogic/input/avin_detect/aml_avin_detect.h
+++ b/drivers/amlogic/input/avin_detect/aml_avin_detect.h
@@ -4,6 +4,15 @@
 #include <linux/cdev.h>
 #include <linux/workqueue.h>
 #include <linux/timer.h>
+#include <linux/mutex.h>
+#include <linux/gpio/consumer.h>
+
+
+#ifndef bool
+#define bool unsigned char
+#endif
+
+#define INT_GPIO_0	96
 
 enum avin_status_e {
 	AVIN_STATUS_IN = 0,
@@ -13,41 +22,57 @@ enum avin_status_e {
 enum avin_channel_e {
 	AVIN_CHANNEL1 = 0,
 	AVIN_CHANNEL2 = 1,
+	AVIN_CHANNEL3 = 2,
 };
 
-#define INT_GPIO_0	96
-
 struct report_data_s {
 	enum avin_channel_e channel;
 	enum avin_status_e status;
 };
 
+struct dts_const_param_s {
+	unsigned char dts_device_num;
+	unsigned char dts_detect_times;
+	unsigned char dts_fault_tolerance;
+	unsigned char dts_interval_length;
+};
+
+/*
+irq_falling_times[i][j]
+i: number of avin device
+j: the times of set_detect_times  --detect_channel_times
+*/
+struct code_variable_s {
+	bool report_data_flag;
+	bool *pin_mask_irq_flag;
+	unsigned char first_time_into_loop;
+	unsigned char *loop_detect_times;
+	unsigned char *detect_channel_times;
+	unsigned char *actual_into_irq_times;
+	unsigned char *irq_falling_times;
+	struct report_data_s *report_data_s;
+	enum avin_status_e *ch_current_status;
+};
+
+struct hw_resource_s {
+	int *irq_num;
+	struct gpio_desc **pin;
+};
+
 struct avin_det_s {
 	char config_name[20];
 	dev_t  avin_devno;
 	struct device *config_dev;
 	struct class *config_class;
 	struct cdev avin_cdev;
-	struct report_data_s report_data_s[2];
-	unsigned int report_data_flag;
-	enum avin_status_e ch1_current_status;
-	enum avin_status_e ch2_current_status;
-	unsigned int irq_num1;
-	unsigned int irq_num2;
-	struct gpio_desc *pin1;
-	struct gpio_desc *pin2;
-	unsigned int set_detect_times;
-	unsigned int set_fault_tolerance;
-	unsigned int detect_channel1_times;
-	unsigned int detect_channel2_times;
-	unsigned int *irq1_falling_times;
-	unsigned int *irq2_falling_times;
-	unsigned int first_time_into_loop;
-	unsigned int detect_interval_length;
+	struct dts_const_param_s dts_param;
+	struct code_variable_s code_variable;
+	struct hw_resource_s hw_res;
 	struct input_dev *input_dev;
 	struct timer_list timer;
-	struct work_struct work_update1;
-	struct work_struct work_update2;
+	struct mutex lock;
+	struct work_struct work_struct_update;
+	struct work_struct work_struct_maskirq;
 };
 
 #endif
diff --git a/drivers/amlogic/input/remote/remote_main.c b/drivers/amlogic/input/remote/remote_main.c
index a069dbe..88f909d 100644
--- a/drivers/amlogic/input/remote/remote_main.c
+++ b/drivers/amlogic/input/remote/remote_main.c
@@ -284,12 +284,6 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode,
 					key_map[gp_remote->map_num][scancode],
 					gp_remote->map_num,
 					gp_remote->cur_lsbkeycode);
-				//modified by Gavin.Lei @2016-05-11 to make S905 and S905L compatible, begin
-                //        gpio_direction_output(148, 1);
-		        if (gp_remote->ir_flag > 0)
-			        gpiod_direction_output(gp_remote->led_pin_desc,
-			                !gp_remote->led_status_on);
-				//modified by Gavin.Lei @2016-05-11 to make S905 and S905L compatible, end
 			break;
 		case 1:
 			input_dbg("press ircode = 0x%02x,",
@@ -298,12 +292,6 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode,
 					key_map[gp_remote->map_num][scancode],
 					gp_remote->map_num,
 					gp_remote->cur_lsbkeycode);
-				//modified by Gavin.Lei @2016-05-11 to make S905 and S905L compatible, begin
-                //        gpio_direction_output(148, 0);
-		        if (gp_remote->ir_flag > 0)
-		        	gpiod_direction_output(gp_remote->led_pin_desc,
-		        	        gp_remote->led_status_on);
-				//modified by Gavin.Lei @2016-05-11 to make S905 and S905L compatible, end
 			break;
 		case 2:
 			input_dbg("repeat ircode = 0x%02x,",
@@ -407,31 +395,6 @@ static ssize_t remote_enable_store(struct device *dev,
 	return strnlen(buf, count);
 }
 
-// add by Elric Fu to add a sysfs interface to control ir led function
-static ssize_t ir_led_enable_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u\n", gp_remote->ir_flag);
-}
-
-static ssize_t ir_led_enable_store(struct device *dev,
-				   struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	int state;
-
-	if (sscanf(buf, "%u", &state) != 1)
-		return -EINVAL;
-
-	if ((state != 1) && (state != 0))
-		return -EINVAL;
-        gp_remote->ir_flag = state;
-
-	return strnlen(buf, count);
-}
-
-static DEVICE_ATTR(ir_led_enable, S_IRUGO | S_IWUSR, ir_led_enable_show,
-		   ir_led_enable_store);
 static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, remote_enable_show,
 		   remote_enable_store);
 static DEVICE_ATTR(log_buffer, S_IRUGO , remote_log_buffer_show, NULL);
@@ -730,8 +693,6 @@ static int remote_probe(struct platform_device *pdev)
 	struct remote *remote;
 	struct input_dev *input_dev;
 	int ao_offset;
-	int led_status_on;
-	int ir_flag;
 	struct resource *res_irq;
 	int i, ret;
 	/*aml_set_reg32_mask(P_AO_RTI_PIN_MUX_REG, (1 << 0));*/
@@ -762,30 +723,6 @@ static int remote_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 	gp_remote = remote;
-	ret = of_property_read_u32(pdev->dev.of_node, "led_status_on",
-					&led_status_on);
-	pr_info("ret = %d\n", ret);
-	if (!ret) {
-		pr_info("remote: enable ir led config!\n");
-		ir_flag = 1;
-		} else {
-		pr_info("remote: not enable ir led config!\n");
-		ir_flag = -1;
-		}
-	remote->ir_flag = ir_flag;
-	//modified by Gavin.Lei @2016-05-11 to make S905 and S905L compatible, begin
-	//remote->led_pin_desc = gpiod_get(&pdev->dev, "led");
-	if(remote->ir_flag > 0){
-		remote->led_pin_desc = of_get_named_gpiod_flags(pdev->dev.of_node, "led_pin", 0, NULL);
-		if (IS_ERR(remote->led_pin_desc)) {
-			pr_err("%s:%d, get led_pin fail\n", __func__, __LINE__);
-			goto err1;
-		}
-	}
-	//modified by Gavin.Lei @2016-05-11 to make S905 and S905L compatible, end
-	remote->led_status_on = led_status_on;
-	pr_info("led_status_on:%d-%d:%d\n", led_status_on,
-	remote->led_status_on, desc_to_gpio(remote->led_pin_desc));
 	remote->debug_enable = 1;
 	remote->ig_custom_enable = 1;
 	gp_remote->remote_send_key = remote_send_key;
@@ -839,12 +776,6 @@ static int remote_probe(struct platform_device *pdev)
 		device_remove_file(&pdev->dev, &dev_attr_enable);
 		goto err1;
 	}
-	ret = device_create_file(&pdev->dev, &dev_attr_ir_led_enable);
-	if (ret < 0) {
-		device_remove_file(&pdev->dev, &dev_attr_enable);
-		device_remove_file(&pdev->dev, &dev_attr_log_buffer);
-		goto err1;
-	}
 	input_dbg("device_create_file completed \r\n");
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL)
 						| BIT_MASK(EV_ABS);
@@ -908,7 +839,6 @@ static int remote_remove(struct platform_device *pdev)
 	free_pages((unsigned long)remote_log_buf, REMOTE_LOG_BUF_ORDER);
 	device_remove_file(&pdev->dev, &dev_attr_enable);
 	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
-	device_remove_file(&pdev->dev, &dev_attr_ir_led_enable);
 	if (gp_remote->work_mode >= DECODEMODE_MAX) {
 #ifdef REMOTE_FIQ
 		free_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
diff --git a/drivers/amlogic/input/remote/remote_main.h b/drivers/amlogic/input/remote/remote_main.h
index 309e314..c09e99a 100644
--- a/drivers/amlogic/input/remote/remote_main.h
+++ b/drivers/amlogic/input/remote/remote_main.h
@@ -5,7 +5,6 @@
 #include <linux/timer.h>
 #include <linux/io.h>
 #include <linux/amlogic/iomap.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
 #ifdef REMOTE_FIQ
 #include <plat/fiq_bridge.h>
 #endif
@@ -621,9 +620,6 @@ struct remote {
 	unsigned int repeat_delay[20];
 	unsigned int relt_delay[20];
 	unsigned int repeat_peroid[20];
-	struct gpio_desc *led_pin_desc;
-	int led_status_on;
-	int ir_flag;
 	int (*remote_reprot_press_key)(struct remote *);
 	int (*key_report)(struct remote *);
 	void (*key_release_report)(struct remote *);
diff --git a/drivers/amlogic/input/sensor/common.c b/drivers/amlogic/input/sensor/common.c
index eb2c310..23e2c75 100644
--- a/drivers/amlogic/input/sensor/common.c
+++ b/drivers/amlogic/input/sensor/common.c
@@ -11,6 +11,7 @@
 #define AML_I2C_BUS_A 1
 #define AML_I2C_BUS_B 2
 #define AML_I2C_BUS_C 3
+#define AML_I2C_BUS_D 4
 #define AML_I2C_BUS_NO (-1)
 #define MAX_SENSOR_ONBOARD  6
 
@@ -144,6 +145,8 @@ int dt_sensor_setup_i2c_dev(struct device_node *node,  struct i2c_board_info
 				*i2c_bus_nr = AML_I2C_BUS_B;
 			else if (!strncmp(value, "i2c_bus_c", 9))
 				*i2c_bus_nr = AML_I2C_BUS_C;
+			else if (!strncmp(value, "i2c_bus_d", 9))
+				*i2c_bus_nr = AML_I2C_BUS_D;
 			else if (!strncmp(value, "i2c_bus_ao", 10))
 				*i2c_bus_nr = AML_I2C_BUS_AO;
 			else
@@ -299,7 +302,7 @@ static int aml_sensor_remove(struct platform_device *pdev)
 
 static const struct of_device_id sensor_prober_dt_match[] = {
 	{
-		.compatible = "amlogic,aml_sensor",
+		.compatible = "amlogic, aml_sensor",
 	},
 	{},
 };
diff --git a/drivers/amlogic/ion_dev/dev_ion.c b/drivers/amlogic/ion_dev/dev_ion.c
index 295295f..b545b3a 100644
--- a/drivers/amlogic/ion_dev/dev_ion.c
+++ b/drivers/amlogic/ion_dev/dev_ion.c
@@ -25,6 +25,7 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/of_reserved_mem.h>
+#include <linux/uaccess.h>
 #include "meson_ion.h"
 
 MODULE_DESCRIPTION("AMLOGIC ION driver");
@@ -89,6 +90,56 @@ int meson_ion_share_fd_to_phys(struct ion_client *client,
 }
 EXPORT_SYMBOL(meson_ion_share_fd_to_phys);
 
+static int meson_ion_get_phys(
+	struct ion_client *client,
+	unsigned long arg)
+{
+	struct meson_phys_data data;
+	struct ion_handle *handle;
+	size_t len;
+	ion_phys_addr_t addr;
+	int ret;
+
+	if (copy_from_user(&data, (void __user *)arg,
+		sizeof(struct meson_phys_data))) {
+		return -EFAULT;
+	}
+	handle = ion_import_dma_buf(client, data.handle);
+	if (IS_ERR_OR_NULL(handle)) {
+		dprintk(0, "EINVAL, client=%p, share_fd=%d\n",
+			client, data.handle);
+		return PTR_ERR(handle);
+	}
+
+	ret = ion_phys(client, handle, &addr, (size_t *)&len);
+	dprintk(1, "ret=%d, phys=0x%lX\n", ret, addr);
+	if (ret < 0) {
+		dprintk(0, "meson_ion_get_phys error, ret=%d\n", ret);
+		return ret;
+	}
+	data.phys_addr = (unsigned int)addr;
+	data.size = (unsigned int)len;
+	if (copy_to_user((void __user *)arg, &data,
+		sizeof(struct meson_phys_data))) {
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static long meson_custom_ioctl(
+	struct ion_client *client,
+	unsigned int cmd,
+	unsigned long arg)
+{
+	switch (cmd) {
+	case ION_IOC_MESON_PHYS_ADDR:
+		return meson_ion_get_phys(client, arg);
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
+
 int dev_ion_probe(struct platform_device *pdev)
 {
 	int err = 0;
@@ -156,7 +207,8 @@ static int ion_dev_mem_init(struct reserved_mem *rmem, struct device *dev)
 	my_ion_heap[num_heaps].size = rmem->size;
 	num_heaps++;
 	heaps = kzalloc(sizeof(struct ion_heap *) * num_heaps, GFP_KERNEL);
-	idev = ion_device_create(NULL);
+	/* idev = ion_device_create(NULL); */
+	idev = ion_device_create(meson_custom_ioctl);
 	if (IS_ERR_OR_NULL(idev)) {
 		kfree(heaps);
 		panic(0);
diff --git a/drivers/amlogic/ion_dev/meson_ion.h b/drivers/amlogic/ion_dev/meson_ion.h
index 759ceff..bbe09f3 100644
--- a/drivers/amlogic/ion_dev/meson_ion.h
+++ b/drivers/amlogic/ion_dev/meson_ion.h
@@ -21,6 +21,19 @@
 #include <ion/ion.h>
 
 /**
+* CUSTOM IOCTL - CMD
+*/
+
+#define ION_IOC_MESON_PHYS_ADDR             8
+
+struct meson_phys_data {
+	int handle;
+	unsigned int phys_addr;
+	unsigned int size;
+};
+
+
+/**
  * meson_ion_client_create() -  allocate a client and returns it
  * @heap_type_mask:	mask of heaps this client can allocate from
  * @name:		used for debugging
diff --git a/drivers/amlogic/ionvideo/ionvideo.h b/drivers/amlogic/ionvideo/ionvideo.h
index d46767c..16b27f5 100644
--- a/drivers/amlogic/ionvideo/ionvideo.h
+++ b/drivers/amlogic/ionvideo/ionvideo.h
@@ -55,8 +55,8 @@
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
 
-#define MAX_WIDTH 1920
-#define MAX_HEIGHT 1920
+#define MAX_WIDTH 4096
+#define MAX_HEIGHT 4096
 
 #define IONVID_INFO(fmt, args...) pr_info("ionvid: info: "fmt"", ## args)
 #define IONVID_DBG(fmt, args...) pr_debug("ionvid: dbg: "fmt"", ## args)
diff --git a/drivers/amlogic/key_manage/amlkey_if.h b/drivers/amlogic/key_manage/amlkey_if.h
index 83a74dd..e541f6b 100644
--- a/drivers/amlogic/key_manage/amlkey_if.h
+++ b/drivers/amlogic/key_manage/amlkey_if.h
@@ -29,6 +29,11 @@ secure 1, non 0
 */
 int32_t amlkey_issecure(const uint8_t *name);
 /*
+ * query if the prgrammed key is encrypt
+ * return encrypt 1, non 0;
+ */
+int32_t amlkey_isencrypt(const uint8_t *name);
+/*
 actual bytes of key value
 */
 ssize_t amlkey_size(const uint8_t *name);
@@ -38,25 +43,31 @@ read non-secure key in bytes, return byets readback actully.
 ssize_t amlkey_read(const uint8_t *name, uint8_t *buffer, uint32_t len);
 
 /*
-write secure/non-secure key in bytes , return byets readback actully
+write key with attr in bytes , return bytes readback actully
+	attr: bit0, secure/non-secure
+		  bit8, encrypt/non-encrypt
 */
 ssize_t amlkey_write(const uint8_t *name,
 		uint8_t *buffer,
 		uint32_t len,
-		uint32_t secure);
+		uint32_t attr);
 
 /*
 get the hash value of programmed secure key | 32bytes length, sha256
 */
 int32_t amlkey_hash_4_secure(const uint8_t *name, uint8_t *hash);
 
-extern int32_t nand_key_read(uint8_t *buf, uint32_t len);
+extern int32_t nand_key_read(uint8_t *buf,
+			uint32_t len, uint32_t *actual_lenth);
 
-extern int32_t nand_key_write(uint8_t *buf, uint32_t len);
+extern int32_t nand_key_write(uint8_t *buf,
+			uint32_t len, uint32_t *actual_lenth);
 
-extern int32_t emmc_key_read(uint8_t *buf, uint32_t len);
+extern int32_t emmc_key_read(uint8_t *buf,
+			uint32_t len, uint32_t *actual_lenth);
 
-extern int32_t emmc_key_write(uint8_t *buf, uint32_t len);
+extern int32_t emmc_key_write(uint8_t *buf,
+			uint32_t len, uint32_t *actual_lenth);
 
 #endif
 
diff --git a/drivers/amlogic/key_manage/storagekey.c b/drivers/amlogic/key_manage/storagekey.c
index ca393e2..897bdf2 100644
--- a/drivers/amlogic/key_manage/storagekey.c
+++ b/drivers/amlogic/key_manage/storagekey.c
@@ -113,7 +113,7 @@ EXPORT_SYMBOL(storage_ops_write);
 int32_t amlkey_init(uint8_t *seed, uint32_t len)
 {
 	int32_t ret = 0;
-	uint32_t buffer_size;
+	uint32_t buffer_size, actual_size;
 
 #ifndef OTHER_METHOD_CALL
 	ret = store_operation_init();
@@ -138,21 +138,18 @@ int32_t amlkey_init(uint8_t *seed, uint32_t len)
 		ret = -1;
 		goto _out;
 	}
-	if (buffer_size != storagekey_info.size) {
-		pr_err("%s() %d: warnning! %d/%d\n",
-			__func__, __LINE__, buffer_size, storagekey_info.size);
-		/* using innor size!*/
-		storagekey_info.size = buffer_size;
-	}
 
+	/* full fill key infos from storage. */
+	if (store_key_read)
+		ret = store_key_read(storagekey_info.buffer,
+					storagekey_info.size, &actual_size);
+
+	storagekey_info.size = actual_size;
 	pr_info("%s() storagekey_info.buffer=%p, storagekey_info.size = %0x!\n",
 		__func__,
 		storagekey_info.buffer,
 		storagekey_info.size);
-	/* full fill key infos from storage. */
-	if (store_key_read)
-		ret = store_key_read(storagekey_info.buffer,
-					storagekey_info.size);
+
 	if (ret) {
 		/* memset head info for bl31 */
 		memset(storagekey_info.buffer, 0, SECUESTORAGE_HEAD_SIZE);
@@ -190,7 +187,7 @@ int32_t amlkey_isexsit(const uint8_t *name)
  * 3. query if the prgrammed key is secure
  * return secure 1, non 0;
  */
-int32_t amlkey_issecure(const uint8_t *name)
+int32_t amlkey_get_attr(const uint8_t *name)
 {
 	int32_t ret = 0;
 	uint32_t retval;
@@ -210,6 +207,24 @@ int32_t amlkey_issecure(const uint8_t *name)
 }
 
 /**
+ * 3.1 query if the prgrammed key is secure
+ * return secure 1, non 0;
+ */
+int32_t amlkey_issecure(const uint8_t *name)
+{
+	return amlkey_get_attr(name) & KEY_UNIFY_ATTR_SECURE_MASK;
+}
+
+/**
+ * 3.2 query if the prgrammed key is encrypt
+ * return encrypt 1, non 0;
+ */
+int32_t amlkey_isencrypt(const uint8_t *name)
+{
+	return amlkey_get_attr(name) & KEY_UNIFY_ATTR_ENCRYPT_MASK;
+}
+
+/**
  * 4. actual bytes of key value
  *  return actual size.
  */
@@ -259,16 +274,19 @@ _out:
 }
 
 /**
- * 6.write secure/non-secure key in bytes , return bytes readback actully
+ * 6.write key with attr in bytes , return bytes readback actully
+ * attr: bit0, secure/non-secure
+ *       bit8, encrypt/non-encrypt
  * return actual size write down.
  */
 ssize_t amlkey_write(const uint8_t *name,
 	uint8_t *buffer,
 	uint32_t len,
-	uint32_t secure)
+	uint32_t attr)
 {
 	int32_t ret = 0;
 	ssize_t retval = 0;
+	uint32_t actual_lenth;
 
 	if (NULL == name) {
 		pr_err("%s() %d, invalid key ", __func__, __LINE__);
@@ -276,7 +294,7 @@ ssize_t amlkey_write(const uint8_t *name,
 	}
 	ret = secure_storage_write((uint8_t *)name,
 		buffer, len,
-		secure);
+		attr);
 	if (ret) {
 		pr_err("%s() %d: return %d\n", __func__, __LINE__, ret);
 		retval = 0;
@@ -287,7 +305,7 @@ ssize_t amlkey_write(const uint8_t *name,
 		if (storagekey_info.buffer != NULL) {
 			if (store_key_write)
 				ret = store_key_write(storagekey_info.buffer,
-							storagekey_info.size);
+					storagekey_info.size, &actual_lenth);
 			if (ret) {
 				pr_err("%s() %d, store_key_write fail\n",
 					__func__, __LINE__);
@@ -318,6 +336,7 @@ int32_t amlkey_hash_4_secure(const uint8_t *name, uint8_t *hash)
 int32_t amlkey_del(const uint8_t *name)
 {
 	int32_t ret = 0;
+	uint32_t actual_lenth;
 
 	/* ret = secure_storage_remove((uint8_t *)name);
 	??????????????????????
@@ -326,7 +345,7 @@ int32_t amlkey_del(const uint8_t *name)
 		/* flush back */
 		if (store_key_write)
 			ret = store_key_write(storagekey_info.buffer,
-						storagekey_info.size);
+				storagekey_info.size, &actual_lenth);
 		if (ret) {
 			pr_err("%s() %d, store_key_write fail\n",
 				 __func__,
diff --git a/drivers/amlogic/key_manage/unifykey.c b/drivers/amlogic/key_manage/unifykey.c
index d46766d..60b70a4 100644
--- a/drivers/amlogic/key_manage/unifykey.c
+++ b/drivers/amlogic/key_manage/unifykey.c
@@ -10,6 +10,8 @@
 #include <linux/uaccess.h>
 #include <linux/amlogic/efuse-amlogic.h>
 #include <linux/of.h>
+#include <linux/ctype.h>
+
 #include "unifykey.h"
 #include "amlkey_if.h"
 
@@ -29,7 +31,7 @@
 #define KEY_WRITE_PROHIBIT	(11<<4)
 
 #define SHA256_SUM_LEN	32
-
+#define DBG_DUMP_DATA	(0)
 static struct unifykey_dev_t *unifykey_devp;
 static dev_t unifykey_devno;
 static struct device *unifykey_device;
@@ -54,74 +56,6 @@ static int key_storage_size(char *keyname)
 	return amlkey_size((uint8_t *)keyname);
 }
 
-#if 0
-static int key_storage_write(char *keyname, unsigned char *keydata,
-		unsigned int datalen, int flag)
-{
-	int ret = 0;
-	/* fixme, todo write down this. */
-	uint8_t origSum[SHA256_SUM_LEN];
-	const int isSecure =
-		(KEY_M_SECURE_KEY == keymanage_dts_get_key_device(keyname));
-	ssize_t writenLen = 0;
-
-	if (isSecure) {
-		sha256_context ctx;
-		sha256_starts(&ctx);
-		sha256_update(&ctx, keydata, datalen);
-		sha256_finish(&ctx, origSum);
-	}
-
-	writenLen = amlkey_write((uint8_t *)keyname,
-		(uint8_t *)keydata,
-		datalen,
-		isSecure);
-	if (writenLen != datalen) {
-		pr_err("Want to write %u bytes, but only %zd Bytes\n",
-			datalen,
-			writenLen);
-		return -EINVAL;
-	}
-
-	if (isSecure) {
-		uint8_t genSum[SHA256_SUM_LEN];
-
-		ret = amlkey_hash_4_secure((uint8_t *)keyname, genSum);
-		if (ret) {
-			pr_err("Failed when gen hash for sec-key[%s],ret=%d\n",
-				keyname,
-				ret);
-			return -EINVAL;
-		}
-
-		ret = memcmp(origSum, genSum, SHA256_SUM_LEN);
-		if (ret) {
-			int index = 0;
-			char origSum_str[SHA256_SUM_LEN * 2 + 2];
-			char genSum_str[SHA256_SUM_LEN * 2 + 2];
-
-			origSum_str[0] = genSum_str[0] = '\0';
-			for (index = 0; index < SHA256_SUM_LEN; ++index) {
-				sprintf(origSum_str, "%s%02x",
-					origSum_str,
-					origSum[index]);
-				sprintf(genSum_str, "%s%02x",
-					genSum_str,
-					genSum[index]);
-			}
-
-			pr_err("Failed in check hash,origSum[%s]!=genSum[%s]\n",
-				origSum_str,
-				genSum_str);
-			return -EINVAL;
-		}
-		pr_info("OK in check sha1256 in burn key[%s]\n", keyname);
-	}
-
-	return ret;
-}
-#endif
-
 static int key_storage_write(char *keyname, unsigned char *keydata,
 		unsigned int datalen, int flag)
 {
@@ -164,6 +98,8 @@ static int key_storage_read(char *keyname, unsigned char *keydata,
 {
 	int ret = 0;
 	ssize_t readLen = 0;
+	int encrypt, encrypt_dts;
+	struct key_item_t *unifykey;
 	/* fixme, todo */
 
 	ret = amlkey_issecure((uint8_t *)keyname);
@@ -172,6 +108,22 @@ static int key_storage_read(char *keyname, unsigned char *keydata,
 		return -EINVAL;
 	}
 
+	/* make sure attr in storage & dts are the same! */
+	encrypt = amlkey_isencrypt((uint8_t *)keyname);
+
+	unifykey = unifykey_find_item_by_name(keyname);
+	if (unifykey == NULL) {
+		pr_err("%s:%d,%s key name is not exist\n",
+			__func__, __LINE__, keyname);
+		return -EINVAL;
+	}
+	encrypt_dts = (unifykey->attr & KEY_UNIFY_ATTR_ENCRYPT_MASK) ?
+		1:0;
+	if (encrypt != encrypt_dts) {
+		pr_err("key[%s] can't read, encrypt?\n", keyname);
+		return -EINVAL;
+	}
+
 	readLen = amlkey_read((uint8_t *)keyname,
 		(uint8_t *)keydata,
 		datalen);
@@ -335,6 +287,7 @@ int key_unify_write(char *keyname, unsigned char *keydata,
 	unsigned int datalen)
 {
 	int err = 0;
+	int attr;
 	struct key_item_t *unifykey;
 
 	unifykey = unifykey_find_item_by_name(keyname);
@@ -356,10 +309,13 @@ int key_unify_write(char *keyname, unsigned char *keydata,
 			err = key_efuse_write(keyname, keydata, datalen);
 			break;
 		case KEY_M_SECURE:
-			err = key_storage_write(keyname, keydata, datalen, 1);
-			break;
 		case KEY_M_NORMAL:
-			err = key_storage_write(keyname, keydata, datalen, 0);
+			attr = ((unifykey->dev == KEY_M_SECURE) ?
+				KEY_UNIFY_ATTR_SECURE : 0);
+			attr |= (unifykey->attr & KEY_UNIFY_ATTR_ENCRYPT_MASK) ?
+				KEY_UNIFY_ATTR_ENCRYPT : 0;
+			err = key_storage_write(keyname, keydata,
+				datalen, attr);
 			break;
 		case KEY_M_UNKNOW_DEV:
 		default:
@@ -547,6 +503,61 @@ int key_unify_query(char *keyname, unsigned int *keystate,
 }
 EXPORT_SYMBOL(key_unify_query);
 
+
+/*
+ *function name: key_unify_encrypt
+ * keyname : key name is ascii string
+ * encrypt : key encrypt status.
+ * return : <0 fail, >=0 ok
+ * */
+int key_unify_encrypt(char *keyname, unsigned int *encrypt)
+{
+	int ret = 0;
+	struct key_item_t *unifykey;
+	unsigned int keystate, keypermit;
+
+	unifykey = unifykey_find_item_by_name(keyname);
+	if (unifykey == NULL) {
+		pr_err("%s:%d,%s key name is not exist\n",
+			__func__,
+			__LINE__,
+			keyname);
+		return -EINVAL;
+	}
+
+	if (unifykey_item_verify_check(unifykey)) {
+		pr_err("%s:%d,%s key name is invalid\n",
+			__func__,
+			__LINE__,
+			keyname);
+		return -EINVAL;
+	}
+
+	/* check key burned or not */
+	ret = key_unify_query(unifykey->name, &keystate, &keypermit);
+	if (ret < 0) {
+		pr_err("%s:%d, key_unify_query failed!\n",
+			__func__, __LINE__);
+		return -EINVAL;
+	}
+
+	*encrypt = 0;
+	/* if burned, ask bl31, else using dts */
+	if (keystate) {
+		ret = amlkey_isencrypt(unifykey->name);
+		if (ret < 0)
+			goto _out;
+		*encrypt = ret;
+	} else {
+		if (unifykey->attr & KEY_UNIFY_ATTR_ENCRYPT_MASK)
+			*encrypt = 1;
+	}
+
+_out:
+	return ret;
+}
+EXPORT_SYMBOL(key_unify_encrypt);
+
 int key_unify_uninit(void)
 {
 	int bakerr, err =  -EINVAL;
@@ -736,6 +747,17 @@ exit:
 	kfree(local_buf);
 	return ret;
 }
+#if (DBG_DUMP_DATA)
+static void _dump_data(char *buffer, unsigned int len, char *name)
+{
+	int i;
+	pr_err("%s(%s, %d)\n", __func__, name, len);
+	for (i = 0; i < len; i++)
+		pr_err("%02x ", buffer[i]);
+	pr_err("\n");
+	return;
+}
+#endif
 
 static ssize_t unifykey_write(struct file *file,
 	const char __user *buf,
@@ -762,6 +784,9 @@ static ssize_t unifykey_write(struct file *file,
 		ret =  -EFAULT;
 		goto exit;
 	}
+#if (DBG_DUMP_DATA)
+	_dump_data(local_buf, count, item->name);
+#endif
 	ret = key_unify_write(item->name, local_buf, count);
 	if (ret < 0)
 		goto exit;
@@ -833,6 +858,38 @@ static ssize_t exist_show(struct class *cla,
 	return n;
 }
 
+static ssize_t encrypt_show(struct class *cla,
+	struct class_attribute *attr,
+	char *buf)
+{
+	ssize_t n = 0;
+	int ret;
+	unsigned int encrypt;
+	char *state[] = {"false", "true", "error"};
+
+	if (curkey == NULL) {
+		pr_err("please set key name 1st, %s:%d\n",
+			__func__, __LINE__);
+		return -EINVAL;
+	}
+
+	/* using current key*/
+	ret = key_unify_encrypt(curkey->name, &encrypt);
+	if (ret < 0) {
+		pr_err("%s:%d, key_unify_query failed!\n",
+			__func__, __LINE__);
+		encrypt = 2;
+		goto _out;
+	}
+
+	if (encrypt > 1)
+		encrypt = 1;
+_out:
+	n += sprintf(&buf[n], "%s\n", state[encrypt]);
+	buf[n] = 0;
+	return n;
+}
+
 static ssize_t size_show(struct class *cla,
 	struct class_attribute *attr,
 	char *buf)
@@ -887,6 +944,7 @@ static ssize_t name_store(struct class *cla,
 	int index, key_cnt;
 	struct key_item_t *unifykey = NULL;
 	size_t query_name_len;
+	size_t reval;
 
 	if (count >= KEY_UNIFY_NAME_LEN)
 		count = KEY_UNIFY_NAME_LEN - 1;
@@ -912,6 +970,8 @@ static ssize_t name_store(struct class *cla,
 		name,
 		(int)query_name_len);
 
+	curkey = NULL;
+
 	for (index = 0; index < key_cnt; index++) {
 		unifykey = unifykey_find_item_by_id(index);
 		if (unifykey != NULL) {
@@ -924,14 +984,17 @@ static ssize_t name_store(struct class *cla,
 			}
 		}
 	}
+	reval = count;
 	if (curkey == NULL) {
 		/* count = 0; */
+		reval++;
 		pr_err("could not found key %s\n", name);
 	}
 	if (!IS_ERR_OR_NULL(name))
 		kfree(name);
+	reval =  count+1;
 
-	return count;
+	return reval;
 }
 
 static ssize_t read_show(struct class *cla,
@@ -1008,15 +1071,22 @@ static ssize_t write_store(struct class *cla,
 				__func__, __LINE__);
 			goto _out;
 		}
-		/* check '\n' and del */
-		if (buf[count - 1] == '\n') {
+		/* check string */
+		for (key_len = 0; key_len < count; key_len++)
+			if (!isascii(buf[key_len]))
+				break;
+		/* check '\n' and del while string */
+		if ((key_len == count) && (buf[count - 1] == '\n')) {
+			pr_err("%s()  is a string\n", __func__);
 			memcpy(keydata, buf, count-1);
 			key_len = count - 1;
 		} else {
 			memcpy(keydata, buf, count);
 			key_len = count;
 		}
-
+	#if (DBG_DUMP_DATA)
+		_dump_data(keydata, key_len, curkey->name);
+	#endif
 		ret = key_unify_write(curkey->name, keydata, key_len);
 		if (ret < 0) {
 			pr_err("%s() %d: key write fail\n",
@@ -1164,6 +1234,7 @@ static struct class_attribute unifykey_class_attrs[] = {
 	__ATTR_RO(version),
 	__ATTR_RO(list),
 	__ATTR_RO(exist),
+	__ATTR_RO(encrypt),
 	__ATTR_RO(size),
 	__ATTR_RO(help),
 	__ATTR(name, KEY_RW_ATTR, name_show, name_store),
diff --git a/drivers/amlogic/key_manage/unifykey.h b/drivers/amlogic/key_manage/unifykey.h
index 61c1b57..e00f00f 100644
--- a/drivers/amlogic/key_manage/unifykey.h
+++ b/drivers/amlogic/key_manage/unifykey.h
@@ -41,13 +41,18 @@ struct key_item_info_t {
 	unsigned int reserve;
 };
 
+#define KEY_UNIFY_ATTR_ENCRYPT		(1 << 8)
+#define KEY_UNIFY_ATTR_ENCRYPT_MASK	(KEY_UNIFY_ATTR_ENCRYPT)
+#define KEY_UNIFY_ATTR_SECURE		(1 << 0)
+#define KEY_UNIFY_ATTR_SECURE_MASK	(KEY_UNIFY_ATTR_SECURE)
+
 struct key_item_t {
 	char name[KEY_UNIFY_NAME_LEN];
 	int id;
 	unsigned int dev; /* key save in device //efuse, */
 	/* unsigned int df; */
 	unsigned int permit;
-	int flag;
+	int attr;
 	int reserve;
 	struct key_item_t *next;
 };
diff --git a/drivers/amlogic/key_manage/unifykey_dts.c b/drivers/amlogic/key_manage/unifykey_dts.c
index 0457b65..4715c9f 100644
--- a/drivers/amlogic/key_manage/unifykey_dts.c
+++ b/drivers/amlogic/key_manage/unifykey_dts.c
@@ -19,6 +19,10 @@
 #define KEY_PERMIT_WRITE	"write"
 #define KEY_PERMIT_DEL		"del"
 
+/* attribute */
+#define KEY_ATTR_TRUE		"true"
+#define KEY_ATTR_FALSE		"false"
+
 static struct key_info_t unify_key_info = {.key_num = 0, .key_flag = 0};
 static struct key_item_t *unifykey_item;
 
@@ -166,6 +170,19 @@ static int unifykey_item_parse_dt(struct device_node *node, int id)
 		temp_item->permit |= KEY_M_PERMIT_DEL;
 	temp_item->id = id;
 
+	temp_item->attr = 0;
+	ret = of_property_read_string(node, "key-encrypt", &propname);
+	if (ret < 0) {
+		goto _next_attr;
+	}
+	if (propname) {
+		if (strcmp(propname, KEY_ATTR_TRUE) == 0)
+			temp_item->attr = KEY_UNIFY_ATTR_ENCRYPT;
+	}
+
+_next_attr:
+	/*todo, add new attribute here*/
+
 	unifykey_add_to_list(temp_item);
 
 	return 0;
diff --git a/drivers/amlogic/mmc/aml_sd_emmc.c b/drivers/amlogic/mmc/aml_sd_emmc.c
index a637aee..655fc37 100644
--- a/drivers/amlogic/mmc/aml_sd_emmc.c
+++ b/drivers/amlogic/mmc/aml_sd_emmc.c
@@ -1128,6 +1128,8 @@ static void aml_sd_emmc_tx_phase_set(struct amlsd_host *host,
 
 	vclkc = sd_emmc_regs->gclock;
 	pclkc->tx_phase = pdata->tx_phase;
+	if (pdata->tx_delay)
+		pclkc->tx_delay = pdata->tx_delay;
 
 	sd_emmc_regs->gclock = vclkc;
 	return;
@@ -1462,7 +1464,7 @@ static unsigned aml_sd_emmc_pre_dma(struct amlsd_host *host,
 		sg_blocks += des_cmd_cur->length;
 		sg_addr = sg_dma_address(sg);
 
-		if (sg_addr & 0x7) { /* for 64 bit dma mode */
+		if (sg_addr & 0x7) { /* for no 64 bit addr alignment mode */
 			WARN_ON(host->sg_cnt > 1);
 
 			host->dma_sts |= (1<<1); /*  */
@@ -2279,14 +2281,14 @@ void mmc_cmd_LBA_show(struct mmc_host *mmc, struct mmc_request *mrq)
 
 		if ((mrq->cmd->arg >= offset)
 				&& (mrq->cmd->arg < (offset + size))) {
-			sd_emmc_err("%s: cmd 0x%x, arg 0x%x, operation is in [%s] disk!\n",
+			sd_emmc_err("%s: cmd %d, arg 0x%x, operation is in [%s] disk!\n",
 				mmc_hostname(mmc),
 				mrq->cmd->opcode, mrq->cmd->arg, pp->name);
 			break;
 		}
 	}
 	if (i == pt_fmt->part_num)
-		sd_emmc_err("%s: cmd 0x%x, arg 0x%x, operation is in [unknown] disk!\n",
+		sd_emmc_err("%s: cmd %d, arg 0x%x, operation is in [unknown] disk!\n",
 			mmc_hostname(mmc),
 			mrq->cmd->opcode, mrq->cmd->arg);
 }
diff --git a/drivers/amlogic/mmc/amlsd.c b/drivers/amlogic/mmc/amlsd.c
index 32d6c99..0c4876b 100644
--- a/drivers/amlogic/mmc/amlsd.c
+++ b/drivers/amlogic/mmc/amlsd.c
@@ -1231,21 +1231,18 @@ int aml_sd_uart_detect(struct amlsd_platform *pdata)
 			return 1;
 		else
 			pdata->is_in = true;
-		if (aml_is_sduart(pdata)
-		&& (!mmc_host_uhs(pdata->mmc))) {
-			/*if (!pdata->is_sduart) {  status change */
-				aml_uart_switch(pdata, 1);
-				pr_info("Uart in\n");
-				pdata->mmc->caps &= ~MMC_CAP_4_BIT_DATA;
-				if (aml_is_sdjtag(pdata)) {
-					is_jtag = true;
-					/* aml_jtag_sd(); */
-					aml_jtag_switch_sd(pdata);
-					pdata->is_in = false;
-					pr_info("JTAG in\n");
-					return 0;
-				}
-			/*}*/
+		if (aml_is_sduart(pdata)) {
+			aml_uart_switch(pdata, 1);
+			pr_info("Uart in\n");
+			pdata->mmc->caps &= ~MMC_CAP_4_BIT_DATA;
+			if (aml_is_sdjtag(pdata)) {
+				is_jtag = true;
+				/* aml_jtag_sd(); */
+				aml_jtag_switch_sd(pdata);
+				pdata->is_in = false;
+				pr_info("JTAG in\n");
+				return 0;
+			}
 		} else {
 			pr_info("normal card in\n");
 			aml_uart_switch(pdata, 0);
@@ -1467,7 +1464,8 @@ int aml_sd_voltage_switch(struct amlsd_platform *pdata, char signal_voltage)
 			ret = gpio_direction_output(pdata->vol_switch,
 					(!pdata->vol_switch_18));
 		CHECK_RET(ret);
-		pdata->signal_voltage = signal_voltage;
+		if (!ret)
+			pdata->signal_voltage = signal_voltage;
 	} else
 		return -EINVAL;
 
@@ -1480,11 +1478,9 @@ void aml_emmc_hw_reset(struct mmc_host *mmc)
 {
 	struct amlsd_platform *pdata = mmc_priv(mmc);
 	u32 ret;
-	if (!aml_card_type_mmc(pdata))
+	if (!aml_card_type_mmc(pdata) || !pdata->hw_reset)
 		return;
 
-	pr_info("%s %d\n", __func__, __LINE__);
-
 	/* boot_9 used as eMMC hw_rst pin here. */
 	gpio_free(pdata->hw_reset);
 	ret = gpio_request_one(pdata->hw_reset,
diff --git a/drivers/amlogic/mmc/amlsd_of.c b/drivers/amlogic/mmc/amlsd_of.c
index d57ecb7..948022d 100644
--- a/drivers/amlogic/mmc/amlsd_of.c
+++ b/drivers/amlogic/mmc/amlsd_of.c
@@ -57,6 +57,8 @@ static const struct sd_caps host_caps[] = {
 	SD_CAPS(MMC_CAP_DRIVER_TYPE_D, "MMC_CAP_DRIVER_TYPE_D"),
 	SD_CAPS(MMC_CAP_CMD23, "MMC_CAP_CMD23"),
 	SD_CAPS(MMC_CAP_HW_RESET, "MMC_CAP_HW_RESET"),
+	SD_CAPS(MMC_CAP_RUNTIME_RESUME, "MMC_CAP_RUNTIME_RESUME"),
+	SD_CAPS(MMC_CAP_AGGRESSIVE_PM, "MMC_CAP_AGGRESSIVE_PM"),
 	SD_CAPS(MMC_PM_KEEP_POWER, "MMC_PM_KEEP_POWER"),
 };
 
@@ -234,6 +236,8 @@ int amlsd_get_platform_data(struct platform_device *pdev,
 			/*tx_phase set default value first*/
 			if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB)
 				pdata->tx_phase = 1;
+			if (get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)
+				pdata->tx_delay = 3;
 			SD_PARSE_U32_PROP_DEC(child, "tx_phase",
 						prop, pdata->tx_phase);
 		}
diff --git a/drivers/amlogic/mmc/emmc_key.c b/drivers/amlogic/mmc/emmc_key.c
index ab851b7..68f3ce4 100644
--- a/drivers/amlogic/mmc/emmc_key.c
+++ b/drivers/amlogic/mmc/emmc_key.c
@@ -397,7 +397,8 @@ static void fill_data(uint8_t *buffer)
 #define		EMMC_BLOCK_SIZE		(0x100)
 #define		MAX_EMMC_BLOCK_SIZE	(128*1024)
 
-int32_t emmc_key_read(uint8_t *buffer, uint32_t length)
+int32_t emmc_key_read(uint8_t *buffer,
+	uint32_t length, uint32_t *actual_lenth)
 {
 	int ret;
 	u64  addr = 0;
@@ -406,7 +407,8 @@ int32_t emmc_key_read(uint8_t *buffer, uint32_t length)
 	unsigned char *dst = NULL;
 	struct mmc_card *card = mmc_card_key;
 	int bit = card->csd.read_blkbits;
-	size = EMMC_KEYAREA_SIZE;
+	size = length;
+	*actual_lenth = length;
 	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
 	blk = addr >> bit;
 	cnt = size >> bit;
@@ -461,7 +463,8 @@ int32_t emmc_key_write(uint8_t *buffer, uint32_t length)
 	return ret;
 }
 */
-int32_t emmc_key_write(uint8_t *buffer, uint32_t length)
+int32_t emmc_key_write(uint8_t *buffer,
+	uint32_t length, uint32_t *actual_lenth)
 {
 	int ret;
 	u64  addr = 0;
@@ -470,7 +473,7 @@ int32_t emmc_key_write(uint8_t *buffer, uint32_t length)
 	unsigned char *src = NULL;
 	struct mmc_card *card = mmc_card_key;
 	int bit = card->csd.read_blkbits;
-	size = EMMC_KEYAREA_SIZE;
+	size = length;
 	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
 	blk = addr >> bit;
 	cnt = size >> bit;
diff --git a/drivers/amlogic/mmc/emmc_key.h b/drivers/amlogic/mmc/emmc_key.h
index 2f98899..76e7358 100644
--- a/drivers/amlogic/mmc/emmc_key.h
+++ b/drivers/amlogic/mmc/emmc_key.h
@@ -74,8 +74,10 @@ struct emmckey_data_t {
 
 int emmc_key_init(struct mmc_card *card);
 
-int32_t emmc_key_read(uint8_t *buffer, uint32_t length);
-int32_t emmc_key_write(uint8_t *buffer, uint32_t length);
+int32_t emmc_key_read(uint8_t *buffer,
+	uint32_t length, uint32_t *actual_lenth);
+int32_t emmc_key_write(uint8_t *buffer,
+	uint32_t length, uint32_t *actual_lenth);
 
 #endif
 
diff --git a/drivers/amlogic/pinctrl/Makefile b/drivers/amlogic/pinctrl/Makefile
index 5e33362..cab6740 100644
--- a/drivers/amlogic/pinctrl/Makefile
+++ b/drivers/amlogic/pinctrl/Makefile
@@ -2,10 +2,11 @@
 #Makefile for the gpio dirver
 #
 ifneq ($(CONFIG_ARM64),)
-obj-$(CONFIG_PINCTRL_AMLOGIC)+= pinctrl_amlogic.o  pinctrl_gxbb.o\
-				pinctrl_gxtvbb.o pinctrl_gxl.o sample_code.o
+obj-$(CONFIG_PINCTRL_AMLOGIC) += pinctrl_amlogic.o sample_code.o \
+                                 pinctrl_gxbb.o pinctrl_gxtvbb.o \
+                                 pinctrl_gxl.o pinctrl_txl.o
 
 else
-obj-$(CONFIG_PINCTRL_AMLOGIC)	+= pinctrl_amlogic.o sample_code.o \
-					pinctrl_m8.o
+obj-$(CONFIG_PINCTRL_AMLOGIC) += pinctrl_amlogic.o sample_code.o \
+                                 pinctrl_m8.o
 endif
diff --git a/drivers/amlogic/pinctrl/pinctrl_amlogic.c b/drivers/amlogic/pinctrl/pinctrl_amlogic.c
index c84dcd3..e34231d 100644
--- a/drivers/amlogic/pinctrl/pinctrl_amlogic.c
+++ b/drivers/amlogic/pinctrl/pinctrl_amlogic.c
@@ -927,6 +927,38 @@ static int meson_gpio_to_irq(struct gpio_chip *chip,
 			0x7<<start_bit, filter<<start_bit);
 	return 0;
 }
+static int meson_gpio_mask_irq(struct gpio_chip *chip,
+			     unsigned int gpio, unsigned gpio_flag)
+{
+	unsigned start_bit;
+	unsigned irq_bank = gpio_flag&0x7;
+	unsigned filter = (gpio_flag>>8)&0x7;
+	unsigned irq_type = (gpio_flag>>16)&0x3;
+	unsigned int pin;
+	unsigned type[] = {0x0,	/*GPIO_IRQ_HIGH*/
+				0x10000, /*GPIO_IRQ_LOW*/
+				0x1,	/*GPIO_IRQ_RISING*/
+				0x10001, /*GPIO_IRQ_FALLING*/
+				};
+	 /*set trigger type*/
+	 pin = 0xff;
+	 regmap_update_bits(int_reg, (GPIO_EDGE * 4),
+						0x10001<<irq_bank,
+						type[irq_type]<<irq_bank);
+	/*select pin*/
+	start_bit = (irq_bank&3)*8;
+	regmap_update_bits(int_reg,
+			irq_bank < 4?(GPIO_SELECT_0_3*4):(GPIO_SELECT_4_7*4),
+			0xff<<start_bit,
+			pin << start_bit);
+	/*set filter*/
+	start_bit = (irq_bank)*4;
+
+	regmap_update_bits(int_reg,  (GPIO_FILTER_NUM*4),
+			0x7<<start_bit, filter<<start_bit);
+	return 0;
+}
+
 struct pinctrl_dev *pctl;
 static int meson_gpiolib_register(struct amlogic_pmx  *pc)
 {
@@ -946,6 +978,7 @@ static int meson_gpiolib_register(struct amlogic_pmx  *pc)
 		domain->chip.set = meson_gpio_set;
 		domain->chip.set_pullup_down = meson_gpio_set_pullup_down;
 		domain->chip.set_gpio_to_irq = meson_gpio_to_irq;
+		domain->chip.mask_gpio_irq = meson_gpio_mask_irq;
 		domain->chip.base = -1;
 		domain->chip.ngpio = domain->data->num_pins;
 		domain->chip.can_sleep = false;
diff --git a/drivers/amlogic/pinctrl/pinctrl_txl.c b/drivers/amlogic/pinctrl/pinctrl_txl.c
new file mode 100644
index 0000000..2e7b81d
--- /dev/null
+++ b/drivers/amlogic/pinctrl/pinctrl_txl.c
@@ -0,0 +1,584 @@
+/*
+ * drivers/amlogic/pinctrl/pinctrl_txl.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/amlogic/pinctrl_amlogic.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_address.h>
+#include <linux/amlogic/gpio-amlogic.h>
+#include <dt-bindings/gpio/txl.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/uaccess.h>
+
+#include "pinconf-amlogic.h"
+#include "pinctrl_txl.h"
+
+
+struct pinctrl_pin_desc pmx_pins[] = {
+	PINCTRL_PIN(PIN_GPIOAO_0,	"GPIOAO_0"),
+	PINCTRL_PIN(PIN_GPIOAO_1,	"GPIOAO_1"),
+	PINCTRL_PIN(PIN_GPIOAO_2,	"GPIOAO_2"),
+	PINCTRL_PIN(PIN_GPIOAO_3,	"GPIOAO_3"),
+	PINCTRL_PIN(PIN_GPIOAO_4,	"GPIOAO_4"),
+	PINCTRL_PIN(PIN_GPIOAO_5,	"GPIOAO_5"),
+	PINCTRL_PIN(PIN_GPIOAO_6,	"GPIOAO_6"),
+	PINCTRL_PIN(PIN_GPIOAO_7,	"GPIOAO_7"),
+	PINCTRL_PIN(PIN_GPIOAO_8,	"GPIOAO_8"),
+	PINCTRL_PIN(PIN_GPIOAO_9,	"GPIOAO_9"),
+	PINCTRL_PIN(PIN_GPIOAO_10,	"GPIOAO_10"),
+	PINCTRL_PIN(PIN_GPIOAO_11,	"GPIOAO_11"),
+
+	PINCTRL_PIN(PIN_GPIOZ_0,	"GPIOZ_0"),
+	PINCTRL_PIN(PIN_GPIOZ_1,	"GPIOZ_1"),
+	PINCTRL_PIN(PIN_GPIOZ_2,	"GPIOZ_2"),
+	PINCTRL_PIN(PIN_GPIOZ_3,	"GPIOZ_3"),
+	PINCTRL_PIN(PIN_GPIOZ_4,	"GPIOZ_4"),
+	PINCTRL_PIN(PIN_GPIOZ_5,	"GPIOZ_5"),
+	PINCTRL_PIN(PIN_GPIOZ_6,	"GPIOZ_6"),
+	PINCTRL_PIN(PIN_GPIOZ_7,	"GPIOZ_7"),
+	PINCTRL_PIN(PIN_GPIOZ_8,	"GPIOZ_8"),
+	PINCTRL_PIN(PIN_GPIOZ_9,	"GPIOZ_9"),
+	PINCTRL_PIN(PIN_GPIOZ_10,	"GPIOZ_10"),
+	PINCTRL_PIN(PIN_GPIOZ_11,	"GPIOZ_11"),
+	PINCTRL_PIN(PIN_GPIOZ_12,	"GPIOZ_12"),
+	PINCTRL_PIN(PIN_GPIOZ_13,	"GPIOZ_13"),
+	PINCTRL_PIN(PIN_GPIOZ_14,	"GPIOZ_14"),
+	PINCTRL_PIN(PIN_GPIOZ_15,	"GPIOZ_15"),
+	PINCTRL_PIN(PIN_GPIOZ_16,	"GPIOZ_16"),
+	PINCTRL_PIN(PIN_GPIOZ_17,	"GPIOZ_17"),
+	PINCTRL_PIN(PIN_GPIOZ_18,	"GPIOZ_18"),
+	PINCTRL_PIN(PIN_GPIOZ_19,	"GPIOZ_19"),
+	PINCTRL_PIN(PIN_GPIOZ_20,	"GPIOZ_20"),
+	PINCTRL_PIN(PIN_GPIOZ_21,	"GPIOZ_21"),
+
+	PINCTRL_PIN(PIN_GPIOH_0,	"GPIOH_0"),
+	PINCTRL_PIN(PIN_GPIOH_1,	"GPIOH_1"),
+	PINCTRL_PIN(PIN_GPIOH_2,	"GPIOH_2"),
+	PINCTRL_PIN(PIN_GPIOH_3,	"GPIOH_3"),
+	PINCTRL_PIN(PIN_GPIOH_4,	"GPIOH_4"),
+	PINCTRL_PIN(PIN_GPIOH_5,	"GPIOH_5"),
+	PINCTRL_PIN(PIN_GPIOH_6,	"GPIOH_6"),
+	PINCTRL_PIN(PIN_GPIOH_7,	"GPIOH_7"),
+	PINCTRL_PIN(PIN_GPIOH_8,	"GPIOH_8"),
+	PINCTRL_PIN(PIN_GPIOH_9,	"GPIOH_9"),
+
+	PINCTRL_PIN(PIN_BOOT_0,		"BOOT_0"),
+	PINCTRL_PIN(PIN_BOOT_1,		"BOOT_1"),
+	PINCTRL_PIN(PIN_BOOT_2,		"BOOT_2"),
+	PINCTRL_PIN(PIN_BOOT_3,		"BOOT_3"),
+	PINCTRL_PIN(PIN_BOOT_4,		"BOOT_4"),
+	PINCTRL_PIN(PIN_BOOT_5,		"BOOT_5"),
+	PINCTRL_PIN(PIN_BOOT_6,		"BOOT_6"),
+	PINCTRL_PIN(PIN_BOOT_7,		"BOOT_7"),
+	PINCTRL_PIN(PIN_BOOT_8,		"BOOT_8"),
+	PINCTRL_PIN(PIN_BOOT_9,		"BOOT_9"),
+	PINCTRL_PIN(PIN_BOOT_10,	"BOOT_10"),
+	PINCTRL_PIN(PIN_BOOT_11,	"BOOT_11"),
+
+	PINCTRL_PIN(PIN_CARD_0,		"CARD_0"),
+	PINCTRL_PIN(PIN_CARD_1,		"CARD_1"),
+	PINCTRL_PIN(PIN_CARD_2,		"CARD_2"),
+	PINCTRL_PIN(PIN_CARD_3,		"CARD_3"),
+	PINCTRL_PIN(PIN_CARD_4,		"CARD_4"),
+	PINCTRL_PIN(PIN_CARD_5,		"CARD_5"),
+	PINCTRL_PIN(PIN_CARD_6,		"CARD_6"),
+
+	PINCTRL_PIN(PIN_GPIODV_0,	"GPIODV_0"),
+	PINCTRL_PIN(PIN_GPIODV_1,	"GPIODV_1"),
+	PINCTRL_PIN(PIN_GPIODV_2,	"GPIODV_2"),
+	PINCTRL_PIN(PIN_GPIODV_3,	"GPIODV_3"),
+	PINCTRL_PIN(PIN_GPIODV_4,	"GPIODV_4"),
+	PINCTRL_PIN(PIN_GPIODV_5,	"GPIODV_5"),
+	PINCTRL_PIN(PIN_GPIODV_6,	"GPIODV_6"),
+	PINCTRL_PIN(PIN_GPIODV_7,	"GPIODV_7"),
+	PINCTRL_PIN(PIN_GPIODV_8,	"GPIODV_8"),
+	PINCTRL_PIN(PIN_GPIODV_9,	"GPIODV_9"),
+	PINCTRL_PIN(PIN_GPIODV_10,	"GPIODV_10"),
+	PINCTRL_PIN(PIN_GPIODV_11,	"GPIODV_11"),
+
+	PINCTRL_PIN(PIN_GPIOW_0,	"GPIOW_0"),
+	PINCTRL_PIN(PIN_GPIOW_1,	"GPIOW_1"),
+	PINCTRL_PIN(PIN_GPIOW_2,	"GPIOW_2"),
+	PINCTRL_PIN(PIN_GPIOW_3,	"GPIOW_3"),
+	PINCTRL_PIN(PIN_GPIOW_4,	"GPIOW_4"),
+	PINCTRL_PIN(PIN_GPIOW_5,	"GPIOW_5"),
+	PINCTRL_PIN(PIN_GPIOW_6,	"GPIOW_6"),
+	PINCTRL_PIN(PIN_GPIOW_7,	"GPIOW_7"),
+	PINCTRL_PIN(PIN_GPIOW_8,	"GPIOW_8"),
+	PINCTRL_PIN(PIN_GPIOW_9,	"GPIOW_9"),
+	PINCTRL_PIN(PIN_GPIOW_10,	"GPIOW_10"),
+	PINCTRL_PIN(PIN_GPIOW_11,	"GPIOW_11"),
+	PINCTRL_PIN(PIN_GPIOW_12,	"GPIOW_12"),
+	PINCTRL_PIN(PIN_GPIOW_13,	"GPIOW_13"),
+	PINCTRL_PIN(PIN_GPIOW_14,	"GPIOW_14"),
+	PINCTRL_PIN(PIN_GPIOW_15,	"GPIOW_15"),
+
+	PINCTRL_PIN(PIN_GPIOCLK_0,	"GPIOCLK_0"),
+	PINCTRL_PIN(PIN_GPIOCLK_1,	"GPIOCLK_1"),
+
+	PINCTRL_PIN(PIN_GPIO_TEST_N,	"GPIO_TEST_N"),
+
+	PINCTRL_PIN(PIN_GPIO_USB_DPDM,	"GPIO_USB_DPDM"),
+	PINCTRL_PIN(PIN_GPIO_USB_DMDP,	"GPIO_USB_DMDP"),
+
+};
+
+
+/* name		first			last
+ *		pullen_reg_idx		start_bit
+ *		pullup_reg_idx		start_bit
+ *		gpio_dir_reg_idx	start_bit
+ *		gpio_out_reg_idx	start_bit
+ *		gpio_in_reg_idx		start_bit
+ */
+static struct meson_bank pmx_ao_banks[] = {
+	BANK("AO",	PIN_GPIOAO_0,		PIN_GPIOAO_11,
+			GPIO_AO_PULL_EN_REG0,	GPIO_AO_PULL_EN_REG0_BIT0,
+			GPIO_AO_PULL_UP_REG0,	GPIO_AO_PULL_UP_REG0_BIT16,
+			GPIO_AO_D_REG0,		GPIO_AO_D_REG0_BIT0,
+			GPIO_AO_O_REG0,		GPIO_AO_O_REG0_BIT16,
+			GPIO_AO_I_REG1,		GPIO_AO_I_REG1_BIT0),
+};
+
+static struct meson_bank pmx_ee_banks[] = {
+	BANK("Z",	PIN_GPIOZ_0,	PIN_GPIOZ_21,
+			PULL_EN_REG3,	0,
+			PULL_UP_REG3,	0,
+			GPIO_D_REG3,	0,
+			GPIO_O_REG3,	0,
+			GPIO_I_REG3,	0),
+
+	BANK("H",	PIN_GPIOH_0,	PIN_GPIOH_9,
+			PULL_EN_REG1,	20,
+			PULL_UP_REG1,	20,
+			GPIO_D_REG1,	20,
+			GPIO_O_REG1,	20,
+			GPIO_I_REG1,	20),
+
+	BANK("BOOT",	PIN_BOOT_0,	PIN_BOOT_11,
+			PULL_EN_REG2,	0,
+			PULL_UP_REG1,	0,
+			GPIO_D_REG2,	0,
+			GPIO_O_REG2,	0,
+			GPIO_I_REG2,	0),
+
+	BANK("CARD",	PIN_CARD_0,	PIN_CARD_6,
+			PULL_EN_REG2,	20,
+			PULL_UP_REG1,	20,
+			GPIO_D_REG2,	20,
+			GPIO_O_REG2,	20,
+			GPIO_I_REG2,	20),
+
+	BANK("DV",	PIN_GPIODV_0,	PIN_GPIODV_11,
+			PULL_EN_REG0,	0,
+			PULL_UP_REG0,	0,
+			GPIO_D_REG0,	0,
+			GPIO_O_REG0,	0,
+			GPIO_I_REG0,	0),
+
+	BANK("W",	PIN_GPIOW_0,	PIN_GPIOW_15,
+			PULL_EN_REG4,	0,
+			PULL_UP_REG4,	0,
+			GPIO_D_REG4,	0,
+			GPIO_O_REG4,	0,
+			GPIO_I_REG4,	0),
+
+	BANK("CLK",	PIN_GPIOCLK_0,	PIN_GPIOCLK_1,
+			PULL_EN_REG3,	28,
+			PULL_UP_REG3,	28,
+			GPIO_D_REG3,	28,
+			GPIO_O_REG3,	28,
+			GPIO_I_REG3,	28),
+};
+
+static struct meson_domain_data pmx_domain_data[] = {
+	{
+		.name		= "banks",
+		.banks		= pmx_ee_banks,
+		.num_banks	= ARRAY_SIZE(pmx_ee_banks),
+		.pin_base	= PIN_EE_BASE,
+		.num_pins	= PIN_EE_SIZE,
+	},
+	{
+		.name		= "ao-bank",
+		.banks		= pmx_ao_banks,
+		.num_banks	= ARRAY_SIZE(pmx_ao_banks),
+		.pin_base	= PIN_AO_BASE,
+		.num_pins	= PIN_AO_SIZE,
+	},
+
+};
+
+
+static unsigned int pmx_pinmuxes[][PMX_FUNCTION_NUM] = {
+	[PIN_GPIOAO_0]  = {PA(0, 12), PA(0, 26), NA,        NA,        NA,},
+	[PIN_GPIOAO_1]  = {PA(0, 11), PA(0, 25), NA,        NA,        NA,},
+	[PIN_GPIOAO_2]  = {PA(0, 10), PA(0, 8),  PA(0, 28), NA,        NA,},
+	[PIN_GPIOAO_3]  = {PA(0, 9),  PA(0, 7),  NA,        PA(0, 22), PJ(0),},
+	[PIN_GPIOAO_4]  = {PA(0, 24), PA(0, 6),  PA(0, 2),  NA,        PJ(0),},
+	[PIN_GPIOAO_5]  = {PA(0, 23), PA(0, 5),  PA(0, 1),  NA,        PJ(0),},
+	[PIN_GPIOAO_6]  = {PA(0, 0),  PA(0, 21), NA,        NA,        NA,},
+	[PIN_GPIOAO_7]  = {PA(0, 15), PA(0, 14), PA(0, 17), NA,        PJ(0),},
+	[PIN_GPIOAO_8]  = {NA,        PA(0, 27), NA,        NA,        NA,},
+	[PIN_GPIOAO_9]  = {NA,        PA(0, 3),  NA,        NA,        NA,},
+	[PIN_GPIOAO_10] = {NA,        NA,        NA,        NA,        NA,},
+	[PIN_GPIOAO_11] = {NA,        NA,        NA,        NA,        NA,},
+
+
+	[PIN_GPIODV_0]  = {PE(2, 25), NA,        NA,        PE(2, 31), NA,},
+	[PIN_GPIODV_1]  = {PE(2, 24), NA,        NA,        PE(2, 31), NA,},
+	[PIN_GPIODV_2]  = {PE(2, 22), PE(2, 23), PE(2, 20), PE(2, 31),
+								PE(2, 19),},
+	[PIN_GPIODV_3]  = {PE(2, 18), PE(2, 21), NA,        PE(2, 31),
+								PE(2, 17),},
+	[PIN_GPIODV_4]  = {PE(2, 16), NA,        NA,        PE(2, 31), NA,},
+	[PIN_GPIODV_5]  = {PE(2, 15), NA,        NA,        PE(2, 31), NA,},
+	[PIN_GPIODV_6]  = {NA,        PE(2, 8),  NA,        PE(2, 31), NA,},
+	[PIN_GPIODV_7]  = {NA,        PE(2, 7),  PE(2, 4),  PE(2, 30), NA,},
+	[PIN_GPIODV_8]  = {PE(2, 14), PE(2, 6),	 PE(2, 3),  PE(2, 29), NA,},
+	[PIN_GPIODV_9]  = {PE(2, 13), PE(2, 5),	 NA,        PE(2, 28), NA,},
+	[PIN_GPIODV_10] = {PE(2, 12), PE(2, 10), PE(2, 2),  PE(2, 27), NA,},
+	[PIN_GPIODV_11] = {PE(2, 11), PE(2, 9),  PE(2, 1),  PE(2, 26),
+								PE(2, 0),},
+
+	[PIN_CARD_0] = {PE(6, 5), PJ(1),    NA,        PE(6, 15), PE(6, 31),},
+	[PIN_CARD_1] = {PE(6, 4), PJ(1),    NA,        PE(6, 14), PE(6, 30),},
+	[PIN_CARD_2] = {PE(6, 3), PJ(1),    NA,        PE(6, 13), PE(6, 29),},
+	[PIN_CARD_3] = {PE(6, 2), PJ(1),    NA,        PE(6, 12), PE(6, 28),},
+	[PIN_CARD_4] = {PE(6, 0), PE(6, 9), PE(6, 11), NA,        PE(6, 27),},
+	[PIN_CARD_5] = {PE(6, 1), PE(6, 8), PE(6, 10), NA,        PE(6, 26),},
+	[PIN_CARD_6] = {NA,       NA,       NA,        NA,        NA,},
+
+	[PIN_GPIOH_0] = {PE(0, 31), NA,        NA,        NA, NA,},
+	[PIN_GPIOH_1] = {PE(0, 30), NA,        NA,        NA, NA,},
+	[PIN_GPIOH_2] = {PE(0, 29), NA,        NA,        NA, NA,},
+	[PIN_GPIOH_3] = {PE(0, 28), NA,        NA,        NA, NA,},
+	[PIN_GPIOH_4] = {PE(0, 27), PE(0, 26), NA,        NA, NA,},
+	[PIN_GPIOH_5] = {NA,        NA,        PE(0, 18), NA, NA,},
+	[PIN_GPIOH_6] = {NA,        NA,        PE(0, 17), NA, NA,},
+	[PIN_GPIOH_7] = {NA,        NA,        PE(0, 16), NA, NA,},
+	[PIN_GPIOH_8] = {NA,        PE(0, 13), PE(0, 15), NA, NA,},
+	[PIN_GPIOH_9] = {PE(0, 12), NA,        PE(0, 14), NA, NA,},
+
+	[PIN_BOOT_0]  = {PE(7, 31), NA,        NA,        NA,        NA,},
+	[PIN_BOOT_1]  = {PE(7, 31), NA,        NA,        NA,        NA,},
+	[PIN_BOOT_2]  = {PE(7, 31), NA,        NA,        NA,        NA,},
+	[PIN_BOOT_3]  = {PE(7, 31), NA,        NA,        PE(7, 23), NA,},
+	[PIN_BOOT_4]  = {PE(7, 31), PE(7, 13), NA,        PE(7, 22), NA,},
+	[PIN_BOOT_5]  = {PE(7, 31), PE(7, 12), NA,        PE(7, 21), NA,},
+	[PIN_BOOT_6]  = {PE(7, 31), PE(7, 11), NA,        PE(7, 20), NA,},
+	[PIN_BOOT_7]  = {PE(7, 31), NA,        NA,        PE(7, 19), NA,},
+	[PIN_BOOT_8]  = {PE(7, 30), NA,        NA,        NA,        NA,},
+	[PIN_BOOT_9]  = {NA,        NA,        NA,        NA,        NA,},
+	[PIN_BOOT_10] = {PE(7, 29), NA,        NA,        NA,        NA,},
+	[PIN_BOOT_11] = {PE(7, 28), PE(7, 10), NA,        NA,        NA,},
+
+
+	[PIN_GPIOZ_0]  = {PE(4, 31), PE(4, 25), NA,        PE(3, 21),
+								PE(3, 16),},
+	[PIN_GPIOZ_1]  = {PE(4, 30), PE(4, 24), NA,        PE(3, 21),
+								PE(3, 15),},
+	[PIN_GPIOZ_2]  = {PE(4, 29), PE(4, 23), PE(4, 21), PE(3, 21),
+								PE(3, 14),},
+	[PIN_GPIOZ_3]  = {PE(4, 28), PE(4, 22), PE(4, 20), PE(3, 21),
+								PE(3, 13),},
+	[PIN_GPIOZ_4]  = {PE(4, 27), PE(4, 19), PE(4, 18), PE(3, 21), NA,},
+	[PIN_GPIOZ_5]  = {PE(4, 26), PE(4, 17), NA,        PE(3, 21), NA,},
+	[PIN_GPIOZ_6]  = {PE(4, 16), PE(4, 15), NA,        PE(3, 21), NA,},
+	[PIN_GPIOZ_7]  = {PE(4, 14), PE(4, 13), NA,        PE(3, 21), NA,},
+	[PIN_GPIOZ_8]  = {PE(4, 12), NA,        NA,        PE(3, 21), NA,},
+	[PIN_GPIOZ_9]  = {PE(4, 11), NA,        NA,        PE(3, 21), NA,},
+	[PIN_GPIOZ_10] = {PE(4, 10), NA,        PE(3, 20), PE(3, 21), NA,},
+	[PIN_GPIOZ_11] = {PE(4, 9),  PE(4, 3),  PE(3, 19), PE(3, 21), NA,},
+	[PIN_GPIOZ_12] = {PE(4, 8),  PE(4, 2),  PE(3, 18), PE(3, 21), NA,},
+	[PIN_GPIOZ_13] = {NA,        PE(4, 1),  PE(3, 17), PE(3, 21), NA,},
+	[PIN_GPIOZ_14] = {PE(4, 7),  NA,        NA,        PE(3, 21), NA,},
+	[PIN_GPIOZ_15] = {PE(4, 6),  NA,        PE(3, 25), PE(3, 21), NA,},
+	[PIN_GPIOZ_16] = {PE(4, 5),  PE(3, 31), PE(3, 24), PE(3, 21), NA,},
+	[PIN_GPIOZ_17] = {PE(3, 22), NA,        NA,        PE(3, 21), NA,},
+	[PIN_GPIOZ_18] = {PE(3, 22), PE(4, 4),  PE(3, 23), NA,        NA,},
+	[PIN_GPIOZ_19] = {PE(3, 22), PE(3, 27), PE(3, 22), PE(3, 26), NA,},
+	[PIN_GPIOZ_20] = {NA,        NA,        NA,        NA,        NA,},
+	[PIN_GPIOZ_21] = {NA,        NA,        NA,        NA,        NA,},
+
+	[PIN_GPIOW_0]  = {PE(5, 31), NA,        NA, NA, NA,},
+	[PIN_GPIOW_1]  = {PE(5, 30), NA,        NA, NA, NA,},
+	[PIN_GPIOW_2]  = {PE(5, 29), PE(5, 15), NA, NA, NA,},
+	[PIN_GPIOW_3]  = {PE(5, 28), PE(5, 14), NA, NA, NA,},
+	[PIN_GPIOW_4]  = {PE(5, 27), NA,        NA, NA, NA,},
+	[PIN_GPIOW_5]  = {PE(5, 26), NA,        NA, NA, NA,},
+	[PIN_GPIOW_6]  = {PE(5, 25), PE(5, 13), NA, NA, NA,},
+	[PIN_GPIOW_7]  = {PE(5, 24), PE(5, 12), NA, NA, NA,},
+	[PIN_GPIOW_8]  = {PE(5, 23), NA,        NA, NA, NA,},
+	[PIN_GPIOW_9]  = {PE(5, 22), NA,        NA, NA, NA,},
+	[PIN_GPIOW_10] = {PE(5, 21), PE(5, 11), NA, NA, NA,},
+	[PIN_GPIOW_11] = {PE(5, 20), PE(5, 10), NA, NA, NA,},
+	[PIN_GPIOW_12] = {PE(5, 19), NA,        NA, NA, NA,},
+	[PIN_GPIOW_13] = {PE(5, 18), NA,        NA, NA, NA,},
+	[PIN_GPIOW_14] = {PE(5, 17), PE(5, 9),  NA, NA, NA,},
+	[PIN_GPIOW_15] = {PE(5, 16), PE(5, 8),  NA, NA, NA,},
+
+	[PIN_GPIOCLK_0] = {PC(10), PC(11),    PE(8, 31), PE(8, 28), NA,},
+	[PIN_GPIOCLK_1] = {PC(12), PE(8, 30), PE(8, 29), PE(8, 27), NA,},
+
+	[PIN_GPIO_TEST_N] = {PA(0, 20), NA, NA, NA, NA,},
+};
+
+static int pmx_gpio_name_to_pin(const char *name)
+{
+	int i, tmp = 100, num = 0;
+	int len = 0;
+	char *p = NULL;
+	char *start = NULL;
+
+	if (!name)
+		return -1;
+
+	if (!strcmp(name, "GPIO_TEST_N"))
+		return PIN_GPIO_TEST_N;
+	if (!strcmp(name, "GPIO_USB_DPDM"))
+		return PIN_GPIO_USB_DPDM;
+	if (!strcmp(name, "GPIO_USB_DMDP"))
+		return PIN_GPIO_USB_DMDP;
+
+	len = strlen(name);
+	p = kzalloc(len+1, GFP_KERNEL);
+	start = p;
+	if (!p) {
+		pr_info("%s:malloc error\n", __func__);
+		return -1;
+	}
+	p = strcpy(p, name);
+	for (i = 0; i < len; p++, i++) {
+		if (*p == '_') {
+			*p = '\0';
+			tmp = i;
+		}
+		if (i > tmp && *p >= '0' && *p <= '9')
+			num = num*10 + *p-'0';
+	}
+	p = start;
+	if (!strcmp(p, "GPIOAO"))
+		num = num + PIN_AO_BASE;
+	else if (!strcmp(p, "GPIOZ"))
+		num = num + PIN_GPIOZ_BASE;
+	else if (!strcmp(p, "GPIOH"))
+		num = num + PIN_GPIOH_BASE;
+	else if (!strcmp(p, "BOOT"))
+		num = num + PIN_BOOT_BASE;
+	else if (!strcmp(p, "CARD"))
+		num = num + PIN_CARD_BASE;
+	else if (!strcmp(p, "GPIODV"))
+		num = num + PIN_GPIODV_BASE;
+	else if (!strcmp(p, "GPIOW"))
+		num = num + PIN_GPIOW_BASE;
+	else if (!strcmp(p, "GPIOCLK"))
+		num = num + PIN_GPIOCLK_BASE;
+	else
+		num = -1;
+	kzfree(start);
+	return num;
+}
+
+
+static int  pmx_clear_pinmux(struct amlogic_pmx *apmx, unsigned int pin)
+{
+	int i, reg, bit, ret = 0;
+	struct meson_domain *dom = NULL;
+	unsigned int v;
+	unsigned int type;
+	unsigned int sel;
+
+	for (i = 0; i < PMX_FUNCTION_NUM; i++) {
+		v = pmx_pinmuxes[pin][i];
+
+		if (v == NA)
+			continue;
+
+		type = PMX_TYP(v);
+
+		switch (type) {
+		case PMX_TYPE_EE:
+			reg = PMX_REG(v);
+			bit = PMX_BIT(v);
+			dom = &apmx->domains[0];
+			ret = regmap_update_bits(dom->reg_mux,
+				reg*4, BIT(bit), 0);
+			break;
+
+		case PMX_TYPE_AO:
+			reg = PMX_AO_REG(v);
+			bit = PMX_AO_BIT(v);
+			dom = &apmx->domains[1];
+			ret = regmap_update_bits(dom->reg_mux,
+				reg*4, BIT(bit), 0);
+			break;
+
+		case PMX_TYPE_JTAG:
+			sel = PMX_JTAG(v);
+			/* @todo clear jtag reg */
+			break;
+
+		case PMX_TYPE_CLK:
+			bit = PMX_CLK_BIT(v);
+			/* @todo clear clk reg */
+			break;
+
+		default:
+			ret = -EINVAL;
+			break;
+		}
+	}
+	return ret;
+}
+
+
+#ifdef CONFIG_ARM64
+
+/*
+ * function id 0x82000046 is to set AO_SEC_REG0 bit[0] in bl31.
+ * bit[0] is set with arg0.
+ * 0: gpio input 1: gpio output
+ *
+ * this function supported by xing.xu@amlogic.com
+ */
+static noinline int __invoke_psci_fn_smc(u64 function_id, u64 arg0, u64 arg1,
+					 u64 arg2)
+{
+	register long x0 asm("x0") = function_id;
+	register long x1 asm("x1") = arg0;
+	register long x2 asm("x2") = arg1;
+	register long x3 asm("x3") = arg2;
+	asm volatile(
+			__asmeq("%0", "x0")
+			__asmeq("%1", "x1")
+			__asmeq("%2", "x2")
+			__asmeq("%3", "x3")
+			"smc	#0\n"
+		: "+r" (x0)
+		: "r" (x1), "r" (x2), "r" (x3));
+
+	return function_id;
+}
+
+#else
+
+static noinline int __invoke_psci_fn_smc(u64 function_id, u64 arg0, u64 arg1,
+					 u64 arg2)
+{
+	return 0;
+}
+
+#endif /* CONFIG_ARM64 */
+
+/*
+ * AO_GPIO_O_EN_N	0x09<<2=0x24	bit[31]		output level
+ * AO_GPIO_I		0x0a<<2=0x28	bit[31]		input level
+ * AO_SEC_REG0		0x50<<2=0x140	bit[0]		input enable
+ * AO_SEC_REG0		0xda100000+0x140=0xda100140
+ * AO_RTI_PULL_UP_REG	0x0b<<2=0x2c	bit[30]		pull-up/down
+ * AO_RTI_PULL_UP_REG	0x0b<<2=0x2c	bit[14]		pull-up enable
+ */
+static int pmx_extern_gpio_output(struct meson_domain *domain,
+				   unsigned int pin,
+				   int value)
+{
+	if (PIN_GPIO_TEST_N == pin) {
+		pr_info("%s PIN_GPIO_TEST_N\n", __func__);
+
+		/* set TEST_N to gpio output */
+		/* AO_SEC_REG0 bit[0] = 1 */
+		__invoke_psci_fn_smc(0x82000046, 1, 0, 0);
+
+		/* set TEST_N output level to #value */
+		aml_aobus_update_bits(0x24, BIT(31), value ? BIT(31) : 0);
+		return 0;
+	}
+	return 1;
+}
+int pmx_extern_gpio_get(struct meson_domain *domain, unsigned int pin)
+{
+	if (PIN_GPIO_TEST_N == pin)
+		return !!(aml_read_aobus(0x24) & BIT(31));
+
+	return -1;
+}
+
+static struct amlogic_pinctrl_soc_data pmx_pinctrl_data = {
+	.pins = pmx_pins,
+	.npins = ARRAY_SIZE(pmx_pins),
+	.domain_data = pmx_domain_data,
+	.num_domains = ARRAY_SIZE(pmx_domain_data),
+	.meson_clear_pinmux = pmx_clear_pinmux,
+	.name_to_pin = pmx_gpio_name_to_pin,
+	.soc_extern_gpio_output = pmx_extern_gpio_output,
+	.soc_extern_gpio_get = pmx_extern_gpio_get,
+};
+
+static struct of_device_id pmx_pinctrl_of_table[] = {
+	{
+		.compatible = "amlogic, pinmux-txl",
+	},
+	{},
+};
+
+static int  pmx_probe(struct platform_device *pdev)
+{
+	return amlogic_pmx_probe(pdev, &pmx_pinctrl_data);
+}
+
+static int  pmx_remove(struct platform_device *pdev)
+{
+	return amlogic_pmx_remove(pdev);
+}
+
+static struct platform_driver pmx_driver = {
+	.driver = {
+		.name = "pinmux-txl",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(pmx_pinctrl_of_table),
+	},
+	.probe = pmx_probe,
+	.remove = pmx_remove,
+};
+
+static int __init pmx_init(void)
+{
+	return platform_driver_register(&pmx_driver);
+}
+arch_initcall(pmx_init);
+
+static void __exit pmx_exit(void)
+{
+	platform_driver_unregister(&pmx_driver);
+}
+module_exit(pmx_exit);
+
+MODULE_DESCRIPTION("txl pin control driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/amlogic/pinctrl/pinctrl_txl.h b/drivers/amlogic/pinctrl/pinctrl_txl.h
new file mode 100644
index 0000000..5dd05ea
--- /dev/null
+++ b/drivers/amlogic/pinctrl/pinctrl_txl.h
@@ -0,0 +1,333 @@
+/*
+ * drivers/amlogic/pinctrl/pinctrl_txl.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __AMLOGIC_PINCTRL_TXL_H
+#define __AMLOGIC_PINCTRL_TXL_H
+
+#include <dt-bindings/gpio/txl.h>
+
+#define PIN_AO_BASE		(0)
+#define PIN_AO_SIZE		(12)
+#define PIN_EE_BASE		(PIN_AO_BASE + PIN_AO_SIZE)
+
+#define PIN_AO(g)		(PIN_AO_BASE + g)
+#define PIN_EE(g)		(PIN_EE_BASE + g)
+
+/* pin gpiozo */
+#define	PIN_GPIOAO_BASE		(PIN_AO_BASE)
+#define	PIN_GPIOAO_SIZE		(12)
+#define	PIN_GPIOAO_0		PIN_AO(GPIOAO_0)
+#define	PIN_GPIOAO_1		PIN_AO(GPIOAO_1)
+#define	PIN_GPIOAO_2		PIN_AO(GPIOAO_2)
+#define	PIN_GPIOAO_3		PIN_AO(GPIOAO_3)
+#define	PIN_GPIOAO_4		PIN_AO(GPIOAO_4)
+#define	PIN_GPIOAO_5		PIN_AO(GPIOAO_5)
+#define	PIN_GPIOAO_6		PIN_AO(GPIOAO_6)
+#define	PIN_GPIOAO_7		PIN_AO(GPIOAO_7)
+#define	PIN_GPIOAO_8		PIN_AO(GPIOAO_8)
+#define	PIN_GPIOAO_9		PIN_AO(GPIOAO_9)
+#define	PIN_GPIOAO_10		PIN_AO(GPIOAO_10)
+#define	PIN_GPIOAO_11		PIN_AO(GPIOAO_11)
+
+/* pin gpioz */
+/* pin gpioz based on pin gpioao, but gpioz based on zero */
+#define	PIN_GPIOZ_BASE		(PIN_GPIOAO_BASE + PIN_GPIOAO_SIZE)
+#define	PIN_GPIOZ_SIZE		(22)
+#define	PIN_GPIOZ_0		PIN_EE(GPIOZ_0)
+#define	PIN_GPIOZ_1		PIN_EE(GPIOZ_1)
+#define	PIN_GPIOZ_2		PIN_EE(GPIOZ_2)
+#define	PIN_GPIOZ_3		PIN_EE(GPIOZ_3)
+#define	PIN_GPIOZ_4		PIN_EE(GPIOZ_4)
+#define	PIN_GPIOZ_5		PIN_EE(GPIOZ_5)
+#define	PIN_GPIOZ_6		PIN_EE(GPIOZ_6)
+#define	PIN_GPIOZ_7		PIN_EE(GPIOZ_7)
+#define	PIN_GPIOZ_8		PIN_EE(GPIOZ_8)
+#define	PIN_GPIOZ_9		PIN_EE(GPIOZ_9)
+#define	PIN_GPIOZ_10		PIN_EE(GPIOZ_10)
+#define	PIN_GPIOZ_11		PIN_EE(GPIOZ_11)
+#define	PIN_GPIOZ_12		PIN_EE(GPIOZ_12)
+#define	PIN_GPIOZ_13		PIN_EE(GPIOZ_13)
+#define	PIN_GPIOZ_14		PIN_EE(GPIOZ_14)
+#define	PIN_GPIOZ_15		PIN_EE(GPIOZ_15)
+#define	PIN_GPIOZ_16		PIN_EE(GPIOZ_16)
+#define	PIN_GPIOZ_17		PIN_EE(GPIOZ_17)
+#define	PIN_GPIOZ_18		PIN_EE(GPIOZ_18)
+#define	PIN_GPIOZ_19		PIN_EE(GPIOZ_19)
+#define	PIN_GPIOZ_20		PIN_EE(GPIOZ_20)
+#define	PIN_GPIOZ_21		PIN_EE(GPIOZ_21)
+
+/* pin gpioh */
+#define	PIN_GPIOH_BASE		(PIN_GPIOZ_BASE + PIN_GPIOZ_SIZE)
+#define	PIN_GPIOH_SIZE		(10)
+#define	PIN_GPIOH_0		PIN_EE(GPIOH_0)
+#define	PIN_GPIOH_1		PIN_EE(GPIOH_1)
+#define	PIN_GPIOH_2		PIN_EE(GPIOH_2)
+#define	PIN_GPIOH_3		PIN_EE(GPIOH_3)
+#define	PIN_GPIOH_4		PIN_EE(GPIOH_4)
+#define	PIN_GPIOH_5		PIN_EE(GPIOH_5)
+#define	PIN_GPIOH_6		PIN_EE(GPIOH_6)
+#define	PIN_GPIOH_7		PIN_EE(GPIOH_7)
+#define	PIN_GPIOH_8		PIN_EE(GPIOH_8)
+#define	PIN_GPIOH_9		PIN_EE(GPIOH_9)
+
+/* pin boot */
+#define	PIN_BOOT_BASE		(PIN_GPIOH_BASE + PIN_GPIOH_SIZE)
+#define	PIN_BOOT_SIZE		(12)
+#define	PIN_BOOT_0		PIN_EE(BOOT_0)
+#define	PIN_BOOT_1		PIN_EE(BOOT_1)
+#define	PIN_BOOT_2		PIN_EE(BOOT_2)
+#define	PIN_BOOT_3		PIN_EE(BOOT_3)
+#define	PIN_BOOT_4		PIN_EE(BOOT_4)
+#define	PIN_BOOT_5		PIN_EE(BOOT_5)
+#define	PIN_BOOT_6		PIN_EE(BOOT_6)
+#define	PIN_BOOT_7		PIN_EE(BOOT_7)
+#define	PIN_BOOT_8		PIN_EE(BOOT_8)
+#define	PIN_BOOT_9		PIN_EE(BOOT_9)
+#define	PIN_BOOT_10		PIN_EE(BOOT_10)
+#define	PIN_BOOT_11		PIN_EE(BOOT_11)
+
+/* pin card */
+#define PIN_CARD_BASE		(PIN_BOOT_BASE + PIN_BOOT_SIZE)
+#define PIN_CARD_SIZE		(7)
+#define	PIN_CARD_0		PIN_EE(CARD_0)
+#define	PIN_CARD_1		PIN_EE(CARD_1)
+#define	PIN_CARD_2		PIN_EE(CARD_2)
+#define	PIN_CARD_3		PIN_EE(CARD_3)
+#define	PIN_CARD_4		PIN_EE(CARD_4)
+#define	PIN_CARD_5		PIN_EE(CARD_5)
+#define	PIN_CARD_6		PIN_EE(CARD_6)
+
+/* pin gpiow */
+#define PIN_GPIODV_BASE		(PIN_CARD_BASE + PIN_CARD_SIZE)
+#define PIN_GPIODV_SIZE		(12)
+#define	PIN_GPIODV_0		PIN_EE(GPIODV_0)
+#define	PIN_GPIODV_1		PIN_EE(GPIODV_1)
+#define	PIN_GPIODV_2		PIN_EE(GPIODV_2)
+#define	PIN_GPIODV_3		PIN_EE(GPIODV_3)
+#define	PIN_GPIODV_4		PIN_EE(GPIODV_4)
+#define	PIN_GPIODV_5		PIN_EE(GPIODV_5)
+#define	PIN_GPIODV_6		PIN_EE(GPIODV_6)
+#define	PIN_GPIODV_7		PIN_EE(GPIODV_7)
+#define	PIN_GPIODV_8		PIN_EE(GPIODV_8)
+#define	PIN_GPIODV_9		PIN_EE(GPIODV_9)
+#define	PIN_GPIODV_10		PIN_EE(GPIODV_10)
+#define	PIN_GPIODV_11		PIN_EE(GPIODV_11)
+
+/* pin gpiow */
+#define PIN_GPIOW_BASE		(PIN_GPIODV_BASE + PIN_GPIODV_SIZE)
+#define PIN_GPIOW_SIZE		(16)
+#define	PIN_GPIOW_0		PIN_EE(GPIOW_0)
+#define	PIN_GPIOW_1		PIN_EE(GPIOW_1)
+#define	PIN_GPIOW_2		PIN_EE(GPIOW_2)
+#define	PIN_GPIOW_3		PIN_EE(GPIOW_3)
+#define	PIN_GPIOW_4		PIN_EE(GPIOW_4)
+#define	PIN_GPIOW_5		PIN_EE(GPIOW_5)
+#define	PIN_GPIOW_6		PIN_EE(GPIOW_6)
+#define	PIN_GPIOW_7		PIN_EE(GPIOW_7)
+#define	PIN_GPIOW_8		PIN_EE(GPIOW_8)
+#define	PIN_GPIOW_9		PIN_EE(GPIOW_9)
+#define	PIN_GPIOW_10		PIN_EE(GPIOW_10)
+#define	PIN_GPIOW_11		PIN_EE(GPIOW_11)
+#define	PIN_GPIOW_12		PIN_EE(GPIOW_12)
+#define	PIN_GPIOW_13		PIN_EE(GPIOW_13)
+#define	PIN_GPIOW_14		PIN_EE(GPIOW_14)
+#define	PIN_GPIOW_15		PIN_EE(GPIOW_15)
+
+/* pin gpioclk */
+#define PIN_GPIOCLK_BASE	(PIN_GPIOW_BASE + PIN_GPIOW_SIZE)
+#define PIN_GPIOCLK_SIZE	(2)
+#define	PIN_GPIOCLK_0		PIN_EE(GPIOCLK_0)
+#define	PIN_GPIOCLK_1		PIN_EE(GPIOCLK_1)
+
+/* pin test_n */
+#define PIN_GPIO_TEST_N_BASE	(PIN_GPIOCLK_BASE + PIN_GPIOCLK_SIZE)
+#define PIN_GPIO_TEST_N_SIZE	(1)
+#define	PIN_GPIO_TEST_N		PIN_EE(GPIO_TEST_N)
+
+/* pin gpio_usb */
+#define PIN_GPIO_USB_BASE	(PIN_GPIO_TEST_N_BASE + PIN_GPIO_TEST_N_SIZE)
+#define PIN_GPIO_USB_SIZE	(2)
+#define	PIN_GPIO_USB_DPDM	PIN_EE(GPIO_USB_DPDM)
+#define	PIN_GPIO_USB_DMDP	PIN_EE(GPIO_USB_DMDP)
+
+#define PIN_EE_SIZE	(PIN_GPIO_USB_BASE + PIN_GPIO_USB_SIZE - PIN_EE_BASE)
+
+#define PIN_SIZE	(PIN_AO_SIZE + PIN_EE_SIZE)
+
+
+/* gpio pull up enable register index */
+#define PULL_EN_REG0		0
+#define PULL_EN_REG1		1
+#define PULL_EN_REG2		2
+#define PULL_EN_REG3		3
+#define PULL_EN_REG4		4
+
+/* gpio pull up register index */
+#define PULL_UP_REG0		0
+#define PULL_UP_REG1		1
+#define PULL_UP_REG2		2
+#define PULL_UP_REG3		3
+#define PULL_UP_REG4		4
+
+/* gpio direction register index */
+#define GPIO_D_REG0		0
+#define GPIO_D_REG1		3
+#define GPIO_D_REG2		6
+#define GPIO_D_REG3		9
+#define GPIO_D_REG4		12
+
+/* gpio output register index */
+#define GPIO_O_REG0		1
+#define GPIO_O_REG1		4
+#define GPIO_O_REG2		7
+#define GPIO_O_REG3		10
+#define GPIO_O_REG4		13
+
+/* gpio input register index */
+#define GPIO_I_REG0		2
+#define GPIO_I_REG1		5
+#define GPIO_I_REG2		8
+#define GPIO_I_REG3		11
+#define GPIO_I_REG4		14
+
+/* AO_GPIO_O_EN_N */
+#define GPIO_AO_D_REG0		0
+#define GPIO_AO_D_REG0_BIT0	0
+#define GPIO_AO_O_REG0		0
+#define GPIO_AO_O_REG0_BIT16	16
+/* AO_GPIO_I */
+#define GPIO_AO_I_REG1		1
+#define GPIO_AO_I_REG1_BIT0	0
+/* AO_RTI_PULL_UP_REG */
+#define GPIO_AO_PULL_EN_REG0		0
+#define GPIO_AO_PULL_EN_REG0_BIT0	0
+#define GPIO_AO_PULL_UP_REG0		0
+#define GPIO_AO_PULL_UP_REG0_BIT16	16
+
+
+#define GPIO_DV_D_REG0		GPIO_D_REG0
+#define GPIO_DV_O_REG0		GPIO_O_REG0
+#define GPIO_DV_I_REG0		GPIO_I_REG0
+#define GPIO_DV_REG0_BIT0	0
+
+#define GPIO_H_D_REG1		GPIO_D_REG1
+#define GPIO_H_O_REG1		GPIO_O_REG1
+#define GPIO_H_I_REG1		GPIO_I_REG1
+#define GPIO_H_REG1_BIT20	20
+
+#define GPIO_CARD_D_REG2	GPIO_D_REG2
+#define GPIO_CARD_O_REG2	GPIO_O_REG2
+#define GPIO_CARD_I_REG2	GPIO_I_REG2
+#define GPIO_CARD_REG2_BIT20	20
+
+#define GPIO_BOOT_D_REG2	GPIO_D_REG2
+#define GPIO_BOOT_O_REG2	GPIO_O_REG2
+#define GPIO_BOOT_I_REG2	GPIO_I_REG2
+#define GPIO_BOOT_REG2_BIT0	0
+
+#define GPIO_CLK_D_REG3		GPIO_D_REG3
+#define GPIO_CLK_O_REG3		GPIO_O_REG3
+#define GPIO_CLK_I_REG3		GPIO_I_REG3
+#define GPIO_CLK_REG3_BIT28	28
+
+#define GPIO_Z_D_REG3		GPIO_D_REG3
+#define GPIO_Z_O_REG3		GPIO_O_REG3
+#define GPIO_Z_I_REG3		GPIO_I_REG3
+#define GPIO_Z_REG3_BIT0	0
+
+#define GPIO_W_D_REG4		GPIO_D_REG4
+#define GPIO_W_O_REG4		GPIO_O_REG4
+#define GPIO_W_I_REG4		GPIO_I_REG4
+#define GPIO_W_REG4_BIT0	0
+
+
+#define PMX_FUNCTION_NUM	(5)
+
+
+/*
+ * [0-4]   5 bits   ee pinmux bit
+ * [5-9]   5 bits   ee pinmux register
+ * [10-14] 5 bits   ao pinmux bit
+ * [15-18] 4 bits   ao pinmux register
+ * [19]    1 bits   jtag select (sd/ao)
+ * [20-24] 5 bits   clk control bit
+ * [25-28] 4 bits   reserved
+ * [29-31] 3 bits   class to distinguish above
+ */
+
+#define PMX_EE_BIT_SFT		0
+#define PMX_EE_BIT_LEN		5
+#define PMX_EE_BIT_MSK		(((1 << PMX_EE_BIT_LEN) - 1) << PMX_EE_BIT_SFT)
+#define PMX_EE_REG_SFT		5
+#define PMX_EE_REG_LEN		5
+#define PMX_EE_REG_MSK		(((1 << PMX_EE_REG_LEN) - 1) << PMX_EE_REG_SFT)
+
+#define PMX_BIT(v)		((v & PMX_EE_BIT_MSK) >> PMX_EE_BIT_SFT)
+#define PMX_REG(v)		((v & PMX_EE_REG_MSK) >> PMX_EE_REG_SFT)
+
+
+#define PMX_AO_BIT_SFT		10
+#define PMX_AO_BIT_LEN		5
+#define PMX_AO_BIT_MSK		(((1 << PMX_AO_BIT_LEN) - 1) << PMX_AO_BIT_SFT)
+#define PMX_AO_REG_SFT		15
+#define PMX_AO_REG_LEN		4
+#define PMX_AO_REG_MSK		(((1 << PMX_AO_REG_LEN) - 1) << PMX_AO_REG_SFT)
+
+#define PMX_AO_BIT(v)		((v & PMX_AO_BIT_MSK) >> PMX_AO_BIT_SFT)
+#define PMX_AO_REG(v)		((v & PMX_AO_REG_MSK) >> PMX_AO_REG_SFT)
+
+#define PMX_JTAG_SFT		19
+#define PMX_JTAG_LEN		1
+#define PMX_JTAG_MSK		(((1 << PMX_JTAG_LEN) - 1) << PMX_JTAG_SFT)
+
+#define PMX_JTAG(v)		((v & PMX_JTAG_MSK) >> PMX_JTAG_SFT)
+
+#define PMX_CLK_BIT_SFT		20
+#define PMX_CLK_BIT_LEN		5
+#define PMX_CLK_BIT_MSK		(((1 << PMX_CLK_BIT_LEN) - 1) \
+					<< PMX_CLK_BIT_SFT)
+
+#define PMX_CLK_BIT(v)		((v & PMX_CLK_BIT_MSK) >> PMX_CLK_BIT_SFT)
+
+#define PMX_TYP_SFT		29
+#define PMX_TYP_LEN		3
+#define PMX_TYP_MSK		(((1 << PMX_TYP_LEN) - 1) << PMX_TYP_SFT)
+
+#define PMX_TYP(v)		((v & PMX_TYP_MSK) >> PMX_TYP_SFT)
+
+
+enum pmx_type {
+	PMX_TYPE_EE = 1,
+	PMX_TYPE_AO = 2,
+	PMX_TYPE_JTAG = 3,
+	PMX_TYPE_CLK = 4,
+	PMX_TYPE_NA = 7,
+};
+
+#define NA		(-1U)
+#define PE(reg, bit)	((PMX_TYPE_EE << PMX_TYP_SFT) | \
+			(reg << PMX_EE_REG_SFT) | (bit << PMX_EE_BIT_SFT))
+#define PA(reg, bit)	((PMX_TYPE_AO << PMX_TYP_SFT) | \
+			(reg << PMX_AO_REG_SFT) | (bit << PMX_AO_BIT_SFT))
+#define PJ(sel)		((PMX_TYPE_JTAG << PMX_TYP_SFT) | \
+			(sel << PMX_JTAG_SFT))
+#define PC(bit)		((PMX_TYPE_CLK << PMX_TYP_SFT) | \
+			(bit << PMX_CLK_BIT_SFT))
+
+
+
+#endif
diff --git a/drivers/amlogic/pm/gxbb_pm.c b/drivers/amlogic/pm/gxbb_pm.c
index 30b247d..dfbb949 100644
--- a/drivers/amlogic/pm/gxbb_pm.c
+++ b/drivers/amlogic/pm/gxbb_pm.c
@@ -148,7 +148,7 @@ static void meson_gx_suspend(void)
 {
 	pr_info("enter meson_pm_suspend!\n");
 	late_suspend();
-	cpu_suspend(0x0010000);
+	cpu_suspend(0x1);
 	early_resume();
 	pr_info("... wake up\n");
 
diff --git a/drivers/amlogic/ppmgr/ppmgr_drv.c b/drivers/amlogic/ppmgr/ppmgr_drv.c
index 610feae..252fc60 100644
--- a/drivers/amlogic/ppmgr/ppmgr_drv.c
+++ b/drivers/amlogic/ppmgr/ppmgr_drv.c
@@ -216,14 +216,17 @@ static ssize_t _ppmgr_angle_write(unsigned long val)
 	ppmgr_device.global_angle = angle;
 	ppmgr_device.videoangle = (angle + ppmgr_device.orientation) % 4;
 	if (!ppmgr_device.use_prot) {
-		if (angle != ppmgr_device.angle)
+		if (angle != ppmgr_device.angle) {
 			property_change = 1;
 			PPMGRDRV_INFO("ppmgr angle:%x\n", ppmgr_device.angle);
 			PPMGRDRV_INFO("orient:%x\n", ppmgr_device.orientation);
 			PPMGRDRV_INFO("vidangl:%x\n", ppmgr_device.videoangle);
+		}
 	} else {
-		set_video_angle(angle);
-		PPMGRDRV_INFO("prot angle:%ld\n", angle);
+		if (angle != ppmgr_device.angle) {
+			set_video_angle(angle);
+			PPMGRDRV_INFO("prot angle:%ld\n", angle);
+		}
 	}
 	ppmgr_device.angle = angle;
 	return 0;
diff --git a/drivers/amlogic/ppmgr/ppmgr_vpp.c b/drivers/amlogic/ppmgr/ppmgr_vpp.c
index 30dada7..71da4d7 100644
--- a/drivers/amlogic/ppmgr/ppmgr_vpp.c
+++ b/drivers/amlogic/ppmgr/ppmgr_vpp.c
@@ -698,7 +698,7 @@ static void vf_rotate_adjust(struct vframe_s *vf, struct vframe_s *new_vf,
 	new_vf->width = w;
 	new_vf->height = h;
 }
-
+#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
 static void display_mode_adjust(struct ge2d_context_s *context,
 		struct vframe_s *new_vf, int pic_struct)
 {
@@ -765,7 +765,7 @@ static void display_mode_adjust(struct ge2d_context_s *context,
 		}
 	}
 }
-
+#endif
 static int process_vf_deinterlace_nv21(struct vframe_s *vf,
 		struct ge2d_context_s *context,
 		struct config_para_ex_s *ge2d_config)
@@ -1372,8 +1372,6 @@ static void process_vf_rotate(struct vframe_s *vf,
 	struct vframe_s *new_vf;
 	struct ppframe_s *pp_vf;
 	struct canvas_s cs0, cs1, cs2, cd;
-	int i;
-	u32 mode = 0;
 	int ret = 0;
 	unsigned cur_angle = 0;
 	int pic_struct = 0, interlace_mode;
@@ -1381,6 +1379,8 @@ static void process_vf_rotate(struct vframe_s *vf,
 	enum platform_type_t platform_type;
 #endif
 #ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
+	int i;
+	u32 mode = 0;
 	int rect_x = 0, rect_y = 0, rect_w = 0, rect_h = 0;
 	u32 ratio = 100;
 	mode = amvideo_get_scaler_para(
diff --git a/drivers/amlogic/rdma/rdma_mgr.c b/drivers/amlogic/rdma/rdma_mgr.c
index 217f4a1..afe39cd 100644
--- a/drivers/amlogic/rdma/rdma_mgr.c
+++ b/drivers/amlogic/rdma/rdma_mgr.c
@@ -51,6 +51,10 @@
 #define rdma_io_write(addr, val) writel((val), addr);
 
 #define RDMA_VSYNC_INPUT_TRIG		0x1
+#define SKIP_OSD_CHANNEL
+
+int rdma_mgr_irq_request;
+
 static int debug_flag;
 /* burst size 0=16; 1=24; 2=32; 3=48.*/
 static int ctrl_ahb_rd_burst_size = 3;
@@ -281,7 +285,7 @@ QUERY:
 		if (!(rdma_status & (1 << (i+24))))
 			continue;
 		/*bypass osd rdma done case*/
-#if 0
+#ifdef SKIP_OSD_CHANNEL
 		if (i == 3)
 			continue;
 #endif
@@ -300,8 +304,13 @@ QUERY:
 		}
 	}
 	rdma_status = READ_VCBUS_REG(RDMA_STATUS);
+#ifdef SKIP_OSD_CHANNEL
+	if ((rdma_status & 0xf7000000) && (retry_count < 100))
+		goto QUERY;
+#else
 	if ((rdma_status & 0xff000000) && (retry_count < 100))
 		goto QUERY;
+#endif
 	return IRQ_HANDLED;
 }
 
@@ -622,7 +631,7 @@ static int rdma_probe(struct platform_device *pdev)
 	int_rdma = platform_get_irq_byname(pdev, "rdma");
 
 	pr_info("%s\n", __func__);
-
+	rdma_mgr_irq_request = 0;
 	for (i = 0; i < RDMA_NUM; i++) {
 			info->rdma_ins[i].rdma_table_size = 0;
 			info->rdma_ins[i].rdma_regadr = &rdma_regadr[i];
@@ -645,6 +654,7 @@ static int rdma_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+	rdma_mgr_irq_request = 1;
 	data32  = 0;
 	data32 |= 0 << 6;
 	data32 |= ctrl_ahb_wr_burst_size << 4;
diff --git a/drivers/amlogic/thermal/aml_thermal_hw.c b/drivers/amlogic/thermal/aml_thermal_hw.c
index b88f383..0e19e2a 100644
--- a/drivers/amlogic/thermal/aml_thermal_hw.c
+++ b/drivers/amlogic/thermal/aml_thermal_hw.c
@@ -182,8 +182,28 @@ int aml_thermal_min_update(struct thermal_cooling_device *cdev)
 }
 EXPORT_SYMBOL(aml_thermal_min_update);
 
+int set_cur_mode(struct thermal_zone_device *tzd, enum thermal_device_mode mode)
+{
+	int i, ret = 0;
+	struct thermal_cooling_device *cdev;
+
+	/*
+	 * each cooling device should return to max state if thermal is disalbed
+	 */
+	if (mode != THERMAL_DEVICE_DISABLED)
+		return 0;
+
+	for (i = 0; i < soc_sensor.cool_dev_num; i++) {
+		cdev = soc_sensor.cool_devs[i].cooling_dev;
+		if (cdev)
+			ret |= cdev->ops->set_cur_state(cdev, 0);
+	}
+	return ret;
+}
+
 static struct thermal_zone_of_device_ops aml_thermal_ops = {
 	.get_temp = get_cur_temp,
+	.set_mode = set_cur_mode,
 };
 
 static int register_cool_dev(struct cool_dev *cool)
diff --git a/drivers/amlogic/tvin/hdmirx/Makefile b/drivers/amlogic/tvin/hdmirx/Makefile
index 9aa9b73..675673a 100644
--- a/drivers/amlogic/tvin/hdmirx/Makefile
+++ b/drivers/amlogic/tvin/hdmirx/Makefile
@@ -5,7 +5,7 @@
 obj-$(CONFIG_TVIN_HDMI) += tvin_hdmirx.o
 tvin_hdmirx-objs := hdmi_rx_wrapper.o hdmi_rx_hw.o hdmirx_drv.o hdcp_main.o hdmi_rx_eq.o
 
-obj-y			+= uart_hdmi.o
+#obj-y			+= uart_hdmi.o
 
 ifneq ($(CONFIG_TVIN_HDMI_CEC),)
 tvin_hdmirx-objs += hdmirx_cec.o
diff --git a/drivers/amlogic/tvin/hdmirx/hdcp_main.c b/drivers/amlogic/tvin/hdmirx/hdcp_main.c
index 15bfbcf..41f730c 100644
--- a/drivers/amlogic/tvin/hdmirx/hdcp_main.c
+++ b/drivers/amlogic/tvin/hdmirx/hdcp_main.c
@@ -283,7 +283,7 @@ static long cmd_get_data_phys_addr(struct esm_device *esm,
 	krequest.returned_phys_addr = esm->data_base;
 	krequest.returned_status = ESM_HL_DRIVER_SUCCESS;
 
-	rx_print("%scmd_get_data_phys_addr: returning data_base=0x%x\n",
+	rx_pr("%scmd_get_data_phys_addr: returning data_base=0x%x\n",
 		MY_TAG, krequest.returned_phys_addr);
 
 	ret = copy_to_user(request, &krequest,
@@ -303,7 +303,7 @@ static long cmd_get_data_size(struct esm_device *esm,
 	krequest.returned_data_size = esm->data_size;
 	krequest.returned_status = ESM_HL_DRIVER_SUCCESS;
 
-	rx_print("%scmd_get_data_size: returning data_size=0x%x\n",
+	rx_pr("%scmd_get_data_size: returning data_size=0x%x\n",
 		MY_TAG, krequest.returned_data_size);
 
 	ret = copy_to_user(request, &krequest,
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_eq.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_eq.c
index baca64f..751dae5 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_eq.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_eq.c
@@ -14,7 +14,6 @@
  * GNU General Public License for more details.
  *
  */
-
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/types.h>
@@ -40,59 +39,9 @@
 #include "hdmirx_drv.h"
 #include "hdmi_rx_reg.h"
 
-int eq_setting[EQ_CH_NUM];
-
-static bool finish_flag[EQ_CH_NUM];
-
-static int nretry;
-/* Auxiliary variable to perform early-late counters averaging */
-int accumulator[EQ_CH_NUM];
-
-/* Variables to store early-late counters averaging */
-int early_cnt[EQ_CH_NUM];
-
-/* Variables to store early-late counters slope */
-int slope_accumulator[EQ_CH_NUM];
-
-/* Auxiliary variable to detect early-late counters trend (up/down) */
-int last_early_cnt[EQ_CH_NUM];
-
-/* EQ Best Long cable setting and valid flag */
-int best_long_setting[EQ_CH_NUM];
-int valid_long_setting[EQ_CH_NUM];
-
-/* EQ Best Short cable setting and valid flag */
-int best_short_setting[EQ_CH_NUM];
-int valid_short_setting[EQ_CH_NUM];
-
-/* EQ Final Setting should be programed to the PHY */
-int best_setting[EQ_CH_NUM];
-
-/*Auxiliary variables to detect stable acquisitions this
-will save 2mS * EQ_MAX_SETTING when good cables are used*/
-static int upperBound_acqCH0, upperBound_acqCH1, upperBound_acqCH2;
-static int lowerBound_acqCH0, lowerBound_acqCH1, lowerBound_acqCH2;
-static int outBound_acqCH0, outBound_acqCH1, outBound_acqCH2;
-
-/* Auxiliary variables to control algorithm status */
-static bool error_cable_flag[EQ_CH_NUM];
-
-/*Auxiliary variable to control how many times Algorithm
-will retry if any error is detected*/
-static bool minmax_err_flag;
-static int minmax_check_cnt;
-static int pll_rate_value = 0xff;
-
-/* TMDSVALID FLAG */
-static bool tmds_valid_flag;
-
-static int min_max_diff = 4;
 int eq_setting_back = 0;
-static int tmds_valid_cnt;
 int fat_bit_status = 0;
-
-static struct hdmirx_phy_data_t *phy_private_data;
-static struct phy_eq_algorithm_data_t *phy_eq_algo_data;
+static int min_max_diff = 4;
 
 int hdmirx_log_flag = 1;
 MODULE_PARM_DESC(hdmirx_log_flag, "\n hdmirx_log_flag\n");
@@ -106,23 +55,25 @@ static int force_clk_rate;
 MODULE_PARM_DESC(force_clk_rate, "\n force_clk_rate\n");
 module_param(force_clk_rate, int, 0664);
 
-static bool fast_switching = true;
-MODULE_PARM_DESC(fast_switching, "\n fast_switching\n");
-module_param(fast_switching, bool, 0664);
+static int delay_ms_cnt = 5;
+MODULE_PARM_DESC(delay_ms_cnt, "\n delay_ms_cnt\n");
+module_param(delay_ms_cnt, int, 0664);
+
+static int eq_sts_stable_max = 2;
+MODULE_PARM_DESC(eq_sts_stable_max, "\n eq_sts_stable_max\n");
+module_param(eq_sts_stable_max, int, 0664);
 
-static int mpll_ctl_setting = 0x200;
-MODULE_PARM_DESC(mpll_ctl_setting, "\n mpll_ctl_setting\n");
-module_param(mpll_ctl_setting, int, 0664);
+static int eq_max_setting = 6;
+MODULE_PARM_DESC(eq_max_setting, "\n eq_max_setting\n");
+module_param(eq_max_setting, int, 0664);
 
-static int eq_clk_rate_wait = 2;
-MODULE_PARM_DESC(eq_clk_rate_wait, "\n eq_clk_rate_wait\n");
-module_param(eq_clk_rate_wait, int, 0664);
 
-static int mpll_param4 = 0x24dc;
-MODULE_PARM_DESC(mpll_param4, "\n mpll_param4\n");
-module_param(mpll_param4, int, 0664);
+struct st_eq_data eq_ch0;
+struct st_eq_data eq_ch1;
+struct st_eq_data eq_ch2;
 
-bool phy_maxvsmin(int ch0Setting, int ch1Setting, int ch2Setting)
+
+bool eq_maxvsmin(int ch0Setting, int ch1Setting, int ch2Setting)
 {
 	int min = ch0Setting;
 	int max = ch0Setting;
@@ -136,718 +87,353 @@ bool phy_maxvsmin(int ch0Setting, int ch1Setting, int ch2Setting)
 	if (ch2Setting < min)
 		min = ch2Setting;
 	if ((max - min) > min_max_diff) {
-		rx_print("MINMAX ERROR\n");
+		rx_pr("MINMAX ERROR\n");
 		return 0;
 	}
 	return 1;
 }
 
-void phy_init_param(void)
+void initvars(struct st_eq_data *ch_data)
 {
-	best_long_setting[EQ_CH0] = 6;
-	best_long_setting[EQ_CH1] = 6;
-	best_long_setting[EQ_CH2] = 6;
-	best_short_setting[EQ_CH0] = EQ_DEFAULT_SETTING;
-	best_short_setting[EQ_CH1] = EQ_DEFAULT_SETTING;
-	best_short_setting[EQ_CH2] = EQ_DEFAULT_SETTING;
-	best_setting[EQ_CH0] = EQ_DEFAULT_SETTING;
-	best_setting[EQ_CH1] = EQ_DEFAULT_SETTING;
-	best_setting[EQ_CH2] = EQ_DEFAULT_SETTING;
-	eq_setting[EQ_CH0] = EQ_DEFAULT_SETTING;
-	eq_setting[EQ_CH1] = EQ_DEFAULT_SETTING;
-	eq_setting[EQ_CH2] = EQ_DEFAULT_SETTING;
-	/*remove error*/
-	phy_eq_algo_data = NULL;
+	/* Slope accumulator */
+	ch_data->acc = 0;
+	/* Early Counter dataAcquisition data */
+	ch_data->acq = 0;
+	ch_data->lastacq = 0;
+	ch_data->validLongSetting = 0;
+	ch_data->validShortSetting = 0;
+	/* BEST Setting = short */
+	ch_data->bestsetting = shortcableSetting;
+	/* TMDS VALID not valid */
+	ch_data->tmdsvalid = 0;
 }
 
-void phy_eq_set_state(enum phy_eq_states_e state, bool force)
+
+void hdmi_rx_phy_ConfEqualSingle(void)
 {
-	if (force)
-		phy_private_data->phy_eq_state = state;
-	else
-		if ((phy_private_data->phy_eq_state != EQ_IDLE) &&
-			(state <= EQ_FAILED))
-			phy_private_data->phy_eq_state = state;
+	hdmirx_wr_phy(PHY_EQCTRL1_CH0, 0x0211);
+	hdmirx_wr_phy(PHY_EQCTRL1_CH1, 0x0211);
+	hdmirx_wr_phy(PHY_EQCTRL1_CH2, 0x0211);
+	hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x0024 | (avgAcq << 11));
+	hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x0024 | (avgAcq << 11));
 }
 
-void phy_conf_eq_setting(int ch0_lockVector,
-				int ch1_lockVector, int ch2_lockVector)
+void hdmi_rx_phy_ConfEqualSetting(uint16_t lockVector)
 {
-	/* ConfEqualSetting */
-	hdmirx_wr_phy(PHY_EQCTRL4_CH0, 1<<ch0_lockVector);
-	hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x0024);
-	hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x0026);
+	hdmirx_wr_phy(PHY_EQCTRL4_CH0, lockVector);
+	hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x4024 | (avgAcq << 11));
+	hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x4026 | (avgAcq << 11));
+}
+
+void hdmi_rx_phy_ConfEqualAutoCalib(void)
+{
+	hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1809);
+	hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1819);
+	hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1809);
+}
 
-	hdmirx_wr_phy(PHY_EQCTRL4_CH1, 1<<ch1_lockVector);
-	hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x0024);
-	hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x0026);
+uint16_t rx_phy_rd_earlycnt_ch0(void)
+{
 
-	hdmirx_wr_phy(PHY_EQCTRL4_CH2, 1<<ch2_lockVector);
-	hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x0024);
-	hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x0026);
+	return hdmirx_rd_phy(PHY_EQSTAT3_CH0);
 }
 
-void set_cmd_state(bool enable)
+uint16_t rx_phy_rd_earlycnt_ch1(void)
 {
-	spin_lock(&phy_private_data->slock);
-	phy_private_data->new_cmd = false;
-	spin_unlock(&phy_private_data->slock);
+
+	return hdmirx_rd_phy(PHY_EQSTAT3_CH1);
 }
 
-int phy_wait_clk_stable(void)
+uint16_t rx_phy_rd_earlycnt_ch2(void)
 {
-	int i;
-	int eq_mainfsm_status;
-	int stable_start = 0;
-
-	for (i = 0; i < EQ_CLK_WAIT_MAX_COUNT; i++) {
-		eq_mainfsm_status = hdmirx_rd_phy(PHY_MAINFSM_STATUS1);
-		/*Make sure that SW is not overriding the equalization not
-		mandatory code (this is the default status)*/
-		hdmirx_wr_phy(PHY_MAIN_FSM_OVERRIDE2, 0x0);
-
-		/*clock_stable = false => Main FSM should wait for clock stable
-		Is mandatory to have a stable clock before starting to do
-		equalization*/
-		if (hdmirx_log_flag & VIDEO_LOG_ENABLE)
-			rx_print("phy state---[%x]\n", eq_mainfsm_status);
-		if ((eq_mainfsm_status >> 8 & 0x1) == 0)
-			stable_start = 0;
-		else {
-			stable_start++;
-			if (stable_start >= eq_clk_rate_wait)
-				break;
-		}
 
-		if (((EQ_CLK_WAIT_MAX_COUNT - 1) == i) ||
-			phy_private_data->new_cmd) {
-			return -1;
-		}
-		block_delay_ms(EQ_CLK_WAIT_DELAY);
-	}
+	return hdmirx_rd_phy(PHY_EQSTAT3_CH2);
+}
 
-	return 0;
+uint16_t hdmi_rx_phy_CoreStatusCh0(void)
+{
+
+	return hdmirx_rd_phy(PHY_CORESTATUS_CH0);
 }
 
-void phy_eq_task_continue(void)
+uint16_t hdmi_rx_phy_CoreStatusCh1(void)
 {
-	if (phy_private_data != NULL)
-		complete(&phy_private_data->phy_task_lock);
+
+	return hdmirx_rd_phy(PHY_CORESTATUS_CH1);
 }
 
-void phy_EQ_workaround(void)
+uint16_t hdmi_rx_phy_CoreStatusCh2(void)
 {
-	int stepSlope[EQ_CH_NUM];
-	int eq_mainfsm_status = 0;
-	int nacq = 5;
-	int eq_counter_th = EQ_COUNTERTHRESHOLD;
-	enum phy_eq_cmd_e new_cmd;
-
-	memset(stepSlope, 0, sizeof(stepSlope));
-	/*check new command*/
-	if (phy_private_data->new_cmd) {
-		spin_lock(&phy_private_data->slock);
-		phy_private_data->new_cmd = false;
-		new_cmd = phy_private_data->cmd;
-		spin_unlock(&phy_private_data->slock);
-		if (new_cmd == EQ_START) {
-			rx_print("start eq calc\n");
-			phy_eq_set_state(EQ_DATA_START, true);
-		} else if (new_cmd == EQ_STOP) {
-			rx_print("exit eq calc\n");
-			phy_eq_set_state(EQ_IDLE, true);
-		}
+
+	return hdmirx_rd_phy(PHY_CORESTATUS_CH2);
+}
+
+void phy_conf_eq_setting(int ch0_lockVector,
+				int ch1_lockVector, int ch2_lockVector)
+{
+	/* ConfEqualSetting */
+	if (is_meson_gxtvbb_cpu()) {
+		hdmirx_wr_phy(PHY_EQCTRL4_CH0, 1<<ch0_lockVector);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x0024);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x0026);
+
+		hdmirx_wr_phy(PHY_EQCTRL4_CH1, 1<<ch1_lockVector);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x0024);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x0026);
+
+		hdmirx_wr_phy(PHY_EQCTRL4_CH2, 1<<ch2_lockVector);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x0024);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x0026);
+	} else {
+		hdmirx_wr_phy(PHY_EQCTRL4_CH0, 1<<ch0_lockVector);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x4024 | (avgAcq << 11));
+		hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x4026 | (avgAcq << 11));
+
+		hdmirx_wr_phy(PHY_EQCTRL4_CH1, 1<<ch1_lockVector);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x4024 | (avgAcq << 11));
+		hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x4026 | (avgAcq << 11));
+
+		hdmirx_wr_phy(PHY_EQCTRL4_CH2, 1<<ch2_lockVector);
+		hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x4024 | (avgAcq << 11));
+		hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x4026 | (avgAcq << 11));
 	}
+}
 
-	switch (phy_private_data->phy_eq_state) {
-	case EQ_DATA_START:
-		hdmirx_phy_EQ_workaround_init();
-		block_delay_ms(1);
-		/********************   IMPORTANT   *************************/
-		/********************* PLEASE README ************************/
-		/*The following piece of code was added here to make sure that
-		before running the algorithm all needed condition are available
-		 if not	The conditions are, PHY is receiving a stable clock
-		[reg (MAINFSM_STATUS1) 0x09[8]=1'b1] and PLL_RATE if greater
-		that 94.5MHz reg (MAINFSM_STATUS1) 0x09[10:9]=2'b0x]
-		If stable clock is not asserted MAIN FSM should wait for such
-		 signal	and call again the algorithm.*/
-
-		/*if it is forced to exit delay,set state to EQ_IDLE
-		otherwise clk stable failed*/
-		if (phy_wait_clk_stable() != 0) {
-			if (phy_private_data->new_cmd) {
-				set_cmd_state(false);
-				phy_eq_set_state(EQ_IDLE, false);
-			} else
-				phy_eq_set_state(EQ_FAILED, false);
-			return;
+uint8_t testType(uint16_t setting, struct st_eq_data *ch_data)
+{
+	uint16_t stepSlope = 0;
+	/* LONG CABLE EQUALIZATION */
+	if ((ch_data->acq < ch_data->lastacq) &&
+		(ch_data->tmdsvalid == 1)) {
+		ch_data->acc += (ch_data->lastacq-ch_data->acq);
+		if (ch_data->validLongSetting == 0 &&
+			ch_data->acq < equalizedCounterValue &&
+			ch_data->acc > AccMinLimit) {
+			ch_data->bestLongSetting = setting;
+			ch_data->validLongSetting = 1;
 		}
-		/*block_delay_ms(eq_clk_rate_wait);*/
-		/* GET PHY STATUS (MAINFSM_STATUS1) */
-		eq_mainfsm_status = hdmirx_rd_phy(PHY_MAINFSM_STATUS1);
-		pll_rate_value = (eq_mainfsm_status >> 9 & 0x3);
-		rx_print("eq_mainfsm_status: %#x,tmds_clk:%d\n",
-			eq_mainfsm_status, hdmirx_get_tmds_clock());
-		if (!hdmirx_tmds_34g()) {
-			if (((eq_mainfsm_status >> 10) & 0x1) != 0) {
-				/* pll_rate smaller than 94.5MHz, algorithm
-				not needed Please make sure that PHY get the
-				 default status */
-				rx_print("low pll rate-[%x]\n",
-						eq_mainfsm_status);
-				/* default status for register 0x33 */
-				hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x0020);
-				/* default status for register 0x53 */
-				hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x0020);
-				/* default status for register 0x73 */
-				hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x0020);
-
-				eq_setting[EQ_CH0] = 0;
-				eq_setting[EQ_CH1] = 0;
-				eq_setting[EQ_CH2] = 0;
-				hdmirx_phy_conf_eq_setting(rx.port,
-							 eq_setting[EQ_CH0],
-				eq_setting[EQ_CH1], eq_setting[EQ_CH2]);
-
-				/* hdmirx_phy_init(rx.port, 0); */
-				phy_eq_set_state(EQ_SUCCESS_END, false);
-				return;
-			}
+		stepSlope = ch_data->lastacq-ch_data->acq;
+	}
+	/* SHORT CABLE EQUALIZATION */
+	if (ch_data->tmdsvalid == 1 &&
+		ch_data->validShortSetting == 0) {
+		/* Short setting better than default, system over-equalized */
+		if (setting < shortcableSetting &&
+			ch_data->acq < equalizedCounterValue)  {
+			ch_data->validShortSetting = 1;
+			ch_data->bestShortSetting = setting;
 		}
-
-		/************* END  NOTICE **************************/
-		fat_bit_status = EQ_FATBIT_MASK;
-		min_max_diff = MINDIFF;
-		eq_counter_th = EQ_COUNTERTHRESHOLD;
-		if ((((eq_mainfsm_status >> 9) & 0x3) == 0))
-			fat_bit_status = EQ_FATBIT_MASK_4k;
-		if (hdmirx_tmds_34g()) {
-			fat_bit_status = EQ_FATBIT_MASK_HDMI20;
-			eq_counter_th = EQ_COUNTERTHRESHOLD_HDMI20;
-			min_max_diff = MINDIFF_HDMI20;
+		/* default Short setting is valid */
+		if (setting == shortcableSetting) {
+			ch_data->validShortSetting = 1;
+			ch_data->bestShortSetting = shortcableSetting;
 		}
+	}
+	/* Exit type Long cable
+	(early-late count curve well behaved
+	and 50% threshold achived) */
+	if (ch_data->validLongSetting  == 1 &&
+		ch_data->acc > AccLimit) {
+		ch_data->bestsetting = ch_data->bestLongSetting;
+		if (log_flag & EQ_LOG)
+			rx_pr("longcable1");
+		return 1;
+	}
+	/* Exit type short cable
+	(early-late count curve  behaved as a short cable) */
+	if (setting == eq_max_setting &&
+		ch_data->acc < AccLimit &&
+		ch_data->validShortSetting == 1) {
+		ch_data->bestsetting = ch_data->bestShortSetting;
+		if (log_flag & EQ_LOG)
+			rx_pr("shortcable");
+		return 2;
+	}
+	/* Exit type long cable
+	(early-late count curve well behaved
+	nevertheless 50% threshold not achieved) */
+	if ((setting == eq_max_setting) &&
+		(ch_data->tmdsvalid == 1) &&
+		(ch_data->acc > AccLimit) &&
+		(stepSlope > minSlope)) {
+		ch_data->bestsetting = eq_max_setting;
+		if (log_flag & EQ_LOG)
+			rx_pr("longcable2");
+		return 3;
+	}
+	/* error cable */
+	if (setting == eq_max_setting) {
+		if (log_flag & EQ_LOG)
+			rx_pr("errcable");
+		ch_data->bestsetting = ErrorcableSetting;
+		return 255;
+	}
+	/* Cable not detected,
+	continue to next setting */
+	return 0;
+}
+
+
+uint8_t aquireEarlyCnt(uint16_t setting)
+{
+	uint16_t lockVector = 0x0001;
+	lockVector = lockVector << setting;
+	hdmi_rx_phy_ConfEqualSetting(lockVector);
+	hdmi_rx_phy_ConfEqualAutoCalib();
+	mdelay(delay_ms_cnt);
+	eq_ch0.tmdsvalid =  (hdmi_rx_phy_CoreStatusCh0() & 0x0080) > 0 ? 1 : 0;
+	eq_ch1.tmdsvalid =  (hdmi_rx_phy_CoreStatusCh1() & 0x0080) > 0 ? 1 : 0;
+	eq_ch2.tmdsvalid =  (hdmi_rx_phy_CoreStatusCh2() & 0x0080) > 0 ? 1 : 0;
+	if ((eq_ch0.tmdsvalid |
+		eq_ch1.tmdsvalid |
+		eq_ch2.tmdsvalid) == 0) {
+		return 0;
+	}
 
-		hdmirx_wr_phy(0x43, fat_bit_status);
-		hdmirx_wr_phy(0x63, fat_bit_status);
-		hdmirx_wr_phy(0x83, fat_bit_status);
-
-		finish_flag[EQ_CH0] = 0;
-		finish_flag[EQ_CH1] = 0;
-		finish_flag[EQ_CH2] = 0;
-
-		error_cable_flag[EQ_CH0] = 0;
-		error_cable_flag[EQ_CH1] = 0;
-		error_cable_flag[EQ_CH2] = 0;
-		valid_long_setting[EQ_CH0] = 0;
-		valid_long_setting[EQ_CH1] = 0;
-		valid_long_setting[EQ_CH2] = 0;
-		valid_short_setting[EQ_CH0] = 0;
-		valid_short_setting[EQ_CH1] = 0;
-		valid_short_setting[EQ_CH2] = 0;
-		accumulator[EQ_CH0] = 0;
-		accumulator[EQ_CH1] = 0;
-		accumulator[EQ_CH2] = 0;
-		slope_accumulator[EQ_CH0] = 0;
-		slope_accumulator[EQ_CH1] = 0;
-		slope_accumulator[EQ_CH2] = 0;
-		last_early_cnt[EQ_CH0] = 0;
-		last_early_cnt[EQ_CH1] = 0;
-		last_early_cnt[EQ_CH2] = 0;
-		eq_setting_back = 0;
-		phy_eq_set_state(EQ_SET_LOCK_VECTOR, false);
-		phy_eq_task_continue();
-	break;
-	case EQ_SET_LOCK_VECTOR:
-		/* tmds_valid_flag = 1; */
-		early_cnt[EQ_CH0] = 0;
-		early_cnt[EQ_CH1] = 0;
-		early_cnt[EQ_CH2] = 0;
+	if (!is_meson_gxtvbb_cpu()) {
+		/* End the acquisitions if no TMDS valid */
+		/* hdmi_rx_phy_ConfEqualSetting(lockVector); */
+		/* phy_conf_eq_setting(setting, setting, setting); */
+		/* sleep_time_CDR should be enough
+			to have TMDS valid asserted. */
+		/* TMDS VALID can be obtained either
+			by per channel basis or global pin */
+		/* TMDS VALID BY channel basis (Option #1) */
+		/* Get early counters */
+		eq_ch0.acq = rx_phy_rd_earlycnt_ch0() >> avgAcq;
+		eq_ch1.acq = rx_phy_rd_earlycnt_ch1() >> avgAcq;
+		eq_ch2.acq = rx_phy_rd_earlycnt_ch2() >> avgAcq;
+	} else {
+		uint16_t cnt;
+		uint16_t upperBound_acqCH0;
+		uint16_t upperBound_acqCH1;
+		uint16_t upperBound_acqCH2;
+		uint16_t lowerBound_acqCH0;
+		uint16_t lowerBound_acqCH1;
+		uint16_t lowerBound_acqCH2;
+		uint8_t outBound_acqCH0;
+		uint8_t outBound_acqCH1;
+		uint8_t outBound_acqCH2;
+		/* Maximum allowable deviation to
+			consider a acquisition stable = 20*2 */
+		uint16_t boundspread = 20;
+		/* Minimum number of acquisitions to evaluate the stability */
+		uint8_t minACQtoStableDetection = 3;
+		uint16_t acq_ch0 = 0;
+		uint16_t acq_ch1 = 0;
+		uint16_t acq_ch2 = 0;
+
+		/* get TMDSVALID and early counters */
+		eq_ch0.acq = 0;
+		eq_ch1.acq = 0;
+		eq_ch2.acq = 0;
 		outBound_acqCH0 = 0;
 		outBound_acqCH1 = 0;
 		outBound_acqCH2 = 0;
-		nretry = 0;
-		phy_conf_eq_setting(eq_setting_back,
-			eq_setting_back, eq_setting_back);
-		phy_eq_set_state(EQ_SET_FORCE_FMS_STATE, false);
-		phy_eq_task_continue();
-	break;
-	case EQ_SET_FORCE_FMS_STATE:
-		hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1809);
-		hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1819);
-		hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1809);
-		/*please make sure that there's at least 10 mS between
-		that state and  TMDSVALID detection/test*/
-		phy_eq_set_state(EQ_CHECK_TMDS_VALID, false);
-		if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-			rx_print("set for FMS state->check TMDS valid\n");
-		phy_eq_task_continue();
-	break;
-	case EQ_CHECK_TMDS_VALID:
-		if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-			rx_print("check TMDS valid\n");
-		/* Please check the following */
-		/* between the following rx_print instructions */
-		/* you have at lest 10ms */
-		/*if it is forced to exit delay,set state to EQ_DATA_START
-		otherwise clk stable failed*/
-		/*if (phy_wait_clk_stable() != 0) {
-			if (phy_private_data->exit_task_delay)
-				phy_eq_set_state(EQ_DATA_START, false);
-			else
-				phy_eq_set_state(EQ_FAILED, false);
-			return;
-		}*/
-
-		/*Is this the tmds valid detection? ALG shouldn't wait for
-		 a long time (much more than 10mS) for TMDSVALID assertion*/
-		if (!hdmirx_phy_check_tmds_valid()) {
-			/*how long are you waiting for TMDSVALID? should
-			 be ~~10mS did you see any case where TMDSVALID
-			 doesn't get asserted after	10mS but get asserted
-			 after a long time?System shouldn't wait for TMDS
-			 VALID assertion more than 10mS	because if TMDSVALID
-			 is not asserted means that setting is not good
-			 enough and must proceed for the next one please
-			 send to us some log file (early counters slope
-			acumulator and setting ) where TMDS VALID just
-			gets asserted after long time*/
-			if (tmds_valid_cnt++ > tmds_valid_cnt_max) {
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print(
-					"valid_cnt=%d 0x09[%x]-0x30[%x]-0x50[%x]-0x70[%x]\n",
-					tmds_valid_cnt, hdmirx_rd_phy(0x09),
-					hdmirx_rd_phy(0x30),
-					hdmirx_rd_phy(0x50),
-					hdmirx_rd_phy(0x70));
-					tmds_valid_flag = 0;
-					tmds_valid_cnt = 0;
-					phy_eq_set_state(EQ_GET_CABLE_TYPE,
-								 false);
-			} else {
-				block_delay_ms(EQ_TMDS_VALID_WAIT_DELAY);
-			}
-		} else {
-			tmds_valid_cnt = 0;
-			tmds_valid_flag = 1;
-			early_cnt[EQ_CH0] = hdmirx_rd_phy(PHY_EQSTAT3_CH0);
-			early_cnt[EQ_CH1] = hdmirx_rd_phy(PHY_EQSTAT3_CH1);
-			early_cnt[EQ_CH2] = hdmirx_rd_phy(PHY_EQSTAT3_CH2);
-
-			accumulator[EQ_CH0] = early_cnt[EQ_CH0];
-			accumulator[EQ_CH1] = early_cnt[EQ_CH1];
-			accumulator[EQ_CH2] = early_cnt[EQ_CH2];
-			upperBound_acqCH0 =
-				accumulator[EQ_CH0] + EQ_BOUNDARYSPREAD;
-			lowerBound_acqCH0 =
-				accumulator[EQ_CH0] - EQ_BOUNDARYSPREAD;
-			upperBound_acqCH1 =
-				accumulator[EQ_CH1] + EQ_BOUNDARYSPREAD;
-			lowerBound_acqCH1 =
-				accumulator[EQ_CH1] - EQ_BOUNDARYSPREAD;
-			upperBound_acqCH2 =
-				accumulator[EQ_CH2] + EQ_BOUNDARYSPREAD;
-			lowerBound_acqCH2 =
-				accumulator[EQ_CH1] - EQ_BOUNDARYSPREAD;
-			phy_eq_set_state(EQ_AQUIRE_EARLY_COUNTER, false);
-			if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-				rx_print("tmds valid->aquire early counter\n");
-		}
-		phy_eq_task_continue();
-	break;
-	case EQ_AQUIRE_EARLY_COUNTER:
-		/* ************************   IMPORTANT   *******************/
-		/* ************************ PLEASE README *******************/
-		/* the execution of the following loop before jumping to the
-		MAIN FSM will save 500mS, taking into account that MAIN FSM
-		 takes 10mS to finish.Important loop to save 500mS of
-		execution time. Loop takes a maximum time of ~5mS */
-		while (1) {
-			nretry++;
-			/* hdmi_rx_phy_ConfEqualAutoCalib */
-			hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1809);
-			hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1819);
-			hdmirx_wr_phy(PHY_MAINFSM_CTL, 0x1809);
-			/* wait EQ_WAITTIME to have a stable
-						read from Early edge counter */
-			mdelay(EQ_WAITTIME);
-
-			/* Update boundaries to detect a stable acquisitions */
-			if (accumulator[EQ_CH0] > upperBound_acqCH0 ||
-				accumulator[EQ_CH0] < lowerBound_acqCH0)
+
+		/* Get fisrt set of early counters */
+		acq_ch0 = rx_phy_rd_earlycnt_ch0();
+		acq_ch1 = rx_phy_rd_earlycnt_ch1();
+		acq_ch2 = rx_phy_rd_earlycnt_ch2();
+
+		eq_ch0.acq += acq_ch0;
+		eq_ch1.acq += acq_ch1;
+		eq_ch2.acq += acq_ch2;
+
+		upperBound_acqCH0 = acq_ch0 + boundspread;
+		lowerBound_acqCH0 = acq_ch0 - boundspread;
+		upperBound_acqCH1 = acq_ch1 + boundspread;
+		lowerBound_acqCH1 = acq_ch1 - boundspread;
+		upperBound_acqCH2 = acq_ch2 + boundspread;
+		lowerBound_acqCH2 = acq_ch2 - boundspread;
+
+		for (cnt = 1; cnt < setting; cnt++) {
+			hdmi_rx_phy_ConfEqualAutoCalib();
+			mdelay(delay_ms_cnt);
+			if (acq_ch0 > upperBound_acqCH0 ||
+				acq_ch0 < lowerBound_acqCH0)
 				outBound_acqCH0++;
-			if (accumulator[EQ_CH1] > upperBound_acqCH1 ||
-				accumulator[EQ_CH1] < lowerBound_acqCH1)
+			if (acq_ch1 > upperBound_acqCH1 ||
+				acq_ch1 < lowerBound_acqCH1)
 				outBound_acqCH1++;
-			if (accumulator[EQ_CH2] > upperBound_acqCH2 ||
-				accumulator[EQ_CH2] < lowerBound_acqCH2)
+			if (acq_ch2 > upperBound_acqCH2 ||
+				acq_ch2 < lowerBound_acqCH2)
 				outBound_acqCH2++;
-			/*Finish averaging because Stable acquisitions were
-			detected,minimum of three readings between boundaries
-			 to finish the averaging*/
-			if (nretry == EQ_MIN_ACQ_STABLE_DETECTION) {
+
+			/* Stable detection, minimum 3 readouts */
+			if (cnt == minACQtoStableDetection) {
 				if (outBound_acqCH0 == 0 &&
 					outBound_acqCH1 == 0 &&
 					outBound_acqCH2 == 0) {
-					nacq = EQ_MIN_ACQ_STABLE_DETECTION;
-					early_cnt[EQ_CH0] =
-						accumulator[EQ_CH0] / nacq;
-					if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-						rx_print(
-						"3early_cnt_ch0=[%d]\n",
-							 early_cnt[EQ_CH0]);
-					early_cnt[EQ_CH1] =
-						accumulator[EQ_CH1] / nacq;
-					if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-						rx_print(
-						"3early_cnt_ch1=[%d]\n",
-						early_cnt[EQ_CH1]);
-					early_cnt[EQ_CH2] =
-						accumulator[EQ_CH2] / nacq;
-					if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-						rx_print(
-						"3early_cnt_ch2=[%d]\n",
-						 early_cnt[EQ_CH2]);
-					nretry = 0;
-					phy_eq_set_state(EQ_GET_CABLE_TYPE,
-								false);
-					phy_eq_task_continue();
-					return;
-				}
-			} else if (nretry == nacq) {
-				/* Finish averaging,  maximum number of
-							readings achieved */
-				nacq = nretry;
-				early_cnt[EQ_CH0] = accumulator[EQ_CH0] / nacq;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("5early_cnt_ch0=[%d]\n",
-							early_cnt[EQ_CH0]);
-				early_cnt[EQ_CH1] = accumulator[EQ_CH1] / nacq;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("5early_cnt_ch1=[%d]\n",
-							 early_cnt[EQ_CH1]);
-				early_cnt[EQ_CH2] = accumulator[EQ_CH2] / nacq;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("5early_cnt_ch2=[%d]\n",
-							 early_cnt[EQ_CH2]);
-				nretry = 0;
-				phy_eq_set_state(EQ_GET_CABLE_TYPE, false);
-				phy_eq_task_continue();
-				return;
-			}
-			/* Read next set of Early edges counter */
-			early_cnt[EQ_CH0] = hdmirx_rd_phy(PHY_EQSTAT3_CH0);
-			early_cnt[EQ_CH1] = hdmirx_rd_phy(PHY_EQSTAT3_CH1);
-			early_cnt[EQ_CH2] = hdmirx_rd_phy(PHY_EQSTAT3_CH2);
-
-			/* update the averaging accumulator */
-			accumulator[EQ_CH0] += early_cnt[EQ_CH0];
-			accumulator[EQ_CH1] += early_cnt[EQ_CH1];
-			accumulator[EQ_CH2] += early_cnt[EQ_CH2];
-		}
-		/* ********************** PLEASE README *********************/
-		/* if the following break gets removed, algorithm becomes
-		10mS*EQ_MAX_SETTING faster */
-	break;
-	case EQ_GET_CABLE_TYPE:
-		/* CABLE SETTING FOR THE BEST EQUALIZATION */
-		/* LONG CABLE EQUALIZATION */
-		if (tmds_valid_flag == 1) {
-			/* rx_print("enter cable type detection\n"); */
-			if ((early_cnt[EQ_CH0] < last_early_cnt[EQ_CH0]) &&
-					(finish_flag[EQ_CH0] == 0)) {
-				slope_accumulator[EQ_CH0] +=
-				(last_early_cnt[EQ_CH0] - early_cnt[EQ_CH0]);
-				if ((0 == valid_long_setting[EQ_CH0]) &&
-					(early_cnt[EQ_CH0] < eq_counter_th) &&
-					(slope_accumulator[EQ_CH0] >
-						EQ_SLOPEACM_MINTHRESHOLD)) {
-					best_long_setting[EQ_CH0] =
-							 eq_setting_back;
-					valid_long_setting[EQ_CH0] = 1;
+					rx_pr("STABLE ACQ\n");
+					setting = 3;
+					break;
 				}
-				stepSlope[EQ_CH0] =
-				 last_early_cnt[EQ_CH0]-early_cnt[EQ_CH0];
-			}
-			if ((early_cnt[EQ_CH1] < last_early_cnt[EQ_CH1]) &&
-					   (finish_flag[EQ_CH1] == 0)) {
-				slope_accumulator[EQ_CH1] +=
-				(last_early_cnt[EQ_CH1] - early_cnt[EQ_CH1]);
-				if ((0 == valid_long_setting[EQ_CH1]) &&
-					(early_cnt[EQ_CH1] < eq_counter_th) &&
-					(slope_accumulator[EQ_CH1] >
-						EQ_SLOPEACM_MINTHRESHOLD)) {
-					best_long_setting[EQ_CH1] =
-							eq_setting_back;
-					valid_long_setting[EQ_CH1] = 1;
-				}
-				stepSlope[EQ_CH1] =
-				last_early_cnt[EQ_CH1]-early_cnt[EQ_CH1];
-			}
-			if ((early_cnt[EQ_CH2] < last_early_cnt[EQ_CH2]) &&
-					   (finish_flag[EQ_CH2] == 0)) {
-				slope_accumulator[EQ_CH2] +=
-				(last_early_cnt[EQ_CH2] - early_cnt[EQ_CH2]);
-				if ((0 == valid_long_setting[EQ_CH2]) &&
-					(early_cnt[EQ_CH2] < eq_counter_th) &&
-					(slope_accumulator[EQ_CH2] >
-						EQ_SLOPEACM_MINTHRESHOLD)) {
-					best_long_setting[EQ_CH2] =
-							eq_setting_back;
-					valid_long_setting[EQ_CH2] = 1;
-				}
-				stepSlope[EQ_CH2] =
-				 last_early_cnt[EQ_CH2]-early_cnt[EQ_CH2];
-			}
-		}
-		/* SHORT CABLE EQUALIZATION */
-		if (tmds_valid_flag == 1 &&
-			eq_setting_back <= EQ_SHORT_CABLE_BEST_SETTING) {
-			/* Short setting better than default */
-			if (early_cnt[EQ_CH0] < eq_counter_th &&
-				valid_short_setting[EQ_CH0] == 0) {
-				best_short_setting[EQ_CH0] = eq_setting_back;
-				valid_short_setting[EQ_CH0] = 1;
-			}
-			if (eq_setting_back == EQ_SHORT_CABLE_BEST_SETTING &&
-				valid_short_setting[EQ_CH0] == 0) {
-				/* default Short setting is valid */
-				best_short_setting[EQ_CH0] =
-					EQ_SHORT_CABLE_BEST_SETTING;
-				valid_short_setting[EQ_CH0] = 1;
-			}
-			/* Short setting better than default */
-			if (early_cnt[EQ_CH1] < eq_counter_th &&
-				valid_short_setting[EQ_CH1] == 0) {
-				best_short_setting[EQ_CH1] = eq_setting_back;
-				valid_short_setting[EQ_CH1] = 1;
-			}
-			if (eq_setting_back == EQ_SHORT_CABLE_BEST_SETTING &&
-				valid_short_setting[EQ_CH1] == 0) {
-				/* Short setting is valid */
-				best_short_setting[EQ_CH1] =
-					 EQ_SHORT_CABLE_BEST_SETTING;
-				valid_short_setting[EQ_CH1] = 1;
-			}
 
-			if (early_cnt[EQ_CH2] < eq_counter_th &&
-				valid_short_setting[EQ_CH2] == 0) {
-				/* Short setting better than default */
-				best_short_setting[EQ_CH2] = eq_setting_back;
-				valid_short_setting[EQ_CH2] = 1;
-			}
-			if (eq_setting_back == EQ_SHORT_CABLE_BEST_SETTING &&
-				valid_short_setting[EQ_CH2] == 0) {
-				/* Short setting is valid */
-				best_short_setting[EQ_CH2] =
-					EQ_SHORT_CABLE_BEST_SETTING;
-				valid_short_setting[EQ_CH2] = 1;
 			}
+			acq_ch0 = rx_phy_rd_earlycnt_ch0();
+			acq_ch1 = rx_phy_rd_earlycnt_ch1();
+			acq_ch2 = rx_phy_rd_earlycnt_ch2();
+			eq_ch0.acq += acq_ch0;
+			eq_ch1.acq += acq_ch1;
+			eq_ch2.acq += acq_ch2;
 		}
+		eq_ch0.acq = eq_ch0.acq/setting;
+		eq_ch1.acq = eq_ch1.acq/setting;
+		eq_ch2.acq = eq_ch2.acq/setting;
+	}
+	return 1;
+}
 
-		/* CABLE DETECTION */
-		/* long cable */
-		if ((1 == valid_long_setting[EQ_CH0]) &&
-			(slope_accumulator[EQ_CH0] >
-			EQ_SLOPEACM_LONG_CABLE_THRESHOLD)
-			&& (finish_flag[EQ_CH0] == 0)) {
-			best_setting[EQ_CH0] = best_long_setting[EQ_CH0];
-			finish_flag[EQ_CH0] = 1;
-			if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-				rx_print("ch0:long cable\n");
+uint8_t SettingFinder(void)
+{
+	uint16_t actSetting = 0;
+	uint16_t retcodeCH0 = 0;
+	uint16_t retcodeCH1 = 0;
+	uint16_t retcodeCH2 = 0;
+	uint8_t tmds_valid = 0;
+
+	initvars(&eq_ch0);
+	initvars(&eq_ch1);
+	initvars(&eq_ch2);
+
+	/* Get statistics of early-late counters for setting 0 */
+	tmds_valid = aquireEarlyCnt(actSetting);
+
+
+	while (retcodeCH0 == 0 || retcodeCH1 == 0 || retcodeCH2 == 0) {
+		actSetting++;
+		/* Update last acquisition value,
+		for threshold crossing detection */
+		eq_ch0.lastacq = eq_ch0.acq;
+		eq_ch1.lastacq = eq_ch1.acq;
+		eq_ch2.lastacq = eq_ch2.acq;
+		/* Get statistics of early-late
+		counters for next setting */
+		tmds_valid = aquireEarlyCnt(actSetting);
+		/* check for cable type, stop after detection */
+		if (retcodeCH0 == 0) {
+			retcodeCH0 = testType(actSetting, &eq_ch0);
+			if ((log_flag & EQ_LOG) && retcodeCH0)
+				rx_pr("-CH0\n");
 		}
-		if ((1 == valid_long_setting[EQ_CH1]) &&
-			(slope_accumulator[EQ_CH1] >
-			EQ_SLOPEACM_LONG_CABLE_THRESHOLD) &&
-			(finish_flag[EQ_CH1] == 0)) {
-			best_setting[EQ_CH1] = best_long_setting[EQ_CH1];
-			finish_flag[EQ_CH1] = 1;
-			if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-				rx_print("ch1:long cable\n");
+		if (retcodeCH1 == 0) {
+			retcodeCH1 = testType(actSetting, &eq_ch1);
+			if ((log_flag & EQ_LOG) && retcodeCH1)
+				rx_pr("-CH1\n");
 		}
-		if ((1 == valid_long_setting[EQ_CH2]) &&
-			 (slope_accumulator[EQ_CH2] >
-			EQ_SLOPEACM_LONG_CABLE_THRESHOLD) &&
-			 (finish_flag[EQ_CH2] == 0)) {
-			best_setting[EQ_CH2] = best_long_setting[EQ_CH2];
-			finish_flag[EQ_CH2] = 1;
-			if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-				rx_print("ch2:long cable\n");
+		if (retcodeCH2 == 0) {
+			retcodeCH2 = testType(actSetting, &eq_ch2);
+			if ((log_flag & EQ_LOG) && retcodeCH2)
+				rx_pr("-CH2\n");
 		}
 
-		/* Maximum setting achieved without long cable detection,
-		so decision must be taken */
-		if (eq_setting_back >= EQ_MAX_SETTING) {
-			if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-				rx_print("eq reach the max settin---%d\n",
-				 eq_setting_back);
-			/* short cable */
-			if ((slope_accumulator[EQ_CH0] <
-				EQ_SLOPEACM_LONG_CABLE_THRESHOLD)
-				&& (finish_flag[EQ_CH0] == 0)) {
-				best_setting[EQ_CH0] =
-						best_short_setting[EQ_CH0];
-				finish_flag[EQ_CH0] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch0:short cable\n");
-			}
-			if ((slope_accumulator[EQ_CH1] <
-				EQ_SLOPEACM_LONG_CABLE_THRESHOLD)
-				&& (finish_flag[EQ_CH1] == 0)) {
-				best_setting[EQ_CH1] =
-					best_short_setting[EQ_CH1];
-				finish_flag[EQ_CH1] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch1:short cable\n");
-			}
-			if ((slope_accumulator[EQ_CH2] <
-				EQ_SLOPEACM_LONG_CABLE_THRESHOLD)
-				&& (finish_flag[EQ_CH2] == 0)) {
-				best_setting[EQ_CH2] =
-					best_short_setting[EQ_CH2];
-				finish_flag[EQ_CH2] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch2:short cable\n");
-			}
-			/* very long cable */
-			if ((slope_accumulator[EQ_CH0] >
-				EQ_SLOPEACM_LONG_CABLE_THRESHOLD) &&
-				(stepSlope[EQ_CH0] > EQ_MINSLOPE_VERYLONGCABLE)
-				&& tmds_valid_flag &&
-				(finish_flag[EQ_CH0] == 0)) {
-				best_setting[EQ_CH0] = EQ_MAX_SETTING;
-				finish_flag[EQ_CH0] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch0:very long cable\n");
-			}
-			if ((slope_accumulator[EQ_CH1] >
-				 EQ_SLOPEACM_LONG_CABLE_THRESHOLD) &&
-				(stepSlope[EQ_CH1] > EQ_MINSLOPE_VERYLONGCABLE)
-				&& tmds_valid_flag
-				&& (finish_flag[EQ_CH1] == 0)) {
-				best_setting[EQ_CH1] = EQ_MAX_SETTING;
-				finish_flag[EQ_CH1] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch1:very long cable\n");
-			}
-			if ((slope_accumulator[EQ_CH2] >
-				EQ_SLOPEACM_LONG_CABLE_THRESHOLD)
-				&& (stepSlope[EQ_CH2] >
-						EQ_MINSLOPE_VERYLONGCABLE)
-				&& tmds_valid_flag &&
-				(finish_flag[EQ_CH2] == 0)) {
-				best_setting[EQ_CH2] = EQ_MAX_SETTING;
-				finish_flag[EQ_CH2] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch2:very long cable\n");
-			}
-			/* error cable */
-			if (finish_flag[EQ_CH0] == 0) {
-				best_setting[EQ_CH0] =
-					 EQ_ERROR_CABLE_BEST_SETTING;
-				finish_flag[EQ_CH0] = 1;
-				error_cable_flag[EQ_CH0] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch0:error cable\n");
-			}
-			if (finish_flag[EQ_CH1] == 0) {
-				best_setting[EQ_CH1] =
-					 EQ_ERROR_CABLE_BEST_SETTING;
-				finish_flag[EQ_CH1] = 1;
-				error_cable_flag[EQ_CH1] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch1:error cable\n");
-			}
-			if (finish_flag[EQ_CH2] == 0) {
-				best_setting[EQ_CH2] =
-					 EQ_ERROR_CABLE_BEST_SETTING;
-				finish_flag[EQ_CH2] = 1;
-				error_cable_flag[EQ_CH2] = 1;
-				if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-					rx_print("ch2:error cable\n");
-			}
-		}
-		/* Algorithm already take the decision for all Channels */
-		if (finish_flag[EQ_CH0] && finish_flag[EQ_CH1] &&
-						 finish_flag[EQ_CH2]) {
-			phy_eq_set_state(EQ_CONF_BEST_SETTING, false);
-		} else {
-			/* Updating latest acquisition memory and jump
-			to the next setting */
-			eq_setting_back++;
-			if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-				rx_print("eq=[%d]\n", eq_setting_back);
-			last_early_cnt[EQ_CH0] = early_cnt[EQ_CH0];
-			last_early_cnt[EQ_CH1] = early_cnt[EQ_CH1];
-			last_early_cnt[EQ_CH2] = early_cnt[EQ_CH2];
-			phy_eq_set_state(EQ_SET_LOCK_VECTOR, false);
-		}
-		phy_eq_task_continue();
-	break;
-	case EQ_CONF_BEST_SETTING:
-		minmax_err_flag = 0;
-		if ((phy_maxvsmin(best_setting[EQ_CH0], best_setting[EQ_CH1],
-			best_setting[EQ_CH2]) == 0) ||
-			error_cable_flag[EQ_CH0] == 1
-			|| error_cable_flag[EQ_CH1] == 1 ||
-			error_cable_flag[EQ_CH2] == 1) {
-			rx_print("ch0-%d-%d,ch1-%d-%d,ch2-%d-%d\n",
-				best_setting[EQ_CH0], error_cable_flag[EQ_CH0],
-				best_setting[EQ_CH1], error_cable_flag[EQ_CH1],
-				best_setting[EQ_CH2], error_cable_flag[EQ_CH2]);
-			best_setting[EQ_CH0] = EQ_ERROR_CABLE_BEST_SETTING;
-			best_setting[EQ_CH1] = EQ_ERROR_CABLE_BEST_SETTING;
-			best_setting[EQ_CH2] = EQ_ERROR_CABLE_BEST_SETTING;
-			minmax_err_flag = 1;
-			minmax_check_cnt++;
-		}
-		if ((minmax_err_flag == 0) || (minmax_check_cnt >= 2)) {
-			tmds_valid_cnt = 0; /* What this means?	Are you
-			waiting for tmdsvalid? */
-			minmax_check_cnt = 0;
-			if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-				rx_print("eq cal->timing chage\n");
-		} else{ /* error detected and will retry */
-			phy_eq_set_state(EQ_DATA_START, false);
-			phy_eq_task_continue();
-			return;
-		}
-		/* please check readme for this particular function */
-		hdmirx_phy_conf_eq_setting(rx.port, best_setting[EQ_CH0],
-		best_setting[EQ_CH1], best_setting[EQ_CH2]);
-		rx_print("best EQ ch0=%d, ch1=%d,ch2=%d\n",
-		best_setting[EQ_CH0], best_setting[EQ_CH1],
-					best_setting[EQ_CH2]);
-		eq_setting[EQ_CH0] = best_setting[EQ_CH0];
-		eq_setting[EQ_CH1] = best_setting[EQ_CH1];
-		eq_setting[EQ_CH2] = best_setting[EQ_CH2];
-		/* Algorithm finish */
-		phy_eq_set_state(EQ_SUCCESS_END, false);
-	break;
-	default:
-	break;
 	}
-}
+	if (retcodeCH0 == 255 || retcodeCH1 == 255 || retcodeCH2 == 255)
+		return 0;
 
-void phy_set_cmd(enum phy_eq_cmd_e cmd)
-{
-	spin_lock(&phy_private_data->slock);
-	phy_private_data->cmd = cmd;
-	phy_private_data->new_cmd = true;
-	spin_unlock(&phy_private_data->slock);
-}
+	return 1;
 
-int phy_eq_task(void *data)
-{
-	while (phy_private_data->task_running) {
-		wait_for_completion_interruptible(
-			&((struct hdmirx_phy_data_t *)data)->phy_task_lock);
-		/*while (
-		down_trylock(&((struct hdmirx_phy_data_t *)data)->phy_task_lock)
-			== 0);*/
-		phy_EQ_workaround();
-	}
-	return 0;
 }
 
 void hdmirx_phy_conf_eq_setting(int rx_port_sel, int ch0Setting,
@@ -855,7 +441,7 @@ void hdmirx_phy_conf_eq_setting(int rx_port_sel, int ch0Setting,
 {
 	unsigned int data32;
 	if (hdmirx_log_flag&VIDEO_LOG_ENABLE)
-		rx_print("hdmirx_phy_conf_eq_setting\n");
+		rx_pr("hdmirx_phy_conf_eq_setting\n");
 	/* PDDQ = 1'b1; PHY_RESET = 1'b0; */
 	data32  = 0;
 	data32 |= 1             << 6;   /* [6]      physvsretmodez */
@@ -892,7 +478,7 @@ bool hdmirx_phy_clk_rate_monitor(void)
 	else
 		clk_rate = (hdmirx_rd_dwc(DWC_SCDC_REGS0) >> 17) & 1;
 
-	if (clk_rate != hdmirx_tmds_34g()) {
+	if (clk_rate != hdmirx_tmds_6g()) {
 		changed = true;
 		for (i = 0; i < 3; i++) {
 			if (1 == clk_rate) {
@@ -908,233 +494,11 @@ bool hdmirx_phy_clk_rate_monitor(void)
 				(clk_rate << 8))
 				break;
 		}
-		rx_print("clk_rate:%d, save: %d\n",
-			clk_rate, phy_private_data->last_clk_rate);
 	}
 	return changed;
 }
 
-int hdmirx_phy_probe(void)
-{
-	phy_init_param();
-	phy_private_data = kmalloc(sizeof(struct hdmirx_phy_data_t),
-							GFP_KERNEL);
-	if (phy_private_data == NULL)
-		return -1;
-	/*phy_eq_algo_data= kmalloc(sizeof(struct phy_eq_algorithm_data_t),
-							GFP_KERNEL);
-	if (phy_eq_algo_data == NULL)
-		return -1;*/
-	spin_lock_init(&phy_private_data->slock);
-	mutex_init(&phy_private_data->state_lock);
-	init_completion(&phy_private_data->phy_task_lock);
-	phy_private_data->task_running = true;
-	phy_private_data->cmd = 0;
-	phy_private_data->new_cmd = false;
-	phy_private_data->task = kthread_create(phy_eq_task,
-				phy_private_data, "eq");
-	if (IS_ERR(phy_private_data->task)) {
-		rx_print("thread creating error.\n");
-		return -1;
-	}
-	wake_up_process(phy_private_data->task);
-	return 0;
-}
-
-void hdmirx_phy_exit(void)
-{
-	if (phy_private_data->task) {
-		phy_private_data->cmd = EQ_STOP;
-		phy_private_data->task_running = false;
-		send_sig(SIGTERM, phy_private_data->task, 1);
-		complete(&phy_private_data->phy_task_lock);
-		kthread_stop(phy_private_data->task);
-		phy_private_data->task = NULL;
-	}
-
-	kfree(phy_private_data);
-	/*kfree(phy_eq_algo_data);*/
-}
-
-int hdmirx_phy_start_eq(void)
-{
-	if (phy_private_data != NULL) {
-		phy_set_cmd(EQ_START);
-		complete(&phy_private_data->phy_task_lock);
-		rx_print("%s\n", __func__);
-	} else {
-		return -1;
-	}
-
-	return 0;
-}
-
-int hdmirx_phy_stop_eq(void)
-{
-	if (phy_private_data != NULL) {
-		if ((hdmirx_phy_get_eq_state() != EQ_IDLE) &&
-			(hdmirx_phy_get_eq_state() < EQ_SUCCESS_END))
-			phy_set_cmd(EQ_STOP);
-		rx_print("%s\n", __func__);
-	} else {
-		return -1;
-	}
-
-
-	return 0;
-}
-
-int hdmirx_phy_suspend_eq(void)
-{
-	hdmirx_phy_stop_eq();
-
-	while ((phy_private_data->phy_eq_state > EQ_IDLE)
-		&& (phy_private_data->phy_eq_state <
-		EQ_SUCCESS_END)) {
-		block_delay_ms(1);
-	}
-
-	return 0;
-}
-
-void hdmirx_phy_reset(int rx_port_sel, int dcm)
-{
-	unsigned int data32;
-	data32	= 0;
-	data32 |= 1 << 6;
-	data32 |= 1 << 4;
-	data32 |= rx_port_sel << 2;
-	data32 |= 1 << 1;
-	data32 |= 0 << 0;
-	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, data32);
-
-	hdmirx_wr_phy(0x43, fat_bit_status);
-	hdmirx_wr_phy(0x63, fat_bit_status);
-	hdmirx_wr_phy(0x83, fat_bit_status);
-
-	hdmirx_wr_phy(PHY_CH0_EQ_CTRL3, eq_setting[EQ_CH0]);
-	hdmirx_wr_phy(PHY_CH1_EQ_CTRL3, eq_setting[EQ_CH1]);
-	hdmirx_wr_phy(PHY_CH2_EQ_CTRL3, eq_setting[EQ_CH2]);
-	if ((0 == eq_setting[EQ_CH0]) &&
-		(0 == eq_setting[EQ_CH1]) &&
-		(0 == eq_setting[EQ_CH2]))
-		hdmirx_wr_phy(PHY_MAIN_FSM_OVERRIDE2, 0x0);
-	else
-		hdmirx_wr_phy(PHY_MAIN_FSM_OVERRIDE2, 0x40);
-
-	/*hdmirx_phy_clk_rate_monitor();*/
-
-	data32 = 0;
-	data32 |= 1 << 6;
-	data32 |= 1 << 4;
-	data32 |= rx_port_sel << 2;
-	data32 |= 0 << 1;
-	data32 |= 0 << 0;
-	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, data32);
-
-	rx_print("%s  %d Done!\n", __func__, rx.port);
-}
-
-void hdmirx_phy_init(int rx_port_sel, int dcm)
-{
-	unsigned int data32;
-	data32 = 0;
-	data32 |= 1 << 6;
-	data32 |= 1 << 4;
-	data32 |= rx_port_sel << 2;
-	data32 |= 1 << 1;
-	data32 |= 1 << 0;
-	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, data32);
-	mdelay(1);
-
-	data32	= 0;
-	data32 |= 1 << 6;
-	data32 |= 1 << 4;
-	data32 |= rx_port_sel << 2;
-	data32 |= 1 << 1;
-	data32 |= 0 << 0;
-	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, data32);
-
-	hdmirx_wr_phy(MPLL_PARAMETERS2,    0x1c94);
-	hdmirx_wr_phy(MPLL_PARAMETERS3,    0x3713);
-	hdmirx_wr_phy(MPLL_PARAMETERS4,    mpll_param4);
-	hdmirx_wr_phy(MPLL_PARAMETERS5,    0x5492);
-	hdmirx_wr_phy(MPLL_PARAMETERS6,    0x4b0d);
-	hdmirx_wr_phy(MPLL_PARAMETERS7,    0x4760);
-	hdmirx_wr_phy(MPLL_PARAMETERS8,    0x008c);
-	hdmirx_wr_phy(MPLL_PARAMETERS9,    0x0010);
-	hdmirx_wr_phy(MPLL_PARAMETERS10,   0x2d20);
-	hdmirx_wr_phy(MPLL_PARAMETERS11, 0x2e31);
-	hdmirx_wr_phy(MPLL_PARAMETERS12, 0x4b64);
-	hdmirx_wr_phy(MPLL_PARAMETERS13, 0x2493);
-	hdmirx_wr_phy(MPLL_PARAMETERS14, 0x676d);
-	hdmirx_wr_phy(MPLL_PARAMETERS15, 0x23e0);
-	hdmirx_wr_phy(MPLL_PARAMETERS16, 0x001b);
-	hdmirx_wr_phy(MPLL_PARAMETERS17, 0x2218);
-	hdmirx_wr_phy(MPLL_PARAMETERS18, 0x1b25);
-	hdmirx_wr_phy(MPLL_PARAMETERS19, 0x2492);
-	hdmirx_wr_phy(MPLL_PARAMETERS20, 0x48ea);
-	hdmirx_wr_phy(MPLL_PARAMETERS21, 0x0011);
-	hdmirx_wr_phy(MPLL_PARAMETERS22, 0x04d2);
-	hdmirx_wr_phy(MPLL_PARAMETERS23, 0x0414);
-
-	hdmirx_wr_phy(0x43, fat_bit_status);
-	hdmirx_wr_phy(0x63, fat_bit_status);
-	hdmirx_wr_phy(0x83, fat_bit_status);
-
-	/* Configuring I2C to work in fastmode */
-	hdmirx_wr_dwc(DWC_I2CM_PHYG3_MODE,	 0x1);
-	/* disable overload protect for Philips DVD */
-	/* NOTE!!!!! don't remove below setting */
-	hdmirx_wr_phy(OVL_PROT_CTRL, 0xa);
-
-	data32 = 0;
-	data32 |= 0	<< 15;
-	data32 |= 0	<< 13;
-	data32 |= 0	<< 12;
-	data32 |= fast_switching << 11;
-	data32 |= 0	<< 10;
-	data32 |= rx.phy.fsm_enhancement << 9;
-	data32 |= 0	<< 8;
-	data32 |= 0	<< 7;
-	data32 |= dcm << 5;
-	data32 |= 0	<< 3;
-	data32 |= rx.phy.port_select_ovr_en << 2;
-	data32 |= rx_port_sel << 0;
-
-	hdmirx_wr_phy(PHY_SYSTEM_CONFIG,
-		(rx.phy.phy_system_config_force_val != 0) ?
-		rx.phy.phy_system_config_force_val : data32);
-
-	hdmirx_wr_phy(PHY_CMU_CONFIG,
-		(rx.phy.phy_cmu_config_force_val != 0) ?
-		rx.phy.phy_cmu_config_force_val :
-		((rx.phy.lock_thres << 10) | (1 << 9) |
-			(((1 << 9) - 1) & ((rx.phy.cfg_clk * 4) / 1000))));
-
-	hdmirx_wr_phy(PHY_CH0_EQ_CTRL3, eq_setting[EQ_CH0]);
-	hdmirx_wr_phy(PHY_CH1_EQ_CTRL3, eq_setting[EQ_CH1]);
-	hdmirx_wr_phy(PHY_CH2_EQ_CTRL3, eq_setting[EQ_CH2]);
-	if ((0 == eq_setting[EQ_CH0]) &&
-		(0 == eq_setting[EQ_CH1]) &&
-		(0 == eq_setting[EQ_CH2]))
-		hdmirx_wr_phy(PHY_MAIN_FSM_OVERRIDE2, 0x0);
-	else
-		hdmirx_wr_phy(PHY_MAIN_FSM_OVERRIDE2, 0x40);
-
-	/*hdmirx_phy_clk_rate_monitor();*/
-
-	data32 = 0;
-	data32 |= 1 << 6;
-	data32 |= 1 << 4;
-	data32 |= rx_port_sel << 2;
-	data32 |= 0 << 1;
-	data32 |= 0 << 0;
-	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, data32);
-
-	rx_print("%s  %d Done!\n", __func__, rx.port);
-}
-
+#if 0
 bool hdmirx_phy_check_tmds_valid(void)
 {
 	if ((((hdmirx_rd_phy(0x30) & 0x80) == 0x80) | finish_flag[EQ_CH0]) &&
@@ -1144,19 +508,53 @@ bool hdmirx_phy_check_tmds_valid(void)
 	else
 		return false;
 }
+#endif
 
-enum phy_eq_states_e hdmirx_phy_get_eq_state(void)
+bool rx_need_eq_workaround(void)
 {
-	return phy_private_data->phy_eq_state;
-}
 
-void hdmirx_phy_EQ_workaround_init(void)
-{
-	/* ConfEqualSingle */
+	int mfsm_status = hdmirx_rd_phy(PHY_MAINFSM_STATUS1);
+
+	/* configure FATBITS PHY */
+	if (hdmirx_tmds_6g()) {
+		fat_bit_status = EQ_FATBIT_MASK_HDMI20;
+		min_max_diff = MINMAX_maxDiff_HDMI20;
+		if (log_flag & EQ_LOG)
+			rx_pr("EQ_6G\n");
+	} else if ((mfsm_status & 0x600) == 0x00) {
+		fat_bit_status = EQ_FATBIT_MASK_4k;
+		min_max_diff = MINMAX_maxDiff;
+		if (log_flag & EQ_LOG)
+			rx_pr("EQ_3G\n");
+	} else if ((mfsm_status & 0x400) == 0x400) {
+		fat_bit_status = EQ_FATBIT_MASK;
+		min_max_diff = MINMAX_maxDiff;
+		if (log_flag & EQ_LOG)
+			rx_pr("EQ_low_freq\n");
+		return false;
+	} else {
+		/* 94.5 ~ 148.5 */
+		fat_bit_status = EQ_FATBIT_MASK;
+		min_max_diff = MINMAX_maxDiff;
+		if (log_flag & EQ_LOG)
+			rx_pr("EQ_1.5G\n");
+	}
+
 	hdmirx_wr_phy(PHY_MAIN_FSM_OVERRIDE2, 0x0);
-	rx_print("hdmirx_phy_EQ_workaround_init\n");
+	hdmi_rx_phy_ConfEqualSingle();
+	#if 0
 	hdmirx_wr_phy(PHY_EQCTRL1_CH0, 0x0211);
 	hdmirx_wr_phy(PHY_EQCTRL1_CH1, 0x0211);
 	hdmirx_wr_phy(PHY_EQCTRL1_CH2, 0x0211);
-}
 
+	hdmirx_wr_phy(PHY_EQCTRL2_CH0, 0x0024 | (avgAcq << 11));
+	hdmirx_wr_phy(PHY_EQCTRL2_CH1, 0x0024 | (avgAcq << 11));
+	hdmirx_wr_phy(PHY_EQCTRL2_CH2, 0x0024 | (avgAcq << 11));
+	#endif
+	/* hdmi_rx_phy_ConfLockVecFirst(dev, 0); */
+	hdmirx_wr_phy(PHY_EQCTRL6_CH0, fat_bit_status);
+	hdmirx_wr_phy(PHY_EQCTRL6_CH1, fat_bit_status);
+	hdmirx_wr_phy(PHY_EQCTRL6_CH2, fat_bit_status);
+
+	return true;
+}
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_eq.h b/drivers/amlogic/tvin/hdmirx/hdmi_rx_eq.h
index cbe81bd..aa9049b 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_eq.h
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_eq.h
@@ -13,65 +13,55 @@
 
 #ifndef _HDMI_RX_EQ_H
 #define _HDMI_RX_EQ_H
+/* time mS */
+#define WaitTimeStartConditions	3
+/* WAIT FOR, CDR LOCK and TMDSVALID */
+#define sleep_time_CDR	10
+/* Maximum slope  accumulator to consider the cable as a short cable */
+#define AccLimit	360
+/* Minimum slope accumulator to consider the following setting */
+#define AccMinLimit	0
+/* suitable for a long cable */
+/* Maximum allowable setting, HW as the maximum = 15, should */
+#define maxsetting	14
+/* only be need for ultra long cables at high rates,
+condition never detected on LAB */
+/* Default setting for short cables,
+if system cannot find any one better than this. */
+#define shortcableSetting	4
+/* Default setting when system cannot detect the cable type */
+#define ErrorcableSetting	4
+/* Minimum current slope needed to consider the cable
+as "very long" and therefore */
+#define minSlope	50
+/* max setting is suitable for equalization */
+/* Maximum number of early-counter measures to average each setting */
+#define avgAcq	4
+/* Threshold Value for the statistics counter */
+/* 3'd0: Selects counter threshold 1K */
+/* 3'd1: Selects counter threshold 2K */
+/* 3'd2: Selects counter threshold 4K */
+/* 3d3: Selects counter threshold 8K */
+/* 3d4: Selects counter threshold 16K */
+/* Number of retries in case of algorithm ending with errors */
+#define MINMAX_nTrys	3
+/* theoretical threshold for an equalized system */
+#define equalizedCounterValue	512
+/* theoretical threshold for an equalized system */
+#define equalizedCounterValue_HDMI20	512
+/* Maximum  difference between pairs */
+#define MINMAX_maxDiff	4
+/* Maximum  difference between pairs  under HDMI2.0 MODE */
+#define MINMAX_maxDiff_HDMI20	2
+/* FATBIT MASK FOR hdmi-1.4 xxxx_001 or xxxx_110 */
+#define EQ_FATBIT_MASK	0x0000
+/* hdmi 1.4 ( pll rate = 00) xx00_001 or xx11_110 */
+#define EQ_FATBIT_MASK_4k	0x0c03
+/* for hdmi2.0 x000_001 or x111_110 */
+#define EQ_FATBIT_MASK_HDMI20	0x0e03
 
-/*-------------------macro define---------------------------*/
-#define MIN_SLOPE		50
-#define ACC_MIN_LIMIT	0
-#define ACC_LIMIT		370
-/* #define EQ_MAX_SETTING 12//for very long cable */
-#define MINDIFF		4/* max min diff between data chs on hdmi1.4 */
-#define MINDIFF_HDMI20	2/* max min diff between data chs on hdmi2.0 */
-#define EQ_CLK_WAIT_MAX_COUNT 1000
-#define EQ_CLK_WAIT_STABLE_COUNT (EQ_CLK_WAIT_MAX_COUNT - 900)
-#define EQ_CLK_WAIT_DELAY 5
-#define EQ_TMDS_VALID_WAIT_DELAY 3
-/*#define EQ_CLK_RATE_WAIT 15*/
 #define block_delay_ms(x) msleep_interruptible((x))
 
-/* Default best setting */
-#define EQ_DEFAULT_SETTING 4
-/* wait time between early/late counter acquisitions */
-#define EQ_WAITTIME						1
-/* Slope acumulator, minimum limit  to
-consider setting suitable for long cable */
-#define EQ_SLOPEACM_MINTHRESHOLD			0
-/* Slope acumulator threshold to considere as long cable */
-#define EQ_SLOPEACM_LONG_CABLE_THRESHOLD	360
-/* minimum slope at maximum setting to consider it as a long cable */
-#define EQ_MINSLOPE_VERYLONGCABLE			50
-/* threshold for equalized system */
-#define EQ_COUNTERTHRESHOLD				512
-/* threshold for equalized system */
-#define EQ_COUNTERTHRESHOLD_HDMI20			512
-/* Maximum allowable setting */
-#define EQ_MAX_SETTING						7/* 13 */
-/* Default best setting for short cables (electrical short length) */
-#define EQ_SHORT_CABLE_BEST_SETTING		4
-/* Default setting when not good equalization is achieved,
-same as short cable */
-#define EQ_ERROR_CABLE_BEST_SETTING		4
-/* Stop averaging (Stable measures), if early/late counter
-acquisitions are within the following range 1oread +-20 */
-#define EQ_BOUNDARYSPREAD					20
-/* Minimum number of early/late counter acquisitions
-to considere a stable acquisition */
-#define EQ_MIN_ACQ_STABLE_DETECTION			3
-/* wait time between early/late counter acquisitions */
-#define EQ_WAITTIME							1
-/* Slope acumulator, minimum limit  to consider setting
-suitable for long cable */
-#define EQ_SLOPEACM_MINTHRESHOLD			0
-/* Slope acumulator threshold to considere as long cable */
-#define	EQ_SLOPEACM_LONG_CABLE_THRESHOLD	360
-/* minimum slope at maximum setting to consider it as a long cable */
-#define EQ_MINSLOPE_VERYLONGCABLE			50
-/* hdmi 1.4 */
-#define EQ_FATBIT_MASK						0
-/* hdmi 1.4 & pll rate = 00 */
-#define EQ_FATBIT_MASK_4k					0xc03
-/* for hdmi2.0 */
-#define EQ_FATBIT_MASK_HDMI20				0xe03
-
 #define FSM_LOG_ENABLE		0x01
 #define VIDEO_LOG_ENABLE	0x02
 #define AUDIO_LOG_ENABLE	0x04
@@ -84,15 +74,9 @@ suitable for long cable */
 /*--------------------------enum define---------------------*/
 enum phy_eq_states_e {
 	EQ_IDLE,
-	EQ_DATA_START,
-	EQ_SET_LOCK_VECTOR,
-	EQ_SET_FORCE_FMS_STATE,
-	EQ_CHECK_TMDS_VALID,
-	EQ_AQUIRE_EARLY_COUNTER,
-	EQ_GET_CABLE_TYPE,
-	EQ_CONF_BEST_SETTING,
-	EQ_SUCCESS_END,
-	EQ_FAILED,
+	EQ_INIT,
+	EQ_MAINLOOP,
+	EQ_END,
 };
 
 enum phy_eq_channel_e {
@@ -107,82 +91,28 @@ enum phy_eq_cmd_e {
 	EQ_STOP,
 };
 
-/*enum define end*/
-
-/*--------------------------struct define---------------------*/
-struct phy_eq_algorithm_data_t {
-	int nretry;
-	/* Auxiliary variable to perform early-late counters averaging */
-	int accumulator[EQ_CH_NUM];
-
-	/* Variables to store early-late counters averaging */
-	int early_cnt[EQ_CH_NUM];
-
-	/* Variables to store early-late counters slope */
-	int slope_accumulator[EQ_CH_NUM];
-
-	/* Auxiliary variable to detect early-late counters trend (up/down) */
-	int last_early_cnt[EQ_CH_NUM];
-
-	/* EQ Best Long cable setting and valid flag */
-	int best_long_setting[EQ_CH_NUM];
-	int valid_long_setting[EQ_CH_NUM];
-
-	/* EQ Best Short cable setting and valid flag */
-	int best_short_setting[EQ_CH_NUM];
-	int valid_short_setting[EQ_CH_NUM];
-
-	/* EQ Final Setting should be programed to the PHY */
-	int best_setting[EQ_CH_NUM];
-
-	/*Auxiliary variables to detect stable acquisitions this
-	will save 2mS * EQ_MAX_SETTING when good cables are used*/
-	int upperBound_acqCH0, upperBound_acqCH1, upperBound_acqCH2;
-	int lowerBound_acqCH0, lowerBound_acqCH1, lowerBound_acqCH2;
-	int outBound_acqCH0, outBound_acqCH1, outBound_acqCH2;
-
-	/* Auxiliary variables to control algorithm status */
-	bool ch0_error_cable_flag;
-	bool ch1_error_cable_flag;
-	bool ch2_error_cable_flag;
-	bool tmds_valid_flag;
-
-	/*Auxiliary variable to control how many times Algorithm
-	will retry if any error is detected*/
-	bool minmax_err_flag;
-	int minmax_check_cnt;
-	int pll_rate_value;
-};
-
-struct hdmirx_phy_data_t {
-	struct completion phy_task_lock;
-	enum phy_eq_states_e phy_eq_state;
-	struct task_struct *task;
-	int phy_clk_wait_count;
-	bool task_running;
-	enum phy_eq_cmd_e cmd;
-	bool new_cmd;
-	spinlock_t slock;
-	struct mutex state_lock;
-	bool last_clk_rate;
-};
-
 /*struct define end*/
+extern struct st_eq_data eq_ch0;
+extern struct st_eq_data eq_ch1;
+extern struct st_eq_data eq_ch2;
 
 /*--------------------------function declare------------------*/
 bool hdmirx_phy_clk_rate_monitor(void);
-void hdmirx_phy_init(int rx_port_sel, int dcm);
-void hdmirx_phy_EQ_workaround_init(void);
+/* void hdmirx_phy_init(int rx_port_sel, int dcm); */
+bool rx_need_eq_workaround(void);
 int hdmirx_phy_probe(void);
 void hdmirx_phy_exit(void);
 int hdmirx_phy_start_eq(void);
-enum phy_eq_states_e hdmirx_phy_get_eq_state(void);
-int hdmirx_phy_stop_eq(void);
-void hdmirx_phy_reset(int rx_port_sel, int dcm);
-int hdmirx_phy_suspend_eq(void);
+uint8_t SettingFinder(void);
+bool eq_maxvsmin(int ch0Setting, int ch1Setting, int ch2Setting);
+
+/* int hdmirx_phy_suspend_eq(void); */
 bool hdmirx_phy_check_tmds_valid(void);
 void hdmirx_phy_conf_eq_setting(int rx_port_sel,
 	int ch0Setting,	int ch1Setting, int ch2Setting);
+void phy_conf_eq_setting(int ch0_lockVector,
+				int ch1_lockVector, int ch2_lockVector);
+
 
 /*function declare end*/
 
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
index ee87dca..cf2ce16 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
@@ -65,11 +65,6 @@
 
 #define AUDIO_OUTPUT_SELECT I2S_32BIT_256FS_OUTPUT
 
-#define HDMIRX_ADDR_PORT	0xda83e000
-#define HDMIRX_DATA_PORT	0xda83e004
-#define HDMIRX_CTRL_PORT	0xda83e008
-#define TOP_INT_MASK_VALUE	0x000003fd
-
 static DEFINE_SPINLOCK(reg_rw_lock);
 
 static int auto_aclk_mute = 2;
@@ -115,6 +110,10 @@ MODULE_PARM_DESC(phy_init_in_probe,
 	"\n phy_init_in_probe\n");
 module_param(phy_init_in_probe, bool, 0664);
 
+static int mpll_param4 = 0x24dc;
+MODULE_PARM_DESC(mpll_param4, "\n mpll_param4\n");
+module_param(mpll_param4, int, 0664);
+
 /* bit5 pll_lck_chg_en */
 /* bit6 clk_change_en */
 int hdmi_ists_en = AKSV_RCV;
@@ -130,10 +129,10 @@ bool hdcp_enable = 1;
 MODULE_PARM_DESC(hdcp_enable, "\n hdcp_enable\n");
 module_param(hdcp_enable, bool, 0664);
 #ifdef HDCP22_ENABLE
-int hdcp_22_on;
-MODULE_PARM_DESC(hdcp_22_on, "\n hdcp_22_on\n");
-module_param(hdcp_22_on, int, 0664);
-static int hdcp_22_nonce_hw_en = 1;
+int hdcp22_on;
+MODULE_PARM_DESC(hdcp22_on, "\n hdcp22_on\n");
+module_param(hdcp22_on, int, 0664);
+/* static int hdcp_22_nonce_hw_en = 1; */
 
 #define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
 
@@ -150,6 +149,17 @@ static int hdmi_mode_hyst = 5;
 MODULE_PARM_DESC(hdmi_mode_hyst, "\n hdmi_mode_hyst\n");
 module_param(hdmi_mode_hyst, int, 0664);
 
+static bool fast_switching = true;
+MODULE_PARM_DESC(fast_switching, "\n fast_switching\n");
+module_param(fast_switching, bool, 0664);
+
+static bool use_i2c_infilter = true;
+MODULE_PARM_DESC(use_i2c_infilter, "\n use_i2c_infilter\n");
+module_param(use_i2c_infilter, bool, 0664);
+
+int top_intr_maskn_value = 0x1e0001;
+MODULE_PARM_DESC(top_intr_maskn_value, "\n top_intr_maskn_value\n");
+module_param(top_intr_maskn_value, int, 0664);
 
 /**
  * Read data from HDMI RX CTRL
@@ -162,8 +172,8 @@ uint32_t hdmirx_rd_dwc(uint16_t addr)
 	int data;
 	unsigned long dev_offset = 0x10;
 	spin_lock_irqsave(&reg_rw_lock, flags);
-	wr_reg(HDMIRX_ADDR_PORT | dev_offset, addr);
-	data = rd_reg(HDMIRX_DATA_PORT | dev_offset);
+	wr_reg(hdmirx_addr_port | dev_offset, addr);
+	data = rd_reg(hdmirx_data_port | dev_offset);
 	spin_unlock_irqrestore(&reg_rw_lock, flags);
 	return data;
 }
@@ -179,8 +189,8 @@ void hdmirx_wr_dwc(uint16_t addr, uint32_t data)
 	ulong flags;
 	unsigned long dev_offset = 0x10;
 	spin_lock_irqsave(&reg_rw_lock, flags);
-	wr_reg(HDMIRX_ADDR_PORT | dev_offset, addr);
-	wr_reg(HDMIRX_DATA_PORT | dev_offset, data);
+	wr_reg(hdmirx_addr_port | dev_offset, addr);
+	wr_reg(hdmirx_data_port | dev_offset, data);
 	spin_unlock_irqrestore(&reg_rw_lock, flags);
 }
 
@@ -210,7 +220,7 @@ uint16_t hdmirx_rd_phy(uint8_t reg_address)
 		}
 		cnt++;
 		if (cnt > 50000) {
-			rx_print("[HDMIRX err]: %s(%x,%x) timeout\n",
+			rx_pr("[HDMIRX err]: %s(%x,%x) timeout\n",
 				__func__, 0x39, reg_address);
 			break;
 		}
@@ -241,7 +251,7 @@ int hdmirx_wr_phy(uint8_t reg_address, uint16_t data)
 		if (cnt > 50000) {
 			error = -1;
 			if (log_flag & ERR_LOG) {
-				rx_print("[error]:(%x,%x,%x)timeout\n",
+				rx_pr("[error]:(%x,%x,%x)timeout\n",
 					__func__, 0x39, reg_address, data);
 			}
 			break;
@@ -255,8 +265,8 @@ void hdmirx_wr_top(unsigned long addr, unsigned long data)
 	ulong flags;
 	unsigned long dev_offset = 0;
 	spin_lock_irqsave(&reg_rw_lock, flags);
-	wr_reg(HDMIRX_ADDR_PORT | dev_offset, addr);
-	wr_reg(HDMIRX_DATA_PORT | dev_offset, data);
+	wr_reg(hdmirx_addr_port | dev_offset, addr);
+	wr_reg(hdmirx_data_port | dev_offset, data);
 	spin_unlock_irqrestore(&reg_rw_lock, flags);
 }
 
@@ -266,9 +276,9 @@ unsigned long hdmirx_rd_top(unsigned long addr)
 	int data;
 	unsigned long dev_offset = 0;
 	spin_lock_irqsave(&reg_rw_lock, flags);
-	wr_reg(HDMIRX_ADDR_PORT | dev_offset, addr);
-	wr_reg(HDMIRX_ADDR_PORT | dev_offset, addr);
-	data = rd_reg(HDMIRX_DATA_PORT | dev_offset);
+	wr_reg(hdmirx_addr_port | dev_offset, addr);
+	wr_reg(hdmirx_addr_port | dev_offset, addr);
+	data = rd_reg(hdmirx_data_port | dev_offset);
 	spin_unlock_irqrestore(&reg_rw_lock, flags);
 	return data;
 } /* hdmirx_rd_TOP */
@@ -297,7 +307,7 @@ void rx_hdcp22_rd_check(uint32_t addr, uint32_t exp_data, uint32_t mask)
 	uint32_t rd_data;
 	rd_data = rx_hdcp22_rd(addr);
 	if ((rd_data | mask) != (exp_data | mask))
-		rx_print("addr=0x%02x rd_data=0x%08x\n", addr, rd_data);
+		rx_pr("addr=0x%02x rd_data=0x%08x\n", addr, rd_data);
 }
 
 void rx_hdcp22_wr(uint32_t addr, uint32_t data)
@@ -422,7 +432,7 @@ void hdmirx_wr_ctl_port(unsigned int offset, unsigned long data)
 {
 	ulong flags;
 	spin_lock_irqsave(&reg_rw_lock, flags);
-	wr_reg(HDMIRX_CTRL_PORT+offset, data);
+	wr_reg(hdmirx_ctrl_port+offset, data);
 	spin_unlock_irqrestore(&reg_rw_lock, flags);
 }
 
@@ -432,13 +442,13 @@ int hdmirx_irq_close(void)
 
 	/* clear enable */
 	hdmirx_wr_dwc(DWC_PDEC_IEN_CLR, ~0);
-	hdmirx_wr_dwc(DWC_AUD_CLK_IEN_CLR, ~0);
+	hdmirx_wr_dwc(DWC_AUD_CEC_IEN_CLR, ~0);
 	hdmirx_wr_dwc(DWC_AUD_FIFO_IEN_CLR, ~0);
 	hdmirx_wr_dwc(DWC_MD_IEN_CLR, ~0);
 	hdmirx_wr_dwc(DWC_HDMI_IEN_CLR, ~0);
 	/* clear status */
 	hdmirx_wr_dwc(DWC_PDEC_ICLR, ~0);
-	hdmirx_wr_dwc(DWC_AUD_CLK_ICLR, ~0);
+	hdmirx_wr_dwc(DWC_AUD_CEC_ICLR, ~0);
 	hdmirx_wr_dwc(DWC_AUD_FIFO_ICLR, ~0);
 	hdmirx_wr_dwc(DWC_MD_ICLR, ~0);
 	hdmirx_wr_dwc(DWC_HDMI_ICLR, ~0);
@@ -452,7 +462,7 @@ int hdmirx_irq_open(void)
 
 	hdmirx_wr_dwc(DWC_PDEC_IEN_SET, DRM_RCV_EN | DRM_CKS_CHG);
 	hdmirx_wr_dwc(DWC_AUD_FIFO_IEN_SET, OVERFL|UNDERFL);
-	if (hdcp_22_on)
+	if (hdcp22_on)
 		hdmirx_wr_dwc(DWC_HDMI2_IEN_SET, 0x3f);
 	/*hdmirx_wr_dwc(DWC_MD_IEN_SET, rx_md_ists_en);*/
 	hdmirx_wr_dwc(DWC_HDMI_IEN_SET, hdmi_ists_en);
@@ -556,8 +566,6 @@ static int DWC_init(unsigned port)
 	hdmirx_control_clk_range(TMDS_CLK_MIN,
 		TMDS_CLK_MAX);
 
-	hdmirx_wr_bits_dwc(DWC_HDMI_PCB_CTRL,
-	INPUT_SELECT, port);
 	hdmirx_wr_bits_dwc(DWC_SNPS_PHYG3_CTRL,
 		((1 << 2) - 1) << 2, port);
 
@@ -571,7 +579,21 @@ static int DWC_init(unsigned port)
 	data32 |= edid_clock_divide << 0;
 	hdmirx_wr_top(TOP_EDID_GEN_CNTL,  data32);
 
-	hdmirx_wr_top(TOP_EDID_ADDR_CEC, EDID_CEC_ID_ADDR);
+	/* hdmirx_wr_top(TOP_EDID_ADDR_CEC, EDID_CEC_ID_ADDR); */
+
+	if (is_meson_gxtvbb_cpu()) {
+		hdmirx_wr_top(TOP_INFILTER_GXTVBB,
+			(0x2001 << 16));
+	} else if (use_i2c_infilter) {
+		hdmirx_wr_top(TOP_INFILTER_HDCP,
+			(0x20012001));
+		hdmirx_wr_top(TOP_INFILTER_I2C0,
+			(0x20012001));
+		hdmirx_wr_top(TOP_INFILTER_I2C1,
+			(0x20012001));
+		hdmirx_wr_top(TOP_INFILTER_I2C2,
+			(0x20012001));
+	}
 
 	data32 = 0;
 	data32 |= 0	<< 28;
@@ -659,6 +681,7 @@ static void hdmi_rx_ctrl_hdcp_config(const struct hdmi_rx_ctrl_hdcp *hdcp)
 	int error = 0;
 	unsigned i = 0;
 	unsigned k = 0;
+	hdmirx_wr_bits_dwc(DWC_HDCP_SETTINGS, HDCP_FAST_MODE, 0);
 	hdmirx_wr_bits_dwc(DWC_HDCP_CTRL, HDCP_ENABLE, 0);
 	/* hdmirx_wr_bits_dwc(ctx, DWC_HDCP_CTRL, KEY_DECRYPT_ENABLE, 1); */
 	hdmirx_wr_bits_dwc(DWC_HDCP_CTRL, KEY_DECRYPT_ENABLE, 0);
@@ -691,16 +714,26 @@ static void hdmi_rx_ctrl_hdcp_config(const struct hdmi_rx_ctrl_hdcp *hdcp)
 
 void hdmirx_set_hpd(int port, unsigned char val)
 {
-	if (!val) {
-		hdmirx_wr_top(TOP_HPD_PWR5V,
-			hdmirx_rd_top(TOP_HPD_PWR5V)&(~(1<<port)));
+	if (is_meson_gxtvbb_cpu()) {
+		if (!val) {
+			hdmirx_wr_top(TOP_HPD_PWR5V,
+				hdmirx_rd_top(TOP_HPD_PWR5V)&(~(1<<port)));
+		} else {
+			hdmirx_wr_top(TOP_HPD_PWR5V,
+				hdmirx_rd_top(TOP_HPD_PWR5V)|(1<<port));
+		}
 	} else {
-		hdmirx_wr_top(TOP_HPD_PWR5V,
-			hdmirx_rd_top(TOP_HPD_PWR5V)|(1<<port));
+		if (val) {
+			hdmirx_wr_top(TOP_HPD_PWR5V,
+				hdmirx_rd_top(TOP_HPD_PWR5V)&(~(1<<port)));
+		} else {
+			hdmirx_wr_top(TOP_HPD_PWR5V,
+				hdmirx_rd_top(TOP_HPD_PWR5V)|(1<<port));
+		}
 	}
 
 	if (log_flag & LOG_EN)
-		rx_print("%s, port:%d, val:%d\n", __func__,
+		rx_pr("%s, port:%d, val:%d\n", __func__,
 						port, val);
 }
 
@@ -720,20 +753,53 @@ void control_reset(void)
 
 	mdelay(1);
 	/* Reset functional modules */
-	hdmirx_wr_dwc(DWC_DMI_SW_RST,     0x0000003F);
+	hdmirx_wr_dwc(DWC_DMI_SW_RST,     0x0000001F);
 	cecrx_hw_init();
 }
 
-void hdmirx_set_pinmux(void)
-{
-}
-
 void clk_off(void)
 {
 	/* wr_reg(HHI_HDMIRX_CLK_CNTL, 0); */
 	/* wr_reg(HHI_HDMIRX_AUD_CLK_CNTL, 0); */
 }
 
+#ifdef HDCP22_ENABLE
+void hdcp22_clk_init(void)
+{
+	unsigned int data32;
+
+	/* Enable clk81_hdcp22_pclk */
+	wr_reg(HHI_GCLK_MPEG2, (rd_reg(HHI_GCLK_MPEG2)|1<<3));
+
+	/* Enable hdcp22_esmclk */
+	/* .clk0               ( fclk_div7  ), */
+	/* .clk1               ( fclk_div4  ), */
+	/* .clk2               ( fclk_div3  ), */
+	/* .clk3               ( fclk_div5  ), */
+	wr_reg(HHI_HDCP22_CLK_CNTL,
+	(rd_reg(HHI_HDCP22_CLK_CNTL) & 0xffff0000) |
+	 /* [10: 9] clk_sel. select fclk_div7=2000/7=285.71 MHz */
+	((0 << 9)   |
+	 /* [    8] clk_en. Enable gated clock */
+	 (1 << 8)   |
+	 /* [ 6: 0] clk_div. Divide by 1. = 285.71/1 = 285.71 MHz */
+	 (0 << 0)));
+
+	wr_reg(HHI_HDCP22_CLK_CNTL,
+	(rd_reg(HHI_HDCP22_CLK_CNTL) & 0x0000ffff) |
+	/* [26:25] clk_sel. select cts_oscin_clk=24 MHz */
+	((0 << 25)  |
+	 (1 << 24)  |   /* [   24] clk_en. Enable gated clock */
+	 (0 << 16)));
+
+	data32 = hdmirx_rd_top(TOP_CLK_CNTL);
+	data32 |= (hdcp22_on << 5);
+	data32 |= (hdcp22_on << 4);
+	data32 |= (hdcp22_on << 3);
+	hdmirx_wr_top(TOP_CLK_CNTL, data32);    /* DEFAULT: {32'h0} */
+}
+#endif
+
 void clk_init(void)
 {
 	unsigned int data32;
@@ -780,8 +846,8 @@ void clk_init(void)
 	data32 |= 2	<< 0;
 	wr_reg(HHI_HDMIRX_AUD_CLK_CNTL, data32);
 
-#ifdef HDCP22_ENABLE
-	if (hdcp_22_on) {
+#if 0 /* def HDCP22_ENABLE */
+	if (hdcp22_on) {
 		/* Enable clk81_hdcp22_pclk */
 		wr_reg(HHI_GCLK_MPEG2, (rd_reg(HHI_GCLK_MPEG2)|1<<3));
 
@@ -811,11 +877,6 @@ void clk_init(void)
 	data32 |= 0 << 31;  /* [31]     disable clkgating */
 	data32 |= 1 << 17;  /* [17]     audfifo_rd_en */
 	data32 |= 1 << 16;  /* [16]     pktfifo_rd_en */
-#ifdef HDCP22_ENABLE
-	data32 |= (hdcp_22_on << 5);
-	data32 |= (hdcp_22_on << 4);
-	data32 |= (hdcp_22_on << 3);
-#endif
 	data32 |= 1 << 2;   /* [2]      hdmirx_cecclk_en */
 	data32 |= 0 << 1;   /* [1]      bus_clk_inv */
 	data32 |= 0 << 0;   /* [0]      hdmi_clk_inv */
@@ -855,36 +916,12 @@ void hdmirx_20_init(void)
 	data32 |= 10	<< 20; /* [29:20]  chlock_max_err */
 	data32 |= 24000	<< 0;  /* [15:0]   milisec_timer_limit */
 	hdmirx_wr_dwc(DWC_CHLOCK_CONFIG, data32);
-	hdmirx_wr_bits_dwc(DWC_HDCP_SETTINGS, HDCP_FAST_MODE, 0);
+
 	/* hdcp2.2 ctl */
 #ifdef HDCP22_ENABLE
-	if (hdcp_22_on) {
-		/* hdmirx_wr_dwc(DWC_HDCP22_CONTROL, */
-		/* (0x1002 | (hdcp_22_on<<2))); */
-		/* hdmirx_wr_dwc(DWC_HDCP_SETTINGS, 0x13374); */
-		/* Configure pkf[127:0] */
-		if (hdcp22_firmware_ok_flag &&
-			(force_hdcp14_en == 0) &&
-			(esm_err_force_14 == 0))
-			hdmirx_wr_dwc(DWC_HDCP22_CONTROL, 0x1000);
-		else
-			hdmirx_wr_dwc(DWC_HDCP22_CONTROL, 2);
-
-		rx_sec_set_duk();
-		/* Validate PKF and DUK */
-			data32	= 0;
-			/* duk_vld */
-			data32 |= (1					<< 2);
-			/* pkf_vld */
-			data32 |= (1					<< 1);
-			/* nonce_hw_en */
-			data32 |= (hdcp_22_nonce_hw_en	<< 0);
-			hdcp22_wr_top(TOP_SKP_CNTL_STAT, data32);
-
-			/* Wait until nonce is valid */
-			/* hdmirx_poll_reg(0, TOP_SKP_CNTL_STAT, */
-			/*	(1<<31), ~(1<<31)); */
-		} else
+	if (hdcp22_on && hdcp22_firmware_ok_flag)
+		hdmirx_wr_dwc(DWC_HDCP22_CONTROL, 0x1000);
+	else
 #endif
 		hdmirx_wr_dwc(DWC_HDCP22_CONTROL, 2);
 }
@@ -895,75 +932,163 @@ void hdmirx_hdcp22_esm_rst(void)
 	hdmirx_wr_top(TOP_SW_RESET, 0x100);
 	mdelay(1);
 	hdmirx_wr_top(TOP_SW_RESET, 0x0);
-	rx_print("esm rst\n");
+	rx_pr("esm rst\n");
 }
 
 void hdmirx_hdcp22_init(void)
 {
 	int ret = 0;
-	if (1 == hdcp22_firmware_ok_flag)
-		ret = rx_sec_set_duk();
-
+	ret = rx_sec_set_duk();
+	rx_pr("hdcp22 == %d\n", ret);
 	if (ret == 1) {
-		if (force_hdcp14_en == 0)
-			hdcp_22_on = 1;
-		else
-			hdcp_22_on = 0;
-		/* hpd_to_esm = 1; */
-		is_duk_key_set = 1;
-		rx_print("hdcp22 on\n");
-	} else {
-		hdcp_22_on = 0;
-		is_duk_key_set = 0;
-		rx_print("hdcp22 off\n");
-	}
+		hdcp22_wr_top(TOP_SKP_CNTL_STAT, 7);
+		hdcp22_on = 1;
+		hdcp22_clk_init();
+	} else
+		hdcp22_on = 0;
 }
 #endif
 
+void hdmirx_phy_init(int rx_port_sel, int dcm)
+{
+	unsigned int data32;
+	data32 = 0;
+	data32 |= 1 << 6;
+	data32 |= 1 << 4;
+	data32 |= rx_port_sel << 2;
+	data32 |= 1 << 1;
+	data32 |= 1 << 0;
+	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, data32);
+	mdelay(1);
+
+	data32	= 0;
+	data32 |= 1 << 6;
+	data32 |= 1 << 4;
+	data32 |= rx_port_sel << 2;
+	data32 |= 1 << 1;
+	data32 |= 0 << 0;
+	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, data32);
+
+	hdmirx_wr_phy(MPLL_PARAMETERS2,    0x1c94);
+	hdmirx_wr_phy(MPLL_PARAMETERS3,    0x3713);
+	hdmirx_wr_phy(MPLL_PARAMETERS4,    mpll_param4);
+	hdmirx_wr_phy(MPLL_PARAMETERS5,    0x5492);
+	hdmirx_wr_phy(MPLL_PARAMETERS6,    0x4b0d);
+	hdmirx_wr_phy(MPLL_PARAMETERS7,    0x4760);
+	hdmirx_wr_phy(MPLL_PARAMETERS8,    0x008c);
+	hdmirx_wr_phy(MPLL_PARAMETERS9,    0x0010);
+	hdmirx_wr_phy(MPLL_PARAMETERS10,   0x2d20);
+	hdmirx_wr_phy(MPLL_PARAMETERS11, 0x2e31);
+	hdmirx_wr_phy(MPLL_PARAMETERS12, 0x4b64);
+	hdmirx_wr_phy(MPLL_PARAMETERS13, 0x2493);
+	hdmirx_wr_phy(MPLL_PARAMETERS14, 0x676d);
+	hdmirx_wr_phy(MPLL_PARAMETERS15, 0x23e0);
+	hdmirx_wr_phy(MPLL_PARAMETERS16, 0x001b);
+	hdmirx_wr_phy(MPLL_PARAMETERS17, 0x2218);
+	hdmirx_wr_phy(MPLL_PARAMETERS18, 0x1b25);
+	hdmirx_wr_phy(MPLL_PARAMETERS19, 0x2492);
+	hdmirx_wr_phy(MPLL_PARAMETERS20, 0x48ea);
+	hdmirx_wr_phy(MPLL_PARAMETERS21, 0x0011);
+	hdmirx_wr_phy(MPLL_PARAMETERS22, 0x04d2);
+	hdmirx_wr_phy(MPLL_PARAMETERS23, 0x0414);
+
+	#if 0
+	hdmirx_wr_phy(0x43, fat_bit_status);
+	hdmirx_wr_phy(0x63, fat_bit_status);
+	hdmirx_wr_phy(0x83, fat_bit_status);
+	#endif
+
+	/* Configuring I2C to work in fastmode */
+	hdmirx_wr_dwc(DWC_I2CM_PHYG3_MODE,	 0x1);
+	/* disable overload protect for Philips DVD */
+	/* NOTE!!!!! don't remove below setting */
+	hdmirx_wr_phy(OVL_PROT_CTRL, 0xa);
+
+	data32 = 0;
+	data32 |= 0	<< 15;
+	data32 |= 0	<< 13;
+	data32 |= 0	<< 12;
+	data32 |= fast_switching << 11;
+	data32 |= 0	<< 10;
+	data32 |= rx.phy.fsm_enhancement << 9;
+	data32 |= 0	<< 8;
+	data32 |= 0	<< 7;
+	data32 |= dcm << 5;
+	data32 |= 0	<< 3;
+	data32 |= rx.phy.port_select_ovr_en << 2;
+	data32 |= rx_port_sel << 0;
+
+	hdmirx_wr_phy(PHY_SYSTEM_CONFIG,
+		(rx.phy.phy_system_config_force_val != 0) ?
+		rx.phy.phy_system_config_force_val : data32);
+
+	hdmirx_wr_phy(PHY_CMU_CONFIG,
+		(rx.phy.phy_cmu_config_force_val != 0) ?
+		rx.phy.phy_cmu_config_force_val :
+		((rx.phy.lock_thres << 10) | (1 << 9) |
+			(((1 << 9) - 1) & ((rx.phy.cfg_clk * 4) / 1000))));
+
+	#if 0
+	hdmirx_wr_phy(PHY_CH0_EQ_CTRL3, eq_setting[EQ_CH0]);
+	hdmirx_wr_phy(PHY_CH1_EQ_CTRL3, eq_setting[EQ_CH1]);
+	hdmirx_wr_phy(PHY_CH2_EQ_CTRL3, eq_setting[EQ_CH2]);
+	if ((0 == eq_setting[EQ_CH0]) &&
+		(0 == eq_setting[EQ_CH1]) &&
+		(0 == eq_setting[EQ_CH2]))
+		hdmirx_wr_phy(PHY_MAIN_FSM_OVERRIDE2, 0x0);
+	else
+		hdmirx_wr_phy(PHY_MAIN_FSM_OVERRIDE2, 0x40);
+	#endif
+	/*hdmirx_phy_clk_rate_monitor();*/
+
+	data32 = 0;
+	data32 |= 1 << 6;
+	data32 |= 1 << 4;
+	data32 |= rx_port_sel << 2;
+	data32 |= 0 << 1;
+	data32 |= 0 << 0;
+	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, data32);
+
+	rx_pr("%s  %d Done!\n", __func__, rx.port);
+}
+
+
 void hdmirx_hw_config(void)
 {
-	rx_print("%s port:%d\n", __func__, rx.port);
-	hdmirx_wr_top(TOP_INTR_MASKN, 0);
-	clk_init();
+	rx_pr("%s port:%d\n", __func__, rx.port);
 	control_reset();
-
 	hdmirx_irq_close();
-	hdmi_rx_ctrl_edid_update();
+	/* hdmi_rx_ctrl_edid_update(); */
 	if (hdcp_enable)
 		hdmi_rx_ctrl_hdcp_config(&rx.hdcp);
 	else
 		hdmirx_wr_bits_dwc(DWC_HDCP_CTRL, HDCP_ENABLE, 0);
-
-	hdmirx_phy_init(rx.port, 0);
-	hdmirx_wr_top(TOP_PORT_SEL, 0x10 | ((1<<rx.port)));
-	DWC_init(rx.port);
 	hdmirx_audio_init();
 	packet_init();
 	hdmirx_20_init();
-	hdmirx_audio_fifo_rst();
-	hdmirx_packet_fifo_rst();
-	/*enable irq */
-	hdmirx_wr_top(TOP_INTR_STAT_CLR, ~0);
-	hdmirx_wr_top(TOP_INTR_MASKN, TOP_INT_MASK_VALUE);
 	hdmirx_irq_open();
 
 	mdelay(100);
 	if (hdmirx_rd_dwc(0xe0) != 0) {
-		rx_print("hdcp engine busy\n");
+		rx_pr("hdcp engine busy\n");
 		mdelay(100);
 	}
-	rx_print("%s  %d Done!\n", __func__, rx.port);
+
+	hdmirx_phy_init(rx.port, 0);
+	hdmirx_wr_top(TOP_PORT_SEL, 0x10 | ((1<<rx.port)));
+	DWC_init(rx.port);
+	rx_pr("%s  %d Done!\n", __func__, rx.port);
 }
 
 void hdcp22_hw_cfg(void)
 {
-	rx_print("hdcp22_hw_cfg\n");
+	rx_pr("hdcp22_hw_cfg\n");
 
 	hdmirx_wr_top(TOP_INTR_MASKN, 0);
 	clk_init();
 	control_reset();
 
-	hdmi_rx_ctrl_edid_update();
+	/* hdmi_rx_ctrl_edid_update(); */
 	if (hdcp_enable)
 		hdmi_rx_ctrl_hdcp_config(&rx.hdcp);
 	else
@@ -981,25 +1106,28 @@ void hdcp22_hw_cfg(void)
 void hdmirx_hw_probe(void)
 {
 	hdmirx_wr_top(TOP_MEM_PD, 0);
-	hdmirx_wr_top(TOP_SW_RESET,	0);
+	hdmirx_wr_top(TOP_SW_RESET, 0);
 	clk_init();
 	hdmirx_wr_top(TOP_EDID_GEN_CNTL, 0x1e109);
-	hdmirx_wr_top(TOP_HPD_PWR5V, 0x10);
-	hdmi_rx_ctrl_edid_update();
-	/* #ifdef HDCP22_ENABLE */
-	/* if (hdcp_22_on) */
-	/*	hpd_to_esm = 1; */
-	/* #endif */
-	mdelay(150);
+
+	if (is_meson_gxtvbb_cpu())
+		hdmirx_wr_top(TOP_HPD_PWR5V, 0x10);
+
 	if (phy_init_in_probe)
 		hdmirx_phy_init(0, 0);
+	if (is_meson_gxtvbb_cpu()) {
+		mdelay(150);
+		hdmirx_wr_top(TOP_HPD_PWR5V, 0x1f);
+	} else {
+		hdmirx_wr_top(TOP_HPD_PWR5V, 0x10);
+	}
 
-	hdmirx_wr_top(TOP_HPD_PWR5V, 0x1f);
 	hdmirx_hdcp22_init();
 	hdmirx_wr_top(TOP_PORT_SEL, 0x10);
 	hdmirx_wr_top(TOP_INTR_STAT_CLR, ~0);
-	hdmirx_wr_top(TOP_INTR_MASKN, TOP_INT_MASK_VALUE);
-	rx_print("%s Done!\n", __func__);
+	hdmirx_wr_top(TOP_INTR_MASKN, top_intr_maskn_value);
+	edid_update_flag = true;
+	rx_pr("%s Done!\n", __func__);
 }
 
 
@@ -1064,8 +1192,7 @@ int hdmirx_get_video_info(struct hdmi_rx_ctrl *ctx,
 	/* DVI mode */
 	params->dvi = hdmirx_rd_bits_dwc(DWC_PDEC_STS, DVIDET) != 0;
 	/* hdcp encrypted state */
-	params->hdcp_enc_state = (hdmirx_rd_dwc(DWC_HDCP_STS) >> 8) & 3;
-
+	params->hdcp_enc_state = hdmirx_rd_bits_dwc(DWC_HDCP_STS, _BIT(9));
 	/* AVI parameters */
 	error |= hdmirx_packet_get_avi(params);
 	if (error != 0)
@@ -1135,7 +1262,7 @@ void hdmirx_set_video_mute(bool mute)
 {
 	hdmirx_wr_bits_dwc(DWC_HDMI_VM_CFG_CH2, _BIT(16), mute);
 	if (log_flag & VIDEO_LOG)
-		rx_print("%s,mute: %d\n", __func__, mute);
+		rx_pr("%s,mute: %d\n", __func__, mute);
 }
 
 void hdmirx_config_video(struct hdmi_rx_ctrl_video *video_params)
@@ -1333,7 +1460,7 @@ void diff_with_testcode(void)
 
 static unsigned int clk_util_clk_msr(unsigned int clk_mux)
 {
-	return 0;
+	return meson_clk_measure(clk_mux);
 }
 
 unsigned int hdmirx_get_clock(int index)
@@ -1348,10 +1475,12 @@ unsigned int hdmirx_get_audio_clock(void)
 
 unsigned int hdmirx_get_tmds_clock(void)
 {
+	return clk_util_clk_msr(25);
+	/*
 	unsigned int clkrate = 0;
 	clkrate = hdmirx_rd_dwc(DWC_HDMI_CKM_RESULT) & 0xffff;
 	clkrate = clkrate * 158000 / 4095 * 1000;
-	return clkrate;
+	return clkrate;*/
 }
 
 unsigned int hdmirx_get_pixel_clock(void)
@@ -1417,3 +1546,72 @@ void hdmirx_read_vendor_specific_info_frame(struct vendor_specific_info_s *vs)
 	#endif
 }
 
+
+/* param: */
+/* lvl: 0-bist  1-cdr*/
+void hdmirx_phy_bist_test(int lvl)
+{
+	unsigned int data32;
+
+	/* set CFGCLK,bist:85M   CDR:75M */
+	if (lvl) {
+		rx_pr("cdr test start:\n");
+		wr_reg(HHI_HDMIRX_CLK_CNTL, 0x03060704);
+	} else {
+		rx_pr("bist test start:\n");
+		wr_reg(HHI_HDMIRX_CLK_CNTL, 0x03050704);
+	}
+
+	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, (0x53 | (rx.port<<2)));
+	mdelay(1);
+	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, (0x52 | (rx.port<<2)));
+	mdelay(10);
+
+	hdmirx_wr_phy(PHY_CMU_CONFIG, 0x1b2c);
+	hdmirx_wr_phy(MPLL_PARAMETERS2,    0x1c94);
+	hdmirx_wr_phy(MPLL_PARAMETERS3,    0x3713);
+	hdmirx_wr_phy(MPLL_PARAMETERS4,    0x24da);
+	hdmirx_wr_phy(MPLL_PARAMETERS5,    0x5492);
+	hdmirx_wr_phy(MPLL_PARAMETERS6,    0x4b0d);
+	hdmirx_wr_phy(MPLL_PARAMETERS7,    0x4760);
+	hdmirx_wr_phy(MPLL_PARAMETERS8,    0x008c);
+	hdmirx_wr_phy(MPLL_PARAMETERS9,    0x02);
+	hdmirx_wr_phy(MPLL_PARAMETERS10,   0x2d20);
+	hdmirx_wr_phy(MPLL_PARAMETERS11, 0x2e31);
+	hdmirx_wr_phy(MPLL_PARAMETERS12, 0x4b64);
+	hdmirx_wr_phy(MPLL_PARAMETERS13, 0x2493);
+	hdmirx_wr_phy(MPLL_PARAMETERS14, 0x676d);
+	hdmirx_wr_phy(MPLL_PARAMETERS15, 0x23e0);
+	hdmirx_wr_phy(MPLL_PARAMETERS16, 0x001b);
+	hdmirx_wr_phy(MPLL_PARAMETERS17, 0x2218);
+	hdmirx_wr_phy(MPLL_PARAMETERS18, 0x1b25);
+	hdmirx_wr_phy(MPLL_PARAMETERS19, 0x2492);
+	hdmirx_wr_phy(MPLL_PARAMETERS20, 0x48ea);
+	hdmirx_wr_phy(MPLL_PARAMETERS21, 0x0011);
+	hdmirx_wr_phy(MPLL_PARAMETERS22, 0x04d2);
+	hdmirx_wr_phy(MPLL_PARAMETERS23, 0x0414);
+
+	if (lvl) {
+		hdmirx_wr_phy(PHY_MAIN_BIST_CONTROL, 0x31);
+	mdelay(10);
+		hdmirx_wr_phy(PHY_CDR_CTRL_CNT, 0x18);
+	mdelay(10);
+		hdmirx_wr_phy(MPLL_DIVIDER_CONTROL, 0x28);
+	} else
+		hdmirx_wr_phy(PHY_MAIN_BIST_CONTROL, 0xb1);
+
+	mdelay(10);
+
+	hdmirx_wr_dwc(DWC_SNPS_PHYG3_CTRL, (0x50 | (rx.port<<2)));
+	mdelay(10);
+
+	data32 = hdmirx_rd_phy(PHY_MAIN_BIST_RESULTS) & 0x3;
+
+	if (data32 == 0x0 || data32 == 0x2)
+		rx_pr("ERROR: bist test not complete!\n");
+	else if (data32 == 0x1)
+		rx_pr("ERROR: bist test fail!\n");
+	else if (data32 == 0x3)
+		rx_pr("PASS!\n");
+}
+
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h b/drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h
index f0c61bc..5b23da3 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h
@@ -67,14 +67,26 @@
 
 #define PHY_RESISTOR_CALIBRATION_1 (0x10UL)
 #define PHY_MAIN_FSM_OVERRIDE2	(0x08UL)
-#define PHY_CH0_EQ_CTRL3			(0x3EUL)
-#define PHY_CH1_EQ_CTRL3			(0x5EUL)
-#define PHY_CH2_EQ_CTRL3			(0x7EUL)
+
+#define PHY_MAIN_BIST_CONTROL	(0x0BUL)
+#define PHY_MAIN_BIST_RESULTS	(0x0CUL)
+
+#define PHY_CORESTATUS_CH0		(0x30UL)
+#define PHY_CORESTATUS_CH1		(0x50UL)
+#define PHY_CORESTATUS_CH2		(0x70UL)
 
 #define PHY_EQCTRL1_CH0			(0x32UL)
 #define PHY_EQCTRL1_CH1			(0x52UL)
 #define PHY_EQCTRL1_CH2			(0x72UL)
 
+#define PHY_EQLSTATS_CH0		(0x34UL)
+#define PHY_EQLSTATS_CH1		(0x54UL)
+#define PHY_EQLSTATS_CH2		(0x74UL)
+
+#define PHY_CH0_EQ_CTRL3		(0x3EUL)
+#define PHY_CH1_EQ_CTRL3		(0x5EUL)
+#define PHY_CH2_EQ_CTRL3		(0x7EUL)
+
 #define PHY_EQCTRL4_CH0			(0x3FUL)
 #define PHY_EQCTRL4_CH1			(0x5FUL)
 #define PHY_EQCTRL4_CH2			(0x7FUL)
@@ -83,14 +95,23 @@
 #define PHY_EQCTRL2_CH1			(0x53UL)
 #define PHY_EQCTRL2_CH2			(0x73UL)
 
+#define PHY_EQLCKST2_CH0		(0x40UL)
+#define PHY_EQLCKST2_CH1		(0x60UL)
+#define PHY_EQLCKST2_CH2		(0x80UL)
+
 #define PHY_EQSTAT3_CH0			(0x42UL)
 #define PHY_EQSTAT3_CH1			(0x62UL)
 #define PHY_EQSTAT3_CH2			(0x82UL)
 
+#define PHY_EQCTRL6_CH0		(0x43UL)
+#define PHY_EQCTRL6_CH1		(0x63UL)
+#define PHY_EQCTRL6_CH2		(0x83UL)
+
 #define OVL_PROT_CTRL                   (0x0DUL)
 #define PHY_CDR_CTRL_CNT			(0x0EUL)
 #define PHY_VOLTAGE_LEVEL		(0x22UL)
 #define PHY_MPLL_CTRL			(0x24UL)
+#define MPLL_DIVIDER_CONTROL	(0x25UL)
 #define MPLL_PARAMETERS2                (0x27UL)
 #define MPLL_PARAMETERS3                (0x28UL)
 #define MPLL_PARAMETERS4                (0x29UL)
@@ -162,7 +183,16 @@
 #define TOP_EDID_GEN_STAT_C              0x026
 #define TOP_EDID_GEN_STAT_D              0x027
 #define	TOP_ACR_CNTL2					 0x02a
-#define	TOP_INFILTER					 0x02b
+/* Gxtvbb */
+#define	TOP_INFILTER_GXTVBB				 0x02b
+/* Gxtvbb */
+
+#define	TOP_INFILTER_HDCP				 0x02C
+#define	TOP_INFILTER_I2C0				 0x02D
+#define	TOP_INFILTER_I2C1				 0x02E
+#define	TOP_INFILTER_I2C2				 0x02F
+#define	TOP_INFILTER_I2C3				 0x030
+
 #define	TOP_SKP_CNTL_STAT				 0x061
 #define	TOP_NONCE_0						 0x062
 #define	TOP_NONCE_1						 0x063
@@ -681,18 +711,18 @@
 /*
  * Audio Clock Interrupt registers
  */
-/** Register address: audio clock interrupt clear enable */
-#define DWC_AUD_CLK_IEN_CLR	(0xF90UL)
-/** Register address: audio clock interrupt set enable */
-#define DWC_AUD_CLK_IEN_SET	(0xF94UL)
-/** Register address: audio clock interrupt status */
-#define DWC_AUD_CLK_ISTS		(0xF98UL)
-/** Register address: audio clock interrupt enable */
-#define DWC_AUD_CLK_IEN		(0xF9CUL)
-/** Register address: audio clock interrupt clear status */
-#define DWC_AUD_CLK_ICLR		(0xFA0UL)
-/** Register address: audio clock interrupt set status */
-#define DWC_AUD_CLK_ISET		(0xFA4UL)
+/** Register address: audio clock and cec interrupt clear enable */
+#define DWC_AUD_CEC_IEN_CLR	(0xF90UL)
+/** Register address: audio clock and cec interrupt set enable */
+#define DWC_AUD_CEC_IEN_SET	(0xF94UL)
+/** Register address: audio clock and cec interrupt status */
+#define DWC_AUD_CEC_ISTS		(0xF98UL)
+/** Register address: audio clock and cec interrupt enable */
+#define DWC_AUD_CEC_IEN		(0xF9CUL)
+/** Register address: audio clock and cec interrupt clear status */
+#define DWC_AUD_CEC_ICLR		(0xFA0UL)
+/** Register address: audio clock and cec interrupt set status */
+#define DWC_AUD_CEC_ISET		(0xFA4UL)
 /*
  * Audio FIFO Interrupt registers
  */
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
index 272d7b6..5211b20 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
@@ -41,6 +41,7 @@
 /* if (is_meson_g9tv_cpu() || is_meson_m8_cpu() || */
 /* is_meson_m8m2_cpu() || is_meson_gxbb_cpu() || */
 /* is_meson_m8b_cpu()) */
+#include <linux/of_gpio.h>
 
 #include <linux/amlogic/tvin/tvin.h>
 /* Local include */
@@ -130,14 +131,10 @@ static int debug_1;
 MODULE_PARM_DESC(debug_1, "\n debug_1\n");
 module_param(debug_1, int, 0664);
 
-static bool clk_debug = true;
+static bool clk_debug;
 MODULE_PARM_DESC(clk_debug, "\n clk_debug\n");
 module_param(clk_debug, bool, 0664);
 
-static int cnt_1 = 10;
-MODULE_PARM_DESC(cnt_1, "\n cnt_1\n");
-module_param(cnt_1, int, 0664);
-
 static int hpd_wait_cnt;
 static int hpd_wait_max = 11;
 MODULE_PARM_DESC(hpd_wait_max, "\n hpd_wait_max\n");
@@ -168,6 +165,9 @@ static int pll_stable_protect_max = 15;
 MODULE_PARM_DESC(pll_stable_protect_max, "\n pll_stable_protect_max\n");
 module_param(pll_stable_protect_max, int, 0664);
 
+static int hdcp22_lost_max = 30;
+MODULE_PARM_DESC(hdcp22_lost_max, "\n hdcp22_lost_max\n");
+module_param(hdcp22_lost_max, int, 0664);
 
 static bool enable_hpd_reset;
 MODULE_PARM_DESC(enable_hpd_reset, "\n enable_hpd_reset\n");
@@ -177,6 +177,10 @@ static int pow5v_max_cnt = 4;
 MODULE_PARM_DESC(pow5v_max_cnt, "\n pow5v_max_cnt\n");
 module_param(pow5v_max_cnt, int, 0664);
 
+static int uart_plugin_check_cnt = 10;
+MODULE_PARM_DESC(uart_plugin_check_cnt, "\n uart_plugin_check_cnt\n");
+module_param(uart_plugin_check_cnt, int, 0664);
+
 static int sig_unstable_reset_hpd_cnt;
 static int sig_unstable_reset_hpd_max = 5;
 MODULE_PARM_DESC(sig_unstable_reset_hpd_max,
@@ -321,6 +325,10 @@ static int hdcp22_authenticated = 0xff;
 MODULE_PARM_DESC(hdcp22_authenticated, "\n hdcp22_authenticated\n");
 module_param(hdcp22_authenticated, int, 0664);
 
+static bool do_link_lost_reset;
+MODULE_PARM_DESC(do_link_lost_reset, "\n do_link_lost_reset\n");
+module_param(do_link_lost_reset, bool, 0664);
+
 static int pre_hdcp22_sts = 0xff;
 MODULE_PARM_DESC(pre_hdcp22_sts, "\n pre_hdcp22_sts\n");
 module_param(pre_hdcp22_sts, int, 0664);
@@ -332,7 +340,7 @@ module_param(use_audioresample_reset, bool, 0664);
 /* 0x100--irq print; */
 /* 0x200-other print */
 /* bit 0, printk; bit 8 enable irq log */
-int log_flag = LOG_EN;
+int log_flag = LOG_EN | HDCP_LOG | EQ_LOG;
 MODULE_PARM_DESC(log_flag, "\n log_flag\n");
 module_param(log_flag, int, 0664);
 
@@ -351,10 +359,16 @@ module_param(hw_dbg_en, bool, 0664);
 static bool auto_switch_off;	/* only for hardware test */
 MODULE_PARM_DESC(auto_switch_off, "\n auto_switch_off\n");
 module_param(auto_switch_off, bool, 0664);
-int wait_clk_stable;
-static int clk_stable_max = 350;
-MODULE_PARM_DESC(clk_stable_max, "\n clk_stable_max\n");
-module_param(clk_stable_max, int, 0664);
+
+int wait_clk_stable_cnt;
+static int wait_clk_stable_max = 400;
+MODULE_PARM_DESC(wait_clk_stable_max, "\n wait_clk_stable_max\n");
+module_param(wait_clk_stable_max, int, 0664);
+
+int is_clk_stable_cnt;
+static int is_clk_stable_max = 3;
+MODULE_PARM_DESC(is_clk_stable_max, "\n is_clk_stable_max\n");
+module_param(is_clk_stable_max, int, 0664);
 
 int force_wait_cnt;
 static int force_wait_max = 30;
@@ -369,17 +383,25 @@ static bool need_clk_stable;
 MODULE_PARM_DESC(need_clk_stable, "\n need_clk_stable\n");
 module_param(need_clk_stable, bool, 0664);
 
-static int eq_calc_mode;
-MODULE_PARM_DESC(eq_calc_mode, "\n eq_calc_mode\n");
-module_param(eq_calc_mode, int, 0664);
+static int eq_dbg_ch0;
+MODULE_PARM_DESC(eq_dbg_ch0, "\n eq_dbg_ch0\n");
+module_param(eq_dbg_ch0, int, 0664);
 
-static int wait_clk_stable_max = 600;
-MODULE_PARM_DESC(wait_clk_stable_max, "\n wait_clk_stable_max\n");
-module_param(wait_clk_stable_max, int, 0664);
+static int eq_dbg_ch1;
+MODULE_PARM_DESC(eq_dbg_ch1, "\n eq_dbg_ch1\n");
+module_param(eq_dbg_ch1, int, 0664);
+
+static int eq_dbg_ch2;
+MODULE_PARM_DESC(eq_dbg_ch2, "\n eq_dbg_ch2\n");
+module_param(eq_dbg_ch2, int, 0664);
+
+static int wait_no_sig_max = 600;
+MODULE_PARM_DESC(wait_no_sig_max, "\n wait_no_sig_max\n");
+module_param(wait_no_sig_max, int, 0664);
 
-static int wait_no_signal_cnt;
-MODULE_PARM_DESC(wait_no_signal_cnt, "\n wait_no_signal_cnt\n");
-module_param(wait_no_signal_cnt, int, 0664);
+static int wait_no_sig_cnt;
+MODULE_PARM_DESC(wait_no_sig_cnt, "\n wait_no_sig_cnt\n");
+module_param(wait_no_sig_cnt, int, 0664);
 
 static bool hdr_enable = true;
 MODULE_PARM_DESC(hdr_enable, "\n hdr_enable\n");
@@ -445,9 +467,9 @@ bool video_stable_to_esm;
 MODULE_PARM_DESC(video_stable_to_esm, "\n video_stable_to_esm\n");
 module_param(video_stable_to_esm, bool, 0664);
 
-static int hdcp_mode_sel;
+static bool hdcp_mode_sel;
 MODULE_PARM_DESC(hdcp_mode_sel, "\n hdcp_mode_sel\n");
-module_param(hdcp_mode_sel, int, 0664);
+module_param(hdcp_mode_sel, bool, 0664);
 
 static bool hdcp_auth_status;
 MODULE_PARM_DESC(hdcp_auth_status, "\n hdcp_auth_status\n");
@@ -504,29 +526,42 @@ module_param(esm_reboot_lvl, int, 0664);
 int enable_esm_reboot;
 MODULE_PARM_DESC(enable_esm_reboot, "\n enable_esm_reboot\n");
 module_param(enable_esm_reboot, int, 0664);
+
+bool esm_error_flag;
+MODULE_PARM_DESC(esm_error_flag, "\n esm_error_flag\n");
+module_param(esm_error_flag, bool, 0664);
 #endif
 
 int pre_port = 0xff;
 module_param(pre_port, int, 0664);
 MODULE_PARM_DESC(pre_port, "pre_port");
 
-int scdc_tmds_try_max = 4;
+int scdc_tmds_try_max = 3;
 module_param(scdc_tmds_try_max, int, 0664);
 MODULE_PARM_DESC(scdc_tmds_try_max, "scdc_tmds_try_max");
 
+int share_with_uart_cfg = 7;
+module_param(share_with_uart_cfg, int, 0664);
+MODULE_PARM_DESC(share_with_uart_cfg, "share_with_uart_cfg");
+
 int do_hpd_reset_flag = 0;
 int wait_hpd_reset_max = 300;
 module_param(wait_hpd_reset_max, int, 0664);
 MODULE_PARM_DESC(wait_hpd_reset_max, "wait_hpd_reset_max");
+
 /****************************/
 /*  func enhancements  */
 /****************************/
 
+bool edid_update_flag;
+bool hdcp22_reauth_enable = 1;
+static int hdcp22_lost_cnt;
 static int last_color_fmt;
 static bool reset_sw = true;
 static int sm_pause;
 static int ddc_state_err_cnt;
 static int irq_video_mute_flag;
+static bool edid_addr_intr_flag;
 
 /***********************
   TVIN driver interface
@@ -780,6 +815,42 @@ static unsigned char edid_domy[] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x19
 };
 
+/* AML EDID for Dolby atmos 0815 */
+static unsigned char edid_aud_atmos[] = {
+0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
+0x05, 0xA0, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00,
+0x20, 0x19, 0x01, 0x03, 0x80, 0x73, 0x41, 0x78,
+0x0A, 0xCF, 0x74, 0xA3, 0x57, 0x4C, 0xB0, 0x23,
+0x09, 0x48, 0x4C, 0x00, 0x00, 0x00, 0x01, 0x01,
+0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x74,
+0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58,
+0x8A, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E,
+0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
+0x58, 0x2C, 0x45, 0x00, 0x20, 0xC2, 0x31, 0x00,
+0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x41,
+0x4D, 0x4C, 0x20, 0x54, 0x56, 0x0A, 0x20, 0x20,
+0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
+0x00, 0x3B, 0x46, 0x1F, 0x8C, 0x3C, 0x00, 0x0A,
+0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x0F,
+0x02, 0x03, 0x4B, 0xF0, 0x5B, 0x5F, 0x10, 0x1F,
+0x14, 0x05, 0x13, 0x04, 0x20, 0x22, 0x3C, 0x3E,
+0x12, 0x16, 0x03, 0x07, 0x11, 0x15, 0x02, 0x06,
+0x01, 0x61, 0x5D, 0x64, 0x65, 0x66, 0x62, 0x60,
+0x29, 0x09, 0x07, 0x03, 0x57, 0x06, 0x01, 0x17,
+0x07, 0x50, 0x83, 0x01, 0x00, 0x00, 0x6A, 0x03,
+0x0C, 0x00, 0x20, 0x00, 0x88, 0x3C, 0x20, 0x80,
+0x00, 0x67, 0xD8, 0x5D, 0xC4, 0x01, 0x78, 0x88,
+0x01, 0xE5, 0x0F, 0x00, 0x00, 0x90, 0x05, 0xE3,
+0x06, 0x05, 0x01, 0x02, 0x3A, 0x80, 0xD0, 0x72,
+0x38, 0x2D, 0x40, 0x10, 0x2C, 0x45, 0x80, 0x30,
+0xEB, 0x52, 0x00, 0x00, 0x1F, 0x01, 0x1D, 0x00,
+0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55,
+0x40, 0x30, 0xEB, 0x52, 0x00, 0x00, 0x1F, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D,
+};
+
 unsigned char *edid_list[] = {
 	edid_buf,
 	aml_edid,
@@ -788,6 +859,7 @@ unsigned char *edid_list[] = {
 	edid_4K_MSD,
 	edid_domy,
 	v2_edid,
+	edid_aud_atmos,
 };
 
 static void dump_state(unsigned char enable);
@@ -798,48 +870,66 @@ static void rx_modify_edid(unsigned char *buffer,
 				int len, unsigned char *addition);
 static void rx_start_repeater_auth(void);
 
-/* add for hot plug det */
-void hdmirx_plug_det(struct work_struct *work)
+void eq_algorithm(struct work_struct *work)
 {
-	unsigned int tmp_5v, check_cnt, i, val;
+	unsigned int i;
 
-	cancel_delayed_work(&hpd_dwork);
-	if (rx.hdcp.hdcp_version) {
-		switch_set_state(&rx.hdcp.switch_hdcp_auth, 0);
-		switch_set_state(&rx.hdcp.switch_hdcp_auth,
+	cancel_delayed_work(&eq_dwork);
+	if (hdmirx_repeat_support()) {
+		if (rx.hdcp.hdcp_version) {
+			switch_set_state(&rx.hdcp.switch_hdcp_auth, 0);
+			switch_set_state(&rx.hdcp.switch_hdcp_auth,
 					rx.hdcp.hdcp_version);
-		rx.hdcp.hdcp_version = HDCP_VERSION_NONE;
+			rx.hdcp.hdcp_version = HDCP_VERSION_NONE;
+		}
 	}
-	if (log_flag & VIDEO_LOG)
-		rx_print("plug detect1:%d\n", pwr_sts);
-	val = 0;
-	check_cnt = pow5v_max_cnt;
-	for (i = 0; i <= 200; i++) {
-		if (auto_switch_off)
-			tmp_5v = 0x0f;
-		else
-			tmp_5v = (hdmirx_rd_top(TOP_HPD_PWR5V) >> 20) & 0xf;
-		mdelay(10);
-		if (val != tmp_5v) {
-			check_cnt = pow5v_max_cnt;
-			val = tmp_5v;
-		} else
-			check_cnt--;
-		if (check_cnt == 0)
-			break;
-		/* rx_print("[HDMIrx queue]cnt:%d 5v status:0x%x\n", */
-		/* check_cnt, tmp_5v); */
+	rx_pr("eq run\n");
+	for (i = 0; i < 3; i++) {
+		if (SettingFinder() == 1) {
+			rx_pr("EQ-%d-%d-%d-",
+					eq_ch0.bestsetting,
+					eq_ch1.bestsetting,
+					eq_ch2.bestsetting);
+
+			if (1 == eq_maxvsmin(eq_ch0.bestsetting,
+					eq_ch1.bestsetting,
+					eq_ch2.bestsetting)) {
+					if (log_flag & EQ_LOG)
+						rx_pr("pass\n");
+					rx.state = FSM_EQ_END;
+					break;
+			} else {
+				if (log_flag & EQ_LOG)
+					rx_pr("fail\n");
+			}
+
+		}
 	}
-	if (pwr_sts != tmp_5v) {
-		pwr_sts = tmp_5v;
-		hdmirx_wait_query();
-		if (log_flag & VIDEO_LOG)
-			rx_print("plug detect2:%d\n", pwr_sts);
+	if (i >= MINMAX_nTrys) {
+		eq_ch0.bestsetting = ErrorcableSetting;
+		eq_ch1.bestsetting = ErrorcableSetting;
+		eq_ch2.bestsetting = ErrorcableSetting;
+		rx.state = FSM_EQ_END;
+		if (log_flag & EQ_LOG)
+			rx_pr("EQ fail-retry\n");
 	}
-
 	return;
 }
 
+void rx_hpd_to_esm_handle(struct work_struct *work)
+{
+	cancel_delayed_work(&eq_dwork);
+
+	switch_set_state(&rx.hpd_sdev, 0x0);
+	rx_pr("esm_hpd-0\n");
+	mdelay(80);
+	switch_set_state(&rx.hpd_sdev, 0x01);
+	rx_pr("esm_hpd-1\n");
+	rx.state = FSM_HPD_HIGH;
+	rx_pr("esm err->FSM_HDMI5V_HIGH\n");
+
+	return;
+}
 /**
  * Clock event handler
  * @param[in,out] ctx context information
@@ -883,7 +973,7 @@ static int clock_handler(struct hdmi_rx_ctrl *ctx)
 		hdmirx_set_video_mute(1);
 
 		if (log_flag&0x100)
-			rx_print("\nmute1\n");
+			rx_pr("\nmute1\n");
 	}
 	return error;
 }
@@ -969,7 +1059,7 @@ static int drm_handler(struct hdmi_rx_ctrl *ctx)
 		hdmirx_set_video_mute(1);
 
 		if (log_flag&0x400)
-			rx_print("\nmd_mute\n");
+			rx_pr("\nmd_mute\n");
 	}
 	return error;
 }*/
@@ -1001,6 +1091,7 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 	/* uint32_t intr_aud_clk = 0; */
 	uint32_t intr_aud_fifo = 0;
 	uint32_t intr_hdcp22 = 0;
+	uint32_t intr_aud_cec = 0;
 
 	bool clk_handle_flag = false;
 	bool video_handle_flag = false;
@@ -1041,6 +1132,11 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 	if (intr_aud_fifo != 0)
 		hdmirx_wr_dwc(DWC_AUD_FIFO_ICLR, intr_aud_fifo);
 
+	intr_aud_cec =
+			hdmirx_rd_dwc(DWC_AUD_CEC_ISTS) &
+			hdmirx_rd_dwc(DWC_AUD_CEC_IEN);
+		if (intr_aud_cec != 0)
+			hdmirx_wr_dwc(DWC_AUD_CEC_ICLR, intr_aud_cec);
 
 	intr_hdcp22 =
 		hdmirx_rd_dwc(DWC_HDMI2_ISTS) &
@@ -1052,7 +1148,7 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 	/* check hdmi open status before dwc isr */
 	if (!rx.open_fg) {
 		if (log_flag & 0x1000)
-			rx_print("[isr] ingore dwc isr ---\n");
+			rx_pr("[isr] ingore dwc isr ---\n");
 		return error;
 	}
 
@@ -1061,16 +1157,18 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 			/* clk_handle_flag = true; */
 		if (get(intr_hdmi, AKSV_RCV) != 0) {
 			if (log_flag & 0x100)
-				rx_print("[RX]receive aksv\n");
+				rx_pr("[RX]receive aksv\n");
 			/*clk_handle_flag = true;*/
-			rx.hdcp.hdcp_version = HDCP_VERSION_14;
-			queue_delayed_work(hpd_wq, &hpd_dwork,
-					msecs_to_jiffies(5));
-			rx_start_repeater_auth();
+			if (hdmirx_repeat_support()) {
+				rx.hdcp.hdcp_version = HDCP_VERSION_14;
+				queue_delayed_work(eq_wq, &eq_dwork,
+						msecs_to_jiffies(5));
+				rx_start_repeater_auth();
+			}
 		}
 		if (get(intr_hdmi, DCM_CURRENT_MODE_CHG) != 0) {
 			if (log_flag & 0x400)
-				rx_print
+				rx_pr
 				    ("[isr] DMI DCM_CURRENT_MODE_CHG\n");
 			video_handle_flag = true;
 		}
@@ -1085,29 +1183,37 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 	if (intr_md != 0) {
 		if (get(intr_md, md_ists_en) != 0) {
 			if (log_flag & 0x100)
-				rx_print("md_ists:%x\n", intr_md);
+				rx_pr("md_ists:%x\n", intr_md);
 			video_handle_flag = true;
 		}
 		ctx->debug_irq_video_mode++;
 	}
 
 	if (intr_hdcp22 != 0) {
-		if (get(intr_hdcp22, _BIT(2)) != 0)
-			hdcp22_authenticated = 2;
-		if (get(intr_hdcp22, _BIT(3)) != 0)
-			hdcp22_authenticated = 3;
-		if (get(intr_hdcp22, _BIT(4)) != 0)
-			hdcp22_authenticated = 4;
-
+		if (log_flag & 0x100) {
+			rx_pr("before authed = %d\n",
+					hdcp22_authenticated);
+			rx_pr("capble sts = %d\n",
+					hdcp22_capable_sts);
+		}
 		if (get(intr_hdcp22, _BIT(0)) != 0)
-			hdcp22_capable_sts = 1;
+			hdcp22_capable_sts = HDCP22_AUTH_STATE_CAPBLE;
 		if (get(intr_hdcp22, _BIT(1)) != 0)
-			hdcp22_capable_sts = 0;
+			hdcp22_capable_sts = HDCP22_AUTH_STATE_NOT_CAPBLE;
+		if (get(intr_hdcp22, _BIT(2)) != 0)
+			hdcp22_authenticated = HDCP22_AUTH_STATE_LOST;
+		if (get(intr_hdcp22, _BIT(3)) != 0)
+			hdcp22_authenticated = HDCP22_AUTH_STATE_SUCCESS;
+		if (get(intr_hdcp22, _BIT(4)) != 0) {
+			hdcp22_authenticated = HDCP22_AUTH_STATE_FAILED;
+			if (hdcp22_capable_sts)
+				esm_set_stable(0);
+		}
 		if (log_flag & HDCP_LOG) {
-			rx_print("hdcp22_authenticated = %d\n",
-						hdcp22_authenticated);
-			rx_print("hdcp22_capable_sts = %d\n",
-						hdcp22_capable_sts);
+			rx_pr("auth = %d\n",
+					hdcp22_authenticated);
+			rx_pr("capable = %d\n",
+					hdcp22_capable_sts);
 		}
 		hdcp22_sts = intr_hdcp22;
 	}
@@ -1117,32 +1223,32 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 		/* hdmirx_wr_dwc(RA_PDEC_ICLR, intr_pedc); */
 		if (get(intr_pedc, DVIDET | AVI_CKS_CHG) != 0) {
 			if (log_flag & 0x400)
-				rx_print("[irq] AVI_CKS_CHG\n");
+				rx_pr("[irq] AVI_CKS_CHG\n");
 			video_handle_flag = true;
 		}
 		if (get(intr_pedc, VSI_CKS_CHG) != 0) {
 			if (log_flag & 0x400)
-				rx_print("[irq] VSI_CKS_CHG\n");
+				rx_pr("[irq] VSI_CKS_CHG\n");
 			vsi_handle_flag = true;
 		}
 		if (get(intr_pedc, DRM_RCV_EN | DRM_CKS_CHG) != 0) {
 			if (log_flag & 0x400)
-				rx_print("[irq] DRM_RCV_EN %#x\n", intr_pedc);
+				rx_pr("[irq] DRM_RCV_EN %#x\n", intr_pedc);
 				drm_handle_flag = true;
 		}
 		/* if (get(intr_pedc, AIF_CKS_CHG) != 0) { */
 		/* if(log_flag&0x400) */
-		/* rx_print("[HDMIrx isr] AIF_CKS_CHG\n"); */
+		/* rx_pr("[HDMIrx isr] AIF_CKS_CHG\n"); */
 		/* audio_handle_flag = true; */
 		/* } */
 		/* if (get(intr_pedc, PD_FIFO_NEW_ENTRY) != 0) { */
 		/* if(log_flag&0x400) */
-		/* rx_print("[HDMIrx isr] PD_FIFO_NEW_ENTRY\n"); */
+		/* rx_pr("[HDMIrx isr] PD_FIFO_NEW_ENTRY\n"); */
 		/* //execute[hdmi_rx_ctrl_event_packet_reception] = true; */
 		/* } */
 		if (get(intr_pedc, PD_FIFO_OVERFL) != 0) {
 			if (log_flag & 0x100)
-				rx_print("[irq] PD_FIFO_OVERFL\n");
+				rx_pr("[irq] PD_FIFO_OVERFL\n");
 			error |= hdmirx_packet_fifo_rst();
 		}
 		ctx->debug_irq_packet_decoder++;
@@ -1156,12 +1262,12 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 	if (intr_aud_fifo != 0) {
 		if (get(intr_aud_fifo, OVERFL) != 0) {
 			if (log_flag & 0x100)
-				rx_print("[irq] OVERFL\n");
+				rx_pr("[irq] OVERFL\n");
 			error |= hdmirx_audio_fifo_rst();
 		}
 		if (get(intr_aud_fifo, UNDERFL) != 0) {
 			if (log_flag & 0x100)
-				rx_print("[irq] UNDERFL\n");
+				rx_pr("[irq] UNDERFL\n");
 			error |= hdmirx_audio_fifo_rst();
 
 		}
@@ -1183,27 +1289,42 @@ static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
 	return error;
 }
 
-
 irqreturn_t irq_handler(int irq, void *params)
 {
 	int error = 0;
 	unsigned long hdmirx_top_intr_stat;
 	if (params == 0) {
-		rx_print("%s: %s\n",
+		rx_pr("%s: %s\n",
 			__func__,
 			"RX IRQ invalid parameter");
 		return IRQ_HANDLED;
 	}
 	hdmirx_top_intr_stat = hdmirx_rd_top(TOP_INTR_STAT);
-	hdmirx_wr_top(TOP_INTR_STAT_CLR, hdmirx_top_intr_stat);
+reisr:hdmirx_wr_top(TOP_INTR_STAT_CLR, hdmirx_top_intr_stat);
 	/* modify interrupt flow for isr loading */
 	/* top interrupt handler */
+	if (hdmirx_top_intr_stat & (0x7 << 17)) {
+		if (hdmirx_top_intr_stat & (0x1 << 17))
+			hdmirx_wr_top(TOP_EDID_GEN_STAT,
+			hdmirx_rd_top(TOP_EDID_GEN_STAT) | (1 << 16));
+		else if (hdmirx_top_intr_stat & (0x2 << 17))
+			hdmirx_wr_top(TOP_EDID_GEN_STAT_B,
+			hdmirx_rd_top(TOP_EDID_GEN_STAT_B) | (1 << 16));
+		else if (hdmirx_top_intr_stat & (0x4 << 17))
+			hdmirx_wr_top(TOP_EDID_GEN_STAT_C,
+			hdmirx_rd_top(TOP_EDID_GEN_STAT_C) | (1 << 16));
+		edid_addr_intr_flag = true;
+		if (log_flag & ERR_LOG)
+			rx_pr("ddc err-%x",
+			(hdmirx_top_intr_stat & (0x7 << 17)));
+	}
+	#if 0
 	if ((hdmirx_top_intr_stat & (0xf << 2)) ||
 		(hdmirx_top_intr_stat & (0xf << 6))) {
-		/* rx_print("%s: %s\n", __func__, " enable queue"); */
-		queue_delayed_work(hpd_wq, &hpd_dwork, msecs_to_jiffies(5));
+		/* rx_pr("%s: %s\n", __func__, " enable queue"); */
+		queue_delayed_work(hpd_wq, &eq_dwork, msecs_to_jiffies(5));
 	}
-
+	#endif
 	/* top interrupt handler */
 	/* if (hdmirx_top_intr_stat & (0xf << 2)) { */
 	/* schedule_work(&rx->plug_wq); */
@@ -1225,7 +1346,7 @@ irqreturn_t irq_handler(int irq, void *params)
 				&((struct rx_s *)params)->ctrl);
 		if (error < 0) {
 			if (error != -EPERM) {
-				rx_print("%s: RX IRQ handler %d\n",
+				rx_pr("%s: RX IRQ handler %d\n",
 					__func__,
 					error);
 			}
@@ -1234,14 +1355,14 @@ irqreturn_t irq_handler(int irq, void *params)
 
 	/* if (hdmirx_top_intr_stat & (0xf << 6)) */
 	/* check the ip interrupt again */
-	/*
+
 	hdmirx_top_intr_stat = hdmirx_rd_top(TOP_INTR_STAT);
-	if (hdmirx_top_intr_stat & (1 << 31) && !cec_has_irq()) {
+	if (hdmirx_top_intr_stat & (1 << 31)) {
 		if (log_flag & 0x100)
-			rx_print("[isr] need clear ip irq---\n");
+			rx_pr("[isr] need clear ip irq---\n");
 		goto reisr;
 
-	}*/
+	}
 	return IRQ_HANDLED;
 }
 
@@ -1340,8 +1461,9 @@ int hdmirx_hw_get_color_fmt(void)
 	case 2:
 		color_format = 1;	/* YUV444 */
 		break;
-	case 3:					/* YUV420 */
-		color_format = 1;	/* YUV444 */
+	case 3:
+		color_format = 3;	/* YUV422 */
+		/* color_format = 1; */	/* YUV444 */
 		break;
 	case 0:
 	default:
@@ -1886,7 +2008,7 @@ static bool is_packetinfo_change(struct hdmi_rx_ctrl_video *pre,
 	/* 3. colorspace change */
 	if (cur->video_format != pre->video_format) {
 		if (log_flag & VIDEO_LOG) {
-			rx_print("cur-video_format=%d, pre-video_format=%d\n",
+			rx_pr("cur-video_format=%d, pre-video_format=%d\n",
 				cur->video_format,
 				pre->video_format);
 		}
@@ -1895,7 +2017,7 @@ static bool is_packetinfo_change(struct hdmi_rx_ctrl_video *pre,
 	}
 	if (cur->interlaced != pre->interlaced) {
 		if (log_flag & VIDEO_LOG)
-			rx_print("cur-intlace=%d, pre-intlace=%d\n",
+			rx_pr("cur-intlace=%d, pre-intlace=%d\n",
 				cur->interlaced, pre->interlaced);
 		return true;
 	}
@@ -1917,17 +2039,17 @@ static bool is_timing_stable(struct hdmi_rx_ctrl_video *pre,
 		ret = false;
 
 		if (log_flag & VIDEO_LOG) {
-			rx_print("[hdmirx] timing unstable:");
-			rx_print("hactive(%d=>%d),",
+			rx_pr("[hdmirx] timing unstable:");
+			rx_pr("hactive(%d=>%d),",
 				     pre->hactive,
 				     cur->hactive);
-			rx_print("vactive(%d=>%d),",
+			rx_pr("vactive(%d=>%d),",
 				     pre->vactive,
 				     cur->vactive);
-			rx_print("pixel_repeat(%d=>%d),",
+			rx_pr("pixel_repeat(%d=>%d),",
 				     pre->repeat,
 				     cur->repeat);
-			rx_print("video_format(%d=>%d)\n",
+			rx_pr("video_format(%d=>%d)\n",
 			     pre->video_format,
 			     cur->video_format);
 		}
@@ -1950,9 +2072,9 @@ static bool is_frame_rate_change(struct hdmi_rx_ctrl_video *pre,
 		ret = true;
 
 		if (log_flag & 0x200) {
-			rx_print("[hdmirx] frame rate");
-			rx_print("change:refresh_rate");
-			rx_print("(%d=>%d),frame_rate:%d\n",
+			rx_pr("[hdmirx] frame rate");
+			rx_pr("change:refresh_rate");
+			rx_pr("(%d=>%d),frame_rate:%d\n",
 			     pre->refresh_rate,
 			     cur->refresh_rate,
 			     cur_rate);
@@ -1974,10 +2096,10 @@ static int get_timing_fmt(struct hdmi_rx_ctrl_video *video_par)
 
 	if ((frame_rate > 9000) && use_frame_rate_check) {
 		if (log_flag & 0x200) {
-			rx_print("[hdmirx] frame_rate");
-			rx_print("not support,sw_vic:%d,",
+			rx_pr("[hdmirx] frame_rate");
+			rx_pr("not support,sw_vic:%d,",
 				     video_par->sw_vic);
-			rx_print("hw_vic:%d,frame_rate:%d\n",
+			rx_pr("hw_vic:%d,frame_rate:%d\n",
 			     video_par->video_mode,
 			     frame_rate);
 		}
@@ -2034,8 +2156,8 @@ static int get_timing_fmt(struct hdmi_rx_ctrl_video *video_par)
 				if (video_par->repeat !=
 					 freq_ref[i].repeat) {
 					if (log_flag & PACKET_LOG)
-						rx_print("\n repeat err1");
-						rx_print("%d:%d(standard)",
+						rx_pr("\n repeat err1");
+						rx_pr("%d:%d(standard)",
 							video_par->repeat,
 							freq_ref[i].repeat);
 					video_par->repeat =
@@ -2045,12 +2167,12 @@ static int get_timing_fmt(struct hdmi_rx_ctrl_video *video_par)
 		}
 		/************ repetition Check patch end ************/
 		if (log_flag & 0x200) {
-			rx_print("[hdmirx] standard hdmi");
-			rx_print("mode,sw_vic:%d,",
+			rx_pr("[hdmirx] standard hdmi");
+			rx_pr("mode,sw_vic:%d,",
 					video_par->sw_vic);
-			rx_print("hw_vic:%d,",
+			rx_pr("hw_vic:%d,",
 					video_par->video_mode);
-			rx_print("frame_rate:%d\n",
+			rx_pr("frame_rate:%d\n",
 			     frame_rate);
 		}
 		return ret;
@@ -2082,8 +2204,8 @@ static int get_timing_fmt(struct hdmi_rx_ctrl_video *video_par)
 				if (video_par->repeat !=
 					 freq_ref[i].repeat) {
 					if (log_flag & PACKET_LOG) {
-						rx_print("\n repeat err2");
-						rx_print("%d:%d(standard)",
+						rx_pr("\n repeat err2");
+						rx_pr("%d:%d(standard)",
 							video_par->repeat,
 							freq_ref[i].repeat);
 					}
@@ -2094,12 +2216,12 @@ static int get_timing_fmt(struct hdmi_rx_ctrl_video *video_par)
 		}
 		/************ repetition Check patch end ************/
 		if (log_flag & 0x200) {
-			rx_print("[hdmirx] non standard");
-			rx_print("hdmi mode,sw_vic:%d,",
+			rx_pr("[hdmirx] non standard");
+			rx_pr("hdmi mode,sw_vic:%d,",
 				     video_par->sw_vic);
-			rx_print("hw_vic:%d,",
+			rx_pr("hw_vic:%d,",
 				     video_par->video_mode);
-			rx_print("frame_rate:%d\n",
+			rx_pr("frame_rate:%d\n",
 			     frame_rate);
 		}
 		return ret;
@@ -2130,8 +2252,8 @@ static void Signal_status_init(void)
 	sig_unstable_cnt = 0;
 	sig_unready_cnt = 0;
 	sig_unstable_reset_hpd_cnt = 0;
-	wait_no_signal_cnt = 0;
-	rx.no_signal = false;
+	wait_no_sig_cnt = 0;
+	/* rx.no_signal = false; */
 	rx.pre_state = 0;
 }
 
@@ -2139,110 +2261,29 @@ static void Signal_status_init(void)
 /* func:         port A,B,C,D  hdmitx-5v monitor & HPD control */
 /* note:         G9TV portD no used */
 /* ---------------------------------------------------------- */
-void HPD_controller(void)
+void rx_5v_det(void)
 {
 	uint32_t tmp_5v = 0;
-
-	tmp_5v = hdmirx_rd_top(TOP_HPD_PWR5V);
-
-	if ((tmp_5v >> 20) & 0x01) {
-		if (rx.portA_pow5v_state < pow5v_max_cnt)
-			rx.portA_pow5v_state++;
-	} else {
-		if (rx.portA_pow5v_state > 0)
-			rx.portA_pow5v_state--;
-	}
-	if ((tmp_5v >> 21) & 0x01) {
-		if (rx.portB_pow5v_state < pow5v_max_cnt)
-			rx.portB_pow5v_state++;
-	} else {
-		if (rx.portB_pow5v_state > 0)
-			rx.portB_pow5v_state--;
-	}
-	if ((tmp_5v >> 22) & 0x01) {
-		if (rx.portC_pow5v_state < pow5v_max_cnt)
-			rx.portC_pow5v_state++;
-	} else {
-		if (rx.portC_pow5v_state > 0)
-			rx.portC_pow5v_state--;
-	}
-
-	if (multi_port_edid_enable) {
-		/* ------------port A-------------// */
-		if (rx.portA_pow5v_state == 0) {
-			if (rx.port == 0)
-				rx.current_port_tx_5v_status = 0;
-			if (rx.portA_pow5v_state_pre == 1) {
-				rx.portA_pow5v_state_pre = 0;
-				if (current_port_hpd_ctl)
-					hdmirx_set_hpd(0, 0);
-			}
-		} else if (rx.portA_pow5v_state == pow5v_max_cnt) {
-			if (rx.port == 0)
-				rx.current_port_tx_5v_status = 1;
-			if (rx.portA_pow5v_state_pre == 0) {
-				rx.portA_pow5v_state_pre = 1;
-				if (current_port_hpd_ctl)
-					hdmirx_set_hpd(0, 1);
-			}
-		}
-		/* ------------port B-------------// */
-		if (rx.portB_pow5v_state == 0) {
-			if (rx.port == 1)
-				rx.current_port_tx_5v_status = 0;
-			if (rx.portB_pow5v_state_pre == 1) {
-				rx.portB_pow5v_state_pre = 0;
-				if (current_port_hpd_ctl)
-					hdmirx_set_hpd(1, 0);
-			}
-		} else if (rx.portB_pow5v_state == pow5v_max_cnt) {
-			if (rx.port == 1)
-				rx.current_port_tx_5v_status = 1;
-			if (rx.portB_pow5v_state_pre == 0) {
-				rx.portB_pow5v_state_pre = 1;
-				if (current_port_hpd_ctl)
-					hdmirx_set_hpd(1, 1);
-			}
-		}
-		/* -------------port C-------------// */
-		if (rx.portC_pow5v_state == 0) {
-			if (rx.port == 2)
-				rx.current_port_tx_5v_status = 0;
-			if (rx.portC_pow5v_state_pre == 1) {
-				rx.portC_pow5v_state_pre = 0;
-				if (current_port_hpd_ctl)
-					hdmirx_set_hpd(2, 0);
-			}
-		} else if (rx.portC_pow5v_state == pow5v_max_cnt) {
-			if (rx.port == 2)
-				rx.current_port_tx_5v_status = 1;
-			if (rx.portC_pow5v_state_pre == 0) {
-				rx.portC_pow5v_state_pre = 1;
-				if (current_port_hpd_ctl)
-					hdmirx_set_hpd(2, 1);
-			}
-		}
-		/* ------------------------------// */
-	} else {
-		if (rx.port == 0) {
-			if (rx.portA_pow5v_state == pow5v_max_cnt)
-				rx.current_port_tx_5v_status = 1;
-			else
-				rx.current_port_tx_5v_status = 0;
-		} else if (rx.port == 1) {
-			if (rx.portB_pow5v_state == pow5v_max_cnt)
-				rx.current_port_tx_5v_status = 1;
-			else
-				rx.current_port_tx_5v_status = 0;
-		} else if (rx.port == 2) {
-			if (rx.portC_pow5v_state == pow5v_max_cnt)
-				rx.current_port_tx_5v_status = 1;
-			else
-				rx.current_port_tx_5v_status = 0;
-		}
-	}
+	static int check_cnt;
 	if (force_hdmi_5v_high)
-		rx.current_port_tx_5v_status = 1;
+		rx.cur_5v_sts = 1;
+	else
+		rx.cur_5v_sts = (pwr_sts >> rx.port) & 1;
+	if (auto_switch_off)
+		tmp_5v = 0x0f;
+	else
+		tmp_5v = (hdmirx_rd_top(TOP_HPD_PWR5V) >> 20) & 0xf;
+	if (tmp_5v == pwr_sts)
+		return;
+	else {
+		check_cnt++;
+		if (check_cnt < pow5v_max_cnt)
+			return;
+	}
+	check_cnt = 0;
+	pwr_sts = tmp_5v;
+	rx_pr("hotplg-%x", pwr_sts);
+	hdmirx_wait_query();
 }
 
 void hdmirx_error_count_config(void)
@@ -2287,11 +2328,11 @@ bool is_low_freq_format(void)
 	clk = (clk >> 10) & 1;
 	if (1 == clk) {
 		if (log_flag & VIDEO_LOG)
-			rx_print("under 94.5M\n");
+			rx_pr("under 94.5M\n");
 		return true;
 	} else {
 		if (log_flag & VIDEO_LOG)
-			rx_print("over 94.5M\n");
+			rx_pr("over 94.5M\n");
 		return false;
 	}
 }
@@ -2378,36 +2419,33 @@ static bool is_ddc_state_error(void)
 		return false;
 }
 
+void hdmirx_hdcp22_reauth(void)
+{
+	if (hdcp22_reauth_enable)
+		esm_auth_fail_en = 1;
+	else {
+		hdmirx_set_hpd(rx.port, 0);
+		rx.state = FSM_HPD_LOW;
+	}
+}
+
 void monitor_capable_sts(void)
 {
-	static int pre_sts_1 = 0xff;
-	static int pre_sts_2 = 0xff;
-	/* if (hdcp22_capable_sts != pre_sts) {
-		if (((2 == hdcp22_authenticated) ||
-			(0xff == hdcp22_authenticated)) &&
-			(0 == hdcp22_capable_sts) &&
-			(1 == pre_sts))	{
-			if (rx.state != FSM_SIG_READY) {
-				rx.state = FSM_WAIT_CLK_STABLE;
-				rx_print("\n force wait stable\n");
-			}
-		}
-		pre_sts = hdcp22_capable_sts;
-	} */
-	if ((pre_sts_1 != hdcp22_capable_sts) ||
-		(pre_sts_2 != hdcp22_authenticated)) {
-
-		if ((rx.state != FSM_WAIT_CLK_STABLE) &&
-			(rx.state != FSM_WAIT_HDCP_SWITCH) &&
-			(rx.state != FSM_SIG_READY)) {
-			rx.pre_state = rx.state;
-			rx.state = FSM_WAIT_HDCP_SWITCH;
-			if (log_flag & HDCP_LOG)
-				rx_print("\n esm change,force wait\n");
+	/*if the auth lost after the success of authentication*/
+	if ((HDCP22_AUTH_STATE_CAPBLE == hdcp22_capable_sts) &&
+		(HDCP22_AUTH_STATE_LOST == hdcp22_authenticated)) {
+		hdcp22_lost_cnt++;
+		if ((hdcp22_lost_cnt > hdcp22_lost_max) &&
+			(do_link_lost_reset)) {
+			hdcp22_authenticated = 254;
+			hdcp22_lost_cnt = 0;
+			hdmirx_hdcp22_reauth();
+			rx_pr("\n auth lost force hpd rst\n");
 		}
+	} else {
+		if (hdcp22_lost_cnt > 0)
+			hdcp22_lost_cnt--;
 	}
-	pre_sts_1 = hdcp22_capable_sts;
-	pre_sts_2 = hdcp22_authenticated;
 }
 
 void monitor_cable_clk_sts(void)
@@ -2415,26 +2453,15 @@ void monitor_cable_clk_sts(void)
 	static bool pre_sts = 0xff;
 	bool sts = is_clk_stable();
 	if (pre_sts != sts) {
-		rx_print("\ncable clk stable = %d\n", sts);
+		if (log_flag & VIDEO_LOG)
+			rx_pr("\nclk stable = %d\n", sts);
 		pre_sts = sts;
 	}
-	if ((sts == false) &&
-		(rx.state < FSM_SIG_READY) &&
-		(rx.state > FSM_HPD_READY)) {
-		if ((rx.state != FSM_WAIT_CLK_STABLE) &&
-			(rx.state != FSM_WAIT_HDCP_SWITCH) &&
-			(rx.state != FSM_SIG_READY)) {
-			rx.pre_state = rx.state;
-			rx.state = FSM_WAIT_CLK_STABLE;
-			if (log_flag & VIDEO_LOG)
-				rx_print("\n clk unstable,force wait\n");
-		}
-	}
 }
 void rx_dwc_reset(void)
 {
 	if (log_flag & VIDEO_LOG)
-		rx_print("rx_dwc_reset\n");
+		rx_pr("rx_dwc_reset\n");
 	/* audio_status_init(); */
 	/* Signal_status_init(); */
 	hdmirx_audio_fifo_rst();
@@ -2448,9 +2475,15 @@ void set_scdc_cfg(int hpdlow, int pwrprovided)
 		(hpdlow << 1) | (pwrprovided << 0));
 }
 
-bool hdmirx_tmds_34g(void)
+int get_cur_hpd_sts(void)
 {
-	return rx.scdc_tmds_cfg >= scdc_tmds_try_max;
+	return hdmirx_rd_top(TOP_HPD_PWR5V) & (1 << rx.port);
+}
+
+bool hdmirx_tmds_6g(void)
+{
+	return (rx.scdc_tmds_cfg >= scdc_tmds_try_max) ||
+		((hdmirx_rd_dwc(DWC_SCDC_REGS0) >> 17) & 1);
 }
 
 bool hdmirx_tmds_34g_max(void)
@@ -2463,7 +2496,7 @@ void esm_reboot_func(void)
 {
 	if (esm_reboot_lvl == 1) {
 		hdmirx_set_hpd(rx.port, 0);
-		hdcp_22_on = 1;
+		hdcp22_on = 1;
 		hdcp22_kill_esm = 1;
 		mdelay(wait_hdcp22_cnt1);
 		hdcp22_kill_esm = 0;
@@ -2477,10 +2510,10 @@ void esm_reboot_func(void)
 			0x1000);
 		hdmirx_hw_config();
 		hpd_to_esm = 1;
-		rx.state = FSM_HDMI5V_HIGH;
+		rx.state = FSM_HPD_HIGH;
 	} else if (esm_reboot_lvl == 2) {
 		hdmirx_set_hpd(rx.port, 0);
-		hdcp_22_on = 1;
+		hdcp22_on = 1;
 		hdcp22_kill_esm = 1;
 		mdelay(wait_hdcp22_cnt1);
 		hdcp22_kill_esm = 0;
@@ -2493,9 +2526,9 @@ void esm_reboot_func(void)
 			0x1000);
 		hdmirx_hw_config();
 		hpd_to_esm = 1;
-		rx.state = FSM_HDMI5V_HIGH;
+		rx.state = FSM_HPD_HIGH;
 	}
-	rx_print("esm_reboot_func\n");
+	rx_pr("esm_reboot_func\n");
 }
 void hdmirx_esm_hw_fault_detect(void)
 {
@@ -2505,12 +2538,12 @@ void hdmirx_esm_hw_fault_detect(void)
 		if (reboot_esm_done == 0) {
 			esm_reboot_func();
 			reboot_esm_done = 1;
-			rx_print("esm reboot done\n");
+			rx_pr("esm reboot done\n");
 		} else {
 			hdmirx_wr_dwc(0x81c,
 				0x2);
 			esm_err_force_14 = 1;
-			rx_print("force 1.4-0\n");
+			rx_pr("force 1.4-0\n");
 		}
 	}
 
@@ -2521,56 +2554,241 @@ void hdmirx_esm_hw_fault_detect(void)
 			hdmirx_wr_dwc(0x81c,
 				0x2);
 			esm_err_force_14 = 1;
-			rx_print("force 1.4-1\n");
+			rx_pr("force 1.4-1\n");
 		}
 	}
 }
 #endif
 
+enum func_hdmi_uart_select {
+	func_hdmi = 0,
+	func_uart = 1,
+};
+
+unsigned char share_status[3] = {
+	func_hdmi,
+	func_hdmi,
+	func_hdmi,
+};
+
+static char * const hdmi_uart_state[] = {
+	"hu_det_none",
+	"hu_det_uart0",
+	"hu_det_uart1",
+	"hu_det_uart2",
+};
+
+void func_switch(unsigned int share_stat)
+{
+	struct pinctrl *p = NULL;
+	if ((share_stat & 7) == 0)
+		p = devm_pinctrl_get_select(hdmirx_dev, hdmi_uart_state[0]);
+	else if ((share_stat & 7) == 1)
+		p = devm_pinctrl_get_select(hdmirx_dev, hdmi_uart_state[1]);
+	else if ((share_stat & 7) == 2)
+		p = devm_pinctrl_get_select(hdmirx_dev, hdmi_uart_state[2]);
+	else if ((share_stat & 7) == 4)
+		p = devm_pinctrl_get_select(hdmirx_dev, hdmi_uart_state[3]);
+	if (IS_ERR(p))
+		rx_pr("pinmux_setting fail, %ld\n", PTR_ERR(p));
+}
+
+#define GPIO_STATUS(a, b, c)\
+(((a << 0) & 1) | ((b << 1) & 2) | ((c << 2) & 4))
+
+void uart_plugin_monitor(void)
+{
+	int sda_sts[3];
+	static char sda_sts_a;
+	static char sda_sts_b;
+	static char sda_sts_c;
+	bool sts_change = false;
+	static unsigned int share_stat;
+	if (0 == share_with_uart_cfg)
+		return;
+	if (0 == hu_share_choise)
+		return;
+	/* force recover to I2c */
+	if ((pwr_sts & 1)
+		&& (share_status[0] != func_hdmi)) {
+		share_status[0] = func_hdmi;
+		sts_change = true;
+	}
+	if ((pwr_sts & 2)
+		&& (share_status[1] != func_hdmi)) {
+		share_status[1] = func_hdmi;
+		sts_change = true;
+	}
+	if ((pwr_sts & 4)
+		&& (share_status[2] != func_hdmi)) {
+		share_status[2] = func_hdmi;
+		sts_change = true;
+	}
+	sda_sts[0] = gpiod_get_value(g_uart_pin[0]);
+	sda_sts[1] = gpiod_get_value(g_uart_pin[1]);
+	sda_sts[2] = gpiod_get_value(g_uart_pin[2]);
+	if (hu_share_choise & 1) {
+		if ((0 == (pwr_sts & 1))
+			&& (sda_sts[0])
+			&& (share_status[0] == func_hdmi)) {
+			/*in case when there are two uart_hdmi connect,
+			one is in use, the other unsed sta_stat will
+			increase the whole time.*/
+			if (!share_stat)
+				sda_sts_a++;
+		} else if ((0 == (pwr_sts & 1))
+			&& (!sda_sts[0])
+			&& (sda_sts_a > 0)) {
+			sda_sts_a--;
+		}
+	}
+	if (hu_share_choise & 2) {
+		if ((0 == (pwr_sts & 2))
+			&& (sda_sts[1])
+			&& (share_status[1] == func_hdmi)) {
+			if (!share_stat)
+				sda_sts_b++;
+		} else if ((0 == (pwr_sts & 2))
+			&& (!sda_sts[1]) &&
+			(sda_sts_b > 0)) {
+			sda_sts_b--;
+		}
+	}
+	if (hu_share_choise & 4) {
+		if ((0 == (pwr_sts & 4))
+			&& (sda_sts[2])
+			&& (share_status[2] == func_hdmi)) {
+			if (!share_stat)
+				sda_sts_c++;
+		} else if ((0 == (pwr_sts & 4))
+			&& (!sda_sts[2])
+			&& (sda_sts_c > 0)) {
+			sda_sts_c--;
+		}
+	}
+	/*share_stat: must=0, if port A is in use,
+	port B/C won't take effect*/
+	share_stat = GPIO_STATUS(share_status[0],
+		share_status[1], share_status[2]);
+	if ((share_stat == 0)
+		&& (sda_sts_a > uart_plugin_check_cnt)) {
+		share_status[0] = func_uart;
+		sts_change = true;
+	} else if ((0 == sda_sts_a)
+		&& (share_status[0] == func_uart)) {
+		share_status[0] = func_hdmi;
+		sts_change = true;
+	}
+	if ((share_stat == 0)
+		&& (sda_sts_b > uart_plugin_check_cnt)) {
+		share_status[1] = func_uart;
+		sts_change = true;
+	} else if ((0 == sda_sts_b)
+		&& (share_status[1] == func_uart)) {
+		share_status[1] = func_hdmi;
+		sts_change = true;
+	}
+	if ((share_stat == 0)
+		&& (sda_sts_c > uart_plugin_check_cnt)) {
+		share_status[2] = func_uart;
+		sts_change = true;
+	} else if ((0 == sda_sts_c)
+		&& (share_status[2] == func_uart)) {
+		share_status[2] = func_hdmi;
+		sts_change = true;
+	}
+	share_stat = GPIO_STATUS(share_status[0],
+		share_status[1], share_status[2]);
+	if (sts_change)
+		func_switch(share_stat);
+}
+
+void esm_set_stable(bool stable)
+{
+	if (log_flag & HDCP_LOG)
+		rx_pr("esm set stable:%d\n", stable);
+	video_stable_to_esm = stable;
+}
+
+void edid_update(void)
+{
+	static int step;
+	if (0 == step)
+		hdmirx_set_hpd(rx.port, 0);
+		rx.change = 1;
+
+	if (2 == step)
+		hdmi_rx_ctrl_edid_update();
+
+	if (step > 15) {
+		edid_update_flag = false;
+		rx.state = FSM_HPD_HIGH;
+		step = 0;
+		return;
+	}
+	step++;
+}
+
+
+void esm_rst_monitor(void)
+{
+	static int esm_rst_cnt;
+	if (video_stable_to_esm == 0) {
+		if (esm_rst_cnt++ > 2) {
+			if (log_flag & HDCP_LOG)
+				rx_pr("esm=1\n");
+			esm_set_stable(1);
+			esm_rst_cnt = 0;
+		}
+	}
+}
 void hdmirx_hw_monitor(void)
 {
 	int pre_sample_rate;
 	int tmp;
 	unsigned int tmds_clk;
 
-	if ((clk_debug) && (rx.state >= FSM_SIG_UNSTABLE))
+	if (clk_debug)
 		monitor_cable_clk_sts();
 
 	if (sm_pause)
 		return;
 
-	HPD_controller();
-	rx_check_repeat();
+	if (esm_error_flag) {
+		esm_error_flag = 0;
+		queue_delayed_work(esm_wq,
+				&esm_dwork, msecs_to_jiffies(1));
+		hdmirx_set_hpd(rx.port, 0);
+		rx_pr("esm err->FSM_HDMI5V_HIGH\n");
+	}
 	#ifdef HDCP22_ENABLE
-	if (hdcp_22_on)
+	if ((hdcp22_on) && (rx.state > FSM_SIG_UNSTABLE))
 		monitor_capable_sts();
+	esm_rst_monitor();
 	#endif
-	if (rx.current_port_tx_5v_status == 0) {
+
+	if (rx.cur_5v_sts == 0) {
 		if (rx.state != FSM_INIT) {
-			rx_print("5v_lost->FSM_INIT\n");
-			rx.no_signal = true;
-			pre_port = 0xfe;
+			rx_pr("5v_lost->FSM_INIT\n");
+			pre_port = e_5v_lost;
 			if (scdc_cfg_en)
 				set_scdc_cfg(1, 0);
-			/* hdmirx_set_hpd(rx.port, 0); */
 			hdmirx_audio_enable(0);
 			hdmirx_audio_fifo_rst();
 			rx_aud_pll_ctl(0);
-			/* when pull signal out,there is shake to start eq */
-			hdmirx_phy_stop_eq();
 			rx.state = FSM_INIT;
 		}
 		#ifdef HDCP22_ENABLE
-		if (hdcp_22_on)
-			video_stable_to_esm = 0;
+		if (hdcp22_on)
+			esm_set_stable(0);
 		#endif
 		return;
 	} else {
 		if (rx.state != FSM_SIG_READY) {
-			if (wait_no_signal_cnt == wait_clk_stable_max)
+			if (wait_no_sig_cnt == wait_no_sig_max)
 				rx.no_signal = true;
 			else
-				wait_no_signal_cnt++;
+				wait_no_sig_cnt++;
 		}
 	}
 	switch (rx.state) {
@@ -2578,21 +2796,22 @@ void hdmirx_hw_monitor(void)
 		if (reset_sw)
 			hdmirx_hw_config();
 			/* hdmi_rx_ctrl_edid_update(); */
-		rx.state = FSM_HDMI5V_LOW;
+		rx.state = FSM_HPD_LOW;
 		rx.pre_state = FSM_INIT;
-		wait_no_signal_cnt = 0;
-		rx_print("INIT->5V_LOW\n");
+		wait_no_sig_cnt = 0;
+		rx_pr("INIT->5V_LOW\n");
 		break;
-	case FSM_HDMI5V_LOW:
-		if (scdc_cfg_en)
-			set_scdc_cfg(1, 1);
+	case FSM_HPD_LOW:
+		/* if (scdc_cfg_en)
+			set_scdc_cfg(1, 1); */
 		audio_status_init();
 		Signal_status_init();
-		rx.state = FSM_HDMI5V_HIGH;
-		rx_print("5V_LOW->5V_HIGH\n");
+		rx.state = FSM_HPD_HIGH;
+		rx_pr("HPD_LOW\n");
 		break;
-	case FSM_HDMI5V_HIGH:
-		if (++hpd_wait_cnt <= hpd_wait_max)
+	case FSM_HPD_HIGH:
+		if (0 == get_cur_hpd_sts() &&
+			(++hpd_wait_cnt <= hpd_wait_max))
 			break;
 		hpd_wait_cnt = 0;
 		rx.scdc_tmds_cfg = 0;
@@ -2600,71 +2819,78 @@ void hdmirx_hw_monitor(void)
 		hdmirx_set_hpd(rx.port, 1);
 		if (scdc_cfg_en)
 			set_scdc_cfg(0, 1);
-		rx.state = FSM_HPD_READY;
-		rx_print("5V_high->HPD_READY\n");
+		rx.state = FSM_WAIT_CLK_STABLE;
+		rx_pr("HPD_HIGH\n");
+		break;
+	case FSM_WAIT_CLK_STABLE:
+		if (is_clk_stable()) {
+			if (is_clk_stable_cnt++ > is_clk_stable_max) {
+				rx.state = FSM_EQ_INIT;
+				wait_clk_stable_cnt = 0;
+				is_clk_stable_cnt = 0;
+			}
+			break;
+		}
+		is_clk_stable_cnt = 0;
+		wait_clk_stable_cnt++;
+		if (wait_clk_stable_cnt == wait_clk_stable_max) {
+			hdmirx_phy_init(rx.port, 0);
+			break;
+		}
+		if (wait_clk_stable_cnt >= wait_clk_stable_max*2) {
+			rx.state = FSM_HPD_LOW;
+			hdmirx_set_hpd(rx.port, 0);
+			pre_port = e_hpd_reset;
+			wait_clk_stable_cnt = 0;
+			break;
+		}
 		break;
-	case FSM_HPD_READY:
+	case FSM_EQ_INIT:
 		/*check mhl 3.4gb*/
-		if (hdmirx_tmds_34g() ||
-			((hdmirx_rd_dwc(DWC_SCDC_REGS0) >> 17) & 1)) {
+		rx_pr("EQ-init\n");
+
+		if (hdmirx_tmds_6g()) {
 			hdmirx_wr_phy(PHY_CDR_CTRL_CNT,
 				hdmirx_rd_phy(PHY_CDR_CTRL_CNT)|(1<<8));
 		} else {
 			hdmirx_wr_phy(PHY_CDR_CTRL_CNT,
 				hdmirx_rd_phy(PHY_CDR_CTRL_CNT)&(~(1<<8)));
 		}
-		if (FSM_SIG_READY != rx.pre_state) {
-			if (eq_calc_mode == 0) {
-				wait_clk_stable = 0;
-				hdmirx_phy_start_eq();
-			}
-			rx.state = FSM_EQ_CALIBRATION;
-			rx_print("HPD_READY->CALIBRATION\n");
+
+		if ((eq_dbg_ch0 != 0) ||
+			(eq_dbg_ch1 != 0) ||
+			(eq_dbg_ch2 != 0)) {
+			if (log_flag & EQ_LOG)
+				rx_pr("eq_dbg:%d-%d-%d",
+				eq_dbg_ch0,
+				eq_dbg_ch1,
+				eq_dbg_ch2);
+			rx.state = FSM_SIG_UNSTABLE;
+			break;
+		} else if (!rx_need_eq_workaround()) {
+			rx.state = FSM_SIG_UNSTABLE;
+			break;
 		} else {
-			rx.state = FSM_PHY_RST;
-			rx_print("HPD_READY->PHY_RST\n");
+			rx.state = FSM_EQ_CALIBRATION;
+			queue_delayed_work(eq_wq,
+				&eq_dwork, msecs_to_jiffies(1));
+			break;
 		}
-		rx.pre_state = FSM_HPD_READY;
 		break;
 	case FSM_EQ_CALIBRATION:
-		if (eq_calc_mode != 0) {
-			hdmirx_phy_conf_eq_setting(rx.port, eq_calc_mode ,
-				eq_calc_mode , eq_calc_mode);
-			rx.state = FSM_SIG_UNSTABLE;
-			rx_print("CALIBRATION->CLK_STABLE\n");
-			return;
-		}
-
-		if (hdmirx_phy_get_eq_state() == EQ_SUCCESS_END) {
-			rx.state = FSM_PHY_RST;
-			rx.pre_state = FSM_EQ_CALIBRATION;
-			wait_clk_stable = 0;
-			rx_print("CALIBRATION->TIMINGCHANGE success\n");
-		} else if (hdmirx_phy_get_eq_state() < EQ_SUCCESS_END) {
-			if (wait_clk_stable > wait_clk_stable_max) {
-				rx.state = FSM_PHY_RST;
-				rx.pre_state = FSM_EQ_CALIBRATION;
-				wait_clk_stable = 0;
-				hdmirx_phy_stop_eq();
-				rx_print(
-				"CALIBRATION->TIMINGCHANGE timeout\n");
-			}
-			wait_clk_stable++;
-		} else {	/* failed */
-			rx_print("CALIBRATION->TIMINGCHANGE fail\n");
-			rx.state = FSM_PHY_RST;
-			rx.pre_state = FSM_EQ_CALIBRATION;
-			hdmirx_phy_stop_eq();
-			wait_clk_stable = 0;
-		}
 		break;
-	case FSM_PHY_RST:
-		if ((reset_sw) && (is_phy_reset)) {
-			if (rx.pre_state == FSM_HPD_READY)
-				hdmirx_phy_reset(rx.port, 1);
-		}
+	case FSM_EQ_END:
+		phy_conf_eq_setting(eq_ch0.bestsetting,
+				eq_ch1.bestsetting,
+				eq_ch2.bestsetting);
+		hdmirx_phy_conf_eq_setting(rx.port,
+				eq_ch0.bestsetting,
+				eq_ch1.bestsetting,
+				eq_ch2.bestsetting);
+		if (log_flag & EQ_LOG)
+			rx_pr("EQ_end\n");
 		rx.state = FSM_SIG_UNSTABLE;
-		rx_print("PHY RST->UNSTABLE\n");
+		rx_pr("->UNSTABLE\n");
 		break;
 	case FSM_WAIT_HDCP_SWITCH:
 		force_wait_cnt++;
@@ -2674,20 +2900,6 @@ void hdmirx_hw_monitor(void)
 			break;
 		}
 		break;
-	case FSM_WAIT_CLK_STABLE:
-		wait_clk_stable++;
-		if (is_clk_stable()) {
-			rx.state = rx.pre_state;
-			wait_clk_stable = 0;
-			break;
-		}
-		if (wait_clk_stable > clk_stable_max) {
-			rx.state = FSM_HDMI5V_LOW;
-			hdmirx_set_hpd(rx.port, 0);
-			wait_clk_stable = 0;
-			break;
-		}
-		break;
 	case FSM_SIG_UNSTABLE:
 		if (hdmirx_tmds_pll_lock()) {
 			sig_pll_lock_cnt++;
@@ -2696,23 +2908,23 @@ void hdmirx_hw_monitor(void)
 				rx.scdc_tmds_cfg = 0;
 				if (reset_sw)
 					rx_dwc_reset();
-				#ifdef HDCP22_ENABLE
-				if (hdcp_22_on)
-					video_stable_to_esm = 1;
-				#endif
+				/* #ifdef HDCP22_ENABLE
+				if (hdcp22_on)
+					esm_set_stable(1);
+				#endif */
 				sig_pll_unlock_cnt = 0;
 				sig_pll_lock_cnt = 0;
 				rx.no_signal = false;
-				rx_print("UNSTABLE->DWC_RST pll:%d\n",
+				rx_pr("UNSTABLE->DWC_RST pll:%d\n",
 					    rx.scdc_tmds_cfg);
 			} else {
 			    if (log_flag & VIDEO_LOG)
-					rx_print("SIG_UNSTABLE lock_cnt :%d\n",
+					rx_pr("SIG_UNSTABLE lock_cnt :%d\n",
 							sig_pll_lock_cnt);
 			}
 		} else {
 			if ((sig_pll_lock_cnt) && (log_flag & VIDEO_LOG))
-				rx_print("pll_lock_cnt=%d\n", sig_pll_lock_cnt);
+				rx_pr("pll_lock_cnt=%d\n", sig_pll_lock_cnt);
 
 			/*for some device sending scdc slow,recheck*/
 			/*hdmirx_phy_clk_rate_monitor();*/
@@ -2726,12 +2938,12 @@ void hdmirx_hw_monitor(void)
 				if (hdmirx_tmds_34g_max()) {
 					rx.scdc_tmds_cfg = 0;
 					hdmirx_set_hpd(rx.port, 0);
-					rx.state = FSM_HDMI5V_LOW;
+					rx.state = FSM_HPD_LOW;
 					sig_pll_unlock_cnt = 0;
 					break;
 				}
-				rx.state = FSM_HPD_READY;
-				rx_print("UNSTABLE->HPD_READY 3g:%d\n",
+				rx.state = FSM_WAIT_CLK_STABLE;
+				rx_pr("UNSTABLE->HPD_READY 3g:%d\n",
 						rx.scdc_tmds_cfg);
 				sig_pll_unlock_cnt = 0;
 
@@ -2749,7 +2961,7 @@ void hdmirx_hw_monitor(void)
 		do_hpd_reset_flag = 0;
 		dwc_rst_wait_cnt = 0;
 		rx.state = FSM_SIG_STABLE;
-		rx_print("DWC_RST->STABLE\n");
+		rx_pr("DWC_RST->STABLE\n");
 		break;
 	case FSM_SIG_STABLE:
 		memcpy(&rx.pre_params,
@@ -2761,7 +2973,7 @@ void hdmirx_hw_monitor(void)
 			&rx.cur_params) || (force_ready)) {
 			if (sig_stable_cnt++ > sig_stable_max) {
 				#ifdef HDCP22_ENABLE
-				if (hdcp_22_on && enable_esm_reboot) {
+				if (hdcp22_on && enable_esm_reboot) {
 					hdmirx_esm_hw_fault_detect();
 					if ((esm_err_force_14 == 1) ||
 						((rx_hdcp22_rd(0x60)&1) == 1))
@@ -2774,13 +2986,13 @@ void hdmirx_hw_monitor(void)
 				if ((rx.pre_params.sw_vic == HDMI_UNSUPPORT) ||
 					(rx.pre_params.sw_vic == HDMI_UNKNOW)) {
 					if (log_flag & VIDEO_LOG)
-						rx_print("stable-unknowvic\n");
+						rx_pr("stable-unknowvic\n");
 					if (sig_stable_cnt < (sig_stable_max*5))
 						break;
 					sig_stable_cnt = 0;
-					rx_print(
+					rx_pr(
 					"novic SIG_STABLE->HPD_READY\n");
-					rx.state = FSM_HPD_READY;
+					rx.state = FSM_WAIT_CLK_STABLE;
 					break;
 				}
 				if (rx.pre_params.sw_dvi == 1) {
@@ -2798,14 +3010,14 @@ void hdmirx_hw_monitor(void)
 					0,
 					sizeof(struct aud_info_s));
 				hdmirx_config_video(&rx.pre_params);
-				rx_print("STABLE->DDC_CORRECT\n");
+				rx_pr("STABLE->DDC_CORRECT\n");
 				if (log_flag & VIDEO_LOG)
 					dump_state(0x1);
 			}
 		} else {
 			sig_stable_cnt = 0;
 			if (sig_unstable_cnt++ > sig_unstable_max) {
-				rx.state = FSM_HPD_READY;
+				rx.state = FSM_WAIT_CLK_STABLE;
 				rx.pre_state = FSM_SIG_STABLE;
 				sig_stable_cnt = 0;
 				sig_unstable_cnt = 0;
@@ -2814,15 +3026,15 @@ void hdmirx_hw_monitor(void)
 					sig_unstable_reset_hpd_cnt++;
 					if (sig_unstable_reset_hpd_cnt >=
 						sig_unstable_reset_hpd_max) {
-						rx.state = FSM_HDMI5V_HIGH;
+						rx.state = FSM_HPD_HIGH;
 						hdmirx_set_hpd(rx.port, 0);
 						sig_unstable_reset_hpd_cnt = 0;
-						rx_print(
+						rx_pr(
 						"unstable->HDMI5V_HIGH\n");
 						break;
 					}
 				}
-				rx_print("STABLE->HPD_READY\n");
+				rx_pr("STABLE->HPD_READY\n");
 			}
 		}
 		break;
@@ -2839,20 +3051,20 @@ void hdmirx_hw_monitor(void)
 				if (scdc_cfg_en)
 					set_scdc_cfg(1, 1);
 				ddc_state_err_cnt = 0;
-				rx.state = FSM_HDMI5V_LOW;
-				rx_print("DDC ERROR->HPD_LOW\n");
+				rx.state = FSM_HPD_LOW;
+				rx_pr("DDC ERROR->HPD_LOW\n");
 				break;
 			}
 	    } else {
 			ddc_state_err_cnt = 0;
 			rx.state = FSM_SIG_READY;
-			#ifdef HDCP22_ENABLE
-				if (hdcp_22_on)
-					video_stable_to_esm = 1;
-			#endif
+			/* #ifdef HDCP22_ENABLE
+				if (hdcp22_on)
+					esm_set_stable(1);
+			#endif */
 			pll_stable_protect_cnt = pll_stable_protect_max;
 			stable_protect_cnt = stable_protect_max;
-			rx_print("DDCERROR->READY\n");
+			rx_pr("DDCERROR->READY\n");
 			break;
 	    }
 		break;
@@ -2866,32 +3078,32 @@ void hdmirx_hw_monitor(void)
 			rx.change = 1;
 			if ((sig_lost_lock_cnt++ >= sig_lost_lock_max) &&
 				(pll_stable_protect_cnt == 0)) {
-				rx.state = FSM_HPD_READY;
+				rx.state = FSM_WAIT_CLK_STABLE;
 				rx.pre_state = FSM_SIG_READY;
 				audio_sample_rate = 0;
 
 				hdmirx_set_video_mute(1);
 				rx_aud_pll_ctl(0);
 				hdmirx_audio_enable(0);
-				#ifdef HDCP22_ENABLE
-				if (hdcp_22_on)
+				/* #ifdef HDCP22_ENABLE
+				if (hdcp22_on)
 					video_stable_to_esm = 0;
-				#endif
+				#endif */
 				sig_lost_lock_cnt = 0;
 				unstable_protect_cnt = 0;
-				wait_no_signal_cnt = 0;
+				wait_no_sig_cnt = 0;
 				rx.aud_sr_stable_cnt = 0;
-				rx_print("PLL_UNLOCK->HPD_READY:%d\n",
+				rx_pr("PLL_UNLOCK->HPD_READY:%d\n",
 					    hdmirx_tmds_pll_lock());
 				break;
 		    } else {
 			    if (log_flag & VIDEO_LOG)
-					rx_print("FSM_SIG_READY lock_cnt :%d\n",
+					rx_pr("FSM_SIG_READY lock_cnt :%d\n",
 							sig_lost_lock_cnt);
 		    }
 		} else {
 			if (sig_lost_lock_cnt)
-				rx_print("sig_lost_lock_cnt = %d",
+				rx_pr("sig_lost_lock_cnt = %d",
 							 sig_lost_lock_cnt);
 		    sig_lost_lock_cnt = 0;
 			if (pll_stable_protect_cnt == 0)
@@ -2922,27 +3134,27 @@ void hdmirx_hw_monitor(void)
 				rx_aud_pll_ctl(0);
 				hdmirx_audio_enable(0);
 				/* hdmirx_audio_fifo_rst(); */
-				rx.state = FSM_HPD_READY;
+				rx.state = FSM_WAIT_CLK_STABLE;
 				rx.pre_state = FSM_SIG_READY;
-				wait_no_signal_cnt = 0;
+				wait_no_sig_cnt = 0;
 				rx.aud_sr_stable_cnt = 0;
-				#ifdef HDCP22_ENABLE
-				if (hdcp_22_on)
+				/* #ifdef HDCP22_ENABLE
+				if (hdcp22_on)
 					video_stable_to_esm = 0;
-				#endif
+				#endif */
 				memcpy(&rx.pre_params,
 					&rx.cur_params,
 					sizeof(struct hdmi_rx_ctrl_video));
 				memset(&rx.vendor_specific_info,
 					0,
 					sizeof(struct vendor_specific_info_s));
-				rx_print("READY->HPD_READY\n");
+				rx_pr("READY->HPD_READY\n");
 				break;
 			}
 	    } else {
 			if (sig_unready_cnt != 0) {
 				if (log_flag & VIDEO_LOG)
-					rx_print("sig_unready_cnt=%d",
+					rx_pr("sig_unready_cnt=%d",
 						sig_unready_cnt);
 				sig_unready_cnt = 0;
 			}
@@ -2957,7 +3169,7 @@ void hdmirx_hw_monitor(void)
 			if (enable_hpd_reset)
 				sig_unstable_reset_hpd_cnt = 0;
 			/* #ifdef HDCP22_ENABLE */
-			/*	if (hdcp_22_on) */
+			/*	if (hdcp22_on) */
 			/*		video_stable_to_esm = 1; */
 			/*	#endif */
 		}
@@ -3011,11 +3223,9 @@ void hdmirx_hw_monitor(void)
 					rx.aud_info.coding_type;
 				audio_channel_count =
 					rx.aud_info.channel_count;
-				auds_rcv_sts =
-					rx.aud_info.aud_packet_received;
 
 				if (hdmirx_get_audio_clock() < 100000) {
-					rx_print("update audio\n");
+					rx_pr("update audio\n");
 					tmp = hdmirx_rd_top(TOP_ACR_CNTL_STAT);
 					hdmirx_wr_top(TOP_ACR_CNTL_STAT,
 							tmp | (1<<11));
@@ -3024,7 +3234,8 @@ void hdmirx_hw_monitor(void)
 		} else {
 
 		}
-
+		auds_rcv_sts =
+			rx.aud_info.aud_packet_received;
 		break;
 	default:
 		break;
@@ -3045,7 +3256,7 @@ int rx_get_edid_index(void)
 		edid_buf[1] == 'D' &&
 		edid_buf[2] == 'I' &&
 		edid_buf[3] == 'D') {
-		rx_print("edid: use Top edid\n");
+		rx_pr("edid: use Top edid\n");
 		return EDID_LIST_BUFF;
 	} else {
 		if (edid_mode == 0)
@@ -3113,10 +3324,10 @@ bool rx_poll_dwc(uint16_t addr, uint32_t exp_data,
 			rd_data = hdmirx_rd_dwc(addr);
 		}
 	}
-	rx_print("poll dwc cnt :%d\n", cnt);
+	rx_pr("poll dwc cnt :%d\n", cnt);
 	if (done == 0) {
 		/* if(log_flag & ERR_LOG) */
-		rx_print("poll dwc%x time-out!\n", addr);
+		rx_pr("poll dwc%x time-out!\n", addr);
 		return false;
 	}
 	return true;
@@ -3126,7 +3337,7 @@ bool rx_set_repeat_aksv(unsigned char *data, int len, int depth,
 	bool dev_exceed, bool cascade_exceed)
 {
 	int i;
-	/*rx_print("set ksv list len:%d,depth:%d\n", len, depth);*/
+	/*rx_pr("set ksv list len:%d,depth:%d\n", len, depth);*/
 	if ((len == 0) || (data == 0) || (depth == 0))
 		return false;
 	/*set repeat depth*/
@@ -3168,7 +3379,7 @@ bool rx_set_repeat_aksv(unsigned char *data, int len, int depth,
 				*(data + i*MAX_KSV_SIZE + 4));
 			hdmirx_wr_dwc(DWC_HDCP_RPT_KSVFIFO0,
 				*((uint32_t *)(data + i*MAX_KSV_SIZE)));
-			rx_print(
+			rx_pr(
 			"[RX]write ksv list index:%d, ksv hi:%#x, low:%#x\n",
 				i, *(data + i*MAX_KSV_SIZE +
 			4), *((uint32_t *)(data + i*MAX_KSV_SIZE)));
@@ -3183,7 +3394,7 @@ bool rx_set_repeat_aksv(unsigned char *data, int len, int depth,
 					(rx.hdcp.count > 0));
 	/* Wait for HW completion of V value*/
 	rx_poll_dwc(DWC_HDCP_RPT_CTRL, FIFO_READY, FIFO_READY, KSV_V_WR_TH);
-	rx_print("[RX]write Ready signal!\n");
+	rx_pr("[RX]write Ready signal!\n");
 
 	return true;
 }
@@ -3199,7 +3410,7 @@ bool rx_set_receive_hdcp(unsigned char *data, int len, int depth,
 {
 	if ((data != 0) && (len != 0) && (len <= MAX_REPEAT_COUNT))
 		memcpy(receive_hdcp, data, len*MAX_KSV_SIZE);
-	rx_print("receive ksv list len:%d,depth:%d,cas:%d,dev:%d\n", len,
+	rx_pr("receive ksv list len:%d,depth:%d,cas:%d,dev:%d\n", len,
 	depth, cas_exceed, devs_exceed);
 	hdcp_len = len;
 	hdcp_repeat_depth = depth;
@@ -3232,7 +3443,7 @@ EXPORT_SYMBOL(rx_edid_physical_addr);
 void rx_send_hpd_pulse(void)
 {
 	hdmirx_set_hpd(rx.port, 0);
-	rx.state = FSM_HDMI5V_HIGH;
+	rx.state = FSM_HPD_HIGH;
 }
 
 void rx_start_repeater_auth(void)
@@ -3273,7 +3484,7 @@ void rx_check_repeat(void)
 	if (repeat_plug) {
 		switch (rx.hdcp.state) {
 		case REPEATER_STATE_START:
-			rx_print("[RX] receive aksv\n");
+			rx_pr("[RX] receive aksv\n");
 			hdmirx_wr_bits_dwc(DWC_HDCP_RPT_CTRL,
 						KSVLIST_TIMEOUT, 0);
 			hdmirx_wr_bits_dwc(DWC_HDCP_RPT_CTRL,
@@ -3284,21 +3495,21 @@ void rx_check_repeat(void)
 		break;
 
 		case REPEATER_STATE_WAIT_KSV:
-		if (!rx.current_port_tx_5v_status) {
+		if (!rx.cur_5v_sts) {
 			rx.hdcp.state = REPEATER_STATE_IDLE;
 			break;
 		}
 		if (hdmirx_rd_bits_dwc(DWC_HDCP_RPT_CTRL, WAITING_KSV)) {
 			rx.hdcp.delay++;
 			if (rx.hdcp.delay == 1)
-				rx_print("[RX] receive ksv wait signal\n");
+				rx_pr("[RX] receive ksv wait signal\n");
 			if (rx.hdcp.delay < KSV_LIST_WR_MAX) {
 				break;
 			} else if (rx.hdcp.delay >= KSV_LIST_WAIT_DELAY) {
 				hdmirx_wr_bits_dwc(DWC_HDCP_RPT_CTRL,
 						KSVLIST_TIMEOUT, 1);
 				rx.hdcp.state = REPEATER_STATE_IDLE;
-				rx_print("[RX] receive ksv wait timeout\n");
+				rx_pr("[RX] receive ksv wait timeout\n");
 			}
 			if (rx_set_repeat_aksv(receive_hdcp, hdcp_len,
 				hdcp_repeat_depth, rx.hdcp.dev_exceed,
@@ -3358,7 +3569,7 @@ int rx_get_ceadata_offset(uint8_t *cur_edid, uint8_t *addition)
 		else
 			i += (1 + (*(cur_edid + i) & 0x1f));
 	}
-	rx_print("type: %#x, start addr: %#x\n", type, i);
+	rx_pr("type: %#x, start addr: %#x\n", type, i);
 
 	return 0;
 }
@@ -3380,7 +3591,7 @@ ori_len = (*cur_data & 0x1f)/FORMAT_SIZE;
 add_len = (*addition & 0x1f)/FORMAT_SIZE;
 
 for (i = 0; i < add_len; i++) {
-	rx_print("mix audio format:%d\n", add_data[i].format_code);
+	rx_pr("mix audio format:%d\n", add_data[i].format_code);
 	/*only support lpcm dts dd+*/
 	if (!is_audio_support(add_data[i].format_code))
 		continue;
@@ -3388,7 +3599,7 @@ for (i = 0; i < add_len; i++) {
 	for (j = 0; j < ori_len; j++) {
 		if (ori_data[j].format_code ==
 					add_data[i].format_code) {
-			rx_print("mix audio mix format:%d\n",
+			rx_pr("mix audio mix format:%d\n",
 					add_data[i].format_code);
 			/*choose channel is lager*/
 			ori_data[j].max_channel =
@@ -3411,7 +3622,7 @@ for (i = 0; i < add_len; i++) {
 				add_data[i].bit_rate.others;
 		} else {
 			if (j == (ori_len - 1)) {
-				rx_print("mix audio add new format: %d\n",
+				rx_pr("mix audio add new format: %d\n",
 					add_data[i].format_code);
 				if (((*cur_data & 0x1f) + FORMAT_SIZE)
 							 <= 0x1f) {
@@ -3453,7 +3664,7 @@ void rx_mix_block(uint8_t *cur_data, uint8_t *addition)
 		(*cur_data >> 5) != (*addition >> 5))
 		return;
 
-	rx_print("before type:%d - %d,len:%d - %d\n",
+	rx_pr("before type:%d - %d,len:%d - %d\n",
 	(*cur_data >> 5), (*addition >> 5),
 	(*cur_data & 0x1f), (*addition & 0x1f));
 
@@ -3469,7 +3680,7 @@ void rx_mix_block(uint8_t *cur_data, uint8_t *addition)
 		break;
 	}
 
-	rx_print("end type:%d - %d,len:%d - %d\n",
+	rx_pr("end type:%d - %d,len:%d - %d\n",
 	(*cur_data >> 5), (*addition >> 5),
 	(*cur_data & 0x1f), (*addition & 0x1f));
 }
@@ -3503,13 +3714,13 @@ void rx_modify_edid(unsigned char *buffer,
 			addition_size = (*cur_data & 0x1f) + 1;
 		} else
 			return;
-		rx_print("start_addr: %#x,cur_size: %d,addition_size: %d\n",
+		rx_pr("start_addr: %#x,cur_size: %d,addition_size: %d\n",
 			start_addr, cur_size, addition_size);
 
 		/*set the block value to edid_temp*/
 		start_addr_temp = rx_get_ceadata_offset(buffer, addition);
 		temp_len = ((buffer[start_addr_temp] & 0x1f) + 1);
-		rx_print("edid_temp start: %#x, len: %d\n", start_addr_temp,
+		rx_pr("edid_temp start: %#x, len: %d\n", start_addr_temp,
 							temp_len);
 		/*move data behind current data if need*/
 		if (temp_len < addition_size) {
@@ -3542,14 +3753,14 @@ void rx_modify_edid(unsigned char *buffer,
 unsigned int rx_exchange_bits(unsigned int value)
 {
 	unsigned int temp;
-	rx_print("bfe:%#x\n", value);
+	rx_pr("bfe:%#x\n", value);
 	temp = value & 0xF;
 	value = (((value >> 4) & 0xF) | (value & 0xFFF0));
 	value = ((value & 0xFF0F) | (temp << 4));
 	temp = value & 0xF00;
 	value = (((value >> 4) & 0xF00) | (value & 0xF0FF));
 	value = ((value & 0x0FFF) | (temp << 4));
-	rx_print("aft:%#x\n", value);
+	rx_pr("aft:%#x\n", value);
 	return value;
 }
 
@@ -3727,6 +3938,8 @@ int hdmi_rx_ctrl_edid_update(void)
 		hdmi_rx_load_edid_data_repeater(edid_temp, real_port_map);
 	} else
 		hdmi_rx_load_edid_data(edid_temp, real_port_map);
+
+	rx_pr("edid update\n");
 	return true;
 }
 
@@ -3751,23 +3964,23 @@ static void set_hdcp(struct hdmi_rx_ctrl_hdcp *hdcp, const unsigned char *b_key)
 int hdmirx_read_key_buf(char *buf, int max_size)
 {
 	if (key_size > max_size) {
-		rx_print("Error: %s,key size %d",
+		rx_pr("Error: %s,key size %d",
 				__func__, key_size);
-		rx_print("is larger than the buf size of %d\n", max_size);
+		rx_pr("is larger than the buf size of %d\n", max_size);
 		return 0;
 	}
 	memcpy(buf, key_buf, key_size);
-	rx_print("HDMIRX: read key buf\n");
+	rx_pr("HDMIRX: read key buf\n");
 	return key_size;
 }
 
 void hdmirx_fill_key_buf(const char *buf, int size)
 {
 	if (size > MAX_KEY_BUF_SIZE) {
-		rx_print("Error: %s,key size %d",
+		rx_pr("Error: %s,key size %d",
 				__func__,
 				size);
-		rx_print("is larger than the max size of %d\n",
+		rx_pr("is larger than the max size of %d\n",
 			MAX_KEY_BUF_SIZE);
 		return;
 	}
@@ -3776,38 +3989,40 @@ void hdmirx_fill_key_buf(const char *buf, int size)
 	} else {
 		memcpy(key_buf, buf, size);
 		key_size = size;
-		rx_print("HDMIRX: fill key buf, size %d\n", size);
+		rx_pr("HDMIRX: fill key buf, size %d\n", size);
 	}
 }
 
 int hdmirx_read_edid_buf(char *buf, int max_size)
 {
 	if (edid_size > max_size) {
-		rx_print("Error: %s,edid size %d",
+		rx_pr("Error: %s,edid size %d",
 				__func__,
 				edid_size);
-		rx_print(" is larger than the buf size of %d\n",
+		rx_pr(" is larger than the buf size of %d\n",
 			max_size);
 		return 0;
 	}
 	memcpy(buf, edid_buf, edid_size);
-	rx_print("HDMIRX: read edid buf\n");
+	rx_pr("HDMIRX: read edid buf\n");
 	return edid_size;
 }
 
 void hdmirx_fill_edid_buf(const char *buf, int size)
 {
 	if (size > MAX_EDID_BUF_SIZE) {
-		rx_print("Error: %s,edid size %d",
+		rx_pr("Error: %s,edid size %d",
 				__func__,
 				size);
-		rx_print(" is larger than the max size of %d\n",
+		rx_pr(" is larger than the max size of %d\n",
 			MAX_EDID_BUF_SIZE);
 		return;
 	}
 	memcpy(edid_buf, buf, size);
+	edid_update_flag = true;
+
 	edid_size = size;
-	rx_print("HDMIRX: fill edid buf, size %d\n",
+	rx_pr("HDMIRX: fill edid buf, size %d\n",
 		size);
 }
 
@@ -3825,61 +4040,61 @@ static void dump_state(unsigned char enable)
 	/* int i = 0; */
 	struct hdmi_rx_ctrl_video v;
 	static struct aud_info_s a;
+	memset(&v, 0, sizeof(struct hdmi_rx_ctrl_video));
 
+	hdmirx_get_video_info(&rx.ctrl, &v);
 	if (enable & 1) {
-		hdmirx_get_video_info(&rx.ctrl, &v);
-		rx_print("[HDMI info]error %d", error);
-		rx_print("video_format %d,", v.video_format);
-		rx_print("VIC %d dvi %d", v.video_mode, v.dvi);
-		rx_print("interlace %d\n", v.interlaced);
-		rx_print(" htotal %d", v.htotal);
-		rx_print(" hactive %d", v.hactive);
-		rx_print(" vtotal %d", v.vtotal);
-		rx_print(" vactive %d", v.vactive);
-		rx_print(" repetition %d\n", v.repeat);
-
-		rx_print(" deep_color %d", v.deep_color_mode);
-		rx_print(" refresh_rate %d\n", v.refresh_rate);
-
+		rx_pr("[HDMI info]error %d", error);
+		rx_pr("video_format %d,", v.video_format);
+		rx_pr("VIC %d dvi %d", v.video_mode, v.dvi);
+		rx_pr("interlace %d\n", v.interlaced);
+		rx_pr(" htotal %d", v.htotal);
+		rx_pr(" hactive %d", v.hactive);
+		rx_pr(" vtotal %d", v.vtotal);
+		rx_pr(" vactive %d", v.vactive);
+		rx_pr(" repetition %d\n", v.repeat);
+
+		rx_pr(" deep_color %d", v.deep_color_mode);
+		rx_pr(" refresh_rate %d\n", v.refresh_rate);
 	}
 	if (enable & 2) {
 		hdmirx_read_audio_info(&a);
-		rx_print("AudioInfo:");
-		rx_print(" CT=%u CC=%u",
+		rx_pr("AudioInfo:");
+		rx_pr(" CT=%u CC=%u",
 				a.coding_type,
 				a.channel_count);
-		rx_print(" SF=%u SS=%u",
+		rx_pr(" SF=%u SS=%u",
 				a.sample_frequency,
 				a.sample_size);
-		rx_print(" CA=%u",
+		rx_pr(" CA=%u",
 			a.channel_allocation);
 
-		rx_print(" CTS=%d, N=%d,",
+		rx_pr(" CTS=%d, N=%d,",
 				a.cts, a.n);
-		rx_print("recovery clock is %d\n",
+		rx_pr("recovery clock is %d\n",
 			a.arc);
 	}
-	rx_print("TMDS clock = %d,",
+	rx_pr("TMDS clock = %d,",
 			hdmirx_get_tmds_clock());
-	rx_print("Pixel clock = %d\n",
+	rx_pr("Pixel clock = %d\n",
 		hdmirx_get_pixel_clock());
 
-	rx_print("rx.no_signal=%d,rx.state=%d,",
+	rx_pr("rx.no_signal=%d,rx.state=%d,",
 			rx.no_signal,
 			rx.state);
-	rx_print("skip frame=%d\n", rx.change);
-	rx_print("fmt=0x%x,sw_vic:%d,",
+	rx_pr("skip frame=%d\n", rx.change);
+	rx_pr("fmt=0x%x,sw_vic:%d,",
 			hdmirx_hw_get_fmt(),
 			rx.pre_params.sw_vic);
-	rx_print("sw_dvi:%d,sw_fp:%d,",
+	rx_pr("sw_dvi:%d,sw_fp:%d,",
 			rx.pre_params.sw_dvi,
 			rx.pre_params.sw_fp);
-	rx_print("sw_alternative:%d\n",
+	rx_pr("sw_alternative:%d\n",
 		rx.pre_params.sw_alternative);
 
-	rx_print("HDCP debug value=0x%x\n",
+	rx_pr("HDCP debug value=0x%x\n",
 		hdmirx_rd_dwc(DWC_HDCP_DBG));
-	rx_print("HDCP encrypted state:%d\n",
+	rx_pr("HDCP encrypted state:%d\n",
 		v.hdcp_enc_state);
 }
 
@@ -3889,17 +4104,17 @@ static void dump_audio_info(unsigned char enable)
 
 	if (enable) {
 		hdmirx_read_audio_info(&a);
-		rx_print("AudioInfo: CT=%u",
+		rx_pr("AudioInfo: CT=%u",
 				a.coding_type);
-		rx_print(" CC=%u SF=%u SS=%u CA=%u",
+		rx_pr(" CC=%u SF=%u SS=%u CA=%u",
 			a.channel_count,
 			a.sample_frequency,
 			a.sample_size,
 			a.channel_allocation);
-		rx_print(" [hdmirx]CTS=%d, N=%d,",
+		rx_pr(" [hdmirx]CTS=%d, N=%d,",
 				a.cts,
 				a.n);
-		rx_print("recovery clock is %d\n",
+		rx_pr("recovery clock is %d\n",
 			a.arc);
 	}
 }
@@ -3944,53 +4159,53 @@ void print_reg(uint start_addr, uint end_addr)
 
 	for (i = start_addr; i <= end_addr; i += sizeof(uint)) {
 		if ((i - start_addr) % (sizeof(uint)*4) == 0)
-			rx_print("[0x%-4x] ", i);
+			rx_pr("[0x%-4x] ", i);
 		if (is_reg_can_read(i))
-			rx_print("0x%-8x,", hdmirx_rd_dwc(i));
+			rx_pr("0x%-8x,", hdmirx_rd_dwc(i));
 		else
-			rx_print("xxxxxx    ,");
+			rx_pr("xxxxxx    ,");
 
 		if ((i - start_addr) % (sizeof(uint)*4) == sizeof(uint)*3)
-			rx_print("\n");
+			rx_pr("\n");
 	}
 
 	if ((end_addr - start_addr + sizeof(uint)) % (sizeof(uint)*4) != 0)
-		rx_print("\n");
+		rx_pr("\n");
 }
 
 void dump_reg(void)
 {
 	int i = 0;
 
-	rx_print("\n***Top registers***\n");
-	rx_print("[addr ]  addr + 0x0,");
-	rx_print("addr + 0x1,  addr + 0x2,	addr + 0x3\n");
+	rx_pr("\n***Top registers***\n");
+	rx_pr("[addr ]  addr + 0x0,");
+	rx_pr("addr + 0x1,  addr + 0x2,	addr + 0x3\n");
 	for (i = 0; i <= 0x24;) {
-		rx_print("[0x%-3x]", i);
-		rx_print("0x%-8x" , hdmirx_rd_top(i));
-		rx_print("0x%-8x,0x%-8x,0x%-8x\n",
+		rx_pr("[0x%-3x]", i);
+		rx_pr("0x%-8x" , hdmirx_rd_top(i));
+		rx_pr("0x%-8x,0x%-8x,0x%-8x\n",
 			hdmirx_rd_top(i + 1),
 			hdmirx_rd_top(i + 2),
 			hdmirx_rd_top(i + 3));
 		i = i + 4;
 	}
-	rx_print("\n***PHY registers***\n");
-	rx_print("[addr ]  addr + 0x0,");
-	rx_print("addr + 0x1,addr + 0x2,");
-	rx_print("addr + 0x3\n");
+	rx_pr("\n***PHY registers***\n");
+	rx_pr("[addr ]  addr + 0x0,");
+	rx_pr("addr + 0x1,addr + 0x2,");
+	rx_pr("addr + 0x3\n");
 	for (i = 0; i <= 0x9a;) {
-		rx_print("[0x%-3x]", i);
-		rx_print("0x%-8x", hdmirx_rd_phy(i));
-		rx_print("0x%-8x,0x%-8x,0x%-8x\n",
+		rx_pr("[0x%-3x]", i);
+		rx_pr("0x%-8x", hdmirx_rd_phy(i));
+		rx_pr("0x%-8x,0x%-8x,0x%-8x\n",
 			hdmirx_rd_phy(i + 1),
 			hdmirx_rd_phy(i + 2),
 			hdmirx_rd_phy(i + 3));
 		i = i + 4;
 	}
-	rx_print("\n**Controller registers**\n");
-	rx_print("[addr ]  addr + 0x0,");
-	rx_print("addr + 0x4,  addr + 0x8,");
-	rx_print("addr + 0xc\n");
+	rx_pr("\n**Controller registers**\n");
+	rx_pr("[addr ]  addr + 0x0,");
+	rx_pr("addr + 0x4,  addr + 0x8,");
+	rx_pr("addr + 0xc\n");
 	print_reg(0, 0xfc);
 	print_reg(0x140, 0x3ac);
 	print_reg(0x3c0, 0x418);
@@ -4014,37 +4229,37 @@ void dump_reg(void)
 
 void dump_hdcp_data(void)
 {
-	rx_print("\n*************HDCP");
-	rx_print("***************");
-	rx_print("\n hdcp-seed = %d ",
+	rx_pr("\n*************HDCP");
+	rx_pr("***************");
+	rx_pr("\n hdcp-seed = %d ",
 		rx.hdcp.seed);
 	/* KSV CONFIDENTIAL */
-	rx_print("\n hdcp-ksv = %x---%x",
+	rx_pr("\n hdcp-ksv = %x---%x",
 		rx.hdcp.bksv[0],
 		rx.hdcp.bksv[1]);
-	rx_print("\n*************HDCP");
+	rx_pr("\n*************HDCP");
 }
 
 void dump_edid_reg(void)
 {
 	int i = 0;
 	int j = 0;
-	rx_print("\n***********************\n");
-	rx_print("0x107 enable rgb range block\n");
-	rx_print("0x106 skyworth mst_or_mtk edid\n");
-	rx_print("0x105 mst sharp porduction edid\n");
-	rx_print("0x104 mst ATSC production edid\n");
-	rx_print("0x103 aml old edid, 4k*2k unsupported\n");
-	rx_print("********************************\n");
+	rx_pr("\n***********************\n");
+	rx_pr("0x107 enable rgb range block\n");
+	rx_pr("0x106 skyworth mst_or_mtk edid\n");
+	rx_pr("0x105 mst sharp porduction edid\n");
+	rx_pr("0x104 mst ATSC production edid\n");
+	rx_pr("0x103 aml old edid, 4k*2k unsupported\n");
+	rx_pr("********************************\n");
 	/* 1024 = 64*16 */
 	for (i = 0; i < 16; i++) {
-		rx_print("[%2d] ", i);
+		rx_pr("[%2d] ", i);
 		for (j = 0; j < 16; j++) {
-			rx_print("0x%02lx, ",
+			rx_pr("0x%02lx, ",
 			       hdmirx_rd_top(TOP_EDID_OFFSET +
 					     (i * 16 + j)));
 		}
-		rx_print("\n");
+		rx_pr("\n");
 	}
 }
 
@@ -4052,17 +4267,17 @@ void dump_hdr_reg(void)
 {
 	int i = 0;
 
-	rx_print("\n********** hdr *************\n");
+	rx_pr("\n********** hdr *************\n");
 
 	for (i = 0; i < sizeof(rx.hdr_data)/4; i++)
-		rx_print("playload[%d]: %#x\n", i ,
+		rx_pr("playload[%d]: %#x\n", i ,
 		*((unsigned int *)&(rx.hdr_data) + i));
-	rx_print("\n********** hdr end*************\n");
+	rx_pr("\n********** hdr end*************\n");
 }
 
 void timer_state(void)
 {
-	rx_print("timer state:%d\n",
+	rx_pr("timer state:%d\n",
 		rx.state);
 }
 
@@ -4083,31 +4298,31 @@ int hdmirx_debug(const char *buf, int size)
 		hdmirx_set_hpd(rx.port, tmpbuf[3] == '0' ? 0 : 1);
 	else if (strncmp(tmpbuf, "cable_status", 12) == 0) {
 		size = hdmirx_rd_top(TOP_HPD_PWR5V) >> 20;
-		rx_print("cable_status = %x\n", size);
+		rx_pr("cable_status = %x\n", size);
 	} else if (strncmp(tmpbuf, "signal_status", 13) == 0) {
 		size = rx.no_signal;
-		rx_print("signal_status = %d\n", size);
+		rx_pr("signal_status = %d\n", size);
 	} else if (strncmp(tmpbuf, "input_mode", 10) == 0) {
 		size = rx.pre_params.sw_vic;
-		rx_print("input_mode = %d", size);
+		rx_pr("input_mode = %d", size);
 	} else if (strncmp(tmpbuf, "reset", 5) == 0) {
 		if (tmpbuf[5] == '0') {
-			rx_print(" hdmirx hw config\n");
+			rx_pr(" hdmirx hw config\n");
 			hdmirx_hw_config();
 			/* hdmi_rx_ctrl_edid_update(); */
 			/* hdmirx_config_video(&rx.video_params); */
 			/* hdmirx_config_audio(); */
 		} else if (tmpbuf[5] == '1') {
-			rx_print(" hdmirx phy init 8bit\n");
+			rx_pr(" hdmirx phy init 8bit\n");
 			hdmirx_phy_init(rx.port, 0);
 		} else if (tmpbuf[5] == '4') {
-			rx_print(" edid update\n");
+			rx_pr(" edid update\n");
 			hdmi_rx_ctrl_edid_update();
 		} else if (tmpbuf[5] == '2') {
-			rx_print(" hdmirx phy init 10bit\n");
+			rx_pr(" hdmirx phy init 10bit\n");
 			hdmirx_phy_init(rx.port, 1);
 		} else if (tmpbuf[5] == '3') {
-			rx_print(" hdmirx phy init 12bit\n");
+			rx_pr(" hdmirx phy init 12bit\n");
 			hdmirx_phy_init(rx.port, 2);
 		} else if (tmpbuf[5] == '5') {
 			#ifdef HDCP22_ENABLE
@@ -4115,41 +4330,41 @@ int hdmirx_debug(const char *buf, int size)
 			#endif
 		} else if (strncmp(tmpbuf + 5, "_on", 3) == 0) {
 			reset_sw = 1;
-			rx_print("reset on!\n");
+			rx_pr("reset on!\n");
 		} else if (strncmp(tmpbuf + 5, "_off", 4) == 0) {
 			reset_sw = 0;
-			rx_print(" reset off!\n");
+			rx_pr(" reset off!\n");
 		}
 	} else if (strncmp(tmpbuf, "state", 5) == 0) {
 		dump_state(0xff);
 	} else if (strncmp(tmpbuf, "hdcp14", 6) == 0) {
 		hdmirx_set_hpd(rx.port, 0);
 		force_hdcp14_en = 1;
-		hdcp_22_on = 0;
+		hdcp22_on = 0;
 		hdmirx_wr_dwc(DWC_HDCP22_CONTROL, 0x2);
 		video_stable_to_esm = 0;
-		rx.state = FSM_HDMI5V_HIGH;
-		rx.pre_state = FSM_HDMI5V_HIGH;
-		rx_print("force hdcp1.4\n");
+		rx.state = FSM_HPD_HIGH;
+		rx.pre_state = FSM_HPD_HIGH;
+		rx_pr("force hdcp1.4\n");
 	} else if (strncmp(tmpbuf, "hdcpauto", 8) == 0) {
 		hdmirx_set_hpd(rx.port, 0);
-		hdcp_22_on = 1;
+		hdcp22_on = 1;
 		force_hdcp14_en = 0;
 		hdmirx_hw_config();
 		hpd_to_esm = 1;
-		rx.state = FSM_HDMI5V_HIGH;
-		rx.pre_state = FSM_HDMI5V_HIGH;
-		rx_print("hdcp22 auto\n");
+		rx.state = FSM_HPD_HIGH;
+		rx.pre_state = FSM_HPD_HIGH;
+		rx_pr("hdcp22 auto\n");
 	} else if (strncmp(tmpbuf, "pause", 5) == 0) {
 		if (kstrtol(tmpbuf + 5, 10, &value) < 0)
 			return -EINVAL;
-		rx_print("%s the state machine\n",
+		rx_pr("%s the state machine\n",
 			value ? "pause" : "enable");
 		sm_pause = value;
 	} else if (strncmp(tmpbuf, "reg", 3) == 0) {
 		dump_reg();
 	}  else if (strncmp(tmpbuf, "duk", 3) == 0) {
-		rx_sec_set_duk();
+		rx_pr("hdcp22=%d\n", rx_sec_set_duk());
 	} else if (strncmp(tmpbuf, "edid", 4) == 0) {
 		dump_edid_reg();
 	} else if (strncmp(tmpbuf, "hdr", 3) == 0) {
@@ -4160,16 +4375,14 @@ int hdmirx_debug(const char *buf, int size)
 		#ifdef HDCP22_ENABLE
 		hdmirx_wr_dwc(DWC_HDCP22_CONTROL,
 		hdmirx_rd_dwc(DWC_HDCP22_CONTROL) | (1<<12));
-		rx_print("set esm hpd\n");
+		rx_pr("set esm hpd\n");
 		#endif
 	} else if (strncmp(tmpbuf, "esmclk", 6) == 0) {
-		#ifdef HDCP22_ENABLE
-		hdmirx_wr_top(TOP_CLK_CNTL,
-		hdmirx_rd_top(TOP_CLK_CNTL) | (7<<3));
-		rx_print("set esm hpd\n");
-		#endif
+		hdmirx_hdcp22_init();
+		hdcp22_on = 1;
+		rx_pr("clk & 22 on\n");
 	} else if (strncmp(tmpbuf, "loadkey", 7) == 0) {
-		rx_print("load hdcp key\n");
+		rx_pr("load hdcp key\n");
 		memcpy(&rx.hdcp, &init_hdcp_data,
 		       sizeof(struct hdmi_rx_ctrl_hdcp));
 		hdmirx_hw_config();
@@ -4178,20 +4391,21 @@ int hdmirx_debug(const char *buf, int size)
 		timer_state();
 	} else if (strncmp(tmpbuf, "load22key", 9) == 0) {
 		if (enable_hdcp22_loadkey) {
-			rx_print("load 2.2 key-a\n");
+			rx_pr("load 2.2 key-a\n");
 			ret = rx_sec_set_duk();
-			rx_print("ret = %d\n", ret);
+			rx_pr("ret = %d\n", ret);
 			if (ret == 1) {
 				if ((hdmirx_rd_dwc(0xf68) & _BIT(3)) == 0) {
-					rx_print("load-1\n");
+					rx_pr("load-1\n");
 					sm_pause = 1;
 					hdmirx_set_hpd(rx.port, 0);
-					hdcp_22_on = 1;
+					hdcp22_on = 1;
 					hdcp22_kill_esm = 1;
 					mdelay(wait_hdcp22_cnt1);
 					hdcp22_kill_esm = 0;
 					mdelay(wait_hdcp22_cnt2);
-					hpd_to_esm = 0;
+					switch_set_state(&rx.hpd_sdev, 0x00);
+					hpd_to_esm = 1;
 					do_esm_rst_flag = 1;
 					hdmirx_wr_dwc(DWC_HDCP22_CONTROL, 0x0);
 					hdmirx_hdcp22_esm_rst();
@@ -4200,22 +4414,24 @@ int hdmirx_debug(const char *buf, int size)
 								0x1000);
 					hdcp22_wr_top(TOP_SKP_CNTL_STAT, 0x1);
 					hdmirx_hw_config();
-					hpd_to_esm = 1;
+					hdmirx_hdcp22_init();
+					switch_set_state(&rx.hpd_sdev, 0x01);
 					mdelay(wait_hdcp22_cnt);
 					hdmirx_set_hpd(rx.port, 1);
 					/* rx.state = FSM_HDMI5V_HIGH; */
 					/* pre_port = 0xee; */
 					sm_pause = 0;
 				} else {
-					rx_print("load-2\n");
+					rx_pr("load-2\n");
 					sm_pause = 1;
 					hdmirx_set_hpd(rx.port, 0);
-					hdcp_22_on = 1;
+					hdcp22_on = 1;
 					hdcp22_kill_esm = 1;
 					mdelay(wait_hdcp22_cnt1);
 					hdcp22_kill_esm = 0;
 					mdelay(wait_hdcp22_cnt2);
-					hpd_to_esm = 0;
+					switch_set_state(&rx.hpd_sdev, 0x00);
+					hpd_to_esm = 1;
 					do_esm_rst_flag = 1;
 					hdmirx_wr_dwc(DWC_HDCP22_CONTROL, 0x0);
 					hdmirx_hdcp22_esm_rst();
@@ -4224,19 +4440,28 @@ int hdmirx_debug(const char *buf, int size)
 								0x1000);
 					hdcp22_wr_top(TOP_SKP_CNTL_STAT, 0x1);
 					hdmirx_hw_config();
-					hpd_to_esm = 1;
+					hdmirx_hdcp22_init();
+					switch_set_state(&rx.hpd_sdev, 0x01);
 					mdelay(wait_hdcp22_cnt3);
 					hdmirx_set_hpd(rx.port, 1);
 					sm_pause = 0;
 				}
 			} else
-				hdcp_22_on = 0;
+				hdcp22_on = 0;
 		} else
-			rx_print("load-2-no\n");
+			rx_pr("load-2-no\n");
+	} else if (strncmp(tmpbuf, "esm0", 4) == 0) {
+		switch_set_state(&rx.hpd_sdev, 0x0);
+	} else if (strncmp(tmpbuf, "esm1", 4) == 0) {
+		switch_set_state(&rx.hpd_sdev, 0x01);
+	} else if (strncmp(tmpbuf, "bist", 4) == 0) {
+		sm_pause = 1;
+		reset_sw = 0;
+		hdmirx_phy_bist_test(tmpbuf[4] == '0' ? 0 : 1);
 	} else if (strncmp(tmpbuf, "clock", 5) == 0) {
 		if (kstrtol(tmpbuf + 5, 10, &value) < 0)
 			return -EINVAL;
-		rx_print("clock[%d] = %d\n",
+		rx_pr("clock[%d] = %d\n",
 			value, hdmirx_get_clock(value));
 	} else if (strncmp(tmpbuf, "sample_rate", 11) == 0) {
 		/* nothing */
@@ -4245,39 +4470,39 @@ int hdmirx_debug(const char *buf, int size)
 	} else if (tmpbuf[0] == 'w') {
 		if (kstrtol(tmpbuf + 3, 16, &adr) < 0)
 				return -EINVAL;
-		rx_print("adr = %x\n", adr);
+		rx_pr("adr = %x\n", adr);
 		if (kstrtol(buf + i + 1, 16, &value) < 0)
 			return -EINVAL;
-		rx_print("value = %x\n", value);
+		rx_pr("value = %x\n", value);
 		if (tmpbuf[1] == 'h') {
 			if (buf[2] == 't') {
 				hdmirx_wr_top(adr, value);
-				rx_print("write %x to TOP [%x]\n",
+				rx_pr("write %x to TOP [%x]\n",
 					value, adr);
 			} else if (buf[2] == 'd') {
 				hdmirx_wr_dwc(adr, value);
-				rx_print("write %x to DWC [%x]\n",
+				rx_pr("write %x to DWC [%x]\n",
 					value, adr);
 			} else if (buf[2] == 'p') {
 				hdmirx_wr_phy(adr, value);
-				rx_print("write %x to PHY [%x]\n",
+				rx_pr("write %x to PHY [%x]\n",
 					value, adr);
 			#ifdef HDCP22_ENABLE
 			} else if (buf[2] == 'h') {
 				hdcp22_wr_top(adr, value);
 				/* hdcp22_wr(adr, value); */
-				rx_print("write %x to hdcp [%x]\n",
+				rx_pr("write %x to hdcp [%x]\n",
 					value, adr);
 			} else if (buf[2] == 'c') {
 				rx_hdcp22_wr_reg(adr, value);
 				/* hdcp22_wr(adr, value); */
-				rx_print("write %x to chdcp [%x]\n",
+				rx_pr("write %x to chdcp [%x]\n",
 					value, adr);
 			#endif
 			}
 		} else if (buf[1] == 'c') {
 			aml_write_cbus(adr, value);
-			rx_print("write %x to CBUS [%x]\n", value, adr);
+			rx_pr("write %x to CBUS [%x]\n", value, adr);
 		} else if (buf[1] == 'p') {
 			/* WRITE_APB_REG(adr, value); */
 		} else if (buf[1] == 'l') {
@@ -4295,45 +4520,48 @@ int hdmirx_debug(const char *buf, int size)
 				return -EINVAL;
 			if (tmpbuf[2] == 't') {
 				value = hdmirx_rd_top(adr);
-				rx_print("TOP [%x]=%x\n", adr, value);
+				rx_pr("TOP [%x]=%x\n", adr, value);
 			} else if (tmpbuf[2] == 'd') {
 				value = hdmirx_rd_dwc(adr);
-				rx_print("DWC [%x]=%x\n", adr, value);
+				rx_pr("DWC [%x]=%x\n", adr, value);
 			} else if (tmpbuf[2] == 'p') {
 				value = hdmirx_rd_phy(adr);
-				rx_print("PHY [%x]=%x\n", adr, value);
+				rx_pr("PHY [%x]=%x\n", adr, value);
 			#ifdef HDCP22_ENABLE
 			} else if (tmpbuf[2] == 'h') {
 				value = hdcp22_rd_top(adr);
 				/* value = hdcp22_rd(adr); */
-				rx_print("hdcp [%x]=%x\n", adr, value);
+				rx_pr("hdcp [%x]=%x\n", adr, value);
 			} else if (tmpbuf[2] == 'c') {
 				value = rx_hdcp22_rd_reg(adr);
 				/* value = hdcp22_rd(adr); */
-				rx_print("chdcp [%x]=%x\n", adr, value);
+				rx_pr("chdcp [%x]=%x\n", adr, value);
 			#endif
 			}
 		} else if (buf[1] == 'c') {
 			/* value = READ_MPEG_REG(adr); */
-			rx_print("CBUS reg[%x]=%x\n", adr, value);
+			rx_pr("CBUS reg[%x]=%x\n", adr, value);
 		} else if (buf[1] == 'p') {
 			/* value = READ_APB_REG(adr); */
-			rx_print("APB reg[%x]=%x\n", adr, value);
+			rx_pr("APB reg[%x]=%x\n", adr, value);
 		} else if (buf[1] == 'l') {
 			/* aml_write_cbus(MDB_CTRL, 2); */
 			/* aml_write_cbus(MDB_ADDR_REG, adr); */
 			/* value = READ_MPEG_REG(MDB_DATA_REG); */
-			rx_print("LMEM[%x]=%x\n", adr, value);
+			rx_pr("LMEM[%x]=%x\n", adr, value);
 		} else if (buf[1] == 'r') {
 			/* aml_write_cbus(MDB_CTRL, 1); */
 			/* aml_write_cbus(MDB_ADDR_REG, adr); */
 			/* value = READ_MPEG_REG(MDB_DATA_REG); */
-			rx_print("amrisc reg[%x]=%x\n", adr, value);
+			rx_pr("amrisc reg[%x]=%x\n", adr, value);
 		}
 	} else if (tmpbuf[0] == 'v') {
-		rx_print("------------------\n");
-		rx_print("Hdmirx version: %s\n", HDMIRX_VER);
-		rx_print("------------------\n");
+		rx_pr("------------------\n");
+		rx_pr("Hdmirx version: %s\n", RX_VER0);
+		rx_pr("Hdmirx version: %s\n", RX_VER1);
+		rx_pr("Hdmirx version: %s\n", RX_VER2);
+		rx_pr("Hdmirx version: %s\n", RX_VER3);
+		rx_pr("------------------\n");
 	}
 	return 0;
 }
@@ -4348,7 +4576,6 @@ void to_init_state(void)
 /***********************
     hdmirx_hw_init
     hdmirx_hw_uninit
-    hdmirx_hw_enable
     hdmirx_hw_disable
     hdmirx_irq_init
 *************************/
@@ -4389,34 +4616,27 @@ void hdmirx_hw_init(enum tvin_port_e port)
 	else
 		rx.hdcp.repeat = 0;
 	rx.port = (port_map >> ((port - TVIN_PORT_HDMI0) << 2)) & 0xf;
-	rx.portA_pow5v_state = pow5v_max_cnt;
-	rx.portB_pow5v_state = pow5v_max_cnt;
-	rx.portC_pow5v_state = pow5v_max_cnt;
-	rx.portD_pow5v_state = pow5v_max_cnt;
-	rx.portA_pow5v_state_pre = 0;
-	rx.portB_pow5v_state_pre = 0;
-	rx.portC_pow5v_state_pre = 0;
 	/* if (pre_port == 0xff)
 		hdmirx_wr_top(TOP_HPD_PWR5V, 0x1f & (~(1<<rx.port)));
 	*/
 	if (pre_port != rx.port) {
-		rx.state = FSM_HDMI5V_LOW;
+		rx.state = FSM_HPD_LOW;
 		hdmirx_set_hpd(rx.port, 0);
+		hdmirx_hw_config();
+		/* pre_port = rx.port; */
 		#ifdef HDCP22_ENABLE
-		if (hdcp_22_on) {
-			video_stable_to_esm = 0;
+		if (hdcp22_on) {
+			esm_set_stable(0);
 			hpd_to_esm = 1;
 			switch_set_state(&rx.hpd_sdev, 0x01);
 			if (log_flag & VIDEO_LOG)
-				rx_print("switch_set_state:%d\n", pwr_sts);
+				rx_pr("switch_set_state:%d\n", pwr_sts);
 		}
 		#endif
-		hdmirx_hw_config();
-		/* pre_port = rx.port; */
 	} else {
-		rx.state = FSM_SIG_STABLE;
+		rx.state = FSM_HPD_HIGH;
 	}
-	rx_print("%s %d nosignal:%d\n", __func__, rx.port, rx.no_signal);
+	rx_pr("%s %d nosignal:%d\n", __func__, rx.port, rx.no_signal);
 
 }
 
@@ -4444,19 +4664,8 @@ void hdmirx_hw_uninit(void)
 	/* hdmirx_phy_pddq(1); */
 }
 
-void hdmirx_hw_enable(void)
-{
-	hdmirx_set_pinmux();
-	hdmirx_hw_probe();
-	hdmirx_default_hpd(1);
-}
-
 void hdmirx_hw_disable(unsigned char flag)
 {
 }
 
-void hdmirx_default_hpd(bool high)
-{
-
-}
 
diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
index b90a940..559f6b8 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
@@ -38,13 +38,13 @@
 /* #include <linux/amlogic/amports/canvas.h> */
 /* #include <mach/am_regs.h> */
 #include <linux/amlogic/amports/vframe.h>
+#include <linux/of_gpio.h>
 
 /* Local include */
 
 #include "hdmirx_drv.h"
 #include "hdmi_rx_reg.h"
 #include "hdmi_rx_eq.h"
-#include "uart_hdmi.h"
 
 #define TVHDMI_NAME				"hdmirx"
 #define TVHDMI_DRIVER_NAME		"hdmirx"
@@ -64,9 +64,12 @@ static dev_t	hdmirx_devno;
 static struct class	*hdmirx_clsp;
 /* static int open_flage; */
 struct hdmirx_dev_s *devp_hdmirx_suspend;
-
-struct delayed_work     hpd_dwork;
-struct workqueue_struct *hpd_wq;
+unsigned int hu_share_choise;
+struct device *hdmirx_dev;
+struct delayed_work     eq_dwork;
+struct workqueue_struct *eq_wq;
+struct delayed_work		esm_dwork;
+struct workqueue_struct	*esm_wq;
 DECLARE_WAIT_QUEUE_HEAD(query_wait);
 unsigned int pwr_sts;
 
@@ -98,6 +101,11 @@ int pc_mode_en;
 MODULE_PARM_DESC(pc_mode_en, "\n pc_mode_en\n");
 module_param(pc_mode_en, int, 0664);
 
+unsigned int hdmirx_addr_port;
+unsigned int hdmirx_data_port;
+unsigned int hdmirx_ctrl_port;
+struct gpio_desc *g_uart_pin[3];
+
 struct reg_map {
 	unsigned int phy_addr;
 	unsigned int size;
@@ -130,6 +138,10 @@ static struct reg_map reg_maps[] = {
 		.phy_addr = 0xc8834400,
 		.size = 0x2000,
 	},
+	{
+		.phy_addr = 0xda846000,
+		.size = 0x57ba000,
+	},
 };
 
 static int in_reg_maps_idx(unsigned int addr)
@@ -153,11 +165,11 @@ void rx_init_reg_map(void)
 	for (i = 0; i < ARRAY_SIZE(reg_maps); i++) {
 		reg_maps[i].p = ioremap(reg_maps[i].phy_addr, reg_maps[i].size);
 		if (!reg_maps[i].p) {
-			rx_print("hdmirx: failed Mapped PHY: 0x%x\n",
+			rx_pr("hdmirx: failed Mapped PHY: 0x%x\n",
 				reg_maps[i].phy_addr);
 		} else {
 			reg_maps[i].flag = 1;
-			rx_print("hdmirx: Mapped PHY: 0x%x\n",
+			rx_pr("hdmirx: Mapped PHY: 0x%x\n",
 				reg_maps[i].phy_addr);
 		}
 	}
@@ -182,7 +194,7 @@ unsigned int rd_reg(unsigned int addr)
 	if ((idx != -1) && check_regmap_flag(addr))
 		val = readl(reg_maps[idx].p + (addr - reg_maps[idx].phy_addr));
 	else
-		rx_print("rd reg %x error\n");
+		rx_pr("rd reg %x error\n");
 	return val;
 }
 
@@ -193,7 +205,7 @@ void wr_reg(unsigned int addr, unsigned int val)
 	if ((idx != -1) && check_regmap_flag(addr))
 		writel(val, reg_maps[idx].p + (addr - reg_maps[idx].phy_addr));
 	else
-		rx_print("wr reg %x err\n", addr);
+		rx_pr("wr reg %x err\n", addr);
 }
 
 
@@ -222,8 +234,13 @@ uint32_t set(uint32_t data, uint32_t mask, uint32_t value)
 void hdmirx_timer_handler(unsigned long arg)
 {
 	struct hdmirx_dev_s *devp = (struct hdmirx_dev_s *)arg;
-
-	hdmirx_hw_monitor();
+	uart_plugin_monitor();
+	rx_5v_det();
+	rx_check_repeat();
+	if (edid_update_flag)
+		edid_update();
+	if ((rx.open_fg) && (!edid_update_flag))
+		hdmirx_hw_monitor();
 	devp->timer.expires = jiffies + TIMER_STATE_CHECK;
 	add_timer(&devp->timer);
 }
@@ -231,7 +248,7 @@ void hdmirx_timer_handler(unsigned long arg)
 int hdmirx_dec_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
 {
 	if ((port >= TVIN_PORT_HDMI0) && (port <= TVIN_PORT_HDMI7)) {
-		rx_print("hdmirx support\n");
+		rx_pr("hdmirx support\n");
 		return 0;
 	} else
 		return -1;
@@ -245,15 +262,20 @@ int hdmirx_dec_open(struct tvin_frontend_s *fe, enum tvin_port_e port)
 	devp_hdmirx_suspend = container_of(fe, struct hdmirx_dev_s, frontend);
 	devp->param.port = port;
 
+	/* should enable the adc ref signal for audio pll */
+	vdac_enable(1, 0x10);
+
 	hdmirx_hw_init(port);
 	/* timer */
+	#if 0
 	init_timer(&devp->timer);
 	devp->timer.data = (ulong)devp;
 	devp->timer.function = hdmirx_timer_handler;
 	devp->timer.expires = jiffies + TIMER_STATE_CHECK;
 	add_timer(&devp->timer);
+	#endif
 	rx.open_fg = 1;
-	rx_print("%s port:%x ok nosignal:%d\n", __func__, port, rx.no_signal);
+	rx_pr("%s port:%x ok nosignal:%d\n", __func__, port, rx.no_signal);
 	return 0;
 }
 
@@ -267,7 +289,7 @@ void hdmirx_dec_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
 	parm = &devp->param;
 	parm->info.fmt = fmt;
 	parm->info.status = TVIN_SIG_STATUS_STABLE;
-	rx_print("%s fmt:%d ok\n", __func__, fmt);
+	rx_pr("%s fmt:%d ok\n", __func__, fmt);
 }
 
 void hdmirx_dec_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
@@ -280,7 +302,7 @@ void hdmirx_dec_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
 	/* parm->info.fmt = TVIN_SIG_FMT_NULL; */
 	/* parm->info.status = TVIN_SIG_STATUS_NULL; */
 	to_init_state();
-	rx_print("%s ok\n", __func__);
+	rx_pr("%s ok\n", __func__);
 }
 
 void hdmirx_dec_close(struct tvin_frontend_s *fe)
@@ -288,17 +310,20 @@ void hdmirx_dec_close(struct tvin_frontend_s *fe)
 	struct hdmirx_dev_s *devp;
 	struct tvin_parm_s *parm;
 
+	/* should disable the adc ref signal for audio pll */
+	vdac_enable(0, 0x10);
+
 	/* open_flage = 0; */
 	rx.open_fg = 0;
 	devp = container_of(fe, struct hdmirx_dev_s, frontend);
 	parm = &devp->param;
-	del_timer_sync(&devp->timer);
+	/*del_timer_sync(&devp->timer);*/
 	hdmirx_hw_uninit();
 	hdmirx_hw_disable(0);
 	parm->info.fmt = TVIN_SIG_FMT_NULL;
 	parm->info.status = TVIN_SIG_STATUS_NULL;
 	to_init_state();
-	rx_print("%s ok\n", __func__);
+	rx_pr("%s ok\n", __func__);
 }
 
 /* interrupt handler */
@@ -373,7 +398,7 @@ bool hdmirx_fmt_chg(struct tvin_frontend_s *fe)
 	else {
 		fmt = hdmirx_hw_get_fmt();
 		if (fmt != parm->info.fmt) {
-			rx_print("hdmirx fmt: %d --> %d\n",
+			rx_pr("hdmirx fmt: %d --> %d\n",
 				parm->info.fmt, fmt);
 			parm->info.fmt = fmt;
 			ret = true;
@@ -449,10 +474,7 @@ void hdmirx_get_sig_property(struct tvin_frontend_s *fe,
 	prop->trans_fmt = TVIN_TFMT_2D;
 	if (hdmirx_hw_get_3d_structure(&_3d_structure,
 		&_3d_ext_data) >= 0) {
-		if (_3d_structure == 0x0) {
-			/* frame packing */
-			prop->trans_fmt = TVIN_TFMT_3D_FP;
-		} else if (_3d_structure == 0x1) {
+		if (_3d_structure == 0x1) {
 			/* field alternative */
 			prop->trans_fmt = TVIN_TFMT_3D_FA;
 		} else if (_3d_structure == 0x2) {
@@ -617,56 +639,57 @@ static long hdmirx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		hdcp_enable = 1;
 		hdmirx_hw_config();
 		hdmirx_set_hpd(rx.port, 0);
-		rx.state = FSM_HDMI5V_LOW;
-		rx.pre_state = FSM_HDMI5V_LOW;
+		rx.state = FSM_HPD_LOW;
+		rx.pre_state = FSM_HPD_LOW;
 		break;
 	case HDMI_IOC_HDCP_OFF:
 		hdcp_enable = 0;
 		hdmirx_hw_config();
 		hdmirx_set_hpd(rx.port, 0);
-		rx.state = FSM_HDMI5V_LOW;
-		rx.pre_state = FSM_HDMI5V_LOW;
+		rx.state = FSM_HPD_LOW;
+		rx.pre_state = FSM_HPD_LOW;
 		break;
 	case HDMI_IOC_EDID_UPDATE:
-		hdmi_rx_ctrl_edid_update();
-		hdmirx_set_hpd(rx.port, 0);
+		/* hdmi_rx_ctrl_edid_update(); */
+		/* hdmirx_set_hpd(rx.port, 0); */
+		/* force_reset_hpd = true; */
 		do_hpd_reset_flag = 1;
-		rx.state = FSM_HDMI5V_LOW;
-		rx.pre_state = FSM_HDMI5V_LOW;
+		/* rx.state = FSM_HDMI5V_LOW; */
+		/* rx.pre_state = FSM_HDMI5V_LOW; */
 		break;
 	case HDMI_IOC_PC_MODE_ON:
 		pc_mode_en = 1;
 		/* hdmirx_set_hpd(rx.port, 0); */
 		/* rx.state = FSM_HDMI5V_HIGH; */
 		/* rx.pre_state = FSM_HDMI5V_HIGH; */
-		rx_print("pc mode on\n");
+		rx_pr("pc mode on\n");
 		break;
 	case HDMI_IOC_PC_MODE_OFF:
 		pc_mode_en = 0;
 		/* hdmirx_set_hpd(rx.port, 0); */
 		/* rx.state = FSM_HDMI5V_HIGH; */
 		/* rx.pre_state = FSM_HDMI5V_HIGH; */
-		rx_print("pc mode off\n");
+		rx_pr("pc mode off\n");
 		break;
 	case HDMI_IOC_HDCP22_AUTO:
 		hdmirx_set_hpd(rx.port, 0);
-		hdcp_22_on = 1;
+		hdcp22_on = 1;
 		force_hdcp14_en = 0;
 		hdmirx_hw_config();
 		hpd_to_esm = 1;
-		rx.state = FSM_HDMI5V_HIGH;
-		rx.pre_state = FSM_HDMI5V_HIGH;
-		rx_print("hdcp22 auto\n");
+		rx.state = FSM_HPD_HIGH;
+		rx.pre_state = FSM_HPD_HIGH;
+		rx_pr("hdcp22 auto\n");
 		break;
 	case HDMI_IOC_HDCP22_FORCE14:
 		hdmirx_set_hpd(rx.port, 0);
 		force_hdcp14_en = 1;
-		hdcp_22_on = 0;
+		hdcp22_on = 0;
 		hdmirx_wr_dwc(DWC_HDCP22_CONTROL, 0x2);
-		video_stable_to_esm = 0;
-		rx.state = FSM_HDMI5V_HIGH;
-		rx.pre_state = FSM_HDMI5V_HIGH;
-		rx_print("force hdcp1.4\n");
+		esm_set_stable(0);
+		rx.state = FSM_HPD_HIGH;
+		rx.pre_state = FSM_HPD_HIGH;
+		rx_pr("force hdcp1.4\n");
 		break;
 	default:
 		ret = -ENOIOCTLCMD;
@@ -731,7 +754,7 @@ static unsigned char *hdmirx_log_buf;
 static unsigned int  hdmirx_log_wr_pos;
 static unsigned int  hdmirx_log_rd_pos;
 static unsigned int  hdmirx_log_buf_size;
-static DEFINE_SPINLOCK(rx_print_lock);
+static DEFINE_SPINLOCK(rx_pr_lock);
 #define DEF_LOG_BUF_SIZE (1024*128)
 #define PRINT_TEMP_BUF_SIZE 128
 
@@ -751,11 +774,11 @@ void hdmirx_powerdown(const char *buf, int size)
 			/* wr_reg(IO_APB_BUS_BASE,
 				HHI_HDMIRX_CLK_CNTL, 0x0); */
 		}
-		rx_print("[hdmirx]: hdmirx power down\n");
+		rx_pr("[hdmirx]: hdmirx power down\n");
 	}
 }
 
-int rx_print_buf(char *buf, int len)
+int rx_pr_buf(char *buf, int len)
 {
 	unsigned long flags;
 	int pos;
@@ -763,7 +786,7 @@ int rx_print_buf(char *buf, int len)
 
 	if (hdmirx_log_buf_size == 0)
 		return 0;
-	spin_lock_irqsave(&rx_print_lock, flags);
+	spin_lock_irqsave(&rx_pr_lock, flags);
 	hdmirx_log_rd_pos_ = hdmirx_log_rd_pos;
 	if (hdmirx_log_wr_pos >= hdmirx_log_rd_pos)
 		hdmirx_log_rd_pos_ += hdmirx_log_buf_size;
@@ -778,21 +801,37 @@ int rx_print_buf(char *buf, int len)
 	}
 	if (hdmirx_log_wr_pos >= hdmirx_log_buf_size)
 		hdmirx_log_wr_pos -= hdmirx_log_buf_size;
-	spin_unlock_irqrestore(&rx_print_lock, flags);
+	spin_unlock_irqrestore(&rx_pr_lock, flags);
 	return pos;
 }
 
-int rx_print(const char *fmt, ...)
+int rx_pr(const char *fmt, ...)
 {
 	va_list args;
 	int avail = PRINT_TEMP_BUF_SIZE;
 	char buf[PRINT_TEMP_BUF_SIZE];
 	int pos = 0;
 	int len = 0;
+	static bool last_break = 1;
+
+	if (last_break == 1) {
+		strcpy(buf, "[RX]-");
+		for (len = 0; len < strlen(fmt); len++)
+			if (fmt[len] == '\n')
+				pos++;
+			else
+				break;
 
+		strcpy(buf + 5, fmt + pos);
+	} else
+		strcpy(buf, fmt);
+	if (fmt[strlen(fmt) - 1] == '\n')
+		last_break = 1;
+	else
+		last_break = 0;
 	if (log_flag & LOG_EN) {
 		va_start(args, fmt);
-		vprintk(fmt, args);
+		vprintk(buf, args);
 		va_end(args);
 		return 0;
 	}
@@ -807,7 +846,7 @@ int rx_print(const char *fmt, ...)
 	if ((avail-len) <= 0)
 		buf[PRINT_TEMP_BUF_SIZE - 1] = '\0';
 
-	pos = rx_print_buf(buf, len);
+	pos = rx_pr_buf(buf, len);
 	return pos;
 }
 
@@ -841,7 +880,7 @@ static ssize_t show_log(struct device *dev,
 
 	if (hdmirx_log_buf_size == 0)
 		return 0;
-	spin_lock_irqsave(&rx_print_lock, flags);
+	spin_lock_irqsave(&rx_pr_lock, flags);
 	if (hdmirx_log_rd_pos < hdmirx_log_wr_pos)
 		read_size = hdmirx_log_wr_pos-hdmirx_log_rd_pos;
 	else if (hdmirx_log_rd_pos > hdmirx_log_wr_pos)
@@ -854,7 +893,7 @@ static ssize_t show_log(struct device *dev,
 	hdmirx_log_rd_pos += read_size;
 	if (hdmirx_log_rd_pos >= hdmirx_log_buf_size)
 		hdmirx_log_rd_pos = 0;
-	spin_unlock_irqrestore(&rx_print_lock, flags);
+	spin_unlock_irqrestore(&rx_pr_lock, flags);
 	return read_size;
 }
 
@@ -868,13 +907,13 @@ static ssize_t store_log(struct device *dev,
 	if (strncmp(buf, "bufsize", 7) == 0) {
 		if (kstrtoul(buf + 7, 10, &tmp) < 0)
 			return -EINVAL;
-		spin_lock_irqsave(&rx_print_lock, flags);
+		spin_lock_irqsave(&rx_pr_lock, flags);
 		log_init(tmp);
-		spin_unlock_irqrestore(&rx_print_lock, flags);
-		rx_print("hdmirx_store:set bufsize tmp %ld %d\n",
+		spin_unlock_irqrestore(&rx_pr_lock, flags);
+		rx_pr("hdmirx_store:set bufsize tmp %ld %d\n",
 			tmp, hdmirx_log_buf_size);
 	} else {
-		rx_print(0, "%s", buf);
+		rx_pr(0, "%s", buf);
 	}
 	return 16;
 }
@@ -988,7 +1027,6 @@ static void hdmirx_delete_device(int minor)
 }
 
 unsigned char *pEdid_buffer;
-
 static int hdmirx_probe(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -1003,11 +1041,11 @@ static int hdmirx_probe(struct platform_device *pdev)
 
 	log_init(DEF_LOG_BUF_SIZE);
 	pEdid_buffer = (unsigned char *) pdev->dev.platform_data;
-
+	hdmirx_dev = &pdev->dev;
 	/* allocate memory for the per-device structure */
 	hdevp = kmalloc(sizeof(struct hdmirx_dev_s), GFP_KERNEL);
 	if (!hdevp) {
-		rx_print("hdmirx:allocate memory failed\n");
+		rx_pr("hdmirx:allocate memory failed\n");
 		ret = -ENOMEM;
 		goto fail_kmalloc_hdev;
 	}
@@ -1032,57 +1070,57 @@ static int hdmirx_probe(struct platform_device *pdev)
 	/* create cdev and reigser with sysfs */
 	ret = hdmirx_add_cdev(&hdevp->cdev, &hdmirx_fops, hdevp->index);
 	if (ret) {
-		rx_print("%s: failed to add cdev\n", __func__);
+		rx_pr("%s: failed to add cdev\n", __func__);
 		goto fail_add_cdev;
 	}
 	/* create /dev nodes */
 	hdevp->dev = hdmirx_create_device(&pdev->dev, hdevp->index);
 	if (IS_ERR(hdevp->dev)) {
-		rx_print("hdmirx: failed to create device node\n");
+		rx_pr("hdmirx: failed to create device node\n");
 		ret = PTR_ERR(hdevp->dev);
 		goto fail_create_device;
 	}
 	/*create sysfs attribute files*/
 	ret = device_create_file(hdevp->dev, &dev_attr_debug);
 	if (ret < 0) {
-		rx_print("hdmirx: fail to create debug attribute file\n");
+		rx_pr("hdmirx: fail to create debug attribute file\n");
 		goto fail_create_debug_file;
 	}
 	ret = device_create_file(hdevp->dev, &dev_attr_edid);
 	if (ret < 0) {
-		rx_print("hdmirx: fail to create edid attribute file\n");
+		rx_pr("hdmirx: fail to create edid attribute file\n");
 		goto fail_create_edid_file;
 	}
 	ret = device_create_file(hdevp->dev, &dev_attr_key);
 	if (ret < 0) {
-		rx_print("hdmirx: fail to create key attribute file\n");
+		rx_pr("hdmirx: fail to create key attribute file\n");
 		goto fail_create_key_file;
 	}
 	ret = device_create_file(hdevp->dev, &dev_attr_log);
 	if (ret < 0) {
-		rx_print("hdmirx: fail to create log attribute file\n");
+		rx_pr("hdmirx: fail to create log attribute file\n");
 		goto fail_create_log_file;
 	}
 	ret = device_create_file(hdevp->dev, &dev_attr_reg);
 	if (ret < 0) {
-		rx_print("hdmirx: fail to create reg attribute file\n");
+		rx_pr("hdmirx: fail to create reg attribute file\n");
 		goto fail_create_reg_file;
 	}
 	ret = device_create_file(hdevp->dev, &dev_attr_cec);
 	if (ret < 0) {
-		rx_print("hdmirx: fail to create cec attribute file\n");
+		rx_pr("hdmirx: fail to create cec attribute file\n");
 		goto fail_create_cec_file;
 	}
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!res) {
-		rx_print("%s: can't get irq resource\n", __func__);
+		rx_pr("%s: can't get irq resource\n", __func__);
 		ret = -ENXIO;
 		/* goto fail_get_resource_irq; */
 	}
 	hdevp->irq = res->start;
 	snprintf(hdevp->irq_name, sizeof(hdevp->irq_name),
 			"hdmirx%d-irq", hdevp->index);
-	rx_print("hdevpd irq: %d, %d\n", hdevp->index,
+	rx_pr("hdevpd irq: %d, %d\n", hdevp->index,
 			hdevp->irq);
 	if (pdev->dev.of_node) {
 		ret = of_property_read_u32(pdev->dev.of_node,
@@ -1105,7 +1143,7 @@ static int hdmirx_probe(struct platform_device *pdev)
 			IRQF_SHARED,
 			hdevp->irq_name,
 			(void *)&rx))
-		rx_print(__func__, "RX IRQ request");
+		rx_pr(__func__, "RX IRQ request");
 	/* frontend */
 	tvin_frontend_init(&hdevp->frontend,
 		&hdmirx_dec_ops,
@@ -1113,7 +1151,19 @@ static int hdmirx_probe(struct platform_device *pdev)
 		hdevp->index);
 	sprintf(hdevp->frontend.name, "%s", TVHDMI_NAME);
 	if (tvin_reg_frontend(&hdevp->frontend) < 0)
-		rx_print("hdmirx: driver probe error!!!\n");
+		rx_pr("hdmirx: driver probe error!!!\n");
+
+	ret = of_property_read_u32(pdev->dev.of_node,
+			"hdmiuart_share_cfg", &(hu_share_choise));
+	if (ret) {
+		pr_err("%s:don't find hu_cfg.\n", __func__);
+		hu_share_choise = 0;
+	} else if (hu_share_choise == 0) {
+		pr_err("%s:hu_cfg = 0.\n", __func__);
+		hu_share_choise = 0;
+	}
+	hu_share_choise &= share_with_uart_cfg;
+	rx_pr("hu_share_choise = %d\n", hu_share_choise);
 
 	/* pinmux set */
 	if (pdev->dev.of_node) {
@@ -1122,10 +1172,9 @@ static int hdmirx_probe(struct platform_device *pdev)
 					    0, &pin_name);
 		if (!ret) {
 			pin = devm_pinctrl_get_select(&pdev->dev, pin_name);
-			rx_print("hdmirx: pinmux:%p, name:%s\n", pin, pin_name);
+			rx_pr("hdmirx: pinmux:%p, name:%s\n", pin, pin_name);
 		}
 	}
-
 	if (pdev->dev.of_node) {
 		ret = of_property_read_u32(pdev->dev.of_node,
 				"rx_port_maps", &real_port_map);
@@ -1134,18 +1183,39 @@ static int hdmirx_probe(struct platform_device *pdev)
 			real_port_map = 0x3120;
 		}
 	}
+	if (pdev->dev.of_node) {
+		ret = of_property_read_u32(pdev->dev.of_node,
+				"hdmirx_addr_port", &hdmirx_addr_port);
+		if (ret)
+			pr_err("get hdmirx_addr_port fail.\n");
+		ret = of_property_read_u32(pdev->dev.of_node,
+				"hdmirx_data_port", &hdmirx_data_port);
+		if (ret)
+			pr_err("get hdmirx_data_port fail.\n");
+		ret = of_property_read_u32(pdev->dev.of_node,
+				"hdmirx_ctrl_port", &hdmirx_ctrl_port);
+		if (ret)
+			pr_err("get hdmirx_ctrl_port fail.\n");
+		ret = of_property_read_u32(pdev->dev.of_node,
+				"repeat", &repeat_function);
+		if (ret) {
+			pr_err("get repeat_function fail.\n");
+			repeat_function = 0;
+		}
+	}
 
-	/* hdmirx_hw_enable(); */
+	g_uart_pin[0] = of_get_named_gpiod_flags(pdev->dev.of_node,
+			"uart_scl_a_pin", 0, NULL);
+	g_uart_pin[1] = of_get_named_gpiod_flags(pdev->dev.of_node,
+			"uart_scl_b_pin", 0, NULL);
+	g_uart_pin[2] = of_get_named_gpiod_flags(pdev->dev.of_node,
+			"uart_scl_c_pin", 0, NULL);
 
 	dev_set_drvdata(hdevp->dev, hdevp);
 
-	/*create eq thread*/
-	if (hdmirx_phy_probe() != 0)
-		rx_print("create eq thread error\n");
-
 	xtal_clk = clk_get(&pdev->dev, "xtal");
 	if (IS_ERR(xtal_clk))
-		rx_print("get xtal err\n");
+		rx_pr("get xtal err\n");
 	else {
 		clk_rate = clk_get_rate(xtal_clk);
 		pr_info("%s: xtal_clk is %d MHZ\n", __func__,
@@ -1153,7 +1223,7 @@ static int hdmirx_probe(struct platform_device *pdev)
 	}
 	fclk_div5_clk = clk_get(&pdev->dev, "fclk_div5");
 	if (IS_ERR(fclk_div5_clk))
-		rx_print("get fclk_div5_clk err\n");
+		rx_pr("get fclk_div5_clk err\n");
 	else {
 		clk_rate = clk_get_rate(fclk_div5_clk);
 		pr_info("%s: fclk_div5_clk is %d MHZ\n", __func__,
@@ -1161,7 +1231,7 @@ static int hdmirx_probe(struct platform_device *pdev)
 	}
 	hdevp->modet_clk = clk_get(&pdev->dev, "hdmirx_modet_clk");
 	if (IS_ERR(hdevp->modet_clk))
-		rx_print("get modet_clk err\n");
+		rx_pr("get modet_clk err\n");
 	else {
 		clk_set_parent(hdevp->modet_clk, xtal_clk);
 		clk_set_rate(hdevp->modet_clk, 24000000);
@@ -1172,7 +1242,7 @@ static int hdmirx_probe(struct platform_device *pdev)
 
 	hdevp->cfg_clk = clk_get(&pdev->dev, "hdmirx_cfg_clk");
 	if (IS_ERR(hdevp->cfg_clk))
-		rx_print("get cfg_clk err\n");
+		rx_pr("get cfg_clk err\n");
 	else {
 		clk_set_parent(hdevp->cfg_clk, fclk_div5_clk);
 		clk_set_rate(hdevp->cfg_clk, 133333333);
@@ -1184,7 +1254,7 @@ static int hdmirx_probe(struct platform_device *pdev)
 	/*
 	hdevp->acr_ref_clk = clk_get(&pdev->dev, "hdmirx_acr_ref_clk");
 	if (IS_ERR(hdevp->acr_ref_clk))
-		rx_print("get acr_ref_clk err\n");
+		rx_pr("get acr_ref_clk err\n");
 	else {
 		clk_set_parent(hdevp->acr_ref_clk, fclk_div5_clk);
 		clk_set_rate(hdevp->acr_ref_clk, 24000000);
@@ -1195,7 +1265,7 @@ static int hdmirx_probe(struct platform_device *pdev)
 	*/
 	hdevp->audmeas_clk = clk_get(&pdev->dev, "hdmirx_audmeas_clk");
 	if (IS_ERR(hdevp->audmeas_clk))
-		rx_print("get audmeas_clk err\n");
+		rx_pr("get audmeas_clk err\n");
 	else {
 		clk_set_parent(hdevp->audmeas_clk, fclk_div5_clk);
 		clk_set_rate(hdevp->audmeas_clk, 200000000);
@@ -1205,14 +1275,22 @@ static int hdmirx_probe(struct platform_device *pdev)
 	}
 
 	/* create for hot plug function */
-	hpd_wq = create_singlethread_workqueue(hdevp->frontend.name);
-	INIT_DELAYED_WORK(&hpd_dwork, hdmirx_plug_det);
+	eq_wq = create_singlethread_workqueue(hdevp->frontend.name);
+	INIT_DELAYED_WORK(&eq_dwork, eq_algorithm);
 
-	queue_delayed_work(hpd_wq, &hpd_dwork, msecs_to_jiffies(5));
+	esm_wq = create_singlethread_workqueue(hdevp->frontend.name);
+	INIT_DELAYED_WORK(&esm_dwork, rx_hpd_to_esm_handle);
+	/* queue_delayed_work(eq_wq, &eq_dwork, msecs_to_jiffies(5)); */
 
 	hdmirx_hw_probe();
 
-	rx_print("hdmirx: driver probe ok\n");
+	init_timer(&hdevp->timer);
+	hdevp->timer.data = (ulong)hdevp;
+	hdevp->timer.function = hdmirx_timer_handler;
+	hdevp->timer.expires = jiffies + TIMER_STATE_CHECK;
+	add_timer(&hdevp->timer);
+
+	rx_pr("hdmirx: driver probe ok\n");
 
 	return 0;
 fail_create_cec_file:
@@ -1245,8 +1323,11 @@ static int hdmirx_remove(struct platform_device *pdev)
 
 	hdevp = platform_get_drvdata(pdev);
 
-	cancel_delayed_work(&hpd_dwork);
-	destroy_workqueue(hpd_wq);
+	cancel_delayed_work(&eq_dwork);
+	destroy_workqueue(eq_wq);
+
+	cancel_delayed_work(&esm_dwork);
+	destroy_workqueue(esm_wq);
 
 	device_remove_file(hdevp->dev, &dev_attr_debug);
 	device_remove_file(hdevp->dev, &dev_attr_edid);
@@ -1254,12 +1335,11 @@ static int hdmirx_remove(struct platform_device *pdev)
 	device_remove_file(hdevp->dev, &dev_attr_log);
 	device_remove_file(hdevp->dev, &dev_attr_reg);
 	device_remove_file(hdevp->dev, &dev_attr_cec);
-	hdmirx_phy_exit();
 	tvin_unreg_frontend(&hdevp->frontend);
 	hdmirx_delete_device(hdevp->index);
 	cdev_del(&hdevp->cdev);
 	kfree(hdevp);
-	rx_print("hdmirx: driver removed ok.\n");
+	rx_pr("hdmirx: driver removed ok.\n");
 	return 0;
 }
 
@@ -1268,8 +1348,7 @@ static int hdmirx_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	int i = 0;
 
-	rx_print("[hdmirx]: hdmirx_suspend\n");
-	hdmirx_phy_suspend_eq();
+	rx_pr("[hdmirx]: hdmirx_suspend\n");
 	if (rx.open_fg == 1) {
 		if (resume_flag == 0)
 			del_timer_sync(&devp_hdmirx_suspend->timer);
@@ -1278,7 +1357,7 @@ static int hdmirx_suspend(struct platform_device *pdev, pm_message_t state)
 	}
 	/*hdmirx_phy_pddq(1);*/
 	/*clk_off();*/
-	rx_print("[hdmirx]: suspend success\n");
+	rx_pr("[hdmirx]: suspend success\n");
 	return 0;
 }
 
@@ -1291,7 +1370,7 @@ static int hdmirx_resume(struct platform_device *pdev)
 		;
 	if ((resume_flag == 0) && (rx.open_fg == 1))
 		add_timer(&devp_hdmirx_suspend->timer);
-	rx_print("hdmirx: resume module---end,rx.open_fg:%d\n", rx.open_fg);
+	rx_pr("hdmirx: resume module---end,rx.open_fg:%d\n", rx.open_fg);
 	pre_port = 0xff;
 	return 0;
 
@@ -1301,7 +1380,7 @@ static int hdmirx_resume(struct platform_device *pdev)
 #ifdef CONFIG_HIBERNATION
 static int hdmirx_restore(struct device *dev)
 {
-	queue_delayed_work(hpd_wq, &hpd_dwork, msecs_to_jiffies(5));
+	/* queue_delayed_work(eq_wq, &eq_dwork, msecs_to_jiffies(5)); */
 	return 0;
 }
 static int hdmirx_pm_suspend(struct device *dev)
@@ -1357,13 +1436,13 @@ static int __init hdmirx_init(void)
 
 	ret = alloc_chrdev_region(&hdmirx_devno, 0, 1, TVHDMI_NAME);
 	if (ret < 0) {
-		rx_print("hdmirx: failed to allocate major number\n");
+		rx_pr("hdmirx: failed to allocate major number\n");
 		goto fail_alloc_cdev_region;
 	}
 
 	hdmirx_clsp = class_create(THIS_MODULE, TVHDMI_NAME);
 	if (IS_ERR(hdmirx_clsp)) {
-		rx_print("hdmirx: can't get hdmirx_clsp\n");
+		rx_pr("hdmirx: can't get hdmirx_clsp\n");
 		ret = PTR_ERR(hdmirx_clsp);
 		goto fail_class_create;
 	}
@@ -1371,24 +1450,24 @@ static int __init hdmirx_init(void)
 	#if 0
 	pdev = platform_device_alloc(TVHDMI_NAME, 0);
 	if (IS_ERR(pdev)) {
-		rx_print("%s alloc platform device error.\n",
+		rx_pr("%s alloc platform device error.\n",
 			__func__);
 		goto fail_class_create;
 	}
 	if (platform_device_add(pdev)) {
-		rx_print("%s failed register platform device.\n",
+		rx_pr("%s failed register platform device.\n",
 			__func__);
 		goto fail_class_create;
 	}
 	#endif
 	ret = platform_driver_register(&hdmirx_driver);
 	if (ret != 0) {
-		rx_print("register hdmirx module failed, error %d\n",
+		rx_pr("register hdmirx module failed, error %d\n",
 			ret);
 		ret = -ENODEV;
 		goto fail_pdrv_register;
 	}
-	rx_print("hdmirx: hdmirx_init.\n");
+	rx_pr("hdmirx: hdmirx_init.\n");
 
 	return 0;
 
@@ -1406,7 +1485,7 @@ static void __exit hdmirx_exit(void)
 	class_destroy(hdmirx_clsp);
 	unregister_chrdev_region(hdmirx_devno, 1);
 	platform_driver_unregister(&hdmirx_driver);
-	rx_print("hdmirx: hdmirx_exit.\n");
+	rx_pr("hdmirx: hdmirx_exit.\n");
 }
 
 module_init(hdmirx_init);
diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
index 1846ba8..14b4d2f 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
+++ b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
@@ -27,7 +27,10 @@
 #include "../tvin_format_table.h"
 #include "../tvin_frontend.h"
 
-#define HDMIRX_VER "Ref.2016/06/23"
+#define RX_VER0 "Ref.2016/08/16"
+#define RX_VER1 "Ref.2016/08/10"
+#define RX_VER2 "Ref.2016/08/10"
+#define RX_VER3 "Ref.2016/09/02"
 
 #define HDMI_STATE_CHECK_FREQ     (20*5)
 #define ABS(x) ((x) < 0 ? -(x) : (x))
@@ -37,7 +40,7 @@
 #define AUDIO_LOG	0x04
 #define HDCP_LOG	0x08
 #define PACKET_LOG	0x10
-#define CEC_LOG		0x20
+#define EQ_LOG		0x20
 #define REG_LOG		0x40
 #define ERR_LOG		0x80
 
@@ -68,6 +71,7 @@ struct hdmirx_dev_s {
 #define HDMI_IOC_PC_MODE_OFF	_IO(HDMI_IOC_MAGIC, 0x05)
 #define HDMI_IOC_HDCP22_AUTO	_IO(HDMI_IOC_MAGIC, 0x06)
 #define HDMI_IOC_HDCP22_FORCE14 _IO(HDMI_IOC_MAGIC, 0x07)
+#define HDMI_IOC_HDMI_20_SET	_IO(HDMI_IOC_MAGIC, 0x08)
 
 #define HDMI_IOC_HDCP_GET_KSV _IOR(HDMI_IOC_MAGIC, 0x09, struct _hdcp_ksv)
 
@@ -168,10 +172,11 @@ enum HDMI_Video_Type {
 
 enum fsm_states_e {
 	FSM_INIT,
-	FSM_HDMI5V_LOW,
-	FSM_HDMI5V_HIGH,
-	FSM_HPD_READY,
+	FSM_HPD_LOW,
+	FSM_HPD_HIGH,
+	FSM_EQ_INIT,
 	FSM_EQ_CALIBRATION,
+	FSM_EQ_END,
 	FSM_PHY_RST,
 	FSM_WAIT_CLK_STABLE,
 	FSM_WAIT_HDCP_SWITCH,
@@ -185,6 +190,15 @@ enum fsm_states_e {
 	FSM_DWC_RESET,
 };
 
+enum port_sts {
+	e_port0,
+	e_port1,
+	e_port2,
+	e_5v_lost = 0xfd,
+	e_hpd_reset = 0xfe,
+	e_init = 0xff,
+};
+
 enum repeater_state_e {
 	REPEATER_STATE_WAIT_KSV,
 	REPEATER_STATE_WAIT_ACK,
@@ -198,6 +212,21 @@ enum hdcp_version_e {
 	HDCP_VERSION_22,
 };
 
+enum hdmirx_port_e {
+	HDMIRX_PORT0,
+	HDMIRX_PORT1,
+	HDMIRX_PORT2,
+	HDMIRX_PORT3,
+};
+
+enum hdcp22_auth_state_e {
+	HDCP22_AUTH_STATE_NOT_CAPBLE,
+	HDCP22_AUTH_STATE_CAPBLE,
+	HDCP22_AUTH_STATE_LOST,
+	HDCP22_AUTH_STATE_SUCCESS,
+	HDCP22_AUTH_STATE_FAILED,
+};
+
 /** Configuration clock minimum [kHz] */
 #define CFG_CLK_MIN				(10000UL)
 /** Configuration clock maximum [kHz] */
@@ -436,18 +465,13 @@ struct rx_s {
 	/* wrapper */
 	unsigned int state;
 	unsigned int pre_state;
-	unsigned char portA_pow5v_state_pre;
-	unsigned char portB_pow5v_state_pre;
-	unsigned char portC_pow5v_state_pre;
-	unsigned char portD_pow5v_state_pre;
-	unsigned char portA_pow5v_state;
-	unsigned char portB_pow5v_state;
-	unsigned char portC_pow5v_state;
-	unsigned char portD_pow5v_state;
-	bool current_port_tx_5v_status;
+
+	unsigned char pre_5v_sts;
+
+	unsigned char cur_5v_sts;
 	/* bool tx_5v_status_pre; */
 	bool no_signal;
-	int hpd_wait_time;
+	/* int hpd_wait_time; */
 	int audio_wait_time;
 	int aud_sr_stable_cnt;
 	int aud_sr_unstable_cnt;
@@ -540,6 +564,7 @@ enum edid_list_e {
 	EDID_LIST_4K,
 	EDID_LIST_DOMY,
 	EDID_LIST_V2,
+	EDID_LIST_ATMOS,
 	EDID_LIST_NUM
 };
 
@@ -567,9 +592,30 @@ struct vsi_infoframe_t {
 	unsigned char struct_3d_ext:4;
 };
 
-/* hpd event */
-extern struct delayed_work     hpd_dwork;
-extern struct workqueue_struct *hpd_wq;
+struct st_eq_data {
+	/* Best long cable setting */
+	uint16_t bestLongSetting;
+	/* long cable setting detected and valid */
+	uint8_t validLongSetting;
+	/* best short cable setting */
+	uint16_t bestShortSetting;
+	/* best short cable setting detected and valid */
+	uint8_t validShortSetting;
+	/* TMDS Valid for channel */
+	uint8_t tmdsvalid;
+	/* best setting to be programed */
+	uint16_t bestsetting;
+	/* Accumulator register */
+	uint16_t acc;
+	/* Aquisition register */
+	uint16_t acq;
+	uint16_t lastacq;
+};
+
+extern struct delayed_work     eq_dwork;
+extern struct workqueue_struct *eq_wq;
+extern struct delayed_work		esm_dwork;
+extern struct workqueue_struct	*esm_wq;
 extern unsigned int pwr_sts;
 extern unsigned char *pEdid_buffer;
 extern bool multi_port_edid_enable;
@@ -582,24 +628,33 @@ extern bool hdcp_enable;
 extern int it_content;
 extern struct rx_s rx;
 extern int log_flag;
+
+extern unsigned int hdmirx_addr_port;
+extern unsigned int hdmirx_data_port;
+extern unsigned int hdmirx_ctrl_port;
 extern unsigned char is_alternative(void);
 extern unsigned char is_frame_packing(void);
 extern void clk_init(void);
 extern void clk_off(void);
 extern void set_scdc_cfg(int hpdlow, int pwrprovided);
-extern int hdmirx_print_flag;
 extern bool irq_ctrl_reg_en; /* enable/disable reg rd/wr in irq  */
 
 extern int rgb_quant_range;
 extern int yuv_quant_range;
-extern int hdcp_22_on;
+extern int hdcp22_on;
 extern int do_esm_rst_flag;
 extern int hdcp22_firmware_ok_flag;
 extern int force_hdcp14_en;
 extern int pre_port;
+extern int share_with_uart_cfg;
+extern unsigned int hu_share_choise;
+extern struct device *hdmirx_dev;
+extern struct gpio_desc *g_uart_pin[3];
+
 extern int esm_err_force_14;
 extern int pc_mode_en;
 extern int do_hpd_reset_flag;
+extern bool edid_update_flag;
 
 unsigned int rd_reg(unsigned int addr);
 void wr_reg(unsigned int addr, unsigned int val);
@@ -673,7 +728,6 @@ unsigned int hdmirx_get_audio_clock(void);
 
 void hdmirx_read_audio_info(struct aud_info_s *audio_info);
 void hdmirx_read_vendor_specific_info_frame(struct vendor_specific_info_s *vs);
-void hdmirx_set_pinmux(void);
 unsigned int hdmirx_get_clock(int index);
 irqreturn_t irq_handler(int irq, void *params);
 
@@ -681,14 +735,14 @@ irqreturn_t irq_handler(int irq, void *params);
  * all functions declare
  */
 extern enum tvin_sig_fmt_e hdmirx_hw_get_fmt(void);
+extern void edid_update(void);
 extern void hdmirx_hw_monitor(void);
+extern void uart_plugin_monitor(void);
 extern bool hdmirx_hw_is_nosig(void);
 extern bool hdmirx_hw_pll_lock(void);
 extern void hdmirx_hw_init(enum tvin_port_e port);
 extern void to_init_state(void);
 extern void hdmirx_hw_uninit(void);
-extern void hdmirx_hw_enable(void);
-extern void hdmirx_default_hpd(bool high);
 extern void hdmirx_hw_disable(unsigned char flag);
 extern void hdmirx_fill_edid_buf(const char *buf, int size);
 extern int hdmirx_read_edid_buf(char *buf, int max_size);
@@ -701,7 +755,7 @@ extern int hdmirx_hw_get_dvi_info(void);
 extern int rx_get_colordepth(void);
 extern int hdmirx_hw_get_pixel_repeat(void);
 extern bool hdmirx_hw_check_frame_skip(void);
-extern int rx_print(const char *fmt, ...);
+extern int rx_pr(const char *fmt, ...);
 extern int hdmirx_de_repeat_enable;
 extern int hdmirx_hw_dump_reg(unsigned char *buf, int size);
 extern bool hdmirx_audio_pll_lock(void);
@@ -711,10 +765,22 @@ extern ssize_t hdmirx_signal_status_buf(char *buf);
 extern void hdmirx_irq_init(void);
 extern void hdmirx_check_new_edid(void);
 
-extern void hdmirx_plug_det(struct work_struct *work);
+extern void eq_algorithm(struct work_struct *work);
 extern void hdmirx_wait_query(void);
-extern bool hdmirx_tmds_34g(void);
+extern bool hdmirx_tmds_6g(void);
+extern void rx_hpd_to_esm_handle(struct work_struct *work);
 
-extern int cec_has_irq(void);
+/* extern int cec_has_irq(void); */
 extern void cecrx_hw_init(void);
+extern int  meson_clk_measure(unsigned int clk_mux);
+extern void esm_set_stable(bool stable);
+extern void rx_5v_det(void);
+extern void hdmirx_set_hdmi20_force(int port, bool value);
+extern bool hdmirx_get_hdmi20_force(int port);
+/* vdac ctrl,adc/dac ref signal,cvbs out signal
+ * module index: atv demod:0x01; dtv demod:0x02;
+ * tvafe:0x4; dac:0x8, audio pll:0x10
+*/
+extern void vdac_enable(bool on, unsigned int module_sel);
+extern void hdmirx_phy_bist_test(int lvl);
 #endif  /* _TVHDMI_H */
diff --git a/drivers/amlogic/tvin/tvafe/tvafe.c b/drivers/amlogic/tvin/tvafe/tvafe.c
index 583fea5..09b2e2a 100644
--- a/drivers/amlogic/tvin/tvafe/tvafe.c
+++ b/drivers/amlogic/tvin/tvafe/tvafe.c
@@ -59,22 +59,29 @@
 
 static dev_t                     tvafe_devno;
 static struct class              *tvafe_clsp;
-static bool                      disableapi;
-static bool                      force_stable;
+struct mutex pll_mutex;
+
 #define TVAFE_TIMER_INTERVAL    (HZ/100)   /* 10ms, #define HZ 100 */
+
+static bool disableapi;
+static bool force_stable;
 static struct am_regs_s tvaferegs;
 static struct tvafe_pin_mux_s tvafe_pinmux;
+
 static bool enable_db_reg = true;
 module_param(enable_db_reg, bool, 0644);
 MODULE_PARM_DESC(enable_db_reg, "enable/disable tvafe load reg");
+
 static int vga_yuv422_enable;
 module_param(vga_yuv422_enable, int, 0664);
 MODULE_PARM_DESC(vga_yuv422_enable, "vga_yuv422_enable");
+
 static bool tvafe_dbg_enable;
 module_param(tvafe_dbg_enable, bool, 0644);
 MODULE_PARM_DESC(tvafe_dbg_enable, "enable/disable tvafe debug enable");
 
 static struct tvafe_info_s *g_tvafe_info;
+
 /***********the  version of changing log************************/
 static const char last_version_s[] = "2013-11-29||11-28";
 static const char version_s[] = "2015-07-08||17-23";
@@ -272,7 +279,7 @@ static ssize_t dumpmem_store(struct device *dev,
 	devp = dev_get_drvdata(dev);
 	ps = buf_orig;
 	while (1) {
-		token = strsep(&ps, "\n");
+		token = strsep(&ps, " \n");
 		if (token == NULL)
 			break;
 		if (*token == '\0')
@@ -708,8 +715,7 @@ int tvafe_dec_open(struct tvin_frontend_s *fe, enum tvin_port_e port)
 		mutex_unlock(&devp->afe_mutex);
 		return 1;
 	}
-	if (((port < TVIN_PORT_CVBS0) || (port > TVIN_PORT_CVBS7)) &&
-			(is_meson_gxtvbb_cpu())) {
+	if ((port < TVIN_PORT_CVBS0) || (port > TVIN_PORT_CVBS7)) {
 
 		pr_err("[tvafe..] %s(%d), %s unsupport\n", __func__,
 				devp->index, tvin_port_str(port));
@@ -773,8 +779,7 @@ void tvafe_dec_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
 		mutex_unlock(&devp->afe_mutex);
 		return;
 	}
-	if (((port < TVIN_PORT_CVBS0) || (port > TVIN_PORT_CVBS7)) &&
-			(is_meson_gxtvbb_cpu())) {
+	if ((port < TVIN_PORT_CVBS0) || (port > TVIN_PORT_CVBS7)) {
 
 		pr_err("[tvafe..] %s(%d), %s unsupport\n", __func__,
 				devp->index, tvin_port_str(port));
@@ -818,8 +823,7 @@ void tvafe_dec_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
 		mutex_unlock(&devp->afe_mutex);
 		return;
 	}
-	if (((port < TVIN_PORT_CVBS0) || (port > TVIN_PORT_CVBS7)) &&
-			(is_meson_gxtvbb_cpu())) {
+	if ((port < TVIN_PORT_CVBS0) || (port > TVIN_PORT_CVBS7)) {
 
 		pr_err("[tvafe..] %s(%d), %s unsupport\n", __func__,
 				devp->index, tvin_port_str(port));
@@ -880,9 +884,8 @@ void tvafe_dec_close(struct tvin_frontend_s *fe)
 		mutex_unlock(&devp->afe_mutex);
 		return;
 	}
-	if (((tvafe->parm.port < TVIN_PORT_CVBS0) ||
-			(tvafe->parm.port > TVIN_PORT_CVBS7)) &&
-			(is_meson_gxtvbb_cpu())) {
+	if ((tvafe->parm.port < TVIN_PORT_CVBS0) ||
+		(tvafe->parm.port > TVIN_PORT_CVBS7)) {
 
 		pr_err("[tvafe..] %s(%d), %s unsupport\n", __func__,
 				devp->index, tvin_port_str(tvafe->parm.port));
@@ -1991,6 +1994,7 @@ int tvafe_hiu_reg_write(unsigned int reg, unsigned int val)
 	return 0;
 }
 EXPORT_SYMBOL(tvafe_hiu_reg_write);
+
 static unsigned int tvafe_use_reserved_mem;
 static struct resource tvafe_memobj;
 static int tvafe_drv_probe(struct platform_device *pdev)
@@ -2194,6 +2198,7 @@ static int tvafe_drv_probe(struct platform_device *pdev)
 	tvin_reg_frontend(&tdevp->frontend);
 
 	mutex_init(&tdevp->afe_mutex);
+	mutex_init(&pll_mutex);
 
 	dev_set_drvdata(tdevp->dev, tdevp);
 	platform_set_drvdata(pdev, tdevp);
@@ -2222,6 +2227,7 @@ static int tvafe_drv_remove(struct platform_device *pdev)
 	tdevp = platform_get_drvdata(pdev);
 
 	mutex_destroy(&tdevp->afe_mutex);
+	mutex_destroy(&pll_mutex);
 	tvin_unreg_frontend(&tdevp->frontend);
 	device_remove_file(tdevp->dev, &dev_attr_debug);
 	device_remove_file(tdevp->dev, &dev_attr_dumpmem);
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_cvd.c b/drivers/amlogic/tvin/tvafe/tvafe_cvd.c
index faaab51..33bee67 100644
--- a/drivers/amlogic/tvin/tvafe/tvafe_cvd.c
+++ b/drivers/amlogic/tvin/tvafe/tvafe_cvd.c
@@ -271,6 +271,11 @@ static unsigned int acd_h_config = 0x8e035e;
 module_param(acd_h_config, uint, 0664);
 MODULE_PARM_DESC(acd_h_config, "acd_h_config");
 
+/*0:NORMAL  1:a little sharper 2:sharper 3:even sharper*/
+static unsigned int cvd2_filter_config_level;
+module_param(cvd2_filter_config_level, uint, 0664);
+MODULE_PARM_DESC(cvd2_filter_config_level, "cvd2_filter_config_level");
+
 static unsigned int try_format_cnt;
 
 static bool cvd_pr_flag;
@@ -337,6 +342,47 @@ static void tvafe_cvd2_memory_init(struct tvafe_cvd2_mem_s *mem,
 
 	return;
 }
+/*
+txl new add adj filter:
+normal filter: 0x3194 = 0x40100160, 0x3195 = 0x50, 0x3196=0x0.
+sharper filter: 0x3194 = 0x40123282, 0x3195 = 0x19dd03a6, 0x96=0x0.
+even sharper filter: 0x3194 = 0x401012da, 0x3195 = 0x2023036c,
+0x3196 = 0xf20815d4
+*/
+static void tvafe_cvd2_filter_config(void)
+{
+	switch (cvd2_filter_config_level) {
+	case 0:
+		W_APB_REG(ACD_REG_94, 0x40100160);
+		W_APB_REG(ACD_REG_95, 0x50);
+		W_APB_REG(ACD_REG_96, 0x0);
+		break;
+	case 1:
+		W_APB_REG(ACD_REG_94, 0x40126266);
+		W_APB_REG(ACD_REG_95, 0x3ad303a1);
+		W_APB_REG(ACD_REG_96, 0x080ee9fa);
+		break;
+	case 2:
+		W_APB_REG(ACD_REG_94, 0x40114288);
+		W_APB_REG(ACD_REG_95, 0x38f30388);
+		W_APB_REG(ACD_REG_96, 0x0416f7e4);
+		break;
+	case 3:
+		W_APB_REG(ACD_REG_94, 0x40123282);
+		W_APB_REG(ACD_REG_95, 0x19dd03a6);
+		W_APB_REG(ACD_REG_96, 0x0);
+		break;
+	default:
+		W_APB_REG(ACD_REG_94, 0x40100160);
+		W_APB_REG(ACD_REG_95, 0x50);
+		W_APB_REG(ACD_REG_96, 0x0);
+		break;
+	}
+	if (cvd_dbg_en)
+		pr_info("[tvafe..]%s cvd2 filter config level %d.\n",
+				__func__, cvd2_filter_config_level);
+
+}
 
 /*
  * tvafe cvd2 load Reg talbe
@@ -350,9 +396,8 @@ static void tvafe_cvd2_write_mode_reg(struct tvafe_cvd2_s *cvd2,
 	W_APB_BIT(CVD2_RESET_REGISTER, 1, SOFT_RST_BIT, SOFT_RST_WID);
 
 	/* for rf&cvbs source acd table */
-	if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
-		(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-		(is_meson_gxtvbb_cpu())) {
+	if ((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+		(cvd2->vd_port == TVIN_PORT_CVBS0)) {
 
 		for (i = 0; i < (ACD_REG_NUM+1); i++) {
 
@@ -373,6 +418,8 @@ static void tvafe_cvd2_write_mode_reg(struct tvafe_cvd2_s *cvd2,
 		}
 
 	}
+	/*cvd filter config*/
+	tvafe_cvd2_filter_config();
 
 	/* load CVD2 reg 0x00~3f (char) */
 	for (i = 0; i < CVD_PART1_REG_NUM; i++) {
@@ -426,9 +473,8 @@ static void tvafe_cvd2_write_mode_reg(struct tvafe_cvd2_s *cvd2,
 
 	/* for tuner picture quality */
 
-	if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
-		(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-		(is_meson_gxtvbb_cpu())) {
+	if ((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+		(cvd2->vd_port == TVIN_PORT_CVBS0)) {
 
 		W_APB_REG(CVD2_REG_B0, 0xf0);
 		W_APB_BIT(CVD2_REG_B2 , 0,
@@ -453,17 +499,15 @@ static void tvafe_cvd2_write_mode_reg(struct tvafe_cvd2_s *cvd2,
 	/* vbi reset release, vbi agent enable */
 #endif
 #if defined(CONFIG_TVIN_TUNER_SI2176)
-	if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
-		(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-		(is_meson_gxtvbb_cpu())) {
+	if ((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+		(cvd2->vd_port == TVIN_PORT_CVBS0)) {
 
 		W_APB_BIT(CVD2_NON_STANDARD_SIGNAL_THRESHOLD, 3,
 				HNON_STD_TH_BIT, HNON_STD_TH_WID);
 	}
 #elif defined(CONFIG_TVIN_TUNER_HTM9AW125)
-	if ((((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+	if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
 		(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-		(is_meson_gxtvbb_cpu())) &&
 		(cvd2->config_fmt == TVIN_SIG_FMT_CVBS_NTSC_M)) {
 
 		W_APB_BIT(ACD_REG_1B , 0xc, YCSEP_TEST6F_BIT, YCSEP_TEST6F_WID);
@@ -471,9 +515,8 @@ static void tvafe_cvd2_write_mode_reg(struct tvafe_cvd2_s *cvd2,
 #endif
 
 	/* add for board e04&e08  */
-	if ((((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+	if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
 		(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-		(is_meson_gxtvbb_cpu())) &&
 		(cvd_reg07_pal != 0x03)
 		&& (cvd2->config_fmt == TVIN_SIG_FMT_CVBS_PAL_I))
 		W_APB_REG(CVD2_OUTPUT_CONTROL, cvd_reg07_pal);
@@ -523,9 +566,8 @@ static void tvafe_cvd2_non_std_config(struct tvafe_cvd2_s *cvd2)
 		}
 
 #ifdef CONFIG_AM_SI2176
-		if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
-			(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-			(is_meson_gxtvbb_cpu())) {
+		if ((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+			(cvd2->vd_port == TVIN_PORT_CVBS0)) {
 
 			W_APB_BIT(CVD2_NON_STANDARD_SIGNAL_THRESHOLD, 3,
 					HNON_STD_TH_BIT, HNON_STD_TH_WID);
@@ -567,9 +609,8 @@ static void tvafe_cvd2_non_std_config(struct tvafe_cvd2_s *cvd2)
 		W_APB_REG(TVFE_CLAMP_INTF, 0x8000);
 		W_APB_BIT(CVD2_H_LOOP_MAXSTATE, 4,
 			HSTATE_MAX_BIT, HSTATE_MAX_WID);
-		if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
-			(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-			(is_meson_gxtvbb_cpu())) {
+		if ((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+			(cvd2->vd_port == TVIN_PORT_CVBS0)) {
 
 #if ((defined CONFIG_AM_R840) || (defined CONFIG_AM_MXL661))
 			W_APB_BIT(CVD2_VSYNC_SIGNAL_THRESHOLD, 0,
@@ -600,9 +641,8 @@ static void tvafe_cvd2_non_std_config(struct tvafe_cvd2_s *cvd2)
 		W_APB_REG(TVFE_CLAMP_INTF, 0x8666);
 		W_APB_BIT(CVD2_H_LOOP_MAXSTATE, 5,
 			HSTATE_MAX_BIT, HSTATE_MAX_WID);
-		if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
-			(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-			(is_meson_gxtvbb_cpu())) {
+		if ((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+			(cvd2->vd_port == TVIN_PORT_CVBS0)) {
 
 
 #ifdef CVD_SI2176_RSSI
@@ -659,7 +699,7 @@ static void tvafe_cvd2_non_std_config(struct tvafe_cvd2_s *cvd2)
 inline void tvafe_cvd2_reset_pga(void)
 {
 	/* reset pga value */
-	if (is_meson_gxtvbb_cpu())
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
 		W_APB_BIT(TVFE_VAFE_CTRL1, pga_default_vale,
 			VAFE_PGA_GAIN_BIT, VAFE_PGA_GAIN_WID);
 	else {
@@ -1439,9 +1479,8 @@ static bool tvafe_cvd2_condition_shift(struct tvafe_cvd2_s *cvd2)
 			}
 		}
 	}
-	if ((((cvd2->vd_port == TVIN_PORT_CVBS3) ||
+	if (((cvd2->vd_port == TVIN_PORT_CVBS3) ||
 		(cvd2->vd_port == TVIN_PORT_CVBS0)) &&
-		(is_meson_gxtvbb_cpu())) &&
 		force_fmt_flag) {
 		if (cvd_dbg_en)
 			pr_info("[%s]:ignore the pal/358/443 flag and return\n",
@@ -2125,7 +2164,7 @@ inline void tvafe_cvd2_adj_pga(struct tvafe_cvd2_s *cvd2)
 
 		cvd2->info.dgain_cnt = TVAFE_SET_CVBS_PGA_START;
 	}
-	if (is_meson_gxtvbb_cpu()) {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
 		if (cvd2->info.dgain_cnt == TVAFE_SET_CVBS_PGA_START) {
 
 			cvd2->info.dgain_cnt = 0;
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_general.c b/drivers/amlogic/tvin/tvafe/tvafe_general.c
index 81eebf4..9f0da81 100644
--- a/drivers/amlogic/tvin/tvafe/tvafe_general.c
+++ b/drivers/amlogic/tvin/tvafe/tvafe_general.c
@@ -18,6 +18,15 @@
 
 /* edid config reg value */
 #define TVAFE_EDID_CONFIG           0x03804050/* 0x03800050 */
+
+/* adc pll ctl, atv demod & tvafe use the same adc module
+ * module index: atv demod:0x01; tvafe:0x2
+*/
+#define ADC_EN_ATV_DEMOD	0x1
+#define ADC_EN_TVAFE		0x2
+
+static unsigned int adc_pll_chg;
+
 #if 0
 /* calibration defines */
 #define TVAFE_ADC_CAL_STEP_GAIN     1
@@ -911,7 +920,7 @@ static enum tvafe_adc_ch_e tvafe_adc_pin_muxing(
 					enum tvafe_adc_pin_e pin)
 {
 	enum tvafe_adc_ch_e ret = TVAFE_ADC_CH_NULL;
-	if (is_meson_gxtvbb_cpu()) {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
 		pr_info("[tvafe]%s:pin:%d\n", __func__, (unsigned int)pin);
 		if (pin == TVAFE_CVBS_IN0) {
 
@@ -1131,8 +1140,7 @@ int tvafe_set_source_muxing(enum tvin_port_e port,
 	switch (port) {
 
 	case TVIN_PORT_CVBS0:
-		if (is_meson_gxtvbb_cpu())
-			tvafe_adc_pin_muxing(pinmux->pin[CVBS_IN0]);
+		tvafe_adc_pin_muxing(pinmux->pin[CVBS_IN0]);
 #if 0
 		else {
 			if (
@@ -1157,8 +1165,7 @@ int tvafe_set_source_muxing(enum tvin_port_e port,
 #endif
 		break;
 	case TVIN_PORT_CVBS1:
-		if (is_meson_gxtvbb_cpu())
-				tvafe_adc_pin_muxing(pinmux->pin[CVBS_IN1]);
+		tvafe_adc_pin_muxing(pinmux->pin[CVBS_IN1]);
 #if 0
 		else {
 			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS1_Y]) ==
@@ -1180,8 +1187,7 @@ int tvafe_set_source_muxing(enum tvin_port_e port,
 #endif
 		break;
 	case TVIN_PORT_CVBS2:
-		if (is_meson_gxtvbb_cpu())
-			tvafe_adc_pin_muxing(pinmux->pin[CVBS_IN2]);
+		tvafe_adc_pin_muxing(pinmux->pin[CVBS_IN2]);
 #if 0
 		else {
 			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS2_Y]) ==
@@ -1203,8 +1209,7 @@ int tvafe_set_source_muxing(enum tvin_port_e port,
 #endif
 		break;
 	case TVIN_PORT_CVBS3:
-		if (is_meson_gxtvbb_cpu())
-			tvafe_adc_pin_muxing(pinmux->pin[CVBS_IN3]);
+		tvafe_adc_pin_muxing(pinmux->pin[CVBS_IN3]);
 #if 0
 		else {
 			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS3_Y]) ==
@@ -3990,15 +3995,27 @@ static void tvafe_set_cvbs_default(struct tvafe_cvd2_s *cvd2,
 #endif
 	/*config adc*/
 	if (port == TVIN_PORT_CVBS3) {
-		/** DADC CNTL for LIF signal input **/
-		W_HIU_REG(HHI_DADC_CNTL, 0x1411036);
-		W_HIU_REG(HHI_DADC_CNTL2, 0x0);
-		W_HIU_REG(HHI_DADC_CNTL3, 0x430036);
-		W_HIU_REG(HHI_DADC_CNTL4, 0x80600240);
+		if (is_meson_txl_cpu()) {
+			/** DADC CNTL for LIF signal input **/
+			W_HIU_REG(HHI_DADC_CNTL, 0x00102038);
+			W_HIU_REG(HHI_DADC_CNTL2, 0x00000406);
+			W_HIU_REG(HHI_DADC_CNTL3, 0x00082183);
+		} else {
+			/** DADC CNTL for LIF signal input **/
+			W_HIU_REG(HHI_DADC_CNTL, 0x1411036);
+			W_HIU_REG(HHI_DADC_CNTL2, 0x0);
+			W_HIU_REG(HHI_DADC_CNTL3, 0x430036);
+			W_HIU_REG(HHI_DADC_CNTL4, 0x80600240);
+		}
 	} else{
-		/** CADC CNTL for LIF signal input **/
-		W_HIU_REG(HHI_CADC_CNTL, 0x8022436);
-		W_HIU_REG(HHI_CADC_CNTL2, 0x848000);
+		if (is_meson_txl_cpu()) {
+			W_HIU_REG(HHI_CADC_CNTL, 0x02000A08);
+			W_HIU_REG(HHI_CADC_CNTL2, 0x04007B05);
+		} else if (is_meson_gxtvbb_cpu()) {
+			/** CADC CNTL for LIF signal input **/
+			W_HIU_REG(HHI_CADC_CNTL, 0x8022436);
+			W_HIU_REG(HHI_CADC_CNTL2, 0x848000);
+		}
 	}
 	/** enable tv_decoder mem clk **/
 	W_HIU_BIT(HHI_VPU_CLK_CNTL, 1 , 28, 1);
@@ -4010,7 +4027,7 @@ static void tvafe_set_cvbs_default(struct tvafe_cvd2_s *cvd2,
 			cvbs_top_reg_default[i][1]);
 		i++;
 	}
-	if (is_meson_gxtvbb_cpu()) {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
 		W_APB_REG(TVFE_VAFE_CTRL0, 0x00090b00);
 		W_APB_REG(TVFE_VAFE_CTRL1, 0x00000110);
 		W_APB_REG(TVFE_VAFE_CTRL2, 0x0010ef93);
@@ -4046,10 +4063,7 @@ static void tvafe_set_cvbs_default(struct tvafe_cvd2_s *cvd2,
 
 void tvafe_enable_avout(enum tvin_port_e port, bool enable)
 {
-	int chip_ver = 0;
-
-	if (is_meson_gxtvbb_cpu()) {
-		chip_ver = get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR);
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
 		if (enable) {
 			if (port == TVIN_PORT_CVBS3) {
 				vdac_enable(1, 0x1);
@@ -4082,6 +4096,86 @@ void tvafe_enable_avout(enum tvin_port_e port, bool enable)
 #endif
 	}
 }
+
+void adc_set_pll_cntl(bool on, unsigned int module_sel)
+{
+	mutex_lock(&pll_mutex);
+	if (!on) {
+		adc_pll_chg &= ~module_sel;
+		/* pr_info("\n%s: init flag on:%d,module:0x%x,flag:0x%x...\n",
+			__func__, on, module_sel, adc_pll_chg); */
+		mutex_unlock(&pll_mutex);
+		return;
+	}
+
+	switch (module_sel) {
+	case ADC_EN_ATV_DEMOD: /* atv demod */
+		if (adc_pll_chg & ADC_EN_TVAFE)
+			break;
+		if (is_meson_txl_cpu()) {
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+			W_HIU_REG(HHI_ADC_PLL_CNTL, 0x30f14250);
+			W_HIU_REG(HHI_ADC_PLL_CNTL1, 0x22000442);
+			/*0x5ba00380 from pll;0x5ba00384 clk
+			form crystal*/
+			W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x5ba00384);
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+			W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02913004);
+			W_HIU_REG(HHI_ADC_PLL_CNTL5, 0x00034a00);
+			W_HIU_REG(HHI_ADC_PLL_CNTL6, 0x00005000);
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca6a2110);
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+		} else {
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca2a2110);
+			W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x2933800);
+			W_HIU_REG(HHI_ADC_PLL_CNTL, 0xe0644220);
+			W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x34e0bf84);
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a2a2110);
+			/* TVFE reset */
+			W_HIU_BIT(RESET1_REGISTER, 1, 7, 1);
+		}
+		adc_pll_chg |= ADC_EN_ATV_DEMOD;
+		/* pr_info("\n%s: on:%d,module:0x%x,flag:0x%x...\n", __func__,
+			on, module_sel, adc_pll_chg); */
+		break;
+	case ADC_EN_TVAFE: /* tvafe */
+		if (adc_pll_chg & ADC_EN_ATV_DEMOD)
+			break;
+		if (is_meson_txl_cpu()) {
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+			W_HIU_REG(HHI_ADC_PLL_CNTL, 0x30f14250);
+			W_HIU_REG(HHI_ADC_PLL_CNTL1, 0x22000442);
+			/*0x5ba00380 from pll;0x5ba00384 clk
+			form crystal*/
+			W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x5ba00384);
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+			W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02913004);
+			W_HIU_REG(HHI_ADC_PLL_CNTL5, 0x00034a00);
+			W_HIU_REG(HHI_ADC_PLL_CNTL6, 0x00005000);
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca6a2110);
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
+		} else {
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca2a2110);
+			W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x2933800);
+			W_HIU_REG(HHI_ADC_PLL_CNTL, 0xe0644220);
+			W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x34e0bf84);
+			W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a2a2110);
+			/* TVFE reset */
+			W_HIU_BIT(RESET1_REGISTER, 1, 7, 1);
+		}
+		adc_pll_chg |= ADC_EN_TVAFE;
+		/* pr_info("\n%s: on:%d,module:0x%x,flag:0x%x...\n", __func__,
+			on, module_sel, adc_pll_chg); */
+		break;
+	default:
+		pr_err("%s:module: 0x%x wrong module index !! ",
+			__func__, module_sel);
+		break;
+	}
+	mutex_unlock(&pll_mutex);
+}
+EXPORT_SYMBOL(adc_set_pll_cntl);
+
 /*
  * tvafe init the whole module
  */
@@ -4136,8 +4230,7 @@ void tvafe_init_reg(struct tvafe_cvd2_s *cvd2,
 #endif
 		if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_CVBS7)) {
 #if (defined(CONFIG_ADC_DOUBLE_SAMPLING_FOR_CVBS) && defined(CRYSTAL_24M))
-			if (is_meson_gxtvbb_cpu()
-				&& (port != TVIN_PORT_CVBS3)
+			if ((port != TVIN_PORT_CVBS3)
 				&& (port != TVIN_PORT_CVBS0)) {
 				W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xa92a2110);
 				W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02973800);
@@ -4146,13 +4239,7 @@ void tvafe_init_reg(struct tvafe_cvd2_s *cvd2,
 				W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x292a2110);
 			} else
 #endif
-			{
-				W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xce7a2110);
-				W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x2933800);
-				W_HIU_REG(HHI_ADC_PLL_CNTL, 0x0484680);
-				W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x34e0bf84);
-				W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4e7a2110);
-			}
+			adc_set_pll_cntl(1, 0x2);
 		}
 		tvafe_set_cvbs_default(cvd2, mem, port, pinmux);
 		/*turn on/off av out*/
@@ -4237,6 +4324,8 @@ void tvafe_enable_module(bool enable)
 		W_HIU_REG(HHI_VAFE_CLKIN_CNTL, 0);
 		W_HIU_REG(HHI_VAFE_CLKPI_CNTL, 0);
 		W_HIU_REG(HHI_TVFE_AUTOMODE_CLK_CNTL, 0);
+		/* init adc pll flag */
+		adc_set_pll_cntl(0, 0x2);
 	}
 	/* adc bandgap, the adc ref signal for demod */
 	/*if (enable)
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_general.h b/drivers/amlogic/tvin/tvafe/tvafe_general.h
index 1e598fe..22888a5 100644
--- a/drivers/amlogic/tvin/tvafe/tvafe_general.h
+++ b/drivers/amlogic/tvin/tvafe/tvafe_general.h
@@ -18,6 +18,8 @@
 #define HHI_VID_CLK_CNTL2			0x1065
 #define HHI_VID_DIVIDER_CNTL			0x1066
 
+#define RESET1_REGISTER				0x1102
+
 #define VENC_VDAC_DACSEL0			0x1b78
 #define P_VENC_VDAC_DACSEL0		VCBUS_REG_ADDR(VENC_VDAC_DACSEL0)
 #define VENC_VDAC_DACSEL1			0x1b79
@@ -95,6 +97,12 @@
 #define P_HHI_ADC_PLL_CNTL3			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL3)
 #define HHI_ADC_PLL_CNTL4			0x10ad
 #define P_HHI_ADC_PLL_CNTL4			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL4)
+#define HHI_ADC_PLL_CNTL5			0x109e
+#define P_HHI_ADC_PLL_CNTL5			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL5)
+#define HHI_ADC_PLL_CNTL6			0x109f
+#define P_HHI_ADC_PLL_CNTL6			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL6)
+#define HHI_ADC_PLL_CNTL1			0x10af
+#define P_HHI_ADC_PLL_CNTL1			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL1)
 #define HHI_GCLK_OTHER              0x1054
 
 
@@ -203,5 +211,7 @@ extern void tvafe_enable_avout(enum tvin_port_e port, bool enable);
 */
 void vdac_enable(bool on, unsigned int module_sel);
 
+extern struct mutex pll_mutex;
+
 #endif  /* _TVAFE_GENERAL_H */
 
diff --git a/drivers/amlogic/tvin/vdin/vdin_canvas.c b/drivers/amlogic/tvin/vdin/vdin_canvas.c
index 53fbc7c..2267035 100644
--- a/drivers/amlogic/tvin/vdin/vdin_canvas.c
+++ b/drivers/amlogic/tvin/vdin/vdin_canvas.c
@@ -186,11 +186,21 @@ void vdin_canvas_auto_config(struct vdin_dev_s *devp)
 		canvas_num = canvas_num/2;
 		canvas_step = 2;
 	} else{/*YUV422*/
-		if (devp->source_bitdepth > 8)
+		/* txl new add yuv422 pack mode:canvas-w=h*2*10/8*/
+		if ((devp->source_bitdepth > 8) &&
+		((devp->format_convert == VDIN_FORMAT_CONVERT_YUV_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_RGB_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_GBR_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_BRG_YUV422)) &&
+		(devp->color_depth_mode == 1))
+			devp->canvas_w = (devp->h_active * 5)/2;
+		else if ((devp->source_bitdepth > 8) &&
+			(devp->color_depth_mode == 0))
 			devp->canvas_w = devp->h_active * 3;
 		else
 			devp->canvas_w = devp->h_active * 2;
 	}
+	/*canvas_w must ensure divided exact by 256bit(32byte)*/
 	devp->canvas_w = roundup(devp->canvas_w, 32);
 	devp->canvas_h = devp->v_active;
 
diff --git a/drivers/amlogic/tvin/vdin/vdin_ctl.c b/drivers/amlogic/tvin/vdin/vdin_ctl.c
index 381e7bd..55064e1 100644
--- a/drivers/amlogic/tvin/vdin/vdin_ctl.c
+++ b/drivers/amlogic/tvin/vdin/vdin_ctl.c
@@ -113,7 +113,7 @@ static unsigned int delay_line_num;
 module_param(delay_line_num, uint, 0644);
 MODULE_PARM_DESC(delay_line_num, "delay_line_num");
 
-bool enable_reset = 1;
+bool enable_reset;
 module_param(enable_reset, bool, 0664);
 MODULE_PARM_DESC(enable_reset, "enable_reset");
 static int vsync_reset_mask;
@@ -680,9 +680,14 @@ static inline void vdin_set_top(unsigned int offset,
 		wr_bits(offset, VDIN_ASFIFO_CTRL2, 0xe4,
 				VDI5_ASFIFO_CTRL_BIT, VDI5_ASFIFO_CTRL_WID);
 		break;
+	case 0xa0:
 	case 0xc0: /* viu */
 		vdin_mux = VDIN_MUX_VIU;
-		wr_bits(offset, VDIN_ASFIFO_CTRL3, 0xf4,
+		if (port == TVIN_PORT_VIDEO)
+			wr_bits(offset, VDIN_ASFIFO_CTRL3, 0xe4,
+				VDI6_ASFIFO_CTRL_BIT, VDI6_ASFIFO_CTRL_WID);
+		else
+			wr_bits(offset, VDIN_ASFIFO_CTRL3, 0xf4,
 				VDI6_ASFIFO_CTRL_BIT, VDI6_ASFIFO_CTRL_WID);
 		break;
 	case 0x100:/* mipi in mybe need modify base on truth */
@@ -779,6 +784,12 @@ void vdin_set_decimation(struct vdin_dev_s *devp)
 	return;
 }
 
+void vdin_fix_nonstd_vsync(struct vdin_dev_s *devp)
+{
+	unsigned int offset = devp->addr_offset;
+	wr_bits(offset, VDIN_INTF_WIDTHM1, 3, 24, 2);
+}
+
 /*
    this fucntion will set the bellow parameters of devp:
    1.h_active
@@ -820,6 +831,14 @@ void vdin_set_cutwin(struct vdin_dev_s *devp)
 
 }
 
+void vdin_set_config(struct vdin_dev_s *devp)
+{
+	if (is_meson_gxbb_cpu() || is_meson_gxm_cpu() || is_meson_gxl_cpu())
+		/* max pixel clk of vdin for gxbb/gxm/gxl */
+		devp->vdin_max_pixelclk = 248832000; /* 2160p30hz*/
+	else
+		devp->vdin_max_pixelclk = 497664000; /* 2160p60hz*/
+}
 
 
 static inline void vdin_set_color_matrix1(unsigned int offset,
@@ -1274,7 +1293,8 @@ static inline void vdin_set_hist_mux(struct vdin_dev_s *devp)
 }
 
 static inline void vdin_set_wr_ctrl(unsigned int offset, unsigned int v,
-		unsigned int h, enum vdin_format_convert_e format_convert)
+		unsigned int h, enum vdin_format_convert_e format_convert,
+		unsigned int color_depth_mode, unsigned int source_bitdeth)
 {
 	unsigned int write_format444 = 0, swap_cbcr = 0;
 	/* unsigned int def_canvas_id = offset?
@@ -1299,6 +1319,13 @@ static inline void vdin_set_wr_ctrl(unsigned int offset, unsigned int v,
 		write_format444 = 1;
 		break;
 	}
+	/*yuv422 full pack mode for 10bit*/
+	if (((format_convert == VDIN_FORMAT_CONVERT_YUV_YUV422) ||
+		(format_convert == VDIN_FORMAT_CONVERT_RGB_YUV422) ||
+		(format_convert == VDIN_FORMAT_CONVERT_GBR_YUV422) ||
+		(format_convert == VDIN_FORMAT_CONVERT_BRG_YUV422)) &&
+		color_depth_mode && (source_bitdeth > 8))
+		write_format444 = 3;
 
 	/* win_he */
 	wr_bits(offset, VDIN_WR_H_START_END, (h - 1), WR_HEND_BIT, WR_HEND_WID);
@@ -1837,7 +1864,8 @@ void vdin_set_all_regs(struct vdin_dev_s *devp)
 	vdin_set_hist_mux(devp);
 	/* write sub-module */
 	vdin_set_wr_ctrl(devp->addr_offset, devp->v_active,
-			devp->h_active, devp->format_convert);
+			devp->h_active, devp->format_convert,
+			devp->color_depth_mode, devp->source_bitdepth);
 
 	/* top sub-module */
 	vdin_set_top(devp->addr_offset, devp->parm.port,
@@ -1988,7 +2016,7 @@ void vdin_set_default_regmap(unsigned int offset)
 	/* [11: 0]       write.lfifo_buf_size   = 0x100 */
 	if (is_meson_g9tv_cpu() || is_meson_m8_cpu() ||
 		is_meson_m8m2_cpu() || is_meson_m8b_cpu() ||
-		is_meson_gxtvbb_cpu())
+		is_meson_gxtvbb_cpu() || is_meson_txl_cpu())
 		wr(offset, VDIN_LFIFO_CTRL,     0x00000f00);
 	else
 		wr(offset, VDIN_LFIFO_CTRL,     0x00000780);
@@ -2033,6 +2061,12 @@ void vdin_set_default_regmap(unsigned int offset)
 		DISCARD_BEF_LINE_FIFO_BIT, DISCARD_BEF_LINE_FIFO_WID);
 	wr_bits(offset, VDIN_WR_CTRL2, vdin_wr_burst_mode,
 		VDIN_WR_BURST_MODE_BIT, VDIN_WR_BURST_MODE_WID);
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		wr_bits(offset, VDIN_WR_CTRL2, 1,
+			VDIN_WR_DATA_EXT_EN_BIT, VDIN_WR_DATA_EXT_EN_WID);
+	else
+		wr_bits(offset, VDIN_WR_CTRL2, 0,
+			VDIN_WR_DATA_EXT_EN_BIT, VDIN_WR_DATA_EXT_EN_WID);
 	/* [20:25] interger = 0 */
 	/* [0:19] fraction = 0 */
 	wr(offset, VDIN_VSC_PHASE_STEP, 0x0000000);
@@ -2253,7 +2287,7 @@ int vdin_vsync_reset_mif(int index)
 
 		vpu_reg_27af |= VDIN0_REQ_EN_BIT;
 	} else if (index == 1) {
-		W_VCBUS_BIT(VDIN1_WR_CTRL, 0, 25, 1); /* vdin->vdin mif wr en */
+		W_VCBUS_BIT(VDIN1_WR_CTRL2, 1, 8, 1); /* vdin->vdin mif wr en */
 		W_VCBUS_BIT(VDIN1_WR_CTRL, 1, 29, 1); /* clock gate */
 		/* wr req en */
 		W_VCBUS_BIT(VDIN1_WR_CTRL, 0, WR_REQ_EN_BIT, WR_REQ_EN_WID);
@@ -2278,7 +2312,7 @@ int vdin_vsync_reset_mif(int index)
 		vpu_reg_27af |= (1 << VDIN1_REQ_EN_BIT);
 		W_VCBUS_BIT(VDIN1_WR_CTRL, 1, WR_REQ_EN_BIT, WR_REQ_EN_WID);
 		W_VCBUS_BIT(VDIN1_WR_CTRL, 0, 29, 1);
-		W_VCBUS_BIT(VDIN1_WR_CTRL, 1, 25, 1);
+		W_VCBUS_BIT(VDIN1_WR_CTRL2, 0, 8, 1);
 	}
 #if 0 /* TODO: if start or end line > 0, should drop this frame! */
 	if ((aml_read_vcbus(VDIN_LCNT_STATUS) & 0xfff) > 0) {
diff --git a/drivers/amlogic/tvin/vdin/vdin_ctl.h b/drivers/amlogic/tvin/vdin/vdin_ctl.h
index eb40815..7d577d6 100644
--- a/drivers/amlogic/tvin/vdin/vdin_ctl.h
+++ b/drivers/amlogic/tvin/vdin/vdin_ctl.h
@@ -144,6 +144,7 @@ extern unsigned int vdin_get_field_type(unsigned int offset);
 extern int vdin_vsync_reset_mif(int index);
 extern void vdin_set_cutwin(struct vdin_dev_s *devp);
 extern void vdin_set_decimation(struct vdin_dev_s *devp);
+extern void vdin_fix_nonstd_vsync(struct vdin_dev_s *devp);
 extern unsigned int vdin_get_meas_hcnt64(unsigned int offset);
 extern unsigned int vdin_get_meas_vstamp(unsigned int offset);
 extern unsigned int vdin_get_active_h(unsigned int offset);
@@ -178,6 +179,7 @@ extern void vdin_set_cm2(unsigned int offset, unsigned int w,
 extern void vdin_bypass_isp(unsigned int offset);
 extern void vdin_set_mpegin(struct vdin_dev_s *devp);
 extern void vdin_force_gofiled(struct vdin_dev_s *devp);
+extern void vdin_set_config(struct vdin_dev_s *devp);
 
 #endif
 
diff --git a/drivers/amlogic/tvin/vdin/vdin_debug.c b/drivers/amlogic/tvin/vdin/vdin_debug.c
index a21d736..5aa65c9 100755
--- a/drivers/amlogic/tvin/vdin/vdin_debug.c
+++ b/drivers/amlogic/tvin/vdin/vdin_debug.c
@@ -145,7 +145,7 @@ static ssize_t vdin_attr_show(struct device *dev,
 	len += sprintf(buf+len,
 		"/sys/class/vdin/vdinx/attr.\n");
 	len += sprintf(buf+len,
-		"echo v4l2start bt656/viuin/isp h_actve v_active");
+		"echo v4l2start bt656/viuin/video/isp h_actve v_active");
 	len += sprintf(buf+len,
 		"frame_rate cfmt dfmt scan_fmt > /sys/class/vdin/vdinx/attr.\n");
 	len += sprintf(buf+len,
@@ -171,6 +171,11 @@ static void vdin_dump_mem(char *path, struct vdin_dev_s *devp)
 		pr_info(KERN_ERR"create %s error.\n", path);
 		return;
 	}
+	if ((devp->cma_config_flag == 1) &&
+		(devp->cma_mem_alloc[devp->index] == 0)) {
+		pr_info("%s:no cma alloc mem!!!\n", __func__);
+		return;
+	}
 
 	for (i = 0; i < devp->canvas_max_num; i++) {
 		pos = canvas_real_size * i;
@@ -238,6 +243,7 @@ static void vdin_dump_state(struct vdin_dev_s *devp)
 	pr_info("frontend_colordepth:%d\n", devp->prop.colordepth);
 	pr_info("source_bitdepth:%d\n", devp->source_bitdepth);
 	pr_info("color_depth_config:%d\n", devp->color_depth_config);
+	pr_info("color_depth_mode:%d\n", devp->color_depth_mode);
 	pr_info("color_depth_support:0x%x\n", devp->color_depth_support);
 	pr_info("cma_flag:%d\n", devp->cma_config_flag);
 	vdin_dump_vf_state(devp->vfp);
@@ -560,6 +566,9 @@ start_chk:
 		} else if (!strcmp(parm[1], "viuin")) {
 			param.port = TVIN_PORT_VIU;
 			pr_info(" port is TVIN_PORT_VIU\n");
+		} else if (!strcmp(parm[1], "video")) {
+			param.port = TVIN_PORT_VIDEO;
+			pr_info(" port is TVIN_PORT_VIDEO\n");
 		} else if (!strcmp(parm[1], "isp")) {
 			param.port = TVIN_PORT_ISP;
 			pr_info(" port is TVIN_PORT_ISP\n");
@@ -838,6 +847,12 @@ start_chk:
 		devp->color_depth_config = val;
 		pr_info("color_depth(%d):%d\n\n", devp->index,
 			devp->color_depth_config);
+	} else if (!strcmp(parm[0], "color_depth_mode")) {
+		if (kstrtoul(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		devp->color_depth_mode = val;
+		pr_info("color_depth_mode(%d):%d\n\n", devp->index,
+			devp->color_depth_mode);
 	} else {
 		/* pr_info("parm[0]:%s [1]:%s [2]:%s [3]:%s\n", */
 		/* parm[0],parm[1],parm[2],parm[3]); */
diff --git a/drivers/amlogic/tvin/vdin/vdin_drv.c b/drivers/amlogic/tvin/vdin/vdin_drv.c
index 5be7baa..b4fea9f 100644
--- a/drivers/amlogic/tvin/vdin/vdin_drv.c
+++ b/drivers/amlogic/tvin/vdin/vdin_drv.c
@@ -315,7 +315,7 @@ static const struct vframe_operations_s vdin_vf_ops = {
 void vdin_cma_alloc(struct vdin_dev_s *devp)
 {
 	char vdin_name[5];
-	unsigned int mem_size;
+	unsigned int mem_size, h_size;
 	int flags = CODEC_MM_FLAGS_CMA_FIRST|CODEC_MM_FLAGS_CMA_CLEAR|
 		CODEC_MM_FLAGS_CPU;
 	if ((devp->format_convert == VDIN_FORMAT_CONVERT_YUV_YUV444) ||
@@ -323,17 +323,26 @@ void vdin_cma_alloc(struct vdin_dev_s *devp)
 		(devp->format_convert == VDIN_FORMAT_CONVERT_RGB_YUV444) ||
 		(devp->format_convert == VDIN_FORMAT_CONVERT_RGB_RGB)) {
 		if (devp->source_bitdepth > 8)
-			mem_size = devp->h_active * devp->v_active * 4;
+			h_size = roundup(devp->h_active * 4, 32);
 		else
-			mem_size = devp->h_active * devp->v_active * 3;
+			h_size = roundup(devp->h_active * 3, 32);
 	} else {
-		if (devp->source_bitdepth > 8)
-			mem_size = devp->h_active * devp->v_active * 3;
+		/* txl new add mode yuv422 pack mode:canvas-w=h*2*10/8
+		*canvas_w must ensure divided exact by 256bit(32byte*/
+		if ((devp->source_bitdepth > 8) &&
+		((devp->format_convert == VDIN_FORMAT_CONVERT_YUV_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_RGB_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_GBR_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_BRG_YUV422)) &&
+		(devp->color_depth_mode == 1))
+			h_size = roundup((devp->h_active * 5)/2, 32);
+		else if ((devp->source_bitdepth > 8) &&
+			(devp->color_depth_mode == 0))
+			h_size = roundup(devp->h_active * 3, 32);
 		else
-			mem_size = devp->h_active * devp->v_active * 2;
+			h_size = roundup(devp->h_active * 2, 32);
 	}
-	if (devp->source_bitdepth > 8)
-		mem_size = mem_size*3/2;
+	mem_size = h_size * devp->v_active;
 	mem_size = PAGE_ALIGN(mem_size)*max_buf_num;
 	mem_size = (mem_size/PAGE_SIZE + 1)*PAGE_SIZE;
 	if (mem_size > devp->cma_mem_size[devp->index])
@@ -678,6 +687,12 @@ static inline void vdin_set_source_bitdepth(struct vdin_dev_s *devp,
 		vf->bitdepth = BITDEPTH_Y8 | BITDEPTH_U8 | BITDEPTH_V8;
 		break;
 	}
+	if (devp->color_depth_mode && (devp->source_bitdepth > 8) &&
+		((devp->format_convert == VDIN_FORMAT_CONVERT_YUV_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_RGB_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_GBR_YUV422) ||
+		(devp->format_convert == VDIN_FORMAT_CONVERT_BRG_YUV422)))
+		vf->bitdepth |= FULL_PACK_422_MODE;
 }
 
 /*
@@ -830,8 +845,11 @@ void vdin_start_dec(struct vdin_dev_s *devp)
 	vdin_set_decimation(devp);
 	vdin_set_cutwin(devp);
 	vdin_set_hvscale(devp);
-	if (is_meson_gxtvbb_cpu())
+	if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu())
 		vdin_set_bitdepth(devp);
+	/* txl new add fix for hdmi switch resolution cause cpu holding */
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL)
+		vdin_fix_nonstd_vsync(devp);
 
 #ifdef CONFIG_AML_RDMA
 	if (rdma_enable && devp->rdma_handle > 0)
@@ -1050,6 +1068,9 @@ int start_tvin_service(int no , struct vdin_parm_s  *para)
 		devp->fmt_info_p->vs_bp     = para->vs_bp;
 		devp->fmt_info_p->hs_pol    = para->hsync_phase;
 		devp->fmt_info_p->vs_pol    = para->vsync_phase;
+		if ((para->h_active * para->v_active * para->frame_rate)
+					> devp->vdin_max_pixelclk)
+				para->h_active >>= 1;
 		devp->fmt_info_p->h_active  = para->h_active;
 		devp->fmt_info_p->v_active  = para->v_active;
 		devp->fmt_info_p->scan_mode = para->scan_mode;
@@ -1989,6 +2010,19 @@ static int vdin_release(struct inode *inode, struct file *file)
 	}
 
 	devp->flags &= (~VDIN_FLAG_FS_OPENED);
+	if (devp->flags & VDIN_FLAG_DEC_STARTED) {
+		devp->flags |= VDIN_FLAG_DEC_STOP_ISR;
+		vdin_stop_dec(devp);
+		/* init flag */
+		devp->flags &= ~VDIN_FLAG_DEC_STOP_ISR;
+		/* clear the flag of decode started */
+		devp->flags &= (~VDIN_FLAG_DEC_STARTED);
+	}
+	if (devp->flags & VDIN_FLAG_DEC_OPENED) {
+		vdin_close_fe(devp);
+		devp->flags &= (~VDIN_FLAG_DEC_OPENED);
+	}
+	devp->flags &= (~VDIN_FLAG_SNOW_FLAG);
 
 	/* free irq */
 	free_irq(devp->irq, (void *)devp);
@@ -2632,6 +2666,10 @@ static int vdin_drv_probe(struct platform_device *pdev)
 		vdevp->color_depth_support = bit_mode;
 		vdevp->color_depth_config = 0;
 	}
+	if (vdevp->color_depth_support&VDIN_WR_COLOR_DEPTH_10BIT_FULL_PCAK_MODE)
+		vdevp->color_depth_mode = 1;
+	else
+		vdevp->color_depth_mode = 0;
 	#endif
 	vdevp->irq = res->start;
 	snprintf(vdevp->irq_name, sizeof(vdevp->irq_name),
@@ -2653,8 +2691,19 @@ static int vdin_drv_probe(struct platform_device *pdev)
 
 	vdevp->flags = 0;
 
+	/*mif reset patch for vdin wr ram bug on gxtvbb*/
+	if (is_meson_gxtvbb_cpu())
+		enable_reset = 1;
+	else
+		enable_reset = 0;
+
 	/* create vf pool */
 	vdevp->vfp = vf_pool_alloc(VDIN_CANVAS_MAX_CNT);
+	if (vdevp->vfp == NULL) {
+		pr_err("%s: fail to alloc vf pool.\n", __func__);
+		goto fail_alloc_vf_pool;
+	}
+
 
 	/* init vframe provider */
 	/* @todo provider name */
@@ -2668,6 +2717,9 @@ static int vdin_drv_probe(struct platform_device *pdev)
 	dev_set_drvdata(vdevp->dev, vdevp);
 	platform_set_drvdata(pdev, vdevp);
 
+	/* set max pixel clk of vdin */
+	vdin_set_config(vdevp);
+
 	/* vdin measure clock */
 	if (is_meson_gxbb_cpu()) {
 		struct clk *clk;
@@ -2731,6 +2783,7 @@ static int vdin_drv_probe(struct platform_device *pdev)
 	pr_info("%s: driver initialized ok\n", __func__);
 	return 0;
 
+fail_alloc_vf_pool:
 fail_get_resource_irq:
 fail_create_dev_file:
 	vdin_delete_device(vdevp->index);
diff --git a/drivers/amlogic/tvin/vdin/vdin_drv.h b/drivers/amlogic/tvin/vdin/vdin_drv.h
index d99d043..6484b25 100644
--- a/drivers/amlogic/tvin/vdin/vdin_drv.h
+++ b/drivers/amlogic/tvin/vdin/vdin_drv.h
@@ -50,7 +50,7 @@
 #include "vdin_vf.h"
 #include "vdin_regs.h"
 
-#define VDIN_VER "Ref.2016/06/17a"
+#define VDIN_VER "Ref.2016/08/12a"
 
 /*the counter of vdin*/
 #define VDIN_MAX_DEVS			2
@@ -97,6 +97,8 @@
 #define VDIN_WR_COLOR_DEPTH_9BIT	(1 << 1)
 #define VDIN_WR_COLOR_DEPTH_10BIT	(1 << 2)
 #define VDIN_WR_COLOR_DEPTH_12BIT	(1 << 3)
+/*TXL new add*/
+#define VDIN_WR_COLOR_DEPTH_10BIT_FULL_PCAK_MODE	(1 << 4)
 
 static inline const char *vdin_fmt_convert_str(
 		enum vdin_format_convert_e fmt_cvt)
@@ -147,7 +149,7 @@ struct vdin_debug_s {
 };
 struct vdin_dev_s {
 	unsigned int			index;
-
+	unsigned int			vdin_max_pixelclk;
 	dev_t					devt;
 	struct cdev				cdev;
 	struct device			*dev;
@@ -252,7 +254,8 @@ struct vdin_dev_s {
 	*bit0:support 8bit
 	*bit1:support 9bit
 	*bit2:support 10bit
-	*bit3:support 12bit*/
+	*bit3:support 12bit
+	*bit4:support yuv422 10bit full pack mode (from txl new add)*/
 	unsigned int			color_depth_support;
 	/*color depth config
 	*0:auto config as frontend
@@ -260,6 +263,10 @@ struct vdin_dev_s {
 	*10:force config as 10bit
 	*12:force config as 12bit*/
 	unsigned int			color_depth_config;
+	/* new add from txl:color depth mode for 10bit
+	*1: full pack mode;config 10bit as 10bit
+	*0: config 10bit as 12bit*/
+	unsigned int			color_depth_mode;
 };
 
 
@@ -271,6 +278,7 @@ int vdin_ctrl_start_fe(int no, struct vdin_parm_s *para);
 int vdin_ctrl_stop_fe(int no);
 enum tvin_sig_fmt_e vdin_ctrl_get_fmt(int no);
 #endif
+extern bool enable_reset;
 extern unsigned int max_buf_num;
 extern unsigned int   vdin_ldim_max_global[100];
 extern struct vframe_provider_s *vf_get_provider_by_name(
diff --git a/drivers/amlogic/tvin/vdin/vdin_regs.h b/drivers/amlogic/tvin/vdin/vdin_regs.h
index 7e55fcb..73c693c 100644
--- a/drivers/amlogic/tvin/vdin/vdin_regs.h
+++ b/drivers/amlogic/tvin/vdin/vdin_regs.h
@@ -37,6 +37,7 @@
 #define VDIN0_MIF_RST_BIT 3
 #define VDIN1_MIF_RST_BIT 4
 #define VDIN_MIF_RST_W 1
+#define VDIN1_WR_CTRL2 0x129f
 #define VDIN1_WR_CTRL 0x12a0
 #define VDIN_COM_CTRL1 0x1282
 
@@ -959,6 +960,10 @@
 /*1: enable WR 10 bit mode, 0: disable WR 10 bit mode */
 #define VDIN_WR_10BIT_MODE_BIT		19
 #define VDIN_WR_10BIT_MODE_WID		1
+/* data_ext_en 1:send out data if req was interrupt by soft reset */
+/* 0:normal mode */
+#define VDIN_WR_DATA_EXT_EN_BIT		18
+#define VDIN_WR_DATA_EXT_EN_WID		1
 /*0: 1 word in 1burst, 1: 2 words in 1burst;
 10: 4 words in 1burst; 11: reserved */
 #define VDIN_WR_BURST_MODE_BIT		12
diff --git a/drivers/amlogic/tvin/vdin/vdin_vf.c b/drivers/amlogic/tvin/vdin/vdin_vf.c
index e0f4ed2..5510f42 100644
--- a/drivers/amlogic/tvin/vdin/vdin_vf.c
+++ b/drivers/amlogic/tvin/vdin/vdin_vf.c
@@ -400,7 +400,7 @@ int vf_pool_init(struct vf_pool *p, int size)
 		}
 		slave->status = VF_STATUS_SL;
 	}
-
+	atomic_set(&p->buffer_cnt, 0);
 #ifdef VF_LOG_EN
 	vf_log_init(p);
 	vf_log(p, VF_OPERATION_INIT, log_state);
@@ -592,7 +592,21 @@ struct vf_entry *receiver_vf_get(struct vf_pool *p)
 	vf_log(p, VF_OPERATION_BGET, true);
 	return vfe;
 }
-
+/*check vf point,0:nornal;1:bad*/
+unsigned int check_vf_put(struct vframe_s *vf, struct vf_pool *p)
+{
+	struct vf_entry *master;
+	unsigned int i;
+	if (!vf || !p)
+		return 1;
+	for (i = 0; i < p->size; i++) {
+		master = vf_get_master(p, i);
+		if (&(master->vf) == vf)
+			return 0;
+	}
+	pr_info("[%s]vf:%p!!!!\n", __func__, vf);
+	return 1;
+}
 void receiver_vf_put(struct vframe_s *vf, struct vf_pool *p)
 {
 	struct vf_entry *master, *slave;
@@ -600,7 +614,8 @@ void receiver_vf_put(struct vframe_s *vf, struct vf_pool *p)
 	struct vf_entry *pos = NULL, *tmp = NULL;
 	int found_in_wt_list = 0;
 
-
+	if (check_vf_put(vf, p))
+		return;
 	master = vf_get_master(p, vf->index);
 	if (master == NULL) {
 		vf_log(p, VF_OPERATION_BPUT, false);
@@ -687,6 +702,7 @@ void receiver_vf_put(struct vframe_s *vf, struct vf_pool *p)
 			vf_log(p, VF_OPERATION_BPUT, true);
 		}
 	}
+	atomic_dec(&p->buffer_cnt);
 }
 
 struct vframe_s *vdin_vf_peek(void *op_arg)
@@ -712,6 +728,7 @@ struct vframe_s *vdin_vf_get(void *op_arg)
 	vfe =  receiver_vf_get(p);
 	if (!vfe)
 		return NULL;
+	atomic_inc(&p->buffer_cnt);
 	return &vfe->vf;
 }
 
@@ -851,6 +868,7 @@ void vdin_dump_vf_state(struct vf_pool *p)
 			pos->vf.canvas1Addr, pos->vf.type);
 	}
 	spin_unlock_irqrestore(&p->tmp_lock, flags);
+	pr_info("buffer get count %d.\n", atomic_read(&p->buffer_cnt));
 
 }
 
diff --git a/drivers/amlogic/tvin/vdin/vdin_vf.h b/drivers/amlogic/tvin/vdin/vdin_vf.h
index badcea3..797d350 100644
--- a/drivers/amlogic/tvin/vdin/vdin_vf.h
+++ b/drivers/amlogic/tvin/vdin/vdin_vf.h
@@ -135,6 +135,7 @@ struct vf_pool {
 #ifdef ISR_LOG_EN
 	struct isr_log_s isr_log;
 #endif
+	atomic_t buffer_cnt;
 };
 
 extern void vf_log_init(struct vf_pool *p);
diff --git a/drivers/amlogic/tvin/viu/viuin.c b/drivers/amlogic/tvin/viu/viuin.c
index 4005333..7ae4f81 100644
--- a/drivers/amlogic/tvin/viu/viuin.c
+++ b/drivers/amlogic/tvin/viu/viuin.c
@@ -53,12 +53,13 @@
 
 
 /* register */
+#define VIU_MISC_CTRL1 0x1a07
 #define VPU_VIU_VENC_MUX_CTRL 0x271a
 #define ENCI_INFO_READ 0x271c
 #define ENCP_INFO_READ 0x271d
 #define ENCT_INFO_READ 0x271e
 #define ENCL_INFO_READ 0x271f
-
+#define VPU_VIU2VDIN_HDN_CTRL 0x2780
 #if 0 /* def CONFIG_GAMMA_AUTO_TUNE */
 
 static bool gamma_tune_en;
@@ -581,7 +582,7 @@ static struct class_attribute gamma_proc_class_attrs[] = {
 #endif
 static int viuin_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
 {
-	if (port == TVIN_PORT_VIU)
+	if (port == TVIN_PORT_VIU || port == TVIN_PORT_VIDEO)
 		return 0;
 	else
 		return -1;
@@ -633,6 +634,19 @@ static int viuin_open(struct tvin_frontend_s *fe, enum tvin_port_e port)
 		break;
 	}
 	viuin_check_venc_line(devp);
+	if (port == TVIN_PORT_VIDEO) {
+		/* enable hsync for vdin loop */
+		wr_bits_viu(VIU_MISC_CTRL1, 1, 28, 1);
+		viu_mux = 0x4;
+	} else {
+		if (is_meson_gxbb_cpu() || is_meson_gxm_cpu() ||
+				is_meson_gxl_cpu()) {
+			if (devp->parm.v_active == 2160 &&
+				devp->parm.frame_rate > 30)
+				/* 1/2 down scaling */
+				wr_viu(VPU_VIU2VDIN_HDN_CTRL, 0x40f00);
+			}
+	}
 	wr_bits_viu(VPU_VIU_VENC_MUX_CTRL, viu_mux, 4, 4);
 	wr_bits_viu(VPU_VIU_VENC_MUX_CTRL, viu_mux, 8, 4);
 	devp->flag = 0;
@@ -652,6 +666,8 @@ static void viuin_close(struct tvin_frontend_s *fe)
 		wr_bits_viu(VPU_VIU_VENC_MUX_CTRL, 0, 8, 4);
 		wr_bits_viu(VPU_VIU_VENC_MUX_CTRL, 0, 4, 4);
 	}
+	if (rd_viu(VPU_VIU2VDIN_HDN_CTRL) != 0)
+		wr_viu(VPU_VIU2VDIN_HDN_CTRL, 0x0);
 }
 
 static void viuin_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
@@ -731,9 +747,12 @@ static void viuin_sig_propery(struct tvin_frontend_s *fe,
 {
 	static const struct vinfo_s *vinfo;
 	struct viuin_s *devp = container_of(fe, struct viuin_s, frontend);
-
-	vinfo = get_current_vinfo();
-	prop->color_format = vinfo->viu_color_fmt;
+	if (devp->parm.port == TVIN_PORT_VIDEO)
+		prop->color_format = TVIN_YUV444;
+	else {
+		vinfo = get_current_vinfo();
+		prop->color_format = vinfo->viu_color_fmt;
+	}
 	prop->dest_cfmt = devp->parm.dfmt;
 
 	prop->scaling4w = devp->parm.dest_hactive;
diff --git a/drivers/amlogic/uart/uart/meson_uart.c b/drivers/amlogic/uart/uart/meson_uart.c
index 074eacb..a976f8c 100644
--- a/drivers/amlogic/uart/uart/meson_uart.c
+++ b/drivers/amlogic/uart/uart/meson_uart.c
@@ -344,6 +344,7 @@ static void meson_uart_shutdown(struct uart_port *port)
 	val = readl(port->membase + AML_UART_CONTROL);
 	val &= ~(AML_UART_RX_EN | AML_UART_TX_EN);
 	val &= ~(AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);
+	val |= (0x1 << 31);
 	writel(val, port->membase + AML_UART_CONTROL);
 
 	spin_unlock_irqrestore(&port->lock, flags);
@@ -520,6 +521,7 @@ static int meson_uart_startup(struct uart_port *port)
 	writel(val, port->membase + AML_UART_CONTROL);
 
 	val |= (AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);
+	val &= ~(0x1 << 31);
 	writel(val, port->membase + AML_UART_CONTROL);
 
 	return ret;
@@ -582,6 +584,7 @@ static void meson_uart_set_termios(struct uart_port *port,
 
 	val = readl(port->membase + AML_UART_CONTROL);
 
+
 	val &= ~AML_UART_DATA_LEN_MASK;
 	switch (cflags & CSIZE) {
 	case CS8:
@@ -620,6 +623,7 @@ static void meson_uart_set_termios(struct uart_port *port,
 		val |= AML_UART_TWO_WIRE_EN;
 
 	writel(val, port->membase + AML_UART_CONTROL);
+
 	spin_unlock_irqrestore(&port->lock, flags);
 
 	baud = uart_get_baud_rate(port, termios, old, 9600, 4000000);
@@ -692,6 +696,9 @@ static int meson_uart_request_port(struct uart_port *port)
 	val = (AML_UART_RECV_IRQ(1) | AML_UART_XMIT_IRQ(port->fifosize / 2));
 	writel(val, port->membase + AML_UART_MISC);
 
+	writel(readl(port->membase + AML_UART_CONTROL)|(1<<31),
+			port->membase + AML_UART_CONTROL);
+
 	ret = request_irq(port->irq, meson_uart_interrupt, 0,
 			  meson_uart_type(port), port);
 	return 0;
diff --git a/drivers/amlogic/vfm/vfm.c b/drivers/amlogic/vfm/vfm.c
index f2df6d1..55f066b 100644
--- a/drivers/amlogic/vfm/vfm.c
+++ b/drivers/amlogic/vfm/vfm.c
@@ -319,8 +319,13 @@ static void vfm_init(void)
 #endif				/*
 				 */
 #if (defined CONFIG_TVIN_AFE) || (defined CONFIG_TVIN_HDMI)
+#ifdef CONFIG_POST_PROCESS_MANAGER
+	char tvpath_id[] = "tvpath";
+	char tvpath_chain[] = "vdin0 ppmgr deinterlace amvideo";
+#else
 	char tvpath_id[] = "tvpath";
 	char tvpath_chain[] = "vdin0 deinterlace amvideo";
+#endif
 #endif				/*
 				 */
 	int i;
diff --git a/drivers/amlogic/vfm/vftrace.c b/drivers/amlogic/vfm/vftrace.c
index 582b326..428b170 100644
--- a/drivers/amlogic/vfm/vftrace.c
+++ b/drivers/amlogic/vfm/vftrace.c
@@ -23,14 +23,14 @@
 #include <linux/dma-contiguous.h>
 #include <linux/cma.h>
 #include <linux/slab.h>
-
+#include <linux/time.h>
 #include "vftrace.h"
 
 struct trace_info {
 	void *vf;
 	int type;
 	int index;
-	u32 in_time;		/*in trace jiffies */
+	u64 in_time_us;		/*in trace jiffies */
 	u32 duration;
 	u32 pts;
 };
@@ -56,6 +56,7 @@ void *vftrace_alloc_trace(const char *name, int get, int max)
 	trace->w_index = 0;
 	trace->name = name;
 	trace->get = get;
+	trace->use_lock = 1;
 	spin_lock_init(&trace->lock);
 	return trace;
 }
@@ -82,15 +83,17 @@ void vftrace_info_in(void *vhandle, struct vframe_s *vf)
 	struct vf_trace *vftrace = vhandle;
 	struct trace_info *info;
 	unsigned long flags = 0;
+	struct timeval  tv;
 	if (!vftrace || !vf)
 		return;
+	do_gettimeofday(&tv);
 	TRACE_LOCK(vftrace);
 	info = &vftrace->trace_buf[vftrace->w_index];
 	info->index = vf->index;
 	info->type = vf->type;
 	info->vf = vf;
 	info->pts = vf->pts;
-	info->in_time = jiffies;
+	info->in_time_us = div64_u64(timeval_to_ns(&tv), 1000);
 	info->duration = info->duration;
 	vftrace->w_index++;
 	vftrace->num++;
@@ -102,14 +105,14 @@ void vftrace_info_in(void *vhandle, struct vframe_s *vf)
 
 static void vftrace_dump_trace_info(struct trace_info *info, int i)
 {
-	pr_info("%d: \tvf:%p:%d\ttype:%x \tpts:%d \td:%d \tt:%u\n",
+	pr_info("%d: \tvf:%p:%d\ttype:%x \tpts:%d \td:%d \tt:%lldUs\n",
 		i,
 		info->vf,
 		info->index,
 		info->type,
 		info->pts,
 		info->duration,
-		info->in_time);
+		info->in_time_us);
 }
 
 void vftrace_dump_trace_infos(void *vhandle)
diff --git a/drivers/amlogic/video_dev/amlvideo2.c b/drivers/amlogic/video_dev/amlvideo2.c
index 3aa5df2..169cfb0 100644
--- a/drivers/amlogic/video_dev/amlvideo2.c
+++ b/drivers/amlogic/video_dev/amlvideo2.c
@@ -385,6 +385,8 @@ int frameInv;
 struct vframe_s *tmp_vf;
 int frame_inittime;
 struct amlvideo2_latency_info latency_info;
+bool pflag;
+struct completion plug_sema;
 };
 
 struct amlvideo2_fh {
@@ -3107,7 +3109,9 @@ void vf_inqueue(struct vframe_s *vf, struct amlvideo2_node *node)
 		return;
 	}
 
+	mutex_lock(&node->mutex);
 	vfq_push(&node->q_ready, vf);
+	mutex_unlock(&node->mutex);
 
 	vf_notify_receiver(
 		name,
@@ -3138,8 +3142,11 @@ static int amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 		&& (node->provide_ready)) || (node->vidq.task_running == 0),
 		msecs_to_jiffies(5000));
 
-	if (i_ret == 0 || node->vidq.task_running == 0)
+	if (i_ret == 0 || node->vidq.task_running == 0) {
+		if (node->pflag)
+			complete(&node->plug_sema);
 		return 0;
+	}
 
 	if ((AML_RECEIVER_NONE != node->r_type) && vfq_full(&node->q_ready))
 		return -1;
@@ -3149,12 +3156,21 @@ static int amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 		node->amlvideo2_pool_size + 1,
 		(struct vframe_s **)&(node->amlvideo2_pool_ready[0]));
 		node->video_blocking = false;
+		node->tmp_vf = NULL;
 		pr_err("video blocking need to reset@!!!!!\n");
 		return 0;
 	}
 
 	if (!fh->is_streamed_on) {
 		dpr_err(node->vid_dev, 1, "dev doesn't stream on\n");
+		if (AML_RECEIVER_NONE != node->r_type) {
+			if (node->tmp_vf) {
+				vf_inqueue(node->tmp_vf, node);
+				node->tmp_vf = NULL;
+			}
+		} else {
+			node->tmp_vf = NULL;
+		}
 		while (vf_peek(node->recv.name) &&
 			(!vfq_full(&node->q_ready))) {
 			vf = vf_get(node->recv.name);
@@ -3171,9 +3187,16 @@ static int amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 		if (amlvideo2_dbg_en)
 			pr_info("provide is not ready .\n");
 		dpr_err(node->vid_dev, 1, "provide is not ready\n");
+		if (node->pflag)
+			complete(&node->plug_sema);
 		return -1;
 	}
 
+	if (node->pflag) {
+		complete(&node->plug_sema);
+		return 0;
+	}
+
 	spin_lock_irqsave(&node->slock, flags);
 	if (list_empty(&dma_q->active)) {
 		if (amlvideo2_dbg_en)
@@ -3361,6 +3384,11 @@ static int amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 	if (waitqueue_active(&buf->vb.done))
 		wake_up(&buf->vb.done);
 
+	if (node->pflag) {
+		complete(&node->plug_sema);
+		return 0;
+	}
+
 	if (amlvideo2_dbg_en)
 		pr_info("filled buffer %p\n", buf);
 
@@ -3400,6 +3428,8 @@ static int amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 	return 0;
 
 unlock: spin_unlock_irqrestore(&node->slock, flags);
+		if (node->pflag)
+			complete(&node->plug_sema);
 	return 0;
 }
 
@@ -3480,7 +3510,7 @@ static int amlvideo2_start_thread(struct amlvideo2_fh *fh)
 	fh->src_height = 0;
 
 	node->tmp_vf = NULL;
-	dma_q->task_running = 1;
+
 
 	#ifdef MUTLI_NODE
 	dma_q->kthread =
@@ -3492,8 +3522,10 @@ static int amlvideo2_start_thread(struct amlvideo2_fh *fh)
 
 	if (IS_ERR(dma_q->kthread)) {
 		v4l2_err(&node->vid_dev->v4l2_dev, "kernel_thread() failed\n");
+		dma_q->kthread = NULL;
 		return PTR_ERR(dma_q->kthread);
 	}
+	dma_q->task_running = 1;
 	/* Wakes thread */
 	/* wake_up_interruptible(&dma_q->wq); */
 
@@ -3503,18 +3535,23 @@ static int amlvideo2_start_thread(struct amlvideo2_fh *fh)
 
 static void amlvideo2_stop_thread(struct amlvideo2_node_dmaqueue *dma_q)
 {
+	int ret = 0;
 	struct amlvideo2_node *node =
 		container_of(dma_q, struct amlvideo2_node, vidq);
 	dpr_err(node->vid_dev, 1, "%s\n", __func__);
 	/* shutdown control thread */
-	if (dma_q->kthread) {
+	if (!IS_ERR(dma_q->kthread)) {
 		dma_q->task_running = 0;
 		send_sig(SIGTERM, dma_q->kthread, 1);
 	#ifdef USE_SEMA_QBUF
 		complete(&dma_q->qbuf_comp);
 	#endif
+		complete(&node->plug_sema);
 		wake_up_interruptible(&dma_q->wq);
-		kthread_stop(dma_q->kthread);
+		ret = kthread_stop(dma_q->kthread);
+		if (ret < 0)
+			pr_info("%s, ret = %d .\n", __func__, ret);
+
 		dma_q->kthread = NULL;
 	}
 }
@@ -3577,10 +3614,14 @@ static struct vframe_s *amlvideo2_vf_peek(void *op_arg)
 
 static struct vframe_s *amlvideo2_vf_get(void *op_arg)
 {
+	struct vframe_s *vf = NULL;
 	struct amlvideo2_node *node = (struct amlvideo2_node *)op_arg;
 	if (node->video_blocking)
 		return NULL;
-	return vfq_pop(&node->q_ready);
+	mutex_lock(&node->mutex);
+	vf = vfq_pop(&node->q_ready);
+	mutex_unlock(&node->mutex);
+	return vf;
 }
 
 static void amlvideo2_vf_put(struct vframe_s *vf, void *op_arg)
@@ -4002,8 +4043,8 @@ static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
 static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
 {
 	struct amlvideo2_fh *fh = priv;
-
-	return videobuf_dqbuf(&fh->vb_vidq, p, file->f_flags & O_NONBLOCK);
+	int ret = videobuf_dqbuf(&fh->vb_vidq, p, file->f_flags & O_NONBLOCK);
+	return ret;
 }
 
 #ifdef CONFIG_VIDEO_V4L1_COMPAT
@@ -4056,6 +4097,220 @@ static enum tvin_scan_mode_e vmode2scan_mode(enum vmode_e mode)
 	/* pr_err("mode=%d, scan_mode=%d\n", mode, scan_mode); */
 	return scan_mode;
 }
+
+/*the counter of AMLVIDEO2*/
+#define AMLVIDEO2_MAX_NODE		2
+static struct amlvideo2_node  *gAmlvideo2_Node[AMLVIDEO2_MAX_NODE];
+
+static int amlvideo2_stop_tvin_service(struct amlvideo2_node *node)
+{
+	int ret = 0;
+	struct vdin_v4l2_ops_s *vops = &node->vops;
+
+	if (amlvideo2_dbg_en)
+		pr_info("%s , %d\n", __func__, __LINE__);
+
+	if (AML_RECEIVER_NONE == node->r_type)
+		amlvideo2_stop_thread(&node->vidq);
+
+	if (((0 == node->input) || (0x1000C000 == node->input)) &&
+			(AML_RECEIVER_NONE == node->r_type)) {
+		if (amlvideo2_dbg_en)
+			pr_info("stop tvin service .\n");
+		if (!(vops->stop_tvin_service)) {
+			pr_info("stop_tvin_service func is NULL.\n");
+			return -1;
+		}
+		vops->stop_tvin_service(node->vdin_device_num);
+	}
+
+	node->start_vdin_flag = 0;
+	return ret;
+}
+
+static int amlvideo2_start_tvin_service(struct amlvideo2_node *node)
+{
+	struct amlvideo2_fh *fh = node->fh;
+	struct vdin_v4l2_ops_s *vops = &node->vops;
+	struct vdin_parm_s para;
+	const struct vinfo_s *vinfo;
+	int dst_w, dst_h;
+	vinfo = get_current_vinfo();
+
+	if ((node->input != 0) && (!node->start_vdin_flag)) /* 0:mirrocast */
+		goto start;
+
+	if ((AML_RECEIVER_NONE != node->r_type) && (!node->start_vdin_flag))
+		goto start;
+
+	if (AML_PROVIDE_MIRROCAST_VDIN0 == node->p_type)
+		node->vdin_device_num = 0;
+	else if (AML_PROVIDE_MIRROCAST_VDIN1 == node->p_type)
+		node->vdin_device_num = 1;
+
+	if (amlvideo2_dbg_en)
+		pr_info("Enter %s .\n", __func__);
+
+	memset(&para, 0, sizeof(para));
+	para.port = node->porttype;
+	para.fmt = TVIN_SIG_FMT_MAX;
+	para.frame_rate = vinfo->sync_duration_num/vinfo->sync_duration_den;
+	para.h_active = vinfo->width;
+	para.v_active = vinfo->height;
+	para.hsync_phase = 0;
+	para.vsync_phase = 1;
+	para.hs_bp = 0;
+	para.vs_bp = 0;
+	para.dfmt = TVIN_NV21;/* TVIN_YUV422; */
+	para.scan_mode = vmode2scan_mode(
+		vinfo->mode);/* TVIN_SCAN_MODE_PROGRESSIVE; */
+	if (TVIN_SCAN_MODE_INTERLACED == para.scan_mode)
+		para.v_active = para.v_active / 2;
+
+	dst_w = fh->width;
+	dst_h = fh->height;
+	if (vinfo->width < vinfo->height) {
+		if ((vinfo->width <= 768) && (vinfo->height <= 1024)) {
+			dst_w = vinfo->width;
+			dst_h = vinfo->height;
+		} else {
+			dst_w = fh->height;
+			dst_h = fh->width;
+		}
+		output_axis_adjust(vinfo->height, vinfo->width, (int *)&dst_h,
+					(int *)&dst_w, 0, NULL);
+	} else {
+		if ((vinfo->height <= 768) && (vinfo->width <= 1024)) {
+			dst_w = vinfo->width;
+			dst_h = vinfo->height;
+		}
+		output_axis_adjust(vinfo->width, vinfo->height, (int *)&dst_w,
+					(int *)&dst_h, 0, NULL);
+	}
+	para.dest_hactive = dst_w;
+	para.dest_vactive = dst_h;
+	if (TVIN_SCAN_MODE_INTERLACED == para.scan_mode)
+		para.dest_vactive = para.dest_vactive / 2;
+	if (amlvideo2_dbg_en) {
+		pr_info("node->input=%d, node->r_type=%d, node->p_type=%d\n",
+			node->input,
+			node->r_type, node->p_type);
+		pr_info("para.h_active: %d, para.v_active: %d,",
+			para.h_active, para.v_active);
+		pr_info("para.dest_hactive: %d, para.dest_vactive: %d,",
+			para.dest_hactive, para.dest_vactive);
+		pr_info("fh->width: %d, fh->height: %d,",
+			fh->width, fh->height);
+		pr_info("vinfo->mode: %d,para.scan_mode: %d\n",
+			vinfo->mode, para.scan_mode);
+		pr_info("node->vdin_device_num = %d .\n" ,
+			node->vdin_device_num);
+	}
+	if (!(vops->start_tvin_service)) {
+		pr_info("start_tvin_service is NULL.\n");
+		return -1;
+	}
+	vops->start_tvin_service(node->vdin_device_num, &para);
+
+start: node->frame_inittime = 1;
+	/* frameInv_adjust = 0; */
+	/* frameInv = 0; */
+	/* tmp_vf = NULL; */
+	do_gettimeofday(&node->thread_ts1);
+	return 0;
+}
+int amlvideo2_notify_callback(struct notifier_block *block, unsigned long cmd,
+			void *para)
+{
+	struct amlvideo2_node  *node = NULL;
+	struct vframe_s *recycle_vf = NULL;
+	struct vframe_states states;
+	struct vframe_provider_s *vfp = NULL;
+	int i;
+	int index = 0;
+	int ret = 0;
+	for (i = 0; i < AMLVIDEO2_MAX_NODE; i++) {
+		if (gAmlvideo2_Node[i]->r_type == AML_RECEIVER_NONE)
+			index = 1;
+	}
+	if (amlvideo2_dbg_en)
+		pr_info("%s , index = %d\n", __func__, index);
+	if (index != 1)
+		return ret;
+	node = gAmlvideo2_Node[index];
+	mutex_lock(&node->mutex);
+	switch (cmd) {
+	case  VOUT_EVENT_MODE_CHANGE:
+		pr_info("mode changed in amlvideo2 .\n");
+		vfp = vf_get_provider(node->recv.name);
+		if ((node == NULL) || (vfp == NULL) ||
+			(!node->fh->is_streamed_on)) {
+			pr_info("driver is not ready or not need to screencap.\n");
+			mutex_unlock(&node->mutex);
+			return ret;
+		}
+		node->pflag = true;
+		wait_for_completion_timeout(&node->plug_sema,
+			msecs_to_jiffies(150));
+		if (amlvideo2_dbg_en)
+			pr_info("finish wait plug sema .\n");
+		/* if local queue have vf , should give back to provider */
+		if (vfq_empty(&node->q_ready)) {
+			if (amlvideo2_dbg_en)
+				pr_info("q_ready is empty .\n");
+		} else {
+			recycle_vf = vfq_pop(&node->q_ready);
+			while (recycle_vf) {
+				vf_put(recycle_vf, node->recv.name);
+				recycle_vf = vfq_pop(&node->q_ready);
+			}
+			if (amlvideo2_dbg_en)
+				pr_info("already flush local vf .\n");
+		}
+		/*debug provider vf state*/
+		if (amlvideo2_dbg_en) {
+			if (vfp && vfp->ops && vfp->ops->vf_states)
+				ret = vfp->ops->vf_states(&states, vfp->op_arg);
+			if (ret == 0) {
+				pr_info("vf_pool_size = %d, buf_free_num = %d .\n",
+				states.vf_pool_size, states.buf_free_num);
+				pr_info("buf_recycle_num = %d, buf_avail_num = %d .\n",
+				states.buf_recycle_num, states.buf_avail_num);
+			}
+		}
+		ret = amlvideo2_stop_tvin_service(node);
+		if (ret < 0) {
+			pr_err("stop tvin service failed.\n");
+			mutex_unlock(&node->mutex);
+			node->pflag = false;
+			return ret;
+		}
+
+		if (AML_RECEIVER_NONE == node->r_type)
+			amlvideo2_start_thread(node->fh);
+		msleep(500);
+
+		ret = amlvideo2_start_tvin_service(node);
+		if (ret < 0) {
+			pr_err("start tvin service failed.\n");
+			mutex_unlock(&node->mutex);
+			node->pflag = false;
+			return ret;
+		}
+		node->pflag = false;
+		break;
+	}
+	mutex_unlock(&node->mutex);
+	if (amlvideo2_dbg_en)
+		pr_info("finish amlvideo2_notify_callback .\n");
+	return ret;
+}
+
+
+static struct notifier_block amlvideo2_notifier_nb = {
+	.notifier_call	= amlvideo2_notify_callback,
+};
+
 static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 {
 	int ret;
@@ -4693,6 +4948,7 @@ static int amlvideo2_close(struct file *file)
 	node->crop_info.source_height_crop = 0;
 	node->crop_info.capture_crop_enable = 0;
 	/* node->provider = NULL; */
+	node->pflag = false;
 	mutex_unlock(&node->mutex);
 	return 0;
 }
@@ -4789,7 +5045,6 @@ static int amlvideo2_receiver_event_fun(int type, void *data,
 	switch (type) {
 	case VFRAME_EVENT_PROVIDER_VFRAME_READY:
 		node->provide_ready = 1;
-		node->video_blocking = false;
 		if (vf_peek(node->recv.name) != NULL)
 			wake_up_interruptible(&node->vidq.wq);
 		break;
@@ -4847,6 +5102,7 @@ static int amlvideo2_receiver_event_fun(int type, void *data,
 	case VFRAME_EVENT_PROVIDER_REG:
 		node->amlvideo2_pool_ready = NULL;
 		node->amlvideo2_pool_size = 0;
+		node->video_blocking = false;
 		if (vf_get_states(&frame_states, node->vid) == 0)
 			node->amlvideo2_pool_size = frame_states.vf_pool_size;
 		else
@@ -4871,10 +5127,13 @@ static int amlvideo2_receiver_event_fun(int type, void *data,
 			pr_err("%s,%dstop thread\n", __func__, __LINE__);
 		}
 		if (amlvideo2_dbg_en)
-			pr_info("unreg amlvideo2\n");
-		vf_unreg_provider(&node->amlvideo2_vf_prov);
+			pr_info("unreg amlvideo2 , pflag = %d\n", node->pflag);
+
+		if (!node->pflag) {
+			vf_unreg_provider(&node->amlvideo2_vf_prov);
+			kfree(node->amlvideo2_pool_ready);
+		}
 
-		kfree(node->amlvideo2_pool_ready);
 		/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 		/* switch_mod_gate_by_name("ge2d", 0); */
 		/* #endif */
@@ -4928,6 +5187,7 @@ static int amlvideo2_release_node(struct amlvideo2_device *vid_dev)
 			kfree(vid_dev->node[i]);
 			vid_dev->node[i] = NULL;
 		}
+		gAmlvideo2_Node[i] = NULL;
 	}
 
 	return 0;
@@ -4990,6 +5250,7 @@ static int amlvideo2_create_node(struct platform_device *pdev)
 		/* initialize locks */
 		spin_lock_init(&vid_node->slock);
 		mutex_init(&vid_node->mutex);
+		init_completion(&vid_node->plug_sema);
 
 		vfd = video_device_alloc();
 		if (!vfd) {
@@ -5040,9 +5301,11 @@ static int amlvideo2_create_node(struct platform_device *pdev)
 		(i == 0) ? DEVICE_NAME0 : DEVICE_NAME1,
 					&amlvideo2_vf_provider,
 					(void *)vid_node);
+		vid_node->pflag = false;
 		vid_dev->node[i] = vid_node;
 		v4l2_info(&vid_dev->v4l2_dev, "V4L2 device registered as %s\n",
 				video_device_node_name(vfd));
+		gAmlvideo2_Node[i] = vid_node;
 		ret = 0;
 	}
 
@@ -5096,6 +5359,8 @@ static int amlvideo2_driver_probe(struct platform_device *pdev)
 	if (ret)
 		goto probe_err1;
 
+	/* register vout client */
+	vout_register_client(&amlvideo2_notifier_nb);
 	return 0;
 
 probe_err1: v4l2_device_unregister(&dev->v4l2_dev);
@@ -5184,7 +5449,8 @@ static int amlvideo2_drv_remove(struct platform_device *pdev)
 	struct amlvideo2_device *vid_dev = container_of(v4l2_dev,
 							struct amlvideo2_device,
 							v4l2_dev);
-
+	/* unregister vout client */
+	vout_unregister_client(&amlvideo2_notifier_nb);
 	amlvideo2_release_node(vid_dev);
 	v4l2_device_unregister(v4l2_dev);
 	platform_set_drvdata(pdev, NULL);
diff --git a/drivers/amlogic/vpu/vpu.c b/drivers/amlogic/vpu/vpu.c
index 74de6c7..2c389e5 100644
--- a/drivers/amlogic/vpu/vpu.c
+++ b/drivers/amlogic/vpu/vpu.c
@@ -114,6 +114,12 @@ static void vpu_chip_detect(void)
 		vpu_conf.clk_level_max = CLK_LEVEL_MAX_GXL;
 		vpu_conf.fclk_type = FCLK_TYPE_GXL;
 		break;
+	case MESON_CPU_MAJOR_ID_TXL:
+		vpu_chip_type = VPU_CHIP_TXL;
+		vpu_conf.clk_level_dft = CLK_LEVEL_DFT_TXL;
+		vpu_conf.clk_level_max = CLK_LEVEL_MAX_TXL;
+		vpu_conf.fclk_type = FCLK_TYPE_TXL;
+		break;
 	default:
 		vpu_chip_type = VPU_CHIP_MAX;
 		vpu_conf.clk_level_dft = 0;
@@ -170,13 +176,15 @@ unsigned int get_vpu_clk(void)
 	unsigned int mux, div;
 
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		reg = HHI_VPU_CLK_CNTL_GX;
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
+		reg = HHI_VPU_CLK_CNTL;
 		break;
 	default:
-		reg = HHI_VPU_CLK_CNTL;
+		reg = HHI_VPU_CLK_CNTL_GX;
 		break;
 	}
 
@@ -405,12 +413,8 @@ static int adjust_vpu_clk(unsigned int clk_level)
 	case VPU_CHIP_G9BB:
 		switch_vpu_clk_m8_g9();
 		break;
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		switch_vpu_clk_gx();
-		break;
 	default:
+		switch_vpu_clk_gx();
 		break;
 	}
 
@@ -445,13 +449,15 @@ static int set_vpu_clk(unsigned int vclk)
 #endif
 
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		reg = HHI_VPU_CLK_CNTL_GX;
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
+		reg = HHI_VPU_CLK_CNTL;
 		break;
 	default:
-		reg = HHI_VPU_CLK_CNTL;
+		reg = HHI_VPU_CLK_CNTL_GX;
 		break;
 	}
 
@@ -670,18 +676,20 @@ void switch_vpu_mem_pd_vmod(unsigned int vmod, int flag)
 
 	val = (flag == VPU_MEM_POWER_ON) ? 0 : 3;
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
-		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
-		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
-		break;
-	default:
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
 		_reg0 = HHI_VPU_MEM_PD_REG0;
 		_reg1 = HHI_VPU_MEM_PD_REG1;
 		_reg2 = 0;
 		break;
+	default:
+		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
+		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
+		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
+		break;
 	}
 
 	vpu_mod = get_vpu_mod(vmod);
@@ -797,8 +805,11 @@ void switch_vpu_mem_pd_vmod(unsigned int vmod, int flag)
 		vpu_hiu_setb(_reg1, val, 30, 2);
 		break;
 	case VPU_VIU1_WM:
-		if (vpu_chip_type == VPU_CHIP_GXL)
+		if ((vpu_chip_type == VPU_CHIP_GXL) ||
+			(vpu_chip_type == VPU_CHIP_GXM) ||
+			(vpu_chip_type == VPU_CHIP_TXL)) {
 			vpu_hiu_setb(_reg2, val, 0, 2);
+		}
 		break;
 	default:
 		VPUPR("switch_vpu_mem_pd: unsupport vpu mod\n");
@@ -842,18 +853,20 @@ int get_vpu_mem_pd_vmod(unsigned int vmod)
 		return -1;
 
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
-		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
-		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
-		break;
-	default:
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
 		_reg0 = HHI_VPU_MEM_PD_REG0;
 		_reg1 = HHI_VPU_MEM_PD_REG1;
 		_reg2 = 0;
 		break;
+	default:
+		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
+		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
+		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
+		break;
 	}
 
 	vpu_mod = get_vpu_mod(vmod);
@@ -973,10 +986,13 @@ int get_vpu_mem_pd_vmod(unsigned int vmod)
 		val = vpu_hiu_getb(_reg1, 30, 2);
 		break;
 	case VPU_VIU1_WM:
-		if (vpu_chip_type == VPU_CHIP_GXL)
+		if ((vpu_chip_type == VPU_CHIP_GXL) ||
+			(vpu_chip_type == VPU_CHIP_GXM) ||
+			(vpu_chip_type == VPU_CHIP_TXL)) {
 			val = vpu_hiu_getb(_reg2, 0, 2);
-		else
+		} else {
 			val = VPU_MEM_PD_ERR;
+		}
 		break;
 	default:
 		val = VPU_MEM_PD_ERR;
@@ -1093,25 +1109,30 @@ static ssize_t vpu_mem_debug(struct class *class, struct class_attribute *attr,
 	unsigned int _reg0, _reg1, _reg2;
 
 	switch (vpu_chip_type) {
-	case VPU_CHIP_GXBB:
-	case VPU_CHIP_GXTVBB:
-	case VPU_CHIP_GXL:
-		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
-		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
-		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
-		break;
-	default:
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
 		_reg0 = HHI_VPU_MEM_PD_REG0;
 		_reg1 = HHI_VPU_MEM_PD_REG1;
 		_reg2 = 0;
 		break;
+	default:
+		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
+		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
+		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
+		break;
 	}
 	switch (buf[0]) {
 	case 'r':
 		VPUPR("mem_pd0: 0x%08x\n", vpu_hiu_read(_reg0));
 		VPUPR("mem_pd1: 0x%08x\n", vpu_hiu_read(_reg1));
-		if (vpu_chip_type == VPU_CHIP_GXL)
+		if ((vpu_chip_type == VPU_CHIP_GXL) ||
+			(vpu_chip_type == VPU_CHIP_GXM) ||
+			(vpu_chip_type == VPU_CHIP_TXL)) {
 			VPUPR("mem_pd2: 0x%08x\n", vpu_hiu_read(_reg2));
+		}
 		break;
 	case 'w':
 		ret = sscanf(buf, "w %u %u", &tmp[0], &tmp[1]);
diff --git a/drivers/amlogic/vpu/vpu.h b/drivers/amlogic/vpu/vpu.h
index 3d559f6..9f4bd75 100644
--- a/drivers/amlogic/vpu/vpu.h
+++ b/drivers/amlogic/vpu/vpu.h
@@ -33,6 +33,7 @@ enum vpu_chip_e {
 	VPU_CHIP_GXTVBB,
 	VPU_CHIP_GXL,
 	VPU_CHIP_GXM,
+	VPU_CHIP_TXL,
 	VPU_CHIP_MAX,
 };
 /*
@@ -117,6 +118,11 @@ static unsigned int fclk_table[] = { /* unit: MHz */
 #define CLK_LEVEL_DFT_GXM     3
 #define CLK_LEVEL_MAX_GXM     8
 #define FCLK_TYPE_GXM         FCLK_2000M
+/* TXL */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_TXL     3
+#define CLK_LEVEL_MAX_TXL     8
+#define FCLK_TYPE_TXL         FCLK_2000M
 
 /* vpu clk setting */
 enum vpu_mux_e {
@@ -152,7 +158,7 @@ static unsigned int vpu_clk_table[2][12][3] = {/* compatible for all chip */
 		{696000000,    GPLL_CLK,     0}, /* 8 */ /* G9TV use gp1_pll */
 		{850000000,    FCLK_DIV3,    0}, /* 9 */
 	},
-	{ /* gxbb, gxtvbb, gxl, fpll=2000M */
+	{ /* gxbb, gxtvbb, gxl, txl, fpll=2000M */
 		/* frequency   clk_mux       div */
 		{100000000,    FCLK_DIV5,    3}, /* 0 */
 		{166667000,    FCLK_DIV3,    3}, /* 1 */
diff --git a/drivers/amlogic/vrtc/aml_vrtc.c b/drivers/amlogic/vrtc/aml_vrtc.c
index 4d6ce64..5b0691a 100644
--- a/drivers/amlogic/vrtc/aml_vrtc.c
+++ b/drivers/amlogic/vrtc/aml_vrtc.c
@@ -88,6 +88,28 @@ static int aml_vrtc_read_time(struct device *dev, struct rtc_time *tm)
 	return 0;
 }
 
+static int aml_rtc_write_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long time_t;
+	unsigned long te = 0;
+	unsigned int time;
+
+	rtc_tm_to_time(tm, &time_t);
+	pr_debug("aml_rtc : write the rtc time, time is %ld\n", time_t);
+
+	time = 0;
+	if (tel_reg_vaddr && teh_reg_vaddr) {
+		te = readl(teh_reg_vaddr);
+		te <<= 32;
+		te += readl(tel_reg_vaddr);
+		time = (u32)(te / 1000000);
+		pr_debug("time_e: %us\n", time);
+	}
+	vrtc_init_date = (unsigned int)time_t - time;
+
+	return 0;
+}
+
 static int set_wakeup_time(unsigned long time)
 {
 	int ret = -1;
@@ -128,6 +150,7 @@ static int aml_vrtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 
 static const struct rtc_class_ops aml_vrtc_ops = {
 	.read_time = aml_vrtc_read_time,
+	.set_time = aml_rtc_write_time,
 	.set_alarm = aml_vrtc_set_alarm,
 };
 
diff --git a/drivers/amlogic/wifi/wifi_dt.c b/drivers/amlogic/wifi/wifi_dt.c
index fc17785..6e111b0 100644
--- a/drivers/amlogic/wifi/wifi_dt.c
+++ b/drivers/amlogic/wifi/wifi_dt.c
@@ -455,8 +455,25 @@ static int wifi_dev_probe(struct platform_device *pdev)
 		if (of_get_property(pdev->dev.of_node,
 			"pinctrl-names", NULL)) {
 			unsigned int pwm_misc;
+			unsigned int pwm_time_count;
+			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+				WIFI_INFO("set pwm as 32k output");
+				aml_write_cbus(0x21b0, 0x16d016e);
+				aml_write_cbus(0x21b5, 0x16d016d);
+
+				pwm_time_count = aml_read_cbus(0x21b4);
+				pwm_time_count &= ~(0xffff << 16);
+				pwm_time_count |= ((3 << 16) | (2 << 24));
+				aml_write_cbus(0x21b4, pwm_time_count);
+
+				pwm_misc = aml_read_cbus(0x21b2);
+				pwm_misc &= ~((0x7f << 8) | (3 << 4) |
+					(1 << 2) | (1 << 0));
+				pwm_misc |= ((1 << 25) | (1 << 15) |
+					(0 << 8) | (0 << 4));
+				aml_write_cbus(0x21b2, (pwm_misc | (1 << 0)));
 
-			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
+			} else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) {
 				/* pwm_e */
 				WIFI_INFO("set pwm as 32k output");
 				aml_write_cbus(0x21b0, 0x7f107f2);
@@ -466,6 +483,7 @@ static int wifi_dev_probe(struct platform_device *pdev)
 				pwm_misc |= ((1 << 15) | (4 << 8) | (3 << 4));
 				aml_write_cbus(0x21b2, pwm_misc);
 				aml_write_cbus(0x21b2, (pwm_misc | (1 << 0)));
+
 			} else if (get_cpu_type() == MESON_CPU_MAJOR_ID_M8B) {
 				/* pwm_e */
 				WIFI_INFO("set pwm as 32k output");
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index 83d9724..1295705 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -133,7 +133,6 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 
 	return val;
 }
-
 static __always_inline irqreturn_t timer_handler(const int access,
 					struct clock_event_device *evt)
 {
@@ -263,7 +262,7 @@ static void __arch_timer_setup(unsigned type,
 	clk->features = CLOCK_EVT_FEAT_ONESHOT;
 
 	if (type == ARCH_CP15_TIMER) {
-		/*clk->features |= CLOCK_EVT_FEAT_C3STOP;*/
+		clk->features |= CLOCK_EVT_FEAT_C3STOP;
 		clk->name = "arch_sys_timer";
 		clk->rating = 450;
 		clk->cpumask = cpumask_of(smp_processor_id());
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 0645c70..000909d 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -687,6 +687,32 @@ static ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)
 	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
 }
 
+#ifdef CONFIG_SCHED_HMP
+int hmp_boost_en;
+static ssize_t show_hmp_boost(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%d\n", hmp_boost_en);
+}
+static ssize_t store_hmp_boost(struct cpufreq_policy *policy,
+					const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	hmp_boost_en = val;
+	return count;
+}
+int get_hmp_boost(void)
+{
+	return hmp_boost_en;
+}
+cpufreq_freq_attr_rw(hmp_boost);
+#endif
+
+
 cpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);
 cpufreq_freq_attr_ro(cpuinfo_min_freq);
 cpufreq_freq_attr_ro(cpuinfo_max_freq);
@@ -716,6 +742,9 @@ static struct attribute *default_attrs[] = {
 	&scaling_driver.attr,
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
+#ifdef CONFIG_SCHED_HMP
+	&hmp_boost.attr,
+#endif
 	NULL
 };
 
diff --git a/drivers/cpufreq/cpufreq_hotplug.c b/drivers/cpufreq/cpufreq_hotplug.c
index 2633faf..0eb99a3 100644
--- a/drivers/cpufreq/cpufreq_hotplug.c
+++ b/drivers/cpufreq/cpufreq_hotplug.c
@@ -593,6 +593,14 @@ void cpufreq_set_max_cpu_num(unsigned int cpu_num, int cluster_id)
 	return;
 }
 
+static bool can_down(void)
+{
+	bool ret = true;
+#ifdef CONFIG_CMA
+	ret &= cma_alloc_ref() > 0 ? false : true;
+#endif
+	return ret;
+}
 
 static int __ref cpu_hotplug_thread(void *data)
 {
@@ -650,6 +658,8 @@ static int __ref cpu_hotplug_thread(void *data)
 		} else if (*hotplug_flag == CPU_HOTPLUG_UNPLUG) {
 			*hotplug_flag = CPU_HOTPLUG_NONE;
 			cpu_down_num = 0;
+			if (!can_down())
+				goto wait_next_hotplug;
 			for (i = 0; i < num_online_cpus()-1; i++) {
 				raw_spin_lock_irqsave(
 					  &NULL_task->pi_lock, flags);
diff --git a/drivers/cpufreq/cpufreq_interactive.c b/drivers/cpufreq/cpufreq_interactive.c
index 215163d..db14d81 100644
--- a/drivers/cpufreq/cpufreq_interactive.c
+++ b/drivers/cpufreq/cpufreq_interactive.c
@@ -122,6 +122,8 @@ static struct cpufreq_interactive_tunables *common_tunables;
 
 static struct attribute_group *get_sysfs_attr(void);
 
+static void cpufreq_hmp_boost(unsigned int, unsigned int, unsigned int);
+
 static void cpufreq_interactive_timer_resched(
 	struct cpufreq_interactive_cpuinfo *pcpu)
 {
@@ -363,6 +365,9 @@ static void cpufreq_interactive_timer(unsigned long data)
 	if (WARN_ON_ONCE(!delta_time))
 		goto rearm;
 
+#ifdef CONFIG_SCHED_HMP
+	cpufreq_hmp_boost(data, pcpu->policy->cur, pcpu->policy->max);
+#endif
 	spin_lock_irqsave(&pcpu->target_freq_lock, flags);
 	do_div(cputime_speedadj, delta_time);
 	loadadjfreq = (unsigned int)cputime_speedadj * 100;
@@ -601,6 +606,35 @@ static void cpufreq_interactive_boost(struct cpufreq_interactive_tunables *tunab
 		wake_up_process(speedchange_task);
 }
 
+#ifdef CONFIG_SCHED_HMP
+#define hmp_boost_thresh	3
+#define hmp_boost_pulse		300000
+static void cpufreq_hmp_boost(unsigned int cpu, unsigned int freq,
+	unsigned int freq_max)
+{
+	static int cnt;
+	struct cpufreq_interactive_cpuinfo *pcpu = &per_cpu(cpuinfo, 4);
+	struct cpufreq_interactive_tunables *tunables;
+
+	if (cpu > 3 || !cpu_online(4))
+		return;
+
+	if (freq < freq_max || !pcpu->governor_enabled || !get_hmp_boost()) {
+		cnt = 0;
+		return;
+	}
+
+	tunables = pcpu->policy->governor_data;
+	if (cnt++ > hmp_boost_thresh) {
+		tunables->boostpulse_endtime =
+			ktime_to_us(ktime_get()) + hmp_boost_pulse;
+		if (pcpu->policy->cur < tunables->hispeed_freq
+			|| !tunables->boosted)
+			cpufreq_interactive_boost(tunables);
+	}
+}
+#endif
+
 static int cpufreq_interactive_notifier(
 	struct notifier_block *nb, unsigned long val, void *data)
 {
@@ -1031,6 +1065,7 @@ gov_sys_pol_attr_rw(boost);
 gov_sys_pol_attr_rw(boostpulse_duration);
 gov_sys_pol_attr_rw(io_is_busy);
 
+
 static struct global_attr boostpulse_gov_sys =
 	__ATTR(boostpulse, 0200, NULL, store_boostpulse_gov_sys);
 
diff --git a/drivers/cpuidle/Kconfig b/drivers/cpuidle/Kconfig
index f04e25f..6b15a9b 100644
--- a/drivers/cpuidle/Kconfig
+++ b/drivers/cpuidle/Kconfig
@@ -30,11 +30,19 @@ config CPU_IDLE_GOV_MENU
 	bool "Menu governor (for tickless system)"
 	default y
 
+config DT_IDLE_STATES
+	bool
+
 menu "ARM CPU Idle Drivers"
 depends on ARM
 source "drivers/cpuidle/Kconfig.arm"
 endmenu
 
+menu "ARM64 CPU Idle Drivers"
+depends on ARM64
+source "drivers/cpuidle/Kconfig.arm64"
+endmenu
+
 menu "POWERPC CPU Idle Drivers"
 depends on PPC
 source "drivers/cpuidle/Kconfig.powerpc"
diff --git a/drivers/cpuidle/Kconfig.arm64 b/drivers/cpuidle/Kconfig.arm64
new file mode 100644
index 0000000..d0a08ed
--- /dev/null
+++ b/drivers/cpuidle/Kconfig.arm64
@@ -0,0 +1,14 @@
+#
+# ARM64 CPU Idle drivers
+#
+
+config ARM64_CPUIDLE
+	bool "Generic ARM64 CPU idle Driver"
+	select ARM64_CPU_SUSPEND
+	select DT_IDLE_STATES
+	help
+	  Select this to enable generic cpuidle driver for ARM64.
+	  It provides a generic idle driver whose idle states are configured
+	  at run-time through DT nodes. The CPUidle suspend backend is
+	  initialized by calling the CPU operations init idle hook
+	  provided by architecture code.
diff --git a/drivers/cpuidle/Makefile b/drivers/cpuidle/Makefile
index f71ae1b..f5a9bf4 100644
--- a/drivers/cpuidle/Makefile
+++ b/drivers/cpuidle/Makefile
@@ -4,6 +4,7 @@
 
 obj-y += cpuidle.o driver.o governor.o sysfs.o governors/
 obj-$(CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED) += coupled.o
+obj-$(CONFIG_DT_IDLE_STATES)		  += dt_idle_states.o
 
 ##################################################################################
 # ARM SoC drivers
@@ -15,6 +16,10 @@ obj-$(CONFIG_ARM_U8500_CPUIDLE)         += cpuidle-ux500.o
 obj-$(CONFIG_ARM_AT91_CPUIDLE)          += cpuidle-at91.o
 
 ###############################################################################
+# ARM64 drivers
+obj-$(CONFIG_ARM64_CPUIDLE)		+= cpuidle-arm64.o
+
+###############################################################################
 # POWERPC drivers
 obj-$(CONFIG_PSERIES_CPUIDLE)		+= cpuidle-pseries.o
 obj-$(CONFIG_POWERNV_CPUIDLE)		+= cpuidle-powernv.o
diff --git a/drivers/cpuidle/cpuidle-arm64.c b/drivers/cpuidle/cpuidle-arm64.c
new file mode 100644
index 0000000..2ae003c
--- /dev/null
+++ b/drivers/cpuidle/cpuidle-arm64.c
@@ -0,0 +1,134 @@
+/*
+ * ARM64 generic CPU idle driver.
+ *
+ * Copyright (C) 2014 ARM Ltd.
+ * Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "CPUidle arm64: " fmt
+
+#include <linux/cpuidle.h>
+#include <linux/cpumask.h>
+#include <linux/cpu_pm.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+#include <asm/cpuidle.h>
+#include <asm/suspend.h>
+
+#include "dt_idle_states.h"
+
+/*
+ * arm64_enter_idle_state - Programs CPU to enter the specified state
+ *
+ * dev: cpuidle device
+ * drv: cpuidle driver
+ * idx: state index
+ *
+ * Called from the CPUidle framework to program the device to the
+ * specified target state selected by the governor.
+ */
+static int arm64_enter_idle_state(struct cpuidle_device *dev,
+				  struct cpuidle_driver *drv, int idx)
+{
+	int ret;
+
+	if (!idx) {
+		cpu_do_idle();
+		return idx;
+	}
+
+	ret = cpu_pm_enter();
+	if (!ret) {
+		/*
+		 * Pass idle state index to cpu_suspend which in turn will
+		 * call the CPU ops suspend protocol with idle index as a
+		 * parameter.
+		 */
+		ret = cpu_suspend(idx);
+
+		cpu_pm_exit();
+	}
+
+	return ret ? -1 : idx;
+}
+
+static struct cpuidle_driver arm64_idle_driver = {
+	.name = "arm64_idle",
+	.owner = THIS_MODULE,
+	/*
+	 * State at index 0 is standby wfi and considered standard
+	 * on all ARM platforms. If in some platforms simple wfi
+	 * can't be used as "state 0", DT bindings must be implemented
+	 * to work around this issue and allow installing a special
+	 * handler for idle state index 0.
+	 */
+	.states[0] = {
+		.enter                  = arm64_enter_idle_state,
+		.exit_latency           = 1,
+		.target_residency       = 1,
+		.power_usage		= UINT_MAX,
+		.flags                  = CPUIDLE_FLAG_TIME_VALID,
+		.name                   = "WFI",
+		.desc                   = "ARM64 WFI",
+	}
+};
+
+static const struct of_device_id arm64_idle_state_match[] __initconst = {
+	{ .compatible = "arm, idle-state",
+	  .data = arm64_enter_idle_state },
+	{ },
+};
+
+/*
+ * arm64_idle_init
+ *
+ * Registers the arm64 specific cpuidle driver with the cpuidle
+ * framework. It relies on core code to parse the idle states
+ * and initialize them using driver data structures accordingly.
+ */
+static int __init arm64_idle_init(void)
+{
+	int cpu, ret;
+	struct cpuidle_driver *drv = &arm64_idle_driver;
+
+	/*
+	 * Initialize idle states data, starting at index 1.
+	 * This driver is DT only, if no DT idle states are detected (ret == 0)
+	 * let the driver initialization fail accordingly since there is no
+	 * reason to initialize the idle driver if only wfi is supported.
+	 */
+	 pr_info("cpuidle init start!!\n");
+	ret = dt_init_idle_driver(drv, arm64_idle_state_match, 1);
+	if (ret <= 0) {
+		if (ret)
+			pr_err("failed to initialize idle states\n");
+		return ret ? : -ENODEV;
+	}
+
+	/*
+	 * Call arch CPU operations in order to initialize
+	 * idle states suspend back-end specific data
+	 */
+	for_each_possible_cpu(cpu) {
+		ret = cpu_init_idle(cpu);
+		if (ret) {
+			pr_err("CPU %d failed to init idle CPU ops\n", cpu);
+			return ret;
+		}
+	}
+
+	ret = cpuidle_register(drv, NULL);
+	if (ret) {
+		pr_err("failed to register cpuidle driver\n");
+		return ret;
+	}
+	pr_info("cpuidle init done!\n");
+	return 0;
+}
+device_initcall(arm64_idle_init);
diff --git a/drivers/cpuidle/dt_idle_states.c b/drivers/cpuidle/dt_idle_states.c
new file mode 100644
index 0000000..52f4d11
--- /dev/null
+++ b/drivers/cpuidle/dt_idle_states.c
@@ -0,0 +1,213 @@
+/*
+ * DT idle states parsing code.
+ *
+ * Copyright (C) 2014 ARM Ltd.
+ * Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "DT idle-states: " fmt
+
+#include <linux/cpuidle.h>
+#include <linux/cpumask.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+#include "dt_idle_states.h"
+
+static int init_state_node(struct cpuidle_state *idle_state,
+			   const struct of_device_id *matches,
+			   struct device_node *state_node)
+{
+	int err;
+	const struct of_device_id *match_id;
+
+	match_id = of_match_node(matches, state_node);
+	if (!match_id)
+		return -ENODEV;
+	/*
+	 * CPUidle drivers are expected to initialize the const void *data
+	 * pointer of the passed in struct of_device_id array to the idle
+	 * state enter function.
+	 */
+	idle_state->enter = match_id->data;
+
+	err = of_property_read_u32(state_node, "wakeup-latency-us",
+				   &idle_state->exit_latency);
+	if (err) {
+		u32 entry_latency, exit_latency;
+
+		err = of_property_read_u32(state_node, "entry-latency-us",
+					   &entry_latency);
+		if (err) {
+			pr_debug(" * %s missing entry-latency-us property\n",
+				 state_node->full_name);
+			return -EINVAL;
+		}
+
+		err = of_property_read_u32(state_node, "exit-latency-us",
+					   &exit_latency);
+		if (err) {
+			pr_debug(" * %s missing exit-latency-us property\n",
+				 state_node->full_name);
+			return -EINVAL;
+		}
+		/*
+		 * If wakeup-latency-us is missing, default to entry+exit
+		 * latencies as defined in idle states bindings
+		 */
+		idle_state->exit_latency = entry_latency + exit_latency;
+	}
+
+	err = of_property_read_u32(state_node, "min-residency-us",
+				   &idle_state->target_residency);
+	if (err) {
+		pr_debug(" * %s missing min-residency-us property\n",
+			     state_node->full_name);
+		return -EINVAL;
+	}
+
+	idle_state->flags = CPUIDLE_FLAG_TIME_VALID;
+	if (of_property_read_bool(state_node, "local-timer-stop"))
+		idle_state->flags |= CPUIDLE_FLAG_TIMER_STOP;
+	/*
+	 * TODO:
+	 *	replace with kstrdup and pointer assignment when name
+	 *	and desc become string pointers
+	 */
+	strncpy(idle_state->name, state_node->name, CPUIDLE_NAME_LEN - 1);
+	strncpy(idle_state->desc, state_node->name, CPUIDLE_DESC_LEN - 1);
+	return 0;
+}
+
+/*
+ * Check that the idle state is uniform across all CPUs in the CPUidle driver
+ * cpumask
+ */
+static bool idle_state_valid(struct device_node *state_node, unsigned int idx,
+			     const cpumask_t *cpumask)
+{
+	int cpu;
+	struct device_node *cpu_node, *curr_state_node;
+	bool valid = true;
+
+	/*
+	 * Compare idle state phandles for index idx on all CPUs in the
+	 * CPUidle driver cpumask. Start from next logical cpu following
+	 * cpumask_first(cpumask) since that's the CPU state_node was
+	 * retrieved from. If a mismatch is found bail out straight
+	 * away since we certainly hit a firmware misconfiguration.
+	 */
+	for (cpu = cpumask_next(cpumask_first(cpumask), cpumask);
+	     cpu < nr_cpu_ids; cpu = cpumask_next(cpu, cpumask)) {
+		cpu_node = of_cpu_device_node_get(cpu);
+		curr_state_node = of_parse_phandle(cpu_node, "cpu-idle-states",
+						   idx);
+		if (state_node != curr_state_node)
+			valid = false;
+
+		of_node_put(curr_state_node);
+		of_node_put(cpu_node);
+		if (!valid)
+			break;
+	}
+
+	return valid;
+}
+
+/**
+ * dt_init_idle_driver() - Parse the DT idle states and initialize the
+ *			   idle driver states array
+ * @drv:	  Pointer to CPU idle driver to be initialized
+ * @matches:	  Array of of_device_id match structures to search in for
+ *		  compatible idle state nodes. The data pointer for each valid
+ *		  struct of_device_id entry in the matches array must point to
+ *		  a function with the following signature, that corresponds to
+ *		  the CPUidle state enter function signature:
+ *
+ *		  int (*)(struct cpuidle_device *dev,
+ *			  struct cpuidle_driver *drv,
+ *			  int index);
+ *
+ * @start_idx:    First idle state index to be initialized
+ *
+ * If DT idle states are detected and are valid the state count and states
+ * array entries in the cpuidle driver are initialized accordingly starting
+ * from index start_idx.
+ *
+ * Return: number of valid DT idle states parsed, <0 on failure
+ */
+int dt_init_idle_driver(struct cpuidle_driver *drv,
+			const struct of_device_id *matches,
+			unsigned int start_idx)
+{
+	struct cpuidle_state *idle_state;
+	struct device_node *state_node, *cpu_node;
+	int i, err = 0;
+	const cpumask_t *cpumask;
+	unsigned int state_idx = start_idx;
+
+	if (state_idx >= CPUIDLE_STATE_MAX)
+		return -EINVAL;
+	/*
+	 * We get the idle states for the first logical cpu in the
+	 * driver mask (or cpu_possible_mask if the driver cpumask is not set)
+	 * and we check through idle_state_valid() if they are uniform
+	 * across CPUs, otherwise we hit a firmware misconfiguration.
+	 */
+	cpumask = drv->cpumask ? : cpu_possible_mask;
+	cpu_node = of_cpu_device_node_get(cpumask_first(cpumask));
+
+	for (i = 0; ; i++) {
+		state_node = of_parse_phandle(cpu_node, "cpu-idle-states", i);
+		if (!state_node)
+			break;
+
+		if (!idle_state_valid(state_node, i, cpumask)) {
+			pr_warn("%s idle state not valid, bailing out\n",
+				state_node->full_name);
+			err = -EINVAL;
+			break;
+		}
+
+		if (state_idx == CPUIDLE_STATE_MAX) {
+			pr_warn("State index reached static CPU idle driver states array size\n");
+			break;
+		}
+
+		idle_state = &drv->states[state_idx++];
+		err = init_state_node(idle_state, matches, state_node);
+		if (err) {
+			pr_err("Parsing idle state node %s failed with err %d\n",
+			       state_node->full_name, err);
+			err = -EINVAL;
+			break;
+		}
+		of_node_put(state_node);
+	}
+
+	of_node_put(state_node);
+	of_node_put(cpu_node);
+	if (err)
+		return err;
+	/*
+	 * Update the driver state count only if some valid DT idle states
+	 * were detected
+	 */
+	if (i)
+		drv->state_count = state_idx;
+
+	/*
+	 * Return the number of present and valid DT idle states, which can
+	 * also be 0 on platforms with missing DT idle states or legacy DT
+	 * configuration predating the DT idle states bindings.
+	 */
+	return i;
+}
+EXPORT_SYMBOL_GPL(dt_init_idle_driver);
diff --git a/drivers/cpuidle/dt_idle_states.h b/drivers/cpuidle/dt_idle_states.h
new file mode 100644
index 0000000..4818134
--- /dev/null
+++ b/drivers/cpuidle/dt_idle_states.h
@@ -0,0 +1,7 @@
+#ifndef __DT_IDLE_STATES
+#define __DT_IDLE_STATES
+
+int dt_init_idle_driver(struct cpuidle_driver *drv,
+			const struct of_device_id *matches,
+			unsigned int start_idx);
+#endif
diff --git a/drivers/cpuidle/governors/menu.c b/drivers/cpuidle/governors/menu.c
index 954a30e..c6b0ec3 100644
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@ -31,11 +31,11 @@
  * The default values do not overflow.
  */
 #define BUCKETS 12
-#define INTERVALS 8
+#define INTERVAL_SHIFT 3
+#define INTERVALS (1UL << INTERVAL_SHIFT)
 #define RESOLUTION 1024
 #define DECAY 8
 #define MAX_INTERESTING 50000
-#define STDDEV_THRESH 400
 
 
 /*
@@ -122,9 +122,8 @@ struct menu_device {
 	int		last_state_idx;
 	int             needs_update;
 
-	unsigned int	expected_us;
+	unsigned int	next_timer_us;
 	unsigned int	predicted_us;
-	unsigned int	exit_us;
 	unsigned int	bucket;
 	unsigned int	correction_factor[BUCKETS];
 	unsigned int	intervals[INTERVALS];
@@ -135,15 +134,13 @@ struct menu_device {
 #define LOAD_INT(x) ((x) >> FSHIFT)
 #define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1-1)) * 100)
 
-static int get_loadavg(void)
+static inline int get_loadavg(unsigned long load)
 {
-	unsigned long this = this_cpu_load();
-
-
-	return LOAD_INT(this) * 10 + LOAD_FRAC(this) / 10;
+	return LOAD_INT(load) * 10 + LOAD_FRAC(load) / 10;
 }
 
-static inline int which_bucket(unsigned int duration)
+static inline int which_bucket(unsigned int duration,
+				unsigned long nr_iowaiters)
 {
 	int bucket = 0;
 
@@ -153,7 +150,7 @@ static inline int which_bucket(unsigned int duration)
 	 * This allows us to calculate
 	 * E(duration)|iowait
 	 */
-	if (nr_iowait_cpu(smp_processor_id()))
+	if (nr_iowaiters)
 		bucket = BUCKETS/2;
 
 	if (duration < 10)
@@ -176,21 +173,17 @@ static inline int which_bucket(unsigned int duration)
  * to be, the higher this multiplier, and thus the higher
  * the barrier to go to an expensive C state.
  */
-static inline int performance_multiplier(void)
+static inline int performance_multiplier(unsigned long nr_iowaiters,
+				unsigned long load)
 {
 	int mult = 1;
 
 	/* for higher loadavg, we are more reluctant */
 
-	/*
-	 * this doesn't work as intended - it is almost always 0, but can
-	 * sometimes, depending on workload, spike very high into the hundreds
-	 * even when the average cpu load is under 10%.
-	 */
-	/* mult += 2 * get_loadavg(); */
+	mult += 2 * get_loadavg(load);
 
 	/* for IO wait tasks (per cpu!) we add 5x each */
-	mult += 10 * nr_iowait_cpu(smp_processor_id());
+	mult += 10 * nr_iowaiters;
 
 	return mult;
 }
@@ -199,12 +192,6 @@ static DEFINE_PER_CPU(struct menu_device, menu_devices);
 
 static void menu_update(struct cpuidle_driver *drv, struct cpuidle_device *dev);
 
-/* This implements DIV_ROUND_CLOSEST but avoids 64 bit division */
-static u64 div_round64(u64 dividend, u32 divisor)
-{
-	return div_u64(dividend + (divisor / 2), divisor);
-}
-
 /*
  * Try detecting repeating patterns by keeping track of the last 8
  * intervals, and checking if the standard deviation of that set
@@ -234,7 +221,10 @@ again:
 				max = value;
 		}
 	}
-	do_div(avg, divisor);
+	if (divisor == INTERVALS)
+		avg >>= INTERVAL_SHIFT;
+	else
+		do_div(avg, divisor);
 
 	/* Then try to determine standard deviation */
 	stddev = 0;
@@ -245,7 +235,11 @@ again:
 			stddev += diff * diff;
 		}
 	}
-	do_div(stddev, divisor);
+	if (divisor == INTERVALS)
+		stddev >>= INTERVAL_SHIFT;
+	else
+		do_div(stddev, divisor);
+
 	/*
 	 * The typical interval is obtained when standard deviation is small
 	 * or standard deviation is small compared to the average interval.
@@ -262,7 +256,7 @@ again:
 		stddev = int_sqrt(stddev);
 		if (((avg > stddev * 6) && (divisor * 4 >= INTERVALS * 3))
 							|| stddev <= 20) {
-			if (data->expected_us > avg)
+			if (data->next_timer_us > avg)
 				data->predicted_us = avg;
 			return;
 		}
@@ -291,57 +285,56 @@ again:
  */
 static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)
 {
-	struct menu_device *data = &__get_cpu_var(menu_devices);
+	struct menu_device *data = this_cpu_ptr(&menu_devices);
 	int latency_req = pm_qos_request(PM_QOS_CPU_DMA_LATENCY);
 	int i;
-	int multiplier;
-	struct timespec t;
+	unsigned int interactivity_req;
+	unsigned long nr_iowaiters, cpu_load;
 
 	if (data->needs_update) {
 		menu_update(drv, dev);
 		data->needs_update = 0;
 	}
 
-	data->last_state_idx = 0;
-	data->exit_us = 0;
+	data->last_state_idx = CPUIDLE_DRIVER_STATE_START - 1;
 
 	/* Special case when user has set very strict latency requirement */
 	if (unlikely(latency_req == 0))
 		return 0;
 
 	/* determine the expected residency time, round up */
-	t = ktime_to_timespec(tick_nohz_get_sleep_length());
-	data->expected_us =
-		t.tv_sec * USEC_PER_SEC + t.tv_nsec / NSEC_PER_USEC;
-
-
-	data->bucket = which_bucket(data->expected_us);
+	data->next_timer_us = ktime_to_us(tick_nohz_get_sleep_length());
 
-	multiplier = performance_multiplier();
-
-	/*
-	 * if the correction factor is 0 (eg first time init or cpu hotplug
-	 * etc), we actually want to start out with a unity factor.
-	 */
-	if (data->correction_factor[data->bucket] == 0)
-		data->correction_factor[data->bucket] = RESOLUTION * DECAY;
+	get_iowait_load(&nr_iowaiters, &cpu_load);
+	data->bucket = which_bucket(data->next_timer_us, nr_iowaiters);
 
 	/*
 	 * Force the result of multiplication to be 64 bits even if both
 	 * operands are 32 bits.
 	 * Make sure to round up for half microseconds.
 	 */
-	data->predicted_us = div_round64((uint64_t)data->expected_us *
+	data->predicted_us = DIV_ROUND_CLOSEST_ULL(
+					(uint64_t)data->next_timer_us *
 					 data->correction_factor[data->bucket],
 					 RESOLUTION * DECAY);
 
 	get_typical_interval(data);
 
 	/*
+	 * Performance multiplier defines a minimum predicted idle
+	 * duration / latency ratio. Adjust the latency limit if
+	 * necessary.
+	 */
+	interactivity_req = data->predicted_us /
+		performance_multiplier(nr_iowaiters, cpu_load);
+	if (latency_req > interactivity_req)
+		latency_req = interactivity_req;
+
+	/*
 	 * We want to default to C1 (hlt), not to busy polling
 	 * unless the timer is happening really really soon.
 	 */
-	if (data->expected_us > 5 &&
+	if (data->next_timer_us > 5 &&
 	    !drv->states[CPUIDLE_DRIVER_STATE_START].disabled &&
 		dev->states_usage[CPUIDLE_DRIVER_STATE_START].disable == 0)
 		data->last_state_idx = CPUIDLE_DRIVER_STATE_START;
@@ -350,6 +343,8 @@ static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)
 	 * Find the idle state with the lowest power while satisfying
 	 * our constraints.
 	 */
+	if (unlikely(latency_req == 0))
+		return 0;
 	for (i = CPUIDLE_DRIVER_STATE_START; i < drv->state_count; i++) {
 		struct cpuidle_state *s = &drv->states[i];
 		struct cpuidle_state_usage *su = &dev->states_usage[i];
@@ -360,11 +355,8 @@ static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)
 			continue;
 		if (s->exit_latency > latency_req)
 			continue;
-		if (s->exit_latency * multiplier > data->predicted_us)
-			continue;
 
 		data->last_state_idx = i;
-		data->exit_us = s->exit_latency;
 	}
 
 	return data->last_state_idx;
@@ -380,10 +372,10 @@ static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)
  */
 static void menu_reflect(struct cpuidle_device *dev, int index)
 {
-	struct menu_device *data = &__get_cpu_var(menu_devices);
+	struct menu_device *data = this_cpu_ptr(&menu_devices);
+
 	data->last_state_idx = index;
-	if (index >= 0)
-		data->needs_update = 1;
+	data->needs_update = 1;
 }
 
 /**
@@ -393,38 +385,44 @@ static void menu_reflect(struct cpuidle_device *dev, int index)
  */
 static void menu_update(struct cpuidle_driver *drv, struct cpuidle_device *dev)
 {
-	struct menu_device *data = &__get_cpu_var(menu_devices);
+	struct menu_device *data = this_cpu_ptr(&menu_devices);
 	int last_idx = data->last_state_idx;
-	unsigned int last_idle_us = cpuidle_get_last_residency(dev);
 	struct cpuidle_state *target = &drv->states[last_idx];
 	unsigned int measured_us;
 	unsigned int new_factor;
 
 	/*
-	 * Ugh, this idle state doesn't support residency measurements, so we
-	 * are basically lost in the dark.  As a compromise, assume we slept
-	 * for the whole expected time.
+	 * Try to figure out how much time passed between entry to low
+	 * power state and occurrence of the wakeup event.
+	 *
+	 * If the entered idle state didn't support residency measurements,
+	 * we use them anyway if they are short, and if long,
+	 * truncate to the whole expected time.
+	 *
+	 * Any measured amount of time will include the exit latency.
+	 * Since we are interested in when the wakeup begun, not when it
+	 * was completed, we must subtract the exit latency. However, if
+	 * the measured amount of time is less than the exit latency,
+	 * assume the state was never reached and the exit latency is 0.
 	 */
-	if (unlikely(!(target->flags & CPUIDLE_FLAG_TIME_VALID)))
-		last_idle_us = data->expected_us;
 
+	/* measured value */
+	measured_us = cpuidle_get_last_residency(dev);
 
-	measured_us = last_idle_us;
-
-	/*
-	 * We correct for the exit latency; we are assuming here that the
-	 * exit latency happens after the event that we're interested in.
-	 */
-	if (measured_us > data->exit_us)
-		measured_us -= data->exit_us;
+	/* Deduct exit latency */
+	if (measured_us > target->exit_latency)
+		measured_us -= target->exit_latency;
 
+	/* Make sure our coefficients do not exceed unity */
+	if (measured_us > data->next_timer_us)
+		measured_us = data->next_timer_us;
 
 	/* Update our correction ratio */
 	new_factor = data->correction_factor[data->bucket];
 	new_factor -= new_factor / DECAY;
 
-	if (data->expected_us > 0 && measured_us < MAX_INTERESTING)
-		new_factor += RESOLUTION * measured_us / data->expected_us;
+	if (data->next_timer_us > 0 && measured_us < MAX_INTERESTING)
+		new_factor += RESOLUTION * measured_us / data->next_timer_us;
 	else
 		/*
 		 * we were idle so long that we count it as a perfect
@@ -444,7 +442,7 @@ static void menu_update(struct cpuidle_driver *drv, struct cpuidle_device *dev)
 	data->correction_factor[data->bucket] = new_factor;
 
 	/* update the repeating-pattern data */
-	data->intervals[data->interval_ptr++] = last_idle_us;
+	data->intervals[data->interval_ptr++] = measured_us;
 	if (data->interval_ptr >= INTERVALS)
 		data->interval_ptr = 0;
 }
@@ -458,9 +456,17 @@ static int menu_enable_device(struct cpuidle_driver *drv,
 				struct cpuidle_device *dev)
 {
 	struct menu_device *data = &per_cpu(menu_devices, dev->cpu);
+	int i;
 
 	memset(data, 0, sizeof(struct menu_device));
 
+	/*
+	 * if the correction factor is 0 (eg first time init or cpu hotplug
+	 * etc), we actually want to start out with a unity factor.
+	 */
+	for (i = 0; i < BUCKETS; i++)
+		data->correction_factor[i] = RESOLUTION * DECAY;
+
 	return 0;
 }
 
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 550b392..6ae19cc 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -2151,6 +2151,25 @@ int gpio_for_irq(unsigned gpio, unsigned int flag)
 	return gpiod_for_irq(gpio_to_desc(gpio), flag);
 }
 EXPORT_SYMBOL_GPL(gpio_for_irq);
+int gpiod_mask_irq(const struct gpio_desc *desc, unsigned int flag)
+{
+	struct gpio_chip	*chip;
+	int			offset;
+
+	if (!desc)
+		return -EINVAL;
+	chip = desc->chip;
+	offset = gpio_chip_hwgpio(desc);
+	return chip->mask_gpio_irq ?
+		chip->mask_gpio_irq(chip, offset, flag) : -ENXIO;
+}
+EXPORT_SYMBOL_GPL(gpiod_mask_irq);
+
+int gpio_mask_irq(unsigned gpio, unsigned int flag)
+{
+	return gpiod_mask_irq(gpio_to_desc(gpio), flag);
+}
+EXPORT_SYMBOL_GPL(gpio_mask_irq);
 
 int gpiod_set_pullup(const struct gpio_desc *desc, int val)
 {
diff --git a/drivers/hid/hid-dia-remote.c b/drivers/hid/hid-dia-remote.c
index b80468a..9f91c03 100644
--- a/drivers/hid/hid-dia-remote.c
+++ b/drivers/hid/hid-dia-remote.c
@@ -32,7 +32,7 @@
 #include <sound/info.h>
 #include <sound/initval.h>
 #include <sound/pcm.h>
-
+#include <linux/delay.h>
 #include "hid-ids.h"
 
 MODULE_LICENSE("GPL v2");
@@ -1433,6 +1433,24 @@ __nodev:
 	return err;
 }
 
+static void input_dev_report(struct hid_report *report)
+{
+	struct input_dev *idev = report->field[0]->hidinput->input;
+	int key = KEY_SEARCH;
+	if (idev == NULL)
+		return;
+	input_event(idev, EV_KEY, key, 1);
+	input_sync(idev);
+
+
+	msleep(20);
+	input_event(idev, EV_KEY, key, 0);
+	input_sync(idev);
+
+	pr_info("%s key=%d reported\n", __func__,  key);
+}
+
+
 static int dia_raw_event(struct hid_device *hdev, struct hid_report *report,
 	u8 *data, int size)
 {
@@ -1452,6 +1470,8 @@ if (report->id == ADPCM_AUDIO_REPORT_ID_0 && data[2] == 0) {
 		struct snd_dialog *dia_snd = substream != NULL ?
 		snd_pcm_substream_chip(substream) : s_dia_snd;
 		snd_dialog_log("Stream Enable %d\n", data[1]);
+		if (data[1] == 1)			/*voice function begin*/
+			input_dev_report(report);
 		/* Mark stream enable/disable position */
 		if (data[1]) {
 			dia_snd->stream_enable_pos = dia_snd->num_bytes;
@@ -1474,7 +1494,6 @@ if (report->id == ADPCM_AUDIO_REPORT_ID_0 && data[2] == 0) {
 			}
 		}
 	}
-
 	if (report->id == ADPCM_AUDIO_REPORT_ID_1
 			|| report->id == ADPCM_AUDIO_REPORT_ID_2
 			|| report->id == ADPCM_AUDIO_REPORT_ID_3){
@@ -1484,11 +1503,14 @@ if (report->id == ADPCM_AUDIO_REPORT_ID_0 && data[2] == 0) {
 		/* pr_err("Report size %d", size); */
 		audio_dec(&data[1], PACKET_TYPE_ADPCM, size - 1);
 		/* we've handled the event */
-		return 1;
+		return -1;
 	}
 
-	/* let the event through for regular input processing */
-	return 0;
+
+	if (report->id == ADPCM_AUDIO_REPORT_ID_0)
+		return -1;
+	else
+		return 0;
 }
 
 static int dia_probe(struct hid_device *hdev, const struct hid_device_id *id)
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
index 190eb56..ec3d417 100644
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -46,7 +46,7 @@
 #include "dvbdev.h"
 #include <linux/dvb/version.h>
 
-static int dvb_frontend_debug = 1;
+static int dvb_frontend_debug;
 static int dvb_shutdown_timeout;
 static int dvb_force_auto_inversion;
 static int dvb_override_tune_delay;
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 5534e6a..e566ad8 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -1345,7 +1345,17 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 		/* Erase size depends on CSD and Extended CSD */
 		mmc_set_erase_size(card);
 	}
+	/* If emmc support HW reset so enable the function, when emmc
+	 * switch partition failed or programing stuck, can use this
+	 * function to reset emmc and reinitial.
+	*/
 
+	if (!card->ext_csd.rst_n_function
+		&& (host->caps & MMC_CAP_HW_RESET)) {
+		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_RST_N_FUNCTION, 1,
+			 card->ext_csd.generic_cmd6_time);
+	}
 	/*
 	 * If enhanced_area_en is TRUE, host needs to enable ERASE_GRP_DEF
 	 * bit.  This bit will be lost every time after a reset or power off.
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
index c714255..aeb06b0 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
@@ -37,6 +37,8 @@ static void __iomem *network_interface_setup(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	struct device *dev = &pdev->dev;
 	struct gpio_desc *gdesc;
+	struct gpio_desc *gdesc_z4;
+	struct gpio_desc *gdesc_z5;
 	struct pinctrl *pin_ctl;
 	struct resource *res;
 	struct resource *res2;
@@ -77,28 +79,37 @@ static void __iomem *network_interface_setup(struct platform_device *pdev)
 		if (internal_phy == 1) {
 			pr_debug("internal phy\n");
 			writel(0x10110181, PREG_ETH_REG2);
-			writel(0xe40908ff, PREG_ETH_REG3);
+			writel(0xe489087f, PREG_ETH_REG3);
+			pin_ctl = devm_pinctrl_get_select(&pdev->dev,
+				"internal_eth_pins");
 		} else {
 			writel(0x10110181, PREG_ETH_REG2);
 			writel(0x2009087f, PREG_ETH_REG3);
+			/* pull reset pin for resetting phy  */
+			gdesc = gpiod_get(&pdev->dev, "rst_pin");
+			gdesc_z4 = gpiod_get(&pdev->dev, "GPIOZ4_pin");
+			gdesc_z5 = gpiod_get(&pdev->dev, "GPIOZ5_pin");
+			if (!IS_ERR(gdesc) && !IS_ERR(gdesc_z4)) {
+				gpiod_direction_output(gdesc_z4, 0);
+				gpiod_direction_output(gdesc_z5, 0);
+				gpiod_direction_output(gdesc, 0);
+				mdelay(20);
+				gpiod_direction_output(gdesc, 1);
+				mdelay(100);
+				gpiod_put(gdesc_z4);
+				gpiod_put(gdesc_z5);
+				pr_debug("Ethernet: gpio reset ok\n");
+			}
+			pin_ctl = devm_pinctrl_get_select(&pdev->dev,
+			"external_eth_pins");
 		}
 		pr_debug("REG2:REG3:REG4 = 0x%x :0x%x :0x%x\n",
 			readl(PREG_ETH_REG2), readl(PREG_ETH_REG3),
 			readl(PREG_ETH_REG4));
+	} else {
+		pin_ctl = devm_pinctrl_get_select(&pdev->dev, "eth_pins");
 	}
-	pin_ctl = devm_pinctrl_get_select(&pdev->dev, "eth_pins");
 	pr_debug("Ethernet: pinmux setup ok\n");
-	/* reset pin choose pull high 100ms than pull low */
-	gdesc = gpiod_get(&pdev->dev, "rst_pin");
-	/*
-	if (!IS_ERR(gdesc)) {
-		gpiod_direction_output(gdesc, 0);
-		mdelay(10);
-		gpiod_direction_output(gdesc, 1);
-		mdelay(30);
-	}
-	*/
-	pr_debug("Ethernet: gpio reset ok\n");
 	return addr;
 }
 
diff --git a/drivers/net/phy/amlogic.c b/drivers/net/phy/amlogic.c
index 5719f03..7cb5fa5 100644
--- a/drivers/net/phy/amlogic.c
+++ b/drivers/net/phy/amlogic.c
@@ -555,6 +555,8 @@ static int pmu4_read_status(struct phy_device *phydev)
 
 static void internal_config(struct phy_device *phydev)
 {
+	/*enable auto mdix*/
+	phy_write(phydev, 0x11, 0x0080);
 	/*Enable Analog and DSP register Bank access by*/
 	phy_write(phydev, 0x14, 0x0000);
 	phy_write(phydev, 0x14, 0x0400);
@@ -574,12 +576,37 @@ static void internal_config(struct phy_device *phydev)
 	phy_write(phydev, 0x14, 0x5C1C);
 }
 
+void internal_wol_init(struct phy_device *phydev)
+{
+	int val;
+	unsigned char *mac_addr;
+	mac_addr = phydev->attached_dev->dev_addr;
+	/*chose wol register bank*/
+	val = phy_read(phydev, 0x14);
+	val |= 0x800;
+	val &= ~0x1000;
+	phy_write(phydev, 0x14, val);/*write data to wol register bank*/
+	/*write mac address*/
+	phy_write(phydev, SMI_ADDR_TSTWRITE, mac_addr[0]|mac_addr[1]<<8);
+	phy_write(phydev, 0x14, 0x4800|0x00);
+	phy_write(phydev, SMI_ADDR_TSTWRITE, mac_addr[2]|mac_addr[3]<<8);
+	phy_write(phydev, 0x14, 0x4800|0x01);
+	phy_write(phydev, SMI_ADDR_TSTWRITE, mac_addr[4]|mac_addr[5]<<8);
+	phy_write(phydev, 0x14, 0x4800|0x02);
+	/*enable wol*/
+	phy_write(phydev, SMI_ADDR_TSTWRITE, 0x9);
+	phy_write(phydev, 0x14, 0x4800|0x03);
+	/*enable interrupt*/
+	phy_write(phydev, 0x1E, 0xe00);
+}
+
 static int internal_config_init(struct phy_device *phydev)
 {
 
 	int val;
 	u32 features;
 	internal_config(phydev);
+	internal_wol_init(phydev);
 
 	/* For now, I'll claim that the generic driver supports
 	 * all possible port types
@@ -630,6 +657,20 @@ int internal_phy_resume(struct phy_device *phydev)
 	rc2 = phy_init_hw(phydev);
 	return rc1|rc2;
 }
+int internal_phy_suspend(struct phy_device *phydev)
+{
+	/*do nothing here if you want WOL enabled*/
+	int value;
+
+	mutex_lock(&phydev->lock);
+
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+	mutex_unlock(&phydev->lock);
+
+	return 0;
+}
 
 
 static int amlogic_phy_config_aneg(struct phy_device *phydev)
@@ -764,7 +805,7 @@ static struct phy_driver internal_phy = {
 	.features	= 0,
 	.config_aneg	= genphy_config_aneg,
 	.read_status	= internal_phy_read_status,
-	.suspend	= genphy_suspend,
+	.suspend	= internal_phy_suspend,
 	.resume = internal_phy_resume,
 	.driver	= { .owner = THIS_MODULE, },
 };
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 2e4e06f..6db788d 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -27,6 +27,7 @@
 #define RTL821x_PHYCR2		0x19
 #define RTL821x_CLKOUT_EN	0x1
 #define RTL821x_EPAGSR		0x1f
+#define RTL821x_LCR		    0x10
 
 #define	RTL8211E_INER_LINK_STATUS	0x400
 
@@ -67,6 +68,10 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	val = phy_read(phydev, 0x9);
 	phy_write(phydev, 0x9, val&(~(1<<9)));
 
+	phy_write(phydev, RTL821x_EPAGSR, 0xd04); /*set page 0xd04*/
+	phy_write(phydev, RTL821x_LCR, 0XC171); /*led configuration*/
+	phy_write(phydev, RTL821x_EPAGSR, 0x0);
+
 	/* rx reg 21 bit 3 tx reg 17 bit 8*/
 	/* phy_write(phydev, 0x1f, 0xd08);
 	 * val =  phy_read(phydev, 0x15);
diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
index c0fe609..7efa99c 100644
--- a/drivers/pinctrl/core.c
+++ b/drivers/pinctrl/core.c
@@ -231,7 +231,7 @@ static int pinctrl_register_one_pin(struct pinctrl_dev *pctldev,
 
 	pindesc = pin_desc_get(pctldev, number);
 	if (pindesc != NULL) {
-		pr_err("pin %d already registered on %s\n", number,
+		pr_err("pin %d(%s) already registered on %s\n", number, name,
 		       pctldev->desc->name);
 		return -EINVAL;
 	}
diff --git a/drivers/thermal/of-thermal.c b/drivers/thermal/of-thermal.c
index 321bd98..26b46e1 100644
--- a/drivers/thermal/of-thermal.c
+++ b/drivers/thermal/of-thermal.c
@@ -284,11 +284,21 @@ static int of_thermal_set_mode(struct thermal_zone_device *tz,
 
 	mutex_lock(&tz->lock);
 
-	if (mode == THERMAL_DEVICE_ENABLED)
+	/* passive_delay should be cleared if disabled */
+	if (mode == THERMAL_DEVICE_ENABLED) {
 		tz->polling_delay = data->polling_delay;
-	else
+		tz->passive_delay = data->passive_delay;
+	} else {
 		tz->polling_delay = 0;
+		tz->passive_delay = 0;
+	}
 
+	/*
+	 * give opportunity that theraml device can
+	 * do something when mode change
+	 */
+	if (data->ops && data->ops->set_mode)
+		data->ops->set_mode(tz, mode);
 	mutex_unlock(&tz->lock);
 
 	data->mode = mode;
diff --git a/drivers/thermal/power_allocator.c b/drivers/thermal/power_allocator.c
index 45d87b0..fe3f3e6 100644
--- a/drivers/thermal/power_allocator.c
+++ b/drivers/thermal/power_allocator.c
@@ -472,6 +472,17 @@ static int power_allocator_throttle(struct thermal_zone_device *tz, int trip)
 	int ret;
 	unsigned long switch_on_temp, control_temp, current_temp;
 	struct power_allocator_params *params = tz->governor_data;
+	struct thermal_zone_device_ops *ops;
+	enum thermal_device_mode mode;
+
+	ops = tz->ops;
+	if (ops->get_mode && !ops->get_mode(tz, &mode)) {
+		/* do nothing if thermal disabled */
+	    if (mode == THERMAL_DEVICE_DISABLED) {
+			dev_warn(&tz->device, "thermal disabled, nothing to do\n");
+			return 0;
+	    }
+	}
 
 	/*
 	 * We get called for every trip point but we only need to do
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index b195fdb..f9bbca4 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -165,6 +165,9 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* INTEL VALUE SSD */
 	{ USB_DEVICE(0x8086, 0xf1a5), .driver_info = USB_QUIRK_RESET_RESUME },
 
+	{ USB_DEVICE(0x1fc9, 0x0011), .driver_info =
+			USB_QUIRK_DEVICE_QUALIFIER },
+
 	{ }  /* terminating entry must be last */
 };
 
diff --git a/drivers/usb/phy/phy-aml-new-usb2.c b/drivers/usb/phy/phy-aml-new-usb2.c
index 5627706..d64733b 100644
--- a/drivers/usb/phy/phy-aml-new-usb2.c
+++ b/drivers/usb/phy/phy-aml-new-usb2.c
@@ -28,6 +28,17 @@ static int amlogic_new_usb2_init(struct usb_phy *x)
 
 	if (phy->suspend_flag) {
 		phy->suspend_flag = 0;
+		for (i = 0; i < phy->portnum; i++) {
+			for (j = 0; j < 3; j++) {
+				u2p_aml_regs.u2p_r[j] = (void __iomem	*)
+				((unsigned long)phy->regs + i*PHY_REGISTER_SIZE
+					+ 4 * j);
+			}
+
+			reg0.d32 = readl(u2p_aml_regs.u2p_r[0]);
+			reg0.b.por = 0;
+			writel(reg0.d32, u2p_aml_regs.u2p_r[0]);
+		}
 		return 0;
 	}
 
@@ -66,8 +77,22 @@ static int amlogic_new_usb2_suspend(struct usb_phy *x, int suspend)
 static void amlogic_new_usb2phy_shutdown(struct usb_phy *x)
 {
 	struct amlogic_usb *phy = phy_to_amlusb(x);
+	struct u2p_aml_regs_t u2p_aml_regs;
+	union u2p_r0_t reg0;
+	int i, j;
 
 	phy->suspend_flag = 1;
+	for (i = phy->portnum - 1; i >= 0; i--) {
+		for (j = 0; j < 3; j++) {
+			u2p_aml_regs.u2p_r[j] = (void __iomem	*)
+				((unsigned long)phy->regs + i*PHY_REGISTER_SIZE
+				+ 4 * j);
+		}
+
+		reg0.d32 = readl(u2p_aml_regs.u2p_r[0]);
+		reg0.b.por = 1;
+		writel(reg0.d32, u2p_aml_regs.u2p_r[0]);
+	}
 }
 
 static int amlogic_new_usb2_probe(struct platform_device *pdev)
diff --git a/include/dt-bindings/clock/gxbb.h b/include/dt-bindings/clock/gxbb.h
index 429540b..b1f33f9 100644
--- a/include/dt-bindings/clock/gxbb.h
+++ b/include/dt-bindings/clock/gxbb.h
@@ -53,7 +53,8 @@
 #define CLK_BT656_CLK1		39
 #define CLK_VID_LOCK_CLK	40
 #define CLK_APB_P			41
-
+#define CLK_PCM_MCLK        42
+#define CLK_PCM_SCLK        43
 
 /* must be greater than maximal clock id */
 #define CLK_NR_CLKS		100
diff --git a/include/dt-bindings/clock/gxl.h b/include/dt-bindings/clock/gxl.h
index 98f6aab..e1212da 100644
--- a/include/dt-bindings/clock/gxl.h
+++ b/include/dt-bindings/clock/gxl.h
@@ -53,6 +53,8 @@
 #define CLK_BT656_CLK1		39
 #define CLK_VID_LOCK_CLK	40
 
+#define CLK_PCM_MCLK        42
+#define CLK_PCM_SCLK        43
 
 /* must be greater than maximal clock id */
 #define CLK_NR_CLKS		100
diff --git a/include/dt-bindings/clock/gxtvbb.h b/include/dt-bindings/clock/gxtvbb.h
index a082d7d..7fcc06e 100644
--- a/include/dt-bindings/clock/gxtvbb.h
+++ b/include/dt-bindings/clock/gxtvbb.h
@@ -60,6 +60,8 @@
 #define CLK_HDMIRX_AUDMEAS_CLK	45
 /* hdmirx */
 #define CLK_VDIN_MEAS_CLK	46
+#define CLK_PCM_MCLK        47
+#define CLK_PCM_SCLK        48
 
 /* must be greater than maximal clock id */
 #define CLK_NR_CLKS		100
diff --git a/include/dt-bindings/clock/txl.h b/include/dt-bindings/clock/txl.h
new file mode 100644
index 0000000..018e795
--- /dev/null
+++ b/include/dt-bindings/clock/txl.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2016 Amlogic, Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Device Tree binding constants for Meson8 clock controller.
+*/
+
+#ifndef _DT_BINDINGS_CLOCK_TXL_H
+#define _DT_BINDINGS_CLOCK_TXL_H
+
+/* core clocks */
+#define CLK_FIXED_PLL		1
+#define CLK_XTAL		2
+#define CLK_DDR_PLL		3
+#define CLK_G_PLL		4
+#define CLK_VID_PLL		5
+#define CLK_HDMITX_PLL		6
+#define CLK_FPLL_DIV2		7
+#define CLK_FPLL_DIV3		8
+#define CLK_FPLL_DIV4		9
+#define CLK_81			10
+#define CLK_HDMITX_SYS		11
+#define CLK_HDMITX_ENCP		12
+#define CLK_HDMITX_ENCI		13
+#define CLK_HDMITX_PIXEL	14
+#define CLK_HDMITX_PHY		15
+#define CLK_SYS_PLL		16
+#define CLK_FPLL_DIV5		17
+#define CLK_FPLL_DIV7		18
+#define CLK_GPU_0		19
+#define CLK_GPU_1		20
+#define CLK_GPU			21
+#define CLK_VID			22
+#define CLK_VAPB_0		23
+#define CLK_VAPB_1		24
+#define CLK_GE2D		25
+#define CLK_CAMERA_12M		26
+#define CLK_CAMERA_24M		27
+
+#define GP0_PLL			30
+
+#define CLK_MPLL0		31
+#define CLK_MPLL1		32
+#define CLK_MPLL2		33
+#define CLK_AMCLK		34
+#define CLK_PDM			35
+#define CLK_I958		36
+#define CLK_SPDIF		37
+#define CLK_BT656_CLK0		38
+#define CLK_BT656_CLK1		39
+#define CLK_VID_LOCK_CLK	40
+#define CLK_APB_P		41
+/* hdmirx */
+#define CLK_HDMIRX_MODET_CLK	42
+#define CLK_HDMIRX_CFG_CLK		43
+#define CLK_HDMIRX_ACR_REF_CLK	44
+#define CLK_HDMIRX_AUDMEAS_CLK	45
+#define CLK_VDIN_MEAS_CLK	46
+/* must be greater than maximal clock id */
+#define CLK_NR_CLKS		100
+#define CLK_MALI_0		CLK_GPU_0
+#define CLK_MALI_1		CLK_GPU_1
+#define CLK_MALI		CLK_GPU
+
+#endif /* _DT_BINDINGS_CLOCK_TXL_H */
diff --git a/include/dt-bindings/gpio/txl.h b/include/dt-bindings/gpio/txl.h
new file mode 100644
index 0000000..3f147a4
--- /dev/null
+++ b/include/dt-bindings/gpio/txl.h
@@ -0,0 +1,189 @@
+/*
+ * include/dt-bindings/gpio/txl.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __DT_BINDINGS_GPIO_TXL_H
+#define __DT_BINDINGS_GPIO_TXL_H
+
+/*
+ * NOTICE: The gpio number sequence according to the gpio interrupts.
+ */
+
+
+/* AO Bank */
+#define GPIO_AO_BASE		(0)
+#define	GPIO_AO_SIZE		(12)
+
+/* gpioao */
+#define GPIOAO_BASE		(0)
+#define	GPIOAO_SIZE		(12)
+
+#define	GPIOAO_0		(GPIOAO_BASE + 0)
+#define	GPIOAO_1		(GPIOAO_BASE + 1)
+#define	GPIOAO_2		(GPIOAO_BASE + 2)
+#define	GPIOAO_3		(GPIOAO_BASE + 3)
+#define	GPIOAO_4		(GPIOAO_BASE + 4)
+#define	GPIOAO_5		(GPIOAO_BASE + 5)
+#define	GPIOAO_6		(GPIOAO_BASE + 6)
+#define	GPIOAO_7		(GPIOAO_BASE + 7)
+#define	GPIOAO_8		(GPIOAO_BASE + 8)
+#define	GPIOAO_9		(GPIOAO_BASE + 9)
+#define	GPIOAO_10		(GPIOAO_BASE + 10)
+#define	GPIOAO_11		(GPIOAO_BASE + 11)
+
+
+/* EE Bank */
+#define GPIO_EE_BASE		(0)
+
+/* gpioz */
+#define	GPIOZ_BASE		(0)
+#define	GPIOZ_SIZE		(22)
+
+#define	GPIOZ_0			(GPIOZ_BASE + 0)
+#define	GPIOZ_1			(GPIOZ_BASE + 1)
+#define	GPIOZ_2			(GPIOZ_BASE + 2)
+#define	GPIOZ_3			(GPIOZ_BASE + 3)
+#define	GPIOZ_4			(GPIOZ_BASE + 4)
+#define	GPIOZ_5			(GPIOZ_BASE + 5)
+#define	GPIOZ_6			(GPIOZ_BASE + 6)
+#define	GPIOZ_7			(GPIOZ_BASE + 7)
+#define	GPIOZ_8			(GPIOZ_BASE + 8)
+#define	GPIOZ_9			(GPIOZ_BASE + 9)
+#define	GPIOZ_10		(GPIOZ_BASE + 10)
+#define	GPIOZ_11		(GPIOZ_BASE + 11)
+#define	GPIOZ_12		(GPIOZ_BASE + 12)
+#define	GPIOZ_13		(GPIOZ_BASE + 13)
+#define	GPIOZ_14		(GPIOZ_BASE + 14)
+#define	GPIOZ_15		(GPIOZ_BASE + 15)
+#define	GPIOZ_16		(GPIOZ_BASE + 16)
+#define	GPIOZ_17		(GPIOZ_BASE + 17)
+#define	GPIOZ_18		(GPIOZ_BASE + 18)
+#define	GPIOZ_19		(GPIOZ_BASE + 19)
+#define	GPIOZ_20		(GPIOZ_BASE + 20)
+#define	GPIOZ_21		(GPIOZ_BASE + 21)
+
+
+/* gpioh */
+#define	GPIOH_BASE		(GPIOZ_BASE + GPIOZ_SIZE) /* 22 */
+#define	GPIOH_SIZE		(10)
+
+#define	GPIOH_0			(GPIOH_BASE + 0)
+#define	GPIOH_1			(GPIOH_BASE + 1)
+#define	GPIOH_2			(GPIOH_BASE + 2)
+#define	GPIOH_3			(GPIOH_BASE + 3)
+#define	GPIOH_4			(GPIOH_BASE + 4)
+#define	GPIOH_5			(GPIOH_BASE + 5)
+#define	GPIOH_6			(GPIOH_BASE + 6)
+#define	GPIOH_7			(GPIOH_BASE + 7)
+#define	GPIOH_8			(GPIOH_BASE + 8)
+#define	GPIOH_9			(GPIOH_BASE + 9)
+
+
+/* boot */
+#define	BOOT_BASE		(GPIOH_BASE + GPIOH_SIZE)
+#define	BOOT_SIZE		(12)
+
+#define	BOOT_0			(BOOT_BASE + 0)
+#define	BOOT_1			(BOOT_BASE + 1)
+#define	BOOT_2			(BOOT_BASE + 2)
+#define	BOOT_3			(BOOT_BASE + 3)
+#define	BOOT_4			(BOOT_BASE + 4)
+#define	BOOT_5			(BOOT_BASE + 5)
+#define	BOOT_6			(BOOT_BASE + 6)
+#define	BOOT_7			(BOOT_BASE + 7)
+#define	BOOT_8			(BOOT_BASE + 8)
+#define	BOOT_9			(BOOT_BASE + 9)
+#define	BOOT_10			(BOOT_BASE + 10)
+#define	BOOT_11			(BOOT_BASE + 11)
+
+
+/* card */
+#define	CARD_BASE		(BOOT_BASE + BOOT_SIZE)
+#define	CARD_SIZE		(7)
+
+#define	CARD_0			(CARD_BASE + 0)
+#define	CARD_1			(CARD_BASE + 1)
+#define	CARD_2			(CARD_BASE + 2)
+#define	CARD_3			(CARD_BASE + 3)
+#define	CARD_4			(CARD_BASE + 4)
+#define	CARD_5			(CARD_BASE + 5)
+#define	CARD_6			(CARD_BASE + 6)
+
+/* gpiodv */
+#define	GPIODV_BASE		(CARD_BASE + CARD_SIZE)
+#define	GPIODV_SIZE		(12)
+
+#define	GPIODV_0		(GPIODV_BASE + 0)
+#define	GPIODV_1		(GPIODV_BASE + 1)
+#define	GPIODV_2		(GPIODV_BASE + 2)
+#define	GPIODV_3		(GPIODV_BASE + 3)
+#define	GPIODV_4		(GPIODV_BASE + 4)
+#define	GPIODV_5		(GPIODV_BASE + 5)
+#define	GPIODV_6		(GPIODV_BASE + 6)
+#define	GPIODV_7		(GPIODV_BASE + 7)
+#define	GPIODV_8		(GPIODV_BASE + 8)
+#define	GPIODV_9		(GPIODV_BASE + 9)
+#define	GPIODV_10		(GPIODV_BASE + 10)
+#define	GPIODV_11		(GPIODV_BASE + 11)
+
+/* gpiow */
+#define	GPIOW_BASE		(GPIODV_BASE + GPIODV_SIZE)
+#define	GPIOW_SIZE		(16)
+
+#define	GPIOW_0			(GPIOW_BASE + 0)
+#define	GPIOW_1			(GPIOW_BASE + 1)
+#define	GPIOW_2			(GPIOW_BASE + 2)
+#define	GPIOW_3			(GPIOW_BASE + 3)
+#define	GPIOW_4			(GPIOW_BASE + 4)
+#define	GPIOW_5			(GPIOW_BASE + 5)
+#define	GPIOW_6			(GPIOW_BASE + 6)
+#define	GPIOW_7			(GPIOW_BASE + 7)
+#define	GPIOW_8			(GPIOW_BASE + 8)
+#define	GPIOW_9			(GPIOW_BASE + 9)
+#define	GPIOW_10		(GPIOW_BASE + 10)
+#define	GPIOW_11		(GPIOW_BASE + 11)
+#define	GPIOW_12		(GPIOW_BASE + 12)
+#define	GPIOW_13		(GPIOW_BASE + 13)
+#define	GPIOW_14		(GPIOW_BASE + 14)
+#define	GPIOW_15		(GPIOW_BASE + 15)
+
+/* gpioclk */
+#define	GPIOCLK_BASE		(GPIOW_BASE + GPIOW_SIZE)
+#define	GPIOCLK_SIZE		(2)
+
+#define	GPIOCLK_0		(GPIOCLK_BASE + 0)
+#define	GPIOCLK_1		(GPIOCLK_BASE + 1)
+
+/* test_n */
+#define	GPIO_TEST_N_BASE	(GPIOCLK_BASE + GPIOCLK_SIZE)
+#define	GPIO_TEST_N_SIZE	(1)
+
+#define	GPIO_TEST_N		(GPIO_TEST_N_BASE + 0)
+
+/* usb_ */
+#define GPIO_USB_BASE		(GPIO_TEST_N_BASE + GPIO_TEST_N_SIZE)
+#define GPIO_USB_SIZE		(2)
+
+#define GPIO_USB_DPDM		(GPIO_USB_BASE + 0)
+#define GPIO_USB_DMDP		(GPIO_USB_BASE + 1)
+
+#define GPIO_EE_SIZE		(84)
+
+/* AO REG */
+#define	AO		0x10
+#define	AO2		0x11
+
+#endif
diff --git a/include/dt-bindings/reset/aml_txl.h b/include/dt-bindings/reset/aml_txl.h
new file mode 100644
index 0000000..5b85305
--- /dev/null
+++ b/include/dt-bindings/reset/aml_txl.h
@@ -0,0 +1,144 @@
+#ifndef __TXL_GATE_DTBINDING_H
+#define __TXL_GATE_DTBINDING_H
+/*0x50*/
+#define GCLK_IDX_DDR         0
+#define GCLK_IDX_DOS         1
+#define GCLK_IDX_RESERVED0         2
+#define GCLK_IDX_RESERVED1         3
+#define GCLK_IDX_AHB_BRIDGE_ABD         4
+#define GCLK_IDX_ISA         5
+#define GCLK_IDX_PL310_CBUS         6
+#define GCLK_IDX__1200XXX       7
+#define GCLK_IDX_SPICC         8
+#define GCLK_IDX_I2C         9
+#define GCLK_IDX_SAR_ADC         10
+#define GCLK_IDX_SMART_CARD_MPEG_DOMAIN         11
+#define GCLK_IDX_RANDOM_NUM_GEN         12
+#define GCLK_IDX_UART0         13
+#define GCLK_IDX_SDHC_ABD         14
+#define GCLK_IDX_STREAM         15
+#define GCLK_IDX_ASYNC_FIFO         16
+#define GCLK_IDX_SDIO_ABD         17
+#define GCLK_IDX_AUD_BUF_ABD         18
+#define GCLK_IDX_HIU_PARSER         19
+#define GCLK_IDX_RESERVED2         20
+#define GCLK_IDX_HDMI_RX_ABD         21
+#define GCLK_IDX_RESERVED3         22
+#define GCLK_IDX_ASSIST_MISC         23
+#define GCLK_IDX_EMMCA         24
+#define GCLK_IDX_EMMCB         25
+#define GCLK_IDX_EMMCC         26
+#define GCLK_IDX_DMA         27
+#define GCLK_IDX_ACODEC         28
+#define GCLK_IDX_RESERVED9         29
+#define GCLK_IDX_SPI         30
+/*0x51*/
+#define GCLK_IDX_RESERVED11         32
+#define GCLK_IDX_RESERVED12         33
+#define GCLK_IDX_AUD_IN         34
+#define GCLK_IDX_ETHERNET         35
+#define GCLK_IDX_DEMUX        36
+#define GCLK_IDX_RESERVED13         37
+#define GCLK_IDX_AIU_AI_TOP_GLUE         38
+#define GCLK_IDX_AIU_IEC958         39
+#define GCLK_IDX_AIU_I2S_OUT         40
+#define GCLK_IDX_AIU_AMCLK_MEASURE         41
+#define GCLK_IDX_AIU_AIFIFO2         42
+#define GCLK_IDX_AIU_AUD_MIXER         43
+#define GCLK_IDX_AIU_MIXER_REG         44
+#define GCLK_IDX_AIU_ADC         45
+#define GCLK_IDX_BLK_MOV         46
+#define GCLK_IDX_AIU_TOP_LEVEL         47
+#define GCLK_IDX_UART1         48
+#define GCLK_IDX_RESERVED14         49
+#define GCLK_IDX_CSI_DIG_CLKIN_ABD         50
+#define GCLK_IDX_RESERVED15         51
+#define GCLK_IDX_GE2D         52
+#define GCLK_IDX_USB0         53
+#define GCLK_IDX_USB1         54
+#define GCLK_IDX_RESET         55
+#define GCLK_IDX_NAND_ABD         56
+#define GCLK_IDX_HIU_PARSER_TOP         57
+#define GCLK_IDX_USB_GENERAL         58
+#define GCLK_IDX_RESERVED16         59
+#define GCLK_IDX_RESERVED17         60
+#define GCLK_IDX_AHB_ARB0         61
+#define GCLK_IDX_EFUSE         62
+#define GCLK_IDX_ROM_CLK         63
+
+/*******0x52********/
+#define GCLK_IDX_RESERVED18         64
+#define GCLK_IDX_AHB_DATA_BUS         65
+#define GCLK_IDX_AHB_CONTROL_BUS         66
+#define GCLK_IDX_HDMI_INTR_SYNC         67
+#define GCLK_IDX_HDMI_PCLK         68
+#define GCLK_IDX_PDM        69
+#define GCLK_IDX_BT656         70
+#define GCLK_IDX_BT656_2         71
+#define GCLK_IDX_MISC_USB1_TO_DDR         72
+#define GCLK_IDX_MISC_USB0_TO_DDR         73
+#define GCLK_IDX_AIU_PCLK        74
+#define GCLK_IDX_MMC_PCLK         75
+#define GCLK_IDX_MISC_DVIN         76
+#define GCLK_IDX_RESERVED22         77
+#define GCLK_IDX_RESERVED23         78
+#define GCLK_IDX_UART2         79
+#define GCLK_IDX_RESERVED24         80
+#define GCLK_IDX_RESERVED25         81
+#define GCLK_IDX_RESERVED26         82
+#define GCLK_IDX_RESERVED27         83
+#define GCLK_IDX_RESERVED28         84
+#define GCLK_IDX_UART3         85
+#define GCLK_IDX_SARADC        86
+#define GCLK_IDX_RESERVED30        87
+#define GCLK_IDX_RESERVED31        88
+#define GCLK_IDX_VPU_INTR        89
+#define GCLK_IDX_SECURE_AHP_APB3        90
+#define GCLK_IDX_RESERVED32        91
+#define GCLK_IDX_RESERVED33        92
+#define GCLK_IDX_CLK81_TO_A9_ABD        93
+#define GCLK_IDX_GIC        94
+#define GCLK_IDX_RESERVED35        95
+/*0x1053 all reserved*/
+/*****54***********/
+#define GCLK_IDX_RESERVED36        (96+32)
+#define GCLK_IDX_VCLK2_VENCI         (97+32)
+#define GCLK_IDX_VCLK2_VENCI1         (98+32)
+#define GCLK_IDX_VCLK2_VENCP         (99+32)
+#define GCLK_IDX_VCLK2_VENCP1         (100+32)
+#define GCLK_IDX_VCLK2_VENCT         (101+32)
+#define GCLK_IDX_VCLK2_VENCT1         (102+32)
+#define GCLK_IDX_VCLK2_OTHER         (103+32)
+#define GCLK_IDX_VCLK2_ENCI         (104+32)
+#define GCLK_IDX_VCLK2_ENCP         (105+32)
+#define GCLK_IDX_DAC_CLK         (106+32)
+#define GCLK_IDX_RESERVED37        (107+32)
+#define GCLK_IDX_RESERVED38        (108+32)
+#define GCLK_IDX_RESERVED39        (109+32)
+#define GCLK_IDX_AIU_AOCLK         (110+32)
+#define GCLK_IDX_RESERVED40         (111+32)
+#define GCLK_IDX_AIU_ICE958_AMCLK         (112+32)
+#define GCLK_IDX_RESERVED41         (113+32)
+#define GCLK_IDX_RESERVED42         (114+32)
+#define GCLK_IDX_RESERVED43         (115+32)
+#define GCLK_IDX_ENC480P         (116+32)
+#define GCLK_IDX_RANDOM_NUM_GEN1         (117+32)
+#define GCLK_IDX_VCLK2_ENCT         (118+32)
+#define GCLK_IDX_VCLK2_ENCL         (119+32)
+#define GCLK_IDX_MMC_CLK         (120+32)
+#define GCLK_IDX_VCLK2_VENCL         (121+32)
+#define GCLK_IDX_VCLK2_OTHER1         (122+32)
+#define GCLK_IDX_RESERVED44         (123+32)
+#define GCLK_IDX_RESERVED45         (124+32)
+#define GCLK_IDX_RESERVED46         (125+32)
+#define GCLK_IDX_RESERVED47         (126+32)
+#define GCLK_IDX_EDP_CLK_ABD         (127+32)
+
+/*************0x1055***************/
+#define GCLK_IDX_AO_CPU         (128+32)
+#define GCLK_IDX_AHB_SRAM         (129+32)
+#define GCLK_IDX_AHB_BUS         (130+32)
+#define GCLK_IDX_AO_REGS         (131+32)
+#define GCLK_IDX_AO_I2C         (132+32)
+
+#endif
diff --git a/include/linux/amlogic/amports/jpegdec.h b/include/linux/amlogic/amports/jpegdec.h
index 9fe0cdb..5d1917e 100644
--- a/include/linux/amlogic/amports/jpegdec.h
+++ b/include/linux/amlogic/amports/jpegdec.h
@@ -18,13 +18,6 @@
 #ifndef JPEGDEC_H
 #define JPEGDEC_H
 
-#define JPEGDEC_IOC_MAGIC  'J'
-
-#define JPEGDEC_IOC_INFOCONFIG	_IOW(JPEGDEC_IOC_MAGIC, 0x00, unsigned int)
-#define JPEGDEC_IOC_DECCONFIG	_IOW(JPEGDEC_IOC_MAGIC, 0x01, unsigned int)
-#define JPEGDEC_IOC_INFO _IOW(JPEGDEC_IOC_MAGIC, 0x02, unsigned int)
-#define JPEGDEC_IOC_STAT _IOW(JPEGDEC_IOC_MAGIC, 0x03, unsigned int)
-#define JPEGDEC_G_MEM_INFO _IOW(JPEGDEC_IOC_MAGIC, 0x04, unsigned int)
 
 #define JPEGDEC_OPT_THUMBNAIL_ONLY		0x01
 #define JPEGDEC_OPT_THUMBNAIL_PREFERED	0x02
@@ -42,6 +35,7 @@
 #define JPEGDEC_STAT_UNSUPPORT			0x10
 #define JPEGDEC_STAT_INFO_READY			0x20
 #define JPEGDEC_STAT_DONE				0x40
+
 enum jpegdec_angle_e {
 	CLKWISE_0 = 0,
 	CLKWISE_90 = 1,
@@ -77,9 +71,52 @@ struct jpegdec_config_s {
 
 	unsigned dec_h;
 
-	jpegdec_angle_t angle;
+	enum jpegdec_angle_e angle;
 };
 
+struct compat_jpegdec_config_s {
+
+	compat_uptr_t addr_y;
+
+	compat_uptr_t addr_u;
+
+	compat_uptr_t addr_v;
+
+	unsigned canvas_width;
+
+	unsigned opt;
+
+	unsigned src_crop_x;
+
+	unsigned src_crop_y;
+
+	unsigned src_crop_w;
+
+	unsigned src_crop_h;
+
+	unsigned dec_x;
+
+	unsigned dec_y;
+
+	unsigned dec_w;
+
+	unsigned dec_h;
+
+	enum jpegdec_angle_e angle;
+};
+
+#define JPEGDEC_IOC_MAGIC  'J'
+
+#define JPEGDEC_IOC_INFOCONFIG	_IOW(JPEGDEC_IOC_MAGIC, 0x00, unsigned int)
+#define JPEGDEC_IOC_DECCONFIG	\
+	_IOW(JPEGDEC_IOC_MAGIC, 0x01, struct jpegdec_config_s)
+#define JPEGDEC_IOC_DECCONFIG32	 \
+	_IOW(JPEGDEC_IOC_MAGIC, 0x01, struct compat_jpegdec_config_s)
+#define JPEGDEC_IOC_INFO _IOW(JPEGDEC_IOC_MAGIC, 0x02, unsigned int)
+#define JPEGDEC_IOC_STAT _IOW(JPEGDEC_IOC_MAGIC, 0x03, unsigned int)
+#define JPEGDEC_G_MEM_INFO _IOW(JPEGDEC_IOC_MAGIC, 0x04, unsigned int)
+
+
 struct jpegdec_info_s {
 
 	unsigned width;
@@ -93,7 +130,7 @@ struct jpegdec_info_s {
 
 struct jpegdec_mem_info_s {
 
-	jpegdec_angle_t angle;
+	enum jpegdec_angle_e angle;
 
 	unsigned dec_w;
 
diff --git a/include/linux/amlogic/amports/vframe.h b/include/linux/amlogic/amports/vframe.h
index 04a4fb0..af69132 100644
--- a/include/linux/amlogic/amports/vframe.h
+++ b/include/linux/amlogic/amports/vframe.h
@@ -197,7 +197,7 @@ enum vframe_secam_phase_e {
 
 #define BITDEPTH_MASK (BITDEPTH_YMASK | BITDEPTH_UMASK | BITDEPTH_VMASK)
 #define BITDEPTH_SAVING_MODE	0x1
-
+#define FULL_PACK_422_MODE		0x2
 struct vframe_s {
 	u32 index;
 	u32 type;
diff --git a/include/linux/amlogic/amports/video.h b/include/linux/amlogic/amports/video.h
index 0411e66..3d91272 100644
--- a/include/linux/amlogic/amports/video.h
+++ b/include/linux/amlogic/amports/video.h
@@ -26,6 +26,10 @@ int RDMA_SET_READ(u32 adr);
 #endif
 
 void try_free_keep_video(void);
+void vh265_free_cmabuf(void);
+void vh264_4k_free_cmabuf(void);
+void vdec_free_cmabuf(void);
+
 
 #endif
 
diff --git a/include/linux/amlogic/amvecm/amvecm.h b/include/linux/amlogic/amvecm/amvecm.h
index 3004e8d..eee4e9f 100644
--- a/include/linux/amlogic/amvecm/amvecm.h
+++ b/include/linux/amlogic/amvecm/amvecm.h
@@ -144,6 +144,7 @@ extern signed int vd1_brightness, vd1_contrast;
 
 extern void amvecm_on_vs(struct vframe_s *vf);
 extern void refresh_on_vs(struct vframe_s *vf);
+extern void pc_mode_process(void);
 
 #endif /* AMVECM_H */
 
diff --git a/include/linux/amlogic/amvecm/ve.h b/include/linux/amlogic/amvecm/ve.h
index e8168e8..dfee37c 100644
--- a/include/linux/amlogic/amvecm/ve.h
+++ b/include/linux/amlogic/amvecm/ve.h
@@ -83,7 +83,7 @@ struct ve_dnlp_table_s {
 	unsigned int new_clashEnd;
 	unsigned int new_cliprate;
 	unsigned int new_mtdbld_rate;
-	unsigned int new_blkgma_rate;
+	unsigned int new_dnlp_pst_gmarat;
 	unsigned int dnlp_sel;
 	unsigned int dnlp_blk_cctr;/*blk signal add brightness*/
 	unsigned int dnlp_brgt_ctrl;
@@ -103,6 +103,27 @@ struct ve_dnlp_table_s {
 	unsigned int dnlp_wextmx;
 	unsigned int dnlp_smhist_ck;
 	unsigned int dnlp_glb_crate;/*12*/
+	unsigned int dnlp_pstgma_brghtrate;
+	unsigned int dnlp_pstgma_brghtrat1;
+	unsigned int dnlp_wext_autorat;
+	unsigned int dnlp_cliprate_min;
+	unsigned int dnlp_adpcrat_lbnd;
+	unsigned int dnlp_adpcrat_hbnd;
+	unsigned int dnlp_adpmtd_lbnd;
+	unsigned int dnlp_adpmtd_hbnd;
+	unsigned int dnlp_set_bext;
+	unsigned int dnlp_set_wext;
+	unsigned int dnlp_satur_rat;
+	unsigned int dnlp_satur_max;
+	unsigned int blk_prct_rng;
+	unsigned int blk_prct_max;
+	unsigned int dnlp_lowrange;
+	unsigned int dnlp_hghrange;
+	unsigned int dnlp_auto_rng;
+	unsigned int dnlp_bin0_absmax;
+	unsigned int dnlp_bin0_sbtmax;
+	unsigned int dnlp_adpalpha_lrate;
+	unsigned int dnlp_adpalpha_hrate;
 	unsigned int dnlp_lrate00;/*0-64bin curve slope*/
 	unsigned int dnlp_lrate02;
 	unsigned int dnlp_lrate04;
diff --git a/include/linux/amlogic/cpu_version.h b/include/linux/amlogic/cpu_version.h
index 7efafae..d6a1b8c 100644
--- a/include/linux/amlogic/cpu_version.h
+++ b/include/linux/amlogic/cpu_version.h
@@ -49,6 +49,7 @@
 #define MESON_CPU_MAJOR_ID_GXTVBB	0x20
 #define MESON_CPU_MAJOR_ID_GXL		0x21
 #define MESON_CPU_MAJOR_ID_GXM		0x22
+#define MESON_CPU_MAJOR_ID_TXL		0x23
 
 #define MESON_CPU_VERSION_LVL_MAJOR	0
 #define MESON_CPU_VERSION_LVL_MINOR	1
@@ -75,71 +76,76 @@ static inline int arch_big_cpu(int cpu)
 	return 0;
 }
 #endif
+
+static inline int get_cpu_type(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR);
+}
+
+static inline u32 get_cpu_package(void)
+{
+	unsigned int pk;
+	pk = get_meson_cpu_version(MESON_CPU_VERSION_LVL_PACK) & 0xF0;
+	return pk;
+}
+
 static inline bool package_id_is(unsigned int id)
 {
-	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_PACK) & 0xF0) ==
-		id;
+	return get_cpu_package() == id;
 }
+
 static inline bool is_meson_m8_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_M8;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8;
 }
 
 static inline bool is_meson_mtvd_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_MTVD;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_MTVD;
 }
 
 static inline bool is_meson_m8b_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_M8B;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8B;
 }
 
 static inline bool is_meson_m8m2_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_M8M2;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8M2;
 }
 
 static inline bool is_meson_g9tv_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_MG9TV;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_MG9TV;
 }
 
 static inline bool is_meson_gxbb_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_GXBB;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB;
 }
 
 static inline bool is_meson_gxtvbb_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_GXTVBB;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB;
 }
+
 static inline bool is_meson_gxbb_package_905(void)
 {
-	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_GXBB) &&
-		((get_meson_cpu_version(MESON_CPU_VERSION_LVL_PACK) & 0xF0) !=
-		0x20);
+	return (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) &&
+		(get_cpu_package() != 0x20);
 }
+
 static inline bool is_meson_gxbb_package_905m(void)
 {
-	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_GXBB) &&
-		((get_meson_cpu_version(MESON_CPU_VERSION_LVL_PACK) & 0xF0) ==
-		0x20);
+	return (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) &&
+		(get_cpu_package() == 0x20);
 }
+
 static inline bool is_meson_gxl_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_GXL;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXL;
 }
+
 static inline bool is_meson_gxl_package_905D(void)
 {
 	return is_meson_gxl_cpu() && package_id_is(0x0);
@@ -148,22 +154,30 @@ static inline bool is_meson_gxl_package_905X(void)
 {
 	return is_meson_gxl_cpu() && package_id_is(0x80);
 }
+
 static inline bool is_meson_gxl_package_905L(void)
 {
 	return is_meson_gxl_cpu() && package_id_is(0xc0);
 }
+
 static inline bool is_meson_gxl_package_905M2(void)
 {
 	return is_meson_gxl_cpu() && package_id_is(0xe0);
 }
+
 static inline bool is_meson_gxm_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR) ==
-		MESON_CPU_MAJOR_ID_GXM;
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXM;
 }
-static inline u32 get_cpu_type(void)
+
+static inline bool is_meson_txl_cpu(void)
 {
-	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR);
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXL;
+}
+
+static inline bool cpu_after_eq(unsigned int id)
+{
+	return get_cpu_type() >= id;
 }
 
 #endif
diff --git a/include/linux/amlogic/ge2d/ge2d.h b/include/linux/amlogic/ge2d/ge2d.h
index cd13a61..76be3af 100644
--- a/include/linux/amlogic/ge2d/ge2d.h
+++ b/include/linux/amlogic/ge2d/ge2d.h
@@ -24,6 +24,11 @@
 #include <linux/sched.h>
 #include <linux/semaphore.h>
 
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+
+
 #define MAX_BITBLT_WORK_CONFIG 4
 #define MAX_GE2D_CMD  32   /* 64 */
 
@@ -613,6 +618,14 @@ struct config_planes_s {
 	unsigned int h;
 };
 
+#ifdef CONFIG_COMPAT
+struct compat_config_planes_s {
+	compat_uptr_t addr;
+	unsigned int w;
+	unsigned int h;
+};
+#endif
+
 struct src_key_ctrl_s {
 	int key_enable;
 	int key_color;
@@ -631,6 +644,19 @@ struct config_para_s {
 	struct src_key_ctrl_s  src_key;
 };
 
+#ifdef CONFIG_COMPAT
+struct compat_config_para_s {
+	int  src_dst_type;
+	int  alu_const_color;
+	unsigned int src_format;
+	unsigned int dst_format; /* add for src&dst all in user space. */
+
+	struct compat_config_planes_s src_planes[4];
+	struct compat_config_planes_s dst_planes[4];
+	struct src_key_ctrl_s  src_key;
+};
+#endif
+
 struct src_dst_para_ex_s {
 	int  canvas_index;
 	int  top;
@@ -685,6 +711,62 @@ struct config_para_ex_s {
 	struct config_planes_s dst_planes[4];
 };
 
+#ifdef CONFIG_COMPAT
+struct compat_config_para_ex_s {
+	struct src_dst_para_ex_s src_para;
+	struct src_dst_para_ex_s src2_para;
+	struct src_dst_para_ex_s dst_para;
+
+	/* key mask */
+	struct src_key_ctrl_s  src_key;
+	struct src_key_ctrl_s  src2_key;
+
+	int alu_const_color;
+	unsigned src1_gb_alpha;
+	unsigned op_mode;
+	unsigned char bitmask_en;
+	unsigned char bytemask_only;
+	unsigned int  bitmask;
+	unsigned char dst_xy_swap;
+
+	/* scaler and phase releated */
+	unsigned hf_init_phase;
+	int hf_rpt_num;
+	unsigned hsc_start_phase_step;
+	int hsc_phase_slope;
+	unsigned vf_init_phase;
+	int vf_rpt_num;
+	unsigned vsc_start_phase_step;
+	int vsc_phase_slope;
+	unsigned char src1_vsc_phase0_always_en;
+	unsigned char src1_hsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	unsigned char src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	unsigned char src1_vsc_rpt_ctrl;
+
+	/* canvas info */
+	struct compat_config_planes_s src_planes[4];
+	struct compat_config_planes_s src2_planes[4];
+	struct compat_config_planes_s dst_planes[4];
+};
+#endif
+
+#define GE2D_IOC_MAGIC  'G'
+
+#define GE2D_CONFIG		_IOW(GE2D_IOC_MAGIC, 0x00, struct config_para_s)
+
+#ifdef CONFIG_COMPAT
+#define GE2D_CONFIG32	_IOW(GE2D_IOC_MAGIC, 0x00, struct compat_config_para_s)
+#endif
+
+#define GE2D_CONFIG_EX	 _IOW(GE2D_IOC_MAGIC, 0x01,  struct config_para_ex_s)
+
+#ifdef CONFIG_COMPAT
+#define GE2D_CONFIG_EX32  \
+	_IOW(GE2D_IOC_MAGIC, 0x01,  struct compat_config_para_ex_s)
+#endif
+
 extern void ge2d_set_src1_data(struct ge2d_src1_data_s *cfg);
 extern void ge2d_set_src1_gen(struct ge2d_src1_gen_s *cfg);
 extern void ge2d_set_src2_dst_data(struct ge2d_src2_dst_data_s *cfg);
diff --git a/include/linux/amlogic/ge2d/ge2d_cmd.h b/include/linux/amlogic/ge2d/ge2d_cmd.h
index 281ed5d..671d2cc 100644
--- a/include/linux/amlogic/ge2d/ge2d_cmd.h
+++ b/include/linux/amlogic/ge2d/ge2d_cmd.h
@@ -36,8 +36,8 @@
 #define	GE2D_FILLRECTANGLE                  0x46fd
 #define	GE2D_SRCCOLORKEY                    0x46fc
 #define	GE2D_SET_COEF                       0x46fb
-#define	GE2D_CONFIG_EX                      0x46fa
-#define	GE2D_CONFIG                         0x46f9
+/* #define	GE2D_CONFIG_EX                      0x46fa */
+/* #define	GE2D_CONFIG                         0x46f9 */
 #define	GE2D_ANTIFLICKER_ENABLE             0x46f8
 
 #endif
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_common.h b/include/linux/amlogic/hdmi_tx/hdmi_common.h
index 86851b3..dcb4e0c 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_common.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_common.h
@@ -209,6 +209,8 @@ enum hdmi_vic {
 #define HDMI_4k2k_smpte_50_y420 HDMI_4096x2160p50_256x135_Y420
 #define HDMI_4k2k_smpte_60_y420 HDMI_4096x2160p60_256x135_Y420
 
+enum hdmi_audio_fs;
+
 /* CEA TIMING STRUCT DEFINITION */
 struct hdmi_cea_timing {
 	unsigned int pixel_freq; /* Unit: 1000 */
@@ -331,6 +333,8 @@ unsigned int hdmi_get_csc_coef(
 	unsigned int color_depth, unsigned int color_format,
 	unsigned char **coef_array, unsigned int *coef_length);
 struct hdmi_format_para *hdmi_get_fmt_name(char const *name);
+unsigned int hdmi_get_aud_n_paras(enum hdmi_audio_fs fs,
+	enum hdmi_color_depth cd, unsigned int tmds_clk);
 
 /* HDMI Audio Parmeters */
 /* Refer to CEA-861-D Page 88 */
@@ -499,12 +503,16 @@ struct hdmi_rx_audioinfo {
 	unsigned CTS;
 };
 
-#define AUDIO_PARA_MAX_NUM       7
+#define AUDIO_PARA_MAX_NUM       13
 struct hdmi_audio_fs_ncts {
 	struct {
 		unsigned int tmds_clk;
-		unsigned int n;
-		unsigned int cts;
+		unsigned int n; /* 24 or 30 bit */
+		unsigned int cts; /* 24 or 30 bit */
+		unsigned int n_36bit;
+		unsigned int cts_36bit;
+		unsigned int n_48bit;
+		unsigned int cts_48bit;
 	} array[AUDIO_PARA_MAX_NUM];
 	unsigned int def_n;
 };
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
index 881546a..7b2bb2c 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
@@ -158,9 +158,6 @@ struct hdmitx_dev {
 #ifdef CONFIG_AML_HDMI_TX_14
 	struct delayed_work cec_work;
 #endif
-	/* for rx sense: detect the voltage of tmds pins */
-	struct timer_list rxsense_timer;
-	unsigned int rxsense_state;
 	struct timer_list hdcp_timer;
 	int hdcp_try_times;
 	/* -1, no hdcp; 0, NULL; 1, 1.4; 2, 2.2 */
@@ -354,7 +351,6 @@ struct hdmitx_dev {
 #define MISC_HPLL_FAKE			(CMD_MISC_OFFSET + 0x0c)
 #define MISC_ESM_RESET		(CMD_MISC_OFFSET + 0x0d)
 #define MISC_HDCP_CLKDIS	(CMD_MISC_OFFSET + 0x0e)
-#define MISC_TMDS_RXSENSE		(CMD_MISC_OFFSET + 0xf)
 
 /***********************************************************************
  *                          Get State //GetState
@@ -426,6 +422,11 @@ void __attribute__((weak))rx_edid_physical_addr(unsigned char a,
 {
 }
 
+extern void rx_set_repeater_support(bool enable);
+void __attribute__((weak))rx_set_repeater_support(bool enable)
+{
+}
+
 extern void rx_set_receiver_edid(unsigned char *data, int len);
 void __attribute__((weak))rx_set_receiver_edid(unsigned char *data, int len)
 {
diff --git a/include/linux/amlogic/key_manage.h b/include/linux/amlogic/key_manage.h
index b7df09a..78476db 100644
--- a/include/linux/amlogic/key_manage.h
+++ b/include/linux/amlogic/key_manage.h
@@ -18,7 +18,8 @@
 #ifndef __KEYMANAGE1__
 #define __KEYMANAGE1__
 
-typedef int32_t (*store_key_ops)(uint8_t *buf, uint32_t len);
+typedef int32_t (*store_key_ops)(uint8_t *buf,
+					uint32_t len, uint32_t *actual_lenth);
 
 #ifdef CONFIG_KEY_MANAGE
 void storage_ops_read(store_key_ops read);
diff --git a/include/linux/amlogic/sd.h b/include/linux/amlogic/sd.h
index 722864a..a2f9a71 100644
--- a/include/linux/amlogic/sd.h
+++ b/include/linux/amlogic/sd.h
@@ -99,7 +99,8 @@ struct amlsd_platform {
 	unsigned int caps;
 	unsigned int caps2;
 	unsigned int card_capacity;
-	unsigned char tx_phase;
+	unsigned int tx_phase;
+	unsigned int tx_delay;
 	unsigned int f_min;
 	unsigned int f_max;
 	unsigned int f_max_w;
diff --git a/include/linux/amlogic/sound/aiu_regs.h b/include/linux/amlogic/sound/aiu_regs.h
index 44d32b0..8cdf4ca 100644
--- a/include/linux/amlogic/sound/aiu_regs.h
+++ b/include/linux/amlogic/sound/aiu_regs.h
@@ -26,6 +26,7 @@
 #define HHI_MPLL_MP1		0xa7
 #define HHI_MPLL_MP2		0xa8
 
+/* AIU regs */
 #define AIU_958_BPF			0x1500
 #define AIU_958_BRST		0x1501
 #define AIU_958_LENGTH		0x1502
@@ -197,4 +198,144 @@
 #define RESET1_REGISTER				0x1102
 #define ACODEC_RESET				0x1D
 
+/* internal EQ regs */
+#define   AED_EQ_CH1_COEF00                 0x1400
+#define   AED_EQ_CH1_COEF01                 0x1401
+#define   AED_EQ_CH1_COEF02                 0x1402
+#define   AED_EQ_CH1_COEF03                 0x1403
+#define   AED_EQ_CH1_COEF04                 0x1404
+#define   AED_EQ_CH1_COEF10                 0x1405
+#define   AED_EQ_CH1_COEF11                 0x1406
+#define   AED_EQ_CH1_COEF12                 0x1407
+#define   AED_EQ_CH1_COEF13                 0x1408
+#define   AED_EQ_CH1_COEF14                 0x1409
+#define   AED_EQ_CH1_COEF20                 0x140a
+#define   AED_EQ_CH1_COEF21                 0x140b
+#define   AED_EQ_CH1_COEF22                 0x140c
+#define   AED_EQ_CH1_COEF23                 0x140d
+#define   AED_EQ_CH1_COEF24                 0x140e
+#define   AED_EQ_CH1_COEF30                 0x140f
+#define   AED_EQ_CH1_COEF31                 0x1410
+#define   AED_EQ_CH1_COEF32                 0x1411
+#define   AED_EQ_CH1_COEF33                 0x1412
+#define   AED_EQ_CH1_COEF34                 0x1413
+#define   AED_EQ_CH1_COEF40                 0x1414
+#define   AED_EQ_CH1_COEF41                 0x1415
+#define   AED_EQ_CH1_COEF42                 0x1416
+#define   AED_EQ_CH1_COEF43                 0x1417
+#define   AED_EQ_CH1_COEF44                 0x1418
+#define   AED_EQ_CH1_COEF50                 0x1419
+#define   AED_EQ_CH1_COEF51                 0x141a
+#define   AED_EQ_CH1_COEF52                 0x141b
+#define   AED_EQ_CH1_COEF53                 0x141c
+#define   AED_EQ_CH1_COEF54                 0x141d
+#define   AED_EQ_CH1_COEF60                 0x141e
+#define   AED_EQ_CH1_COEF61                 0x141f
+#define   AED_EQ_CH1_COEF62                 0x1420
+#define   AED_EQ_CH1_COEF63                 0x1421
+#define   AED_EQ_CH1_COEF64                 0x1422
+#define   AED_EQ_CH1_COEF70                 0x1423
+#define   AED_EQ_CH1_COEF71                 0x1424
+#define   AED_EQ_CH1_COEF72                 0x1425
+#define   AED_EQ_CH1_COEF73                 0x1426
+#define   AED_EQ_CH1_COEF74                 0x1427
+#define   AED_EQ_CH1_COEF80                 0x1428
+#define   AED_EQ_CH1_COEF81                 0x1429
+#define   AED_EQ_CH1_COEF82                 0x142a
+#define   AED_EQ_CH1_COEF83                 0x142b
+#define   AED_EQ_CH1_COEF84                 0x142c
+#define   AED_EQ_CH1_COEF90                 0x142d
+#define   AED_EQ_CH1_COEF91                 0x142e
+#define   AED_EQ_CH1_COEF92                 0x142f
+#define   AED_EQ_CH1_COEF93                 0x1430
+#define   AED_EQ_CH1_COEF94                 0x1431
+
+#define   AED_EQ_CH2_COEF00                 0x1432
+#define   AED_EQ_CH2_COEF01                 0x1433
+#define   AED_EQ_CH2_COEF02                 0x1434
+#define   AED_EQ_CH2_COEF03                 0x1435
+#define   AED_EQ_CH2_COEF04                 0x1436
+#define   AED_EQ_CH2_COEF10                 0x1437
+#define   AED_EQ_CH2_COEF11                 0x1438
+#define   AED_EQ_CH2_COEF12                 0x1439
+#define   AED_EQ_CH2_COEF13                 0x143a
+#define   AED_EQ_CH2_COEF14                 0x143b
+#define   AED_EQ_CH2_COEF20                 0x143c
+#define   AED_EQ_CH2_COEF21                 0x143d
+#define   AED_EQ_CH2_COEF22                 0x143e
+#define   AED_EQ_CH2_COEF23                 0x143f
+#define   AED_EQ_CH2_COEF24                 0x1440
+#define   AED_EQ_CH2_COEF30                 0x1441
+#define   AED_EQ_CH2_COEF31                 0x1442
+#define   AED_EQ_CH2_COEF32                 0x1443
+#define   AED_EQ_CH2_COEF33                 0x1444
+#define   AED_EQ_CH2_COEF34                 0x1445
+#define   AED_EQ_CH2_COEF40                 0x1446
+#define   AED_EQ_CH2_COEF41                 0x1447
+#define   AED_EQ_CH2_COEF42                 0x1448
+#define   AED_EQ_CH2_COEF43                 0x1449
+#define   AED_EQ_CH2_COEF44                 0x144a
+#define   AED_EQ_CH2_COEF50                 0x144b
+#define   AED_EQ_CH2_COEF51                 0x144c
+#define   AED_EQ_CH2_COEF52                 0x144d
+#define   AED_EQ_CH2_COEF53                 0x144e
+#define   AED_EQ_CH2_COEF54                 0x144f
+#define   AED_EQ_CH2_COEF60                 0x1450
+#define   AED_EQ_CH2_COEF61                 0x1451
+#define   AED_EQ_CH2_COEF62                 0x1452
+#define   AED_EQ_CH2_COEF63                 0x1453
+#define   AED_EQ_CH2_COEF64                 0x1454
+#define   AED_EQ_CH2_COEF70                 0x1455
+#define   AED_EQ_CH2_COEF71                 0x1456
+#define   AED_EQ_CH2_COEF72                 0x1457
+#define   AED_EQ_CH2_COEF73                 0x1458
+#define   AED_EQ_CH2_COEF74                 0x1459
+#define   AED_EQ_CH2_COEF80                 0x145a
+#define   AED_EQ_CH2_COEF81                 0x145b
+#define   AED_EQ_CH2_COEF82                 0x145c
+#define   AED_EQ_CH2_COEF83                 0x145d
+#define   AED_EQ_CH2_COEF84                 0x145e
+#define   AED_EQ_CH2_COEF90                 0x145f
+#define   AED_EQ_CH2_COEF91                 0x1460
+#define   AED_EQ_CH2_COEF92                 0x1461
+#define   AED_EQ_CH2_COEF93                 0x1462
+#define   AED_EQ_CH2_COEF94                 0x1463
+
+#define   AED_EQ_EN                         0x1464
+#define   AED_EQ_VOLUME                     0x1465
+#define   AED_EQ_VOLUME_SLEW_CNT            0x1466
+#define   AED_MUTE                          0x1467
+
+/* internal DRC reg*/
+#define   AED_DRC_EN                        0x1470
+#define   AED_DRC_AE                        0x1471
+#define   AED_DRC_AA                        0x1472
+#define   AED_DRC_AD                        0x1473
+#define   AED_DRC_AE_1M                     0x1474
+#define   AED_DRC_AA_1M                     0x1475
+#define   AED_DRC_AD_1M                     0x1476
+#define   AED_DRC_OFFSET0                   0x1477
+#define   AED_DRC_OFFSET1                   0x1478
+#define   AED_DRC_THD0                      0x1479
+#define   AED_DRC_THD1                      0x147a
+#define   AED_DRC_K0                        0x147b
+#define   AED_DRC_K1                        0x147c
+#define   AED_CLIP_THD                      0x147d
+
+/* internal noise gate regs*/
+#define   AED_NG_THD0                       0x147e
+#define   AED_NG_THD1                       0x147f
+#define   AED_NG_CNT_THD                    0x1480
+#define   AED_NG_CTL                        0x1481
+
+#define   AED_ED_CTL                        0x1482
+#define   AED_DEBUG0                        0x1483
+#define   AED_DEBUG1                        0x1484
+#define   AED_DEBUG2                        0x1485
+#define   AED_DEBUG3                        0x1486
+#define   AED_DEBUG4                        0x1487
+#define   AED_DEBUG5                        0x1488
+#define   AED_DEBUG6                        0x1489
+#define   AED_TOP_CTL                       0x1490
+
 #endif /* _AML_AIU_REGS_H */
diff --git a/include/linux/amlogic/sound/audin_regs.h b/include/linux/amlogic/sound/audin_regs.h
index 363c079..42a9b65 100644
--- a/include/linux/amlogic/sound/audin_regs.h
+++ b/include/linux/amlogic/sound/audin_regs.h
@@ -132,7 +132,8 @@
 #define AUD_RESAMPLE_CTRL0			0x28bf
 #define AUD_RESAMPLE_CTRL1			0x28c0
 #define AUD_RESAMPLE_STATUS			0x28c1
-#define AUDIN_ADDR_END				0x28c2
+#define AUD_RESAMPLE_CTRL2			0x28c2
+#define AUDIN_ADDR_END				0x28c3
 
 /* I2S CLK and LRCLK direction. 0 : input 1 : output. */
 #define I2SIN_DIR			0
diff --git a/include/linux/amlogic/tvin/tvin.h b/include/linux/amlogic/tvin/tvin.h
index dd1011f..05be19b 100644
--- a/include/linux/amlogic/tvin/tvin.h
+++ b/include/linux/amlogic/tvin/tvin.h
@@ -82,6 +82,7 @@ enum tvin_port_e {
 	TVIN_PORT_HDMI6,
 	TVIN_PORT_HDMI7,
 	TVIN_PORT_DVIN0 = 0x00008000,
+	TVIN_PORT_VIDEO = 0x0000a000,
 	TVIN_PORT_VIU = 0x0000C000,
 	TVIN_PORT_MIPI = 0x00010000,
 	TVIN_PORT_ISP = 0x00020000,
@@ -850,4 +851,13 @@ struct tvafe_pin_mux_s {
 #endif
 #define TVIN_IOC_S_AFE_SONWON     _IO(_TM_T, 0x22)
 #define TVIN_IOC_S_AFE_SONWOFF     _IO(_TM_T, 0x23)
+
+/*
+   function defined applied for other driver
+ */
+/* adc pll ctl, atv demod & tvafe use the same adc module
+ * module index: atv demod:0x01; tvafe:0x2
+*/
+extern void adc_set_pll_cntl(bool on, unsigned int module_sel);
+
 #endif
diff --git a/include/linux/amlogic/vout/aml_ldim.h b/include/linux/amlogic/vout/aml_ldim.h
index de29e85..3118dd7 100644
--- a/include/linux/amlogic/vout/aml_ldim.h
+++ b/include/linux/amlogic/vout/aml_ldim.h
@@ -24,10 +24,19 @@
 #include <linux/amlogic/vout/aml_bl.h>
 #include <linux/spi/spi.h>
 
+enum ldim_dev_type_e {
+	LDIM_DEV_TYPE_NORMAL = 0,
+	LDIM_DEV_TYPE_SPI,
+	LDIM_DEV_TYPE_I2C,
+	LDIM_DEV_TYPE_MAX,
+};
+
 #define LDIM_SPI_INIT_ON_SIZE     300
 #define LDIM_SPI_INIT_OFF_SIZE    20
 struct ldim_dev_config_s {
 	char name[20];
+	char pinmux_name[20];
+	unsigned char type;
 	int cs_hold_delay;
 	int cs_clk_delay;
 	int en_gpio;
@@ -50,21 +59,25 @@ struct ldim_dev_config_s {
 struct aml_ldim_driver_s {
 	int valid_flag;
 	int dev_index;
+	int static_pic_flag;
 	struct ldim_dev_config_s *ldev_conf;
-	unsigned short *ldim_matrix_2_spi;
+	unsigned short *ldim_matrix_buf;
 	int (*init)(void);
 	int (*power_on)(void);
 	int (*power_off)(void);
 	int (*set_level)(unsigned int level);
-	int (*pinmux_ctrl)(int status);
+	int (*pinmux_ctrl)(char *pin_str, int status);
+	int (*pwm_vs_update)(void);
 	int (*device_power_on)(void);
 	int (*device_power_off)(void);
 	int (*device_bri_update)(unsigned short *buf, unsigned char len);
+	int (*device_bri_check)(void);
 	void (*config_print)(void);
 	void (*test_ctrl)(int flag);
 	struct pinctrl *pin;
 	struct device *dev;
 	struct spi_device *spi;
+	struct spi_board_info *spi_dev;
 };
 
 extern struct aml_ldim_driver_s *aml_ldim_get_driver(void);
diff --git a/include/linux/amlogic/vout/lcd_unifykey.h b/include/linux/amlogic/vout/lcd_unifykey.h
index 726c332..7999c9f 100644
--- a/include/linux/amlogic/vout/lcd_unifykey.h
+++ b/include/linux/amlogic/vout/lcd_unifykey.h
@@ -81,10 +81,12 @@ struct aml_lcd_unifykey_header_s {
 #define LCD_UKEY_SS_LEVEL          1
 #define LCD_UKEY_CLK_AUTO_GEN      1
 #define LCD_UKEY_PCLK              4
-#define LCD_UKEY_CUST_VAL_4        4
-#define LCD_UKEY_CUST_VAL_5        4
-#define LCD_UKEY_CUST_VAL_6        4
-#define LCD_UKEY_CUST_VAL_7        4
+#define LCD_UKEY_H_PERIOD_MIN      2
+#define LCD_UKEY_H_PERIOD_MAX      2
+#define LCD_UKEY_V_PERIOD_MIN      2
+#define LCD_UKEY_V_PERIOD_MAX      2
+#define LCD_UKEY_PCLK_MIN          4
+#define LCD_UKEY_PCLK_MAX          4
 #define LCD_UKEY_CUST_VAL_8        4
 #define LCD_UKEY_CUST_VAL_9        4
 /* interface (20Byte) */
diff --git a/include/linux/amlogic/vout/lcd_vout.h b/include/linux/amlogic/vout/lcd_vout.h
index f1cc520..c59a23c 100644
--- a/include/linux/amlogic/vout/lcd_vout.h
+++ b/include/linux/amlogic/vout/lcd_vout.h
@@ -22,6 +22,7 @@
 #include <linux/platform_device.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/vout/vout_notify.h>
 
 /* **********************************
  * debug print define
@@ -85,13 +86,14 @@ enum lcd_mode_e {
 
 enum lcd_chip_e {
 	LCD_CHIP_M6 = 0,
-	LCD_CHIP_M8,
-	LCD_CHIP_M8B,
-	LCD_CHIP_M8M2,
-	LCD_CHIP_G9TV,
-	LCD_CHIP_G9BB,
-	LCD_CHIP_GXTVBB,
-	LCD_CHIP_MAX,
+	LCD_CHIP_M8,     /* 1 */
+	LCD_CHIP_M8B,    /* 2 */
+	LCD_CHIP_M8M2,   /* 3 */
+	LCD_CHIP_G9TV,   /* 4 */
+	LCD_CHIP_G9BB,   /* 5 */
+	LCD_CHIP_GXTVBB, /* 6 */
+	LCD_CHIP_TXL,    /* 7 */
+	LCD_CHIP_MAX,    /* 8 */
 };
 
 enum lcd_type_e {
@@ -113,15 +115,26 @@ struct lcd_basic_s {
 	unsigned short v_active;    /* Vertical display area */
 	unsigned short h_period;    /* Horizontal total period time */
 	unsigned short v_period;    /* Vertical total period time */
+	unsigned short h_period_min;
+	unsigned short h_period_max;
+	unsigned short v_period_min;
+	unsigned short v_period_max;
+	unsigned int lcd_clk_min;
+	unsigned int lcd_clk_max;
 
 	unsigned int screen_width;  /* screen physical width(unit: mm) */
 	unsigned int screen_height; /* screen physical height(unit: mm) */
 };
 
+#define LCD_CLK_FRAC_UPDATE     (1 << 0)
+#define LCD_CLK_PLL_CHANGE      (1 << 1)
 struct lcd_timing_s {
 	unsigned char clk_auto; /* clk parameters auto generation */
 	unsigned int lcd_clk;   /* pixel clock(unit: Hz) */
 	unsigned int lcd_clk_dft; /* internal used */
+	unsigned int h_period_dft; /* internal used */
+	unsigned int v_period_dft; /* internal used */
+	unsigned char clk_change; /* internal used */
 	unsigned int pll_ctrl;  /* pll settings */
 	unsigned int div_ctrl;  /* divider settings */
 	unsigned int clk_ctrl;  /* clock settings */
@@ -346,9 +359,15 @@ struct lcd_config_s {
 	struct lcd_control_config_s lcd_control;
 	struct lcd_power_ctrl_s *lcd_power;
 	struct pinctrl *pin;
+	unsigned char pinmux_flag;
 	struct lcd_clk_gate_ctrl_s rstc;
 };
 
+struct lcd_duration_s {
+	unsigned int duration_num;
+	unsigned int duration_den;
+};
+
 struct aml_lcd_drv_s {
 	char *version;
 	enum lcd_chip_e chip_type;
@@ -361,11 +380,14 @@ struct aml_lcd_drv_s {
 	struct device *dev;
 	struct lcd_config_s *lcd_config;
 	struct vinfo_s *lcd_info;
+	unsigned char fr_auto_policy;
+	struct lcd_duration_s std_duration;
 
 	void (*vout_server_init)(void);
 	void (*driver_init_pre)(void);
 	int (*driver_init)(void);
 	void (*driver_disable)(void);
+	void (*module_reset)(void);
 	/*void (*module_enable)(void);
 	void (*module_disable)(void);
 	void (*set_gamma_table)(unsigned int gamma_en);
diff --git a/include/linux/amlogic/vout/vout_notify.h b/include/linux/amlogic/vout/vout_notify.h
index 4e7dc94..2e4922a 100644
--- a/include/linux/amlogic/vout/vout_notify.h
+++ b/include/linux/amlogic/vout/vout_notify.h
@@ -60,6 +60,7 @@ extern struct vinfo_s *get_current_vinfo(void);
 extern enum vmode_e get_current_vmode(void);
 extern int set_current_vmode(enum vmode_e);
 extern enum vmode_e validate_vmode(char *);
+extern int get_vsource_fps(int duration);
 extern int set_vframe_rate_hint(int);
 extern int set_vframe_rate_end_hint(void);
 
@@ -108,5 +109,6 @@ extern int vout2_resume(void);
 extern void update_vout_mode_attr(const struct vinfo_s *vinfo);
 
 extern char *get_vout_mode_internal(void);
+extern char *get_vout_mode_uboot(void);
 
 #endif /* _VOUT_NOTIFY_H_ */
diff --git a/include/linux/amlogic/vpu.h b/include/linux/amlogic/vpu.h
index 09506b8..0618efe 100644
--- a/include/linux/amlogic/vpu.h
+++ b/include/linux/amlogic/vpu.h
@@ -63,7 +63,7 @@ enum vpu_mod_e {
 	VPU_LDIM_STTS,        /* reg1[29:28]  //GXTVBB, GXL */
 	VPU_XVYCC_LUT,        /* reg1[31:30]  //GXTVBB, GXL */
 
-	VPU_VIU1_WM,          /* reg2[1:0]  //GXL */
+	VPU_VIU1_WM,          /* reg2[1:0]  //GXL, TXL */
 
 	VPU_MAX,
 };
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index ced5420..f580c90 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -566,6 +566,7 @@ static inline void cpufreq_set_max_cpu_num(unsigned int cpu_num, int cluster_id)
 {
 }
 #endif
+int get_hmp_boost(void);
 int dev_pm_opp_init_cpufreq_table(struct device *dev,
 		struct cpufreq_frequency_table **table);
 void dev_pm_opp_free_cpufreq_table(struct device *dev,
diff --git a/include/linux/gpio/consumer.h b/include/linux/gpio/consumer.h
index 93d18a2..515fd0a 100644
--- a/include/linux/gpio/consumer.h
+++ b/include/linux/gpio/consumer.h
@@ -64,6 +64,8 @@ int desc_to_gpio(const struct gpio_desc *desc);
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 int gpiod_set_pullup(const struct gpio_desc *desc, int val);
 int gpio_set_pullup(unsigned gpio, int val);
+int gpiod_mask_irq(const struct gpio_desc *desc, unsigned int flag);
+int gpio_mask_irq(unsigned gpio, unsigned int flag);
 
 #else /* CONFIG_GPIOLIB */
 
diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 181b2a5..5c587b0 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -94,6 +94,8 @@ struct gpio_chip {
 	int (*set_gpio_to_irq)(struct gpio_chip *chip, unsigned int gpio,
 							unsigned gpio_flag);
 
+	int (*mask_gpio_irq)(struct gpio_chip *chip, unsigned int gpio,
+							unsigned gpio_flag);
 	int			base;
 	u16			ngpio;
 	struct gpio_desc	*desc;
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 3b4dbcb..92e35a0 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -48,6 +48,17 @@ extern int sysctl_legacy_va_layout;
 #define sysctl_legacy_va_layout 0
 #endif
 
+#ifdef CONFIG_HAVE_ARCH_MMAP_RND_BITS
+extern const int mmap_rnd_bits_min;
+extern const int mmap_rnd_bits_max;
+extern int mmap_rnd_bits __read_mostly;
+#endif
+#ifdef CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS
+extern const int mmap_rnd_compat_bits_min;
+extern const int mmap_rnd_compat_bits_max;
+extern int mmap_rnd_compat_bits __read_mostly;
+#endif
+
 #ifdef CONFIG_CMA
 #define MIGRATE_CMA_HOLD  1
 #define MIGRATE_CMA_ALLOC 2
@@ -63,6 +74,9 @@ extern int migrate_status;
 extern int mutex_status;
 extern int migrate_refcount;
 extern wait_queue_head_t migrate_wq;
+extern int cma_alloc_ref(void);
+extern void get_cma_alloc_ref(void);
+extern void put_cma_alloc_ref(void);
 #endif
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -1970,6 +1984,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
 #define FOLL_HWPOISON	0x100	/* check page is hwpoisoned */
 #define FOLL_NUMA	0x200	/* force NUMA hinting page fault */
 #define FOLL_MIGRATION	0x400	/* wait for page to replace migration entry */
+#define FOLL_COW	0x4000	/* internal GUP flag */
 
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 27b064d..b4af582 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -172,6 +172,8 @@ extern int nr_processes(void);
 extern unsigned long nr_running(void);
 extern unsigned long nr_iowait(void);
 extern unsigned long nr_iowait_cpu(int cpu);
+extern void get_iowait_load(unsigned long *nr_waiters,
+				unsigned long *load);
 extern unsigned long this_cpu_load(void);
 
 
diff --git a/include/linux/thermal.h b/include/linux/thermal.h
index e70e90d..b2c2281 100644
--- a/include/linux/thermal.h
+++ b/include/linux/thermal.h
@@ -333,6 +333,7 @@ struct thermal_genl_event {
  * @get_temp: a pointer to a function that reads the sensor temperature.
  *
  * Optional:
+ * @set_mode: device job to do when mode changed
  * @get_trend: a pointer to a function that reads the sensor temperature trend.
  * @set_emul_temp: a pointer to a function that sets sensor emulated
  *		   temperature.
@@ -340,6 +341,7 @@ struct thermal_genl_event {
 struct thermal_zone_of_device_ops {
 	int (*get_temp)(void *, long *);
 	int (*get_trend)(void *, long *);
+	int (*set_mode)(struct thermal_zone_device*, enum thermal_device_mode);
 	int (*set_emul_temp)(void *, unsigned long);
 };
 
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 1891a7d..1546a76 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2387,6 +2387,13 @@ unsigned long nr_iowait_cpu(int cpu)
 	return atomic_read(&this->nr_iowait);
 }
 
+void get_iowait_load(unsigned long *nr_waiters, unsigned long *load)
+{
+	struct rq *rq = this_rq();
+	*nr_waiters = atomic_read(&rq->nr_iowait);
+	*load = rq->load.weight;
+}
+
 #ifdef CONFIG_SMP
 
 /*
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index b6ecc90..420915c 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -5009,7 +5009,7 @@ static void hmp_attr_add(
 static int hmp_attr_init(void)
 {
 	int ret;
-	memset(&hmp_data, sizeof(hmp_data), 0);
+	memset(&hmp_data, 0, sizeof(hmp_data));
 	hmp_attr_add("hmp_domains",
 		NULL,
 		NULL,
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 6430271..0cd7472 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -1167,7 +1167,7 @@ static struct ctl_table vm_table[] = {
 		.proc_handler	= overcommit_kbytes_handler,
 	},
 	{
-		.procname	= "page-cluster", 
+		.procname	= "page-cluster",
 		.data		= &page_cluster,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
@@ -1547,6 +1547,28 @@ static struct ctl_table vm_table[] = {
 		.extra2		= &irq_time_max,
 	},
 #endif
+#ifdef CONFIG_HAVE_ARCH_MMAP_RND_BITS
+	{
+		.procname	= "mmap_rnd_bits",
+		.data		= &mmap_rnd_bits,
+		.maxlen		= sizeof(mmap_rnd_bits),
+		.mode		= 0600,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= (void *)&mmap_rnd_bits_min,
+		.extra2		= (void *)&mmap_rnd_bits_max,
+	},
+#endif
+#ifdef CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS
+	{
+		.procname	= "mmap_rnd_compat_bits",
+		.data		= &mmap_rnd_compat_bits,
+		.maxlen		= sizeof(mmap_rnd_compat_bits),
+		.mode		= 0600,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= (void *)&mmap_rnd_compat_bits_min,
+		.extra2		= (void *)&mmap_rnd_compat_bits_max,
+	},
+#endif
 	{ }
 };
 
@@ -1669,7 +1691,7 @@ static struct ctl_table fs_table[] = {
 		.mode		= 0555,
 		.child		= inotify_table,
 	},
-#endif	
+#endif
 #ifdef CONFIG_EPOLL
 	{
 		.procname	= "epoll",
@@ -2007,12 +2029,12 @@ static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,
 	unsigned long page = 0;
 	size_t left;
 	char *kbuf;
-	
+
 	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
-	
+
 	i = (int *) tbl_data;
 	vleft = table->maxlen / sizeof(*i);
 	left = *lenp;
@@ -2101,7 +2123,7 @@ static int do_proc_dointvec(struct ctl_table *table, int write,
  * @ppos: file position
  *
  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
- * values from/to the user buffer, treated as an ASCII string. 
+ * values from/to the user buffer, treated as an ASCII string.
  *
  * Returns 0 on success.
  */
@@ -2467,7 +2489,7 @@ static int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,
  * @ppos: file position
  *
  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
- * values from/to the user buffer, treated as an ASCII string. 
+ * values from/to the user buffer, treated as an ASCII string.
  * The values read are assumed to be in seconds, and are converted into
  * jiffies.
  *
@@ -2489,8 +2511,8 @@ int proc_dointvec_jiffies(struct ctl_table *table, int write,
  * @ppos: pointer to the file position
  *
  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
- * values from/to the user buffer, treated as an ASCII string. 
- * The values read are assumed to be in 1/USER_HZ seconds, and 
+ * values from/to the user buffer, treated as an ASCII string.
+ * The values read are assumed to be in 1/USER_HZ seconds, and
  * are converted into jiffies.
  *
  * Returns 0 on success.
@@ -2512,8 +2534,8 @@ int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
  * @ppos: the current position in the file
  *
  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
- * values from/to the user buffer, treated as an ASCII string. 
- * The values read are assumed to be in 1/1000 seconds, and 
+ * values from/to the user buffer, treated as an ASCII string.
+ * The values read are assumed to be in 1/1000 seconds, and
  * are converted into jiffies.
  *
  * Returns 0 on success.
diff --git a/mm/cma.c b/mm/cma.c
index 8b3755d..21ca7d9 100644
--- a/mm/cma.c
+++ b/mm/cma.c
@@ -46,6 +46,25 @@ static struct cma cma_areas[MAX_CMA_AREAS];
 static unsigned cma_area_count;
 static DEFINE_MUTEX(cma_mutex);
 
+static atomic_t cma_allocate;
+int cma_alloc_ref(void)
+{
+	return atomic_read(&cma_allocate);
+}
+EXPORT_SYMBOL(cma_alloc_ref);
+
+void get_cma_alloc_ref(void)
+{
+	atomic_inc(&cma_allocate);
+}
+EXPORT_SYMBOL(get_cma_alloc_ref);
+
+void put_cma_alloc_ref(void)
+{
+	atomic_dec(&cma_allocate);
+}
+EXPORT_SYMBOL(put_cma_alloc_ref);
+
 phys_addr_t cma_get_base(struct cma *cma)
 {
 	return PFN_PHYS(cma->base_pfn);
@@ -137,6 +156,7 @@ static int __init cma_init_reserved_areas(void)
 		if (ret)
 			return ret;
 	}
+	atomic_set(&cma_allocate, 0);
 
 	return 0;
 }
@@ -322,6 +342,7 @@ struct page *cma_alloc(struct cma *cma, int count, unsigned int align)
 	if (!count)
 		return NULL;
 
+	get_cma_alloc_ref();
 	mask = cma_bitmap_aligned_mask(cma, align);
 	bitmap_maxno = cma_bitmap_maxno(cma);
 	bitmap_count = cma_bitmap_pages_to_bits(cma, count);
@@ -359,7 +380,7 @@ struct page *cma_alloc(struct cma *cma, int count, unsigned int align)
 		/* try again with a bit different memory target */
 		start = bitmap_no + mask + 1;
 	}
-
+	put_cma_alloc_ref();
 	pr_debug("%s(): returned %p\n", __func__, page);
 	return page;
 }
diff --git a/mm/memory.c b/mm/memory.c
index a2998e9..0b985f2 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1448,6 +1448,16 @@ int zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,
 }
 EXPORT_SYMBOL_GPL(zap_vma_ptes);
 
+/*
+ * FOLL_FORCE can write to even unwritable pte's, but only
+ * after we've gone through a COW cycle and they are dirty.
+ */
+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
+{
+	return pte_write(pte) ||
+		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
+}
+
 /**
  * follow_page_mask - look up a page descriptor from a user-virtual address
  * @vma: vm_area_struct mapping @address
@@ -1568,7 +1578,7 @@ split_fallthrough:
 	}
 	if ((flags & FOLL_NUMA) && pte_numa(pte))
 		goto no_page;
-	if ((flags & FOLL_WRITE) && !pte_write(pte))
+	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags))
 		goto unlock;
 
 	page = vm_normal_page(vma, address, pte);
@@ -1875,7 +1885,7 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 				 */
 				if ((ret & VM_FAULT_WRITE) &&
 				    !(vma->vm_flags & VM_WRITE))
-					foll_flags &= ~FOLL_WRITE;
+					foll_flags |= FOLL_COW;
 
 				cond_resched();
 			}
diff --git a/mm/migrate.c b/mm/migrate.c
index dec39c9..5b2e285 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -945,7 +945,7 @@ uncharge:
 			add_wait_queue(&migrate_wq, &wait);
 			mutex_unlock(&migrate_wait);
 
-			schedule_timeout_interruptible(20);
+			schedule_timeout_interruptible(msecs_to_jiffies(10));
 
 			mutex_lock(&migrate_wait);
 			remove_wait_queue(&migrate_wq, &wait);
diff --git a/mm/mmap.c b/mm/mmap.c
index 5b680b6..c7aeee0 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -53,6 +53,18 @@
 #define arch_rebalance_pgtables(addr, len)		(addr)
 #endif
 
+#ifdef CONFIG_HAVE_ARCH_MMAP_RND_BITS
+const int mmap_rnd_bits_min = CONFIG_ARCH_MMAP_RND_BITS_MIN;
+const int mmap_rnd_bits_max = CONFIG_ARCH_MMAP_RND_BITS_MAX;
+int mmap_rnd_bits __read_mostly = CONFIG_ARCH_MMAP_RND_BITS;
+#endif
+#ifdef CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS
+const int mmap_rnd_compat_bits_min = CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN;
+const int mmap_rnd_compat_bits_max = CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX;
+int mmap_rnd_compat_bits __read_mostly = CONFIG_ARCH_MMAP_RND_COMPAT_BITS;
+#endif
+
+
 static void unmap_region(struct mm_struct *mm,
 		struct vm_area_struct *vma, struct vm_area_struct *prev,
 		unsigned long start, unsigned long end);
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index faa3553..dacae84 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -163,7 +163,7 @@ bool pm_suspended_storage(void)
 int pageblock_order __read_mostly;
 #endif
 
-static void __free_pages_ok(struct page *page, unsigned int order);
+static int __free_pages_ok(struct page *page, unsigned int order);
 
 /*
  * results with 256, 32 in the lowmem_reserve sysctl:
@@ -221,6 +221,7 @@ int min_free_order_shift = 1;
  */
 int extra_free_kbytes = 0;
 
+
 static unsigned long __meminitdata nr_kernel_pages;
 static unsigned long __meminitdata nr_all_pages;
 static unsigned long __meminitdata dma_reserve;
@@ -572,7 +573,7 @@ static inline int page_is_buddy(struct page *page, struct page *buddy,
  * -- nyc
  */
 
-static inline void __free_one_page(struct page *page,
+static inline int __free_one_page(struct page *page,
 		struct zone *zone, unsigned int order,
 		int migratetype)
 {
@@ -585,7 +586,7 @@ static inline void __free_one_page(struct page *page,
 
 	if (unlikely(PageCompound(page)))
 		if (unlikely(destroy_compound_page(page, order)))
-			return;
+			return -1;
 
 	VM_BUG_ON(migratetype == -1);
 
@@ -648,6 +649,7 @@ out:
 	zone->free_area[order].nr_free++;
 	if (is_migrate_cma(migratetype))
 		zone->free_area[order].nr_free_cma++;
+	return order;
 }
 
 static inline int free_pages_check(struct page *page)
@@ -740,18 +742,20 @@ static void free_pcppages_bulk(struct zone *zone, int count,
 	spin_unlock(&zone->lock);
 }
 
-static void free_one_page(struct zone *zone, struct page *page, int order,
+static int free_one_page(struct zone *zone, struct page *page, int order,
 				int migratetype)
 {
 	int cur_migratetype;
+	int free_order;
 	spin_lock(&zone->lock);
 	zone->pages_scanned = 0;
 
 	cur_migratetype = get_pageblock_migratetype(page);
-	__free_one_page(page, zone, order, cur_migratetype);
+	free_order = __free_one_page(page, zone, order, cur_migratetype);
 	if (unlikely(!is_migrate_isolate(cur_migratetype)))
 		__mod_zone_freepage_state(zone, 1 << order, cur_migratetype);
 	spin_unlock(&zone->lock);
+	return free_order;
 }
 
 static bool free_pages_prepare(struct page *page, unsigned int order)
@@ -781,20 +785,22 @@ static bool free_pages_prepare(struct page *page, unsigned int order)
 	return true;
 }
 
-static void __free_pages_ok(struct page *page, unsigned int order)
+static int __free_pages_ok(struct page *page, unsigned int order)
 {
 	unsigned long flags;
 	int migratetype;
+	int free_order;
 
 	if (!free_pages_prepare(page, order))
-		return;
+		return -1;
 
 	local_irq_save(flags);
 	__count_vm_events(PGFREE, 1 << order);
 	migratetype = get_pageblock_migratetype(page);
 	set_freepage_migratetype(page, migratetype);
-	free_one_page(page_zone(page), page, order, migratetype);
+	free_order = free_one_page(page_zone(page), page, order, migratetype);
 	local_irq_restore(flags);
+	return free_order;
 }
 
 void __init __free_pages_bootmem(struct page *page, unsigned int order)
@@ -951,18 +957,43 @@ static int prep_new_page(struct page *page, int order, gfp_t gfp_flags)
 	return 0;
 }
 
+#ifdef CONFIG_CMA
+static inline bool cma_page(struct page *page)
+{
+	int migrate_type = 0;
+
+	migrate_type = get_pageblock_migratetype(page);
+	if (is_migrate_cma(migrate_type) ||
+	   is_migrate_isolate(migrate_type)) {
+		return true;
+	}
+	return false;
+}
+#endif
+
+static inline bool is_writeback(gfp_t flags)
+{
+	return flags & __GFP_WRITE;
+}
+
 /*
  * Go through the free lists for the given migratetype and remove
  * the smallest available page from the freelists
  */
 static inline
 struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,
-						int migratetype)
+						int migratetype, gfp_t flags)
 {
 	unsigned int current_order;
 	struct free_area *area;
 	struct page *page;
 
+#ifdef CONFIG_CMA
+	/* write back pages should not use CMA */
+	if (migratetype == MIGRATE_CMA &&
+		(is_writeback(flags) || cma_alloc_ref()))
+		return NULL;
+#endif
 	/* Find a page of the appropriate size in the preferred list */
 	for (current_order = order; current_order < MAX_ORDER; ++current_order) {
 		area = &(zone->free_area[current_order]);
@@ -1149,7 +1180,8 @@ static int try_to_steal_freepages(struct zone *zone, struct page *page,
 
 /* Remove an element from the buddy allocator from the fallback list */
 static inline struct page *
-__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
+__rmqueue_fallback(struct zone *zone, int order,
+		   int start_migratetype, gfp_t gfp_flag)
 {
 	struct free_area *area;
 	int current_order;
@@ -1170,8 +1202,13 @@ __rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
 			if (migratetype == MIGRATE_RESERVE)
 				break;
 #ifdef CONFIG_CMA
-			if (flags && migratetype == MIGRATE_CMA)
-				continue;
+			/* write back pages should not use CMA */
+			if (migratetype == MIGRATE_CMA) {
+				if (flags                  ||
+				    is_writeback(gfp_flag) ||
+				    cma_alloc_ref())
+					continue;
+			}
 #endif
 			area = &(zone->free_area[current_order]);
 			if (list_empty(&area->free_list[migratetype]))
@@ -1215,7 +1252,7 @@ __rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
  * Call me with the zone->lock already held.
  */
 static struct page *__rmqueue(struct zone *zone, unsigned int order,
-						int migratetype)
+						int migratetype, gfp_t gfp_flag)
 {
 	struct page *page;
 	int ori_migratetype = migratetype;
@@ -1240,7 +1277,8 @@ static struct page *__rmqueue(struct zone *zone, unsigned int order,
 				break;
 		}
 		if (tmp_migratetype == MIGRATE_CMA) {
-			page = __rmqueue_smallest(zone, order, MIGRATE_CMA);
+			page = __rmqueue_smallest(zone, order,
+						  MIGRATE_CMA, gfp_flag);
 			if (page) {
 				ori_migratetype = MIGRATE_CMA;
 				goto alloc_page_success;
@@ -1249,10 +1287,10 @@ static struct page *__rmqueue(struct zone *zone, unsigned int order,
 	}
 #endif
 retry_reserve:
-	page = __rmqueue_smallest(zone, order, ori_migratetype);
+	page = __rmqueue_smallest(zone, order, ori_migratetype, gfp_flag);
 
 	if (unlikely(!page) && ori_migratetype != MIGRATE_RESERVE) {
-		page = __rmqueue_fallback(zone, order, migratetype);
+		page = __rmqueue_fallback(zone, order, migratetype, gfp_flag);
 
 		/*
 		 * Use MIGRATE_RESERVE rather than fail an allocation. goto
@@ -1278,13 +1316,13 @@ alloc_page_success:
  */
 static int rmqueue_bulk(struct zone *zone, unsigned int order,
 			unsigned long count, struct list_head *list,
-			int migratetype, int cold)
+			int migratetype, int cold, gfp_t flags)
 {
 	int i;
 
 	spin_lock(&zone->lock);
 	for (i = 0; i < count; ++i) {
-		struct page *page = __rmqueue(zone, order, migratetype);
+		struct page *page = __rmqueue(zone, order, migratetype, flags);
 		if (unlikely(page == NULL))
 			break;
 
@@ -1649,7 +1687,7 @@ again:
 #endif
 			pcp->count += rmqueue_bulk(zone, 0,
 					pcp->batch, list,
-					migratetype, cold);
+					migratetype, cold, gfp_flags);
 #ifdef CONFIG_CMA
 			if (gfp_flags & __GFP_BDEV)
 				migratetype &= (~__GFP_BDEV);
@@ -1663,11 +1701,15 @@ again:
 		else
 			page = list_entry(list->next, struct page, lru);
 #ifdef CONFIG_CMA
-		if (gfp_flags & __GFP_BDEV) {
+		/* pcp pages with cma should not used for writeback */
+		if (gfp_flags & __GFP_BDEV  ||
+		    is_writeback(gfp_flags) ||
+		    cma_alloc_ref()) {
 			if (get_freepage_migratetype(page) == MIGRATE_CMA) {
 				spin_lock(&zone->lock);
 				migratetype |= __GFP_BDEV;
-				page = __rmqueue(zone, order, migratetype);
+				page = __rmqueue(zone, order,
+						 migratetype, gfp_flags);
 				migratetype &= (~__GFP_BDEV);
 				spin_unlock(&zone->lock);
 				if (!page)
@@ -1679,7 +1721,8 @@ again:
 		} else if (migratetype == MIGRATE_MOVABLE) {
 			if (get_freepage_migratetype(page) != MIGRATE_CMA) {
 				spin_lock(&zone->lock);
-				tmp_page = __rmqueue(zone, order, MIGRATE_CMA);
+				tmp_page = __rmqueue(zone, order,
+						     MIGRATE_CMA, gfp_flags);
 				spin_unlock(&zone->lock);
 				if (!tmp_page)
 					goto use_pcp_page;
@@ -1708,7 +1751,7 @@ use_pcp_page:
 			WARN_ON_ONCE(order > 1);
 		}
 		spin_lock_irqsave(&zone->lock, flags);
-		page = __rmqueue(zone, order, migratetype);
+		page = __rmqueue(zone, order, migratetype, gfp_flags);
 		spin_unlock(&zone->lock);
 		if (!page)
 			goto failed;
@@ -2944,6 +2987,12 @@ out:
 		goto retry_cpuset;
 
 	memcg_kmem_commit_charge(page, memcg, order);
+#ifdef CONFIG_CMA
+	if (page != NULL && is_writeback(gfp_mask) && cma_page(page)) {
+		WARN(1, "write back in cma, order:%d, mask:%x, migrate:%d\n",
+		     order, gfp_mask, get_pageblock_migratetype(page));
+	}
+#endif
 	return page;
 }
 EXPORT_SYMBOL(__alloc_pages_nodemask);
@@ -2986,6 +3035,24 @@ void __free_pages(struct page *page, unsigned int order)
 
 EXPORT_SYMBOL(__free_pages);
 
+int __free_pages_cma(struct page *page, unsigned int order, unsigned int *cnt)
+{
+	int i;
+	int ref = 0;
+
+	/* clear ref count first */
+	for (i = 0; i < (1 << order); i++) {
+		if (!put_page_testzero(page + i))
+			ref++;
+	}
+	if (ref) {
+		pr_info("%s, %d pages are still in use\n", __func__, ref);
+		*cnt += ref;
+		return -1;
+	}
+	return __free_pages_ok(page, order);
+}
+
 void free_pages(unsigned long addr, unsigned int order)
 {
 	if (addr != 0) {
@@ -6523,7 +6590,7 @@ try_again:
 
 	/* Make sure the range is really isolated. */
 	if (test_pages_isolated(outer_start, end, false)) {
-		pr_warn("alloc_contig_range test_pages_isolated(%lx, %lx) failed\n",
+		pr_debug("alloc_contig_range test_pages_isolated(%lx, %lx) failed\n",
 		       outer_start, end);
 		try_times++;
 		if (try_times < 10)
@@ -6555,12 +6622,37 @@ done:
 void free_contig_range(unsigned long pfn, unsigned nr_pages)
 {
 	unsigned int count = 0;
+	struct page *page;
+	int free_order, start_order = 0;
+	int batch;
 
-	for (; nr_pages--; pfn++) {
-		struct page *page = pfn_to_page(pfn);
-
-		count += page_count(page) != 1;
-		__free_page(page);
+	while (nr_pages) {
+		page = pfn_to_page(pfn);
+		batch = (1 << start_order);
+		free_order = __free_pages_cma(page, start_order, &count);
+		pr_debug("pages:%4d, free:%2d, start:%2d, batch:%4d, pfn:%ld\n",
+			nr_pages, free_order,
+			start_order, batch, pfn);
+		nr_pages -= batch;
+		pfn += batch;
+		/*
+		 * since pages are contigunous, and it's buddy already has large
+		 * order, we can try to free same oder as free_order to get more
+		 * quickly free speed.
+		 */
+		if (free_order < 0) {
+			start_order = 0;
+			continue;
+		}
+		if (nr_pages >= (1 << free_order)) {
+			start_order = free_order;
+		} else {
+			/* remain pages is not enough */
+			start_order = 0;
+			while (nr_pages >= (1 << start_order))
+				start_order++;
+			start_order--;
+		}
 	}
 	WARN(count != 0, "%d pages are still in use!\n", count);
 }
diff --git a/mm/page_isolation.c b/mm/page_isolation.c
index 29ab686..55fcd64 100644
--- a/mm/page_isolation.c
+++ b/mm/page_isolation.c
@@ -219,9 +219,15 @@ __test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,
 			 */
 			pfn++;
 			continue;
-		}
-		else
+		} else {
+			pr_debug("%s, page:%ld not isolate, flag:%lx, ",
+				__func__, pfn, page->flags);
+			pr_debug("page_cnt:%d, isolate:%d, mapcnt:%d\n",
+				page_count(page),
+				get_freepage_migratetype(page),
+				atomic_read(&page->_mapcount));
 			return -EBUSY;
+		}
 	}
 	if (pfn < end_pfn)
 		return 1;
@@ -265,7 +271,7 @@ int test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,
 			add_wait_queue(&iso_wq, &wait);
 			mutex_unlock(&iso_wait);
 
-			schedule_timeout_interruptible(20);
+			schedule_timeout_interruptible(msecs_to_jiffies(10));
 
 			mutex_lock(&iso_wait);
 			remove_wait_queue(&iso_wq, &wait);
diff --git a/net/netfilter/xt_qtaguid.c b/net/netfilter/xt_qtaguid.c
index 0849672..01f3c05 100644
--- a/net/netfilter/xt_qtaguid.c
+++ b/net/netfilter/xt_qtaguid.c
@@ -2543,7 +2543,7 @@ static int pp_stats_line(struct seq_file *m, struct tag_stat *ts_entry,
 	uid_t stat_uid = get_uid_from_tag(tag);
 	struct proc_print_info *ppi = m->private;
 	/* Detailed tags are not available to everybody */
-	if (get_atag_from_tag(tag) && !can_read_other_uid_stats(
+	if (!can_read_other_uid_stats(
 						make_kuid(&init_user_ns,stat_uid))) {
 		CT_DEBUG("qtaguid: stats line: "
 			 "%s 0x%llx %u: insufficient priv "
diff --git a/sound/soc/aml/m8/Kconfig b/sound/soc/aml/m8/Kconfig
index b8e7b5e..045f91e 100644
--- a/sound/soc/aml/m8/Kconfig
+++ b/sound/soc/aml/m8/Kconfig
@@ -9,3 +9,22 @@ menuconfig SND_AML_M8
 	select SND_SOC_TAS5717
 	select SND_SOC_TAS5731
 	select SND_SOC_AMLT9015
+	select SND_SOC_AMLT9015S
+
+if SND_AML_M8
+
+config SND_AML_SPLIT_MODE
+	tristate "AIU split mode, otherwise normal mode"
+	depends on SND_AML_M8_SOC
+	help
+		Say 'Y' to enable AIU split mode. If not, it's normal mode.
+
+config SND_AML_SPLIT_MODE_MMAP
+	tristate "AIU split mode, mmap"
+	depends on SND_AML_SPLIT_MODE
+	depends on SND_AML_M8_SOC
+	help
+		Say 'Y' or 'N' to enable/disable AIU split mmap
+
+endif
+
diff --git a/sound/soc/aml/m8/Makefile b/sound/soc/aml/m8/Makefile
index da85a5c..229241b 100644
--- a/sound/soc/aml/m8/Makefile
+++ b/sound/soc/aml/m8/Makefile
@@ -5,7 +5,7 @@ snd-soc-aml-i2s-dai-objs := aml_i2s_dai.o
 snd-soc-aml-pcm-dai-objs := aml_pcm_dai.o
 snd-soc-aml-spdif-dai-objs  := aml_spdif_dai.o
 snd-soc-aml-hw-objs  := aml_audio_hw.o
-snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm2bt.o
+snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm.o
 
 obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-pcm.o
 obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-i2s.o
diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index d778715..6851e61 100644
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -27,6 +27,7 @@
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/aiu_regs.h>
 #include <linux/amlogic/sound/audin_regs.h>
+#include <linux/amlogic/cpu_version.h>
 #include "aml_audio_hw.h"
 
 /* i2s mode 0: master 1: slave */
@@ -146,16 +147,32 @@ int audio_clock_config_table[][13][2] = {
 
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffff00);
+	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffff00);
+#else
 	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
 	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
+#endif
+
 	if (channel == 8) {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 1 << 6);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
+			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+#else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 256);
+#endif
 	} else {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 0 << 6);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
+			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+#else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+#endif
 	}
 	/* Hold I2S */
 	aml_write_cbus(AIU_I2S_MISC, 0x0004);
@@ -176,12 +193,19 @@ void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 		*  Each bit indicates which channels are READ from memory
 		*/
 			       (0xff << 0));
-	} else
+	} else {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		/* [31:16] IRQ block. */
+		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
+			(0xff << 8) |
+			(0xff << 0));
+#else
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
 			       (0x3 << 8) |
 			       (0x3 << 0));
-
+#endif
+	}
 	/* 16 bit PCM mode */
 	/* aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 6, 1); */
 	/* Set init high then low to initilize the I2S memory logic */
@@ -207,17 +231,32 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 				       addr & 0xffffffc0);
 		if (flag == 0) {
 			/* this is for 16bit 2 channel */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				(addr & 0xffffffc0) +
+				(size & 0xffffffc0) - 8);
+#else
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
 				       (addr & 0xffffffc0) +
 				       (size & 0xffffffc0) - 64);
+#endif
 		} else {
 			/* this is for RAW mode */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+						(addr & 0xffffffc0) +
+						(size & 0xffffffc0) - 8);
+#else
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
 				       (addr & 0xffffffc0) +
 				       (size & 0xffffffc0) - 1);
+#endif
 		}
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0xffff);
+#else
 		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0x303);
-
+#endif
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 1);
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 0);
 
@@ -265,14 +304,25 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
 		       | 0 << 0);	/* fifo0_din_pos */
 
 	if (audio_in_source == 0) {
-		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
-			       | (3 << I2SIN_SIZE)
-			       | (1 << I2SIN_LRCLK_INVT)
-			       | (1 << I2SIN_LRCLK_SKEW)
-			       | (sync_mode << I2SIN_POS_SYNC)
-			       | (!mode << I2SIN_LRCLK_SEL)
-			       | (!mode << I2SIN_CLK_SEL)
-			       | (!mode << I2SIN_DIR));
+		if (is_meson_txl_cpu()) {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (0 << I2SIN_POS_SYNC)
+					| (0 << I2SIN_LRCLK_SEL)
+					| (0 << I2SIN_CLK_SEL)
+					| (0 << I2SIN_DIR));
+		} else {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (sync_mode << I2SIN_POS_SYNC)
+					| (!mode << I2SIN_LRCLK_SEL)
+					| (!mode << I2SIN_CLK_SEL)
+					| (!mode << I2SIN_DIR));
+		}
 	} else if (audio_in_source == 1) {
 		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
 			       | (0 << I2SIN_SIZE)
@@ -474,6 +524,77 @@ void audio_in_spdif_set_wrptr(unsigned int val)
 	aml_write_cbus(AUDIN_FIFO1_RDPTR, val);
 }
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+void audio_set_i2s_mode(u32 mode, unsigned int channel)
+{
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x800);
+
+	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0);
+
+	if (8 == channel) {
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 1);
+
+		if (mode == AIU_I2S_MODE_PCM32) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+		} else if (mode == AIU_I2S_MODE_PCM24) {
+			/* todo: to verify it */
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+
+		} else if (mode == AIU_I2S_MODE_PCM16) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+						1 << 6);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+
+			aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0x5);
+		}
+	} else if (2 == channel) {
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 0);
+
+		if (mode == AIU_I2S_MODE_PCM16) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+						1 << 6);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+		} else if (mode == AIU_I2S_MODE_PCM24) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+		} else if (mode == AIU_I2S_MODE_PCM32) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+		}
+	}
+
+	/* In split mode, there are not mask control,
+	so aiu_mem_i2s_mask[15:0] must set 8'hffff_ffff. */
+	/*aml_write_cbus(AIU_MEM_I2S_MASKS,
+		(16 << 16) |
+		(0xff << 8) |
+		(0xff << 0));*/
+}
+#else
 void audio_set_i2s_mode(u32 mode)
 {
 	const unsigned short mask[4] = {
@@ -504,6 +625,7 @@ void audio_set_i2s_mode(u32 mode)
 		aml_cbus_update_bits(AIU_MEM_I2S_MASKS, 0xffff, mask[mode]);
 	}
 }
+#endif
 
 /*
  *  if normal clock, i2s clock is twice of 958 clock,
@@ -593,7 +715,11 @@ void audio_util_set_dac_i2s_format(unsigned format)
 		aml_write_cbus(AIU_I2S_DAC_CFG, 0x0007);
 
 	/* four 2-channel */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, (1 << 11));
+#else
 	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x0001);
+#endif
 }
 
 /* set sclk and lrclk, mclk = 256fs. */
@@ -791,9 +917,16 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 	} else if (mode == AIU_958_MODE_PCM32) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
 			/* pcm */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
@@ -804,9 +937,16 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 	} else if (mode == AIU_958_MODE_PCM24) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
 			/* pcm */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
@@ -820,7 +960,12 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 		if (ENABLE_IEC958) {
 			aml_write_cbus(AIU_958_MISC, 0x2042);
 			/* pcm */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
 					     1 << 7, 1 << 7);
@@ -833,6 +978,11 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 
 	audio_hw_958_reset(0, 1);
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	if (mode == AIU_958_MODE_PCM32)
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 1 << 8, 1 << 8);
+#endif
+
 	aml_write_cbus(AIU_958_FORCE_LEFT, 1);
 }
 
@@ -863,6 +1013,8 @@ void audio_hw_958_enable(unsigned flag)
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 					     0x3 << 1);
 		} else {
+			aml_write_cbus(AIU_RST_SOFT, 0x04);
+			aml_write_cbus(AIU_958_FORCE_LEFT, 0);
 			aml_write_cbus(AIU_958_DCU_FF_CTRL, 0);
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 					     0);
diff --git a/sound/soc/aml/m8/aml_audio_hw.h b/sound/soc/aml/m8/aml_audio_hw.h
index 39213a3..6b28d30 100644
--- a/sound/soc/aml/m8/aml_audio_hw.h
+++ b/sound/soc/aml/m8/aml_audio_hw.h
@@ -126,7 +126,11 @@ void audio_in_spdif_enable(int flag);
 unsigned int audio_in_i2s_rd_ptr(void);
 unsigned int audio_in_i2s_wr_ptr(void);
 unsigned int audio_in_spdif_wr_ptr(void);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+void audio_set_i2s_mode(u32 mode, unsigned int channel);
+#else
 void audio_set_i2s_mode(u32 mode);
+#endif
 void audio_set_i2s_clk_div(void);
 void audio_set_spdif_clk_div(void);
 void audio_enable_ouput(int flag);
diff --git a/sound/soc/aml/m8/aml_audio_hw_pcm.c b/sound/soc/aml/m8/aml_audio_hw_pcm.c
new file mode 100644
index 0000000..7beaee8
--- /dev/null
+++ b/sound/soc/aml/m8/aml_audio_hw_pcm.c
@@ -0,0 +1,707 @@
+/*
+ * sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#define pr_fmt(fmt) "audio_pcm" fmt
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/sound/audin_regs.h>
+#include "aml_audio_hw_pcm.h"
+
+#include <linux/amlogic/sound/aiu_regs.h>
+
+static unsigned int pcmin_buffer_addr;
+static unsigned int pcmin_buffer_size;
+
+static unsigned int pcmout_buffer_addr;
+static unsigned int pcmout_buffer_size;
+
+int valid_channel[] = {
+	0x1,    /* slot number 1 */
+	0x3,    /* slot number 2 */
+	0x7,    /* slot number 3 */
+	0xf,    /* slot number 4 */
+	0x1f,    /* slot number 5 */
+	0x3f,    /* slot number 6 */
+	0x7f,    /* slot number 7 */
+	0xff,    /* slot number 8 */
+	0x1ff,    /* slot number 9 */
+	0x3ff,    /* slot number 10 */
+	0x7ff,    /* slot number 11 */
+	0xfff,    /* slot number 12 */
+	0x1fff,    /* slot number 13 */
+	0x2fff,    /* slot number 14 */
+	0x3fff,    /* slot number 15 */
+	0x7fff    /* slot number 16 */
+};
+
+static uint32_t aml_read_cbus_bits(uint32_t reg, const uint32_t start,
+				   const uint32_t len)
+{
+	return (aml_read_cbus(reg) >> start) & ((1L << len) - 1);
+}
+
+static void pcm_in_register_show(void)
+{
+	pr_debug("PCMIN registers show:\n");
+	pr_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START,
+		  aml_read_cbus(AUDIN_FIFO1_START));
+	pr_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END,
+		  aml_read_cbus(AUDIN_FIFO1_END));
+	pr_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR,
+		  aml_read_cbus(AUDIN_FIFO1_PTR));
+	pr_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR,
+		  aml_read_cbus(AUDIN_FIFO1_RDPTR));
+	pr_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL,
+		  aml_read_cbus(AUDIN_FIFO1_CTRL));
+	pr_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1,
+		  aml_read_cbus(AUDIN_FIFO1_CTRL1));
+	pr_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0,
+		  aml_read_cbus(PCMIN_CTRL0));
+	pr_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1,
+		  aml_read_cbus(PCMIN_CTRL1));
+}
+
+void pcm_master_in_enable(struct snd_pcm_substream *substream, int flag)
+{
+	unsigned dsp_mode = SND_SOC_DAIFMT_DSP_B;
+	unsigned fs_offset;
+
+	if (SND_SOC_DAIFMT_DSP_A == dsp_mode)
+		fs_offset = 1;
+	else {
+		fs_offset = 0;
+
+		if (SND_SOC_DAIFMT_DSP_B != dsp_mode)
+			pr_err("Unsupport DSP mode\n");
+	}
+
+	/* reset fifo */
+RESET_FIFO:
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 1 << 1);
+	aml_write_cbus(AUDIN_FIFO1_PTR, 0);
+	if (aml_read_cbus(AUDIN_FIFO1_PTR) != aml_read_cbus(AUDIN_FIFO1_START))
+		goto RESET_FIFO;
+
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 0 << 1);
+
+	/* reset pcmin */
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 30, 0 << 30);
+
+	/* disable fifo */
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1, 0);
+
+	/* disable pcmin */
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 31, 0 << 31);
+
+	if (flag) {
+		unsigned pcm_mode = 1;
+		unsigned valid_slot =
+			valid_channel[substream->runtime->channels - 1];
+
+		switch (substream->runtime->format) {
+		case SNDRV_PCM_FORMAT_S32_LE:
+			pcm_mode = 3;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			pcm_mode = 2;
+			break;
+		case SNDRV_PCM_FORMAT_S16_LE:
+			pcm_mode = 1;
+			break;
+		case SNDRV_PCM_FORMAT_S8:
+			pcm_mode = 0;
+			break;
+		}
+
+		/* set buffer start ptr end */
+		aml_write_cbus(AUDIN_FIFO1_START, pcmin_buffer_addr);
+		aml_write_cbus(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
+		aml_write_cbus(AUDIN_FIFO1_END,
+			pcmin_buffer_addr + pcmin_buffer_size - 8);
+
+		/* fifo control */
+		aml_write_cbus(AUDIN_FIFO1_CTRL,
+			(1 << 15) |    /* urgent request */
+			(1 << 11) |    /* channel */
+			(6 << 8) |     /* endian */
+			(2 << 3) |     /* PCMIN input selection */
+			(1 << 2) |     /* load address */
+			(0 << 1) |     /* reset fifo */
+			(1 << 0)       /* fifo enable */
+		);
+
+		/* fifo control1 */
+		aml_write_cbus(AUDIN_FIFO1_CTRL1,
+			/* data destination DDR */
+			(0 << 4) |
+			/* fifo1 din byte num.  00 : 1 byte. 01: 2 bytes.
+			10: 3 bytes. 11: 4 bytes */
+			(pcm_mode << 2) |
+			/* data position */
+			(0 << 0)
+		);
+
+		/* pcmin control1 */
+		aml_write_cbus(PCMIN_CTRL1,
+			/* pcmin SRC sel */
+			(0 << 29) |
+			/* pcmin clock sel */
+			(1 << 28) |
+			/* using negedge of PCM clock to latch the input data */
+			(1 << 27) |
+			/* max slot number in one frame */
+			(0xF << 21) |
+			/* data msb 16bits data */
+			(0xF << 16) |
+			/* slot valid */
+			(valid_slot << 0)
+		);
+
+		/* pcmin control0 */
+		aml_write_cbus(PCMIN_CTRL0,
+			/* pcmin enable */
+			(1 << 31) |
+			/* sync on clock posedge */
+			(1 << 29) |
+			/* FS SKEW */
+			(fs_offset << 16) |
+			/* waithing 1 system clock cycles
+			then sample the PCMIN singals */
+			(0 << 4) |
+			/* use clock counter to do the sample */
+			(0 << 3) |
+			/* fs inverted. */
+			(0 << 2) |
+			/* msb first */
+			(1 << 1) |
+			/* left justified */
+			(1 << 0)
+		);
+
+		if (!pcm_out_is_enable()) {
+			aml_write_cbus(PCMOUT_CTRL2,
+				aml_read_cbus(PCMOUT_CTRL2) |
+				/* pcmo max slot number in one frame*/
+				(0xF << 22) |
+				/* pcmo max bit number in one slot*/
+				(0xF << 16) |
+				(valid_slot << 0)
+			);
+			aml_write_cbus(PCMOUT_CTRL1,
+				aml_read_cbus(PCMOUT_CTRL1) |
+				/* use posedge of PCM clock to output data*/
+				(0 << 28) |
+				/* invert fs phase */
+				(1 << 26) |
+				/* invert the fs_o for master mode */
+				(1 << 25) |
+				/* fs_o start postion frame
+				slot counter number */
+				(0 << 18) |
+				/*fs_o start postion slot bit counter number*/
+				(0 << 12) |
+				/*fs_o end postion frame slot counter number.*/
+				(0 << 6) |
+				/* fs_o end postion slot bit counter number.*/
+				(1 << 0)
+			);
+			aml_write_cbus(PCMOUT_CTRL0,
+				aml_read_cbus(PCMOUT_CTRL0) |
+				(1 << 31) |     /* enable */
+				(1 << 29)     /* master */
+			);
+		}
+	} else {
+		if (!pcm_out_is_enable()) {
+			/* disable pcmout */
+			aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
+		}
+	}
+
+	pr_debug("PCMIN %s\n", flag ? "enable" : "disable");
+	pcm_in_register_show();
+}
+
+
+void pcm_in_enable(int flag)
+{
+	/* reset fifo */
+ RESET_FIFO:
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 1 << 1);
+	aml_write_cbus(AUDIN_FIFO1_PTR, 0);
+	if (aml_read_cbus(AUDIN_FIFO1_PTR) != aml_read_cbus(AUDIN_FIFO1_START))
+		goto RESET_FIFO;
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 0 << 1);
+
+	/* reset pcmin */
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 30, 0 << 30);
+
+	/* disable fifo */
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1, 0);
+
+	/* disable pcmin */
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 31, 0 << 31);
+
+	if (flag) {
+		/* set buffer start ptr end */
+		aml_write_cbus(AUDIN_FIFO1_START, pcmin_buffer_addr);
+		aml_write_cbus(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
+		aml_write_cbus(AUDIN_FIFO1_END,
+			       pcmin_buffer_addr + pcmin_buffer_size - 8);
+
+		/* fifo control */
+		/* urgent request */
+		aml_write_cbus(AUDIN_FIFO1_CTRL, (1 << 15) |
+			       (1 << 11) |	/* channel */
+			       (6 << 8) |	/* endian */
+			       /* (0 << 8) |     // endian */
+			       (2 << 3) |	/* PCMIN input selection */
+			       (1 << 2) |	/* load address */
+			       (0 << 1) |	/* reset fifo */
+			       (1 << 0)	/* fifo enable */
+		    );
+
+		/* fifo control1 */
+		/* data destination DDR */
+		aml_write_cbus(AUDIN_FIFO1_CTRL1, (0 << 4) |
+			       (1 << 2) |	/* 16bits */
+			       (0 << 0)	/* data position */
+		    );
+
+		/* pcmin control1 */
+		aml_write_cbus(PCMIN_CTRL1, (0 << 29) |	/* external chip */
+	       (0 << 28) |	/* external chip */
+		/* using negedge of PCM clock to latch the input data */
+	       (1 << 27) |
+	       (15 << 21) |	/* slot bit msb 16 clocks per slot */
+	       (15 << 16) |	/* data msb 16bits data */
+	       (1 << 0)	/* slot valid */
+		    );
+
+		/* pcmin control0 */
+		aml_write_cbus(PCMIN_CTRL0, (1 << 31) |	/* pcmin enable */
+	       (1 << 29) |	/* sync on clock posedge */
+	       (0 << 16) |	/* FS SKEW */
+			/* waithing 1 system clock cycles
+				then sample the PCMIN singals */
+	       (0 << 4) |
+	       (0 << 3) |	/* use clock counter to do the sample */
+	       (0 << 2) |	/* fs not inverted. H = left, L = right */
+	       (1 << 1) |	/* msb first */
+	       (1 << 0));	/* left justified */
+	}
+
+	pr_debug("PCMIN %s\n", flag ? "enable" : "disable");
+	pcm_in_register_show();
+}
+
+void pcm_in_set_buf(unsigned int addr, unsigned int size)
+{
+	pcmin_buffer_addr = addr;
+	pcmin_buffer_size = size;
+
+	pr_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n",
+		  pcmin_buffer_addr, pcmin_buffer_size);
+}
+
+int pcm_in_is_enable(void)
+{
+	int value = aml_read_cbus_bits(PCMIN_CTRL0, 31, 1);
+
+	return value;
+}
+
+unsigned int pcm_in_rd_ptr(void)
+{
+	unsigned int value = aml_read_cbus(AUDIN_FIFO1_RDPTR);
+	pr_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
+
+	return value;
+}
+
+unsigned int pcm_in_set_rd_ptr(unsigned int value)
+{
+	unsigned int old = aml_read_cbus(AUDIN_FIFO1_RDPTR);
+	aml_write_cbus(AUDIN_FIFO1_RDPTR, value);
+	pr_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
+
+	return old;
+}
+
+unsigned int pcm_in_wr_ptr(void)
+{
+	unsigned int writing = 0;
+	unsigned int written = 0;
+	unsigned int value = 0;
+
+	writing = aml_read_cbus(AUDIN_FIFO1_PTR);
+
+	aml_write_cbus(AUDIN_FIFO1_PTR, 1);
+	written = aml_read_cbus(AUDIN_FIFO1_PTR);
+	pr_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
+
+	/* value = written; */
+	value = written & (~0x07);
+	return value;
+}
+
+unsigned int pcm_in_fifo_int(void)
+{
+	unsigned int value = 0;
+	value = aml_read_cbus(AUDIN_FIFO_INT);
+	pr_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
+
+	return value;
+}
+
+static void pcm_out_register_show(void)
+{
+	pr_debug("PCMOUT registers show:\n");
+	pr_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA,
+		  aml_read_cbus(AUDOUT_BUF0_STA));
+	pr_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA,
+		  aml_read_cbus(AUDOUT_BUF0_EDA));
+	pr_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR,
+		  aml_read_cbus(AUDOUT_BUF0_WPTR));
+	pr_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR,
+		  aml_read_cbus(AUDOUT_FIFO_RPTR));
+	pr_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL,
+		  aml_read_cbus(AUDOUT_CTRL));
+	pr_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1,
+		  aml_read_cbus(AUDOUT_CTRL1));
+	pr_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0,
+		  aml_read_cbus(PCMOUT_CTRL0));
+	pr_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1,
+		  aml_read_cbus(PCMOUT_CTRL1));
+	pr_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2,
+		  aml_read_cbus(PCMOUT_CTRL2));
+	pr_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3,
+		  aml_read_cbus(PCMOUT_CTRL3));
+}
+
+void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag)
+{
+	unsigned pcm_mode = 1;
+	unsigned valid_slot = valid_channel[substream->runtime->channels - 1];
+	unsigned dsp_mode = SND_SOC_DAIFMT_DSP_B;
+	unsigned bit_offset_s, slot_offset_s, bit_offset_e, slot_offset_e;
+
+	if (SND_SOC_DAIFMT_DSP_A == dsp_mode) {
+		bit_offset_s = 0xF;
+		slot_offset_s = 0xF;
+		bit_offset_e = 0;
+		slot_offset_e = 0;
+	} else {
+		if (SND_SOC_DAIFMT_DSP_B != dsp_mode)
+			pr_err("Unsupport DSP mode\n");
+
+		bit_offset_s = 0;
+		slot_offset_s = 0;
+		bit_offset_e = 0;
+		slot_offset_e = 1;
+	}
+
+	switch (substream->runtime->format) {
+	case SNDRV_PCM_FORMAT_S32_LE:
+		pcm_mode = 3;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		pcm_mode = 2;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		pcm_mode = 1;
+		break;
+	case SNDRV_PCM_FORMAT_S8:
+		pcm_mode = 0;
+		break;
+	}
+
+	/* reset fifo */
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
+	/* disable fifo */
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 31, 0 << 31);
+
+	if (!pcm_in_is_enable()) {
+		/* reset pcmout */
+		aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 30, 1 << 30);
+		aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 30, 0 << 30);
+		/* disable pcmout */
+		aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
+	}
+
+	if (flag) {
+		/* set buffer start ptr end */
+		aml_write_cbus(AUDOUT_BUF0_STA, pcmout_buffer_addr);
+		aml_write_cbus(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
+		aml_write_cbus(AUDOUT_BUF0_EDA,
+			pcmout_buffer_addr + pcmout_buffer_size - 8);
+
+		/* fifo control */
+		aml_write_cbus(AUDOUT_CTRL, (0 << 31) |     /* fifo enable */
+			(0 << 30) |     /* soft reset */
+			(1 << 29) |     /* load address */
+			/* use cbus AUDOUT BUFFER0 write pointer
+			as the AUDOUT FIFO write pointer */
+			(0 << 22) |
+			(52 << 15) |    /* data request size */
+			(64 << 8) |     /* buffer level to keep */
+			(0 << 7) |      /* buffer level control */
+			(1 << 6) |      /* DMA mode */
+			(1 << 5) |      /* circular buffer */
+			(0 << 4) |      /* use register set 0 always */
+			(1 << 3) |      /* urgent request */
+			(6 << 0)        /* endian */
+		);
+
+		aml_write_cbus(AUDOUT_CTRL, (1 << 31) |/* fifo enable */
+			(0 << 30) |     /* soft reset */
+			(1 << 29) |     /* load address */
+			/* use cbus AUDOUT BUFFER0 write pointer
+			as the AUDOUT FIFO write pointer */
+			(1 << 22) |
+			(56 << 15) |    /* data request size */
+			(64 << 8) |     /* buffer level to keep */
+			(1 << 7) |      /* buffer level control */
+			(1 << 6) |      /* DMA mode */
+			(1 << 5) |      /* circular buffer */
+			(0 << 4) |      /* use register set 0 always */
+			(1 << 3) |       /* urgent request */
+			(6 << 0)         /* endian */
+		);
+
+		/* pcmout control3 */
+		aml_write_cbus(PCMOUT_CTRL3, 0); /* mute constant */
+
+		/* pcmout control2 */
+		/* FS * 16 * 16 = BCLK */
+		aml_write_cbus(PCMOUT_CTRL2,
+			/* underrun use mute constant */
+			(0 << 29) |
+			/* pcmo max slot number in one frame */
+			(0xF << 22) |
+			/* pcmo max bit number in one slot */
+			(0xF << 16) |
+			/* pcmo valid slot. each bit for one slot */
+			(valid_slot << 0)
+		);
+
+		/* pcmout control1 */
+		aml_write_cbus(PCMOUT_CTRL1,
+			/* pcmo output data byte number.  00 : 8bits.
+			01: 16bits. 10: 24bits. 11: 32bits */
+			(pcm_mode << 30) |
+			/* use posedge of PCM clock to output data */
+			(0 << 28) |
+			/* pcmo slave parts clock invert */
+			(0 << 27) |
+			/* invert fs phase */
+			(1 << 26) |
+			/* invert the fs_o for master mode */
+			(1 << 25) |
+			/* fs_o start postion frame slot counter number */
+			(bit_offset_s << 18) |
+			/* fs_o start postion slot bit counter number.*/
+			(slot_offset_s << 12) |
+			/* fs_o end postion frame slot counter number. */
+			(bit_offset_e << 6) |
+			/* fs_o end postion slot bit counter number. */
+			(slot_offset_e << 0)
+		);
+
+		/* pcmout control0 */
+		aml_write_cbus(PCMOUT_CTRL0,
+			(1 << 31) |     /* enable */
+			(1 << 29) |     /* master */
+			(1 << 28) |     /* sync on clock rising edge */
+			/*system clock sync at clock edge of pcmout clock.
+			0 = sync on clock counter.*/
+			(0 << 27) |
+			/* system clock sync at counter number
+			if sync on clock counter */
+			(0 << 15) |
+			(1 << 14) |     /* msb first */
+			(1 << 13) |     /* left justified */
+			(0 << 12) |     /* data position */
+			/*slave mode, sync fs with the slot bit counter.*/
+			(0 << 6) |
+			/*slave mode, sync fs with frame slot counter.*/
+			(0 << 0)
+		);
+	}
+
+	pr_debug("PCMOUT %s\n", flag ? "enable" : "disable");
+	pcm_out_register_show();
+}
+
+void pcm_out_enable(int flag)
+{
+	/* reset fifo */
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
+
+	/* reset pcmout */
+	aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 30, 0 << 30);
+
+	/* disable fifo */
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 31, 0 << 31);
+
+	/* disable pcmout */
+	aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
+
+	if (flag) {
+		/* set buffer start ptr end */
+		aml_write_cbus(AUDOUT_BUF0_STA, pcmout_buffer_addr);
+		aml_write_cbus(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
+		aml_write_cbus(AUDOUT_BUF0_EDA,
+			       pcmout_buffer_addr + pcmout_buffer_size - 8);
+
+		/* fifo control */
+		aml_write_cbus(AUDOUT_CTRL, (0 << 31) |	/* fifo enable */
+	       (0 << 30) |	/* soft reset */
+	       (1 << 29) |	/* load address */
+			/* use cbus AUDOUT BUFFER0 write pointer
+				as the AUDOUT FIFO write pointer */
+	       (0 << 22) |
+	       (52 << 15) |	/* data request size */
+	       (64 << 8) |	/* buffer level to keep */
+	       (0 << 7) |	/* buffer level control */
+	       (1 << 6) |	/* DMA mode */
+	       (1 << 5) |	/* circular buffer */
+	       (0 << 4) |	/* use register set 0 always */
+	       (1 << 3) |	/* urgent request */
+	       (6 << 0));	/* endian */
+
+		aml_write_cbus(AUDOUT_CTRL, (1 << 31) |	/* fifo enable */
+	       (0 << 30) |	/* soft reset */
+	       (0 << 29) |	/* load address */
+			/* use cbus AUDOUT BUFFER0 write pointer
+				as the AUDOUT FIFO write pointer */
+			(0 << 22) |
+			(52 << 15) |	/* data request size */
+			(64 << 8) |	/* buffer level to keep */
+			(0 << 7) |	/* buffer level control */
+			(1 << 6) |	/* DMA mode */
+			(1 << 5) |	/* circular buffer */
+			(0 << 4) |	/* use register set 0 always */
+			(1 << 3) |	/* urgent request */
+			(6 << 0));	/* endian */
+
+		/* pcmout control3 */
+		aml_write_cbus(PCMOUT_CTRL3, 0);	/* mute constant */
+
+		/* pcmout control2 */
+		/* 1 channel per frame */
+		aml_write_cbus(PCMOUT_CTRL2, (0 << 29) | (0 << 22) |
+			       (15 << 16) |	/* 16 bits per slot */
+			       (1 << 0)	/* enable 1 slot */
+		    );
+
+		/* pcmout control1 */
+		/* use posedge of PCM clock to output data */
+		aml_write_cbus(PCMOUT_CTRL1, (1 << 30) | (0 << 28) |
+			/* use negedge of pcm clock to check the fs */
+			(1 << 27));
+
+		/* pcmout control0 */
+		/* slave */
+		aml_write_cbus(PCMOUT_CTRL0, (1 << 31) | (0 << 29) |
+			/* sync on clock rising edge */
+			(1 << 28) |
+			/* data sample mode */
+			(0 << 27) |
+			/* sync on 4 system clock later ? */
+			(1 << 15) |
+			/* msb first */
+			(1 << 14) |
+			/* left justified */
+			(1 << 13) |
+			/* data position */
+			(0 << 12) |
+			/* sync fs with the slot bit counter. */
+			(3 << 6) |
+			/* sync fs with frame slot counter. */
+			(0 << 0));
+	}
+
+	pr_debug("PCMOUT %s\n", flag ? "enable" : "disable");
+	pcm_out_register_show();
+}
+
+void pcm_out_mute(int flag)
+{
+	int value = flag ? 1 : 0;
+	aml_cbus_update_bits(PCMOUT_CTRL2, 1 << 31, value << 31);
+}
+
+void pcm_out_set_buf(unsigned int addr, unsigned int size)
+{
+	pcmout_buffer_addr = addr;
+	pcmout_buffer_size = size;
+
+	pr_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n",
+		  pcmout_buffer_addr, pcmout_buffer_size);
+}
+
+int pcm_out_is_enable(void)
+{
+	int value = aml_read_cbus_bits(PCMOUT_CTRL0, 31, 1);
+
+	return value;
+}
+
+int pcm_out_is_mute(void)
+{
+	int value = aml_read_cbus_bits(PCMOUT_CTRL2, 31, 1);
+
+	return value;
+}
+
+unsigned int pcm_out_rd_ptr(void)
+{
+	unsigned int value = aml_read_cbus(AUDOUT_FIFO_RPTR);
+	pr_debug("PCMOUT read pointer: 0x%08x\n", value);
+
+	return value;
+}
+
+unsigned int pcm_out_wr_ptr(void)
+{
+	unsigned int value = 0;
+	value = aml_read_cbus(AUDOUT_BUF0_WPTR);
+	pr_debug("PCMOUT write pointer: 0x%08x\n", value);
+	return value;
+}
+
+unsigned int pcm_out_set_wr_ptr(unsigned int value)
+{
+	unsigned int old = aml_read_cbus(AUDOUT_BUF0_WPTR);
+	aml_write_cbus(AUDOUT_BUF0_WPTR, value);
+	pr_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
+
+	return old;
+}
diff --git a/sound/soc/aml/m8/aml_audio_hw_pcm.h b/sound/soc/aml/m8/aml_audio_hw_pcm.h
new file mode 100644
index 0000000..dbaa0e4
--- /dev/null
+++ b/sound/soc/aml/m8/aml_audio_hw_pcm.h
@@ -0,0 +1,43 @@
+/*
+ * sound/soc/aml/m8/aml_audio_hw_pcm.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __AML_PCM_HW_H__
+#define __AML_PCM_HW_H__
+
+#include "sound/asound.h"
+#include <sound/pcm.h>
+
+void pcm_in_enable(int flag);
+void pcm_in_set_buf(unsigned int addr, unsigned int size);
+int  pcm_in_is_enable(void);
+unsigned int pcm_in_rd_ptr(void);
+unsigned int pcm_in_wr_ptr(void);
+unsigned int pcm_in_set_rd_ptr(unsigned int value);
+unsigned int pcm_in_fifo_int(void);
+
+void pcm_out_enable(int flag);
+void pcm_out_mute(int flag);
+void pcm_out_set_buf(unsigned int addr, unsigned int size);
+int  pcm_out_is_enable(void);
+int  pcm_out_is_mute(void);
+unsigned int pcm_out_rd_ptr(void);
+unsigned int pcm_out_wr_ptr(void);
+unsigned int pcm_out_set_wr_ptr(unsigned int value);
+
+void pcm_master_in_enable(struct snd_pcm_substream *substream, int flag);
+void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag);
+#endif
diff --git a/sound/soc/aml/m8/aml_g9tv.c b/sound/soc/aml/m8/aml_g9tv.c
index c2d703b..9e66b23 100644
--- a/sound/soc/aml/m8/aml_g9tv.c
+++ b/sound/soc/aml/m8/aml_g9tv.c
@@ -28,6 +28,8 @@
 #include <linux/i2c.h>
 #include <linux/delay.h>
 
+#include <sound/soc.h>
+#include <sound/tlv.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -41,6 +43,8 @@
 #include <linux/amlogic/aml_gpio_consumer.h>
 #include <linux/of_gpio.h>
 #include <linux/io.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/sound/aiu_regs.h>
 
 #include "aml_i2s.h"
 #include "aml_audio_hw.h"
@@ -51,6 +55,42 @@
 int aml_audio_Hardware_resample = 0;
 unsigned int clk_rate = 0;
 
+static u32 aml_EQ_param[20][5] = {
+	/*channel 1 param*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef0*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef1*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef2*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef3*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef4*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef5*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef6*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef7*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef8*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef9*/
+	/*channel 2 param*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef0*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef1*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef2*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef3*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef4*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef5*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef6*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef7*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef8*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef9*/
+};
+
+static u32 drc_table[3][2] = {
+	{0x800000, 0x00}, /*drc_ae && drc_ae_1m*/
+	{0x800000, 0x00}, /*drc_aa && drc_aa_1m*/
+	{0x800000, 0x00}, /*drc_ad && drc_ad_1m*/
+};
+
+static u32 drc_tko_table[2][3] = {
+	{0x0, 0xbf000000, 0x40000}, /*offset, thd, k*/
+	{0x0, 0x0, 0x40000}, /*offset, thd, k*/
+};
+
 static const char *const audio_in_source_texts[] = { "LINEIN", "ATV", "HDMI" };
 
 static const struct soc_enum audio_in_source_enum =
@@ -75,8 +115,12 @@ static int aml_audio_set_in_source(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
 	if (ucontrol->value.enumerated.item[0] == 0) {
-		/* select external codec output as I2S source */
-		aml_write_cbus(AUDIN_SOURCE_SEL, 0);
+		if (is_meson_txl_cpu()) {
+			/* select internal acodec output in TXL as I2S source */
+			aml_write_cbus(AUDIN_SOURCE_SEL, 3);
+		} else
+			/* select external codec output as I2S source */
+			aml_write_cbus(AUDIN_SOURCE_SEL, 0);
 		audio_in_source = 0;
 	} else if (ucontrol->value.enumerated.item[0] == 1) {
 		/* select ATV output as I2S source */
@@ -152,9 +196,9 @@ static const struct sppdif_audio_info type_texts[] = {
 	{1, 0x1, "AC3"},
 	{2, 0x15, "EAC3"},
 	{3, 0xb, "DTS-I"},
-	{3, 0x10c, "DTS-II"},
-	{3, 0x20d, "DTS-III"},
-	{3, 0x411, "DTS-IV"},
+	{3, 0x0c, "DTS-II"},
+	{3, 0x0d, "DTS-III"},
+	{3, 0x11, "DTS-IV"},
 	{4, 0, "DTS-HD"},
 	{5, 0x16, "TRUEHD"},
 };
@@ -339,6 +383,31 @@ static int aml_set_audio_in_switch(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static int init_EQ_DRC_module(void)
+{
+	aml_write_cbus(AED_TOP_CTL, (1 << 31)); /* fifo init */
+	aml_write_cbus(AED_ED_CTL, 1); /* soft reset*/
+	msleep(20);
+	aml_write_cbus(AED_ED_CTL, 0); /* soft reset*/
+	aml_write_cbus(AED_TOP_CTL, (0 << 1) /*i2s in sel*/
+						| (1 << 0)); /*module enable*/
+	aml_write_cbus(AED_NG_CTL, (3 << 30)); /* disable noise gate*/
+	return 0;
+}
+
+static int set_internal_EQ_volume(unsigned master_volume,
+			unsigned channel_1_volume, unsigned channel_2_volume)
+{
+	aml_write_cbus(AED_EQ_VOLUME, (2 << 30) /* volume step: 0.5dB*/
+			| (master_volume << 16) /* master volume: 0dB*/
+			| (channel_1_volume << 8) /* channel 1 volume: 0dB*/
+			| (channel_2_volume << 0) /* channel 2 volume: 0dB*/
+			);
+	aml_write_cbus(AED_EQ_VOLUME_SLEW_CNT, 0x40);
+	aml_write_cbus(AED_MUTE, 0);
+	return 0;
+}
+
 static const struct snd_kcontrol_new av_controls[] = {
 	SOC_ENUM_EXT("AudioIn Switch",
 			 audio_in_switch_enum,
@@ -373,12 +442,122 @@ static const struct snd_kcontrol_new aml_g9tv_controls[] = {
 		     aml_output_swap_set_enum),
 };
 
+static int aml_get_cbus_reg(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol) {
+
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int max = mc->max;
+	unsigned int invert = mc->invert;
+	unsigned int value =
+			(((unsigned)aml_read_cbus(reg)) >> shift) & max;
+
+	if (invert)
+		value = (~value) & max;
+	ucontrol->value.integer.value[0] = value;
+
+	return 0;
+}
+
+static int aml_set_cbus_reg(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol) {
+
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int max = mc->max;
+	unsigned int invert = mc->invert;
+	unsigned int value = ucontrol->value.integer.value[0];
+	unsigned int reg_value = (unsigned int)aml_read_cbus(reg);
+
+	if (invert)
+		value = (~value) & max;
+	max = ~(max << shift);
+	reg_value &= max;
+	reg_value |= (value << shift);
+	aml_write_cbus(reg, reg_value);
+
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(mvol_tlv, -12276, 12, 1);
+static const DECLARE_TLV_DB_SCALE(chvol_tlv, -12750, 50, 1);
+
+static const struct snd_kcontrol_new aml_EQ_DRC_controls[] = {
+	SOC_SINGLE_EXT_TLV("EQ master volume",
+			 AED_EQ_VOLUME, 16, 0x3FF, 1,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 mvol_tlv),
+
+	SOC_SINGLE_EXT_TLV("EQ ch1 volume",
+			 AED_EQ_VOLUME, 8, 0xFF, 1,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 chvol_tlv),
+
+	SOC_SINGLE_EXT_TLV("EQ ch2 volume",
+			 AED_EQ_VOLUME, 0, 0xFF, 1,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 chvol_tlv),
+
+	SOC_SINGLE_EXT_TLV("EQ master volume mute",
+			 AED_MUTE, 31, 0x1, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+
+	SOC_SINGLE_EXT_TLV("EQ enable",
+			 AED_EQ_EN, 0, 0x1, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+
+	SOC_SINGLE_EXT_TLV("DRC enable",
+			 AED_DRC_EN, 0, 0x1, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+
+	SOC_SINGLE_EXT_TLV("NG enable",
+			 AED_NG_CTL, 0, 0x1, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+
+	SOC_SINGLE_EXT_TLV("NG noise thd",
+			 AED_NG_THD0, 8, 0x7FFF, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+
+	SOC_SINGLE_EXT_TLV("NG signal thd",
+			 AED_NG_THD1, 8, 0x7FFF, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+
+	SOC_SINGLE_EXT_TLV("NG counter thd",
+			 AED_NG_CNT_THD, 0, 0xFFFF, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+
+	SOC_SINGLE_EXT_TLV("Hw resample pause enable",
+			 AUD_RESAMPLE_CTRL2, 24, 0x1, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+
+	SOC_SINGLE_EXT_TLV("Hw resample pause thd",
+			 AUD_RESAMPLE_CTRL2, 11, 0x1FFF, 0,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
+			 NULL),
+};
+
 static int aml_suspend_pre(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
 
 	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		gpiod_direction_output(p_aml_audio->mute_desc,
+					GPIOF_OUT_INIT_LOW);
+	};
 	return 0;
 }
 
@@ -401,6 +580,12 @@ static int aml_resume_post(struct snd_soc_card *card)
 	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		gpiod_direction_output(p_aml_audio->mute_desc,
+					GPIOF_OUT_INIT_HIGH);
+	}
 	return 0;
 }
 
@@ -453,6 +638,7 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 static void aml_g9tv_pinmux_init(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
+	int ret = 0;
 
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	p_aml_audio->pin_ctl =
@@ -464,7 +650,12 @@ static void aml_g9tv_pinmux_init(struct snd_soc_card *card)
 
 	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
 	if (!IS_ERR(p_aml_audio->mute_desc)) {
-		pr_info("%s, make avmute gpio high!\n", __func__);
+		ret = of_property_read_u32(card->dev->of_node, "sleep_time",
+				&p_aml_audio->sleep_time);
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		pr_info("make av unmute! sleep %d ms\n",
+				p_aml_audio->sleep_time);
 		gpiod_direction_output(p_aml_audio->mute_desc,
 					   GPIOF_OUT_INIT_HIGH);
 	}
@@ -989,6 +1180,88 @@ err:
 	return ret;
 }
 
+static int aml_EQ_DRC_parse_of(struct snd_soc_card *card)
+{
+	struct device_node *audio_codec_node = card->dev->of_node;
+	struct device_node *child;
+	int length = 0;
+	int ret = 0;
+	int i = 0;
+	u32 *reg_ptr = &aml_EQ_param[0][0];
+
+	child = of_get_child_by_name(audio_codec_node, "aml_EQ_DRC");
+	if (child == NULL) {
+		pr_err("Error: failed to find node %s\n", "aml_EQ_DRC");
+		return -1;
+	}
+
+	if (of_find_property(child, "eq_table", &length) == NULL) {
+		pr_err("[%s] not found!\n", "eq_table");
+	} else {
+		/*pr_info("child name: %s, length = %d\n",
+			child->name, length);*/
+		ret = of_property_read_u32_array(child, "eq_table",
+					reg_ptr, 100);
+		if (ret) {
+			pr_err("Can't get EQ param [%s]!\n", "eq_table");
+		} else {
+			for (i = 0; i < 100; i++) {
+				aml_write_cbus(AED_EQ_CH1_COEF00 + i, *reg_ptr);
+				/*pr_info("EQ value[%d]: 0x%x\n",
+					i, *reg_ptr);*/
+				reg_ptr++;
+			}
+		}
+	}
+
+	reg_ptr = &drc_table[0][0];
+	if (of_find_property(child, "drc_table", &length) == NULL) {
+		pr_err("[%s] not found!\n", "drc_table");
+	} else {
+		ret = of_property_read_u32_array(child, "drc_table",
+					reg_ptr, 6);
+		if (ret) {
+			pr_err("Can't get drc param [%s]!\n", "drc_table");
+		} else {
+			aml_write_cbus(AED_DRC_AE, drc_table[0][0]);
+			aml_write_cbus(AED_DRC_AA, drc_table[1][0]);
+			aml_write_cbus(AED_DRC_AD, drc_table[2][0]);
+			aml_write_cbus(AED_DRC_AE_1M, drc_table[0][1]);
+			aml_write_cbus(AED_DRC_AA_1M, drc_table[1][1]);
+			aml_write_cbus(AED_DRC_AD_1M, drc_table[2][1]);
+			/*pr_info("DRC table: 0x%x, 0x%x,"
+					"0x%x, 0x%x, 0x%x, 0x%x,\n",
+					drc_table[0][0], drc_table[0][1],
+					drc_table[1][0], drc_table[1][1],
+					drc_table[2][0], drc_table[2][1]);*/
+		}
+	}
+
+	reg_ptr = &drc_tko_table[0][0];
+	if (of_find_property(child, "drc_tko_table", &length) == NULL) {
+		pr_err("[%s] not found!\n", "drc_tko_table");
+	} else {
+		ret = of_property_read_u32_array(child, "drc_tko_table",
+					reg_ptr, 6);
+		if (ret) {
+			pr_err("Can't get drc param [%s]!\n", "drc_tko_table");
+		} else {
+			aml_write_cbus(AED_DRC_OFFSET0, drc_tko_table[0][0]);
+			aml_write_cbus(AED_DRC_OFFSET1, drc_tko_table[1][0]);
+			aml_write_cbus(AED_DRC_THD0, drc_tko_table[0][1]);
+			aml_write_cbus(AED_DRC_THD1, drc_tko_table[1][1]);
+			aml_write_cbus(AED_DRC_K0, drc_tko_table[0][2]);
+			aml_write_cbus(AED_DRC_K1, drc_tko_table[1][2]);
+			/*pr_info("DRC tko: 0x%x, 0x%x,"
+			"0x%x, 0x%x, 0x%x, 0x%x,\n",
+			drc_tko_table[0][0], drc_tko_table[1][0],
+			drc_tko_table[0][1], drc_tko_table[1][1],
+			drc_tko_table[0][2], drc_tko_table[1][2]);*/
+		}
+	}
+	return 0;
+}
+
 static int aml_g9tv_audio_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1040,6 +1313,14 @@ static int aml_g9tv_audio_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	if (is_meson_txl_cpu()) {
+		set_internal_EQ_volume(0xc0, 0x30, 0x30);
+		init_EQ_DRC_module();
+		snd_soc_add_card_controls(card, aml_EQ_DRC_controls,
+					ARRAY_SIZE(aml_EQ_DRC_controls));
+		aml_EQ_DRC_parse_of(card);
+	}
+
 	aml_g9tv_pinmux_init(card);
 	return 0;
 err:
diff --git a/sound/soc/aml/m8/aml_g9tv.h b/sound/soc/aml/m8/aml_g9tv.h
index 223a028..5ba1ea5 100644
--- a/sound/soc/aml/m8/aml_g9tv.h
+++ b/sound/soc/aml/m8/aml_g9tv.h
@@ -36,6 +36,7 @@ struct aml_audio_private_data {
 	struct timer_list timer;
 	struct gpio_desc *mute_desc;
 	struct clk *clk;
+	int sleep_time;
 
 	struct switch_dev sdev;	/* for android */
 	struct switch_dev mic_sdev;	/* for android */
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index 3461a3d..a2bf64e 100644
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -79,9 +79,13 @@ static void aml_i2s_timer_callback(unsigned long data);
  *	 them against real values for AML
  */
 static const struct snd_pcm_hardware aml_i2s_hardware = {
-	.info = SNDRV_PCM_INFO_INTERLEAVED |
+	.info =
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	SNDRV_PCM_INFO_MMAP |
+	SNDRV_PCM_INFO_MMAP_VALID |
+#endif
+	SNDRV_PCM_INFO_INTERLEAVED |
 	    SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE,
-
 	.formats =
 	    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
 	    SNDRV_PCM_FMTBIT_S32_LE,
@@ -96,7 +100,11 @@ static const struct snd_pcm_hardware aml_i2s_hardware = {
 	.rate_max = 48000,
 	.channels_min = 2,
 	.channels_max = 8,
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	.fifo_size = 4,
+#else
 	.fifo_size = 0,
+#endif
 };
 
 static const struct snd_pcm_hardware aml_i2s_capture = {
@@ -134,6 +142,28 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 /*--------------------------------------------------------------------------*\
  * Helper functions
 \*--------------------------------------------------------------------------*/
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = aml_i2s_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+
+	buf->area = dmam_alloc_coherent(pcm->card->dev, size,
+			&buf->addr, GFP_KERNEL);
+	dev_info(pcm->card->dev, "aml-pcm %d: playback preallocate_dma_buffer: area=%p, addr=%p, size=%ld\n",
+		stream, (void *) buf->area, (void *) buf->addr, size);
+	if (!buf->area)
+		return -ENOMEM;
+
+	buf->bytes = size;
+	return 0;
+}
+#else
 static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 
@@ -207,7 +237,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	return 0;
 
 }
-
+#endif
 /*--------------------------------------------------------------------------*\
  * ISR
 \*--------------------------------------------------------------------------*/
@@ -549,6 +579,7 @@ static int aml_i2s_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+#ifndef CONFIG_SND_AML_SPLIT_MODE_MMAP
 static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 				 snd_pcm_uframes_t pos,
 				 void __user *buf, snd_pcm_uframes_t count,
@@ -556,8 +587,10 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 {
 	int res = 0;
 	int n;
+#ifndef CONFIG_SND_AML_SPLIT_MODE
 	int i = 0, j = 0;
 	int align = runtime->channels * 32;
+#endif
 	unsigned long offset = frames_to_bytes(runtime, pos);
 	char *hwbuf = runtime->dma_area + offset;
 	struct aml_runtime_data *prtd = runtime->private_data;
@@ -566,9 +599,10 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 	void *ubuf = tmp_buf->buffer_start;
 	struct audio_stream *s = &prtd->s;
 	struct device *dev = substream->pcm->card->dev;
+#ifndef CONFIG_SND_AML_SPLIT_MODE
 	int cached_len = tmp_buf->cached_len;
 	char *cache_buffer_bytes = tmp_buf->cache_buffer_bytes;
-
+#endif
 	n = frames_to_bytes(runtime, count);
 	if (n > tmp_buf->buffer_size) {
 		dev_err(dev, "FATAL_ERR:UserData/%d > buffer_size/%d\n",
@@ -579,6 +613,7 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 	if (res)
 		return -EFAULT;
 
+#ifndef CONFIG_SND_AML_SPLIT_MODE
 	/*mask align byte(64 or 256)*/
 	if ((cached_len != 0 || (n % align) != 0)) {
 		int byte_size = n;
@@ -613,11 +648,15 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 		n = ouput_len;
 	}
 	/*end of mask*/
+#endif
 
 	if (s->device_type == AML_AUDIO_I2SOUT)
 		aml_i2s_alsa_write_addr = offset;
 
 	if (access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		memcpy(hwbuf, ubuf, n);
+#else
 		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
 
 			int16_t *tfrom, *to, *left, *right;
@@ -703,7 +742,7 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 				}
 			}
 		}
-
+#endif
 	} else {
 		res = -EFAULT;
 	}
@@ -778,6 +817,7 @@ static int aml_i2s_copy(struct snd_pcm_substream *substream, int channel,
 	}
 	return ret;
 }
+#endif
 
 int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 		    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
@@ -792,6 +832,21 @@ int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 	return 0;
 }
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+static int aml_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	dev_info(substream->pcm->card->dev,
+		"\narea=%p,addr=%ld,bytes=%ld,rate:%d, channels:%d, subformat:%d\n",
+		runtime->dma_area, (long)runtime->dma_addr, runtime->dma_bytes,
+		runtime->rate, runtime->channels, runtime->subformat);
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+		runtime->dma_area, runtime->dma_addr, runtime->dma_bytes);
+}
+#endif
+
 static struct snd_pcm_ops aml_i2s_ops = {
 	.open = aml_i2s_open,
 	.close = aml_i2s_close,
@@ -801,7 +856,11 @@ static struct snd_pcm_ops aml_i2s_ops = {
 	.prepare = aml_i2s_prepare,
 	.trigger = aml_i2s_trigger,
 	.pointer = aml_i2s_pointer,
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	.mmap = aml_pcm_mmap,
+#else
 	.copy = aml_i2s_copy,
+#endif
 	.silence = aml_i2s_silence,
 };
 
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index 3626676..1bac72f 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -71,7 +71,11 @@ static void aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
 		i2s_mode = AIU_I2S_MODE_PCM16;
 		break;
 	}
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	audio_set_i2s_mode(i2s_mode, runtime->channels);
+#else
 	audio_set_i2s_mode(i2s_mode);
+#endif
 	audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes,
 			 runtime->channels);
 }
@@ -113,7 +117,7 @@ static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
 	if (IEC958_mode_codec == 0)
-		aml_spdif_play();
+		aml_spdif_play(1);
 	return;
 }
 
@@ -122,11 +126,11 @@ static int aml_i2s_set_amclk(struct aml_i2s *i2s, unsigned long rate)
 {
 	int ret = 0;
 
-	ret = clk_set_rate(i2s->clk_mpl0, rate * 10);
+	ret = clk_set_rate(i2s->clk_mpll, rate * 10);
 	if (ret)
 		return ret;
 
-	ret = clk_set_parent(i2s->clk_mclk, i2s->clk_mpl0);
+	ret = clk_set_parent(i2s->clk_mclk, i2s->clk_mpll);
 	if (ret)
 		return ret;
 
@@ -146,11 +150,10 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s = &prtd->s;
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		audio_out_i2s_enable(0);
-
-	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	}
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		s->i2s_mode = dai_info[dai->id].i2s_mode;
 		audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes * 2,
@@ -169,7 +172,7 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 		aml_hw_i2s_init(runtime);
 		/* i2s/958 share the same audio hw buffer when PCM mode */
 		if (IEC958_mode_codec == 0) {
-			aml_hw_iec958_init(substream);
+			aml_hw_iec958_init(substream, 1);
 			/* use the hw same sync for i2s/958 */
 			dev_info(substream->pcm->card->dev, "i2s/958 same source\n");
 			/* aml_set_spdif_clk(runtime->rate*512, 0); */
@@ -362,10 +365,10 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 	i2s->disable_clk_suspend =
 		of_property_read_bool(pnode, "disable_clk_suspend");
 
-	i2s->clk_mpl0 = devm_clk_get(&pdev->dev, "mpll0");
-	if (IS_ERR(i2s->clk_mpl0)) {
-		dev_err(&pdev->dev, "Can't retrieve mpll0 clock\n");
-		ret = PTR_ERR(i2s->clk_mpl0);
+	i2s->clk_mpll = devm_clk_get(&pdev->dev, "mpll2");
+	if (IS_ERR(i2s->clk_mpll)) {
+		dev_err(&pdev->dev, "Can't retrieve mpll2 clock\n");
+		ret = PTR_ERR(i2s->clk_mpll);
 		goto err;
 	}
 
diff --git a/sound/soc/aml/m8/aml_i2s_dai.h b/sound/soc/aml/m8/aml_i2s_dai.h
index 72d305c..d9cc7f8 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.h
+++ b/sound/soc/aml/m8/aml_i2s_dai.h
@@ -20,7 +20,7 @@
 
 extern struct snd_soc_dai_driver aml_dai[];
 struct aml_i2s {
-	struct clk *clk_mpl0;
+	struct clk *clk_mpll;
 	struct clk *clk_mclk;
 	int old_samplerate;
 	bool disable_clk_suspend;
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
index f570989..0c03db8 100644
--- a/sound/soc/aml/m8/aml_m8.c
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -56,7 +56,11 @@ static int i2sbuf[32 + 16];
 static void aml_i2s_play(void)
 {
 	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	audio_set_i2s_mode(AIU_I2S_MODE_PCM16, 2);
+#else
 	audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
+#endif
 	memset(i2sbuf, 0, sizeof(i2sbuf));
 	audio_set_aiubuf((virt_to_phys(i2sbuf) + 63) & (~63), 128, 2);
 	audio_out_i2s_enable(1);
@@ -238,7 +242,8 @@ static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
 	       aml_m8_spk_enabled);
 
 	msleep_interruptible(10);
-	gpiod_set_value(p_audio->mute_desc, aml_m8_spk_enabled);
+	if (!IS_ERR(p_audio->mute_desc))
+		gpiod_direction_output(p_audio->mute_desc, aml_m8_spk_enabled);
 
 	if (aml_m8_spk_enabled == 1)
 		msleep_interruptible(100);
@@ -257,6 +262,7 @@ static int aml_suspend_pre(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
 	struct pinctrl_state *state;
+	int val = 0;
 
 	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
@@ -281,6 +287,12 @@ static int aml_suspend_pre(struct snd_soc_card *card)
 		pinctrl_select_state(p_aml_audio->pin_ctl, state);
 	}
 
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	};
+
 	return 0;
 }
 
@@ -301,6 +313,7 @@ static int aml_resume_post(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
 	struct pinctrl_state *state;
+	int val = 0;
 
 	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
@@ -325,6 +338,13 @@ static int aml_resume_post(struct snd_soc_card *card)
 		pinctrl_select_state(p_aml_audio->pin_ctl, state);
 	}
 
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	}
 	return 0;
 }
 
@@ -333,7 +353,7 @@ static int speaker_events(struct snd_soc_dapm_widget *w,
 {
 	int val = 0;
 
-	if (p_audio->mute_desc == NULL) {
+	if (IS_ERR(p_audio->mute_desc)) {
 		pr_info("no mute_gpio setting");
 		return 0;
 	}
@@ -499,7 +519,9 @@ static void aml_m8_pinmux_init(struct snd_soc_card *card)
 	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
 	p_aml_audio->mute_inv =
 	    of_property_read_bool(card->dev->of_node, "mute_inv");
-	if (p_aml_audio->mute_desc) {
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
 		val = p_aml_audio->mute_inv ?
 			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
 		gpiod_direction_output(p_aml_audio->mute_desc, val);
@@ -696,7 +718,6 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 	}
 
 	aml_i2s_play();
-	msleep(100);
 	aml_m8_pinmux_init(card);
 	return 0;
  err:
diff --git a/sound/soc/aml/m8/aml_pcm.c b/sound/soc/aml/m8/aml_pcm.c
index 13d4064..6c44b48 100644
--- a/sound/soc/aml/m8/aml_pcm.c
+++ b/sound/soc/aml/m8/aml_pcm.c
@@ -38,9 +38,8 @@
 #include <sound/pcm_params.h>
 
 #include <linux/amlogic/sound/audin_regs.h>
-/* #include "aml_i2s.h" */
 #include "aml_pcm.h"
-#include "aml_audio_hw_pcm2bt.h"
+#include "aml_audio_hw_pcm.h"
 
 /*--------------------------------------------------------------------------*\
  * Hardware definition
@@ -48,21 +47,42 @@
 /* TODO: These values were taken from the AML platform driver, check
  *	 them against real values for AML
  */
-static const struct snd_pcm_hardware aml_pcm2bt_hardware = {
+static const struct snd_pcm_hardware aml_pcm_hardware = {
 	.info = SNDRV_PCM_INFO_INTERLEAVED |
 	    SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE,
-	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.formats =
+	    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+	    SNDRV_PCM_FMTBIT_S32_LE,
 	.period_bytes_min = 32,
 	.period_bytes_max = 8 * 1024,
 	.periods_min = 2,
 	.periods_max = 1024,
 	.buffer_bytes_max = 64 * 1024,
 	.rate_min = 8000,
-	.rate_max = 8000,
+	.rate_max = 48000,
+	.channels_min = 1,
+	.channels_max = 8,
+};
+
+static const struct snd_pcm_hardware aml_pcm_capture = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+	    SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE,
+
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min = 64,
+	.period_bytes_max = 32 * 1024,
+	.periods_min = 2,
+	.periods_max = 1024,
+	.buffer_bytes_max = 64 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
 	.channels_min = 1,
-	.channels_max = 1,
+	.channels_max = 8,
+	.fifo_size = 0,
 };
 
+
 static unsigned int period_sizes[] = { 64, 128, 256, 512,
 	1024, 2048, 4096, 8192
 };
@@ -73,16 +93,6 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 	.mask = 0
 };
 
-unsigned int aml_pcm2bt_playback_buffer_addr = 0;
-unsigned int aml_pcm2bt_playback_buffer_size = 0;
-unsigned int aml_pcm2bt_capture_buffer_addr = 0;
-unsigned int aml_pcm2bt_capture_buffer_size = 0;
-
-unsigned int aml_pcm2bt_playback_phy_buffer_addr = 0;
-unsigned int aml_pcm2bt_playback_phy_buffer_size = 0;
-unsigned int aml_pcm2bt_capture_phy_buffer_addr = 0;
-unsigned int aml_pcm2bt_capture_phy_buffer_size = 0;
-
 static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
 {
 	unsigned int value = 0;
@@ -117,7 +127,7 @@ static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
 	return (unsigned int)diff;
 }
 
-static void aml_pcm2bt_timer_update(struct aml_pcm_runtime_data *prtd)
+static void aml_pcm_timer_update(struct aml_pcm_runtime_data *prtd)
 {
 	struct snd_pcm_substream *substream = prtd->substream;
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -159,25 +169,25 @@ static void aml_pcm2bt_timer_update(struct aml_pcm_runtime_data *prtd)
 
 }
 
-static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
+static void aml_pcm_timer_rearm(struct aml_pcm_runtime_data *prtd)
 {
 	prtd->timer.expires = jiffies + prtd->timer_period;
 	add_timer(&prtd->timer);
 }
 
-static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
+static int aml_pcm_timer_start(struct aml_pcm_runtime_data *prtd)
 {
-	pr_debug("%s\n", __func__);
+	pr_info("%s\n", __func__);
 	spin_lock(&prtd->lock);
-	aml_pcm2bt_timer_rearm(prtd);
+	aml_pcm_timer_rearm(prtd);
 	prtd->running = 1;
 	spin_unlock(&prtd->lock);
 	return 0;
 }
 
-static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
+static int aml_pcm_timer_stop(struct aml_pcm_runtime_data *prtd)
 {
-	pr_debug("%s\n", __func__);
+	pr_info("%s\n", __func__);
 	spin_lock(&prtd->lock);
 	prtd->running = 0;
 	del_timer(&prtd->timer);
@@ -185,7 +195,7 @@ static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
 	return 0;
 }
 
-static void aml_pcm2bt_timer_callback(unsigned long data)
+static void aml_pcm_timer_callback(unsigned long data)
 {
 	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -195,8 +205,8 @@ static void aml_pcm2bt_timer_callback(unsigned long data)
 	unsigned int datasize = 0;
 
 	spin_lock_irqsave(&prtd->lock, flags);
-	aml_pcm2bt_timer_update(prtd);
-	aml_pcm2bt_timer_rearm(prtd);
+	aml_pcm_timer_update(prtd);
+	aml_pcm_timer_rearm(prtd);
 	elapsed = prtd->peroid_elapsed;
 	datasize = prtd->data_size;
 	if (elapsed) {
@@ -213,28 +223,29 @@ static void aml_pcm2bt_timer_callback(unsigned long data)
 	}
 }
 
-static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
+static int aml_pcm_timer_create(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 
-	pr_debug("%s\n", __func__);
+	pr_info("%s\n", __func__);
 	init_timer(&prtd->timer);
 	prtd->timer_period = 1;
 	prtd->timer.data = (unsigned long)substream;
-	prtd->timer.function = aml_pcm2bt_timer_callback;
+	prtd->timer.function = aml_pcm_timer_callback;
 	prtd->running = 0;
 	return 0;
 }
 
 static int
-aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
+aml_pcm_hw_params(struct snd_pcm_substream *substream,
 		     struct snd_pcm_hw_params *params)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 	size_t size = params_buffer_bytes(params);
 	int ret = 0;
+	pr_info("enter %s\n", __func__);
 
 	ret = snd_pcm_lib_malloc_pages(substream, size);
 	if (ret < 0)
@@ -244,56 +255,49 @@ aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
 		prtd->buffer_size = runtime->dma_bytes;
 
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
-			aml_pcm2bt_playback_phy_buffer_size =
-			    runtime->dma_bytes;
 		} else {
-			aml_pcm2bt_capture_phy_buffer_addr = runtime->dma_addr;
-			aml_pcm2bt_capture_phy_buffer_size = runtime->dma_bytes;
 		}
 	}
 
 	return ret;
 }
 
-static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
+static int aml_pcm_hw_free(struct snd_pcm_substream *substream)
 {
-	pr_debug("enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	snd_pcm_lib_free_pages(substream);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		aml_pcm2bt_playback_phy_buffer_addr = 0;
-		aml_pcm2bt_playback_phy_buffer_size = 0;
 	} else {
-		aml_pcm2bt_capture_phy_buffer_addr = 0;
-		aml_pcm2bt_capture_phy_buffer_size = 0;
 	}
 
 	return 0;
 }
 
-static int aml_pcm2bt_prepare(struct snd_pcm_substream *substream)
+static int aml_pcm_prepare(struct snd_pcm_substream *substream)
 {
+	pr_info("enter %s\n", __func__);
+
 	return 0;
 }
 
-static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
+static int aml_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 	int ret = 0;
-	pr_debug("enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		aml_pcm2bt_timer_start(prtd);
+		aml_pcm_timer_start(prtd);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		aml_pcm2bt_timer_stop(prtd);
+		aml_pcm_timer_stop(prtd);
 		break;
 	default:
 		ret = -EINVAL;
@@ -302,26 +306,30 @@ static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
 	return ret;
 }
 
-static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
+static snd_pcm_uframes_t aml_pcm_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 	snd_pcm_uframes_t frames;
 
-	pr_debug("enter %s\n", __func__);
+	/* pr_info("enter %s\n", __func__); */
 	frames = bytes_to_frames(runtime, (ssize_t) prtd->buffer_offset);
 
 	return frames;
 }
 
-static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
+static int aml_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd;
 	int ret;
-	pr_debug("enter %s\n", __func__);
+	pr_info("enter %s, stream:%d\n", __func__, substream->stream);
+
 
-	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_set_runtime_hwparams(substream, &aml_pcm_hardware);
+	else
+		snd_soc_set_runtime_hwparams(substream, &aml_pcm_capture);
 
 	/* Ensure that peroid size is a multiple of 32bytes */
 	ret =
@@ -349,7 +357,7 @@ static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
 	}
 
 	runtime->private_data = prtd;
-	aml_pcm2bt_timer_create(substream);
+	aml_pcm_timer_create(substream);
 	prtd->substream = substream;
 	spin_lock_init(&prtd->lock);
 
@@ -358,7 +366,7 @@ static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
 	return ret;
 }
 
-static int aml_pcm2bt_close(struct snd_pcm_substream *substream)
+static int aml_pcm_close(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
@@ -371,7 +379,7 @@ static int aml_pcm2bt_close(struct snd_pcm_substream *substream)
 }
 
 static int
-aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+aml_pcm_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 			 snd_pcm_uframes_t pos,
 			 void __user *buf, snd_pcm_uframes_t count)
 {
@@ -381,9 +389,9 @@ aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 	unsigned int wrptr = 0;
 	int ret = 0;
 
-	pr_debug("enter %s channel: %d pos: %ld count: %ld\n",
+/*	pr_info("enter %s channel: %d pos: %ld count: %ld\n",
 		  __func__, channel, pos, count);
-
+*/
 	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
 		pr_err("%s copy from user failed!\n", __func__);
 		return -EFAULT;
@@ -395,12 +403,11 @@ aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 
 		pcm_out_set_wr_ptr(wrptr);
 	}
-
 	return ret;
 }
 
 static int
-aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+aml_pcm_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 			snd_pcm_uframes_t pos,
 			void __user *buf, snd_pcm_uframes_t count)
 {
@@ -410,9 +417,9 @@ aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 	unsigned int rdptr = 0;
 	int ret = 0;
 
-	pr_debug("enter %s channel: %d pos: %ld count: %ld\n",
+/*	pr_info("enter %s channel: %d pos: %ld count: %ld\n",
 		  __func__, channel, pos, count);
-
+*/
 	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
 		pr_err("%s copy to user failed!\n", __func__);
 		return -EFAULT;
@@ -430,7 +437,7 @@ aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 	return ret;
 }
 
-static int aml_pcm2bt_copy(struct snd_pcm_substream *substream,
+static int aml_pcm_copy(struct snd_pcm_substream *substream,
 	int channel, snd_pcm_uframes_t pos,
 	void __user *buf, snd_pcm_uframes_t count)
 {
@@ -439,23 +446,23 @@ static int aml_pcm2bt_copy(struct snd_pcm_substream *substream,
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		ret =
-		    aml_pcm2bt_copy_playback(runtime, channel, pos, buf, count);
+		    aml_pcm_copy_playback(runtime, channel, pos, buf, count);
 	} else {
 		ret =
-		    aml_pcm2bt_copy_capture(runtime, channel, pos, buf, count);
+		    aml_pcm_copy_capture(runtime, channel, pos, buf, count);
 	}
 
 	return ret;
 }
 
-static int aml_pcm2bt_silence(struct snd_pcm_substream *substream,
+static int aml_pcm_silence(struct snd_pcm_substream *substream,
 	int channel, snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned char *ppos = NULL;
 	ssize_t n;
 
-	pr_debug("enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	n = frames_to_bytes(runtime, count);
 	ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
 	memset(ppos, 0, n);
@@ -463,30 +470,30 @@ static int aml_pcm2bt_silence(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static struct snd_pcm_ops aml_pcm2bt_ops = {
-	.open = aml_pcm2bt_open,
-	.close = aml_pcm2bt_close,
+static struct snd_pcm_ops aml_pcm_ops = {
+	.open = aml_pcm_open,
+	.close = aml_pcm_close,
 	.ioctl = snd_pcm_lib_ioctl,
-	.hw_params = aml_pcm2bt_hw_params,
-	.hw_free = aml_pcm2bt_hw_free,
-	.prepare = aml_pcm2bt_prepare,
-	.trigger = aml_pcm2bt_trigger,
-	.pointer = aml_pcm2bt_pointer,
-	.copy = aml_pcm2bt_copy,
-	.silence = aml_pcm2bt_silence,
+	.hw_params = aml_pcm_hw_params,
+	.hw_free = aml_pcm_hw_free,
+	.prepare = aml_pcm_prepare,
+	.trigger = aml_pcm_trigger,
+	.pointer = aml_pcm_pointer,
+	.copy = aml_pcm_copy,
+	.silence = aml_pcm_silence,
 };
 
 /*--------------------------------------------------------------------------*\
  * ASoC platform driver
 \*--------------------------------------------------------------------------*/
 
-static u64 aml_pcm2bt_dmamask = DMA_BIT_MASK(32);
+static u64 aml_pcm_dmamask = DMA_BIT_MASK(32);
 
-static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
-	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
+	size_t size = aml_pcm_hardware.buffer_bytes_max;
 
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
@@ -503,31 +510,30 @@ static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	return 0;
 }
 
-static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
+static int aml_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
-	/* pr_debug("enter %s\n", __FUNCTION__); */
 	int ret = 0;
 	struct snd_soc_card *card = rtd->card;
 	struct snd_pcm *pcm = rtd->pcm;
 	struct snd_soc_dai *dai;
 	dai = rtd->cpu_dai;
-	pr_debug("enter %s dai->name: %s dai->id: %d\n", __func__,
+	pr_info("enter %s dai->name: %s dai->id: %d\n", __func__,
 		  dai->name, dai->id);
 
 	if (!card->dev->dma_mask)
-		card->dev->dma_mask = &aml_pcm2bt_dmamask;
+		card->dev->dma_mask = &aml_pcm_dmamask;
 	if (!card->dev->coherent_dma_mask)
 		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
 
 	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
-		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
+		ret = aml_pcm_preallocate_dma_buffer(pcm,
 				SNDRV_PCM_STREAM_PLAYBACK);
 		if (ret)
 			goto out;
 	}
 
 	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
+		ret = aml_pcm_preallocate_dma_buffer(pcm,
 				SNDRV_PCM_STREAM_CAPTURE);
 		if (ret)
 			goto out;
@@ -537,13 +543,13 @@ static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
 	return ret;
 }
 
-static void aml_pcm2bt_free(struct snd_pcm *pcm)
+static void aml_pcm_free(struct snd_pcm *pcm)
 {
 	struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
 	int stream;
 
-	pr_debug("enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
 		if (!substream)
@@ -559,21 +565,46 @@ static void aml_pcm2bt_free(struct snd_pcm *pcm)
 	}
 }
 
-struct snd_soc_platform_driver aml_soc_platform_pcm2bt = {
-	.ops = &aml_pcm2bt_ops,
-	.pcm_new = aml_pcm2bt_new,
-	.pcm_free = aml_pcm2bt_free,
-	/* .suspend     = aml_pcm_suspend, */
-	/* .resume              = aml_pcm_resume, */
+#ifdef CONFIG_PM
+static int aml_pcm_suspend(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	if (!runtime)
+		return 0;
+
+	/* TODO */
+	return 0;
+}
+
+static int aml_pcm_resume(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	if (!runtime)
+		return 0;
+
+	/* TODO */
+	return 0;
+}
+#else
+#define aml_pcm_suspend	NULL
+#define aml_pcm_resume	NULL
+#endif
+
+struct snd_soc_platform_driver aml_soc_platform_pcm = {
+	.ops = &aml_pcm_ops,
+	.pcm_new = aml_pcm_new,
+	.pcm_free = aml_pcm_free,
+	.suspend  = aml_pcm_suspend,
+	.resume   = aml_pcm_resume,
 };
-EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
+EXPORT_SYMBOL_GPL(aml_soc_platform_pcm);
 
-static int aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
+static int aml_soc_platform_pcm_probe(struct platform_device *pdev)
 {
-	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm);
 }
 
-static int aml_soc_platform_pcm2bt_remove(struct platform_device *pdev)
+static int aml_soc_platform_pcm_remove(struct platform_device *pdev)
 {
 	snd_soc_unregister_platform(&pdev->dev);
 	return 0;
@@ -581,37 +612,38 @@ static int aml_soc_platform_pcm2bt_remove(struct platform_device *pdev)
 
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_audio_dt_match[] = {
-	{.compatible = "amlogic, aml-pcm",
-	 },
+	{
+		.compatible = "amlogic, aml-pcm",
+	},
 	{},
 };
 #else
 #define amlogic_audio_dt_match NULL
 #endif
 
-static struct platform_driver aml_platform_pcm2bt_driver = {
+static struct platform_driver aml_platform_pcm_driver = {
 	.driver = {
 		   .name = "aml-pcm",
 		   .owner = THIS_MODULE,
 		   .of_match_table = amlogic_audio_dt_match,
 		   },
 
-	.probe = aml_soc_platform_pcm2bt_probe,
-	.remove = aml_soc_platform_pcm2bt_remove,
+	.probe = aml_soc_platform_pcm_probe,
+	.remove = aml_soc_platform_pcm_remove,
 };
 
-static int __init aml_alsa_bt_init(void)
+static int __init aml_alsa_pcm_init(void)
 {
-	return platform_driver_register(&aml_platform_pcm2bt_driver);
+	return platform_driver_register(&aml_platform_pcm_driver);
 }
 
-static void __exit aml_alsa_bt_exit(void)
+static void __exit aml_alsa_pcm_exit(void)
 {
-	platform_driver_unregister(&aml_platform_pcm2bt_driver);
+	platform_driver_unregister(&aml_platform_pcm_driver);
 }
 
-module_init(aml_alsa_bt_init);
-module_exit(aml_alsa_bt_exit);
+module_init(aml_alsa_pcm_init);
+module_exit(aml_alsa_pcm_exit);
 
 MODULE_AUTHOR("AMLogic, Inc.");
 MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/m8/aml_pcm_dai.c b/sound/soc/aml/m8/aml_pcm_dai.c
index ed5e021..2b9b938 100644
--- a/sound/soc/aml/m8/aml_pcm_dai.c
+++ b/sound/soc/aml/m8/aml_pcm_dai.c
@@ -33,26 +33,58 @@
 #include "aml_pcm_dai.h"
 #include "aml_pcm.h"
 #include "aml_i2s.h"
-#include "aml_audio_hw_pcm2bt.h"
+#include "aml_audio_hw_pcm.h"
 
 #include <linux/of.h>
 
 #define DEV_NAME "aml-pcm-dai"
 
-static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
+#define AML_DAI_PCM_RATES		(SNDRV_PCM_RATE_8000_192000)
+#define AML_DAI_PCM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+#define PCM_DEFAULT_SAMPLERATE 8000
+#define PCM_DEFAULT_MCLK_RATIO_SR 256
+
+static int aml_pcm_set_clk(struct aml_pcm *pcm, unsigned long rate)
+{
+	int ret = 0;
+
+	ret = clk_set_rate(pcm->clk_mpll, rate * 10);
+	if (ret) {
+		pr_debug("%s, line:%d, error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = clk_set_parent(pcm->clk_pcm_mclk, pcm->clk_mpll);
+	if (ret) {
+		pr_debug("%s line:%d, error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = clk_set_rate(pcm->clk_pcm_mclk, rate);
+	if (ret) {
+		pr_debug("%s, line:%d, error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int aml_pcm_dai_startup(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
 	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
-static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
+static void aml_pcm_dai_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
 	pr_debug("***Entered %s\n", __func__);
 }
 
-static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
+static int aml_pcm_dai_prepare(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -76,34 +108,53 @@ static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
 	prtd->buffer_offset = 0;
 	prtd->data_size = 0;
 	prtd->peroid_elapsed = 0;
-/* #endif */
+
 	return 0;
 }
 
-static int aml_dai_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
+static int aml_pcm_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 			       struct snd_soc_dai *dai)
 {
+	struct aml_pcm *pcm_p = dev_get_drvdata(dai->dev);
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		/* TODO */
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			pr_info("aiu pcm playback enable\n\n");
-			pcm_out_enable(1);
+		if (pcm_p && pcm_p->pcm_mode) {
+			pr_info("aiu pcm master stream %d enable\n\n",
+				substream->stream);
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				pcm_master_out_enable(substream, 1);
+			else
+				pcm_master_in_enable(substream, 1);
 		} else {
-			pcm_in_enable(1);
+			pr_info("aiu slave pcm stream %d enable\n\n",
+				substream->stream);
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				pcm_out_enable(1);
+			else
+				pcm_in_enable(1);
 		}
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			pr_info("aiu pcm playback disable\n\n");
-			pcm_out_enable(0);
+		if (pcm_p && pcm_p->pcm_mode) {
+			pr_info("aiu master pcm stream %d disable\n\n",
+				substream->stream);
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				pcm_master_out_enable(substream, 0);
+			else
+				pcm_master_in_enable(substream, 0);
 		} else {
-			pcm_in_enable(0);
-
+			pr_info("aiu slave pcm stream %d disable\n\n",
+				substream->stream);
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				pcm_out_enable(0);
+			else
+				pcm_in_enable(0);
 		}
 		break;
 	default:
@@ -113,15 +164,25 @@ static int aml_dai_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
+static int aml_pcm_dai_hw_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
 				 struct snd_soc_dai *dai)
 {
+	struct aml_pcm *pcm = snd_soc_dai_get_drvdata(dai);
+	int srate, mclk_rate;
+
+	srate = params_rate(params);
+	if (pcm->old_samplerate != srate) {
+		pcm->old_samplerate = srate;
+		mclk_rate = srate * PCM_DEFAULT_MCLK_RATIO_SR;
+		aml_pcm_set_clk(pcm, mclk_rate);
+	}
+
 	pr_debug("***Entered %s:%s\n", __FILE__, __func__);
 	return 0;
 }
 
-static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+static int aml_pcm_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
 	pr_debug("***Entered %s\n", __func__);
 	if (fmt & SND_SOC_DAIFMT_CBS_CFS)
@@ -129,7 +190,7 @@ static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	return 0;
 }
 
-static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
+static int aml_pcm_dai_set_sysclk(struct snd_soc_dai *dai,
 				  int clk_id, unsigned int freq, int dir)
 {
 	pr_debug("***Entered %s\n", __func__);
@@ -137,53 +198,50 @@ static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
 }
 
 #ifdef CONFIG_PM
-static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
+static int aml_pcm_dai_suspend(struct snd_soc_dai *dai)
 {
 
 	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
-static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
+static int aml_pcm_dai_resume(struct snd_soc_dai *dai)
 {
 	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
 #else				/* CONFIG_PM */
-#define aml_dai_pcm_suspend	NULL
-#define aml_dai_pcm_resume	NULL
+#define aml_pcm_dai_suspend	NULL
+#define aml_pcm_dai_resume	NULL
 #endif				/* CONFIG_PM */
 
-#define AML_DAI_PCM_RATES		(SNDRV_PCM_RATE_8000)
-#define AML_DAI_PCM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
-	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
-static struct snd_soc_dai_ops aml_dai_pcm_ops = {
-	.startup = aml_dai_pcm_startup,
-	.shutdown = aml_dai_pcm_shutdown,
-	.prepare = aml_dai_pcm_prepare,
-	.trigger = aml_dai_pcm_trigger,
-	.hw_params = aml_dai_pcm_hw_params,
-	.set_fmt = aml_dai_set_pcm_fmt,
-	.set_sysclk = aml_dai_set_pcm_sysclk,
+static struct snd_soc_dai_ops aml_pcm_dai_ops = {
+	.startup = aml_pcm_dai_startup,
+	.shutdown = aml_pcm_dai_shutdown,
+	.prepare = aml_pcm_dai_prepare,
+	.trigger = aml_pcm_dai_trigger,
+	.hw_params = aml_pcm_dai_hw_params,
+	.set_fmt = aml_pcm_dai_set_fmt,
+	.set_sysclk = aml_pcm_dai_set_sysclk,
 };
 
 struct snd_soc_dai_driver aml_pcm_dai[] = {
 	{
-	 .suspend = aml_dai_pcm_suspend,
-	 .resume = aml_dai_pcm_resume,
+	 .suspend = aml_pcm_dai_suspend,
+	 .resume = aml_pcm_dai_resume,
 	 .playback = {
 		      .channels_min = 1,
-		      .channels_max = 1,
+		      .channels_max = 8,
 		      .rates = AML_DAI_PCM_RATES,
 		      .formats = AML_DAI_PCM_FORMATS,},
 	 .capture = {
 		     .channels_min = 1,
-		     .channels_max = 1,
+		     .channels_max = 8,
 		     .rates = AML_DAI_PCM_RATES,
 		     .formats = AML_DAI_PCM_FORMATS,},
-	 .ops = &aml_dai_pcm_ops,
+	 .ops = &aml_pcm_dai_ops,
 	 },
 
 };
@@ -196,6 +254,8 @@ static const struct snd_soc_component_driver aml_component = {
 static int aml_pcm_dai_probe(struct platform_device *pdev)
 {
 	struct pinctrl *pin_ctl;
+	struct aml_pcm *pcm_p = NULL;
+	int ret;
 
 	pr_debug("enter %s\n", __func__);
 
@@ -203,50 +263,117 @@ static int aml_pcm_dai_probe(struct platform_device *pdev)
 	if (IS_ERR(pin_ctl))
 		pr_err("aml audio pcm dai pinmux set error!\n");
 
-	return snd_soc_register_component(&pdev->dev, &aml_component,
+	pcm_p = devm_kzalloc(&pdev->dev, sizeof(struct aml_pcm), GFP_KERNEL);
+	if (!pcm_p) {
+		dev_err(&pdev->dev, "Can't allocate pcm_p\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	dev_set_drvdata(&pdev->dev, pcm_p);
+
+	/* is PCM master? */
+	ret =
+	    of_property_read_u32((&pdev->dev)->of_node, "pcm_mode",
+				 &pcm_p->pcm_mode);
+
+	pr_info("pcm mode detection =%d\n", pcm_p->pcm_mode);
+
+	if (pcm_p->pcm_mode) {
+		pcm_p->clk_mpll = devm_clk_get(&pdev->dev, "mpll0");
+		if (IS_ERR(pcm_p->clk_mpll)) {
+			dev_err(&pdev->dev, "Can't retrieve mpll0 clock\n");
+			ret = PTR_ERR(pcm_p->clk_mpll);
+			goto err;
+		}
+
+		pcm_p->clk_pcm_mclk = devm_clk_get(&pdev->dev, "pcm_mclk");
+		if (IS_ERR(pcm_p->clk_pcm_mclk)) {
+			dev_err(&pdev->dev, "Can't retrieve clk_pcm_mclk clock\n");
+			ret = PTR_ERR(pcm_p->clk_pcm_mclk);
+			goto err;
+		}
+		pcm_p->clk_pcm_sync = devm_clk_get(&pdev->dev, "pcm_sclk");
+		if (IS_ERR(pcm_p->clk_pcm_sync)) {
+			dev_err(&pdev->dev, "Can't retrieve clk_pcm_sync clock\n");
+			ret = PTR_ERR(pcm_p->clk_pcm_sync);
+			goto err;
+		}
+
+		/* now only 256fs is supported */
+		ret = aml_pcm_set_clk(pcm_p,
+			PCM_DEFAULT_SAMPLERATE * PCM_DEFAULT_MCLK_RATIO_SR);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Can't set aml_pcm clk :%d\n", ret);
+			goto err;
+		}
+
+		ret = clk_prepare_enable(pcm_p->clk_pcm_mclk);
+		if (ret) {
+			dev_err(&pdev->dev,
+			"Can't enable pcm clk_pcm_mclk clock: %d\n", ret);
+			goto err;
+		}
+		ret = clk_prepare_enable(pcm_p->clk_pcm_sync);
+		if (ret) {
+			dev_err(&pdev->dev,
+			"Can't enable pcm clk_pcm_sync clock: %d\n", ret);
+			goto err;
+		}
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_pcm_dai, ARRAY_SIZE(aml_pcm_dai));
+
+err:
+	return ret;
+
 }
 
 static int aml_pcm_dai_remove(struct platform_device *pdev)
 {
+	struct aml_pcm *pcm_priv = dev_get_drvdata(&pdev->dev);
+
+	clk_disable_unprepare(pcm_priv->clk_pcm_mclk);
+	clk_disable_unprepare(pcm_priv->clk_pcm_sync);
+
 	snd_soc_unregister_component(&pdev->dev);
 	return 0;
 }
 
 #ifdef CONFIG_OF
-static const struct of_device_id amlogic_dai_dt_match[] = {
+static const struct of_device_id amlogic_pcm_dai_match[] = {
 	{.compatible = "amlogic, aml-pcm-dai",
 	 },
 	{},
 };
 #else
-#define amlogic_dai_dt_match NULL
+#define amlogic_pcm_dai_match NULL
 #endif
 
 static struct platform_driver aml_pcm_dai_driver = {
 	.driver = {
 		   .name = DEV_NAME,
 		   .owner = THIS_MODULE,
-		   .of_match_table = amlogic_dai_dt_match,
+		   .of_match_table = amlogic_pcm_dai_match,
 		   },
 
 	.probe = aml_pcm_dai_probe,
 	.remove = aml_pcm_dai_remove,
 };
 
-static int __init aml_dai_modinit(void)
+static int __init aml_pcm_dai_modinit(void)
 {
 	return platform_driver_register(&aml_pcm_dai_driver);
 }
 
-module_init(aml_dai_modinit);
+module_init(aml_pcm_dai_modinit);
 
-static void __exit aml_dai_modexit(void)
+static void __exit aml_pcm_dai_modexit(void)
 {
 	platform_driver_unregister(&aml_pcm_dai_driver);
 }
 
-module_exit(aml_dai_modexit);
+module_exit(aml_pcm_dai_modexit);
 
 /* Module information */
 MODULE_AUTHOR("AMLogic, Inc.");
diff --git a/sound/soc/aml/m8/aml_pcm_dai.h b/sound/soc/aml/m8/aml_pcm_dai.h
index 49abb41..fc1ac0a 100644
--- a/sound/soc/aml/m8/aml_pcm_dai.h
+++ b/sound/soc/aml/m8/aml_pcm_dai.h
@@ -17,6 +17,15 @@
 
 #ifndef AML_DAI_H
 #define AML_DAI_H
+
+struct aml_pcm {
+	struct clk *clk_mpll;
+	struct clk *clk_pcm_mclk;
+	struct clk *clk_pcm_sync;
+	int old_samplerate;
+	int pcm_mode;
+};
+
 void aml_hw_iec958_init(struct snd_pcm_substream *substream);
 extern struct snd_soc_dai_driver aml_dai[];
 
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index d88e872..3030af5 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -70,8 +70,9 @@ unsigned int clk81 = 0;
 EXPORT_SYMBOL(clk81);
 
 static int old_samplerate = -1;
+static int flag_samesrc = -1;
 
-void aml_spdif_play(void)
+void aml_spdif_play(int samesrc)
 {
 	if (is_meson_gxtvbb_cpu() == false) {
 		static int iec958buf[32 + 16];
@@ -92,11 +93,13 @@ void aml_spdif_play(void)
 		set.chan_stat->chstat1_l = 0X200;
 		set.chan_stat->chstat1_r = 0X200;
 		audio_hw_958_enable(0);
-		if (old_samplerate != AUDIO_CLK_FREQ_48) {
+		if (old_samplerate != AUDIO_CLK_FREQ_48
+				|| samesrc != flag_samesrc) {
 			pr_info("enterd %s,set_clock:%d,sample_rate=%d\n",
 			__func__, old_samplerate, AUDIO_CLK_FREQ_48);
 			old_samplerate = AUDIO_CLK_FREQ_48;
-			aml_set_spdif_clk(48000 * 512, 0);
+			flag_samesrc = samesrc;
+			aml_set_spdif_clk(48000 * 512, samesrc);
 		}
 		/* Todo, div can be changed, for most case, div = 2 */
 		/* audio_set_spdif_clk_div(); */
@@ -105,7 +108,7 @@ void aml_spdif_play(void)
 		IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
 			pr_info("set 4x audio clk for 958\n");
 			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-		} else if (0) {
+		} else if (samesrc) {
 			pr_info("share the same clock\n");
 			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
 		} else {
@@ -115,17 +118,12 @@ void aml_spdif_play(void)
 		/* enable 958 divider */
 		aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
 		audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+		/*clear the same source function as new raw data output */
+		audio_i2s_958_same_source(0);
 		memset(iec958buf, 0, sizeof(iec958buf));
 		audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63),
 					128, 0);
 		audio_set_958_mode(AIU_958_MODE_PCM16, &set);
-#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1
-		/* 512fs divide 4 == 128fs */
-		aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 4, 0x3 << 4);
-#else
-		/* 256fs divide 2 == 128fs */
-		aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 4, 0x1 << 4);
-#endif
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, &substream);
 		audio_hw_958_enable(1);
 	}
@@ -179,7 +177,7 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-void aml_hw_iec958_init(struct snd_pcm_substream *substream)
+void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 {
 	struct _aiu_958_raw_setting_t set;
 	struct _aiu_958_channel_status_t chstat;
@@ -243,14 +241,15 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 		break;
 	};
 	audio_hw_958_enable(0);
-	pr_info("aml_hw_iec958_init,runtime->rate=%d\n",
-	       runtime->rate);
-	/* int srate; */
-	/* srate = params_rate(params); */
-	if (old_samplerate != sample_rate) {
+	pr_info("aml_hw_iec958_init,runtime->rate=%d, same source mode(%d)\n",
+	       runtime->rate, samesrc);
+
+	if (old_samplerate != sample_rate || samesrc != flag_samesrc) {
 		old_samplerate = sample_rate;
-		aml_set_spdif_clk(runtime->rate * 512, 0);
+		flag_samesrc = samesrc;
+		aml_set_spdif_clk(runtime->rate * 512, samesrc);
 	}
+
 	/* Todo, div can be changed, for most case, div = 2 */
 	/* audio_set_spdif_clk_div(); */
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
@@ -258,7 +257,7 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
 		pr_info("set 4x audio clk for 958\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (0) {
+	} else if (samesrc) {
 		pr_info("share the same clock\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
 	} else {
@@ -323,12 +322,18 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 			pr_info("sample_rate==AUDIO_CLK_FREQ_882\n");
 			set.chan_stat->chstat1_l = 0x800;
 			set.chan_stat->chstat1_r = 0x800;
-		}
-
-		if (sample_rate == AUDIO_CLK_FREQ_96) {
+		} else if (sample_rate == AUDIO_CLK_FREQ_96) {
 			pr_info("sample_rate==AUDIO_CLK_FREQ_96\n");
 			set.chan_stat->chstat1_l = 0xa00;
 			set.chan_stat->chstat1_r = 0xa00;
+		} else if (sample_rate == AUDIO_CLK_FREQ_1764) {
+			pr_info("sample_rate==AUDIO_CLK_FREQ_1764\n");
+			set.chan_stat->chstat1_l = 0xc00;
+			set.chan_stat->chstat1_r = 0xc00;
+		} else if (sample_rate == AUDIO_CLK_FREQ_192) {
+			pr_info("sample_rate==AUDIO_CLK_FREQ_192\n");
+			set.chan_stat->chstat1_l = 0xe00;
+			set.chan_stat->chstat1_r = 0xe00;
 		}
 		start = buf->addr;
 		size = snd_pcm_lib_buffer_bytes(substream);
@@ -483,7 +488,7 @@ static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 	/* audio_stream_t *s = &prtd->s; */
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		aml_hw_iec958_init(substream);
+		aml_hw_iec958_init(substream, 0);
 	} else {
 		audio_in_spdif_set_buf(runtime->dma_addr,
 				       runtime->dma_bytes * 2);
@@ -699,7 +704,7 @@ static int aml_dai_spdif_probe(struct platform_device *pdev)
 	}
 	clk81 = clk_get_rate(spdif_priv->clk_81);
 
-	aml_spdif_play();
+	aml_spdif_play(0);
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_spdif_dai,
 					  ARRAY_SIZE(aml_spdif_dai));
diff --git a/sound/soc/aml/m8/aml_spdif_dai.h b/sound/soc/aml/m8/aml_spdif_dai.h
index fd11637..a098171 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.h
+++ b/sound/soc/aml/m8/aml_spdif_dai.h
@@ -45,7 +45,7 @@ extern unsigned int IEC958_mode_codec;
 * 3)PCM  output for audios except ac3/dts,
 * when raw output mode is selected by user
 */
-void aml_hw_iec958_init(struct snd_pcm_substream *substream);
+void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc);
 int aml_set_spdif_clk(unsigned long rate, bool src_i2s);
-void aml_spdif_play(void);
+void aml_spdif_play(int samesrc);
 #endif  /* _AML_SPDIF_DAI_H */
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 16af443..4e47e46 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -583,3 +583,6 @@ config SND_SOC_PCM2BT
 
 config SND_SOC_AMLT9015
 	tristate
+
+config SND_SOC_AMLT9015S
+	tristate
\ No newline at end of file
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 0ceeb62..a938765 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -128,6 +128,7 @@ snd-soc-dummy_codec-objs := dummy_codec.o
 snd-soc-pcm2bt-objs  := pcm2bt.o
 snd-soc-amlpmu4-objs := aml_pmu4_codec.o
 snd-soc-aml_t9015-objs := aml_codec_t9015.o
+snd-soc-aml_t9015S-objs := aml_codec_t9015S.o
 
 # Amp
 snd-soc-max9877-objs := max9877.o
@@ -265,6 +266,7 @@ obj-$(CONFIG_SND_SOC_DUMMY_CODEC)	+= snd-soc-dummy_codec.o
 obj-$(CONFIG_SND_SOC_PCM2BT)	+= snd-soc-pcm2bt.o
 obj-$(CONFIG_SND_SOC_AMLPMU4)	+= snd-soc-amlpmu4.o
 obj-$(CONFIG_SND_SOC_AMLT9015)	+= snd-soc-aml_t9015.o
+obj-$(CONFIG_SND_SOC_AMLT9015S)	+= snd-soc-aml_t9015S.o
 
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
diff --git a/sound/soc/codecs/aml_codec_t9015.c b/sound/soc/codecs/aml_codec_t9015.c
index 1a72593..490f5c2 100644
--- a/sound/soc/codecs/aml_codec_t9015.c
+++ b/sound/soc/codecs/aml_codec_t9015.c
@@ -21,7 +21,7 @@
 #include "aml_codec_t9015.h"
 
 static struct mutex acodec;
-void acodec_reg_write(unsigned data, unsigned addr)
+static void acodec_reg_write(unsigned data, unsigned addr)
 {
 	void __iomem *vaddr;
 	mutex_lock(&acodec);
@@ -31,7 +31,7 @@ void acodec_reg_write(unsigned data, unsigned addr)
 	mutex_unlock(&acodec);
 }
 
-unsigned acodec_reg_read(unsigned addr)
+static unsigned acodec_reg_read(unsigned addr)
 {
 	unsigned tmp;
 	void __iomem *vaddr;
@@ -411,12 +411,15 @@ static int aml_T9015_audio_remove(struct snd_soc_codec *codec)
 
 static int aml_T9015_audio_suspend(struct snd_soc_codec *codec)
 {
+	pr_info("aml_T9015_audio_suspend!\n");
 	aml_T9015_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0);
 	return 0;
 }
 
 static int aml_T9015_audio_resume(struct snd_soc_codec *codec)
 {
+	pr_info("aml_T9015_audio_resume!\n");
 	aml_T9015_audio_reset(codec);
 	aml_T9015_audio_start_up(codec);
 	aml_T9015_audio_reg_init(codec);
diff --git a/sound/soc/codecs/aml_codec_t9015S.c b/sound/soc/codecs/aml_codec_t9015S.c
new file mode 100644
index 0000000..c781245
--- /dev/null
+++ b/sound/soc/codecs/aml_codec_t9015S.c
@@ -0,0 +1,630 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/sound/aiu_regs.h>
+#include <linux/amlogic/sound/audin_regs.h>
+
+#include "aml_codec_t9015S.h"
+
+static struct mutex acodec;
+static void acodec_reg_write(unsigned data, unsigned addr)
+{
+	void __iomem *vaddr;
+	mutex_lock(&acodec);
+	vaddr = ioremap((addr), 0x4);
+	writel(data, vaddr);
+	iounmap(vaddr);
+	mutex_unlock(&acodec);
+}
+
+static unsigned acodec_reg_read(unsigned addr)
+{
+	unsigned tmp;
+	void __iomem *vaddr;
+	mutex_lock(&acodec);
+	vaddr = ioremap((addr), 0x4);
+	tmp = readl(vaddr);
+	iounmap(vaddr);
+	mutex_unlock(&acodec);
+	return tmp;
+}
+
+struct aml_T9015S_audio_priv {
+	struct snd_soc_codec *codec;
+	struct snd_pcm_hw_params *params;
+};
+
+struct T9015S_audio_init_reg {
+	u32 reg;
+	u32 val;
+};
+
+static struct T9015S_audio_init_reg init_list[] = {
+	{AUDIO_CONFIG_BLOCK_ENABLE, 0x3400Bc0F},
+	{ADC_VOL_CTR_PGA_IN_CONFIG, 0x50502929},
+	{DAC_VOL_CTR_DAC_SOFT_MUTE, 0xFBFB0000},
+	{LINE_OUT_CONFIG, 0x00004444},
+	{POWER_CONFIG, 0x00010000},
+};
+
+#define T9015S_AUDIO_INIT_REG_LEN ARRAY_SIZE(init_list)
+
+static int aml_T9015S_audio_reg_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for (i = 0; i < T9015S_AUDIO_INIT_REG_LEN; i++)
+		snd_soc_write(codec, init_list[i].reg, init_list[i].val);
+
+	return 0;
+}
+
+static unsigned int aml_T9015S_audio_read(struct snd_soc_codec *codec,
+				unsigned int reg)
+{
+	u32 val;
+	u32 int_reg = reg & (~0x3);
+	val = acodec_reg_read(ACODEC_BASE_ADD + int_reg);
+	return val;
+
+}
+
+static int aml_T9015S_audio_write(struct snd_soc_codec *codec, unsigned int reg,
+				unsigned int val)
+{
+	u32 int_reg = reg & (~0x3);
+	acodec_reg_write(val, (ACODEC_BASE_ADD + int_reg));
+	return 0;
+}
+
+static int aml_DAC_Gain_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	u32 add = ACODEC_BASE_ADD + ADC_VOL_CTR_PGA_IN_CONFIG;
+	u32 val = acodec_reg_read(add);
+	u32 val1 = (val & (0x1 <<  DAC_GAIN_SEL_L)) >> DAC_GAIN_SEL_L;
+	u32 val2 = (val & (0x1 <<  DAC_GAIN_SEL_H)) >> (DAC_GAIN_SEL_H - 1);
+	val = val1 | val2;
+	ucontrol->value.enumerated.item[0] = val;
+	return 0;
+}
+
+static int aml_DAC_Gain_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	u32 add = ACODEC_BASE_ADD + ADC_VOL_CTR_PGA_IN_CONFIG;
+	u32 val = acodec_reg_read(add);
+
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		val &= ~(0x1 << DAC_GAIN_SEL_H);
+		val &= ~(0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		val &= ~(0x1 << DAC_GAIN_SEL_H);
+		val |= (0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	} else if (ucontrol->value.enumerated.item[0] == 2) {
+		val |= (0x1 << DAC_GAIN_SEL_H);
+		val &= ~(0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	} else if (ucontrol->value.enumerated.item[0] == 3) {
+		val |= (0x1 << DAC_GAIN_SEL_H);
+		val |= (0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	}
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(pga_in_tlv, -1200, 250, 1);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -29625, 375, 1);
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -95250, 375, 1);
+
+static const char *const DAC_Gain_texts[] = { "0dB", "6dB", "12dB", "18dB" };
+
+static const struct soc_enum DAC_Gain_enum = SOC_ENUM_SINGLE(
+			SND_SOC_NOPM, 0, ARRAY_SIZE(DAC_Gain_texts),
+			DAC_Gain_texts);
+
+static const struct snd_kcontrol_new T9015S_audio_snd_controls[] = {
+	/*PGA_IN Gain */
+	SOC_DOUBLE_TLV("PGA IN Gain", ADC_VOL_CTR_PGA_IN_CONFIG,
+		       PGAL_IN_GAIN, PGAR_IN_GAIN,
+		       0x1f, 0, pga_in_tlv),
+
+	/*ADC Digital Volume control */
+	SOC_DOUBLE_TLV("ADC Digital Capture Volume", ADC_VOL_CTR_PGA_IN_CONFIG,
+		       ADCL_VC, ADCR_VC,
+		       0x7f, 0, adc_vol_tlv),
+
+	/*DAC Digital Volume control */
+	SOC_DOUBLE_TLV("DAC Digital Playback Volume",
+			   DAC_VOL_CTR_DAC_SOFT_MUTE,
+			   DACL_VC, DACR_VC,
+			   0xff, 0, dac_vol_tlv),
+
+    /*DAC extra Digital Gain control */
+	SOC_ENUM_EXT("DAC Extra Digital Gain",
+			   DAC_Gain_enum,
+			   aml_DAC_Gain_get_enum,
+			   aml_DAC_Gain_set_enum),
+
+};
+
+/*pgain Left Channel Input */
+static const char * const T9015S_pgain_left_txt[] = {
+	"None", "AIL1", "AIL2", "AIL3", "AIL4"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_pgain_left_enum,
+				  ADC_VOL_CTR_PGA_IN_CONFIG   ,
+				  PGAL_IN_SEL, T9015S_pgain_left_txt);
+
+static const struct snd_kcontrol_new pgain_ln_mux =
+SOC_DAPM_ENUM("ROUTE_L", T9015S_pgain_left_enum);
+
+/*pgain right Channel Input */
+static const char * const T9015S_pgain_right_txt[] = {
+	"None", "AIR1", "AIR2", "AIR3", "AIR4"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_pgain_right_enum,
+				  ADC_VOL_CTR_PGA_IN_CONFIG   ,
+				  PGAR_IN_SEL, T9015S_pgain_right_txt);
+
+static const struct snd_kcontrol_new pgain_rn_mux =
+SOC_DAPM_ENUM("ROUTE_R", T9015S_pgain_right_enum);
+
+/*line out Left Positive mux */
+static const char * const T9015S_out_lp_txt[] = {
+	"None", "LOLP_SEL_AIL_INV", "LOLP_SEL_AIL", "Reserved", "LOLP_SEL_DACL"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_out_lp_enum, LINE_OUT_CONFIG,
+				  LOLP_SEL_AIL_INV, T9015S_out_lp_txt);
+
+static const struct snd_kcontrol_new line_out_lp_mux =
+SOC_DAPM_ENUM("ROUTE_LP_OUT", T9015S_out_lp_enum);
+
+/*line out Left Negative mux */
+static const char * const T9015S_out_ln_txt[] = {
+	"None", "LOLN_SEL_AIL", "LOLN_SEL_DACL", "Reserved", "LOLN_SEL_DACL_INV"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_out_ln_enum, LINE_OUT_CONFIG,
+				  LOLN_SEL_AIL, T9015S_out_ln_txt);
+
+static const struct snd_kcontrol_new line_out_ln_mux =
+SOC_DAPM_ENUM("ROUTE_LN_OUT", T9015S_out_ln_enum);
+
+/*line out Right Positive mux */
+static const char * const T9015S_out_rp_txt[] = {
+	"None", "LORP_SEL_AIR_INV", "LORP_SEL_AIR", "Reserved", "LORP_SEL_DACR"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_out_rp_enum, LINE_OUT_CONFIG,
+				  LORP_SEL_AIR_INV, T9015S_out_rp_txt);
+
+static const struct snd_kcontrol_new line_out_rp_mux =
+SOC_DAPM_ENUM("ROUTE_RP_OUT", T9015S_out_rp_enum);
+
+/*line out Right Negative mux */
+static const char * const T9015S_out_rn_txt[] = {
+	"None", "LORN_SEL_AIR", "LORN_SEL_DACR", "Reserved", "LORN_SEL_DACR_INV"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_out_rn_enum, LINE_OUT_CONFIG,
+				  LORN_SEL_AIR, T9015S_out_rn_txt);
+
+static const struct snd_kcontrol_new line_out_rn_mux =
+SOC_DAPM_ENUM("ROUTE_RN_OUT", T9015S_out_rn_enum);
+
+static const struct snd_soc_dapm_widget T9015S_audio_dapm_widgets[] = {
+
+	/* Input */
+	SND_SOC_DAPM_INPUT("Linein left 1"),
+	SND_SOC_DAPM_INPUT("Linein left 2"),
+	SND_SOC_DAPM_INPUT("Linein left 3"),
+	SND_SOC_DAPM_INPUT("Linein left 4"),
+
+	SND_SOC_DAPM_INPUT("Linein right 1"),
+	SND_SOC_DAPM_INPUT("Linein right 2"),
+	SND_SOC_DAPM_INPUT("Linein right 3"),
+	SND_SOC_DAPM_INPUT("Linein right 4"),
+
+	/*PGA input */
+	SND_SOC_DAPM_PGA("PGAL_IN_EN", AUDIO_CONFIG_BLOCK_ENABLE,
+			 PGAL_IN_EN, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("PGAR_IN_EN", AUDIO_CONFIG_BLOCK_ENABLE,
+			 PGAL_IN_EN, 0, NULL, 0),
+
+	/*PGA input source select */
+	SND_SOC_DAPM_MUX("Linein left switch", SND_SOC_NOPM,
+			 0, 0, &pgain_ln_mux),
+	SND_SOC_DAPM_MUX("Linein right switch", SND_SOC_NOPM,
+			 0, 0, &pgain_rn_mux),
+
+	/*ADC capture stream */
+	SND_SOC_DAPM_ADC("Left ADC", "HIFI Capture", AUDIO_CONFIG_BLOCK_ENABLE,
+			 ADCL_EN, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "HIFI Capture", AUDIO_CONFIG_BLOCK_ENABLE,
+			 ADCR_EN, 0),
+
+	/*Output */
+	SND_SOC_DAPM_OUTPUT("Lineout left N"),
+	SND_SOC_DAPM_OUTPUT("Lineout left P"),
+	SND_SOC_DAPM_OUTPUT("Lineout right N"),
+	SND_SOC_DAPM_OUTPUT("Lineout right P"),
+
+	/*DAC playback stream */
+	SND_SOC_DAPM_DAC("Left DAC", "HIFI Playback",
+			 AUDIO_CONFIG_BLOCK_ENABLE,
+			 DACL_EN, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "HIFI Playback",
+			 AUDIO_CONFIG_BLOCK_ENABLE,
+			 DACR_EN, 0),
+
+	/*DRV output */
+	SND_SOC_DAPM_OUT_DRV("LOLP_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LOLN_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LORP_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LORN_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+
+	/*MUX output source select */
+	SND_SOC_DAPM_MUX("Lineout left P switch", SND_SOC_NOPM,
+			 0, 0, &line_out_lp_mux),
+	SND_SOC_DAPM_MUX("Lineout left N switch", SND_SOC_NOPM,
+			 0, 0, &line_out_ln_mux),
+	SND_SOC_DAPM_MUX("Lineout right P switch", SND_SOC_NOPM,
+			 0, 0, &line_out_rp_mux),
+	SND_SOC_DAPM_MUX("Lineout right N switch", SND_SOC_NOPM,
+			 0, 0, &line_out_rn_mux),
+};
+
+static const struct snd_soc_dapm_route T9015S_audio_dapm_routes[] = {
+/* Input path */
+	{"Linein left switch", "AIL1", "Linein left 1"},
+	{"Linein left switch", "AIL2", "Linein left 2"},
+	{"Linein left switch", "AIL3", "Linein left 3"},
+	{"Linein left switch", "AIL4", "Linein left 4"},
+
+	{"Linein right switch", "AIR1", "Linein right 1"},
+	{"Linein right switch", "AIR2", "Linein right 2"},
+	{"Linein right switch", "AIR3", "Linein right 3"},
+	{"Linein right switch", "AIR4", "Linein right 4"},
+
+	{"PGAL_IN_EN", NULL, "Linein left switch"},
+	{"PGAR_IN_EN", NULL, "Linein right switch"},
+
+	{"Left ADC", NULL, "PGAL_IN_EN"},
+	{"Right ADC", NULL, "PGAR_IN_EN"},
+
+/*Output path*/
+	{"Lineout left P switch", "LOLP_SEL_DACL", "Left DAC"},
+	{"Lineout left P switch", "LOLP_SEL_AIL", "PGAL_IN_EN"},
+	{"Lineout left P switch", "LOLP_SEL_AIL_INV", "PGAL_IN_EN"},
+
+	{"Lineout left N switch", "LOLN_SEL_AIL", "PGAL_IN_EN"},
+	{"Lineout left N switch", "LOLN_SEL_DACL", "Left DAC"},
+	{"Lineout left N switch", "LOLN_SEL_DACL_INV", "Left DAC"},
+
+	{"Lineout right P switch", "LORP_SEL_DACR", "Right DAC"},
+	{"Lineout right P switch", "LORP_SEL_AIR", "PGAR_IN_EN"},
+	{"Lineout right P switch", "LORP_SEL_AIR_INV", "PGAR_IN_EN"},
+
+	{"Lineout right N switch", "LORN_SEL_AIR", "PGAR_IN_EN"},
+	{"Lineout right N switch", "LORN_SEL_DACR", "Right DAC"},
+	{"Lineout right N switch", "LORN_SEL_DACR_INV", "Right DAC"},
+
+	{"LOLN_OUT_EN", NULL, "Lineout left N switch"},
+	{"LOLP_OUT_EN", NULL, "Lineout left P switch"},
+	{"LORN_OUT_EN", NULL, "Lineout right N switch"},
+	{"LORP_OUT_EN", NULL, "Lineout right P switch"},
+
+	{"Lineout left N", NULL, "LOLN_OUT_EN"},
+	{"Lineout left P", NULL, "LOLP_OUT_EN"},
+	{"Lineout right N", NULL, "LORN_OUT_EN"},
+	{"Lineout right P", NULL, "LORP_OUT_EN"},
+};
+
+static int aml_T9015S_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		snd_soc_update_bits(codec, AUDIO_CONFIG_BLOCK_ENABLE,
+					I2S_MODE, 1);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		snd_soc_update_bits(codec, AUDIO_CONFIG_BLOCK_ENABLE,
+					I2S_MODE, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aml_T9015S_set_dai_sysclk(struct snd_soc_dai *dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int aml_T9015S_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct aml_T9015S_audio_priv *T9015S_audio =
+	    snd_soc_codec_get_drvdata(codec);
+
+	T9015S_audio->params = params;
+
+	return 0;
+}
+
+static int aml_T9015S_audio_set_bias_level(struct snd_soc_codec *codec,
+					 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (SND_SOC_BIAS_OFF == codec->dapm.bias_level) {
+			codec->cache_only = false;
+			codec->cache_sync = 1;
+			snd_soc_cache_sync(codec);
+		}
+		break;
+
+	case SND_SOC_BIAS_OFF:
+
+		break;
+
+	default:
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+static int aml_T9015S_prepare(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	/*struct snd_soc_codec *codec = dai->codec;*/
+	return 0;
+
+}
+
+static int aml_T9015S_audio_reset(struct snd_soc_codec *codec)
+{
+	aml_cbus_update_bits(RESET1_REGISTER, (1 << ACODEC_RESET),
+					(1 << ACODEC_RESET));
+	udelay(1000);
+	return 0;
+}
+
+static int aml_T9015S_audio_start_up(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0xF000);
+	msleep(200);
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0xB000);
+	return 0;
+}
+
+static int aml_T9015S_codec_mute_stream(struct snd_soc_dai *dai, int mute,
+				      int stream)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u32 reg;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		reg = snd_soc_read(codec, DAC_VOL_CTR_DAC_SOFT_MUTE);
+		if (mute)
+			reg |= 0x1 << DAC_SOFT_MUTE;
+		else
+			reg &= ~(0x1 << DAC_SOFT_MUTE);
+
+		snd_soc_write(codec, DAC_VOL_CTR_DAC_SOFT_MUTE, reg);
+	}
+	return 0;
+}
+
+static int aml_T9015S_audio_probe(struct snd_soc_codec *codec)
+{
+	struct aml_T9015S_audio_priv *T9015S_audio = NULL;
+
+	T9015S_audio = kzalloc(sizeof(struct aml_T9015S_audio_priv),
+		GFP_KERNEL);
+	if (NULL == T9015S_audio)
+		return -ENOMEM;
+	snd_soc_codec_set_drvdata(codec, T9015S_audio);
+
+	/*reset audio codec register*/
+	aml_T9015S_audio_reset(codec);
+	aml_T9015S_audio_start_up(codec);
+	aml_T9015S_audio_reg_init(codec);
+
+	aml_write_cbus(AIU_ACODEC_CTRL, (1 << 4)
+			   |(1 << 6)
+			   |(1 << 11)
+			   |(1 << 15)
+			   |(2 << 2)
+	);
+
+	aml_write_cbus(AUDIN_SOURCE_SEL, 3);
+	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+	T9015S_audio->codec = codec;
+
+	return 0;
+}
+
+static int aml_T9015S_audio_remove(struct snd_soc_codec *codec)
+{
+	aml_T9015S_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int aml_T9015S_audio_suspend(struct snd_soc_codec *codec)
+{
+	pr_info("aml_T9015S_audio_suspend!\n");
+	aml_T9015S_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0);
+	return 0;
+}
+
+static int aml_T9015S_audio_resume(struct snd_soc_codec *codec)
+{
+	pr_info("aml_T9015S_audio_resume!\n");
+	aml_T9015S_audio_reset(codec);
+	aml_T9015S_audio_start_up(codec);
+	aml_T9015S_audio_reg_init(codec);
+	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+	aml_T9015S_audio_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+
+#define T9015S_AUDIO_STEREO_RATES SNDRV_PCM_RATE_8000_96000
+#define T9015S_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE \
+			| SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE \
+			| SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S32_LE)
+
+struct snd_soc_dai_ops T9015S_audio_aif_dai_ops = {
+	.hw_params = aml_T9015S_hw_params,
+	.prepare = aml_T9015S_prepare,
+	.set_fmt = aml_T9015S_set_dai_fmt,
+	.set_sysclk = aml_T9015S_set_dai_sysclk,
+	.mute_stream = aml_T9015S_codec_mute_stream,
+};
+
+struct snd_soc_dai_driver aml_T9015S_audio_dai[] = {
+	{
+	 .name = "T9015S-audio-hifi",
+	 .id = 0,
+	 .playback = {
+		      .stream_name = "HIFI Playback",
+		      .channels_min = 2,
+		      .channels_max = 8,
+		      .rates = T9015S_AUDIO_STEREO_RATES,
+		      .formats = T9015S_AUDIO_FORMATS,
+		      },
+	 .capture = {
+		     .stream_name = "HIFI Capture",
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = T9015S_AUDIO_STEREO_RATES,
+		     .formats = T9015S_AUDIO_FORMATS,
+		     },
+	 .ops = &T9015S_audio_aif_dai_ops,
+	 },
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_aml_T9015S_audio = {
+	.probe = aml_T9015S_audio_probe,
+	.remove = aml_T9015S_audio_remove,
+	.suspend = aml_T9015S_audio_suspend,
+	.resume = aml_T9015S_audio_resume,
+	.read = aml_T9015S_audio_read,
+	.write = aml_T9015S_audio_write,
+	.set_bias_level = aml_T9015S_audio_set_bias_level,
+	.controls = T9015S_audio_snd_controls,
+	.num_controls = ARRAY_SIZE(T9015S_audio_snd_controls),
+	.dapm_widgets = T9015S_audio_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(T9015S_audio_dapm_widgets),
+	.dapm_routes = T9015S_audio_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(T9015S_audio_dapm_routes),
+	.reg_cache_size = 16,
+	.reg_word_size = sizeof(u16),
+	.reg_cache_step = 2,
+};
+
+static int aml_T9015S_audio_codec_probe(struct platform_device *pdev)
+{
+	int ret;
+	dev_info(&pdev->dev, "aml_T9015S_audio_codec_probe\n");
+	mutex_init(&acodec);
+	ret = snd_soc_register_codec(&pdev->dev,
+				     &soc_codec_dev_aml_T9015S_audio,
+				     &aml_T9015S_audio_dai[0], 1);
+	return ret;
+}
+
+static int aml_T9015S_audio_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static const struct of_device_id aml_T9015S_codec_dt_match[] = {
+	{.compatible = "amlogic, aml_codec_T9015S",},
+	{},
+};
+
+static struct platform_driver aml_T9015S_codec_platform_driver = {
+	.driver = {
+		   .name = "aml_codec_T9015S",
+		   .owner = THIS_MODULE,
+		   .of_match_table = aml_T9015S_codec_dt_match,
+		   },
+	.probe = aml_T9015S_audio_codec_probe,
+	.remove = aml_T9015S_audio_codec_remove,
+};
+
+static int __init aml_T9015S_audio_modinit(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&aml_T9015S_codec_platform_driver);
+	if (ret != 0) {
+		pr_err(
+			"Failed to register AML T9015S codec platform driver: %d\n",
+			ret);
+	}
+
+	return ret;
+}
+
+module_init(aml_T9015S_audio_modinit);
+
+static void __exit aml_T9015S_audio_exit(void)
+{
+	platform_driver_unregister(&aml_T9015S_codec_platform_driver);
+}
+
+module_exit(aml_T9015S_audio_exit);
+
+MODULE_DESCRIPTION("ASoC AML T9015S audio codec driver");
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/aml_codec_t9015S.h b/sound/soc/codecs/aml_codec_t9015S.h
new file mode 100644
index 0000000..1659b48
--- /dev/null
+++ b/sound/soc/codecs/aml_codec_t9015S.h
@@ -0,0 +1,79 @@
+#ifndef AML_T9015S_H_
+#define AML_T9015S_H_
+
+#define ACODEC_BASE_ADD    0xc8832000
+#define ACODEC_TOP_ADDR(x) (x)
+
+#define AUDIO_CONFIG_BLOCK_ENABLE       ACODEC_TOP_ADDR(0x00)
+#define MCLK_FREQ                   0x1F
+#define I2S_MODE                    0x1E
+#define ADC_HPF_EN                  0x1D
+#define ADC_HPF_MODE                0x1C
+#define ADC_OVERLOAD_DET_EN         0x1B
+#define ADC_DEM_EN                  0x1A
+#define ADC_CLK_TO_GPIO_EN          0x19
+#define DAC_CLK_TO_GPIO_EN          0x18
+#define DACL_DATA_SOURCE            0x17
+#define DACR_DATA_SOURCE            0x16
+#define DACL_INV                    0x15
+#define DACR_INV                    0x14
+#define ADCDATL_SOURCE              0x13
+#define ADCDATR_SOURCE              0x12
+#define ADCL_INV                    0x11
+#define ADCR_INV                    0x10
+#define VMID_GEN_EN                 0x0F
+#define VMID_GEN_FAST               0x0E
+#define BIAS_CURRENT_EN             0x0D
+#define REFP_BUF_EN                 0x0C
+#define PGAL_IN_EN                  0x0B
+#define PGAR_IN_EN                  0x0A
+#define PGAL_IN_ZC_EN               0x09
+#define PGAR_IN_ZC_EN               0x08
+#define ADCL_EN                     0x07
+#define ADCR_EN                     0x06
+#define DACL_EN                     0x05
+#define DACR_EN                     0x04
+#define LOLP_EN                     0x03
+#define LOLN_EN                     0x02
+#define LORP_EN                     0x01
+#define LORN_EN                     0x00
+
+#define ADC_VOL_CTR_PGA_IN_CONFIG       ACODEC_TOP_ADDR(0x04)
+#define DAC_GAIN_SEL_H              0x1F
+#define ADCL_VC                     0x18
+#define DAC_GAIN_SEL_L              0x17
+#define ADCR_VC                     0x10
+#define PGAL_IN_SEL                 0x0D
+#define PGAL_IN_GAIN                0x08
+#define PGAR_IN_SEL                 0x05
+#define PGAR_IN_GAIN                0x00
+
+#define DAC_VOL_CTR_DAC_SOFT_MUTE       ACODEC_TOP_ADDR(0x08)
+#define DACL_VC                     0x18
+#define DACR_VC                     0x10
+#define DAC_SOFT_MUTE               0x0F
+#define DAC_UNMUTE_MODE             0x0E
+#define DAC_MUTE_MODE               0x0D
+#define DAC_VC_RAMP_MODE            0x0C
+#define DAC_RAMP_RATE               0x0A
+#define DAC_MONO                    0x08
+
+#define LINE_OUT_CONFIG                 ACODEC_TOP_ADDR(0x0c)
+#define LOLP_SEL_DACL               0x0E
+#define LOLP_SEL_AIL                0x0D
+#define LOLP_SEL_AIL_INV            0x0C
+#define LOLN_SEL_DACL_INV           0x0A
+#define LOLN_SEL_DACL               0x09
+#define LOLN_SEL_AIL                0x08
+#define LORP_SEL_DACR               0x06
+#define LORP_SEL_AIR                0x05
+#define LORP_SEL_AIR_INV            0x04
+#define LORN_SEL_DACR_INV           0x02
+#define LORN_SEL_DACR               0x01
+#define LORN_SEL_AIR                0x00
+
+#define POWER_CONFIG                    ACODEC_TOP_ADDR(0x10)
+#define MUTE_DAC_PD_EN              0x1F
+#define IB_CON                      0x10
+
+#endif
diff --git a/sound/soc/codecs/aml_pmu4_codec.c b/sound/soc/codecs/aml_pmu4_codec.c
index 845efee..69de6cf 100644
--- a/sound/soc/codecs/aml_pmu4_codec.c
+++ b/sound/soc/codecs/aml_pmu4_codec.c
@@ -38,7 +38,7 @@ struct pmu4_audio_init_reg {
 #define AML1220_PMU_CTR_04 0x05
 
 static struct pmu4_audio_init_reg init_list[] = {
-	{PMU4_BLOCK_ENABLE, 0xBc06},
+	{PMU4_BLOCK_ENABLE, 0xBCF6},
 	{PMU4_AUDIO_CONFIG, 0x3400},
 	{PMU4_PGA_IN_CONFIG, 0x2929},
 	{PMU4_ADC_VOL_CTR, 0x5050},
