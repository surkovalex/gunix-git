diff --git a/bt/Android.mk b/bt/Android.mk
index 6a77074..677d63e 100644
--- a/bt/Android.mk
+++ b/bt/Android.mk
@@ -18,6 +18,10 @@ ifneq ($(TARGET_BUILD_VARIANT),user)
 bdroid_CFLAGS += -DBLUEDROID_DEBUG
 endif
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_QCOM),true)
+bdroid_CFLAGS += -DCONFIG_QCA9377
+endif
+
 bdroid_CFLAGS += \
   -Wall \
   -Wno-unused-parameter \
diff --git a/bt/audio_a2dp_hw/audio_a2dp_hw.c b/bt/audio_a2dp_hw/audio_a2dp_hw.c
index d0b36a0..4e58b3f 100644
--- a/bt/audio_a2dp_hw/audio_a2dp_hw.c
+++ b/bt/audio_a2dp_hw/audio_a2dp_hw.c
@@ -242,7 +242,7 @@ static int skt_read(int fd, void *p, size_t len)
 
     ts_log("skt_read recv", len, NULL);
 
-    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)
+    if ((read = TEMP_FAILURE_RETRY(recv(fd, p, len, MSG_NOSIGNAL))) == -1)
     {
         ERROR("write failed with errno=%d\n", errno);
         return -1;
@@ -264,12 +264,12 @@ static int skt_write(int fd, const void *p, size_t len)
     /* poll for 500 ms */
 
     /* send time out */
-    if (poll(&pfd, 1, 500) == 0)
+    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 500)) == 0)
         return 0;
 
     ts_log("skt_write", len, NULL);
 
-    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
+    if ((sent = TEMP_FAILURE_RETRY(send(fd, p, len, MSG_NOSIGNAL))) == -1)
     {
         ERROR("write failed with errno=%d\n", errno);
         return -1;
@@ -300,14 +300,14 @@ static int skt_disconnect(int fd)
 
 static int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)
 {
-    int ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
+    int ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));
     if (ret < 0)
     {
         ERROR("ack failed (%s)", strerror(errno));
         if (errno == EINTR)
         {
             /* retry again */
-            ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
+            ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));
             if (ret < 0)
             {
                ERROR("ack failed (%s)", strerror(errno));
@@ -334,7 +334,7 @@ static int a2dp_command(struct a2dp_stream_common *common, char cmd)
     DEBUG("A2DP COMMAND %s", dump_a2dp_ctrl_event(cmd));
 
     /* send command */
-    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)
+    if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1)
     {
         ERROR("cmd failed (%s)", strerror(errno));
         skt_disconnect(common->ctrl_fd);
@@ -407,13 +407,13 @@ static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)
                 break;
 
             ERROR("error : a2dp not ready, wait 250 ms and retry");
-            usleep(250000);
+            TEMP_FAILURE_RETRY(usleep(250000));
             skt_disconnect(common->ctrl_fd);
             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
         }
 
         /* ctrl channel not ready, wait a bit */
-        usleep(250000);
+        TEMP_FAILURE_RETRY(usleep(250000));
     }
 }
 
@@ -576,7 +576,7 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
 
             DEBUG("emulate a2dp write delay (%d us)", us_delay);
 
-            usleep(us_delay);
+            TEMP_FAILURE_RETRY(usleep(us_delay));
             pthread_mutex_unlock(&out->common.lock);
             return -1;
         }
@@ -950,7 +950,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
 
             DEBUG("emulate a2dp read delay (%d us)", us_delay);
 
-            usleep(us_delay);
+            TEMP_FAILURE_RETRY(usleep(us_delay));
             pthread_mutex_unlock(&in->common.lock);
             return -1;
         }
@@ -1077,7 +1077,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     DEBUG("success");
     /* Delay to ensure Headset is in proper state when START is initiated
        from DUT immediately after the connection due to ongoing music playback. */
-    usleep(250000);
+    TEMP_FAILURE_RETRY(usleep(250000));
     return 0;
 
 err_open:
diff --git a/bt/btif/co/bta_hh_co.c b/bt/btif/co/bta_hh_co.c
index 31dfde1..e7ec4f8 100644
--- a/bt/btif/co/bta_hh_co.c
+++ b/bt/btif/co/bta_hh_co.c
@@ -46,8 +46,8 @@ static tBTA_HH_RPT_CACHE_ENTRY sReportCache[BTA_HH_NV_LOAD_MAX];
 /*Internal function to perform UHID write and error checking*/
 static int uhid_write(int fd, const struct uhid_event *ev)
 {
-    ssize_t ret;
-    ret = write(fd, ev, sizeof(*ev));
+    ssize_t ret = TEMP_FAILURE_RETRY(write(fd, ev, sizeof(*ev)));
+
     if (ret < 0){
         int rtn = -errno;
         APPL_TRACE_ERROR("%s: Cannot write to uhid:%s",
@@ -73,7 +73,7 @@ static int uhid_event(btif_hh_device_t *p_dev)
         APPL_TRACE_ERROR("%s: Device not found",__FUNCTION__)
         return -1;
     }
-    ret = read(p_dev->fd, &ev, sizeof(ev));
+    ret = TEMP_FAILURE_RETRY(read(p_dev->fd, &ev, sizeof(ev)));
     if (ret == 0) {
         APPL_TRACE_ERROR("%s: Read HUP on uhid-cdev %s", __FUNCTION__,
                                                  strerror(errno));
@@ -184,7 +184,7 @@ static void *btif_hh_poll_event_thread(void *arg)
     pfds[0].events = POLLIN;
 
     while(p_dev->hh_keep_polling){
-        ret = poll(pfds, 1, 50);
+        ret = TEMP_FAILURE_RETRY(poll(pfds, 1, 50));
         if (ret < 0) {
             APPL_TRACE_ERROR("%s: Cannot poll for fds: %s\n", __FUNCTION__, strerror(errno));
             break;
@@ -276,7 +276,7 @@ void bta_hh_co_open(UINT8 dev_handle, UINT8 sub_class, tBTA_HH_ATTR_MASK attr_ma
                                   __FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);
 
             if(p_dev->fd<0) {
-                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);
+                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));
                 if (p_dev->fd < 0){
                     APPL_TRACE_ERROR("%s: Error: failed to open uhid, err:%s",
                                                                     __FUNCTION__,strerror(errno));
@@ -303,7 +303,7 @@ void bta_hh_co_open(UINT8 dev_handle, UINT8 sub_class, tBTA_HH_ATTR_MASK attr_ma
 
                 btif_hh_cb.device_num++;
                 // This is a new device,open the uhid driver now.
-                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);
+                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));
                 if (p_dev->fd < 0){
                     APPL_TRACE_ERROR("%s: Error: failed to open uhid, err:%s",
                                                                     __FUNCTION__,strerror(errno));
diff --git a/bt/btif/co/bta_hl_co.c b/bt/btif/co/bta_hl_co.c
index 9aa91f7..f133145 100644
--- a/bt/btif/co/bta_hl_co.c
+++ b/bt/btif/co/bta_hl_co.c
@@ -34,6 +34,7 @@
 #include <fcntl.h>
 #include <ctype.h>
 #include <cutils/sockets.h>
+#include <unistd.h>
 #include "bta_api.h"
 #include "btm_api.h"
 #include "bta_sys.h"
@@ -384,7 +385,7 @@ void bta_hl_co_put_rx_data (UINT8 app_id, tBTA_HL_MDL_HANDLE mdl_handle,
             {
                 BTIF_TRACE_DEBUG("app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d",
                                   app_idx, mcl_idx, mdl_idx, data_size);
-                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);
+                r = TEMP_FAILURE_RETRY(send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0));
 
                 if (r == data_size)
                 {
diff --git a/bt/btif/include/btif_api.h b/bt/btif/include/btif_api.h
index 62687d3..6bb1d39 100644
--- a/bt/btif/include/btif_api.h
+++ b/bt/btif/include/btif_api.h
@@ -87,6 +87,23 @@ bt_status_t btif_shutdown_bluetooth(void);
 
 /*******************************************************************************
 **
+** Function         is_restricted_mode
+**
+** Description      Checks if BT was enabled in restriced mode. In restricted
+**                  mode, bonds that are created are marked as temporary.
+**                  These bonds persist until we leave restricted mode, at
+**                  which point they will be deleted from the config. Also
+**                  while in restricted mode, the user can access devices
+**                  that are already paired before entering restricted mode,
+**                  but they cannot remove any of these devices.
+**
+** Returns          bool
+**
+*******************************************************************************/
+bool is_restricted_mode(void);
+
+/*******************************************************************************
+**
 ** Function         btif_get_adapter_properties
 **
 ** Description      Fetches all local adapter properties
diff --git a/bt/btif/include/btif_storage.h b/bt/btif/include/btif_storage.h
index 7763d3a..26384e1 100644
--- a/bt/btif/include/btif_storage.h
+++ b/bt/btif/include/btif_storage.h
@@ -309,6 +309,18 @@ bt_status_t btif_storage_add_device_to_autopair_blacklist(bt_bdaddr_t *remote_bd
 *******************************************************************************/
 BOOLEAN btif_storage_is_fixed_pin_zeros_keyboard(bt_bdaddr_t *remote_bd_addr);
 
+/*******************************************************************************
+**
+** Function         btif_storage_is_retricted_device
+**
+** Description      BTIF storage API - checks if this device is a restricted device
+**
+** Returns          TRUE  if the device is labled as restricted
+**                  FALSE otherwise
+**
+*******************************************************************************/
+BOOLEAN btif_storage_is_restricted_device(const bt_bdaddr_t *remote_bd_addr);
+
 #if (BLE_INCLUDED == TRUE)
 bt_status_t btif_storage_add_ble_bonding_key( bt_bdaddr_t *remote_bd_addr,
                                               char *key,
diff --git a/bt/btif/src/bluetooth.c b/bt/btif/src/bluetooth.c
index 3213221..5ee48d3 100644
--- a/bt/btif/src/bluetooth.c
+++ b/bt/btif/src/bluetooth.c
@@ -55,6 +55,7 @@
 #include "osi/include/log.h"
 #include "stack_manager.h"
 #include "btif_config.h"
+#include "btif_storage.h"
 
 /************************************************************************************
 **  Constants & Macros
@@ -67,6 +68,7 @@
 ************************************************************************************/
 
 bt_callbacks_t *bt_hal_cbacks = NULL;
+bool restricted_mode = FALSE;
 
 /** Operating System specific callouts for resource management */
 bt_os_callouts_t *bt_os_callouts = NULL;
@@ -135,8 +137,10 @@ static int init(bt_callbacks_t *callbacks) {
   return BT_STATUS_SUCCESS;
 }
 
-static int enable(void) {
-  LOG_INFO("%s", __func__);
+static int enable(bool start_restricted) {
+  LOG_INFO(LOG_TAG, "%s: start restricted = %d", __func__, start_restricted);
+
+  restricted_mode = start_restricted;
 
   if (!interface_ready())
     return BT_STATUS_NOT_READY;
@@ -157,6 +161,10 @@ static void cleanup(void) {
   stack_manager_get_interface()->clean_up_stack_async();
 }
 
+bool is_restricted_mode() {
+  return restricted_mode;
+}
+
 static int get_adapter_properties(void)
 {
     /* sanity check */
@@ -267,6 +275,9 @@ static int cancel_bond(const bt_bdaddr_t *bd_addr)
 
 static int remove_bond(const bt_bdaddr_t *bd_addr)
 {
+    if (is_restricted_mode() && !btif_storage_is_restricted_device(bd_addr))
+        return BT_STATUS_SUCCESS;
+
     /* sanity check */
     if (interface_ready() == FALSE)
         return BT_STATUS_NOT_READY;
diff --git a/bt/btif/src/btif_config.c b/bt/btif/src/btif_config.c
index ad5b607..bae39d2 100644
--- a/bt/btif/src/btif_config.c
+++ b/bt/btif/src/btif_config.c
@@ -27,6 +27,7 @@
 #include "osi/include/alarm.h"
 #include "osi/include/allocator.h"
 #include "btcore/include/bdaddr.h"
+#include "btif_api.h"
 #include "btif_config.h"
 #include "btif_config_transcode.h"
 #include "btif_util.h"
@@ -45,6 +46,7 @@ static const period_ms_t CONFIG_SETTLE_PERIOD_MS = 3000;
 static void timer_config_save_cb(void *data);
 static void btif_config_write(void);
 static void btif_config_remove_unpaired(config_t *config);
+static void btif_config_remove_restricted(config_t *config);
 
 // TODO(zachoverflow): Move these two functions out, because they are too specific for this file
 // {grumpy-cat/no, monty-python/you-make-me-sad}
@@ -111,6 +113,10 @@ static future_t *init(void) {
 
   btif_config_remove_unpaired(config);
 
+  // Cleanup temporary pairings if we have left guest mode
+  if (!is_restricted_mode())
+    btif_config_remove_restricted(config);
+
   // TODO(sharvil): use a non-wake alarm for this once we have
   // API support for it. There's no need to wake the system to
   // write back to disk.
@@ -421,3 +427,19 @@ static void btif_config_remove_unpaired(config_t *conf) {
     snode = config_section_next(snode);
   }
 }
+
+static void btif_config_remove_restricted(config_t* config) {
+  assert(config != NULL);
+
+  pthread_mutex_lock(&lock);
+  const config_section_node_t *snode = config_section_begin(config);
+  while (snode != config_section_end(config)) {
+    const char *section = config_section_name(snode);
+    if (string_is_bdaddr(section) && config_has_key(config, section, "Restricted")) {
+        BTIF_TRACE_DEBUG("%s: Removing restricted device %s", __func__, section);
+        config_remove_section(config, section);
+    }
+    snode = config_section_next(snode);
+  }
+  pthread_mutex_unlock(&lock);
+}
diff --git a/bt/btif/src/btif_core.c b/bt/btif/src/btif_core.c
index d552e5c..bbd75ee 100644
--- a/bt/btif/src/btif_core.c
+++ b/bt/btif/src/btif_core.c
@@ -29,6 +29,7 @@
 #include <ctype.h>
 #include <cutils/properties.h>
 #include <dirent.h>
+#include <errno.h>
 #include <fcntl.h>
 #include <hardware/bluetooth.h>
 #include <stdlib.h>
@@ -330,10 +331,10 @@ static void btif_fetch_local_bdaddr(bt_bdaddr_t *local_addr)
 
         BTIF_TRACE_DEBUG("local bdaddr is stored in %s", val);
 
-        if ((addr_fd = open(val, O_RDONLY)) != -1)
+        if ((addr_fd = TEMP_FAILURE_RETRY(open(val, O_RDONLY))) != -1)
         {
             memset(val, 0, sizeof(val));
-            read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN);
+            TEMP_FAILURE_RETRY(read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN));
             string_to_bdaddr(val, local_addr);
             /* If this is not a reserved/special bda, then use it */
             if (memcmp(local_addr->address, null_bdaddr, BD_ADDR_LEN) != 0)
diff --git a/bt/btif/src/btif_dm.c b/bt/btif/src/btif_dm.c
index cf317d6..1907703 100644
--- a/bt/btif/src/btif_dm.c
+++ b/bt/btif/src/btif_dm.c
@@ -28,6 +28,7 @@
 #define LOG_TAG "bt_btif_dm"
 
 #include <assert.h>
+#include <errno.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -1782,7 +1783,7 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
             BTIF_TRACE_ERROR("Received H/W Error. ");
             /* Flush storage data */
             btif_config_flush();
-            usleep(100000); /* 100milliseconds */
+            TEMP_FAILURE_RETRY(usleep(100000)); /* 100milliseconds */
             /* Killing the process to force a restart as part of fault tolerance */
             kill(getpid(), SIGKILL);
             break;
diff --git a/bt/btif/src/btif_hh.c b/bt/btif/src/btif_hh.c
index 3b9220a..9d6c9e0 100644
--- a/bt/btif/src/btif_hh.c
+++ b/bt/btif/src/btif_hh.c
@@ -33,6 +33,8 @@
 
 #define LOG_TAG "bt_btif_hh"
 
+#include <cutils/log.h>
+
 #include "bta_api.h"
 #include "bta_hh_api.h"
 #include "btif_storage.h"
@@ -232,7 +234,7 @@ static void toggle_os_keylockstates(int fd, int changedlockstates)
     BTIF_TRACE_DEBUG("%s:  %x %x %x", __FUNCTION__,
          hidreport[6], hidreport[7], hidreport[8]);
     bta_hh_co_write(fd , hidreport, sizeof(hidreport));
-    usleep(200000);
+    TEMP_FAILURE_RETRY(usleep(200000));
     memset(hidreport,0,9);
     hidreport[0]=1;
     BTIF_TRACE_DEBUG("Writing hidreport #2 to os: "\
@@ -254,7 +256,12 @@ static void toggle_os_keylockstates(int fd, int changedlockstates)
 *******************************************************************************/
 static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)
 {
-    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));
+    UINT16 buflen = (UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR));
+    if (buflen < len) {
+      android_errorWriteWithInfoLog(0x534e4554, "28672558", -1, NULL, 0);
+      return NULL;
+    }
+    BT_HDR* p_buf = GKI_getbuf(buflen);
 
     if (p_buf) {
         UINT8* pbuf_data;
@@ -322,7 +329,7 @@ static void sync_lockstate_on_connect(btif_hh_device_t *p_dev)
         BTIF_TRACE_DEBUG("%s: Sending hid report to kernel "\
             "indicating lock key state 0x%x",__FUNCTION__,
             keylockstates);
-        usleep(200000);
+        TEMP_FAILURE_RETRY(usleep(200000));
         toggle_os_keylockstates(p_dev->fd, keylockstates);
     }
     else
diff --git a/bt/btif/src/btif_hl.c b/bt/btif/src/btif_hl.c
index 9d0c0d7..995146e 100644
--- a/bt/btif/src/btif_hl.c
+++ b/bt/btif/src/btif_hl.c
@@ -4795,8 +4795,8 @@ void btif_hl_select_monitor_callback(fd_set *p_cur_set ,fd_set *p_org_set) {
                 }
                 p_dcb->p_tx_pkt = btif_hl_get_buf (p_dcb->mtu);
                 if (p_dcb) {
-                    int r = (int)recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,
-                            p_dcb->mtu, MSG_DONTWAIT);
+                    int r = (int)TEMP_FAILURE_RETRY(recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,
+                            p_dcb->mtu, MSG_DONTWAIT));
                     if (r > 0) {
                         BTIF_TRACE_DEBUG("btif_hl_select_monitor_callback send data r =%d", r);
                         p_dcb->tx_size = r;
@@ -4852,7 +4852,7 @@ static inline int btif_hl_select_wakeup_init(fd_set* set){
 static inline int btif_hl_select_wakeup(void){
     char sig_on = btif_hl_signal_select_wakeup;
     BTIF_TRACE_DEBUG("btif_hl_select_wakeup");
-    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
+    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));
 }
 
 /*******************************************************************************
@@ -4867,7 +4867,7 @@ static inline int btif_hl_select_wakeup(void){
 static inline int btif_hl_select_close_connected(void){
     char sig_on = btif_hl_signal_select_close_connected;
     BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
-    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
+    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));
 }
 
 /*******************************************************************************
@@ -4884,7 +4884,7 @@ static inline int btif_hl_close_select_thread(void)
     int result = 0;
     char sig_on = btif_hl_signal_select_exit;
     BTIF_TRACE_DEBUG("btif_hl_signal_select_exit");
-    result = send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
+    result = TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));
     if (btif_is_enabled())
     {
         /* Wait for the select_thread_id to exit if BT is still enabled
@@ -4911,7 +4911,7 @@ static inline int btif_hl_select_wake_reset(void){
     char sig_recv = 0;
 
     BTIF_TRACE_DEBUG("btif_hl_select_wake_reset");
-    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
+    TEMP_FAILURE_RETRY(recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
     return(int)sig_recv;
 }
 /*******************************************************************************
@@ -4972,7 +4972,7 @@ static void *btif_hl_select_thread(void *arg){
         BTIF_TRACE_DEBUG("set curr_set = org_set ");
         curr_set = org_set;
         max_curr_s = max_org_s;
-        int ret = select((max_curr_s + 1), &curr_set, NULL, NULL, NULL);
+        int ret = TEMP_FAILURE_RETRY(select((max_curr_s + 1), &curr_set, NULL, NULL, NULL));
         BTIF_TRACE_DEBUG("select unblocked ret=%d", ret);
         if (ret == -1)
         {
diff --git a/bt/btif/src/btif_pan.c b/bt/btif/src/btif_pan.c
index c3dec2a..e2e391a 100644
--- a/bt/btif/src/btif_pan.c
+++ b/bt/btif/src/btif_pan.c
@@ -312,7 +312,7 @@ static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)
     //set mac addr
     memset(&ifr, 0, sizeof(ifr));
     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);
-    err = ioctl(sk, SIOCGIFHWADDR, &ifr);
+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCGIFHWADDR, &ifr));
     if (err < 0)
     {
         BTIF_TRACE_ERROR("Could not get network hardware for interface:%s, errno:%s", devname, strerror(errno));
@@ -333,7 +333,7 @@ static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)
         ifr.ifr_hwaddr.sa_data[0] &= ~0x01;
     }
 
-    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);
+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr));
 
     if (err < 0) {
         BTIF_TRACE_ERROR("Could not set bt address for interface:%s, errno:%s", devname, strerror(errno));
@@ -348,7 +348,7 @@ static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)
     ifr.ifr_flags |= IFF_UP;
     ifr.ifr_flags |= IFF_MULTICAST;
 
-    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);
+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));
 
 
     if (err < 0) {
@@ -375,7 +375,7 @@ static int tap_if_down(const char *devname)
 
     ifr.ifr_flags &= ~IFF_UP;
 
-    ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);
+    TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));
 
     close(sk);
 
@@ -401,7 +401,7 @@ int btpan_tap_open()
 
     /* open the clone device */
 
-    if ((fd = open(clonedev, O_RDWR)) < 0)
+    if ((fd = TEMP_FAILURE_RETRY(open(clonedev, O_RDWR))) < 0)
     {
         BTIF_TRACE_DEBUG("could not open %s, err:%d", clonedev, errno);
         return fd;
@@ -413,7 +413,7 @@ int btpan_tap_open()
     strncpy(ifr.ifr_name, TAP_IF_NAME, IFNAMSIZ);
 
     /* try to create the device */
-    if ((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0)
+    if ((err = TEMP_FAILURE_RETRY(ioctl(fd, TUNSETIFF, (void *) &ifr))) < 0)
     {
         BTIF_TRACE_DEBUG("ioctl error:%d, errno:%s", err, strerror(errno));
         close(fd);
@@ -421,8 +421,8 @@ int btpan_tap_open()
     }
     if (tap_if_up(TAP_IF_NAME, controller_get_interface()->get_address()) == 0)
     {
-        int flags = fcntl(fd, F_GETFL, 0);
-        fcntl(fd, F_SETFL, flags | O_NONBLOCK);
+        int flags = TEMP_FAILURE_RETRY(fcntl(fd, F_GETFL, 0));
+        TEMP_FAILURE_RETRY(fcntl(fd, F_SETFL, flags | O_NONBLOCK));
         return fd;
     }
     BTIF_TRACE_ERROR("can not bring up tap interface:%s", TAP_IF_NAME);
@@ -451,7 +451,7 @@ int btpan_tap_send(int tap_fd, const BD_ADDR src, const BD_ADDR dst, UINT16 prot
         memcpy(packet + sizeof(tETH_HDR), buf, len);
 
         /* Send data to network interface */
-        int ret = write(tap_fd, packet, len + sizeof(tETH_HDR));
+        int ret = TEMP_FAILURE_RETRY(write(tap_fd, packet, len + sizeof(tETH_HDR)));
         BTIF_TRACE_DEBUG("ret:%d", ret);
         return ret;
     }
@@ -682,7 +682,7 @@ static void btu_exec_tap_fd_read(void *p_param) {
         // We save it in the congest_packet right away in case we can't deliver it in this
         // attempt.
         if (!btpan_cb.congest_packet_size) {
-            ssize_t ret = read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet));
+            ssize_t ret = TEMP_FAILURE_RETRY(read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet)));
             switch (ret) {
                 case -1:
                     BTIF_TRACE_ERROR("%s unable to read from driver: %s", __func__, strerror(errno));
@@ -726,7 +726,7 @@ static void btu_exec_tap_fd_read(void *p_param) {
         ufd.fd = fd;
         ufd.events = POLLIN;
         ufd.revents = 0;
-        if (poll(&ufd, 1, 0) <= 0 || IS_EXCEPTION(ufd.revents))
+        if (TEMP_FAILURE_RETRY(poll(&ufd, 1, 0)) <= 0 || IS_EXCEPTION(ufd.revents))
             break;
     }
     //add fd back to monitor thread
diff --git a/bt/btif/src/btif_rc.c b/bt/btif/src/btif_rc.c
index 1b5696c..476d8f1 100644
--- a/bt/btif/src/btif_rc.c
+++ b/bt/btif/src/btif_rc.c
@@ -24,6 +24,7 @@
  *  Description:   Bluetooth AVRC implementation
  *
  *****************************************************************************/
+#include <errno.h>
 #include <hardware/bluetooth.h>
 #include <fcntl.h>
 #include <string.h>
@@ -235,7 +236,7 @@ int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
     event.code  = code;
     event.value = value;
 
-    return write(fd, &event, sizeof(event));
+    return TEMP_FAILURE_RETRY(write(fd, &event, sizeof(event)));
 }
 
 void send_key (int fd, uint16_t key, int pressed)
@@ -274,7 +275,7 @@ int uinput_create(char *name)
 
     for(x=0; x < MAX_UINPUT_PATHS; x++)
     {
-        fd = open(uinput_dev_path[x], O_RDWR);
+        fd = TEMP_FAILURE_RETRY(open(uinput_dev_path[x], O_RDWR));
         if (fd < 0)
             continue;
         break;
@@ -292,20 +293,20 @@ int uinput_create(char *name)
     dev.id.product = 0x0000;
     dev.id.version = 0x0000;
 
-    if (write(fd, &dev, sizeof(dev)) < 0) {
+    if (TEMP_FAILURE_RETRY(write(fd, &dev, sizeof(dev))) < 0) {
         BTIF_TRACE_ERROR("%s Unable to write device information", __FUNCTION__);
         close(fd);
         return -1;
     }
 
-    ioctl(fd, UI_SET_EVBIT, EV_KEY);
-    ioctl(fd, UI_SET_EVBIT, EV_REL);
-    ioctl(fd, UI_SET_EVBIT, EV_SYN);
+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_KEY));
+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_REL));
+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_SYN));
 
     for (x = 0; key_map[x].name != NULL; x++)
-        ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id);
+        TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id));
 
-    if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {
+    if (TEMP_FAILURE_RETRY(ioctl(fd, UI_DEV_CREATE, NULL)) < 0) {
         BTIF_TRACE_ERROR("%s Unable to create uinput device", __FUNCTION__);
         close(fd);
         return -1;
@@ -333,7 +334,7 @@ void close_uinput (void)
 {
     BTIF_TRACE_DEBUG("%s", __FUNCTION__);
     if (uinput_fd > 0) {
-        ioctl(uinput_fd, UI_DEV_DESTROY);
+        TEMP_FAILURE_RETRY(ioctl(uinput_fd, UI_DEV_DESTROY));
 
         close(uinput_fd);
         uinput_fd = -1;
diff --git a/bt/btif/src/btif_sock_l2cap.c b/bt/btif/src/btif_sock_l2cap.c
index 04c5b67..7b1a5cf 100644
--- a/bt/btif/src/btif_sock_l2cap.c
+++ b/bt/btif/src/btif_sock_l2cap.c
@@ -968,7 +968,7 @@ static BOOLEAN flush_incoming_que_on_wr_signal_l(l2cap_socket *sock)
     uint32_t len;
 
     while (packet_get_head_l(sock, &buf, &len)) {
-        int sent = send(sock->our_fd, buf, len, MSG_DONTWAIT);
+        int sent = TEMP_FAILURE_RETRY(send(sock->our_fd, buf, len, MSG_DONTWAIT));
 
         if (sent == (signed)len)
             osi_free(buf);
@@ -1002,7 +1002,7 @@ void btsock_l2cap_signaled(int fd, int flags, uint32_t user_id)
             if (sock->connected) {
                 int size = 0;
 
-                if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(sock->our_fd, FIONREAD, &size)
+                if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (TEMP_FAILURE_RETRY(ioctl(sock->our_fd, FIONREAD, &size))
                         == 0 && size)) {
                     uint8_t *buffer = osi_malloc(L2CAP_MAX_SDU_LENGTH);
                     //uint8_t *buffer = (uint8_t*)GKI_getbuf(L2CAP_MAX_SDU_LENGTH);
@@ -1028,8 +1028,8 @@ void btsock_l2cap_signaled(int fd, int flags, uint32_t user_id)
                          * UPDATE: Since we are responsible for freeing the buffer in the
                          * write_complete_ind, it is OK to use malloc. */
 
-                        int count = recv(fd, buffer, L2CAP_MAX_SDU_LENGTH,
-                                MSG_NOSIGNAL | MSG_DONTWAIT);
+                        int count = TEMP_FAILURE_RETRY(recv(fd, buffer, L2CAP_MAX_SDU_LENGTH,
+                                MSG_NOSIGNAL | MSG_DONTWAIT));
                         APPL_TRACE_DEBUG("btsock_l2cap_signaled - %d bytes received from socket",
                                 count);
                         if (sock->fixed_chan) {
@@ -1061,7 +1061,7 @@ void btsock_l2cap_signaled(int fd, int flags, uint32_t user_id)
         }
         if (drop_it || (flags & SOCK_THREAD_FD_EXCEPTION)) {
             int size = 0;
-            if (drop_it || ioctl(sock->our_fd, FIONREAD, &size) != 0 || size == 0)
+            if (drop_it || TEMP_FAILURE_RETRY(ioctl(sock->our_fd, FIONREAD, &size)) != 0 || size == 0)
                 btsock_l2cap_free_l(sock);
         }
     }
diff --git a/bt/btif/src/btif_sock_rfc.c b/bt/btif/src/btif_sock_rfc.c
index f80ed56..605099e 100644
--- a/bt/btif/src/btif_sock_rfc.c
+++ b/bt/btif/src/btif_sock_rfc.c
@@ -720,7 +720,7 @@ static sent_status_t send_data_to_app(int fd, BT_HDR *p_buf) {
   if (p_buf->len == 0)
     return SENT_ALL;
 
-  ssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);
+  ssize_t sent = TEMP_FAILURE_RETRY(send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT));
 
   if (sent == -1) {
     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
@@ -783,11 +783,9 @@ void btsock_rfc_signaled(UNUSED_ATTR int fd, int flags, uint32_t user_id) {
     if (slot->f.connected) {
       // Make sure there's data pending in case the peer closed the socket.
       int size = 0;
-      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(slot->fd, FIONREAD, &size) == 0 && size))
-        //unlock before BTA_JvRfcommWrite to avoid deadlock on concurrnet multi rfcomm connectoins
-        //concurrnet multi rfcomm connectoins
-        pthread_mutex_unlock(&slot_lock);
+      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) == 0 && size)) {
         BTA_JvRfcommWrite(slot->rfc_handle, slot->id);
+      }
     } else {
       LOG_ERROR("%s socket signaled for read while disconnected, slot: %d, channel: %d", __func__, slot->id, slot->scn);
       need_close = true;
@@ -805,7 +803,7 @@ void btsock_rfc_signaled(UNUSED_ATTR int fd, int flags, uint32_t user_id) {
   if (need_close || (flags & SOCK_THREAD_FD_EXCEPTION)) {
     // Clean up if there's no data pending.
     int size = 0;
-    if (need_close || ioctl(slot->fd, FIONREAD, &size) != 0 || !size)
+    if (need_close || TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) != 0 || !size)
       cleanup_rfc_slot(slot);
   }
 
@@ -859,7 +857,7 @@ int bta_co_rfc_data_outgoing_size(void *user_data, int *size) {
   if (!slot)
     goto out;
 
-  if (ioctl(slot->fd, FIONREAD, size) == 0) {
+  if (TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, size)) == 0) {
     ret = true;
   } else {
     LOG_ERROR("%s unable to determine bytes remaining to be read on fd %d: %s", __func__, slot->fd, strerror(errno));
@@ -880,7 +878,7 @@ int bta_co_rfc_data_outgoing(void *user_data, uint8_t *buf, uint16_t size) {
   if (!slot)
     goto out;
 
-  int received = recv(slot->fd, buf, size, 0);
+  int received = TEMP_FAILURE_RETRY(recv(slot->fd, buf, size, 0));
   if(received == size) {
     ret = true;
   } else {
diff --git a/bt/btif/src/btif_sock_thread.c b/bt/btif/src/btif_sock_thread.c
index 459aeba..6ccdeb6 100644
--- a/bt/btif/src/btif_sock_thread.c
+++ b/bt/btif/src/btif_sock_thread.c
@@ -114,12 +114,12 @@ static pthread_mutex_t thread_slot_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 static inline void set_socket_blocking(int s, int blocking)
 {
     int opts;
-    opts = fcntl(s, F_GETFL);
+    opts = TEMP_FAILURE_RETRY(fcntl(s, F_GETFL));
     if (opts<0) APPL_TRACE_ERROR("set blocking (%s)", strerror(errno));
     if(blocking)
         opts &= ~O_NONBLOCK;
     else opts |= O_NONBLOCK;
-    if (fcntl(s, F_SETFL, opts) < 0)
+    if (TEMP_FAILURE_RETRY(fcntl(s, F_SETFL, opts)) < 0)
         APPL_TRACE_ERROR("set blocking (%s)", strerror(errno));
 }
 
@@ -161,7 +161,7 @@ static inline int accept_server_socket(int s)
 {
     struct sockaddr_un client_address;
     socklen_t clen;
-    int fd = accept(s, (struct sockaddr*)&client_address, &clen);
+    int fd = TEMP_FAILURE_RETRY(accept(s, (struct sockaddr*)&client_address, &clen));
     APPL_TRACE_DEBUG("accepted fd:%d for server fd:%d", fd, s);
     return fd;
 }
@@ -325,7 +325,7 @@ int btsock_thread_add_fd(int h, int fd, int type, int flags, uint32_t user_id)
     }
     sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};
     APPL_TRACE_DEBUG("adding fd:%d, flags:0x%x", fd, flags);
-    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);
 }
 
 bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)
@@ -342,7 +342,7 @@ bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)
     }
 
     sock_cmd_t cmd = {CMD_REMOVE_FD, fd, 0, 0, 0};
-    return send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
+    return TEMP_FAILURE_RETRY(send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);
 }
 
 int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)
@@ -376,7 +376,7 @@ int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size,
             return FALSE;
         }
     }
-    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;
+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, cmd_send, size_send, 0)) == size_send;
 }
 int btsock_thread_wakeup(int h)
 {
@@ -391,7 +391,7 @@ int btsock_thread_wakeup(int h)
         return FALSE;
     }
     sock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};
-    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);
 }
 int btsock_thread_exit(int h)
 {
@@ -406,7 +406,7 @@ int btsock_thread_exit(int h)
         return FALSE;
     }
     sock_cmd_t cmd = {CMD_EXIT, 0, 0, 0, 0};
-    if(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd))
+    if (TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd))
     {
         pthread_join(ts[h].thread_id, 0);
         pthread_mutex_lock(&thread_slot_lock);
@@ -501,7 +501,7 @@ static int process_cmd_sock(int h)
 {
     sock_cmd_t cmd = {-1, 0, 0, 0, 0};
     int fd = ts[h].cmd_fdr;
-    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))
+    if (TEMP_FAILURE_RETRY(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL)) != sizeof(cmd))
     {
         APPL_TRACE_ERROR("recv cmd errno:%d", errno);
         return FALSE;
@@ -608,7 +608,7 @@ static void *sock_poll_thread(void *arg)
     for(;;)
     {
         prepare_poll_fds(h, pfds);
-        int ret = poll(pfds, ts[h].poll_count, -1);
+        int ret = TEMP_FAILURE_RETRY(poll(pfds, ts[h].poll_count, -1));
         if(ret == -1)
         {
             APPL_TRACE_ERROR("poll ret -1, exit the thread, errno:%d, err:%s", errno, strerror(errno));
diff --git a/bt/btif/src/btif_sock_util.c b/bt/btif/src/btif_sock_util.c
index baa3ed3..ead113f 100644
--- a/bt/btif/src/btif_sock_util.c
+++ b/bt/btif/src/btif_sock_util.c
@@ -74,7 +74,7 @@ int sock_send_all(int sock_fd, const uint8_t* buf, int len)
     int ret;
     while(s)
     {
-        do ret = send(sock_fd, buf, s, 0);
+        do ret = TEMP_FAILURE_RETRY(send(sock_fd, buf, s, 0));
         while(ret < 0 && errno == EINTR);
         if(ret <= 0)
         {
@@ -92,7 +92,7 @@ int sock_recv_all(int sock_fd, uint8_t* buf, int len)
     int ret = -1;
     while(r)
     {
-        do ret = recv(sock_fd, buf, r, MSG_WAITALL);
+        do ret = TEMP_FAILURE_RETRY(recv(sock_fd, buf, r, MSG_WAITALL));
         while(ret < 0 && errno == EINTR);
         if(ret <= 0)
         {
@@ -140,7 +140,7 @@ int sock_send_fd(int sock_fd, const uint8_t* buf, int len, int send_fd)
         msg.msg_iovlen = 1;
 
         do {
-            ret = sendmsg(sock_fd, &msg, MSG_NOSIGNAL);
+            ret = TEMP_FAILURE_RETRY(sendmsg(sock_fd, &msg, MSG_NOSIGNAL));
         } while (ret < 0 && errno == EINTR);
 
         if (ret < 0) {
diff --git a/bt/btif/src/btif_storage.c b/bt/btif/src/btif_storage.c
index 687af94..83a5c2e 100644
--- a/bt/btif/src/btif_storage.c
+++ b/bt/btif/src/btif_storage.c
@@ -806,6 +806,13 @@ bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,
     int ret = btif_config_set_int(bdstr, "LinkKeyType", (int)key_type);
     ret &= btif_config_set_int(bdstr, "PinLength", (int)pin_length);
     ret &= btif_config_set_bin(bdstr, "LinkKey", link_key, sizeof(LINK_KEY));
+
+    if (is_restricted_mode()) {
+        BTIF_TRACE_WARNING("%s: '%s' pairing will be removed if unrestricted",
+                         __func__, bdstr);
+        btif_config_set_int(bdstr, "Restricted", 1);
+    }
+
     /* write bonded info immediately */
     btif_config_flush();
     return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
@@ -1660,3 +1667,20 @@ BOOLEAN btif_storage_is_fixed_pin_zeros_keyboard(bt_bdaddr_t *remote_bd_addr)
 
 }
 
+/*******************************************************************************
+**
+** Function         btif_storage_is_restricted_device
+**
+** Description      BTIF storage API - checks if this device is a restricted device
+**
+** Returns          TRUE  if the device is labeled as restricted
+**                  FALSE otherwise
+**
+*******************************************************************************/
+BOOLEAN btif_storage_is_restricted_device(const bt_bdaddr_t *remote_bd_addr)
+{
+    bdstr_t bdstr;
+    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
+
+    return btif_config_exist(bdstr, "Restricted");
+}
diff --git a/bt/device/src/controller.c b/bt/device/src/controller.c
index 1938f09..e5cbbf7 100644
--- a/bt/device/src/controller.c
+++ b/bt/device/src/controller.c
@@ -34,7 +34,11 @@
 #include "stack/include/btm_ble_api.h"
 #include "btcore/include/version.h"
 
+#ifdef CONFIG_QCA9377
+const bt_event_mask_t BLE_EVENT_MASK = { "\x00\x00\x00\x00\x00\x00\x04\x7f" };
+#else
 const bt_event_mask_t BLE_EVENT_MASK = { "\x00\x00\x00\x00\x00\x00\x06\x7f" };
+#endif
 
 #if (BLE_INCLUDED)
 const bt_event_mask_t CLASSIC_EVENT_MASK = { HCI_DUMO_EVENT_MASK_EXT };
diff --git a/bt/gki/ulinux/gki_ulinux.c b/bt/gki/ulinux/gki_ulinux.c
index 72ad479..703e992 100644
--- a/bt/gki/ulinux/gki_ulinux.c
+++ b/bt/gki/ulinux/gki_ulinux.c
@@ -76,7 +76,7 @@ void GKI_delay(UINT32 timeout_ms) {
 
   int err;
   do {
-    err = nanosleep(&delay, &delay);
+    err = TEMP_FAILURE_RETRY(nanosleep(&delay, &delay));
   } while (err == -1 && errno == EINTR);
 }
 
diff --git a/bt/hci/src/btsnoop.c b/bt/hci/src/btsnoop.c
index d859e68..7b6b97f 100644
--- a/bt/hci/src/btsnoop.c
+++ b/bt/hci/src/btsnoop.c
@@ -169,14 +169,14 @@ static void update_logging() {
         LOG_ERROR("%s unable to rename '%s' to '%s': %s", __func__, log_path, last_log_path, strerror(errno));
     }
 
-    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
+    logfile_fd = TEMP_FAILURE_RETRY(open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH));
     if (logfile_fd == INVALID_FD) {
       LOG_ERROR("%s unable to open '%s': %s", __func__, log_path, strerror(errno));
       is_logging = false;
       return;
     }
 
-    write(logfile_fd, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16);
+    TEMP_FAILURE_RETRY(write(logfile_fd, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16));
   } else {
     if (logfile_fd != INVALID_FD)
       close(logfile_fd);
@@ -188,7 +188,7 @@ static void update_logging() {
 
 static void btsnoop_write(const void *data, size_t length) {
   if (logfile_fd != INVALID_FD)
-    write(logfile_fd, data, length);
+    TEMP_FAILURE_RETRY(write(logfile_fd, data, length));
 
   btsnoop_net_write(data, length);
 }
diff --git a/bt/hci/src/btsnoop_net.c b/bt/hci/src/btsnoop_net.c
index c6a9cd6..1aff832 100644
--- a/bt/hci/src/btsnoop_net.c
+++ b/bt/hci/src/btsnoop_net.c
@@ -77,7 +77,7 @@ void btsnoop_net_write(const void *data, size_t length) {
 
   pthread_mutex_lock(&client_socket_lock_);
   if (client_socket_ != -1) {
-    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {
+    if (TEMP_FAILURE_RETRY(send(client_socket_, data, length, 0)) == -1 && errno == ECONNRESET) {
       safe_close_(&client_socket_);
     }
   }
@@ -115,7 +115,7 @@ static void *listen_fn_(UNUSED_ATTR void *context) {
   }
 
   for (;;) {
-    int client_socket = accept(listen_socket_, NULL, NULL);
+    int client_socket = TEMP_FAILURE_RETRY(accept(listen_socket_, NULL, NULL));
     if (client_socket == -1) {
       if (errno == EINVAL || errno == EBADF) {
         break;
@@ -129,7 +129,7 @@ static void *listen_fn_(UNUSED_ATTR void *context) {
     pthread_mutex_lock(&client_socket_lock_);
     safe_close_(&client_socket_);
     client_socket_ = client_socket;
-    send(client_socket_, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16, 0);
+    TEMP_FAILURE_RETRY(send(client_socket_, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16, 0));
     pthread_mutex_unlock(&client_socket_lock_);
   }
 
diff --git a/bt/hci/src/hci_hal_h4.c b/bt/hci/src/hci_hal_h4.c
index 4fc4274..86c0dc7 100644
--- a/bt/hci/src/hci_hal_h4.c
+++ b/bt/hci/src/hci_hal_h4.c
@@ -139,7 +139,7 @@ static uint16_t transmit_data(serial_data_type_t type, uint8_t *data, uint16_t l
 
   uint16_t transmitted_length = 0;
   while (length > 0) {
-    ssize_t ret = write(uart_fd, data + transmitted_length, length);
+    ssize_t ret = TEMP_FAILURE_RETRY(write(uart_fd, data + transmitted_length, length));
     switch (ret) {
       case -1:
         LOG_ERROR("In %s, error writing to the uart serial port: %s", __func__, strerror(errno));
diff --git a/bt/hci/src/hci_hal_mct.c b/bt/hci/src/hci_hal_mct.c
index 9b3707c..5219e03 100644
--- a/bt/hci/src/hci_hal_mct.c
+++ b/bt/hci/src/hci_hal_mct.c
@@ -159,7 +159,7 @@ static uint16_t transmit_data_on(int fd, uint8_t *data, uint16_t length) {
 
   uint16_t transmitted_length = 0;
   while (length > 0) {
-    ssize_t ret = write(fd, data + transmitted_length, length);
+    ssize_t ret = TEMP_FAILURE_RETRY(write(fd, data + transmitted_length, length));
     switch (ret) {
       case -1:
         LOG_ERROR("In %s, error writing to the serial port with fd %d: %s", __func__, fd, strerror(errno));
diff --git a/bt/hci/src/hci_layer.c b/bt/hci/src/hci_layer.c
index 5138ce6..f7bea81 100644
--- a/bt/hci/src/hci_layer.c
+++ b/bt/hci/src/hci_layer.c
@@ -20,6 +20,7 @@
 
 #include <assert.h>
 #include <cutils/properties.h>
+#include <errno.h>
 #include <string.h>
 #include <signal.h>
 #include <string.h>
@@ -516,9 +517,11 @@ static void command_timed_out(UNUSED_ATTR void *context) {
     LOG_ERROR("%s hci layer timeout waiting for response to a command. opcode: 0x%x", __func__, wait_entry->opcode);
   }
 
-  LOG_ERROR("%s restarting the bluetooth process.", __func__);
-  usleep(10000);
-  kill(getpid(), SIGKILL);
+  if (firmware_is_configured) {
+    LOG_ERROR("%s restarting the bluetooth process.", __func__);
+    TEMP_FAILURE_RETRY(usleep(10000));
+    kill(getpid(), SIGKILL);
+  }
 }
 
 // Event/packet receiving functions
diff --git a/bt/hci/test/hci_hal_h4_test.cpp b/bt/hci/test/hci_hal_h4_test.cpp
index 2c4030d..6b42111 100644
--- a/bt/hci/test/hci_hal_h4_test.cpp
+++ b/bt/hci/test/hci_hal_h4_test.cpp
@@ -177,26 +177,26 @@ static void expect_socket_data(int fd, char first_byte, char *data) {
     fd_set read_fds;
     FD_ZERO(&read_fds);
     FD_SET(fd, &read_fds);
-    select(fd + 1, &read_fds, NULL, NULL, NULL);
+    TEMP_FAILURE_RETRY(select(fd + 1, &read_fds, NULL, NULL, NULL));
 
     char byte;
-    read(fd, &byte, 1);
+    TEMP_FAILURE_RETRY(read(fd, &byte, 1));
 
     EXPECT_EQ(i == 0 ? first_byte : data[i - 1], byte);
   }
 }
 
 static void write_packet(int fd, char first_byte, char *data) {
-  write(fd, &first_byte, 1);
-  write(fd, data, strlen(data));
+  TEMP_FAILURE_RETRY(write(fd, &first_byte, 1));
+  TEMP_FAILURE_RETRY(write(fd, data, strlen(data)));
 }
 
 static void write_packet_reentry(int fd, char first_byte, char *data) {
-  write(fd, &first_byte, 1);
+  TEMP_FAILURE_RETRY(write(fd, &first_byte, 1));
 
   int length = strlen(data);
   for (int i = 0; i < length; i++) {
-    write(fd, &data[i], 1);
+    TEMP_FAILURE_RETRY(write(fd, &data[i], 1));
     semaphore_wait(reentry_semaphore);
   }
 }
@@ -245,7 +245,7 @@ TEST_F(HciHalH4Test, test_type_byte_only_must_not_signal_data_ready) {
   reset_for(type_byte_only);
 
   char byte = DATA_TYPE_ACL;
-  write(sockfd[1], &byte, 1);
+  TEMP_FAILURE_RETRY(write(sockfd[1], &byte, 1));
 
   fd_set read_fds;
 
@@ -258,6 +258,6 @@ TEST_F(HciHalH4Test, test_type_byte_only_must_not_signal_data_ready) {
     timeout.tv_sec = 0;
     timeout.tv_usec = 0;
 
-    select(sockfd[0] + 1, &read_fds, NULL, NULL, &timeout);
+    TEMP_FAILURE_RETRY(select(sockfd[0] + 1, &read_fds, NULL, NULL, &timeout));
   } while(FD_ISSET(sockfd[0], &read_fds));
 }
diff --git a/bt/hci/test/hci_hal_mct_test.cpp b/bt/hci/test/hci_hal_mct_test.cpp
index 911aabc..a857629 100644
--- a/bt/hci/test/hci_hal_mct_test.cpp
+++ b/bt/hci/test/hci_hal_mct_test.cpp
@@ -186,23 +186,23 @@ static void expect_socket_data(int fd, char *data) {
     fd_set read_fds;
     FD_ZERO(&read_fds);
     FD_SET(fd, &read_fds);
-    select(fd + 1, &read_fds, NULL, NULL, NULL);
+    TEMP_FAILURE_RETRY(select(fd + 1, &read_fds, NULL, NULL, NULL));
 
     char byte;
-    read(fd, &byte, 1);
+    TEMP_FAILURE_RETRY(read(fd, &byte, 1));
 
     EXPECT_EQ(data[i], byte);
   }
 }
 
 static void write_packet(int fd, char *data) {
-  write(fd, data, strlen(data));
+  TEMP_FAILURE_RETRY(write(fd, data, strlen(data)));
 }
 
 static void write_packet_reentry(int fd, char *data) {
   int length = strlen(data);
   for (int i = 0; i < length; i++) {
-    write(fd, &data[i], 1);
+    TEMP_FAILURE_RETRY(write(fd, &data[i], 1));
     semaphore_wait(reentry_semaphore);
   }
 }
diff --git a/bt/osi/src/config.c b/bt/osi/src/config.c
index c87f531..3d5d87f 100644
--- a/bt/osi/src/config.c
+++ b/bt/osi/src/config.c
@@ -21,10 +21,13 @@
 #include <assert.h>
 #include <ctype.h>
 #include <errno.h>
+#include <fcntl.h>
+#include <libgen.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include "osi/include/allocator.h"
 #include "osi/include/config.h"
@@ -275,16 +278,39 @@ bool config_save(const config_t *config, const char *filename) {
   assert(filename != NULL);
   assert(*filename != '\0');
 
-  char *temp_filename = osi_calloc(strlen(filename) + 5);
-  if (!temp_filename) {
-    LOG_ERROR("%s unable to allocate memory for filename.", __func__);
-    return false;
+  // Steps to ensure content of config file gets to disk:
+  //
+  // 1) Open and write to temp file (e.g. bt_config.conf.new).
+  // 2) Sync the temp file to disk with fsync().
+  // 3) Rename temp file to actual config file (e.g. bt_config.conf).
+  //    This ensures atomic update.
+  // 4) Sync directory that has the conf file with fsync().
+  //    This ensures directory entries are up-to-date.
+  int dir_fd = -1;
+  FILE *fp = NULL;
+
+  // Build temp config file based on config file (e.g. bt_config.conf.new).
+  static const char *temp_file_ext = ".new";
+  const int filename_len = strlen(filename);
+  const int temp_filename_len = filename_len + strlen(temp_file_ext) + 1;
+  char *temp_filename = osi_calloc(temp_filename_len);
+  snprintf(temp_filename, temp_filename_len, "%s%s", filename, temp_file_ext);
+
+  // Extract directory from file path (e.g. /data/misc/bluedroid).
+  char *temp_dirname = osi_strdup(filename);
+  const char *directoryname = dirname(temp_dirname);
+  if (!directoryname) {
+    LOG_ERROR("%s error extracting directory from '%s': %s", __func__, filename, strerror(errno));
+    goto error;
   }
 
-  strcpy(temp_filename, filename);
-  strcat(temp_filename, ".new");
+  dir_fd = TEMP_FAILURE_RETRY(open(directoryname, O_RDONLY));
+  if (dir_fd < 0) {
+    LOG_ERROR("%s unable to open dir '%s': %s", __func__, directoryname, strerror(errno));
+    goto error;
+  }
 
-  FILE *fp = fopen(temp_filename, "wt");
+  fp = fopen(temp_filename, "wt");
   if (!fp) {
     LOG_ERROR("%s unable to write file '%s': %s", __func__, temp_filename, strerror(errno));
     goto error;
@@ -292,20 +318,38 @@ bool config_save(const config_t *config, const char *filename) {
 
   for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {
     const section_t *section = (const section_t *)list_node(node);
-    fprintf(fp, "[%s]\n", section->name);
+    if (fprintf(fp, "[%s]\n", section->name) < 0) {
+      LOG_ERROR("%s unable to write to file '%s': %s", __func__, temp_filename, strerror(errno));
+      goto error;
+    }
 
     for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {
       const entry_t *entry = (const entry_t *)list_node(enode);
-      fprintf(fp, "%s = %s\n", entry->key, entry->value);
+      if (fprintf(fp, "%s = %s\n", entry->key, entry->value) < 0) {
+        LOG_ERROR("%s unable to write to file '%s': %s", __func__, temp_filename, strerror(errno));
+        goto error;
+      }
     }
 
     // Only add a separating newline if there are more sections.
-    if (list_next(node) != list_end(config->sections))
-      fputc('\n', fp);
+    if (list_next(node) != list_end(config->sections)) {
+      if (fputc('\n', fp) == EOF) {
+        LOG_ERROR("%s unable to write to file '%s': %s", __func__, temp_filename, strerror(errno));
+        goto error;
+      }
+    }
   }
 
-  fflush(fp);
-  fclose(fp);
+  // Sync written temp file out to disk. fsync() is blocking until data makes it to disk.
+  if (fsync(fileno(fp)) < 0) {
+    LOG_WARN("%s unable to fsync file '%s': %s", __func__, temp_filename, strerror(errno));
+  }
+
+  if (fclose(fp) == EOF) {
+    LOG_ERROR("%s unable to close file '%s': %s", __func__, temp_filename, strerror(errno));
+    goto error;
+  }
+  fp = NULL;
 
   // Change the file's permissions to Read/Write by User and Group
   if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {
@@ -313,17 +357,35 @@ bool config_save(const config_t *config, const char *filename) {
     goto error;
   }
 
+  // Rename written temp file to the actual config file.
   if (rename(temp_filename, filename) == -1) {
     LOG_ERROR("%s unable to commit file '%s': %s", __func__, filename, strerror(errno));
     goto error;
   }
 
+  // This should ensure the directory is updated as well.
+  if (fsync(dir_fd) < 0) {
+    LOG_WARN("%s unable to fsync dir '%s': %s", __func__, directoryname, strerror(errno));
+  }
+
+  if (close(dir_fd) < 0) {
+    LOG_ERROR("%s unable to close dir '%s': %s", __func__, directoryname, strerror(errno));
+    goto error;
+  }
+
   osi_free(temp_filename);
+  osi_free(temp_dirname);
   return true;
 
-error:;
+error:
+  // This indicates there is a write issue.  Unlink as partial data is not acceptable.
   unlink(temp_filename);
+  if (fp)
+    fclose(fp);
+  if (dir_fd != -1)
+    close(dir_fd);
   osi_free(temp_filename);
+  osi_free(temp_dirname);
   return false;
 }
 
diff --git a/bt/osi/src/eager_reader.c b/bt/osi/src/eager_reader.c
index 63b190e..e90a35e 100644
--- a/bt/osi/src/eager_reader.c
+++ b/bt/osi/src/eager_reader.c
@@ -224,7 +224,7 @@ static bool has_byte(const eager_reader_t *reader) {
   timeout.tv_sec = 0;
   timeout.tv_usec = 0;
 
-  select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout);
+  TEMP_FAILURE_RETRY(select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout));
   return FD_ISSET(reader->bytes_available_fd, &read_fds);
 }
 
@@ -240,7 +240,7 @@ static void inbound_data_waiting(void *context) {
   buffer->length = 0;
   buffer->offset = 0;
 
-  int bytes_read = read(reader->inbound_fd, buffer->data, reader->buffer_size);
+  int bytes_read = TEMP_FAILURE_RETRY(read(reader->inbound_fd, buffer->data, reader->buffer_size));
   if (bytes_read > 0) {
     // Save the data for later
     buffer->length = bytes_read;
diff --git a/bt/osi/src/reactor.c b/bt/osi/src/reactor.c
index 08b5098..32bd1be 100644
--- a/bt/osi/src/reactor.c
+++ b/bt/osi/src/reactor.c
@@ -241,7 +241,7 @@ static reactor_status_t run_reactor(reactor_t *reactor, int iterations) {
 
     int ret;
     do {
-      ret = epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1);
+      ret = TEMP_FAILURE_RETRY(epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1));
     } while (ret == -1 && errno == EINTR);
 
     if (ret == -1) {
diff --git a/bt/osi/src/semaphore.c b/bt/osi/src/semaphore.c
index 5ee9926..76fba0d 100644
--- a/bt/osi/src/semaphore.c
+++ b/bt/osi/src/semaphore.c
@@ -73,12 +73,12 @@ bool semaphore_try_wait(semaphore_t *semaphore) {
   assert(semaphore != NULL);
   assert(semaphore->fd != INVALID_FD);
 
-  int flags = fcntl(semaphore->fd, F_GETFL);
+  int flags = TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_GETFL));
   if (flags == -1) {
     LOG_ERROR("%s unable to get flags for semaphore fd: %s", __func__, strerror(errno));
     return false;
   }
-  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {
+  if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK)) == -1) {
     LOG_ERROR("%s unable to set O_NONBLOCK for semaphore fd: %s", __func__, strerror(errno));
     return false;
   }
@@ -87,7 +87,7 @@ bool semaphore_try_wait(semaphore_t *semaphore) {
   if (eventfd_read(semaphore->fd, &value) == -1)
     return false;
 
-  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)
+  if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags)) == -1)
     LOG_ERROR("%s unable to resetore flags for semaphore fd: %s", __func__, strerror(errno));
   return true;
 }
diff --git a/bt/osi/src/socket.c b/bt/osi/src/socket.c
index 91f084e..9905ae3 100644
--- a/bt/osi/src/socket.c
+++ b/bt/osi/src/socket.c
@@ -121,7 +121,7 @@ bool socket_listen(const socket_t *socket, port_t port) {
 socket_t *socket_accept(const socket_t *socket) {
   assert(socket != NULL);
 
-  int fd = accept(socket->fd, NULL, NULL);
+  int fd = TEMP_FAILURE_RETRY(accept(socket->fd, NULL, NULL));
   if (fd == INVALID_FD) {
     LOG_ERROR("%s unable to accept socket: %s", __func__, strerror(errno));
     return NULL;
@@ -142,14 +142,14 @@ ssize_t socket_read(const socket_t *socket, void *buf, size_t count) {
   assert(socket != NULL);
   assert(buf != NULL);
 
-  return recv(socket->fd, buf, count, MSG_DONTWAIT);
+  return TEMP_FAILURE_RETRY(recv(socket->fd, buf, count, MSG_DONTWAIT));
 }
 
 ssize_t socket_write(const socket_t *socket, const void *buf, size_t count) {
   assert(socket != NULL);
   assert(buf != NULL);
 
-  return send(socket->fd, buf, count, MSG_DONTWAIT);
+  return TEMP_FAILURE_RETRY(send(socket->fd, buf, count, MSG_DONTWAIT));
 }
 
 ssize_t socket_write_and_transfer_fd(const socket_t *socket, const void *buf, size_t count, int fd) {
@@ -179,7 +179,7 @@ ssize_t socket_write_and_transfer_fd(const socket_t *socket, const void *buf, si
   header->cmsg_len = CMSG_LEN(sizeof(int));
   *(int *)CMSG_DATA(header) = fd;
 
-  ssize_t ret = sendmsg(socket->fd, &msg, MSG_DONTWAIT);
+  ssize_t ret = TEMP_FAILURE_RETRY(sendmsg(socket->fd, &msg, MSG_DONTWAIT));
   close(fd);
   return ret;
 }
@@ -188,7 +188,7 @@ ssize_t socket_bytes_available(const socket_t *socket) {
   assert(socket != NULL);
 
   int size = 0;
-  if (ioctl(socket->fd, FIONREAD, &size) == -1)
+  if (TEMP_FAILURE_RETRY(ioctl(socket->fd, FIONREAD, &size)) == -1)
     return -1;
   return size;
 }
diff --git a/bt/osi/test/alarm_test.cpp b/bt/osi/test/alarm_test.cpp
index 287d408..fec828f 100644
--- a/bt/osi/test/alarm_test.cpp
+++ b/bt/osi/test/alarm_test.cpp
@@ -32,7 +32,7 @@ static int cb_counter;
 static const uint64_t EPSILON_MS = 5;
 
 static void msleep(uint64_t ms) {
-  usleep(ms * 1000);
+  TEMP_FAILURE_RETRY(usleep(ms * 1000));
 }
 
 class AlarmTest : public AlarmTestHarness {
diff --git a/bt/osi/test/atomic_test.cpp b/bt/osi/test/atomic_test.cpp
index b0039ab..6cde546 100644
--- a/bt/osi/test/atomic_test.cpp
+++ b/bt/osi/test/atomic_test.cpp
@@ -17,7 +17,7 @@ struct atomic_test_s32_s {
 void *atomic_thread(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
-    usleep(1);
+    TEMP_FAILURE_RETRY(usleep(1));
     atomic_inc_prefix_s32(&at->data[i]);
   }
   return NULL;
@@ -26,9 +26,9 @@ void *atomic_thread(void *context) {
 void *atomic_thread_inc_dec(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
-    usleep(1);
+    TEMP_FAILURE_RETRY(usleep(1));
     atomic_inc_prefix_s32(&at->data[i]);
-    usleep(1);
+    TEMP_FAILURE_RETRY(usleep(1));
     atomic_dec_prefix_s32(&at->data[i]);
   }
   return NULL;
diff --git a/bt/osi/test/eager_reader_test.cpp b/bt/osi/test/eager_reader_test.cpp
index ad00e17..d979f42 100644
--- a/bt/osi/test/eager_reader_test.cpp
+++ b/bt/osi/test/eager_reader_test.cpp
@@ -126,7 +126,7 @@ TEST_F(EagerReaderTest, test_small_data) {
   thread_t *read_thread = thread_new("read_thread");
   eager_reader_register(reader, thread_get_reactor(read_thread), expect_data, (void *)small_data);
 
-  write(pipefd[1], small_data, strlen(small_data));
+  TEMP_FAILURE_RETRY(write(pipefd[1], small_data, strlen(small_data)));
 
   semaphore_wait(done);
   eager_reader_free(reader);
@@ -139,7 +139,7 @@ TEST_F(EagerReaderTest, test_large_data_multibyte) {
   thread_t *read_thread = thread_new("read_thread");
   eager_reader_register(reader, thread_get_reactor(read_thread), expect_data_multibyte, (void *)large_data);
 
-  write(pipefd[1], large_data, strlen(large_data));
+  TEMP_FAILURE_RETRY(write(pipefd[1], large_data, strlen(large_data)));
 
   semaphore_wait(done);
   eager_reader_free(reader);
diff --git a/bt/osi/test/reactor_test.cpp b/bt/osi/test/reactor_test.cpp
index 6e3a009..73a6ae0 100644
--- a/bt/osi/test/reactor_test.cpp
+++ b/bt/osi/test/reactor_test.cpp
@@ -64,7 +64,7 @@ TEST_F(ReactorTest, reactor_start_wait_stop) {
   reactor_t *reactor = reactor_new();
 
   spawn_reactor_thread(reactor);
-  usleep(50 * 1000);
+  TEMP_FAILURE_RETRY(usleep(50 * 1000));
   EXPECT_TRUE(thread_running);
 
   reactor_stop(reactor);
@@ -108,7 +108,7 @@ TEST_F(ReactorTest, reactor_unregister_from_separate_thread) {
 
   reactor_object_t *object = reactor_register(reactor, fd, NULL, NULL, NULL);
   spawn_reactor_thread(reactor);
-  usleep(50 * 1000);
+  TEMP_FAILURE_RETRY(usleep(50 * 1000));
   reactor_unregister(object);
 
   reactor_stop(reactor);
diff --git a/bt/stack/include/btm_ble_api.h b/bt/stack/include/btm_ble_api.h
index f697d0e..0a91d5f 100644
--- a/bt/stack/include/btm_ble_api.h
+++ b/bt/stack/include/btm_ble_api.h
@@ -129,7 +129,7 @@ typedef UINT8   tBTM_BLE_SFP;
 #define BTM_BLE_EXT_SCAN_WIN_MAX        0xFFFF
 #define BTM_BLE_CONN_INT_MIN            0x0006
 #define BTM_BLE_CONN_INT_MAX            0x0C80
-#define BTM_BLE_CONN_LATENCY_MAX        200
+#define BTM_BLE_CONN_LATENCY_MAX        500
 #define BTM_BLE_CONN_SUP_TOUT_MIN       0x000A
 #define BTM_BLE_CONN_SUP_TOUT_MAX       0x0C80
 #define BTM_BLE_CONN_PARAM_UNDEF        0xffff      /* use this value when a specific value not to be overwritten */
@@ -138,7 +138,7 @@ typedef UINT8   tBTM_BLE_SFP;
 /* default connection parameters if not configured, use GAP recommend value for auto/selective connection */
 /* default scan interval */
 #ifndef BTM_BLE_SCAN_FAST_INT
-#define BTM_BLE_SCAN_FAST_INT    48    /* 30 ~ 60 ms (use 60)  = 96 *0.625 */
+#define BTM_BLE_SCAN_FAST_INT    96    /* 30 ~ 60 ms (use 60)  = 96 *0.625 */
 #endif
 /* default scan window for background connection, applicable for auto connection or selective conenction */
 #ifndef BTM_BLE_SCAN_FAST_WIN
@@ -147,15 +147,15 @@ typedef UINT8   tBTM_BLE_SFP;
 
 /* default scan paramter used in reduced power cycle (background scanning) */
 #ifndef BTM_BLE_SCAN_SLOW_INT_1
-#define BTM_BLE_SCAN_SLOW_INT_1    512    /* 1.28 s   = 2048 *0.625 */
+#define BTM_BLE_SCAN_SLOW_INT_1    2048    /* 1.28 s   = 2048 *0.625 */
 #endif
 #ifndef BTM_BLE_SCAN_SLOW_WIN_1
-#define BTM_BLE_SCAN_SLOW_WIN_1   18      /* 30 ms = 48 *0.625 */
+#define BTM_BLE_SCAN_SLOW_WIN_1   48      /* 30 ms = 48 *0.625 */
 #endif
 
 /* default scan paramter used in reduced power cycle (background scanning) */
 #ifndef BTM_BLE_SCAN_SLOW_INT_2
-#define BTM_BLE_SCAN_SLOW_INT_2    512    /* 2.56 s   = 4096 *0.625 */
+#define BTM_BLE_SCAN_SLOW_INT_2    4096    /* 2.56 s   = 4096 *0.625 */
 #endif
 #ifndef BTM_BLE_SCAN_SLOW_WIN_2
 #define BTM_BLE_SCAN_SLOW_WIN_2   36      /* 22.5 ms = 36 *0.625 */
@@ -178,7 +178,7 @@ typedef UINT8   tBTM_BLE_SFP;
 
 /* default supervision timeout */
 #ifndef BTM_BLE_CONN_TIMEOUT_DEF
-#define BTM_BLE_CONN_TIMEOUT_DEF    1000
+#define BTM_BLE_CONN_TIMEOUT_DEF    2000
 #endif
 
 /* minimum acceptable connection interval */
diff --git a/bt/stack/l2cap/l2c_ble.c b/bt/stack/l2cap/l2c_ble.c
index a5cfb4d..3186ece 100644
--- a/bt/stack/l2cap/l2c_ble.c
+++ b/bt/stack/l2cap/l2c_ble.c
@@ -632,8 +632,8 @@ void l2cble_process_sig_cmd (tL2C_LCB *p_lcb, UINT8 *p, UINT16 pkt_len)
             /* If we are a master, the slave wants to update the parameters */
             if (p_lcb->link_role == HCI_ROLE_MASTER)
             {
-                if (min_interval < BTM_BLE_CONN_INT_MIN_LIMIT)
-                    min_interval = BTM_BLE_CONN_INT_MIN_LIMIT;
+                /*if (min_interval < BTM_BLE_CONN_INT_MIN_LIMIT)
+                    min_interval = BTM_BLE_CONN_INT_MIN_LIMIT;*/
 
                 if (min_interval < BTM_BLE_CONN_INT_MIN || min_interval > BTM_BLE_CONN_INT_MAX ||
                     max_interval < BTM_BLE_CONN_INT_MIN || max_interval > BTM_BLE_CONN_INT_MAX ||
diff --git a/bt/test/bluedroidtest/bluedroidtest.c b/bt/test/bluedroidtest/bluedroidtest.c
index ac727d8..022738a 100644
--- a/bt/test/bluedroidtest/bluedroidtest.c
+++ b/bt/test/bluedroidtest/bluedroidtest.c
@@ -560,7 +560,7 @@ void bdt_enable(void)
         bdt_log("Bluetooth is already enabled");
         return;
     }
-    status = sBtInterface->enable();
+    status = sBtInterface->enable(false);
 
     check_return_status(status);
 }
diff --git a/bt/test/suite/cases/adapter.c b/bt/test/suite/cases/adapter.c
index 280cfc6..4fcf6b9 100644
--- a/bt/test/suite/cases/adapter.c
+++ b/bt/test/suite/cases/adapter.c
@@ -24,7 +24,7 @@
 bool adapter_enable_disable() {
   int error;
 
-  CALL_AND_WAIT(error = bt_interface->enable(), adapter_state_changed);
+  CALL_AND_WAIT(error = bt_interface->enable(false), adapter_state_changed);
   TASSERT(error == BT_STATUS_SUCCESS, "Error enabling Bluetooth: %d", error);
   TASSERT(adapter_get_state() == BT_STATE_ON, "Adapter did not turn on.");
 
diff --git a/bt/test/suite/main.c b/bt/test/suite/main.c
index 24cb862..4f4ad1e 100644
--- a/bt/test/suite/main.c
+++ b/bt/test/suite/main.c
@@ -228,7 +228,7 @@ int main(int argc, char **argv) {
   for (size_t i = 0; i < test_suite_size; ++i) {
     if (!test_name || !strcmp(test_name, test_suite[i].function_name)) {
       callbacks_init();
-      CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+      CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
       if (test_suite[i].function()) {
         printf("[%4d] %-64s [%sPASS%s]\n", ++case_num, test_suite[i].function_name, GREEN, DEFAULT);
         ++pass;
diff --git a/bt/test/suite/support/callbacks.h b/bt/test/suite/support/callbacks.h
index e01de39..2ef3515 100644
--- a/bt/test/suite/support/callbacks.h
+++ b/bt/test/suite/support/callbacks.h
@@ -20,12 +20,14 @@
 
 #include "base.h"
 
+#include <errno.h>
 #include <semaphore.h>
+#include <unistd.h>
 
 #define WAIT(callback) \
   do { \
     sem_t *semaphore = callbacks_get_semaphore(#callback); \
-    sem_wait(semaphore); \
+    TEMP_FAILURE_RETRY(sem_wait(semaphore)); \
   } while (0)
 
 #define CALL_AND_WAIT(expression, callback) \
@@ -33,7 +35,7 @@
     sem_t *semaphore = callbacks_get_semaphore(#callback); \
     while (!sem_trywait(semaphore)); \
     expression; \
-    sem_wait(semaphore); \
+    TEMP_FAILURE_RETRY(sem_wait(semaphore)); \
   } while(0)
 
 // To be called from every exit point of the callback. This macro
diff --git a/bt/tools/bdtool/bdtool.c b/bt/tools/bdtool/bdtool.c
index d0d0cc7..81c05c4 100644
--- a/bt/tools/bdtool/bdtool.c
+++ b/bt/tools/bdtool/bdtool.c
@@ -99,7 +99,7 @@ int main(int argc, char **argv) {
   }
 
   if (discover) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, "BT adapter is up\n");
 
     fprintf(stdout, "Starting to start discovery\n");
@@ -114,7 +114,7 @@ int main(int argc, char **argv) {
   }
 
   if (discoverable) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, "BT adapter is up\n");
 
     bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
@@ -133,7 +133,7 @@ int main(int argc, char **argv) {
       exit(1);
     }
 
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, "BT adapter is up\n");
 
     int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0 /* UNKNOWN; Currently not documented :( */);
@@ -143,7 +143,7 @@ int main(int argc, char **argv) {
   }
 
   if (up) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, "BT adapter is up\n");
 
     fprintf(stdout, "Waiting for %d seconds\n", timeout_in_sec);
@@ -151,7 +151,7 @@ int main(int argc, char **argv) {
   }
 
   if (get_name) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, "BT adapter is up\n");
     int error;
     CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
@@ -168,7 +168,7 @@ int main(int argc, char **argv) {
   }
 
   if (set_name) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, "BT adapter is up\n");
 
     bt_property_t *property = property_new_name(bd_name);
@@ -189,7 +189,7 @@ int main(int argc, char **argv) {
   }
 
   if (sco_listen) {
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, "BT adapter is up\n");
 
     bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
@@ -221,7 +221,7 @@ int main(int argc, char **argv) {
       exit(1);
     }
 
-    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, "BT adapter is up\n");
 
     const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);
diff --git a/bt/tools/hci/main.c b/bt/tools/hci/main.c
index fc433bc..97fbef1 100644
--- a/bt/tools/hci/main.c
+++ b/bt/tools/hci/main.c
@@ -1,3 +1,4 @@
+#include <errno.h>
 #include <hardware/bluetooth.h>
 #include <netinet/in.h>
 #include <stdio.h>
@@ -149,16 +150,16 @@ static bool write_hci_command(hci_packet_t type, const void *packet, size_t leng
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = htonl(0x7F000001);
   addr.sin_port = htons(8873);
-  if (connect(sock, (const struct sockaddr *)&addr, sizeof(addr)) == -1)
+  if (TEMP_FAILURE_RETRY(connect(sock, (const struct sockaddr *)&addr, sizeof(addr))) == -1)
     goto error;
 
-  if (send(sock, &type, 1, 0) != 1)
+  if (TEMP_FAILURE_RETRY(send(sock, &type, 1, 0)) != 1)
     goto error;
 
-  if (send(sock, &length, 2, 0) != 2)
+  if (TEMP_FAILURE_RETRY(send(sock, &length, 2, 0)) != 2)
     goto error;
 
-  if (send(sock, packet, length, 0) != (ssize_t)length)
+  if (TEMP_FAILURE_RETRY(send(sock, packet, length, 0)) != (ssize_t)length)
     goto error;
 
   close(sock);
diff --git a/bt/udrv/ulinux/uipc.c b/bt/udrv/ulinux/uipc.c
index f3c746e..5a94d73 100644
--- a/bt/udrv/ulinux/uipc.c
+++ b/bt/udrv/ulinux/uipc.c
@@ -184,7 +184,7 @@ static int accept_server_socket(int sfd)
     pfd.fd = sfd;
     pfd.events = POLLIN;
 
-    if (poll(&pfd, 1, 0) == 0)
+    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 0)) == 0)
     {
         BTIF_TRACE_EVENT("accept poll timeout");
         return -1;
@@ -192,7 +192,7 @@ static int accept_server_socket(int sfd)
 
     //BTIF_TRACE_EVENT("poll revents 0x%x", pfd.revents);
 
-    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
+    if ((fd = TEMP_FAILURE_RETRY(accept(sfd, (struct sockaddr *)&remote, &len))) == -1)
     {
          BTIF_TRACE_ERROR("sock accept failed (%s)", strerror(errno));
          return -1;
@@ -330,7 +330,7 @@ static void uipc_check_interrupt_locked(void)
     {
         char sig_recv = 0;
         //BTIF_TRACE_EVENT("UIPC INTERRUPT");
-        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
+        TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
     }
 }
 
@@ -338,7 +338,7 @@ static inline void uipc_wakeup_locked(void)
 {
     char sig_on = 1;
     BTIF_TRACE_EVENT("UIPC SEND WAKE UP");
-    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);
+    TEMP_FAILURE_RETRY(send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0));
 }
 
 static int uipc_setup_server_locked(tUIPC_CH_ID ch_id, char *name, tUIPC_RCV_CBACK *cback)
@@ -394,7 +394,7 @@ static void uipc_flush_ch_locked(tUIPC_CH_ID ch_id)
 
     while (1)
     {
-        ret = poll(&pfd, 1, 1);
+        ret = TEMP_FAILURE_RETRY(poll(&pfd, 1, 1));
         BTIF_TRACE_VERBOSE("%s() - polling fd %d, revents: 0x%x, ret %d",
                 __FUNCTION__, pfd.fd, pfd.revents, ret);
 
@@ -412,7 +412,7 @@ static void uipc_flush_ch_locked(tUIPC_CH_ID ch_id)
 
         /* read sufficiently large buffer to ensure flush empties socket faster than
            it is getting refilled */
-        read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE);
+        TEMP_FAILURE_RETRY(read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE));
     }
 }
 
@@ -502,7 +502,7 @@ static void uipc_read_task(void *arg)
     {
         uipc_main.read_set = uipc_main.active_set;
 
-        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);
+        result = TEMP_FAILURE_RETRY(select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL));
 
         if (result == 0)
         {
@@ -715,7 +715,7 @@ BOOLEAN UIPC_Send(tUIPC_CH_ID ch_id, UINT16 msg_evt, UINT8 *p_buf,
 
     UIPC_LOCK();
 
-    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)
+    if (TEMP_FAILURE_RETRY(write(uipc_main.ch[ch_id].fd, p_buf, msglen)) < 0)
     {
         BTIF_TRACE_ERROR("failed to write (%s)", strerror(errno));
     }
@@ -784,7 +784,7 @@ UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UINT32 len)
 
         /* make sure there is data prior to attempting read to avoid blocking
            a read for more than poll timeout */
-        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)
+        if (TEMP_FAILURE_RETRY(poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms)) == 0)
         {
             BTIF_TRACE_EVENT("poll timeout (%d ms)", uipc_main.ch[ch_id].read_poll_tmo_ms);
             break;
@@ -801,7 +801,7 @@ UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UINT32 len)
             return 0;
         }
 
-        n = recv(fd, p_buf+n_read, len-n_read, 0);
+        n = TEMP_FAILURE_RETRY(recv(fd, p_buf+n_read, len-n_read, 0));
 
         //BTIF_TRACE_EVENT("read %d bytes", n);
 
diff --git a/core/init/builtins.cpp b/core/init/builtins.cpp
index b4aba4c..771dd2f 100755
--- a/core/init/builtins.cpp
+++ b/core/init/builtins.cpp
@@ -855,7 +855,9 @@ int do_confirm_formated(int nargs, char **args) {
     char dev[128];
     char mountpoint[128];
 
-    if ( nargs != 4 ) {
+    unsigned block_size, bytes_per_inode;
+
+    if ( (nargs != 4) && (nargs != 6) ) {
         ERROR("do_confirm_formated nargs is not valid, nargs:%d\n", nargs);
         return -1;
     }
@@ -863,13 +865,26 @@ int do_confirm_formated(int nargs, char **args) {
     strcpy( dev, args[2] );
     strcpy( mountpoint, args[3]);
 
+    if (nargs == 6) {
+        ERROR("blocksize %s, bytes_per_inode %s\n", args[4], args[5]);
+        block_size = (unsigned) atoi(args[4]);
+        if ((block_size % 1024 != 0) || block_size > 8192)
+            block_size = 4096;
+        bytes_per_inode = (unsigned) atoi(args[5]);
+        if (bytes_per_inode < block_size)
+            bytes_per_inode = block_size;
+    }
     if ( !strncmp( args[1], "ext4", 4 ) ) {
         ERROR("do_confirm_formated ext4 try mount\n");
         int result = mount(dev, mountpoint, "ext4", flags, options);
         if ( result != 0 ) {
             ERROR("do_confirm_formated mount fail,maybe firstboot, need format, try format now, dev:%s, mountpoint:%s\n", dev, mountpoint);
             int fd = -1;
-            result = make_ext4fs(dev, 0, mountpoint, sehandle);
+            if (nargs == 4)
+                result = make_ext4fs(dev, 0, mountpoint, sehandle);
+            else
+                result = make_ext4fs_bisize(dev, 0, mountpoint, sehandle,
+                    block_size, bytes_per_inode);
 
             if (result != 0) {
                 ERROR("do_confirm_formated mount make_extf4fs fail on %s, err[%s]\n", dev, strerror(errno));
diff --git a/core/init/init_parser.cpp b/core/init/init_parser.cpp
index 9da3164..0b24d74 100755
--- a/core/init/init_parser.cpp
+++ b/core/init/init_parser.cpp
@@ -131,6 +131,7 @@ static int lookup_keyword(const char *s)
         if (!strcmp(s, "hmod")) return K_chmod;
         if (!strcmp(s, "ritical")) return K_critical;
         if (!strcmp(s, "onfirm_formated")) return K_confirm_formated;
+        if (!strcmp(s, "onfirm_formated_ext")) return K_confirm_formated_ext;
         break;
     case 'd':
         if (!strcmp(s, "isabled")) return K_disabled;
diff --git a/core/init/keywords.h b/core/init/keywords.h
index 7f942b3..4e78a4c 100644
--- a/core/init/keywords.h
+++ b/core/init/keywords.h
@@ -103,6 +103,7 @@ enum {
     KEYWORD(write,       COMMAND, 2, do_write)
     KEYWORD(writepid,    OPTION,  0, 0)
     KEYWORD(confirm_formated,      COMMAND, 3, do_confirm_formated)
+    KEYWORD(confirm_formated_ext,      COMMAND, 5, do_confirm_formated)
 #ifdef __MAKE_KEYWORD_ENUM__
     KEYWORD_COUNT,
 };
diff --git a/core/init/property_service.cpp b/core/init/property_service.cpp
index a5dd02d..b48e8f2 100644
--- a/core/init/property_service.cpp
+++ b/core/init/property_service.cpp
@@ -229,12 +229,8 @@ static int property_set_impl(const char* name, const char* value) {
         }
     }
 
-    if ( strncmp("sys.boot_completed", name, strlen("sys.boot_completed")) == 0 &&
-        strcmp("1", value) == 0 ) {
-        clear_firstboot_flag();
-    }
     /* If name starts with "net." treat as a DNS property. */
-    else if (strncmp("net.", name, strlen("net.")) == 0)  {
+    if (strncmp("net.", name, strlen("net.")) == 0)  {
         if (strcmp("net.change", name) == 0) {
             return 0;
         }
diff --git a/core/init/util.cpp b/core/init/util.cpp
index 9178fcf..9c8dcaa 100644
--- a/core/init/util.cpp
+++ b/core/init/util.cpp
@@ -464,17 +464,6 @@ int restorecon_recursive(const char* pathname)
     return selinux_android_restorecon(pathname, SELINUX_ANDROID_RESTORECON_RECURSE);
 }
 
-//if boot completed, we should clear first boot flag if it is the first boot
-void clear_firstboot_flag() {
-    bootenv_init();
-    const char* first_boot = bootenv_get("ubootenv.var.firstboot");
-    if ( first_boot && ( strcmp(first_boot, "1") == 0 ) ) {
-        ERROR("clear_firstboot_flag first_boot:%s, clear it to 0\n", first_boot);
-        if ( bootenv_update("ubootenv.var.firstboot", "0") < 0 ) {
-            ERROR("clear_firstboot_flag set firstboot to 0 fail\n");
-        }
-    }
-}
 /*
  * Writes hex_len hex characters (1/2 byte) to hex from bytes.
  */
diff --git a/core/init/util.h b/core/init/util.h
index d7fd0e0..09d64cd 100644
--- a/core/init/util.h
+++ b/core/init/util.h
@@ -62,6 +62,5 @@ void import_kernel_cmdline(bool in_qemu, std::function<void(char*,bool)>);
 int make_dir(const char *path, mode_t mode);
 int restorecon(const char *pathname);
 int restorecon_recursive(const char *pathname);
-void clear_firstboot_flag();
 std::string bytes_to_hex(const uint8_t *bytes, size_t bytes_len);
 #endif
diff --git a/core/libnetutils/dhcp_utils.c b/core/libnetutils/dhcp_utils.c
index bceeb0b..be388f9 100755
--- a/core/libnetutils/dhcp_utils.c
+++ b/core/libnetutils/dhcp_utils.c
@@ -258,7 +258,7 @@ int dhcp_start(const char *interface)
     }
 
     /* Wait for the daemon to return a result */
-    if (wait_for_property(result_prop_name, result_status, 90) < 0) {
+    if (wait_for_property(result_prop_name, result_status, 180) < 0) {
         snprintf(errmsg, sizeof(errmsg), "%s", "Timed out waiting for DHCP to finish");
         return -1;
     }
diff --git a/core/libnetutils/ifc_utils.c b/core/libnetutils/ifc_utils.c
index 7d2a5fb..ade1ce7 100644
--- a/core/libnetutils/ifc_utils.c
+++ b/core/libnetutils/ifc_utils.c
@@ -174,7 +174,8 @@ int ifc_get_hwaddr(const char *name, void *ptr)
     int r;
     struct ifreq ifr;
     ifc_init_ifr(name, &ifr);
-
+    if (ifc_ctl_sock == -1)
+       ifc_init();
     r = ioctl(ifc_ctl_sock, SIOCGIFHWADDR, &ifr);
     if(r < 0) return -1;
 
@@ -187,7 +188,8 @@ int ifc_get_ifindex(const char *name, int *if_indexp)
     int r;
     struct ifreq ifr;
     ifc_init_ifr(name, &ifr);
-
+    if (ifc_ctl_sock == -1)
+       ifc_init();
     r = ioctl(ifc_ctl_sock, SIOCGIFINDEX, &ifr);
     if(r < 0) return -1;
 
@@ -200,6 +202,8 @@ static int ifc_set_flags(const char *name, unsigned set, unsigned clr)
     struct ifreq ifr;
     ifc_init_ifr(name, &ifr);
 
+    if (ifc_ctl_sock == -1)
+        ifc_init();
     if(ioctl(ifc_ctl_sock, SIOCGIFFLAGS, &ifr) < 0) return -1;
     ifr.ifr_flags = (ifr.ifr_flags & (~clr)) | set;
     return ioctl(ifc_ctl_sock, SIOCSIFFLAGS, &ifr);
@@ -234,7 +238,8 @@ int ifc_set_addr(const char *name, in_addr_t addr)
 
     ifc_init_ifr(name, &ifr);
     init_sockaddr_in(&ifr.ifr_addr, addr);
-
+    if (ifc_ctl_sock == -1)
+        ifc_init();
     ret = ioctl(ifc_ctl_sock, SIOCSIFADDR, &ifr);
     if (DBG) printerr("ifc_set_addr(%s, xx) = %d", name, ret);
     return ret;
@@ -426,6 +431,8 @@ int ifc_set_hwaddr(const char *name, const void *ptr)
 
     ifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;
     memcpy(&ifr.ifr_hwaddr.sa_data, ptr, ETH_ALEN);
+    if (ifc_ctl_sock == -1)
+        ifc_init();
     return ioctl(ifc_ctl_sock, SIOCSIFHWADDR, &ifr);
 }
 
@@ -436,7 +443,8 @@ int ifc_set_mask(const char *name, in_addr_t mask)
 
     ifc_init_ifr(name, &ifr);
     init_sockaddr_in(&ifr.ifr_addr, mask);
-
+    if (ifc_ctl_sock == -1)
+        ifc_init();
     ret = ioctl(ifc_ctl_sock, SIOCSIFNETMASK, &ifr);
     if (DBG) printerr("ifc_set_mask(%s, xx) = %d", name, ret);
     return ret;
@@ -452,6 +460,8 @@ int ifc_set_prefixLength(const char *name, int prefixLength)
     ifc_init_ifr(name, &ifr);
     init_sockaddr_in(&ifr.ifr_addr, mask);
 
+    if (ifc_ctl_sock == -1)
+        ifc_init();
     return ioctl(ifc_ctl_sock, SIOCSIFNETMASK, &ifr);
 }
 
@@ -462,6 +472,8 @@ int ifc_get_addr(const char *name, in_addr_t *addr)
 
     ifc_init_ifr(name, &ifr);
     if (addr != NULL) {
+        if (ifc_ctl_sock == -1)
+            ifc_init();
         ret = ioctl(ifc_ctl_sock, SIOCGIFADDR, &ifr);
         if (ret < 0) {
             *addr = 0;
@@ -476,7 +488,8 @@ int ifc_get_info(const char *name, in_addr_t *addr, int *prefixLength, unsigned
 {
     struct ifreq ifr;
     ifc_init_ifr(name, &ifr);
-
+    if (ifc_ctl_sock == -1)
+        ifc_init();
     if (addr != NULL) {
         if(ioctl(ifc_ctl_sock, SIOCGIFADDR, &ifr) < 0) {
             *addr = 0;
diff --git a/core/logcat/logcat.cpp b/core/logcat/logcat.cpp
index 00b7379..0d3e8e5 100644
--- a/core/logcat/logcat.cpp
+++ b/core/logcat/logcat.cpp
@@ -36,6 +36,12 @@
 #include <log/logprint.h>
 #include <utils/threads.h>
 
+// aml Android Patch Begin
+#include <sys/klog.h>
+#include <cutils/properties.h>
+// aml Android Patch End
+
+#define DEFAULT_LOG_ROTATE_SIZE_KBYTES 16
 #define DEFAULT_MAX_ROTATED_LOGS 4
 
 static AndroidLogFormat * g_logformat;
@@ -76,11 +82,23 @@ static size_t g_outByteCount = 0;
 static int g_printBinary = 0;
 static int g_devCount = 0;                              // >1 means multiple
 
+// aml Android Patch Begin
+static int g_kmsg = 0;
+// aml Android Patch End
 __noreturn static void logcat_panic(bool showHelp, const char *fmt, ...) __printflike(2,3);
 
+//aml patch begin
+static int g_aml_log_filter = 0;
+static char g_aml_filters[100];
+//aml patch end
+
 static int openLogFile (const char *pathname)
 {
-    return open(pathname, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR);
+    char attr[1024] = {0};
+    int ret = open(pathname, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR);
+    sprintf(attr, "chmod 664 %s", pathname);
+    system (attr);
+    return ret;
 }
 
 static void rotateLogs()
@@ -206,6 +224,62 @@ static void maybePrintStart(log_device_t* dev, bool printDividers) {
     }
 }
 
+// aml Android Patch Begin
+static int printKernelBuffer(char *buf, int count) {
+    int bytesWritten = 0;
+    AndroidLogEntry entry;
+    char tag[10]="Kernel";
+    int prio = 0;
+    char *buffer = buf;
+    char *next = NULL;
+    struct timespec ts;
+
+    while (buffer < (buf + count)) {
+        if (buffer[0] != '<') {
+            next = strchr(buffer, '<');
+            if (next == NULL) {
+                next = buf + count;
+            }
+        } else {
+            if (sscanf(buffer, "<%d>", &prio) < 0)
+                break;
+
+            next = strchr(buffer, '\n');
+            if (next == NULL) {
+                next = buf + count;
+            } else {
+                next++;
+            }
+            entry.priority = ANDROID_LOG_INFO;
+        }
+
+        clock_gettime(CLOCK_REALTIME, &ts);
+        entry.tv_sec  = ts.tv_sec;
+        entry.tv_nsec = ts.tv_nsec;
+        entry.pid = 0;
+        entry.tid = 0;
+        entry.tag = tag;
+        entry.messageLen =  next - buffer;
+        entry.message = buffer;
+
+        bytesWritten = android_log_printLogLine(g_logformat, g_outFD, &entry);
+        if (bytesWritten < 0) {
+            perror("output error");
+            exit(-1);
+        }
+        g_outByteCount += bytesWritten;
+        buffer = next;
+    }
+
+
+    if ((g_logRotateSizeKBytes > 0) && ((g_outByteCount/1024) >= g_logRotateSizeKBytes)) {
+        rotateLogs();
+    }
+
+    return bytesWritten;
+}
+// aml Android Patch End
+
 static void setupOutput()
 {
 
@@ -271,6 +345,10 @@ static void show_help(const char *cmd)
                     "                  count is pure numerical, time is 'MM-DD hh:mm:ss.mmm'\n"
                     "  -g              get the size of the log's ring buffer and exit\n"
                     "  -L              dump logs from prior to last reboot\n"
+                    // aml Android Patch Begin
+                    "  -K              dump kernel log by klogctl, this operation need super user\n"
+                    "                  permission.\n"
+                    // aml Android Patch End
                     "  -b <buffer>     Request alternate ring buffer, 'main', 'system', 'radio',\n"
                     "                  'events', 'crash' or 'all'. Multiple -b parameters are\n"
                     "                  allowed and results are interleaved. The default is\n"
@@ -491,9 +569,9 @@ int main(int argc, char **argv)
 
     for (;;) {
         int ret;
-
-        ret = getopt(argc, argv, ":cdDLt:T:gG:sQf:r:n:v:b:BSpP:");
-
+        // aml Android Patch Begin
+        ret = getopt(argc, argv, ":cdDLt:T:gG:sQf:r:n:v:b:BSpP:KM");
+        // aml Android Patch End
         if (ret < 0) {
             break;
         }
@@ -554,6 +632,12 @@ int main(int argc, char **argv)
                 getLogSize = 1;
             break;
 
+            // aml Android Patch Begin
+            case 'K':
+                android::g_kmsg = 1;
+            break;
+            // aml Android Patch End
+
             case 'G': {
                 char *cp;
                 if (strtoll(optarg, &cp, 0) > 0) {
@@ -747,7 +831,14 @@ int main(int argc, char **argv)
             case 'S':
                 printStatistics = 1;
                 break;
-
+            case 'M'://aml patch
+                /* this is a *hidden* option used to log output control for aml
+                    don't use property, maybe property system not ready here*/
+                {
+                    android::g_aml_log_filter = 1;
+                    strcpy(android::g_aml_filters,"*:V");
+                }
+                break;
             case ':':
                 logcat_panic(true, "Option -%c needs an argument\n", optopt);
                 break;
@@ -840,6 +931,9 @@ int main(int argc, char **argv)
             if (ret) {
                 logcat_panic(false, "failed to clear the log");
             }
+            // aml Android Patch Begin
+            klogctl(KLOG_CLEAR, 0, 0);
+            // aml Android Patch End
         }
 
         if (setLogSize && android_logger_set_log_size(dev->logger, setLogSize)) {
@@ -956,7 +1050,73 @@ int main(int argc, char **argv)
 
     dev = NULL;
     log_device_t unexpected("unexpected", false);
+
+    // aml Android Patch Begin
+    if (android::g_kmsg) {
+        char *kernelBuf = NULL;
+        int ret, klogBufLen;
+
+        klogBufLen = klogctl(KLOG_SIZE_UNREAD, 0, 0);
+        if (klogBufLen == 0) {
+            /*
+            * buffer len is zero means this is not the first time to invoke logcat
+            * but we need to get kernel log that read last time. so read all log here.
+            */
+            klogBufLen = klogctl(KLOG_SIZE_BUFFER, 0, 0);
+            kernelBuf = (char *)malloc(klogBufLen + 1);
+            if ((ret = klogctl(KLOG_READ_ALL, kernelBuf, klogBufLen)) > 0) {
+                kernelBuf[ret] = '\n';
+                if (android::printKernelBuffer(kernelBuf, ret) < 0) {
+                    perror ("write kernel log error");
+                }
+            }
+        } else {
+            kernelBuf = (char *)malloc(klogBufLen + 1);
+            if ((ret = klogctl(KLOG_READ, kernelBuf, klogBufLen)) > 0) {
+                kernelBuf[ret] = '\n';
+                if (android::printKernelBuffer(kernelBuf, ret) < 0) {
+                    perror ("write kernel log error");
+                }
+            }
+        }
+
+        if (NULL != kernelBuf)
+            free(kernelBuf);
+    }
+    // aml Android Patch End
+
+    int filterLoop = 0;
     while (1) {
+        // aml Android Patch Begin
+        if (android::g_kmsg) {
+            int ret = 0;
+            char kernelBuf[1024] = {0};
+            if ((ret = klogctl(KLOG_SIZE_UNREAD, kernelBuf, sizeof(kernelBuf))) > 0) {
+                if ((ret = klogctl(KLOG_READ, kernelBuf, sizeof(kernelBuf))) > 0) {
+                    if (android::printKernelBuffer(kernelBuf, ret) < 0) {
+                        perror("write kernel log error");
+                    }
+                }
+            }
+        }
+        // aml Android Patch End
+
+        if (android::g_aml_log_filter == 1) {
+            filterLoop++;
+            if (filterLoop > 50) {
+                filterLoop = 0;
+                char contents[100];
+                property_get("persist.sys.logcat.filter", contents, "*:V");
+                if (strcmp(android::g_aml_filters, contents) != 0) {
+                    char FilterChange[100];
+                    snprintf(FilterChange, sizeof(FilterChange), "aml logcat filter change from %s to %s\n", android::g_aml_filters, contents);
+                    android::printKernelBuffer(FilterChange, strlen(FilterChange)+1);
+                    strcpy(android::g_aml_filters, contents);
+                    android_log_addFilterString(g_logformat, contents);
+                }
+            }
+        }
+
         struct log_msg log_msg;
         log_device_t* d;
         int ret = android_logger_list_read(logger_list, &log_msg);
diff --git a/core/rootdir/init.rc b/core/rootdir/init.rc
index c0bbfde..8ac71f2 100644
--- a/core/rootdir/init.rc
+++ b/core/rootdir/init.rc
@@ -54,7 +54,6 @@ on init
     mkdir /data 0771 system system
     mkdir /cache 0770 system cache
     mkdir /config 0500 root root
-    mkdir /ghost 0777 system system
 
     # Mount staging areas for devices managed by vold
     # See storage config details at http://source.android.com/tech/storage/
@@ -183,9 +182,6 @@ on init
     chmod 0664 /dev/cpuset/system-background/tasks
     chmod 0664 /dev/cpuset/tasks
 
-    # add by Elric Fu 
-    chown system system /ghost
-    chmod 0777 /ghost
 
     # qtaguid will limit access to specific data based on group memberships.
     #   net_bw_acct grants impersonation of socket owners.
@@ -556,6 +552,11 @@ on property:sys.sysctl.extra_free_kbytes=*
 on property:sys.sysctl.tcp_def_init_rwnd=*
     write /proc/sys/net/ipv4/tcp_default_init_rwnd ${sys.sysctl.tcp_def_init_rwnd}
 
+on property:security.perf_harden=0
+    write /proc/sys/kernel/perf_event_paranoid 1
+
+on property:security.perf_harden=1
+    write /proc/sys/kernel/perf_event_paranoid 3
 
 ## Daemon processes to be run by init.
 ##
@@ -668,7 +669,7 @@ service drm /system/bin/drmserver
 service media /system/bin/mediaserver
     class main
     user media
-    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm
+    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm sdcard_r sdcard_rw
     ioprio rt 4
 
 # One shot invocation to deal with encrypted volume.
@@ -769,8 +770,3 @@ service logcatd /system/bin/logcat -b all -v threadtime -v usec -v printable -D
     user logd
     group log
     writepid /dev/cpuset/system-background/tasks
-
-service execmd /system/bin/execmd.sh
-    class main
-    group root root
-    oneshot
\ No newline at end of file
diff --git a/core/sdcard/sdcard.c b/core/sdcard/sdcard.c
index 143ae89..291fb4f 100644
--- a/core/sdcard/sdcard.c
+++ b/core/sdcard/sdcard.c
@@ -41,6 +41,7 @@
 #include <cutils/hashmap.h>
 #include <cutils/log.h>
 #include <cutils/multiuser.h>
+#include <cutils/properties.h>
 
 #include <private/android_filesystem_config.h>
 
@@ -77,6 +78,7 @@
  */
 
 #define FUSE_TRACE 0
+#define LIMIT_SDCARD_SIZE
 
 #if FUSE_TRACE
 #define TRACE(x...) ALOGD(x)
@@ -103,6 +105,10 @@
  * or that a reply has already been written. */
 #define NO_STATUS 1
 
+#ifdef LIMIT_SDCARD_SIZE
+__u64 internal_sdcard_free_size_threshold = 100 * 1024 * 1024;
+#endif
+
 /* Path to system-provided mapping of package name to appIds */
 static const char* const kPackagesListFile = "/data/system/packages.list";
 
@@ -233,6 +239,10 @@ struct fuse {
 
     gid_t gid;
     mode_t mask;
+
+    #ifdef LIMIT_SDCARD_SIZE
+    __u64 free_size;
+    #endif
 };
 
 /* Private data used by a single FUSE handler */
@@ -1268,6 +1278,29 @@ static int handle_write(struct fuse* fuse, struct fuse_handler* handler,
 
     TRACE("[%d] WRITE %p(%d) %u@%"PRIu64"\n", handler->token,
             h, h->fd, req->size, req->offset);
+    #ifdef LIMIT_SDCARD_SIZE
+    if (!strncmp(fuse->global->source_path, "/data/media", PATH_MAX)) {
+        pthread_mutex_lock(&fuse->global->lock);
+        fuse->free_size -= req->size;
+        pthread_mutex_unlock(&fuse->global->lock);
+
+        if (fuse->free_size <= internal_sdcard_free_size_threshold) {
+            struct statfs stat;
+            if (statfs(fuse->global->source_path, &stat) < 0) {
+                ERROR("get %s fs status fail \n", fuse->global->source_path);
+                fuse->free_size = 0;
+                return -errno;
+            } else {
+                pthread_mutex_lock(&fuse->global->lock);
+                fuse->free_size = stat.f_bfree * stat.f_bsize;
+                pthread_mutex_unlock(&fuse->global->lock);
+            }
+            errno = ENOSPC;
+            TRACE("[fuse_debug]fuse.free_size = %lld, no space for write!\n", fuse->free_size);
+            return -errno;
+        }
+    }
+    #endif
     res = pwrite64(h->fd, buffer, req->size, req->offset);
     if (res < 0) {
         return -errno;
@@ -1908,6 +1941,29 @@ static void run(const char* source_path, const char* label, uid_t uid,
         fs_prepare_dir(global.obb_path, 0775, uid, gid);
     }
 
+    #ifdef LIMIT_SDCARD_SIZE
+    struct statfs stat;
+    char value[PROPERTY_VALUE_MAX];
+    int reserv_size;
+    if (statfs(global.source_path, &stat) < 0) {
+        ERROR("get %s fs status fail \n", global.source_path);
+        fuse_default.free_size = 0;
+        fuse_read.free_size = 0;
+        fuse_write.free_size = 0;
+    } else {
+        fuse_default.free_size = stat.f_bfree * stat.f_bsize;
+        fuse_read.free_size = stat.f_bfree * stat.f_bsize;
+        fuse_write.free_size = stat.f_bfree * stat.f_bsize;
+        TRACE("[fuse_debug]fuse.free_size = %lld \n", fuse_default.free_size);
+    }
+
+    property_get("ro.sdcard.ReservSize", value, "100");
+    if (sscanf(value, "%d", &reserv_size) == 1 && reserv_size > 0) {
+        internal_sdcard_free_size_threshold = reserv_size * 1024 *1024;
+        TRACE("[fuse_debug]ro.sdcard.ReservSize = %d \n", reserv_size);
+    }
+
+    #endif
     if (pthread_create(&thread_default, NULL, start_handler, &handler_default)
             || pthread_create(&thread_read, NULL, start_handler, &handler_read)
             || pthread_create(&thread_write, NULL, start_handler, &handler_write)) {
diff --git a/core/toolbox/lsof.c b/core/toolbox/lsof.c
index 982f5aa..da78ddd 100644
--- a/core/toolbox/lsof.c
+++ b/core/toolbox/lsof.c
@@ -100,10 +100,11 @@ out:
 static void print_maps(struct pid_info_t* info)
 {
     FILE *maps;
+
     size_t offset;
     char device[10];
     long int inode;
-    char file[PATH_MAX];
+    char file[1024];
 
     strlcat(info->path, "maps", sizeof(info->path));
 
@@ -111,8 +112,8 @@ static void print_maps(struct pid_info_t* info)
     if (!maps)
         goto out;
 
-    while (fscanf(maps, "%*x-%*x %*s %zx %s %ld %s\n", &offset, device, &inode,
-            file) == 4) {
+    while (fscanf(maps, "%*x-%*x %*s %zx %5s %ld %1023s\n",
+                  &offset, device, &inode, file) == 4) {
         // We don't care about non-file maps
         if (inode == 0 || !strcmp(device, "00:00"))
             continue;
diff --git a/extras/ext4_utils/ext4_sb.h b/extras/ext4_utils/ext4_sb.h
index 832fa33..8e62796 100644
--- a/extras/ext4_utils/ext4_sb.h
+++ b/extras/ext4_utils/ext4_sb.h
@@ -31,6 +31,7 @@ struct fs_info {
 			 * end of the partition, else use the size given. */
 	uint32_t block_size;
 	uint32_t blocks_per_group;
+	uint32_t bytes_per_inode;
 	uint32_t inodes_per_group;
 	uint32_t inode_size;
 	uint32_t inodes;
diff --git a/extras/ext4_utils/make_ext4fs.c b/extras/ext4_utils/make_ext4fs.c
index 669d080..a07fbb1 100644
--- a/extras/ext4_utils/make_ext4fs.c
+++ b/extras/ext4_utils/make_ext4fs.c
@@ -349,11 +349,16 @@ static u32 compute_blocks_per_group()
 	return info.block_size * 8;
 }
 
-static u32 compute_inodes()
+static u32 compute_inodes_default()
 {
 	return DIV_ROUND_UP(info.len, info.block_size) / 4;
 }
 
+static u32 compute_inodes(uint32_t bytes_per_inode)
+{
+	return DIV_ROUND_UP(info.len, bytes_per_inode);
+}
+
 static u32 compute_inodes_per_group()
 {
 	u32 blocks = DIV_ROUND_UP(info.len, info.block_size);
@@ -428,6 +433,29 @@ int make_ext4fs(const char *filename, long long len,
 	return status;
 }
 
+int make_ext4fs_bisize(const char *filename, long long len,
+				const char *mountpoint, struct selabel_handle *sehnd,
+				uint32_t block_size, uint32_t bytes_per_inode)
+{
+	int fd;
+	int status;
+
+	reset_ext4fs_info();
+	info.len = len;
+	info.block_size = block_size;
+	info.bytes_per_inode = bytes_per_inode;
+
+	fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);
+	if (fd < 0) {
+		error_errno("open");
+		return EXIT_FAILURE;
+	}
+
+	status = make_ext4fs_internal(fd, NULL, NULL, mountpoint, NULL, 0, 0, 0, 1, 0, sehnd, 0, -1, NULL);
+	close(fd);
+
+	return status;
+}
 /* return a newly-malloc'd string that is a copy of str.  The new string
    is guaranteed to have a trailing slash.  If absolute is true, the new string
    is also guaranteed to have a leading slash.
@@ -542,8 +570,10 @@ int make_ext4fs_internal(int fd, const char *_directory, const char *_target_out
 	if (info.blocks_per_group <= 0)
 		info.blocks_per_group = compute_blocks_per_group();
 
-	if (info.inodes <= 0)
-		info.inodes = compute_inodes();
+	if (info.bytes_per_inode <= 0)
+		info.inodes = compute_inodes_default();
+	else
+		info.inodes = compute_inodes(info.bytes_per_inode);
 
 	if (info.inode_size <= 0)
 		info.inode_size = 256;
diff --git a/extras/ext4_utils/make_ext4fs.h b/extras/ext4_utils/make_ext4fs.h
index 3784a9e..5d955e4 100644
--- a/extras/ext4_utils/make_ext4fs.h
+++ b/extras/ext4_utils/make_ext4fs.h
@@ -25,6 +25,9 @@ struct selabel_handle;
 
 int make_ext4fs(const char *filename, long long len,
                 const char *mountpoint, struct selabel_handle *sehnd);
+int make_ext4fs_bisize(const char *filename, long long len,
+				const char *mountpoint, struct selabel_handle *sehnd,
+				unsigned block_size, unsigned bytes_per_inode);
 int make_ext4fs_sparse_fd(int fd, long long len,
                 const char *mountpoint, struct selabel_handle *sehnd);
 
diff --git a/media/audio/include/system/audio.h b/media/audio/include/system/audio.h
index cd123cc..a7749aa 100644
--- a/media/audio/include/system/audio.h
+++ b/media/audio/include/system/audio.h
@@ -1423,6 +1423,8 @@ static inline char *audio_device_address_to_parameter(audio_devices_t device, co
         snprintf(param, kSize, "%s=%s", "a2dp_sink_address", address);
     else if (device & AUDIO_DEVICE_OUT_REMOTE_SUBMIX)
         snprintf(param, kSize, "%s=%s", "mix", address);
+    else if (device & AUDIO_DEVICE_OUT_HDMI_ARC)
+        snprintf(param, kSize, "%s=%s", "hdmi_arc_ad", address);
     else
         snprintf(param, kSize, "%s", address);
 
