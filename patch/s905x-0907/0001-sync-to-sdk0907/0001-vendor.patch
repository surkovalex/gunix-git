diff --git a/amlogic/apps/AppInstaller/src/com/droidlogic/appinstall/main.java b/amlogic/apps/AppInstaller/src/com/droidlogic/appinstall/main.java
index 4427ab5..10ab01a 100644
--- a/amlogic/apps/AppInstaller/src/com/droidlogic/appinstall/main.java
+++ b/amlogic/apps/AppInstaller/src/com/droidlogic/appinstall/main.java
@@ -562,16 +562,14 @@ public class main extends Activity {
         //functions for installing and uninstalling
         public void install_apk (String apk_filepath) {
             Intent installintent = new Intent();
-            installintent.setComponent (new ComponentName ("com.android.packageinstaller", "com.android.packageinstaller.PackageInstallerActivity"));
             installintent.setAction (Intent.ACTION_VIEW);
-            installintent.setData (Uri.fromFile (new File (apk_filepath)));
+            installintent.setDataAndType(Uri.fromFile (new File (apk_filepath)), "application/vnd.android.package-archive");
             startActivity (installintent);
         }
 
         public void uninstall_apk (String apk_pkgname) {
             Intent uninstallintent = new Intent();
-            uninstallintent.setComponent (new ComponentName ("com.android.packageinstaller", "com.android.packageinstaller.UninstallerActivity"));
-            uninstallintent.setAction (Intent.ACTION_VIEW);
+            uninstallintent.setAction (Intent.ACTION_UNINSTALL_PACKAGE);
             uninstallintent.setData (Uri.fromParts ("package", apk_pkgname, null));
             startActivity (uninstallintent);
         }
diff --git a/amlogic/apps/DLNA/Android.mk b/amlogic/apps/DLNA/Android.mk
index 6a3d179..701556f 100644
--- a/amlogic/apps/DLNA/Android.mk
+++ b/amlogic/apps/DLNA/Android.mk
@@ -26,7 +26,7 @@ include $(BUILD_PACKAGE)
 ##############################################
 
 include $(CLEAR_VARS)
-LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := liblebo:libs/LEBO-SDK-3.0.0.1r_external_amlogic.jar \
+LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := liblebo:libs/LEBO-SDK-3.0.0.7r_external_amlogic.jar \
                                         libmid:libs/mid-mid-sdk-2.3.jar \
                                         libmta:libs/mta-android-stat-sdk-2.1.0_20160111.jar \
                                         libandroid-support-v4:libs/android-support-v4.jar \
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/airplay/Photo.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/airplay/Photo.java
index 9da0696..7f2559f 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/airplay/Photo.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/airplay/Photo.java
@@ -94,7 +94,8 @@ public class Photo extends Activity {
         public void onCreate ( Bundle savedInstanceState ) {
             super.onCreate ( savedInstanceState );
             requestWindowFeature ( Window.FEATURE_NO_TITLE );
-            getWindow().setFlags ( WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN );
+            getWindow().setFlags ( WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+            getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON);
             container = new FrameLayout ( this );
             android.view.ViewGroup.LayoutParams lp1 = new LayoutParams ( LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT );
             container.setLayoutParams ( lp1 );
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/airplay/VideoPlayer.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/airplay/VideoPlayer.java
index ca25099..7d20eeb 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/airplay/VideoPlayer.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/airplay/VideoPlayer.java
@@ -110,6 +110,7 @@ public class VideoPlayer extends Activity implements OnBufferingUpdateListener,
             requestWindowFeature ( Window.FEATURE_NO_TITLE );
             getWindow().setFlags ( WindowManager.LayoutParams.FLAG_FULLSCREEN,
                                    WindowManager.LayoutParams.FLAG_FULLSCREEN );
+            getWindow().addFlags(LayoutParams.FLAG_DISMISS_KEYGUARD | LayoutParams.FLAG_TURN_SCREEN_ON);
             getWindow().getDecorView().setSystemUiVisibility (
                 View.SYSTEM_UI_FLAG_LOW_PROFILE );
             // PowerManager pm = (PowerManager)
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/AsynImageLoader.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/AsynImageLoader.java
index 108af16..6b28f06 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/AsynImageLoader.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/AsynImageLoader.java
@@ -28,7 +28,8 @@ public class AsynImageLoader {
     // cache images map loaded
     private Map<String, SoftReference<Bitmap>> caches;
     // task list
-    private List<Task> taskQueue;
+    private HashMap<String,Task> taskQueue;
+    private ArrayList<String> taskQueueName;
     private boolean isRunning = false;
 
     private ImageCallback getImageCallback(final ImageView imageView, final int resId) {
@@ -52,9 +53,10 @@ public class AsynImageLoader {
         public void run() {
             while (isRunning) {
                 // 当队列中还有未处理的任务时，执行下载任务
-                while (taskQueue.size() > 0) {
+                while ( taskQueueName != null && taskQueueName.size() > 0) {
                     // 获取第一个任务，并将之从任务队列中删除
-                    Task task = taskQueue.remove(0);
+                    String key = taskQueueName.remove(0);
+                    Task task = taskQueue.remove(key);
                     task.bitmap = PicUtil.getbitmapAndwrite(task.path);
                     // 将下载的图片添加到缓存
                     caches.put(task.path, new SoftReference<Bitmap>(task.bitmap));
@@ -92,7 +94,8 @@ public class AsynImageLoader {
     public AsynImageLoader() {
         // init
         caches = new HashMap<String, SoftReference<Bitmap>>();
-        taskQueue = new ArrayList<AsynImageLoader.Task>();
+        taskQueue = new HashMap<String,AsynImageLoader.Task>();
+        taskQueueName = new ArrayList<String>();
         isRunning = true;
         new Thread(runnable).start();
     }
@@ -123,7 +126,7 @@ public class AsynImageLoader {
      * @param imageCallback
      * @return
      */
-    private Bitmap loadImageAsyn(String path, ImageCallback imageCallback) {
+    private synchronized Bitmap loadImageAsyn(String path, ImageCallback imageCallback) {
         // 判断缓存中是否已经存在该图片
         if (caches.containsKey(path)) {
             // 取出软引用
@@ -139,13 +142,12 @@ public class AsynImageLoader {
                 return bitmap;
             }
         } else {
-            // 如果缓存中不常在该图片，则创建图片下载任务
-            Task task = new Task();
-            task.path = path;
-            task.callback = imageCallback;
-            Log.d(TAG, "create task," + path);
-            if (!taskQueue.contains(task)) {
-                taskQueue.add(task);
+            if (!taskQueue.containsKey(path)) {
+                Task task = new Task();
+                task.path = path;
+                task.callback = imageCallback;
+                taskQueueName.add(path);
+                taskQueue.put(path,task);
                 // 唤醒任务下载队列
                 synchronized (runnable) {
                     runnable.notify();
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/ImageFromUrl.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/ImageFromUrl.java
index c4d0481..d5fcc40 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/ImageFromUrl.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/ImageFromUrl.java
@@ -54,6 +54,7 @@ import android.view.View.OnFocusChangeListener;
 import android.view.ViewGroup;
 import android.view.Window;
 import android.view.WindowManager;
+import android.view.WindowManager.LayoutParams;
 import android.widget.ImageButton;
 import android.widget.ImageView;
 import android.widget.Toast;
@@ -120,6 +121,7 @@ public class ImageFromUrl extends Activity {
             mShowView = ( ImageView ) findViewById ( R.id.imageview );
             mHandler = new DecodeHandler ( mCurUri );
             mDecodeBitmapTask.start();
+            Debug.d(TAG,"mCurUri:"+mCurUri);
             ViewGroup mainView = ( ViewGroup ) findViewById ( R.id.image_control );
             mainView.setOnClickListener ( new View.OnClickListener() {
                 @Override
@@ -207,7 +209,6 @@ public class ImageFromUrl extends Activity {
             btnLeft.setOnFocusChangeListener ( listener );
             reg = false;
             Intent intent = getIntent();
-            Debug.d ( TAG, "intent!=null" + ( intent != null ) + intent.getStringExtra ( AmlogicCP.EXTRA_MEDIA_URI ) );
             if ( intent != null ) {
                 String url = intent.getStringExtra ( AmlogicCP.EXTRA_MEDIA_URI );
                 Message msg = new Message();
@@ -329,6 +330,7 @@ public class ImageFromUrl extends Activity {
                     //mHandler = null;
                     unregistRec();
                     stopExit();
+                    mSlideShow = SLIDE_UNSTATE;
                     ImageFromUrl.this.finish();
                 }
                 return true;
@@ -394,9 +396,10 @@ public class ImageFromUrl extends Activity {
         @Override
         protected void onResume() {
             super.onResume();
+            getWindow().addFlags(LayoutParams.FLAG_DISMISS_KEYGUARD | LayoutParams.FLAG_TURN_SCREEN_ON);
             isShowingForehand = true;
-            mHandler.removeMessages ( STOP_BY_SEVER );
-            mHandler.sendEmptyMessageDelayed ( STOP_BY_SEVER, 5000 );
+            //mHandler.removeMessages ( STOP_BY_SEVER );
+            //mHandler.sendEmptyMessageDelayed ( STOP_BY_SEVER, 5000 );
             if ( isBrowserMode ) {
                 mHandler.sendEmptyMessageDelayed ( HIDEPANEL, STOP_SHOW_INTERVAL );
             }
@@ -419,7 +422,7 @@ public class ImageFromUrl extends Activity {
             stopExit();
             isShowingForehand = false;
             hideLoading();
-            mSlideShow = SLIDE_STOP;
+            mSlideShow = SLIDE_UNSTATE;
             if ( mCurUri != null ) {
                 mCurUri.setUrl ( null );
             }
@@ -432,6 +435,20 @@ public class ImageFromUrl extends Activity {
             mWakeLock.release();
         }
 
+        @Override
+        protected void onStop() {
+            super.onStop();
+            Debug.d(TAG,"onStop");
+            if ( mHandler != null ) {
+                mHandler = null;
+            }
+            if ( mCurUri != null ) {
+                mCurUri = null;
+            }
+            if ( mDecodeBitmapTask != null ) {
+                mDecodeBitmapTask = null;
+            }
+        }
 
         class ImageFromUrlReceiver extends BroadcastReceiver {
                 /*
@@ -465,6 +482,7 @@ public class ImageFromUrl extends Activity {
                         }
                         msg.what = LOADING_URL_IMAG;
                         msg.obj = url;
+                        mHandler.removeMessages(LOADING_URL_IMAG);
                         mHandler.sendMessage ( msg );
                         return;
                     } else if ( action.equals ( AmlogicCP.UPNP_STOP_ACTION ) ) {
@@ -515,10 +533,12 @@ public class ImageFromUrl extends Activity {
                                     Intent playIntent = new Intent(MediaRendererDevice.PLAY_STATE_PLAYING);
                                     ImageFromUrl.this.sendBroadcast(playIntent);
                                     if ( mHandler != null ) {
-                                        Message msg = Message.obtain();
+                                        mHandler.removeMessages(SHOW_BITMAP_URL);
+                                        Message msg = new Message();
                                         msg.what = SHOW_BITMAP_URL;
                                         msg.obj = urlString;
                                         mHandler.sendMessage(msg);
+                                        Debug.d(TAG,"SHOW_BITMAP_URL"+urlString);
                                     }
                                     connection.disconnect();
                                 }
@@ -613,16 +633,18 @@ public class ImageFromUrl extends Activity {
         }
 
         private void showImage() {
+             Debug.d(TAG,"showImage showMap:"+mSlideShow);
             if ( mSlideShow == SLIDE_STOP ) {
                 hideLoading();
                 return;
             }
-            Debug.d(TAG,"showImage showMap:"+System.currentTimeMillis());
+            Debug.d(TAG,"showImage showMap:"+System.currentTimeMillis()+"-"+(myBitmap != null));
             if ( myBitmap != null ) {
                 zoomCount = 1;
                 int height = myBitmap.getHeight();
                 int width = myBitmap.getWidth();
                 float reSize = 1.0f;
+                Debug.d(TAG,"showImage showMap:"+height+"-"+width);
                 if ( width > TOPSIZE || height > TOPSIZE ) {
                     if ( height > width ) {
                         reSize = TOPSIZE / height;
@@ -633,8 +655,10 @@ public class ImageFromUrl extends Activity {
                     matrix.postScale ( reSize, reSize );
                     myBitmap = Bitmap.createBitmap ( myBitmap, 0, 0, width,
                                                      height, matrix, true );
+                    Debug.d(TAG,"showImage showMap:"+(myBitmap==null));
                     mShowView.setImageBitmap ( myBitmap );
                 } else {
+                    Debug.d(TAG,"showImage showMa==========");
                     mShowView.setImageBitmap ( myBitmap );
                 }
                 //myBitmap = null;
@@ -674,6 +698,7 @@ public class ImageFromUrl extends Activity {
 
                 @Override
                 public void handleMessage ( Message msg ) {
+                    Debug.d (TAG,"handleMessage msg:"+msg.what);
                     switch ( msg.what ) {
                         case LOADING_URL_IMAG:
                             stopExit();
@@ -686,7 +711,7 @@ public class ImageFromUrl extends Activity {
                             }
                             break;
                         case SHOW_BITMAP_URL:
-                            hideLoading();
+                            //hideLoading();
                             showImage();
                             break;
                         case SHOW_STOP:
@@ -709,21 +734,21 @@ public class ImageFromUrl extends Activity {
                                 }
                                 mSlideView.setVisibility ( View.VISIBLE );
                             }
-                            return;
+                            break;
                         case HIDEPANEL:
                             if ( mSlideView != null ) {
                                 mSlideView.setVisibility ( View.INVISIBLE );
                             }
-                            return;
+                            break;
                         case STOP_BY_SEVER:
-                            if ( !isShowingForehand ) {
+                            /*if ( !isShowingForehand ) {
                                 ImageFromUrl.this.finish();
                             } else {
                                 if ( null != mHandler ) {
                                     mHandler.sendEmptyMessageDelayed ( STOP_BY_SEVER, 5000 );
                                 }
-                            }
-                            return;
+                            }*/
+                            break;
                     }
                 }
         }
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/MediaCenterService.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/MediaCenterService.java
index f0dbfcb..7df3d4a 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/MediaCenterService.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/MediaCenterService.java
@@ -271,6 +271,7 @@ public class MediaCenterService extends Service {
                 String name = cn.getClassName();
                 if (!MusicPlayer.isShowingForehand && MediaRendererDevice.TYPE_AUDIO.equals(type)) {
                     intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
                     intent.setClass(MediaCenterService.this, MusicPlayer.class);
                     VideoPlayer.running = false;
                     ImageFromUrl.isShowingForehand = false;
@@ -279,6 +280,7 @@ public class MediaCenterService extends Service {
                     return;
                 } else if (!VideoPlayer.running && MediaRendererDevice.TYPE_VIDEO.equals(type)) {
                     intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
                     intent.setClass(MediaCenterService.this, VideoPlayer.class);
                     ImageFromUrl.isShowingForehand = false;
                     MusicPlayer.isShowingForehand = false;
@@ -286,6 +288,7 @@ public class MediaCenterService extends Service {
                     startActivity(intent);
                     return;
                 } else if (!ImageFromUrl.isShowingForehand && MediaRendererDevice.TYPE_IMAGE.equals(type)) {
+                    intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
                     intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                     intent.setClass(MediaCenterService.this, ImageFromUrl.class);
                     MusicPlayer.isShowingForehand = false;
@@ -317,6 +320,10 @@ public class MediaCenterService extends Service {
         }
 
         private void startDMRInternal() {
+            if (isDMRStart) {
+                //already run;
+                return;
+            }
             if (super.isRunning()) {
                 super.stop(false);
             }
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/MusicPlayer.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/MusicPlayer.java
index 93507a0..641ff70 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/MusicPlayer.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/MusicPlayer.java
@@ -171,6 +171,7 @@ public class MusicPlayer extends Activity implements OnPreparedListener,
         public void onCreate ( Bundle savedInstanceState ) {
             super.onCreate ( savedInstanceState );
             setContentView ( R.layout.music_activity );
+            getWindow().addFlags(LayoutParams.FLAG_DISMISS_KEYGUARD | LayoutParams.FLAG_TURN_SCREEN_ON);
             LayoutParams params = getWindow().getAttributes();
             //params.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
             //| WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY;
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/UPNPVideoView.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/UPNPVideoView.java
index 35f4aa4..673ee9a 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/UPNPVideoView.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/UPNPVideoView.java
@@ -100,7 +100,7 @@ public class UPNPVideoView extends SurfaceView implements VideoController.MediaP
         private boolean     mCanPause;
         private boolean     mCanSeekBack;
         private boolean     mCanSeekForward;
-
+        private boolean     mWaitDisplay;
         public UPNPVideoView ( Context context ) {
             super ( context );
             mContext = context;
@@ -232,16 +232,23 @@ public class UPNPVideoView extends SurfaceView implements VideoController.MediaP
             mUri = uri;
             mHeaders = headers;
             mSeekWhenPrepared = 0;
-            openVideo();
-            //requestLayout();
-            //invalidate();
+            if ( mSurfaceHolder == null ) {
+                mWaitDisplay = true;
+            }else {
+                openVideo();
+                mWaitDisplay = false;
+            }
+
+            requestLayout();
+            invalidate();
         }
 
         public void stopPlayback() {
             if ( mMediaPlayer != null ) {
                 mMediaPlayer.stop();
-                mMediaPlayer.release();
-                mMediaPlayer = null;
+                mMediaPlayer.reset();
+                //mMediaPlayer.release();
+                //mMediaPlayer = null;
                 mCurrentState = STATE_IDLE;
                 mTargetState  = STATE_IDLE;
                 if ( mOnStateChangedListener != null ) {
@@ -251,10 +258,6 @@ public class UPNPVideoView extends SurfaceView implements VideoController.MediaP
         }
 
         private void openVideo() {
-            /*if ( mUri == null || mSurfaceHolder == null ) {
-                // not ready for playback just yet, will try again later
-                return;
-            }*/
             // Tell the music playback service to pause
             // TODO: these constants need to be published somewhere in the framework.
             Intent i = new Intent ( "com.android.music.musicservicecommand" );
@@ -274,9 +277,9 @@ public class UPNPVideoView extends SurfaceView implements VideoController.MediaP
                 mMediaPlayer.setOnBufferingUpdateListener ( mBufferingUpdateListener );
                 mCurrentBufferPercentage = 0;
                 mMediaPlayer.setDataSource ( mContext, mUri, mHeaders );
-                //mMediaPlayer.setDisplay ( mSurfaceHolder );
-                mMediaPlayer.setAudioStreamType ( AudioManager.STREAM_MUSIC );
+                mMediaPlayer.setDisplay( mSurfaceHolder );
                 mMediaPlayer.setScreenOnWhilePlaying ( true );
+                mMediaPlayer.setAudioStreamType ( AudioManager.STREAM_MUSIC );
                 mMediaPlayer.prepare();
                 // we don't set the target state here either, but preserve the
                 // target state that was there before.
@@ -571,6 +574,7 @@ public class UPNPVideoView extends SurfaceView implements VideoController.MediaP
             }
             public void surfaceChanged ( SurfaceHolder holder, int format,
             int w, int h ) {
+                mSurfaceHolder = holder;
                 /*mSurfaceWidth = w;
                 mSurfaceHeight = h;
                 boolean isValidState =  ( mTargetState == STATE_PLAYING );
@@ -585,10 +589,10 @@ public class UPNPVideoView extends SurfaceView implements VideoController.MediaP
             }
             public void surfaceCreated ( SurfaceHolder holder ) {
                 mSurfaceHolder = holder;
-                if ( mMediaPlayer != null ) {
-                    mMediaPlayer.setDisplay ( mSurfaceHolder );
+                if (mWaitDisplay) {
+                    openVideo();
+                    mWaitDisplay = false;
                 }
-                //openVideo();
                 initSurface ( holder );
             }
             public void surfaceDestroyed ( SurfaceHolder holder ) {
@@ -596,7 +600,7 @@ public class UPNPVideoView extends SurfaceView implements VideoController.MediaP
                 mSurfaceHolder = null;
                 if ( mVideoController != null ) { mVideoController.hide(); }
                 stopPlayback();
-                //release ( true );
+                release ( true );
             }
         };
 
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/VideoController.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/VideoController.java
index b1d1ffe..73ff3fa 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/VideoController.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/VideoController.java
@@ -592,7 +592,7 @@ public class VideoController extends FrameLayout {
                 }
                 return true;
             } else if ( keyCode == KeyEvent.KEYCODE_MEDIA_STOP ) {
-                if ( uniqueDown && mPlayer.isInPlaybackState() ) {
+                if ( uniqueDown && (mPlayer != null) && mPlayer.isInPlaybackState() ) {
                     mPlayer.seekTo ( 0 );
                     setProgress();
                     if ( mPlayer.isPlaying() ) {
diff --git a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/VideoPlayer.java b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/VideoPlayer.java
index ef6ba73..d8e5246 100644
--- a/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/VideoPlayer.java
+++ b/amlogic/apps/DLNA/src/com/droidlogic/mediacenter/dlna/VideoPlayer.java
@@ -120,15 +120,16 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
         private boolean mHideStatusBar = false;
         private Timer mTimer;
         private TimerTask mTimerTask;
-
+        private boolean seekComplete;
         private static final int SHOW_DIALOG_DELAY = 5000;
         private static final int HIDE_LOADING_DIALOG = 500;
         private static final int FRESH_POSITION = 2000;
         private static final int SWITCH_VIDEO_DELAY = 3000;
-
+        public static final int SEEK_INTERVAL            = 9999;
         @Override
         public void onCreate ( Bundle savedInstanceState ) {
             super.onCreate ( savedInstanceState );
+            getWindow().addFlags(LayoutParams.FLAG_DISMISS_KEYGUARD | LayoutParams.FLAG_TURN_SCREEN_ON);
             mTimer = new Timer();
             setContentView ( R.layout.video_view );
             mVideoController = new VideoController ( this );
@@ -180,7 +181,6 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
             } else {
                 mVideoController.setPrevNextListeners ( null, null );
             }
-            start();
             mBrocastProgress = new Handler();
             mAudioManager = ( AudioManager ) getSystemService ( Context.AUDIO_SERVICE );
             mVideoView.setOnCompletionListener ( new MediaPlayer.OnCompletionListener() {
@@ -234,7 +234,8 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
                     Debug.d ( TAG, "#############onSeekComplete#####################"+mp.getCurrentPosition());
                     handlerUI.sendEmptyMessage ( HIDE_LOADING );
                     handlerUI.removeMessages ( GETINFO_FRESH );
-                    refressGetInfo();
+                    handlerUI.sendEmptyMessage ( GETINFO_FRESH );
+                    seekComplete = true;
                 }
             } );
             mVideoView.setOnStateChangedListener ( new UPNPVideoView.OnStateChangedListener() {
@@ -266,6 +267,7 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
                     }
                 }
             } );
+            start();
             mUPNPReceiver = new UPNPReceiver();
             Debug.d ( TAG, "##############################" );
             Debug.d ( TAG, "##############################" );
@@ -282,10 +284,6 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
                         start();
                         return;
                     case GETINFO_FRESH:
-                        /*mBrocastProgress.postDelayed(
-                                new ProgressRefresher(),
-                                500);*/
-                        //Debug.d ( TAG, "refressGetInforefressGetInforefressGetInforefressGetInfo" );
                         refressGetInfo();
                         return;
                     case HNALDE_HIDE_LOADING:
@@ -347,7 +345,7 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
             int vol = mAudioManager.getStreamVolume ( AudioManager.STREAM_MUSIC );
             mVideoBuffer = (String)PrefUtils.getProperties( "media.amplayer.buffertime","0.0");
             PrefUtils.setProperties("media.amplayer.buffertime", "6" );
-            PrefUtils.setProperties("media.amplayer.displast_frame", "true");
+            //PrefUtils.setProperties("media.amplayer.displast_frame", "true");
             if ( mLastState == STATE_PLAY ) {
                 play();
             }
@@ -446,7 +444,7 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
             Debug.d ( TAG, "##############################" );
             Debug.d ( TAG, "##############################" );
             Debug.d ( TAG, "onStop: make running as FALSE" );
-            PrefUtils.setProperties("media.amplayer.displast_frame", "false");
+            //PrefUtils.setProperties("media.amplayer.displast_frame", "false");
             mCurPos = 0;
             mDuration = 0;
             currentURI = null;
@@ -533,6 +531,7 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
             // mAudioManager.requestAudioFocus(mAudioFocusListener,
             // AudioManager.STREAM_MUSIC,
             // AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
+            seekComplete = true;
             Debug.d ( TAG, "*********************currentURI=" + currentURI );
             //showLoading();
             handlerUI.sendEmptyMessage ( SHOW_LOADING );
@@ -644,7 +643,6 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
                         stopExit();
                         handlerUI.sendEmptyMessageDelayed ( SHOW_STOP, 6000 );
                     } else if ( action.equals ( MediaRendererDevice.PLAY_STATE_SEEK ) ) {
-                        handlerUI.removeMessages ( GETINFO_FRESH );
                         String time = intent.getStringExtra ( "REL_TIME" );
                         if ( time == null || time.isEmpty() )
                             return;
@@ -652,8 +650,15 @@ public class VideoPlayer extends Activity implements OnInfoListener// implements
                         if ( ( msecs < 0 ) || ( ( msecs > mDuration ) && ( mDuration > 0 ) ) )
                         { return; }
                         Debug.d ( TAG, "*********seek to: " + time + ",   msecs=" + msecs + "mDuration:"+ mDuration);
-
-                        mVideoView.seekTo ( msecs );
+                        if ( seekComplete ) {
+                            seekComplete = false;
+                            if (( msecs - mVideoView.getCurrentPosition() ) > SEEK_INTERVAL || ( mVideoView.getCurrentPosition() - msecs ) > SEEK_INTERVAL ) {
+                                mVideoView.seekTo ( msecs );
+                                if ( play_state == STATE_PLAY ) {
+                                    handlerUI.removeMessages ( GETINFO_FRESH );
+                                }
+                            }
+                        }
                         //handlerUI.sendEmptyMessageDelayed(3, 500);
                     } else if ( action.equals ( AmlogicCP.UPNP_SETVOLUME_ACTION ) ) {
                         int vol = intent.getIntExtra ( "DesiredVolume", 50 );
diff --git a/amlogic/apps/DTVPlayer/src/com/amlogic/DTVPlayer/DTVPlayer.java b/amlogic/apps/DTVPlayer/src/com/amlogic/DTVPlayer/DTVPlayer.java
index e771772..01ead3d 100755
--- a/amlogic/apps/DTVPlayer/src/com/amlogic/DTVPlayer/DTVPlayer.java
+++ b/amlogic/apps/DTVPlayer/src/com/amlogic/DTVPlayer/DTVPlayer.java
@@ -68,6 +68,7 @@ public class DTVPlayer extends DTVActivity{
 	private PowerManager.WakeLock wakeLock = null;
 	private HomeKeyEventBroadCastReceiver home_receiver=null;
 
+	SubAsyncTask mTask = null;
 	private enum menu{
 		PROGRAM,
 		SEARCH,
@@ -176,7 +177,11 @@ public class DTVPlayer extends DTVActivity{
 				DismissDialog();
 				break;
 			case TVMessage.TYPE_PROGRAM_START:
-				SubAsyncTask mTask = new SubAsyncTask();  
+				if (mTask != null && mTask.getStatus() != AsyncTask.Status.FINISHED)
+				{
+                    mTask.cancel(true);
+				}
+                mTask = new SubAsyncTask();  
 				mTask.execute();  
 				break;
 			case TVMessage.TYPE_BOOKING_START:
@@ -2034,6 +2039,7 @@ public class DTVPlayer extends DTVActivity{
 		
 		TextView Text_proname = (TextView) findViewById(R.id.Text_proname);
 		Text_proname.setTextColor(Color.YELLOW);
+		Log.d(TAG,"dtvplayer event:---"+dtvplayer_cur_event);
 
 		TextView Text_curevent = (TextView) findViewById(R.id.Text_curevent);
 		Text_curevent.setTextColor(Color.YELLOW);
@@ -2048,18 +2054,21 @@ public class DTVPlayer extends DTVActivity{
 		else
 			Text_title_info.setText(dtvplayer_event_des);
 	
+		Log.d(TAG,"dtvplayer event des:---"+dtvplayer_event_des);
 		TextView Text_detail_info = (TextView) findViewById(R.id.Text_detail_info);
 		if(dtvplayer_event_ext_des==null)
 			Text_detail_info.setText(getString(R.string.dtvplayer_detail_info));
 		else
 			Text_detail_info.setText(dtvplayer_event_ext_des);
 
+		Log.d(TAG,"dtvplayer event ext des:---"+dtvplayer_event_ext_des);
 		TextView Text_nextevent = (TextView) findViewById(R.id.Text_nextevent);
 		if(dtvplayer_next_event==null)
 			Text_nextevent.setText(getString(R.string.dtvplayer_no_next_event));
 		else
 			Text_nextevent.setText(dtvplayer_next_event);
 
+		Log.d(TAG,"dtvplayer next event ext des:---"+dtvplayer_next_event);
 		TextView Text_parent_rate = (TextView) findViewById(R.id.Text_parent_rate);	
 		
 
@@ -3478,23 +3487,83 @@ public class DTVPlayer extends DTVActivity{
 	          
 	        @Override
 	        protected String doInBackground(Object... params) {  
-			DTVPlayerGetCurrentProgramData();
-			if(mTVProgram!=null)
-				DTVPlayerSetRecallList(mTVProgram.getID());
-			return null;  
+				DTVPlayerGetCurrentProgramData();
+				if(mTVProgram!=null)
+					DTVPlayerSetRecallList(mTVProgram.getID());
+				/*add re get epg info if epg not get*/
+				Integer[] progress = new Integer[1];
+				progress[0]=0;
+				publishProgress(progress);
+			     if(dtvplayer_event_des == null
+                	||dtvplayer_cur_event == null
+                	||dtvplayer_event_ext_des == null
+                	||dtvplayer_next_event == null)
+			    {
+			    	while (true) 
+					{
+		                try {
+		                    Thread.sleep(200);
+		                } catch (InterruptedException e) {
+		                    Log.e("ERROR", "SubAsyncTask Thread Interrupted");
+		                }
+
+		                if (isCancelled())
+		                {
+		                    Log.e("ERROR", "SubAsyncTask Thread canceled");
+		                    return null; 
+		                }
+		                DTVPlayerGetCurrentProgramData();
+
+		                if(dtvplayer_b_epg==true)
+		                {
+		                	progress[0]=1;
+							publishProgress(progress);
+		                	//break;
+		                }
+		                else
+		                {
+		                	Log.e("OK", "SubAsyncTask not get epg date");
+		                }
+		                if(dtvplayer_event_des!=null
+		                	&&dtvplayer_cur_event!=null
+		                	&&dtvplayer_event_ext_des!=null
+		                	&&dtvplayer_next_event!=null
+		                	)
+		                {
+		                	Log.e("OK", "SubAsyncTask epg is get all--");
+		                	break;
+		                }
+		                if(inforbar_show_flag == false)
+		                {
+		                	Log.e("OK", "SubAsyncTask banner is hidden---");
+		                	break;
+		                }
+		            }
+			    }
+				return null;  
 	        }  
 	  
 	        @Override
 	        protected void onProgressUpdate(Integer... progress) { 
-			super.onProgressUpdate(progress);  
+		        if(progress[0]==0)
+		        {
+		        	RelativeLayout_loading_icon.setVisibility(View.INVISIBLE);
+					ShowControlBar();
+					updateInforbar();
+		        }
+		        else
+		        {	
+		        	if(inforbar_show_flag == true)
+		        	{
+		        		updateInforbar();
+		        	}
+		        }
+				super.onProgressUpdate(progress);  
 	        }  
 	  
 	        @Override
 	        protected void onPostExecute(String result) {  
-			RelativeLayout_loading_icon.setVisibility(View.INVISIBLE);
-			ShowControlBar();
-			updateInforbar();
-			super.onPostExecute(result);  
+				super.onPostExecute(result);  
 	        }  
 	  
 	}  
diff --git a/amlogic/apps/FileBrowser/src/com/droidlogic/FileBrower/FileOp.java b/amlogic/apps/FileBrowser/src/com/droidlogic/FileBrower/FileOp.java
index 58df237..5cff963 100644
--- a/amlogic/apps/FileBrowser/src/com/droidlogic/FileBrower/FileOp.java
+++ b/amlogic/apps/FileBrowser/src/com/droidlogic/FileBrower/FileOp.java
@@ -223,6 +223,7 @@ public class FileOp {
         ".jif",
         ".jfif",
         ".mpo",
+        ".webp",
         ".3dg",
         "3dp"
     };
diff --git a/amlogic/apps/MboxLauncher2/res/raw/default_shortcut b/amlogic/apps/MboxLauncher2/res/raw/default_shortcut
index ecad517..5de57c3 100755
--- a/amlogic/apps/MboxLauncher2/res/raw/default_shortcut
+++ b/amlogic/apps/MboxLauncher2/res/raw/default_shortcut
@@ -1,5 +1,5 @@
 Home_Shortcut:com.droidlogic.videoplayer;com.android.music;com.droidlogic.appinstall;
 Video_Shortcut:com.moretv.android;com.qiyi.video;com.togic.livevideo;com.sohutv.tv;com.youku.tv;net.myvst.v2;com.elinkway.tvlive2;
-Recommend_Shortcut:com.android.gallery3d;
+Recommend_Shortcut:com.droidlogic.mediacenter;com.droidlogic.miracast;
 Music_shortcut:com.moretv.mv;com.android.music;com.hycstv.android;
 Local_Shortcut:com.android.gallery3d;com.droidlogic.videoplayer;com.droidlogic.FileBrower;
diff --git a/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/AppLayout.java b/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/AppLayout.java
index 440412b..3b64afc 100644
--- a/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/AppLayout.java
+++ b/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/AppLayout.java
@@ -87,7 +87,7 @@ public class AppLayout extends RelativeLayout{
         grid_layout.clearFocus();
         grid_layout.setLayoutView(mode, list);
         if (mode != Launcher.MODE_HOME && grid_layout.getChildCount() > 0) {
-            final MyRelativeLayout firstChild = (MyRelativeLayout)grid_layout.getChildAt(0);
+            MyRelativeLayout firstChild = (MyRelativeLayout)grid_layout.getChildAt(0);
             firstChild.requestFocus();
         }
     }
diff --git a/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/CustomView.java b/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/CustomView.java
index 00ecd09..3989cc4 100644
--- a/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/CustomView.java
+++ b/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/CustomView.java
@@ -22,7 +22,7 @@ import android.widget.Toast;
 import android.view.animation.Animation;
 import android.view.animation.TranslateAnimation;
 import android.view.animation.Animation.AnimationListener;
-import 	android.view.animation.AccelerateInterpolator;
+import android.view.animation.AccelerateInterpolator;
 import android.animation.Animator;
 import android.animation.Animator.AnimatorListener;
 import android.view.ViewGroup;
@@ -42,6 +42,7 @@ public class CustomView extends FrameLayout implements OnItemClickListener, OnGl
     private final static String COMPONENT_NAME = "component name";
 
     private final static int duration = 300;
+    private static boolean allowAnimation = true;
 
     private ImageView img_screen_shot = null;
     private ImageView img_screen_shot_keep = null;
@@ -112,19 +113,21 @@ public class CustomView extends FrameLayout implements OnItemClickListener, OnGl
         Launcher context = (Launcher) mContext;
         View view = context.getMainView();
         this.setVisibility(View.VISIBLE);
-        TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -transY);
-        translateAnimation.setDuration(duration);
-        //translateAnimation.setAnimationListener(new exitAnimationListener());
-        translateAnimation.setInterpolator(new AccelerateInterpolator());
-        gv.startAnimation(translateAnimation);
-        view.animate().
-            translationY(0).
-            setDuration(duration).
-            alpha(1f).
-            setInterpolator(new AccelerateInterpolator()).
-            setListener(new mAnimatorListener()).
-            start();
-        context.getAppDataLoader().saveShortcut(mMode, str_custom_apps);
+        if (allowAnimation) {
+            allowAnimation = false;
+            TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -transY);
+            translateAnimation.setDuration(duration);
+            translateAnimation.setInterpolator(new AccelerateInterpolator());
+            gv.startAnimation(translateAnimation);
+            view.animate().
+                translationY(0).
+                setDuration(duration).
+                alpha(1f).
+                setInterpolator(new AccelerateInterpolator()).
+                setListener(new mAnimatorListener()).
+                start();
+            context.getAppDataLoader().saveShortcut(mMode, str_custom_apps);
+        }
     }
 
     private  List<ArrayMap<String, Object>> getAppList() {
@@ -257,21 +260,6 @@ public class CustomView extends FrameLayout implements OnItemClickListener, OnGl
         }
     }
 
-    private class exitAnimationListener implements AnimationListener {
-        @Override
-        public void onAnimationStart(Animation animation) {
-        }
-
-        @Override
-        public void onAnimationEnd(Animation animation) {
-            ((Launcher)mContext).getRootView().removeView(thisView);
-            ((Launcher)mContext).recoverFromCustom();
-        }
-
-        @Override
-        public void onAnimationRepeat(Animation animation) {
-        }
-    }
     private class mAnimatorListener implements AnimatorListener {
         @Override
         public void onAnimationCancel(Animator animation) {
@@ -281,6 +269,7 @@ public class CustomView extends FrameLayout implements OnItemClickListener, OnGl
         }
         @Override
         public void onAnimationEnd(Animator animation) {
+            allowAnimation = true;
             ((Launcher)mContext).getRootView().removeView(thisView);
             ((Launcher)mContext).getMainView().animate().setListener(null);
             ((Launcher)mContext).recoverFromCustom();
diff --git a/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/Launcher.java b/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/Launcher.java
index 69d443b..7b7c5fb 100644
--- a/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/Launcher.java
+++ b/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/Launcher.java
@@ -222,7 +222,7 @@ public class Launcher extends Activity{
             setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
         }
 
-        getMainView().animate().translationY(0).start();
+        //getMainView().animate().translationY(0).start();
         setBigBackgroundDrawable();
         displayShortcuts();
         displayStatus();
@@ -238,13 +238,15 @@ public class Launcher extends Activity{
     protected void onPause() {
         super.onPause();
         Log.d(TAG, "------onPause");
+        mTvHandler.removeMessages(TV_MSG_PLAY_TV);
+        if (needPreviewFeture())
+            releaseTvView();
     }
 
     @Override
     protected void onStop() {
         recycleBigBackgroundDrawable();
-        if (needPreviewFeture())
-            releaseTvView();
+
         super.onStop();
         Log.d(TAG, "------onStop");
     }
@@ -423,7 +425,6 @@ public class Launcher extends Activity{
 
         Intent intent = new Intent();
         intent.setComponent(ComponentName.unflattenFromString(COMPONENT_TV_SETTINGS));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         mSettingsView.setType(TYPE_SETTINGS);
         mSettingsView.setIntent(intent);
     }
@@ -677,7 +678,6 @@ public class Launcher extends Activity{
     public void startTvSettings() {
         Intent intent = new Intent();
         intent.setComponent(ComponentName.unflattenFromString(COMPONENT_TV_SETTINGS));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         startActivity(intent);
     }
 
diff --git a/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/MyRelativeLayout.java b/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/MyRelativeLayout.java
index 880f948..7fa2e8b 100644
--- a/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/MyRelativeLayout.java
+++ b/amlogic/apps/MboxLauncher2/src/com/droidlogic/mboxlauncher/MyRelativeLayout.java
@@ -1,7 +1,9 @@
 package com.droidlogic.mboxlauncher;
 
 import android.content.Context;
+import android.content.ComponentName;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 import android.widget.ImageView;
@@ -146,9 +148,20 @@ public class MyRelativeLayout extends RelativeLayout implements OnGlobalLayoutLi
                             break;
                         case Launcher.TYPE_APP_SHORTCUT:
                         case Launcher.TYPE_HOME_SHORTCUT:
+                            ComponentName cameraCom = new ComponentName("com.android.camera2", "com.android.camera.CameraLauncher");
                             if (mIntent != null) {
                                 if (mIntent.getComponent().flattenToString().equals(Launcher.COMPONENT_TV_APP))
                                     ((Launcher)mContext).startTvApp();
+                                else if (mIntent.getComponent().equals(cameraCom)) {
+                                    if (mContext.getPackageManager().getComponentEnabledSetting(cameraCom)
+                                        != PackageManager.COMPONENT_ENABLED_STATE_DISABLED) {
+                                        try {
+                                            mContext.startActivity(mIntent);
+                                        } catch (Exception e) {
+                                            e.printStackTrace();
+                                        }
+                                    }
+                                }
                                 else
                                     mContext.startActivity(mIntent);
                             } else if (mIsAddButton){
@@ -195,9 +208,20 @@ public class MyRelativeLayout extends RelativeLayout implements OnGlobalLayoutLi
                             break;
                         case Launcher.TYPE_APP_SHORTCUT:
                         case Launcher.TYPE_HOME_SHORTCUT:
+                            ComponentName cameraCom = new ComponentName("com.android.camera2", "com.android.camera.CameraLauncher");
                             if (mIntent != null) {
                                 if (mIntent.getComponent().flattenToString().equals(Launcher.COMPONENT_TV_APP))
                                     ((Launcher)mContext).startTvApp();
+                                else if (mIntent.getComponent().equals(cameraCom)) {
+                                    if (mContext.getPackageManager().getComponentEnabledSetting(cameraCom)
+                                        != PackageManager.COMPONENT_ENABLED_STATE_DISABLED) {
+                                        try {
+                                            mContext.startActivity(mIntent);
+                                        } catch (Exception e) {
+                                            e.printStackTrace();
+                                        }
+                                    }
+                                }
                                 else
                                     mContext.startActivity(mIntent);
                             } else if (mIsAddButton){
diff --git a/amlogic/apps/NativeImagePlayer/src/com/droidlogic/imageplayer/FullImageActivity.java b/amlogic/apps/NativeImagePlayer/src/com/droidlogic/imageplayer/FullImageActivity.java
index 72ed444..1f765df 100644
--- a/amlogic/apps/NativeImagePlayer/src/com/droidlogic/imageplayer/FullImageActivity.java
+++ b/amlogic/apps/NativeImagePlayer/src/com/droidlogic/imageplayer/FullImageActivity.java
@@ -253,11 +253,12 @@ public class FullImageActivity extends Activity implements ImagePlayer.ImagePlay
     }
 
     private String filterPath(String filePath) {
-        if ( filePath.startsWith("/storage/emulated/0") ) {
+        if ( filePath.startsWith("/storage/emulated/") ) {
             try {
                 Method method = Environment.class.getMethod("getLegacyExternalStorageDirectory");
                 File file = (File)method.invoke(null);
-                filePath = file.getAbsolutePath() + filePath.substring(filePath.lastIndexOf('/'), filePath.length());
+                String filePathSubString = filePath.substring("/storage/emulated/".length());
+                filePath = file.getAbsolutePath() + filePathSubString.substring(filePathSubString.indexOf('/'));
             } catch (Exception ex) {
                 ex.printStackTrace();
                 return filePath;
diff --git a/amlogic/apps/RemoteIME/jni/android/com_droidlogic_inputmethod_remote_PinyinDecoderService.cpp b/amlogic/apps/RemoteIME/jni/android/com_droidlogic_inputmethod_remote_PinyinDecoderService.cpp
index c8b9415..ec71725 100644
--- a/amlogic/apps/RemoteIME/jni/android/com_droidlogic_inputmethod_remote_PinyinDecoderService.cpp
+++ b/amlogic/apps/RemoteIME/jni/android/com_droidlogic_inputmethod_remote_PinyinDecoderService.cpp
@@ -193,7 +193,7 @@ extern "C" {
 
     JNIEXPORT jint JNICALL nativeImGetPredictsNum ( JNIEnv *env, jclass clazz,
                                                     jstring fixed_str ) {
-        char16 *fixed_ptr = ( char16 * ) ( *env ).GetStringChars ( fixed_str, false );
+        char16 *fixed_ptr = ( char16 * ) ( *env ).GetStringChars ( fixed_str, NULL );
         size_t fixed_len = ( size_t ) ( *env ).GetStringLength ( fixed_str );
         char16 fixed_buf[kMaxPredictSize + 1];
         if ( fixed_len > kMaxPredictSize ) {
diff --git a/amlogic/apps/SubTitle/assets/fonts/simhei.ttf b/amlogic/apps/SubTitle/assets/fonts/simhei.ttf
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/SubTitle/assets/fonts/simsun.ttf b/amlogic/apps/SubTitle/assets/fonts/simsun.ttf
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/SubTitle/src/com/droidlogic/SubTitleService/SubTitleService.java b/amlogic/apps/SubTitle/src/com/droidlogic/SubTitleService/SubTitleService.java
index 7a831da..6fb8986 100644
--- a/amlogic/apps/SubTitle/src/com/droidlogic/SubTitleService/SubTitleService.java
+++ b/amlogic/apps/SubTitle/src/com/droidlogic/SubTitleService/SubTitleService.java
@@ -721,14 +721,14 @@ public class SubTitleService extends ISubTitleService.Stub {
                     break;
 
                 case CLOSE:
-                    if (subShowState == SUB_ON) {
+                    //if (subShowState == SUB_ON) {
                         removeView();
                         subTitleView.stopSubThread(); //close insub parse thread
                         subTitleView.closeSubtitle();
                         subTitleView.clear();
                         subShowState = SUB_OFF;
                         mRatioSet = false;
-                    }
+                    //}
                     break;
 
                 case SET_TXT_COLOR:
diff --git a/amlogic/apps/SubTitle/src/com/subtitleparser/FileIO.java b/amlogic/apps/SubTitle/src/com/subtitleparser/FileIO.java
index cdf3461..47c67ec 100644
--- a/amlogic/apps/SubTitle/src/com/subtitleparser/FileIO.java
+++ b/amlogic/apps/SubTitle/src/com/subtitleparser/FileIO.java
@@ -12,6 +12,7 @@ import android.util.Log;
 * @author
 */
 public class FileIO {
+    static String mFont = null;
         /**
         * Fetch the entire contents of a text file, and return it in a String.
         * This style of implementation does not throw Exceptions to the caller.
@@ -56,6 +57,11 @@ public class FileIO {
             return contents.toString();
         }
 
+        public static String getFont() {
+            Log.i("getFont", "mFont:" + mFont);
+            return mFont;
+        }
+
         public static Subtitle.SUBTYPE dectFileType (String filePath, String encoding) {
             BufferedReader input = null;
             Subtitle.SUBTYPE type = Subtitle.SUBTYPE.SUB_INVALID;
@@ -82,15 +88,39 @@ public class FileIO {
             Pattern LRC_Pattern = Pattern.compile ("\\[\\d+:\\d+.\\d+\\]" + "(.*?)");
             Pattern XML_Pattern = Pattern.compile ("<Subtitle>");
             Matcher matcher = null;
+            int i = 0;
+            int idx = 0;
             try {
                 //use buffering
                 //this implementation reads one line at a time
                 //          input = new BufferedReader( new FileReader(filePath));
                 input = new BufferedReader (new InputStreamReader (new FileInputStream (new File (filePath)), encoding), 1024);
                 String line = null; //not declared within while loop
+                mFont = null; //reset font
                 try {
                     while ( (line = input.readLine()) != null && testMaxLines > 0) {
                         Log.v ("dectFileType", " -----new line--------" + (60 - testMaxLines) + "  " + line);
+
+                        if (line.indexOf("Format:") >= 0) {
+                            String[] propNames = line.split(", ");
+                            for (String propName: propNames) {
+                                if (propName.equals("Fontname")) {
+                                    break;
+                                }
+                                idx++;
+                            }
+                        }
+                        else if (line.indexOf("Style:") >= 0) {
+                            String[] propTypes = line.split(",");
+                            for (String propType: propTypes) {
+                                if (i == idx) {
+                                    mFont = propType;
+                                    break;
+                                }
+                                i++;
+                            }
+                        }
+
                         if (line.length() > 3000) {
                             type = Subtitle.SUBTYPE.SUB_INVALID;
                             break;
diff --git a/amlogic/apps/SubTitle/src/com/subtitleparser/Subtitle.java b/amlogic/apps/SubTitle/src/com/subtitleparser/Subtitle.java
index 2b4636c..f734328 100644
--- a/amlogic/apps/SubTitle/src/com/subtitleparser/Subtitle.java
+++ b/amlogic/apps/SubTitle/src/com/subtitleparser/Subtitle.java
@@ -246,7 +246,9 @@ public class Subtitle {
             return FileIO.dectFileType (file, encoding);
         }
 
-
+        public String getFont() {
+            return FileIO.getFont();
+        }
 
         private static String checkEncoding (String fileName, String enc) {
             BufferedInputStream bis = null;
diff --git a/amlogic/apps/SubTitle/src/com/subtitleview/SubManager.java b/amlogic/apps/SubTitle/src/com/subtitleview/SubManager.java
index 87ae213..348d50d 100644
--- a/amlogic/apps/SubTitle/src/com/subtitleview/SubManager.java
+++ b/amlogic/apps/SubTitle/src/com/subtitleview/SubManager.java
@@ -115,6 +115,9 @@ public class SubManager {
             return type;
         }
 
+        public String getFont() {
+            return subtitle.getFont();
+        }
         public int getDisplayWidth() {
             //Log.d(TAG, "display_width:"+display_width);
             return display_width;
diff --git a/amlogic/apps/SubTitle/src/com/subtitleview/SubtitleView.java b/amlogic/apps/SubTitle/src/com/subtitleview/SubtitleView.java
index 4e7af78..a1d5440 100644
--- a/amlogic/apps/SubTitle/src/com/subtitleview/SubtitleView.java
+++ b/amlogic/apps/SubTitle/src/com/subtitleview/SubtitleView.java
@@ -2,6 +2,7 @@ package com.subtitleview;
 
 import android.R.bool;
 import android.content.Context;
+import android.content.res.AssetManager;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
@@ -36,6 +37,12 @@ public class SubtitleView extends FrameLayout {
         private ImageView mImageView = null;
         private TextView mTextView = null;
 
+        //for font
+        Context mContext;
+        private String mFont = null;
+        Typeface mSimSun;
+        Typeface mSimHei;
+
         //add for pgs show
         private SubData dataPgsA = null;
         private SubData dataPgsB = null;
@@ -66,12 +73,13 @@ public class SubtitleView extends FrameLayout {
         }
 
         private void init (Context context) {
+            mContext = context;
             mImageView = new ImageView (context);
             mTextView = new TextView (context);
             if (mTextView != null) {
                 mTextView.setTextColor (0);
                 mTextView.setTextSize (12);
-                mTextView.setTypeface (null, Typeface.BOLD);
+                //mTextView.setTypeface (null, Typeface.BOLD);
                 mTextView.setGravity (Gravity.CENTER);
             }
             wscale = 1.000f;
@@ -269,6 +277,14 @@ public class SubtitleView extends FrameLayout {
                         sttmp_2[ sttmp_2.length - 1] = 0x20;
                     }
                     if (mTextView != null) {
+                        if (mFont != null && (mFont.indexOf("hei") >= 0
+                            || mFont.indexOf("Hei") >= 0)) {
+                            mTextView.setTypeface(mSimHei);
+                        }
+                        else if (mFont != null && (mFont.indexOf("sun") >= 0
+                            || mFont.indexOf("Sun") >= 0)) {
+                            mTextView.setTypeface(mSimSun);
+                        }
                         mTextView.setText (new String (sttmp_2) );
                         this.addView (mTextView);
                     }
@@ -562,6 +578,10 @@ public class SubtitleView extends FrameLayout {
             dataPgsAShowed = false;
             dataPgsBShowed = false;
             Subtitle.SUBTYPE tmp = SubManager.getinstance().setFile (file, enc);
+            mFont = SubManager.getinstance().getFont();
+            AssetManager mgr = mContext.getAssets();
+            mSimSun = Typeface.createFromAsset(mgr, "fonts/simsun.ttf");
+            mSimHei = Typeface.createFromAsset(mgr, "fonts/simhei.ttf");
             return tmp;
         }
 
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/AndroidManifest.xml b/amlogic/apps/TvInput/DroidLogicTvInput/AndroidManifest.xml
index 6107483..f1691ad 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/AndroidManifest.xml
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/AndroidManifest.xml
@@ -91,6 +91,15 @@
             <meta-data android:name="android.media.tv.input"
                 android:resource="@xml/atvinputservice" />
         </service>
+        <service
+            android:name=".services.SPDIFInputService"
+            android:permission="android.permission.BIND_TV_INPUT" >
+            <intent-filter>
+                <action android:name="android.media.tv.TvInputService" />
+            </intent-filter>
+            <meta-data android:name="android.media.tv.input"
+                android:resource="@xml/spdifinputservice" />
+        </service>
 
         <activity
             android:name=".settings.TvSettingsActivity"
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/jni/DTVEpgScanner.c b/amlogic/apps/TvInput/DroidLogicTvInput/jni/DTVEpgScanner.c
index a714a84..340edb9 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/jni/DTVEpgScanner.c
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/jni/DTVEpgScanner.c
@@ -27,6 +27,10 @@ static jclass    gEvtClass;
 static jmethodID gEvtInitID;
 static jclass    gChannelClass;
 static jmethodID gChannelInitID;
+static jclass    gServiceInfosFromSDTClass;
+static jmethodID gServiceInfosFromSDTInitID;
+static jclass    gServiceInfoFromSDTClass;
+static jmethodID gServiceInfoFromSDTInitID;
 
 typedef struct{
 	int dmx_id;
@@ -46,9 +50,16 @@ typedef struct {
 	int dvbVersion;
 }EPGEventData;
 
+struct sdt_service;
+typedef struct sdt_service sdt_service_t;
+
+#define MAX_LEN_MULTINAME ((64+4)*4 + 1)
+#define SPLIT_MULTINAME     {0x80}
+#define LEN_SPLIT_MULTINAME 1
+
 typedef struct {
 	int valid;
-	char name[(64+4)*4 + 1];
+	char name[MAX_LEN_MULTINAME];
 	int mOriginalNetworkId;
 	int mTransportStreamId;
 	int mServiceId;
@@ -63,10 +74,21 @@ typedef struct {
 	int mVideoFormat;
 	AM_SI_AudioInfo_t mAudioInfo;
 	AM_SI_SubtitleInfo_t mSubtitleInfo;
+	AM_SI_TeletextInfo_t mTeletextInfo;
 	int mPcrPID;
 	int mSdtVersion;
+	sdt_service_t *services;
 }EPGChannelData;
 
+struct sdt_service{
+	int id;
+	int type;
+	char name[MAX_LEN_MULTINAME];
+	int running;
+	int free_ca;
+	sdt_service_t *next;
+};
+
 EPGChannelData gChannelMonitored = {.valid = 0};
 
 static void epg_on_event(jobject obj, EPGEventData *evt_data)
@@ -261,49 +283,167 @@ static void format_audio_strings(AM_SI_AudioInfo_t *ai, char *pids, char *fmts,
 	}
 }
 
+#define gen_type_n_string(array, item, fmt, n, string, n_s) do { \
+		int i; char tmp[32]; \
+		(string)[0] = 0; \
+		for (i=0; i<(n); i++) \
+			snprintf(string, n_s, "%s " fmt, string, (array)[i].item); \
+		}while(0)
+
+#define gen_audio_3strings(array, n, strings, n_s) do { \
+		gen_type_n_string(array,pid,"%d",n,(strings)[0],n_s); \
+		gen_type_n_string(array,fmt,"%d",n,(strings)[1],n_s); \
+		gen_type_n_string(array,lang,"%s",n,(strings)[2],n_s); \
+		}while(0)
+#define gen_subtitle_5strings(array, n, strings, n_s) do { \
+		gen_type_n_string(array,pid,"%d",n,(strings)[0],n_s); \
+		gen_type_n_string(array,type,"%d",n,(strings)[1],n_s); \
+		gen_type_n_string(array,comp_page_id,"%d",n,(strings)[2],n_s); \
+		gen_type_n_string(array,anci_page_id,"%d",n,(strings)[3],n_s); \
+		gen_type_n_string(array,lang,"%s",n,(strings)[4],n_s); \
+		}while(0)
+#define gen_teletext_5strings(array, n, strings, n_s) do { \
+		gen_type_n_string(array,pid,"%d",n,(strings)[0],n_s); \
+		gen_type_n_string(array,type,"%d",n,(strings)[1],n_s); \
+		gen_type_n_string(array,magazine_no,"%d",n,(strings)[2],n_s); \
+		gen_type_n_string(array,page_no,"%d",n,(strings)[3],n_s); \
+		gen_type_n_string(array,lang,"%s",n,(strings)[4],n_s); \
+		}while(0)
+
+
 static int check_pmt_update(EPGChannelData *c1, EPGChannelData *c2)
 {
 	int ret=0;
+	int i, j;
 
-	if (c1->mVideoPID != c2->mVideoPID || c1->mVideoFormat != c2->mVideoFormat)
-	{
+	if (c1->mVideoPID != c2->mVideoPID || c1->mVideoFormat != c2->mVideoFormat) { //check video
 		//notify
 		ret = 1;
 	}
-	else
-	{
-		int i, j;
-		for (i=0; i<c1->mAudioInfo.audio_count; i++)
-		{
-			for (j=0; j<c2->mAudioInfo.audio_count; j++)
-			{
+
+	if (ret == 0) {
+		if (c1->mAudioInfo.audio_count != c2->mAudioInfo.audio_count)
+			ret = 2;
+	}
+	if (ret == 0) {//check audio
+		for (i=0; i<c1->mAudioInfo.audio_count; i++) {
+			for (j=0; j<c2->mAudioInfo.audio_count; j++) {
 				if (c1->mAudioInfo.audios[i].pid == c2->mAudioInfo.audios[j].pid &&
 					c1->mAudioInfo.audios[i].fmt == c2->mAudioInfo.audios[j].fmt &&
 					!strncmp(c1->mAudioInfo.audios[i].lang, c2->mAudioInfo.audios[j].lang, 3))
 					break;
 			}
-			if (j >= c2->mAudioInfo.audio_count)
-			{
+			if (j >= c2->mAudioInfo.audio_count) {
 				//notify
-				ret = 1;
+				ret = 2;
 				break;
 			}
 		}
 	}
-	if (ret) {
-		char str_prev_apids[256], str_cur_apids[256];
-		char str_prev_afmts[256], str_cur_afmts[256];
-		char str_prev_alangs[256], str_cur_alangs[256];
-		log_info(">>> Video/Audio changed ");
-		log_info("Video pid/fmt: (%d/%d) -> (%d/%d)", c1->mVideoPID, c1->mVideoFormat, c1->mVideoPID, c1->mVideoFormat);
-		format_audio_strings(&c1->mAudioInfo, str_prev_apids, str_prev_afmts, str_prev_alangs);
-		format_audio_strings(&c2->mAudioInfo, str_cur_apids, str_cur_afmts, str_cur_alangs);
-		log_info("Audio pid/fmt/lang: ('%s'/'%s'/'%s') -> ('%s'/'%s'/'%s')",
-			str_prev_apids, str_prev_afmts, str_prev_alangs, str_cur_apids, str_cur_afmts, str_cur_alangs);
+	if (ret == 0) {
+		if (c1->mSubtitleInfo.subtitle_count != c2->mSubtitleInfo.subtitle_count)
+			ret = 3;
+	}
+	if (ret == 0) {//check subtitle
+		for (i=0; i<c1->mSubtitleInfo.subtitle_count; i++) {
+			for (j=0; j<c2->mSubtitleInfo.subtitle_count; j++) {
+				if (c1->mSubtitleInfo.subtitles[i].pid == c2->mSubtitleInfo.subtitles[j].pid &&
+					c1->mSubtitleInfo.subtitles[i].type == c2->mSubtitleInfo.subtitles[j].type &&
+					c1->mSubtitleInfo.subtitles[i].comp_page_id == c2->mSubtitleInfo.subtitles[j].comp_page_id &&
+					c1->mSubtitleInfo.subtitles[i].anci_page_id == c2->mSubtitleInfo.subtitles[j].anci_page_id &&
+					!strncmp(c1->mSubtitleInfo.subtitles[i].lang, c2->mSubtitleInfo.subtitles[j].lang, 3))
+					break;
+			}
+			if (j >= c2->mSubtitleInfo.subtitle_count) {
+				//notify
+				ret = 3;
+				break;
+			}
+		}
+	}
+	if (ret == 0) {
+		int sub_txt_cnt = 0;
+		for (i=0; i<c2->mTeletextInfo.teletext_count; i++) {
+			if ((c2->mTeletextInfo.teletexts[i].type == 0x2)
+				|| (c2->mTeletextInfo.teletexts[i].type == 0x5))
+				sub_txt_cnt++;
+		}
+		if (c1->mTeletextInfo.teletext_count != sub_txt_cnt)
+			ret = 4;
+	}
+	if (ret == 0) {//check teletext
+		for (i=0; i<c1->mTeletextInfo.teletext_count; i++) {
+			for (j=0; j<c2->mTeletextInfo.teletext_count; j++) {
+				//remove the check below when teletext's stored for tvinput.
+				if ((c2->mTeletextInfo.teletexts[j].type != 0x2)
+					&& (c2->mTeletextInfo.teletexts[j].type != 0x5))
+					continue;
+				if (c1->mTeletextInfo.teletexts[i].pid == c2->mTeletextInfo.teletexts[j].pid &&
+					c1->mTeletextInfo.teletexts[i].type == c2->mTeletextInfo.teletexts[j].type &&
+					c1->mTeletextInfo.teletexts[i].magazine_no == c2->mTeletextInfo.teletexts[j].magazine_no &&
+					c1->mTeletextInfo.teletexts[i].page_no == c2->mTeletextInfo.teletexts[j].page_no &&
+					!strncmp(c1->mTeletextInfo.teletexts[i].lang, c2->mTeletextInfo.teletexts[j].lang, 3))
+					break;
+			}
+			if (j >= c2->mTeletextInfo.teletext_count) {
+				//notify
+				ret = 4;
+				break;
+			}
+		}
+	}
+
+	switch (ret) {
+		case 1:	{
+			log_info(">>> Video/Audio changed ");
+			log_info("Video pid/fmt: (%d/%d) -> (%d/%d)",
+				c1->mVideoPID, c1->mVideoFormat,
+				c2->mVideoPID, c2->mVideoFormat);
+			}break;
+		case 2: {
+			char str_prev_ainfo[3][256], str_cur_ainfo[3][256];
+			gen_audio_3strings(c1->mAudioInfo.audios, c1->mAudioInfo.audio_count, str_prev_ainfo, 256);
+			gen_audio_3strings(c2->mAudioInfo.audios, c2->mAudioInfo.audio_count, str_cur_ainfo, 256);
+			log_info(">>> Audio changed pid/fmt/lang:");
+			log_info("pid '%s'\nfmt '%s'\nlang '%s'", str_prev_ainfo[0], str_prev_ainfo[1], str_prev_ainfo[2]);
+			log_info("changed to ->\npid '%s'\nfmt '%s'\nlang '%s'", str_cur_ainfo[0], str_cur_ainfo[1], str_cur_ainfo[2]);
+			}break;
+		case 3: {
+			char str_prev_sinfo[5][256], str_cur_sinfo[5][256];
+			gen_subtitle_5strings(c1->mSubtitleInfo.subtitles, c1->mSubtitleInfo.subtitle_count, str_prev_sinfo, 256);
+			gen_subtitle_5strings(c2->mSubtitleInfo.subtitles, c2->mSubtitleInfo.subtitle_count, str_cur_sinfo, 256);
+			log_info(">>> Subtitle changed pid/type/id1/id2/lang");
+			log_info("pid [%s]\ntype [%s]\nid1 [%s]\nid2 [%s]\nlang [%s]",
+				str_prev_sinfo[0], str_prev_sinfo[1], str_prev_sinfo[2],str_prev_sinfo[3], str_prev_sinfo[4]);
+			log_info("changed to ->\npid [%s]\ntype [%s]\nid1 [%s]\nid2 [%s]\nlang [%s]",
+				str_cur_sinfo[0], str_cur_sinfo[1], str_cur_sinfo[2],str_cur_sinfo[3], str_cur_sinfo[4]);
+			}break;
+		case 4: {
+			char str_prev_tinfo[5][256], str_cur_tinfo[5][256];
+			gen_teletext_5strings(c1->mTeletextInfo.teletexts, c1->mTeletextInfo.teletext_count, str_prev_tinfo, 256);
+			gen_teletext_5strings(c2->mTeletextInfo.teletexts, c2->mTeletextInfo.teletext_count, str_cur_tinfo, 256);
+			log_info(">>> Teletext changed pid/type/id1/id2/lang");
+			log_info("pid [%s]\ntype [%s]\nid1 [%s]\nid2 [%s]\nlang [%s]",
+				str_prev_tinfo[0], str_prev_tinfo[1], str_prev_tinfo[2],str_prev_tinfo[3], str_prev_tinfo[4]);
+			log_info("changed to ->\npid [%s]\ntype [%s]\nid1 [%s]\nid2 [%s]\nlang [%s]",
+				str_cur_tinfo[0], str_cur_tinfo[1], str_cur_tinfo[2],str_cur_tinfo[3], str_cur_tinfo[4]);
+			}break;
 	}
 	return ret;
 }
 
+typedef struct {
+	int sub_count;
+	struct {
+		int type;
+		int pid;
+		int stype;
+		int id1;
+		int id2;
+		char lang[16];
+	}subs[AM_SI_MAX_SUB_CNT];
+}sub_t;
+
 #define FUNC_get_int_array(_n, _S, _c, _s, _e) \
 static jintArray get_##_n##_array(_S *s) \
 { \
@@ -335,9 +475,6 @@ static jintArray get_##_n##_array(_S *s) \
 	return result; \
 }
 
-FUNC_get_int_array(aids, AM_SI_AudioInfo_t, audio_count, audios, pid);
-FUNC_get_int_array(afmts, AM_SI_AudioInfo_t, audio_count, audios, fmt);
-
 #define FUNC_get_string_array(_n, _S, _c, _s, _e) \
 static jobjectArray get_##_n##_array(_S *s)\
 { \
@@ -373,8 +510,19 @@ static jobjectArray get_##_n##_array(_S *s)\
 	return args; \
 }
 
+/*for Audios*/
+FUNC_get_int_array(aids, AM_SI_AudioInfo_t, audio_count, audios, pid);
+FUNC_get_int_array(afmts, AM_SI_AudioInfo_t, audio_count, audios, fmt);
 FUNC_get_string_array(alangs, AM_SI_AudioInfo_t, audio_count, audios, lang);
 
+/*for Subs*/
+FUNC_get_int_array(sids, sub_t, sub_count, subs, pid);
+FUNC_get_int_array(stypes, sub_t, sub_count, subs, type);
+FUNC_get_int_array(sstypes, sub_t, sub_count, subs, stype);
+FUNC_get_int_array(sid1s, sub_t, sub_count, subs, id1);
+FUNC_get_int_array(sid2s, sub_t, sub_count, subs, id2);
+FUNC_get_string_array(slangs, sub_t, sub_count, subs, lang);
+
 static void PMT_Update(AM_EPG_Handle_t handle, dvbpsi_pmt_t *pmts)
 {
 	dvbpsi_pmt_t *pmt;
@@ -393,11 +541,12 @@ static void PMT_Update(AM_EPG_Handle_t handle, dvbpsi_pmt_t *pmts)
 	ch.mVideoFormat = -1;
 	ch.mPcrPID = (pmts) ? pmts->i_pcr_pid : 0x1fff;
 
+	log_info("PMT update");
 	AM_SI_LIST_BEGIN(pmts, pmt)
 		AM_SI_LIST_BEGIN(pmt->p_first_es, es)
 			AM_SI_ExtractAVFromES(es, &ch.mVideoPID, &ch.mVideoFormat, &ch.mAudioInfo);
-			//AM_SI_ExtractDVBSubtitleFromES(es, &ch.sub_info);
-			//AM_SI_ExtractDVBTeletextFromES(es, &ch.ttx_info);
+			AM_SI_ExtractDVBSubtitleFromES(es, &ch.mSubtitleInfo);
+			AM_SI_ExtractDVBTeletextFromES(es, &ch.mTeletextInfo);
 		AM_SI_LIST_END()
 	AM_SI_LIST_END()
 
@@ -407,6 +556,35 @@ static void PMT_Update(AM_EPG_Handle_t handle, dvbpsi_pmt_t *pmts)
 		/*update current*/
 		memcpy(pch_cur, &ch, sizeof(pch_cur[0]));
 
+		/*merge ebu subtitle & dvb subtitle*/
+		sub_t sub;
+		{
+			int i;
+			sub.sub_count = ch.mSubtitleInfo.subtitle_count;
+			for (i=0; i<ch.mSubtitleInfo.subtitle_count; i++) {
+				sub.subs[i].type = 1;
+				sub.subs[i].pid = ch.mSubtitleInfo.subtitles[i].pid;
+				sub.subs[i].stype = ch.mSubtitleInfo.subtitles[i].type;
+				sub.subs[i].id1 = ch.mSubtitleInfo.subtitles[i].comp_page_id;
+				sub.subs[i].id2 = ch.mSubtitleInfo.subtitles[i].anci_page_id;
+				strncpy(sub.subs[i].lang, ch.mSubtitleInfo.subtitles[i].lang, 10);
+			}
+			int nsub = sub.sub_count;
+			for (i=0; i<ch.mTeletextInfo.teletext_count && nsub<AM_SI_MAX_SUB_CNT; i++) {
+				if (ch.mTeletextInfo.teletexts[i].type != 0x2 &&
+			                ch.mTeletextInfo.teletexts[i].type != 0x5)
+			                continue;
+				sub.subs[nsub].type = 2;
+				sub.subs[nsub].pid = ch.mSubtitleInfo.subtitles[i].pid;
+				sub.subs[nsub].stype = ch.mSubtitleInfo.subtitles[i].type;
+				sub.subs[nsub].id1 = ch.mSubtitleInfo.subtitles[i].comp_page_id;
+				sub.subs[nsub].id2 = ch.mSubtitleInfo.subtitles[i].anci_page_id;
+				strncpy(sub.subs[nsub].lang, ch.mSubtitleInfo.subtitles[i].lang, 10);
+				nsub++;
+			}
+			sub.sub_count = nsub;
+		}
+
 		JNIEnv *env;
 		int ret;
 		int attached = 0;
@@ -441,6 +619,18 @@ static void PMT_Update(AM_EPG_Handle_t handle, dvbpsi_pmt_t *pmts)
 				(*env)->GetFieldID(env, gChannelClass, "mAudioFormats", "[I"), get_afmts_array(&ch.mAudioInfo));
 		(*env)->SetObjectField(env,channel,\
 				(*env)->GetFieldID(env, gChannelClass, "mAudioLangs", "[Ljava/lang/String;"), get_alangs_array(&ch.mAudioInfo));
+		(*env)->SetObjectField(env,channel,\
+				(*env)->GetFieldID(env, gChannelClass, "mSubtitlePids", "[I"), get_sids_array(&sub));
+		(*env)->SetObjectField(env,channel,\
+				(*env)->GetFieldID(env, gChannelClass, "mSubtitleTypes", "[I"), get_stypes_array(&sub));
+		(*env)->SetObjectField(env,channel,\
+				(*env)->GetFieldID(env, gChannelClass, "mSubtitleStypes", "[I"), get_sstypes_array(&sub));
+		(*env)->SetObjectField(env,channel,\
+				(*env)->GetFieldID(env, gChannelClass, "mSubtitleId1s", "[I"), get_sid1s_array(&sub));
+		(*env)->SetObjectField(env,channel,\
+				(*env)->GetFieldID(env, gChannelClass, "mSubtitleId2s", "[I"), get_sid2s_array(&sub));
+		(*env)->SetObjectField(env,channel,\
+				(*env)->GetFieldID(env, gChannelClass, "mSubtitleLangs", "[Ljava/lang/String;"), get_slangs_array(&sub));
 		(*env)->SetIntField(env,channel,\
 				(*env)->GetFieldID(env, gChannelClass, "mPcrPid", "I"), ch.mPcrPID);
 
@@ -463,79 +653,88 @@ static int epg_sdt_update_check_version(EPGChannelData *ch, dvbpsi_sdt_t *sdts)
 	return 1;
 }
 
-static int epg_sdt_update(AM_EPG_Handle_t handle, int type, void *tables, void *user_data)
-{
-	dvbpsi_sdt_t *sdts = (dvbpsi_sdt_t*)tables;
-	EPGChannelData *pch_cur = &gChannelMonitored;
-	dvbpsi_sdt_t *sdt;
-
-	UNUSED(type);
-	UNUSED(user_data);
-
-	if (sdts->i_table_id != AM_SI_TID_SDT_ACT)
-		return 1;
-
-	if (!pch_cur->valid)
-		return 1;
-
-	if (!epg_sdt_update_check_version(pch_cur, sdts))
-		return 2;
-
-	log_info("something changed.");
-
-	/*nid/tsid changed*/
-	if (((pch_cur->mOriginalNetworkId != -1) && (pch_cur->mOriginalNetworkId != sdts->i_network_id))
-		|| (pch_cur->mTransportStreamId != sdts->i_ts_id)) {
-		log_info("nid:[0x%04x->0x%04x] tsid:[0x%04x->0x%04x]",
-			pch_cur->mOriginalNetworkId, sdts->i_network_id,
-			pch_cur->mTransportStreamId, sdts->i_ts_id);
-		pch_cur->mOriginalNetworkId = sdts->i_network_id;
-		pch_cur->mTransportStreamId = sdts->i_ts_id;
-		pch_cur->mSdtVersion = sdts->i_version;
-		epg_evt_callback((long)handle, AM_EPG_EVT_UPDATE_TS, 0, NULL);
-		return 0;
-	}
-
-	/*version changed*/
-	if ((pch_cur->mSdtVersion != 0xff) && (pch_cur->mSdtVersion != sdts->i_version)) {
-		log_info("sdt ver:[%d->%d]", pch_cur->mSdtVersion, sdts->i_version);
-		pch_cur->mOriginalNetworkId = sdts->i_network_id;
-		pch_cur->mTransportStreamId = sdts->i_ts_id;
-		pch_cur->mSdtVersion = sdts->i_version;
-		epg_evt_callback((long)handle, AM_EPG_EVT_UPDATE_TS, 0, NULL);
-		return 0;
+static int string_cat(void *d, int n_d, void *s, int n_s) {
+	int l = strlen(d);
+	if ((l+n_s) < n_d) {
+		memcpy(((unsigned char*)d)+l, s, n_s);
+		((unsigned char*)d)[l+n_s] = 0;
+		return n_s;
 	}
+	return 0;
+}
 
-	pch_cur->mOriginalNetworkId = sdts->i_network_id;
-	pch_cur->mTransportStreamId = sdts->i_ts_id;
-	pch_cur->mSdtVersion = sdts->i_version;
+static int sdt_get_services(dvbpsi_sdt_t *sdts, EPGChannelData *pch_cur) {
+	dvbpsi_sdt_t *sdt;
 
 	AM_SI_LIST_BEGIN(sdts, sdt)
 	dvbpsi_sdt_service_t *srv;
 	AM_SI_LIST_BEGIN(sdt->p_first_service, srv)
 		dvbpsi_descriptor_t *descr;
 
-		if (srv->i_service_id != pch_cur->mServiceId)
+		sdt_service_t *pservice = calloc(sizeof(sdt_service_t), 1);
+		if (!pservice) {
+			log_error("No memory for sdt update");
 			continue;
+		}
+
+		pservice->id = srv->i_service_id;
+		pservice->running = srv->i_running_status;
+		pservice->free_ca = srv->b_free_ca;
 
 		AM_SI_LIST_BEGIN(srv->p_first_descriptor, descr)
-		if (descr->p_decoded && descr->i_tag == AM_SI_DESCR_SERVICE)
-		{
+		if (descr->p_decoded && descr->i_tag == AM_SI_DESCR_SERVICE) {
 			dvbpsi_service_dr_t *psd = (dvbpsi_service_dr_t*)descr->p_decoded;
 			char name[AM_DB_MAX_SRV_NAME_LEN + 4];
 			char *old_name = pch_cur->name;
-			if (psd->i_service_name_length > 0)
-			{
+
+			pservice->type = psd->i_service_type;
+
+			if (psd->i_service_name_length > 0) {
 				AM_SI_ConvertDVBTextCode((char*)psd->i_service_name, psd->i_service_name_length,\
 							name, AM_DB_MAX_SRV_NAME_LEN);
 				name[AM_DB_MAX_SRV_NAME_LEN+3] = 0;
-				log_info("SDT Update: Program name changed: %s -> %s", old_name, name);
+
+				sprintf(pservice->name, "xxx%s", name);
+
+				if (pch_cur->mServiceId == pservice->id) {
+					log_info("SDT Update: Program name changed: %s -> %s", old_name, name);
+					memcpy(pch_cur->name, name, sizeof(pch_cur->name));
+				}
 			}
 		}
+
+		if (descr->p_decoded && descr->i_tag == AM_SI_DESCR_MULTI_SERVICE_NAME) {
+			int i;
+			dvbpsi_multi_service_name_dr_t *pmsnd = (dvbpsi_multi_service_name_dr_t*)descr->p_decoded;
+			char name[AM_DB_MAX_SRV_NAME_LEN + 4];
+			for (i=0; i<pmsnd->i_name_count; i++) {
+				name[0] = 0;
+				AM_SI_ConvertDVBTextCode((char*)pmsnd->p_service_name[i].i_service_name,
+					pmsnd->p_service_name[i].i_service_name_length,
+					name, AM_DB_MAX_SRV_NAME_LEN);
+				name[AM_DB_MAX_SRV_NAME_LEN] = 0;
+
+				if (pservice->name[0]) {
+					char split[] = SPLIT_MULTINAME;
+					string_cat(pservice->name, MAX_LEN_MULTINAME, split, LEN_SPLIT_MULTINAME);
+				}
+				string_cat(pservice->name, MAX_LEN_MULTINAME, pmsnd->p_service_name[i].i_iso_639_code, 3);
+				string_cat(pservice->name, MAX_LEN_MULTINAME, name, strlen(name));
+			}
+		}
+
 		AM_SI_LIST_END()
+
+		pservice->next = pch_cur->services;
+		pch_cur->services = pservice;
+
 	AM_SI_LIST_END()
 	AM_SI_LIST_END()
 
+	return 0;
+}
+
+static void SDT_Update(AM_EPG_Handle_t handle, EPGChannelData *pch) {
 	JNIEnv *env;
 	int ret;
 	int attached = 0;
@@ -543,35 +742,133 @@ static int epg_sdt_update(AM_EPG_Handle_t handle, int type, void *tables, void *
 
 	AM_EPG_GetUserData(handle, (void**)&priv_data);
 	if (!priv_data)
-		return 1;
+		return ;
 
 	ret = (*gJavaVM)->GetEnv(gJavaVM, (void**) &env, JNI_VERSION_1_4);
 	if (ret <0) {
 		ret = (*gJavaVM)->AttachCurrentThread(gJavaVM,&env,NULL);
 		if (ret <0) {
 			log_error("callback handler:failed to attach current thread");
-			return 1;
+			return ;
 		}
 		attached = 1;
 	}
 
 	jobject event = (*env)->NewObject(env, gEventClass, gEventInitID, priv_data->obj, EVENT_PROGRAM_NAME_UPDATE);
+
 	jobject channel = (*env)->NewObject(env, gChannelClass, gChannelInitID, event, 0);
 
 	(*env)->SetIntField(env,channel,\
-			(*env)->GetFieldID(env, gChannelClass, "mSdtVersion", "I"), pch_cur->mSdtVersion);
+			(*env)->GetFieldID(env, gChannelClass, "mSdtVersion", "I"), pch->mSdtVersion);
 	(*env)->SetIntField(env,channel,\
-			(*env)->GetFieldID(env, gChannelClass, "mOriginalNetworkId", "I"), pch_cur->mOriginalNetworkId);
+			(*env)->GetFieldID(env, gChannelClass, "mOriginalNetworkId", "I"), pch->mOriginalNetworkId);
 	(*env)->SetObjectField(env,channel,\
-			(*env)->GetFieldID(env, gChannelClass, "mDisplayName", "Ljava/lang/String;"), (*env)->NewStringUTF(env, pch_cur->name));
+			(*env)->GetFieldID(env, gChannelClass, "mDisplayName", "Ljava/lang/String;"), (*env)->NewStringUTF(env, pch->name));
+	(*env)->SetIntField(env,channel,\
+			(*env)->GetFieldID(env, gChannelClass, "mServiceId", "I"), pch->mServiceId);
 
 	(*env)->SetObjectField(env,event,(*env)->GetFieldID(env, gEventClass, "channel", "Lcom/droidlogic/app/tv/ChannelInfo;"), channel);
 
+
+	jobject serviceinfos = (*env)->NewObject(env, gServiceInfosFromSDTClass, gServiceInfosFromSDTInitID, event, 0);
+
+	(*env)->SetIntField(env, serviceinfos,\
+			(*env)->GetFieldID(env, gServiceInfosFromSDTClass, "mNetworkId", "I"), pch->mOriginalNetworkId);
+	(*env)->SetIntField(env, serviceinfos,\
+			(*env)->GetFieldID(env, gServiceInfosFromSDTClass, "mTSId", "I"), pch->mTransportStreamId);
+	(*env)->SetIntField(env, serviceinfos,\
+			(*env)->GetFieldID(env, gServiceInfosFromSDTClass, "mVersion", "I"), pch->mSdtVersion);
+
+	jclass list_cls = (*env)->FindClass(env, "java/util/ArrayList");
+	jmethodID list_costruct = (*env)->GetMethodID(env, list_cls , "<init>","()V");
+	jmethodID list_add  = (*env)->GetMethodID(env, list_cls,"add","(Ljava/lang/Object;)Z");
+
+	jobject services =  (*env)->NewObject(env, list_cls, list_costruct, serviceinfos, 0);
+
+	sdt_service_t *pservice = pch->services;
+	while (pservice) {
+		jobject service = (*env)->NewObject(env, gServiceInfoFromSDTClass, gServiceInfoFromSDTInitID, serviceinfos, 0);
+		(*env)->SetIntField(env, service,\
+			(*env)->GetFieldID(env, gServiceInfoFromSDTClass, "mId", "I"), pservice->id);
+		(*env)->SetIntField(env, service,\
+			(*env)->GetFieldID(env, gServiceInfoFromSDTClass, "mType", "I"), pservice->type);
+		(*env)->SetObjectField(env,service,\
+			(*env)->GetFieldID(env, gServiceInfoFromSDTClass, "mName", "Ljava/lang/String;"), (*env)->NewStringUTF(env, pservice->name));
+		(*env)->SetIntField(env, service,\
+			(*env)->GetFieldID(env, gServiceInfoFromSDTClass, "mRunning", "I"), pservice->running);
+		(*env)->SetIntField(env, service,\
+			(*env)->GetFieldID(env, gServiceInfoFromSDTClass, "mFreeCA", "I"), pservice->free_ca);
+
+		(*env)->CallBooleanMethod(env, services, list_add, service);
+
+		pservice = pservice->next;
+	}
+
+	(*env)->SetObjectField(env, serviceinfos,\
+			(*env)->GetFieldID(env, gServiceInfosFromSDTClass, "mServices", "Ljava/util/ArrayList;"), services);
+
+	(*env)->SetObjectField(env, event,\
+			(*env)->GetFieldID(env, gEventClass, "services", "Lcom/droidlogic/tvinput/services/DTVEpgScanner$Event$ServiceInfosFromSDT;"), serviceinfos);
+
 	(*env)->CallVoidMethod(env, priv_data->obj, gOnEventID, event);
 
 	if (attached) {
 		(*gJavaVM)->DetachCurrentThread(gJavaVM);
 	}
+}
+
+static int epg_sdt_update(AM_EPG_Handle_t handle, int type, void *tables, void *user_data)
+{
+	dvbpsi_sdt_t *sdts = (dvbpsi_sdt_t*)tables;
+	EPGChannelData *pch_cur = &gChannelMonitored;
+	dvbpsi_sdt_t *sdt;
+
+	UNUSED(type);
+	UNUSED(user_data);
+
+	if (sdts->i_table_id != AM_SI_TID_SDT_ACT)
+		return 1;
+
+	if (!pch_cur->valid)
+		return 1;
+
+	if (!epg_sdt_update_check_version(pch_cur, sdts))
+		return 2;
+
+	log_info("something changed.");
+
+	/*nid/tsid changed*/
+	if (((pch_cur->mOriginalNetworkId != -1) && (pch_cur->mOriginalNetworkId != sdts->i_network_id))
+		|| (pch_cur->mTransportStreamId != sdts->i_ts_id)) {
+		log_info("nid:[0x%04x->0x%04x] tsid:[0x%04x->0x%04x]",
+			pch_cur->mOriginalNetworkId, sdts->i_network_id,
+			pch_cur->mTransportStreamId, sdts->i_ts_id);
+		pch_cur->mOriginalNetworkId = sdts->i_network_id;
+		pch_cur->mTransportStreamId = sdts->i_ts_id;
+		pch_cur->mSdtVersion = sdts->i_version;
+		epg_evt_callback((long)handle, AM_EPG_EVT_UPDATE_TS, 0, NULL);
+		return 0;
+	}
+
+	/*version changed*/
+	if ((pch_cur->mSdtVersion != 0xff) && (pch_cur->mSdtVersion != sdts->i_version)) {
+		log_info("sdt ver:[%d->%d]", pch_cur->mSdtVersion, sdts->i_version);
+		pch_cur->mOriginalNetworkId = sdts->i_network_id;
+		pch_cur->mTransportStreamId = sdts->i_ts_id;
+		pch_cur->mSdtVersion = sdts->i_version;
+		epg_evt_callback((long)handle, AM_EPG_EVT_UPDATE_TS, 0, NULL);
+		return 0;
+	}
+
+	/*sdt not received yet, request name update*/
+	pch_cur->mOriginalNetworkId = sdts->i_network_id;
+	pch_cur->mTransportStreamId = sdts->i_ts_id;
+	pch_cur->mSdtVersion = sdts->i_version;
+
+	sdt_get_services(sdts, pch_cur);
+
+	SDT_Update(handle, pch_cur);
+
 	return 0;
 }
 
@@ -703,14 +1000,9 @@ static int get_channel_data(JNIEnv* env, jobject obj, jobject channel, EPGChanne
 	}
 	pch->mOriginalNetworkId = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mOriginalNetworkId", "I"));
 	pch->mTransportStreamId = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mTransportStreamId", "I"));
-	//pch->mType = (*env)->GetIntField(env, (*env)->GetFieldID(env, objclass, "mType", "I"),0);
-	//pch->mServiceType = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mServiceType", "I"),0);
 	pch->mServiceId = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mServiceId", "I"));
 	pch->mFrequency = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mFrequency", "I"));
 	pch->mBandwidth = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mBandwidth", "I"));
-	//pch->mModulation = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mModulation", "I"),0);
-	//pch->mSymbolRate = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mSymbolRate", "I"),0);
-	//pch->mFEMisc = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mFEMisc", "I"),0);
 	pch->mVideoPID = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mVideoPid", "I"));
 	pch->mVideoFormat = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mVfmt", "I"));
 	pch->mPcrPID = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mPcrPid", "I"));
@@ -720,6 +1012,7 @@ static int get_channel_data(JNIEnv* env, jobject obj, jobject channel, EPGChanne
 	if (aids && afmts) {
 		jint *paids = (*env)->GetIntArrayElements(env, aids, 0);
 		jint *pafmts = (*env)->GetIntArrayElements(env, afmts, 0);
+
 		pch->mAudioInfo.audio_count = (*env)->GetArrayLength(env, aids);
 		for (i=0; i<pch->mAudioInfo.audio_count; i++) {
 			jstring jstr = (*env)->GetObjectArrayElement(env, alangs, i);
@@ -728,10 +1021,60 @@ static int get_channel_data(JNIEnv* env, jobject obj, jobject channel, EPGChanne
 			pch->mAudioInfo.audios[i].fmt = pafmts[i];
 			strncpy(pch->mAudioInfo.audios[i].lang, str, 10);
 			(*env)->ReleaseStringUTFChars(env, jstr, str);
+			(*env)->DeleteLocalRef(env, jstr);
 		}
 		(*env)->ReleaseIntArrayElements(env, aids, paids, JNI_ABORT);
 		(*env)->ReleaseIntArrayElements(env, afmts, pafmts, JNI_ABORT);
 	}
+	jintArray stypes = (jintArray)(*env)->GetObjectField(env, channel, (*env)->GetFieldID(env, objclass, "mSubtitleTypes", "[I"));
+	jintArray sids = (jintArray)(*env)->GetObjectField(env, channel, (*env)->GetFieldID(env, objclass, "mSubtitlePids", "[I"));
+	jintArray sstypes = (jintArray)(*env)->GetObjectField(env, channel, (*env)->GetFieldID(env, objclass, "mSubtitleStypes", "[I"));
+	jintArray sid1s = (jintArray)(*env)->GetObjectField(env, channel, (*env)->GetFieldID(env, objclass, "mSubtitleId1s", "[I"));
+	jintArray sid2s = (jintArray)(*env)->GetObjectField(env, channel, (*env)->GetFieldID(env, objclass, "mSubtitleId2s", "[I"));
+	jobjectArray slangs = (jobjectArray)(*env)->GetObjectField(env, channel, (*env)->GetFieldID(env, objclass, "mSubtitleLangs", "[Ljava/lang/String;"));
+	if (sids && stypes && sstypes && sid1s && sid2s) {
+
+		jint *psids = (*env)->GetIntArrayElements(env, sids, 0);
+		jint *pstypes = (*env)->GetIntArrayElements(env, stypes, 0);
+		jint *psstypes = (*env)->GetIntArrayElements(env, sstypes, 0);
+		jint *psid1s = (*env)->GetIntArrayElements(env, sid1s, 0);
+		jint *psid2s = (*env)->GetIntArrayElements(env, sid2s, 0);
+
+		int subtitle_count = (*env)->GetArrayLength(env, sids);
+		for (i=0; i<subtitle_count; i++) {
+			if (pstypes[i] == 1) {//subtitle
+				jstring jstr = (*env)->GetObjectArrayElement(env, slangs, i);
+				const char *str = (char *)(*env)->GetStringUTFChars(env, jstr, 0);
+				int ii = pch->mSubtitleInfo.subtitle_count;
+				pch->mSubtitleInfo.subtitles[ii].pid = psids[i];
+				pch->mSubtitleInfo.subtitles[ii].type = psstypes[i];
+				pch->mSubtitleInfo.subtitles[ii].comp_page_id = psid1s[i];
+				pch->mSubtitleInfo.subtitles[ii].anci_page_id = psid2s[i];
+				strncpy(pch->mSubtitleInfo.subtitles[ii].lang, str, 10);
+				(*env)->ReleaseStringUTFChars(env, jstr, str);
+				(*env)->DeleteLocalRef(env, jstr);
+				pch->mSubtitleInfo.subtitle_count++;
+			} else if (pstypes[i] == 2) {//teletext subtitle
+				jstring jstr = (*env)->GetObjectArrayElement(env, slangs, i);
+				const char *str = (char *)(*env)->GetStringUTFChars(env, jstr, 0);
+				int ii = pch->mTeletextInfo.teletext_count;
+				pch->mTeletextInfo.teletexts[ii].pid = psids[i];
+				pch->mTeletextInfo.teletexts[ii].type = psstypes[i];
+				pch->mTeletextInfo.teletexts[ii].magazine_no = psid1s[i];
+				pch->mTeletextInfo.teletexts[ii].page_no = psid2s[i];
+				strncpy(pch->mTeletextInfo.teletexts[ii].lang, str, 10);
+				(*env)->ReleaseStringUTFChars(env, jstr, str);
+				(*env)->DeleteLocalRef(env, jstr);
+				pch->mTeletextInfo.teletext_count++;
+			}
+		}
+		(*env)->ReleaseIntArrayElements(env, sids,    psids,    JNI_ABORT);
+		(*env)->ReleaseIntArrayElements(env, stypes,  pstypes,  JNI_ABORT);
+		(*env)->ReleaseIntArrayElements(env, sstypes, psstypes, JNI_ABORT);
+		(*env)->ReleaseIntArrayElements(env, sid1s,   psid1s,   JNI_ABORT);
+		(*env)->ReleaseIntArrayElements(env, sid2s,   psid2s,   JNI_ABORT);
+	}
+
 	pch->mSdtVersion = (*env)->GetIntField(env, channel, (*env)->GetFieldID(env, objclass, "mSdtVersion", "I"));
 	pch->valid = 1;
 	return 0;
@@ -850,6 +1193,14 @@ JNI_OnLoad(JavaVM* vm, void* reserved)
 	gChannelClass   = (jclass)(*env)->NewGlobalRef(env, (jobject)gChannelClass);
 	gChannelInitID  = (*env)->GetMethodID(env, gChannelClass, "<init>", "()V");
 
+	gServiceInfosFromSDTClass   = (*env)->FindClass(env, "com/droidlogic/tvinput/services/DTVEpgScanner$Event$ServiceInfosFromSDT");
+	gServiceInfosFromSDTClass   = (jclass)(*env)->NewGlobalRef(env, (jobject)gServiceInfosFromSDTClass);
+	gServiceInfosFromSDTInitID  = (*env)->GetMethodID(env, gServiceInfosFromSDTClass, "<init>", "(Lcom/droidlogic/tvinput/services/DTVEpgScanner$Event;)V");
+
+	gServiceInfoFromSDTClass   = (*env)->FindClass(env, "com/droidlogic/tvinput/services/DTVEpgScanner$Event$ServiceInfosFromSDT$ServiceInfoFromSDT");
+	gServiceInfoFromSDTClass   = (jclass)(*env)->NewGlobalRef(env, (jobject)gServiceInfoFromSDTClass);
+	gServiceInfoFromSDTInitID  = (*env)->GetMethodID(env, gServiceInfoFromSDTClass, "<init>", "(Lcom/droidlogic/tvinput/services/DTVEpgScanner$Event$ServiceInfosFromSDT;)V");
+
 	return JNI_VERSION_1_4;
 }
 
@@ -867,5 +1218,7 @@ JNI_OnUnload(JavaVM* vm, void* reserved)
 	(*env)->DeleteGlobalRef(env, (jobject)gChannelClass);
 	(*env)->DeleteGlobalRef(env, (jobject)gEventClass);
 	(*env)->DeleteGlobalRef(env, (jobject)gEvtClass);
+	(*env)->DeleteGlobalRef(env, (jobject)gServiceInfosFromSDTClass);
+	(*env)->DeleteGlobalRef(env, (jobject)gServiceInfoFromSDTClass);
 }
 
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m1.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m1.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m10.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m10.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m11.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m11.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m12.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m12.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m13.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m13.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m14.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m14.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m15.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m15.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m16.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m16.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m17.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m17.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m18.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m18.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m19.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m19.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m2.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m2.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m20.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m20.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m21.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m21.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m3.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m3.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m4.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m4.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m5.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m5.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m6.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m6.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m7.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m7.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m8.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m8.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m9.png b/amlogic/apps/TvInput/DroidLogicTvInput/res/drawable-mdpi/progress_m9.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/layout/layout_option_list.xml b/amlogic/apps/TvInput/DroidLogicTvInput/res/layout/layout_option_list.xml
index 8127b75..ac3ea82 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/res/layout/layout_option_list.xml
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/res/layout/layout_option_list.xml
@@ -18,7 +18,7 @@
     <com.droidlogic.tvinput.settings.OptionListView
         android:id="@+id/option_list"
         android:layout_width="262dp"
-        android:layout_height="wrap_content"
+        android:layout_height="375dp"
         android:layout_marginTop="30dp"
         android:layout_marginLeft="31dp"
         android:listSelector="@drawable/item_background"
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/values/strings.xml b/amlogic/apps/TvInput/DroidLogicTvInput/res/values/strings.xml
index 701bd31..d57c234 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/res/values/strings.xml
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/res/values/strings.xml
@@ -138,6 +138,7 @@
     <string name="tv">TV</string>
     <string name="radio">Radio</string>
     <string name="hdmi20">HDMI 2.0</string>
+    <string name="fbc_upgrade">FBC Upgrade</string>
 
     <string name="ensure_restore">ensure restore</string>
     <string name="ok">OK</string>
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/xml/list_settings.xml b/amlogic/apps/TvInput/DroidLogicTvInput/res/xml/list_settings.xml
index 5b316d7..171187e 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/res/xml/list_settings.xml
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/res/xml/list_settings.xml
@@ -42,6 +42,11 @@
     </Preference>
 
     <Preference
+        android:key="fbc_upgrade"
+        android:title="@string/fbc_upgrade" >
+    </Preference>
+
+    <Preference
         android:key="hdmi20"
         android:title="@string/hdmi20" >
     </Preference>
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/res/xml/spdifinputservice.xml b/amlogic/apps/TvInput/DroidLogicTvInput/res/xml/spdifinputservice.xml
new file mode 100644
index 0000000..ebb5b22
--- /dev/null
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/res/xml/spdifinputservice.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2015 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<tv-input xmlns:android="http://schemas.android.com/apk/res/android"
+    android:setupActivity="com.droidlogic.tvinput.settings.TvSettingsActivity"
+    android:settingsActivity="com.droidlogic.tvinput.shortcut.ShortCutActivity" />
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/ATVInputService.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/ATVInputService.java
index 8a1ecbd..a7c73dc 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/ATVInputService.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/ATVInputService.java
@@ -28,14 +28,19 @@ import java.util.HashSet;
 import java.util.Set;
 import com.droidlogic.app.tv.TvControlManager;
 
+import java.util.HashMap;
+import java.util.Map;
+import android.view.Surface;
+
 public class ATVInputService extends DroidLogicTvInputService {
 
     private static final String TAG = "ATVInputService";
 
     private ATVSessionImpl mCurrentSession;
     private ChannelInfo mCurrentChannel = null;
-    private int number = 0;
-    private int currentNumber = 0;
+    private int id = 0;
+    private Map<Integer, ATVSessionImpl> sessionMap = new HashMap<>();
+
 
     private final BroadcastReceiver mParentalControlsBroadcastReceiver = new BroadcastReceiver() {
         @Override
@@ -68,11 +73,32 @@ public class ATVInputService extends DroidLogicTvInputService {
 
         mCurrentSession = new ATVSessionImpl(this, inputId, getHardwareDeviceId(inputId));
         registerInputSession(mCurrentSession);
-        mCurrentSession.setNumber(number);
-        number++;
+        mCurrentSession.setSessionId(id);
+        sessionMap.put(id, mCurrentSession);
+        id++;
         return mCurrentSession;
     }
 
+    @Override
+    public void setCurrentSessionById(int sessionId) {
+        Utils.logd(TAG, "setCurrentSessionById:"+sessionId);
+        ATVSessionImpl session = sessionMap.get(sessionId);
+        if (session != null) {
+            mCurrentSession = session;
+        }
+    }
+
+    @Override
+    public void doTuneFinish(int result, Uri uri, int sessionId) {
+        Utils.logd(TAG, "doTuneFinish,result:"+result+"sessionId:"+sessionId);
+        if (result == ACTION_SUCCESS) {
+            ATVSessionImpl session = sessionMap.get(sessionId);
+            if (session != null)
+                session.switchToSourceInput(uri);
+        }
+    }
+
+
     public class ATVSessionImpl extends TvInputBaseSession {
         private final Context mContext;
         private TvInputManager mTvInputManager;
@@ -91,23 +117,14 @@ public class ATVInputService extends DroidLogicTvInputService {
             mLastBlockedRating = null;
             mCurrentChannel = null;
         }
-
-        public TvStreamConfig[] getConfigs() {
-            return mConfigs;
-        }
-
-        public Hardware getHardware() {
-            return mHardware;
-        }
-
-        public int getCurrentSessionNumber() {
-            return currentNumber;
+        @Override
+        public boolean onSetSurface(Surface surface) {
+            return setSurfaceInService(surface,this);
         }
 
-        public void setCurrentSession() {
-           currentNumber = getNumber();
-           mCurrentSession = this;
-           registerInputSession(mCurrentSession);
+        @Override
+        public boolean onTune(Uri channelUri) {
+            return doTuneInService(channelUri, getSessionId());
         }
 
         @Override
@@ -116,15 +133,6 @@ public class ATVInputService extends DroidLogicTvInputService {
         }
 
         @Override
-        public int doTune(Uri uri) {
-            int ret = super.doTune(uri);
-            if (ret == ACTION_SUCCESS) {
-                switchToSourceInput(uri);
-            }
-            return ret;
-        }
-
-        @Override
         public void doAppPrivateCmd(String action, Bundle bundle) {
             super.doAppPrivateCmd(action, bundle);
             if (TextUtils.equals(DroidLogicTvUtils.ACTION_STOP_TV, action)) {
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/AV1InputService.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/AV1InputService.java
index 719de38..99427d8 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/AV1InputService.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/AV1InputService.java
@@ -20,11 +20,15 @@ import android.os.Bundle;
 import android.text.TextUtils;
 import android.view.Surface;
 
+import java.util.HashMap;
+import java.util.Map;
+import android.net.Uri;
+
 public class AV1InputService extends DroidLogicTvInputService {
     private static final String TAG = AV1InputService.class.getSimpleName();;
     private AV1InputSession mCurrentSession;
-    private int number = 0;
-    private int currentNumber = 0;
+    private int id = 0;
+    private Map<Integer, AV1InputSession> sessionMap = new HashMap<>();
 
     @Override
     public Session onCreateSession(String inputId) {
@@ -32,34 +36,37 @@ public class AV1InputService extends DroidLogicTvInputService {
 
         mCurrentSession = new AV1InputSession(getApplicationContext(), inputId, getHardwareDeviceId(inputId));
         registerInputSession(mCurrentSession);
-        mCurrentSession.setNumber(number);
-        number++;
+        mCurrentSession.setSessionId(id);
+        sessionMap.put(id, mCurrentSession);
+        id++;
 
         return mCurrentSession;
     }
 
+    @Override
+    public void setCurrentSessionById(int sessionId) {
+        Utils.logd(TAG, "setCurrentSessionById:"+sessionId);
+        AV1InputSession session = sessionMap.get(sessionId);
+        if (session != null) {
+            mCurrentSession = session;
+        }
+    }
+
+
+
     public class AV1InputSession extends TvInputBaseSession {
         public AV1InputSession(Context context, String inputId, int deviceId) {
             super(context, inputId, deviceId);
             Utils.logd(TAG, "=====new AVInputSession=====");
         }
 
-        public TvStreamConfig[] getConfigs() {
-            return mConfigs;
-        }
-
-        public Hardware getHardware() {
-            return mHardware;
-        }
-
-        public int getCurrentSessionNumber() {
-            return currentNumber;
+        @Override
+        public boolean onSetSurface(Surface surface) {
+            return setSurfaceInService(surface,this);
         }
-
-        public void setCurrentSession() {
-           currentNumber = getNumber();
-           mCurrentSession = this;
-           registerInputSession(mCurrentSession);
+        @Override
+        public boolean onTune(Uri channelUri) {
+            return doTuneInService(channelUri, getSessionId());
         }
 
         @Override
@@ -75,10 +82,6 @@ public class AV1InputService extends DroidLogicTvInputService {
             }
         }
 
-        @Override
-        public void doSetSurface(Surface surface) {
-            super.doSetSurface(surface);
-        }
     }
 
     public TvInputInfo onHardwareAdded(TvInputHardwareInfo hardwareInfo) {
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/AV2InputService.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/AV2InputService.java
index 84f7da1..0b95430 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/AV2InputService.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/AV2InputService.java
@@ -20,11 +20,15 @@ import android.os.Bundle;
 import android.text.TextUtils;
 import android.view.Surface;
 
+import java.util.HashMap;
+import java.util.Map;
+import android.net.Uri;
+
 public class AV2InputService extends DroidLogicTvInputService {
     private static final String TAG = AV1InputService.class.getSimpleName();;
     private AV2InputSession mCurrentSession;
-    private int number = 0;
-    private int currentNumber = 0;
+    private int id = 0;
+    private Map<Integer, AV2InputSession> sessionMap = new HashMap<>();
 
     @Override
     public Session onCreateSession(String inputId) {
@@ -32,34 +36,39 @@ public class AV2InputService extends DroidLogicTvInputService {
 
         mCurrentSession = new AV2InputSession(getApplicationContext(), inputId, getHardwareDeviceId(inputId));
         registerInputSession(mCurrentSession);
-        mCurrentSession.setNumber(number);
-        number++;
+        mCurrentSession.setSessionId(id);
+        sessionMap.put(id, mCurrentSession);
+        /**** END  ****/
+        id++;
 
         return mCurrentSession;
     }
 
+    @Override
+    public void setCurrentSessionById(int sessionId) {
+        Utils.logd(TAG, "setCurrentSessionById:"+sessionId);
+        AV2InputSession session = sessionMap.get(sessionId);
+        if (session != null) {
+            mCurrentSession = session;
+        }
+    }
+
+
+
     public class AV2InputSession extends TvInputBaseSession {
         public AV2InputSession(Context context, String inputId, int deviceId) {
             super(context, inputId, deviceId);
             Utils.logd(TAG, "=====new AVInputSession=====");
         }
 
-        public TvStreamConfig[] getConfigs() {
-            return mConfigs;
-        }
-
-        public Hardware getHardware() {
-            return mHardware;
-        }
-
-        public int getCurrentSessionNumber() {
-            return currentNumber;
+        @Override
+        public boolean onSetSurface(Surface surface) {
+            return setSurfaceInService(surface,this);
         }
 
-        public void setCurrentSession() {
-           currentNumber = getNumber();
-           mCurrentSession = this;
-           registerInputSession(mCurrentSession);
+        @Override
+        public boolean onTune(Uri channelUri) {
+            return doTuneInService(channelUri, getSessionId());
         }
 
         @Override
@@ -74,11 +83,6 @@ public class AV2InputService extends DroidLogicTvInputService {
                 stopTv();
             }
         }
-
-        @Override
-        public void doSetSurface(Surface surface) {
-            super.doSetSurface(surface);
-        }
     }
 
     public TvInputInfo onHardwareAdded(TvInputHardwareInfo hardwareInfo) {
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/DTVEpgScanner.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/DTVEpgScanner.java
index 1bed049..e6046ba 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/DTVEpgScanner.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/DTVEpgScanner.java
@@ -1,6 +1,8 @@
 package com.droidlogic.tvinput.services;
 
 import android.util.Log;
+import java.util.ArrayList;
+import java.util.Arrays;
 
 import com.droidlogic.app.tv.TVChannelParams;
 import com.droidlogic.app.tv.ChannelInfo;
@@ -57,6 +59,7 @@ abstract public class DTVEpgScanner {
         public int dvbVersion;
         public Evt[] evts;
         public ChannelInfo channel;
+        public ServiceInfosFromSDT services;
 
         public class Evt {
             int src;
@@ -80,6 +83,25 @@ abstract public class DTVEpgScanner {
             Evt() {}
         }
 
+        public class ServiceInfosFromSDT {
+
+            public int mNetworkId;
+            public int mTSId;
+            public int mVersion;
+            public ArrayList<ServiceInfoFromSDT> mServices;
+
+            public class ServiceInfoFromSDT {
+                public int mId;
+                public int mType;
+                public String mName;
+                public int mRunning;
+                public int mFreeCA;
+
+                ServiceInfoFromSDT(){}
+            }
+            ServiceInfosFromSDT(){}
+        }
+
         public Event(int type) {
             this.type = type;
         }
@@ -104,8 +126,10 @@ abstract public class DTVEpgScanner {
     private int fend_type   = -1;
     private ChannelInfo mChannel;
 
+    private int mode;
+
     /*Start scan the sections.*/
-    private void startScan(int mode) {
+    public void startScan(int mode) {
         if (!created)
             return;
 
@@ -113,14 +137,15 @@ abstract public class DTVEpgScanner {
     }
 
     /*Stop scan the sections.*/
-    private void stopScan(int mode) {
+    public void stopScan(int mode) {
         if (!created)
             return;
 
         native_epg_change_mode(MODE_REMOVE, mode);
     }
 
-    public DTVEpgScanner() {
+    public DTVEpgScanner(int mode) {
+        this.mode = mode;
     }
 
     public void setSource(int fend, int dmx, int src, String textLanguages) {
@@ -151,11 +176,14 @@ abstract public class DTVEpgScanner {
 
         Log.d(TAG, "enter Channel");
 
+        startScan(mode);
+/*
         if (fend_type == TVChannelParams.MODE_ATSC) {
             startScan(SCAN_PSIP_EIT | SCAN_MGT | SCAN_VCT | SCAN_RRT | SCAN_STT);
         } else {
-            startScan(SCAN_EIT_ALL | SCAN_TDT | SCAN_SDT/*|SCAN_NIT|SCAN_CAT*/);
+            startScan(SCAN_EIT_ALL | SCAN_TDT | SCAN_SDT);//SCAN_NIT|SCAN_CAT
         }
+*/
     }
 
     /*Leave the channel.*/
@@ -170,11 +198,13 @@ abstract public class DTVEpgScanner {
 
     /*Enter the program.*/
     public void enterProgram(ChannelInfo channel) {
+        /*do not check this, we need show all channel info to lower level.
         if (mChannel != null
             && channel.getServiceId() == mChannel.getServiceId()
             && channel.getTransportStreamId() == mChannel.getTransportStreamId()
             && channel.getOriginalNetworkId() == mChannel.getOriginalNetworkId())
             return;
+        */
 
         if (!created)
             return;
@@ -183,7 +213,8 @@ abstract public class DTVEpgScanner {
             leaveProgram();
         }
 
-        Log.d(TAG, "enter Program sid[" + channel.getServiceId() + "] name[" + channel.getDisplayName() + "]");
+        Log.d(TAG, "enter Program sid["+channel.getServiceId()+"] name["+channel.getDisplayName()+"]");
+        Log.d(TAG, "\tapid:["+Arrays.toString(channel.getAudioPids())+"] spid:["+Arrays.toString(channel.getSubtitlePids())+"]");
 
         native_epg_monitor_service(channel);
         startScan(SCAN_PAT | SCAN_PMT);
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/DTVInputService.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/DTVInputService.java
index 4d51314..5306d81 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/DTVInputService.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/DTVInputService.java
@@ -37,6 +37,7 @@ import com.droidlogic.app.tv.TvInputBaseSession;
 import com.droidlogic.app.tv.Program;
 import com.droidlogic.app.tv.TVMultilingualText;
 import com.droidlogic.app.tv.TVTime;
+import com.droidlogic.app.SystemControlManager;
 
 import java.util.HashSet;
 import java.util.Set;
@@ -48,14 +49,21 @@ import java.util.Arrays;
 
 import com.droidlogic.app.tv.TvControlManager;
 
+import java.util.HashMap;
+import java.util.Map;
+import android.net.Uri;
+import android.view.Surface;
+
 public class DTVInputService extends DroidLogicTvInputService {
 
     private static final String TAG = "DTVInputService";
 
+    private static final String DTV_AUTO_RESCAN_SERVICE = "tv.dtv.auto_rescan_service";
+
     private DTVSessionImpl mCurrentSession;
-    private int number = 0;
-    private int currentNumber = 0;
+    private int id = 0;
 
+    private Map<Integer, DTVSessionImpl> sessionMap = new HashMap<>();
     private final BroadcastReceiver mParentalControlsBroadcastReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -65,7 +73,7 @@ public class DTVInputService extends DroidLogicTvInputService {
                     || action.equals(TvInputManager.ACTION_PARENTAL_CONTROLS_ENABLED_CHANGED)) {
                     mCurrentSession.checkContentBlockNeeded();
                 } else if (action.equals(Intent.ACTION_TIME_CHANGED)) {
-                    mCurrentSession.restartEPGTime();
+                    mCurrentSession.restartMonitorTime();
                 }
             }
         }
@@ -95,12 +103,52 @@ public class DTVInputService extends DroidLogicTvInputService {
 
         mCurrentSession = new DTVSessionImpl(this, inputId, getHardwareDeviceId(inputId));
         registerInputSession(mCurrentSession);
-        mCurrentSession.setNumber(number);
-        number++;
+        mCurrentSession.setSessionId(id);
+        sessionMap.put(id, mCurrentSession);
+        id++;
 
         return mCurrentSession;
     }
 
+    @Override
+    public void tvPlayStopped(int sessionId) {
+        DTVSessionImpl session = sessionMap.get(sessionId);
+        if (session != null) {
+            session.stopSubtitle();
+            session.setMonitor(null);
+        }
+    }
+
+    @Override
+    public void setCurrentSessionById(int sessionId) {
+        Utils.logd(TAG, "setCurrentSessionById:"+sessionId);
+        DTVSessionImpl session = sessionMap.get(sessionId);
+        if (session != null) {
+            mCurrentSession = session;
+        }
+    }
+
+    @Override
+    public void doTuneFinish(int result, Uri uri, int sessionId) {
+        Log.d(TAG, "doTuneFinish,result:"+result+"sessionId:"+sessionId);
+        if (result == ACTION_SUCCESS) {
+            DTVSessionImpl session = sessionMap.get(sessionId);
+            if (session != null)
+                session.switchToSourceInput(uri);
+        }
+    }
+
+    /*set below 3 vars true to enable tracks-auto-select in this service.*/
+    private static boolean subtitleAutoSave = false;
+    private static boolean audioAutoSave = false;
+    private static boolean subtitleAutoStart = false;
+
+    /*only one monitor instance for all sessions*/
+    private static HandlerThread mHandlerThread = null;
+    private static Handler mHandler = null;
+    private static DTVSessionImpl.DTVMonitor monitor = null;
+    private final Object mLock = new Object();
+
     public class DTVSessionImpl extends TvInputBaseSession implements TvControlManager.AVPlaybackListener {
         private final Context mContext;
         private TvInputManager mTvInputManager;
@@ -110,6 +158,8 @@ public class DTVInputService extends DroidLogicTvInputService {
         private TvContentRating mCurrentContentRating;
         private final Set<TvContentRating> mUnblockedRatingSet = new HashSet<>();
         private ChannelInfo mCurrentChannel;
+        private Uri  mCurrentUri;
+        private SystemControlManager mSystemControlManager;
 
         protected DTVSessionImpl(Context context, String inputId, int deviceId) {
             super(context, inputId, deviceId);
@@ -117,51 +167,27 @@ public class DTVInputService extends DroidLogicTvInputService {
             mContext = context;
             mTvDataBaseManager = new TvDataBaseManager(mContext);
             mTvControlManager = TvControlManager.getInstance();
+            mSystemControlManager = new SystemControlManager(mContext);
             mLastBlockedRating = null;
             mCurrentChannel = null;
+            mCurrentUri = null;
         }
 
-        public TvStreamConfig[] getConfigs() {
-            return mConfigs;
-        }
-
-        public Hardware getHardware() {
-            return mHardware;
-        }
-
-        public int getCurrentSessionNumber() {
-            return currentNumber;
-        }
-
-        public void setCurrentSession() {
-           currentNumber = getNumber();
-           mCurrentSession = this;
-           registerInputSession(mCurrentSession);
+        @Override
+        public boolean onSetSurface(Surface surface) {
+            return setSurfaceInService(surface,this);
         }
 
         @Override
-        public int stopTvPlay() {
-            int ret = super.stopTvPlay();
-            if (ret == ACTION_SUCCESS) {
-                stopSubtitle();
-            }
-            return ret;
+        public boolean onTune(Uri channelUri) {
+            return doTuneInService(channelUri, getSessionId());
         }
 
         @Override
         public void doRelease() {
             super.doRelease();
             stopSubtitle();
-            setEPG(null);
-        }
-
-        @Override
-        public int doTune(Uri uri) {
-            int ret = super.doTune(uri);
-            if (ret == ACTION_SUCCESS) {
-                switchToSourceInput(uri);
-            }
-            return ret;
+            setMonitor(null);
         }
 
         @Override
@@ -172,7 +198,21 @@ public class DTVInputService extends DroidLogicTvInputService {
             } else if (TextUtils.equals(DroidLogicTvUtils.ACTION_STOP_PLAY, action)) {
                 Log.d(TAG, "do private cmd: STOP_PLAY");
                 stopSubtitle();
-                setEPG(null);
+                setMonitor(null);
+                releasePlayer();
+            } else if (TextUtils.equals(DroidLogicTvUtils.ACTION_DTV_AUTO_TRACKS, action)) {
+                Log.d(TAG, "do private cmd: AUTO_TRACKS");
+                subtitleAutoSave = true;
+                audioAutoSave = true;
+                subtitleAutoStart = true;
+                if (mCurrentChannel != null)
+                    startSubtitle(mCurrentChannel);
+            } else if (DroidLogicTvUtils.ACTION_DTV_AUTO_SCAN.equals(action)
+                || DroidLogicTvUtils.ACTION_DTV_MANUAL_SCAN.equals(action)) {
+                Log.d(TAG, "do private cmd: DTV_XXX_SCAN, stop play...");
+                mCurrentUri = null;
+                stopSubtitle();
+                setMonitor(null);
                 releasePlayer();
             }
         }
@@ -186,6 +226,7 @@ public class DTVInputService extends DroidLogicTvInputService {
         }
 
         private void switchToSourceInput(Uri uri) {
+            mCurrentUri = uri;
             mUnblockedRatingSet.clear();
             Log.d(TAG, "switchToSourceInput  uri=" + uri);
             if (Utils.getChannelId(uri) < 0) {
@@ -230,7 +271,7 @@ public class DTVInputService extends DroidLogicTvInputService {
 
             startSubtitle(info);
 
-            setEPG(info);
+            setMonitor(info);
 
             checkContentBlockNeeded();
             return true;
@@ -283,6 +324,8 @@ public class DTVInputService extends DroidLogicTvInputService {
                 if (mCurrentChannel != null && ChannelInfo.isRadioChannel(mCurrentChannel)) {
                     notifyVideoAvailable();
                 }
+            } else if (msgType == TvControlManager.EVENT_AV_VIDEO_AVAILABLE) {
+                notifyVideoAvailable();
             }
         }
 
@@ -294,31 +337,45 @@ public class DTVInputService extends DroidLogicTvInputService {
                 return false;
 
             if (type == TvTrackInfo.TYPE_AUDIO) {
+                int index = -1;
                 Map<String, String> parsedMap = ChannelInfo.stringToMap(trackId);
+                index = Integer.parseInt(parsedMap.get("id"));
                 mTvControlManager.DtvSwitchAudioTrack(Integer.parseInt(parsedMap.get("pid")),
                                         Integer.parseInt(parsedMap.get("fmt")),
                                         0);
 
                 notifyTrackSelected(type, trackId);
 
+                if (audioAutoSave) {
+                    Log.d(TAG, "audioAutoSave: idx=" + index);
+                    mCurrentChannel.setAudioTrackIndex(index);
+                    mTvDataBaseManager.updateChannelInfo(mCurrentChannel);
+                }
+
                 return true;
 
             } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
+                int index = -1;
                 if (trackId == null) {
                     stopSubtitle();
-                    notifyTrackSelected(type, trackId);
-                    return true;
+                    index = -2;
+                } else {
+                    Map<String, String> parsedMap = ChannelInfo.stringToMap(trackId);
+                    index = Integer.parseInt(parsedMap.get("id"));
+                    startSubtitle(Integer.parseInt(parsedMap.get("type")),
+                                  Integer.parseInt(parsedMap.get("pid")),
+                                  Integer.parseInt(parsedMap.get("stype")),
+                                  Integer.parseInt(parsedMap.get("uid1")),
+                                  Integer.parseInt(parsedMap.get("uid2")));
                 }
-
-                Map<String, String> parsedMap = ChannelInfo.stringToMap(trackId);
-                startSubtitle(Integer.parseInt(parsedMap.get("type")),
-                              Integer.parseInt(parsedMap.get("pid")),
-                              Integer.parseInt(parsedMap.get("stype")),
-                              Integer.parseInt(parsedMap.get("uid1")),
-                              Integer.parseInt(parsedMap.get("uid2")));
-
                 notifyTrackSelected(type, trackId);
 
+                if (subtitleAutoSave) {
+                    Log.d(TAG, "subtitleAutoSave: idx=" + index);
+                    mCurrentChannel.setSubtitleTrackIndex(index);
+                    mTvDataBaseManager.updateChannelInfo(mCurrentChannel);
+                }
+
                 return true;
             }
             return false;
@@ -342,7 +399,7 @@ public class DTVInputService extends DroidLogicTvInputService {
             int[] audioPids = ch.getAudioPids();
             int AudioTracksCount = (audioPids == null) ? 0 : audioPids.length;
             if (AudioTracksCount != 0) {
-                Log.d(TAG, "notify audio tracks:");
+                Log.d(TAG, "notify audio tracks["+AudioTracksCount+"]:");
                 String[] audioLanguages = ch.getAudioLangs();
                 int[] audioFormats = ch.getAudioFormats();
                 int audioTrackAuto = getAudioTrackAuto(ch);
@@ -377,7 +434,7 @@ public class DTVInputService extends DroidLogicTvInputService {
             int[] subPids = ch.getSubtitlePids();
             int SubTracksCount = (subPids == null) ? 0 : subPids.length;
             if (SubTracksCount != 0) {
-                Log.d(TAG, "notify subtitle tracks:");
+                Log.d(TAG, "notify subtitle tracks["+SubTracksCount+"]:");
                 String[] subLanguages = ch.getSubtitleLangs();
                 int[] subTypes = ch.getSubtitleTypes();
                 int[] subStypes = ch.getSubtitleStypes();
@@ -427,20 +484,25 @@ public class DTVInputService extends DroidLogicTvInputService {
         }
 
         /*
-                Auto rule: channel specified track > default language track > the 1st track > -1
+                Auto rule: channel specified track > default language track > system language > the 1st track > -1
             */
         private int getAudioTrackAuto(ChannelInfo info) {
             String[] trackLangArray = info.getAudioLangs();
             if (trackLangArray == null)
                 return -1;
 
-            if (info.getAudioTrackIndex() >= 0)
+            if (info.getAudioTrackIndex() >= 0) {
+                if (info.getAudioTrackIndex() >= trackLangArray.length)
+                    return 0;
                 return info.getAudioTrackIndex();
+            }
 
             if (info.getAudioTrackIndex() == -2)//off by user
                 return -2;
 
             String def_lan = Settings.System.getString(mContext.getContentResolver(), DroidLogicTvUtils.TV_KEY_DEFAULT_LANGUAGE);
+            if (def_lan == null)
+                def_lan = TVMultilingualText.getLocalLang();
             for (int trackIdx = 0; trackIdx < trackLangArray.length; trackIdx++) {
                 if (trackLangArray[trackIdx].equals(def_lan))
                     return trackIdx;
@@ -454,13 +516,18 @@ public class DTVInputService extends DroidLogicTvInputService {
             if (trackLangArray == null)
                 return -1;
 
-            if (info.getSubtitleTrackIndex() >= 0)
+            if (info.getSubtitleTrackIndex() >= 0) {
+                if (info.getSubtitleTrackIndex() >= trackLangArray.length)
+                    return 0;
                 return info.getSubtitleTrackIndex();
+            }
 
             if (info.getSubtitleTrackIndex() == -2)//off by user
                 return -2;
 
             String def_lan = Settings.System.getString(mContext.getContentResolver(), DroidLogicTvUtils.TV_KEY_DEFAULT_LANGUAGE);
+            if (def_lan == null)
+                def_lan = TVMultilingualText.getLocalLang();
             for (int trackIdx = 0; trackIdx < trackLangArray.length; trackIdx++) {
                 if (trackLangArray[trackIdx].equals(def_lan))
                     return trackIdx;
@@ -477,8 +544,6 @@ public class DTVInputService extends DroidLogicTvInputService {
         private static final int TYPE_DTV_CC = 4;
         private static final int TYPE_ATV_CC = 5;
 
-        private static final boolean subtitleAutoStart = false;
-
         private void startSubtitle(ChannelInfo channelInfo) {
 
             if (!subtitleAutoStart)
@@ -565,9 +630,6 @@ public class DTVInputService extends DroidLogicTvInputService {
             }
         }
 
-
-        private HandlerThread mHandlerThread = null;
-        private Handler mHandler;
         private void initThread(String name) {
             if (mHandlerThread == null) {
                 mHandlerThread = new HandlerThread(name);
@@ -584,34 +646,37 @@ public class DTVInputService extends DroidLogicTvInputService {
             }
         }
 
-        private EPGCurrentProgramRunnable mEPGCurrentProgramRunnable;
-        private EPGScanner epg = null;
+        private DTVMonitorCurrentProgramRunnable mMonitorCurrentProgramRunnable;
 
-        private static final int EPG_FEND = 0;
-        private static final int EPG_DMX = 0;
+        private static final int MONITOR_FEND = 0;
+        private static final int MONITOR_DMX = 0;
+        private static final int MONITOR_MODE = DTVMonitor.MODE_UPDATE_SERVICE | DTVMonitor.MODE_UPDATE_EPG;
         private static final String EPG_LANGUAGE = "local eng zho chi chs first";
         private static final String DEF_CODING = "GB2312";//"standard";//force setting for auto-detect fail.
 
-        private class EPGCurrentProgramRunnable implements Runnable {
+        private class DTVMonitorCurrentProgramRunnable implements Runnable {
             private final ChannelInfo mChannel;
 
-            public EPGCurrentProgramRunnable(ChannelInfo channel) {
+            public DTVMonitorCurrentProgramRunnable(ChannelInfo channel) {
                 mChannel = channel;
             }
 
             @Override
             public void run() {
-                Log.d(TAG, "epg ch: " + mChannel.getDisplayNumber() + "-" + mChannel.getDisplayName());
+                synchronized (mLock) {
+                    Log.d(TAG, "monitor ch: " + mChannel.getDisplayNumber() + "-" + mChannel.getDisplayName());
+                    if (monitor == null) {
+                        monitor = new DTVMonitor(mContext, getInputId(), DEF_CODING, MONITOR_MODE);
+                        monitor.reset(MONITOR_FEND, MONITOR_DMX,
+                                  Utils.type2mode(mChannel.getType()),
+                                  EPG_LANGUAGE.replaceAll("local", TVMultilingualText.getLocalLang()));
+                    }
 
-                if (epg == null) {
-                    epg = new EPGScanner(mContext, getInputId(), DEF_CODING);
-                    epg.reset(EPG_FEND, EPG_DMX,
-                              Utils.type2mode(mChannel.getType()),
-                              EPG_LANGUAGE.replaceAll("local", TVMultilingualText.getLocalLang()));
-                }
+                    monitor.enterChannel(getTVChannelParams(mChannel), false);
+                    monitor.enterService(mChannel);
 
-                epg.enterChannel(getTVChannelParams(mChannel), false);
-                epg.enterService(mChannel);
+                    monitor.setEpgAutoReset(true);
+                }
             }
         }
 
@@ -625,38 +690,59 @@ public class DTVInputService extends DroidLogicTvInputService {
             return params;
         }
 
-        private void setEPG(ChannelInfo channel) {
-            if (channel != null) {
-                Log.d(TAG, "startEPG");
+        private void setMonitor(ChannelInfo channel) {
+            synchronized (mLock) {
+                if (channel != null) {
+                    Log.d(TAG, "startMonitor");
+
+                    initThread("DTVMonitor Thread");
+                    mHandler.removeCallbacks(mMonitorCurrentProgramRunnable);
+                    mMonitorCurrentProgramRunnable = new DTVMonitorCurrentProgramRunnable(channel);
+                    mHandler.post(mMonitorCurrentProgramRunnable);
+                } else {
+                    if (monitor != null) {
+                        monitor.destroy();
+                        monitor = null;
+                    }
+                    releaseThread();
 
-                initThread("startEpg Thread");
-                mHandler.removeCallbacks(mEPGCurrentProgramRunnable);
-                mEPGCurrentProgramRunnable = new EPGCurrentProgramRunnable(channel);
-                mHandler.post(mEPGCurrentProgramRunnable);
-            } else {
-                if (epg != null) {
-                    epg.destroy();
-                    epg = null;
+                    Log.d(TAG, "stopMonitor");
                 }
-                releaseThread();
-
-                Log.d(TAG, "stopEPG");
             }
         }
 
-        private void restartEPGTime() {
-            Log.d(TAG, "restartEPGTime");
-            if (epg != null)
-                epg.restartEPGTime();
+        private void restartMonitorTime() {
+            synchronized (mLock) {
+                Log.d(TAG, "restartMonitorTime");
+                if (monitor != null)
+                    monitor.restartMonitorTime();
+            }
         }
 
-        public class EPGScanner {
-            private static final String TAG = "EPGScanner";
-            private static final int MSG_EPG_EVENT = 1000;
+        public class DTVMonitor {
+            private static final String TAG = "DTVMonitor";
+            private static final int MSG_MONITOR_EVENT = 1000;
+            private static final int MSG_MONITOR_RESCAN = 2000;
+
+            private static final int MODE_UPDATE_EPG = DTVEpgScanner.SCAN_EIT_ALL;
+            private static final int MODE_UPDATE_SERVICE = DTVEpgScanner.SCAN_SDT;
+            private static final int MODE_UPDATE_TS = DTVEpgScanner.SCAN_NIT;
+
+            /*
+                Rescan service info periodically @AUTO_RESCAN_SERVICE_INTERVAL for data changing,
+                due to only version-triggered at low-level
+            */
+            private boolean auto_rescan_service = true;
+            private static final int AUTO_RESCAN_SERVICE_INTERVAL = 5000;//5s
+
+            /*Retune current uri if necessary*/
+            private boolean auto_retune_service = true;
 
             private HandlerThread mHandlerThread;
             private Handler mHandler;
             private Context mContext;
+            private String mInputId;
+            private int mMode;
             private DTVEpgScanner epgScanner;
             private TVChannelParams tvchan = null;
             private ChannelInfo tvservice = null;
@@ -666,41 +752,48 @@ public class DTVInputService extends DroidLogicTvInputService {
             private ChannelObserver mChannelObserver;
             private ArrayList<ChannelInfo> channelMap;
             private long maxChannel_ID = 0;
-            private String mInputId;
 
             private int fend = 0;
             private int dmx = 0;
             private int src = 0;
             private String[] languages = null;
 
-            EPGScanner(Context context, String inputId, String coding) {
+            DTVMonitor(Context context, String inputId, String coding, int mode) {
                 mContext = context;
                 mInputId = inputId;
+                mMode = mode;
                 mTvDataBaseManager = new TvDataBaseManager(mContext);
                 mTvTime = new TVTime(mContext);
 
+                if (TextUtils.equals(mSystemControlManager.getProperty(DTV_AUTO_RESCAN_SERVICE), "0"))
+                    auto_rescan_service = false;
+
                 mHandlerThread = new HandlerThread(getClass().getSimpleName());
                 mHandlerThread.start();
                 mHandler = new Handler(mHandlerThread.getLooper()) {
                     @Override
                     public void handleMessage(Message msg) {
-                        if (msg.what == MSG_EPG_EVENT) {
-                            resolveEPGEvent((DTVEpgScanner.Event)msg.obj);
+                        if (msg.what == MSG_MONITOR_EVENT) {
+                            resolveMonitorEvent((DTVEpgScanner.Event)msg.obj);
+                        } else if (msg.what == MSG_MONITOR_RESCAN) {
+                            rescanService();
                         }
                     }
                 };
 
-                epgScanner = new DTVEpgScanner() {
+                epgScanner = new DTVEpgScanner(mode) {
                     public void onEvent(DTVEpgScanner.Event event) {
                         Log.d(TAG, "send event:" + event.type);
-                        mHandler.obtainMessage(MSG_EPG_EVENT, event).sendToTarget();
+                        mHandler.obtainMessage(MSG_MONITOR_EVENT, event).sendToTarget();
                     }
                 };
                 epgScanner.setDvbTextCoding(coding);
 
-                if (mChannelObserver == null)
-                    mChannelObserver = new ChannelObserver();
-                mContext.getContentResolver().registerContentObserver(TvContract.Channels.CONTENT_URI, true, mChannelObserver);
+                if ((mode & MODE_UPDATE_EPG) == MODE_UPDATE_EPG) {
+                    if (mChannelObserver == null)
+                        mChannelObserver = new ChannelObserver();
+                    mContext.getContentResolver().registerContentObserver(TvContract.Channels.CONTENT_URI, true, mChannelObserver);
+                }
             }
 
             private void refreshChannelMap() {
@@ -714,18 +807,30 @@ public class DTVInputService extends DroidLogicTvInputService {
             }
 
             public void reset(int fend, int dmx, int src, String textLanguages) {
-                refreshChannelMap();
+                Log.d(TAG, "monitor reset all.");
+                if ((mMode & MODE_UPDATE_EPG) == MODE_UPDATE_EPG)
+                    refreshChannelMap();
+
+                synchronized (this) {
+                    if (epgScanner == null)
+                        return;
 
-                epgScanner.setSource(fend, dmx, src, textLanguages);
-                languages = textLanguages.split(" ");
+                    epgScanner.setSource(fend, dmx, src, textLanguages);
+                    languages = textLanguages.split(" ");
 
-                this.fend = fend;
-                this.dmx = dmx;
-                this.src = src;
+                    this.fend = fend;
+                    this.dmx = dmx;
+                    this.src = src;
+                }
             }
 
             public void reset() {
-                Log.d(TAG, "epg reset.");
+                Log.d(TAG, "monitor reset.");
+
+                if (epgScanner == null) {
+                    Log.d(TAG, "monitor may exit, ignore.");
+                    return;
+                }
 
                 reset(fend, dmx, src, EPG_LANGUAGE.replaceAll("local", TVMultilingualText.getLocalLang()));
 
@@ -734,18 +839,28 @@ public class DTVInputService extends DroidLogicTvInputService {
             }
 
             public void destroy() {
+                setEpgAutoReset(false);
+
                 if (mChannelObserver != null) {
                     mContext.getContentResolver().unregisterContentObserver(mChannelObserver);
                     mChannelObserver = null;
                 }
-                if (epgScanner != null) {
-                    epgScanner.destroy();
-                    epgScanner = null;
-                }
-                if (mHandler != null) {
-                    mHandler.removeMessages(MSG_EPG_EVENT);
-                    mHandler = null;
+
+                if (mHandler != null)/*take care of rescan befor epgScanner=null*/
+                    mHandler.removeMessages(MSG_MONITOR_RESCAN);
+
+                synchronized (this) {
+                    if (epgScanner != null) {
+                        epgScanner.destroy();
+                        epgScanner = null;
+                    }
+                    if (mHandler != null) {
+                        mHandler.removeMessages(MSG_MONITOR_EVENT);
+                        mHandler.removeMessages(MSG_MONITOR_RESCAN);
+                        mHandler = null;
+                    }
                 }
+
                 if (mHandlerThread != null) {
                     mHandlerThread.quit();
                     mHandlerThread = null;
@@ -755,23 +870,68 @@ public class DTVInputService extends DroidLogicTvInputService {
             }
 
             public void enterChannel(TVChannelParams chan, boolean force) {
-                if (chan == null)
-                    epgScanner.leaveChannel();
-                else if ((tvchan == null) || !tvchan.equals(chan) || force)
-                    epgScanner.enterChannel();
-                tvchan = chan;
+                synchronized (this) {
+                    if (epgScanner == null)
+                        return;
+                    if (chan == null)
+                        epgScanner.leaveChannel();
+                    else if ((tvchan == null) || !tvchan.equals(chan) || force)
+                        epgScanner.enterChannel();
+                    tvchan = chan;
+                }
             }
 
             public void enterService(ChannelInfo channel) {
-                if (channel == null)
-                    epgScanner.leaveProgram();
-                else
-                    epgScanner.enterProgram(channel);
-                tvservice = channel;
+                synchronized (this) {
+                    if (epgScanner == null)
+                        return;
+                    if (channel == null) {
+                        rescanServiceLater(false);
+                        epgScanner.leaveProgram();
+                    } else {
+                        epgScanner.enterProgram(channel);
+                        rescanServiceLater(true);
+                    }
+                    tvservice = channel;
+                }
+            }
+
+            public void rescanServiceLater(boolean on) {
+                if (!auto_rescan_service)
+                    return;
+                synchronized (this) {
+                    if (mHandler != null) {
+                        mHandler.removeMessages(MSG_MONITOR_RESCAN);
+                        if (on) {
+                            Log.d(TAG, "rescanServiceLater");
+                            mHandler.sendEmptyMessageDelayed(MSG_MONITOR_RESCAN, AUTO_RESCAN_SERVICE_INTERVAL);
+                        }
+                    }
+                }
             }
 
-            public void restartEPGTime(){
-                epgScanner.rescanTDT();
+            public void rescanService() {
+                if (!auto_rescan_service)
+                    return;
+                synchronized (this) {
+                    if (tvservice != null && epgScanner != null) {
+                        Log.d(TAG, "rescanService");
+                        epgScanner.stopScan(DTVEpgScanner.SCAN_PAT|DTVEpgScanner.SCAN_PMT);
+                        epgScanner.startScan(DTVEpgScanner.SCAN_PAT|DTVEpgScanner.SCAN_PMT);
+                    }
+                    rescanServiceLater(tvservice != null);
+                }
+            }
+
+            public void restartMonitorTime(){
+                Log.d(TAG, "restartMonitorTime");
+                synchronized (this) {
+                    if (epgScanner == null) {
+                        Log.d(TAG, "monitor may exit, ignore.");
+                        return;
+                    }
+                    epgScanner.rescanTDT();
+                }
             }
 
             private List<Program> getChannelPrograms(Uri channelUri, ChannelInfo channel,
@@ -810,8 +970,8 @@ public class DTVInputService extends DroidLogicTvInputService {
                 return programs;
             }
 
-            private void resolveEPGEvent(DTVEpgScanner.Event event) {
-                Log.d(TAG, "Channel epg event: " + event.type);
+            private void resolveMonitorEvent(DTVEpgScanner.Event event) {
+                Log.d(TAG, "Monitor event: " + event.type + " this:" +this);
                 switch (event.type) {
                     case DTVEpgScanner.Event.EVENT_PROGRAM_EVENTS_UPDATE:
                         for (int i = 0; (channelMap != null && i < channelMap.size()); ++i) {
@@ -835,6 +995,12 @@ public class DTVInputService extends DroidLogicTvInputService {
                               + " Aids:" + Arrays.toString(event.channel.getAudioPids())
                               + " Afmts:" + Arrays.toString(event.channel.getAudioFormats())
                               + " Alangs:" + Arrays.toString(event.channel.getAudioLangs())
+                              + " Stypes:" + Arrays.toString(event.channel.getSubtitleTypes())
+                              + " Sids:" + Arrays.toString(event.channel.getSubtitlePids())
+                              + " Sstypes:" + Arrays.toString(event.channel.getSubtitleStypes())
+                              + " Sid1s:" + Arrays.toString(event.channel.getSubtitleId1s())
+                              + " Sid2s:" + Arrays.toString(event.channel.getSubtitleId2s())
+                              + " Slangs:" + Arrays.toString(event.channel.getSubtitleLangs())
                              );
                         if (tvservice.getServiceId() == event.channel.getServiceId()) {
                             tvservice.setVideoPid(event.channel.getVideoPid());
@@ -843,22 +1009,63 @@ public class DTVInputService extends DroidLogicTvInputService {
                             tvservice.setAudioPids(event.channel.getAudioPids());
                             tvservice.setAudioFormats(event.channel.getAudioFormats());
                             tvservice.setAudioLangs(event.channel.getAudioLangs());
+                            tvservice.setSubtitlePids(event.channel.getSubtitlePids());
+                            tvservice.setSubtitleTypes(event.channel.getSubtitleTypes());
+                            tvservice.setSubtitleStypes(event.channel.getSubtitleStypes());
+                            tvservice.setSubtitleId1s(event.channel.getSubtitleId1s());
+                            tvservice.setSubtitleId2s(event.channel.getSubtitleId2s());
+                            tvservice.setSubtitleLangs(event.channel.getSubtitleLangs());
                             mTvDataBaseManager.updateChannelInfo(tvservice);
+
+                            if (auto_retune_service) {
+                                Log.d(TAG, "Retune Current Uri");
+                                if (mCurrentUri != null)
+                                    switchToSourceInput(mCurrentUri);
+                            }
                         }
-                        break;
-                    case DTVEpgScanner.Event.EVENT_PROGRAM_NAME_UPDATE:
-                        Log.d(TAG, "[NAME Update]: ServiceId:" + event.channel.getServiceId()
-                              + " Network:" + event.channel.getOriginalNetworkId()
-                              + " Name:" + event.channel.getDisplayName()
-                              + " SdtVersion:" + event.channel.getSdtVersion()
-                             );
-                        if (tvservice.getServiceId() == event.channel.getServiceId()) {
-                            tvservice.setDisplayName(event.channel.getDisplayName());
-                            tvservice.setOriginalNetworkId(event.channel.getOriginalNetworkId());
-                            tvservice.setSdtVersion(event.channel.getSdtVersion());
-                            mTvDataBaseManager.updateChannelInfo(tvservice);
+                    break;
+                    case DTVEpgScanner.Event.EVENT_PROGRAM_NAME_UPDATE: {
+                        Log.d(TAG, "[NAME Update]: current: ONID:"+event.channel.getOriginalNetworkId()
+                            +" Version:"+event.channel.getSdtVersion());
+                        Log.d(TAG, "\t[Service]: id:"+event.channel.getServiceId() + " name:"+event.channel.getDisplayName());
+                        Log.d(TAG, "[NAME Update]: ONID:"+event.services.mNetworkId
+                            +" TSID:"+event.services.mTSId
+                            +" Version:"+event.services.mVersion);
+                        for (DTVEpgScanner.Event.ServiceInfosFromSDT.ServiceInfoFromSDT s : event.services.mServices) {
+                            Log.d(TAG, "\t[Service]: id:" + s.mId + " type:"+s.mType + " name:"+s.mName);
+                            Log.d(TAG, "\t           running:"+s.mRunning + " freeCA:"+s.mFreeCA);
                         }
-                        break;
+                        ArrayList<ChannelInfo> channelList =
+                            mTvDataBaseManager.getChannelList(mInputId, ChannelInfo.COMMON_PROJECTION,
+                                TvContract.Channels.COLUMN_ORIGINAL_NETWORK_ID+"=? and "+
+                                TvContract.Channels.COLUMN_TRANSPORT_STREAM_ID+"=?",
+                                new String[]{
+                                    /*
+                                     * If sdt timeout in scanning, onid should be -1.
+                                     * Risk exsits if sdt timeout more then once in autoscan,
+                                     * TSId+SId may not identify a service without ONId.
+                                     * */
+                                    "-1",
+                                    /*String.valueOf(event.services.mNetworkId),*/
+                                    String.valueOf(event.services.mTSId)
+                                });
+                        int count = 0;
+                        for (ChannelInfo co : channelList) {
+                            for (DTVEpgScanner.Event.ServiceInfosFromSDT.ServiceInfoFromSDT sn : event.services.mServices) {
+                                if (co.getServiceId() == sn.mId) {
+                                    co.setOriginalNetworkId(event.services.mNetworkId);
+                                    co.setDisplayName(TVMultilingualText.getText(sn.mName));
+                                    co.setDisplayNameMulti(sn.mName);
+                                    co.setSdtVersion(event.services.mVersion);
+                                    mTvDataBaseManager.updateChannelInfo(co);
+                                    count = count + 1;
+                                }
+                            }
+                        }
+                        Log.d(TAG, "found ["+event.services.mServices.size()+"] services in SDT.");
+                        Log.d(TAG, "update ["+count+"] services in DB.");
+                    }
+                    break;
                     case DTVEpgScanner.Event.EVENT_CHANNEL_UPDATE:
                         Log.d(TAG, "[TS Update]: Freq:" + tvservice.getFrequency());
                         Log.d(TAG, "TS changed, need autoscan. not impelement");
@@ -869,9 +1076,7 @@ public class DTVInputService extends DroidLogicTvInputService {
             }
 
 
-
-
-            private boolean epg_auto_reset = true;
+            private boolean epg_auto_reset = false;
             private void setEpgAutoReset(boolean enable) {
                 epg_auto_reset = enable;
             }
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi1InputService.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi1InputService.java
index 53c04fb..da42433 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi1InputService.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi1InputService.java
@@ -22,13 +22,17 @@ import android.text.TextUtils;
 import android.view.KeyEvent;
 import android.view.Surface;
 
+import java.util.HashMap;
+import java.util.Map;
+import android.net.Uri;
+
 public class Hdmi1InputService extends DroidLogicTvInputService {
     private static final String TAG = Hdmi1InputService.class.getSimpleName();
     private Hdmi1InputSession mCurrentSession;
-    private int number = 0;
-    private int currentNumber = 0;
+    private int id = 0;
     private final int TV_SOURCE_EXTERNAL = 0;
     private final int TV_SOURCE_INTERNAL = 1;
+    private Map<Integer, Hdmi1InputSession> sessionMap = new HashMap<>();
 
     @Override
     public Session onCreateSession(String inputId) {
@@ -36,34 +40,37 @@ public class Hdmi1InputService extends DroidLogicTvInputService {
 
         mCurrentSession = new Hdmi1InputSession(getApplicationContext(), inputId, getHardwareDeviceId(inputId));
         registerInputSession(mCurrentSession);
-        mCurrentSession.setNumber(number);
-        number++;
+        mCurrentSession.setSessionId(id);
+
+        sessionMap.put(id, mCurrentSession);
+        id++;
 
         return mCurrentSession;
     }
 
+    @Override
+    public void setCurrentSessionById(int sessionId) {
+        Utils.logd(TAG, "setCurrentSessionById:"+sessionId);
+        Hdmi1InputSession session = sessionMap.get(sessionId);
+        if (session != null) {
+            mCurrentSession = session;
+        }
+    }
+
     public class Hdmi1InputSession extends TvInputBaseSession {
         public Hdmi1InputSession(Context context, String inputId, int deviceId) {
             super(context, inputId, deviceId);
             Utils.logd(TAG, "=====new HdmiInputSession=====");
         }
 
-        public TvStreamConfig[] getConfigs() {
-            return mConfigs;
-        }
-
-        public Hardware getHardware() {
-            return mHardware;
-        }
-
-        public int getCurrentSessionNumber() {
-            return currentNumber;
+        @Override
+        public boolean onSetSurface(Surface surface) {
+            return setSurfaceInService(surface,this);
         }
 
-        public void setCurrentSession() {
-           currentNumber = getNumber();
-           mCurrentSession = this;
-           registerInputSession(mCurrentSession);
+        @Override
+        public boolean onTune(Uri channelUri) {
+            return doTuneInService(channelUri, getSessionId());
         }
 
         @Override
@@ -80,11 +87,6 @@ public class Hdmi1InputService extends DroidLogicTvInputService {
         }
 
         @Override
-        public void doSetSurface(Surface surface) {
-            super.doSetSurface(surface);
-        }
-
-        @Override
         public boolean onKeyUp(int keyCode, KeyEvent event) {
             return false;
         }
@@ -92,7 +94,7 @@ public class Hdmi1InputService extends DroidLogicTvInputService {
         @Override
         public boolean onKeyDown(int keyCode, KeyEvent event) {
             if (isNavigationKey(keyCode)) {
-                getHardware().dispatchKeyEventToHdmi(event);
+                mHardware.dispatchKeyEventToHdmi(event);
                 return true;
             }
             return false;
@@ -190,10 +192,7 @@ public class Hdmi1InputService extends DroidLogicTvInputService {
         }
         Utils.logd(TAG, "createTvInputInfo, id:" + info.getId());
         updateInfoListIfNeededLocked(phyaddr, info, false);
-        if (mCurrentSession != null) {
-            mCurrentSession.selectHdmiDevice(TV_SOURCE_EXTERNAL);
-        }
-
+        selectHdmiDevice(DroidLogicTvUtils.DEVICE_ID_HDMI1);
         return info;
     }
 
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi2InputService.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi2InputService.java
index 82e2f9f..ef9b9c8 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi2InputService.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi2InputService.java
@@ -22,48 +22,56 @@ import android.text.TextUtils;
 import android.view.KeyEvent;
 import android.view.Surface;
 
+import java.util.HashMap;
+import java.util.Map;
+import android.net.Uri;
+
 public class Hdmi2InputService extends DroidLogicTvInputService {
     private static final String TAG = Hdmi2InputService.class.getSimpleName();
     private Hdmi2InputSession mCurrentSession;
-    private int number = 0;
-    private int currentNumber = 0;
+    private int id = 0;
     private final int TV_SOURCE_EXTERNAL = 0;
     private final int TV_SOURCE_INTERNAL = 1;
 
+   private Map<Integer, Hdmi2InputSession> sessionMap = new HashMap<>();
+
     @Override
     public Session onCreateSession(String inputId) {
         super.onCreateSession(inputId);
 
         mCurrentSession = new Hdmi2InputSession(getApplicationContext(), inputId, getHardwareDeviceId(inputId));
         registerInputSession(mCurrentSession);
-        mCurrentSession.setNumber(number);
-        number++;
+        mCurrentSession.setSessionId(id);
+        sessionMap.put(id, mCurrentSession);
+        id++;
 
         return mCurrentSession;
     }
 
+    @Override
+    public void setCurrentSessionById(int sessionId) {
+        Utils.logd(TAG, "setCurrentSessionById:"+sessionId);
+        Hdmi2InputSession session = sessionMap.get(sessionId);
+        if (session != null) {
+            mCurrentSession = session;
+        }
+    }
+
+
     public class Hdmi2InputSession extends TvInputBaseSession {
         public Hdmi2InputSession(Context context, String inputId, int deviceId) {
             super(context, inputId, deviceId);
             Utils.logd(TAG, "=====new HdmiInputSession=====");
         }
 
-        public TvStreamConfig[] getConfigs() {
-            return mConfigs;
-        }
-
-        public Hardware getHardware() {
-            return mHardware;
-        }
-
-        public int getCurrentSessionNumber() {
-            return currentNumber;
+        @Override
+        public boolean onSetSurface(Surface surface) {
+            return setSurfaceInService(surface,this);
         }
 
-        public void setCurrentSession() {
-           currentNumber = getNumber();
-           mCurrentSession = this;
-           registerInputSession(mCurrentSession);
+        @Override
+        public boolean onTune(Uri channelUri) {
+            return doTuneInService(channelUri, getSessionId());
         }
 
         @Override
@@ -80,11 +88,6 @@ public class Hdmi2InputService extends DroidLogicTvInputService {
         }
 
         @Override
-        public void doSetSurface(Surface surface) {
-            super.doSetSurface(surface);
-        }
-
-        @Override
         public boolean onKeyUp(int keyCode, KeyEvent event) {
             return false;
         }
@@ -92,7 +95,7 @@ public class Hdmi2InputService extends DroidLogicTvInputService {
         @Override
         public boolean onKeyDown(int keyCode, KeyEvent event) {
             if (isNavigationKey(keyCode)) {
-                getHardware().dispatchKeyEventToHdmi(event);
+                mHardware.dispatchKeyEventToHdmi(event);
                 return true;
             }
             return false;
@@ -190,9 +193,7 @@ public class Hdmi2InputService extends DroidLogicTvInputService {
         }
         Utils.logd(TAG, "createTvInputInfo, id:" + info.getId());
         updateInfoListIfNeededLocked(phyaddr, info, false);
-        if (mCurrentSession != null) {
-            mCurrentSession.selectHdmiDevice(TV_SOURCE_EXTERNAL);
-        }
+        selectHdmiDevice(DroidLogicTvUtils.DEVICE_ID_HDMI2);
 
         return info;
     }
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi3InputService.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi3InputService.java
index cef2779..18515a6 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi3InputService.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/Hdmi3InputService.java
@@ -22,48 +22,57 @@ import android.text.TextUtils;
 import android.view.KeyEvent;
 import android.view.Surface;
 
+import java.util.HashMap;
+import java.util.Map;
+import android.net.Uri;
+
+
 public class Hdmi3InputService extends DroidLogicTvInputService {
     private static final String TAG = Hdmi3InputService.class.getSimpleName();
     private Hdmi3InputSession mCurrentSession;
-    private int number = 0;
-    private int currentNumber = 0;
+    private int id = 0;
     private final int TV_SOURCE_EXTERNAL = 0;
     private final int TV_SOURCE_INTERNAL = 1;
 
+    private Map<Integer, Hdmi3InputSession> sessionMap = new HashMap<>();
+
     @Override
     public Session onCreateSession(String inputId) {
         super.onCreateSession(inputId);
 
         mCurrentSession = new Hdmi3InputSession(getApplicationContext(), inputId, getHardwareDeviceId(inputId));
         registerInputSession(mCurrentSession);
-        mCurrentSession.setNumber(number);
-        number++;
+        mCurrentSession.setSessionId(id);
+        sessionMap.put(id, mCurrentSession);
+        id++;
 
         return mCurrentSession;
     }
 
+    @Override
+    public void setCurrentSessionById(int sessionId) {
+        Utils.logd(TAG, "setCurrentSessionById:"+sessionId);
+        Hdmi3InputSession session = sessionMap.get(sessionId);
+        if (session != null) {
+            mCurrentSession = session;
+        }
+    }
+
+
     public class Hdmi3InputSession extends TvInputBaseSession {
         public Hdmi3InputSession(Context context, String inputId, int deviceId) {
             super(context, inputId, deviceId);
             Utils.logd(TAG, "=====new HdmiInputSession=====");
         }
 
-        public TvStreamConfig[] getConfigs() {
-            return mConfigs;
-        }
-
-        public Hardware getHardware() {
-            return mHardware;
-        }
-
-        public int getCurrentSessionNumber() {
-            return currentNumber;
+        @Override
+        public boolean onSetSurface(Surface surface) {
+            return setSurfaceInService(surface,this);
         }
 
-        public void setCurrentSession() {
-           currentNumber = getNumber();
-           mCurrentSession = this;
-           registerInputSession(mCurrentSession);
+        @Override
+        public boolean onTune(Uri channelUri) {
+            return doTuneInService(channelUri, getSessionId());
         }
 
         @Override
@@ -80,11 +89,6 @@ public class Hdmi3InputService extends DroidLogicTvInputService {
         }
 
         @Override
-        public void doSetSurface(Surface surface) {
-            super.doSetSurface(surface);
-        }
-
-        @Override
         public boolean onKeyUp(int keyCode, KeyEvent event) {
             return false;
         }
@@ -92,7 +96,7 @@ public class Hdmi3InputService extends DroidLogicTvInputService {
         @Override
         public boolean onKeyDown(int keyCode, KeyEvent event) {
             if (isNavigationKey(keyCode)) {
-                getHardware().dispatchKeyEventToHdmi(event);
+                mHardware.dispatchKeyEventToHdmi(event);
                 return true;
             }
             return false;
@@ -190,9 +194,7 @@ public class Hdmi3InputService extends DroidLogicTvInputService {
         }
         Utils.logd(TAG, "createTvInputInfo, id:" + info.getId());
         updateInfoListIfNeededLocked(phyaddr, info, false);
-        if (mCurrentSession != null) {
-            mCurrentSession.selectHdmiDevice(TV_SOURCE_EXTERNAL);
-        }
+        selectHdmiDevice(DroidLogicTvUtils.DEVICE_ID_HDMI3);
 
         return info;
     }
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/SPDIFInputService.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/SPDIFInputService.java
new file mode 100644
index 0000000..2e9d397
--- /dev/null
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/services/SPDIFInputService.java
@@ -0,0 +1,127 @@
+package com.droidlogic.tvinput.services;
+
+import java.io.IOException;
+
+import org.xmlpull.v1.XmlPullParserException;
+
+import com.droidlogic.tvinput.Utils;
+
+import com.droidlogic.app.tv.DroidLogicTvInputService;
+import com.droidlogic.app.tv.DroidLogicTvUtils;
+import com.droidlogic.app.tv.TvInputBaseSession;
+
+import android.content.Context;
+import android.content.pm.ResolveInfo;
+import android.media.tv.TvInputHardwareInfo;
+import android.media.tv.TvInputInfo;
+import android.media.tv.TvStreamConfig;
+import android.media.tv.TvInputManager.Hardware;
+import android.os.Bundle;
+import android.text.TextUtils;
+import java.util.HashMap;
+import java.util.Map;
+import android.view.Surface;
+import android.net.Uri;
+
+public class SPDIFInputService extends DroidLogicTvInputService {
+    private static final String TAG = SPDIFInputService.class.getSimpleName();;
+    private SPDIFInputSession mCurrentSession;
+    private int id = 0;
+    private Map<Integer, SPDIFInputSession> sessionMap = new HashMap<>();
+
+    @Override
+    public Session onCreateSession(String inputId) {
+        super.onCreateSession(inputId);
+
+        mCurrentSession = new SPDIFInputSession(getApplicationContext(), inputId, getHardwareDeviceId(inputId));
+        registerInputSession(mCurrentSession);
+        mCurrentSession.setSessionId(id);
+        sessionMap.put(id, mCurrentSession);
+        id++;
+
+        return mCurrentSession;
+    }
+
+    @Override
+    public void setCurrentSessionById(int sessionId) {
+        Utils.logd(TAG, "setCurrentSessionById:"+sessionId);
+        SPDIFInputSession session = sessionMap.get(sessionId);
+        if (session != null) {
+            mCurrentSession = session;
+        }
+    }
+
+    public class SPDIFInputSession extends TvInputBaseSession {
+        public SPDIFInputSession(Context context, String inputId, int deviceId) {
+            super(context, inputId, deviceId);
+            Utils.logd(TAG, "=====new SPDIFInputSession=====");
+        }
+
+        @Override
+        public boolean onSetSurface(Surface surface) {
+            return setSurfaceInService(surface,this);
+        }
+
+        @Override
+        public boolean onTune(Uri channelUri) {
+            return doTuneInService(channelUri, getSessionId());
+        }
+
+        @Override
+        public void doRelease() {
+            super.doRelease();
+        }
+
+        @Override
+        public void doAppPrivateCmd(String action, Bundle bundle) {
+            super.doAppPrivateCmd(action, bundle);
+            if (TextUtils.equals(DroidLogicTvUtils.ACTION_STOP_TV, action)) {
+                stopTv();
+            }
+        }
+    }
+
+    public TvInputInfo onHardwareAdded(TvInputHardwareInfo hardwareInfo) {
+        if (hardwareInfo.getDeviceId() != DroidLogicTvUtils.DEVICE_ID_SPDIF
+            || hasInfoExisted(hardwareInfo))
+            return null;
+
+        Utils.logd(TAG, "=====onHardwareAdded=====" + hardwareInfo.getDeviceId());
+
+        TvInputInfo info = null;
+        ResolveInfo rInfo = getResolveInfo(SPDIFInputService.class.getName());
+        if (rInfo != null) {
+            try {
+                info = TvInputInfo.createTvInputInfo(
+                           getApplicationContext(),
+                           rInfo,
+                           hardwareInfo,
+                           getTvInputInfoLabel(hardwareInfo.getDeviceId()),
+                           null);
+            } catch (XmlPullParserException e) {
+                // TODO: handle exception
+            } catch (IOException e) {
+                // TODO: handle exception
+            }
+        }
+        updateInfoListIfNeededLocked(hardwareInfo, info, false);
+
+        return info;
+    }
+
+    public String onHardwareRemoved(TvInputHardwareInfo hardwareInfo) {
+        if (hardwareInfo.getDeviceId() != DroidLogicTvUtils.DEVICE_ID_SPDIF
+            || !hasInfoExisted(hardwareInfo))
+            return null;
+
+        TvInputInfo info = getTvInputInfo(hardwareInfo);
+        String id = null;
+        if (info != null)
+            id = info.getId();
+        updateInfoListIfNeededLocked(hardwareInfo, info, true);
+
+        Utils.logd(TAG, "=====onHardwareRemoved=====" + id);
+        return id;
+    }
+
+}
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/ChannelEdit.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/ChannelEdit.java
index de7d742..0dd4197 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/ChannelEdit.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/ChannelEdit.java
@@ -194,6 +194,7 @@ public class ChannelEdit implements OnClickListener, OnFocusChangeListener, OnIt
     private void setChannelName () {
         EditText edit_name = (EditText)channelEditView.findViewById(R.id.edit_name);
         getSettingsManager().setChannelName(channelType, currentChannelPosition, edit_name.getText().toString());
+        edit_name.setText("");
     }
 
     private void swapChannelPosition () {
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/ContentListView.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/ContentListView.java
index a56765c..3fa3da9 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/ContentListView.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/ContentListView.java
@@ -145,7 +145,8 @@ public class ContentListView extends ListView implements OnItemSelectedListener
             getOptionUiManager().setOptionListener(view);
             if (getOptionUiManager().getOptionTag() == OptionUiManager.OPTION_CHANNEL_INFO
                 || getOptionUiManager().getOptionTag() == OptionUiManager.OPTION_AUDIO_TRACK
-                || getOptionUiManager().getOptionTag() == OptionUiManager.OPTION_DEFAULT_LANGUAGE) {
+                || getOptionUiManager().getOptionTag() == OptionUiManager.OPTION_DEFAULT_LANGUAGE
+                || getOptionUiManager().getOptionTag() == OptionUiManager.OPTION_FBC_UPGRADE) {
                 OptionListLayout optionListLayout = new OptionListLayout(mContext, view, getOptionUiManager().getOptionTag());
             } else if (getOptionUiManager().getOptionTag() == OptionUiManager.OPTION_CHANNEL_EDIT) {
                 ChannelEdit channelEdit = new ChannelEdit(mContext, view);
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/OptionListLayout.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/OptionListLayout.java
index 3005dd8..bb69ec7 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/OptionListLayout.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/OptionListLayout.java
@@ -1,23 +1,34 @@
 package com.droidlogic.tvinput.settings;
 
 import android.app.Activity;
-
+import android.app.AlertDialog;
+import android.app.AlertDialog.Builder;
+import android.app.Dialog;
 import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
 import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
 import android.widget.AdapterView;
 import android.widget.AdapterView.OnItemClickListener;
 import android.widget.ListView;
 import android.widget.RelativeLayout.LayoutParams;
 import android.widget.SimpleAdapter;
 import android.widget.TextView;
+import android.widget.Toast;
 import android.util.Log;
 
+import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
 
 import com.droidlogic.tvinput.R;
+import com.droidlogic.app.tv.TvControlManager;
+import com.droidlogic.app.tv.TvControlManager.UpgradeFBCListener;
+import android.os.Build;
 
-public class OptionListLayout implements OnItemClickListener {
+public class OptionListLayout implements OnItemClickListener,UpgradeFBCListener {
     private static final String TAG = "OptionListLayout";
 
     private Context mContext;
@@ -25,6 +36,8 @@ public class OptionListLayout implements OnItemClickListener {
     private int mTag = -1;
     private View optionView = null;
 
+    private TvControlManager mTvControlManager;
+    private String listitem;
     public OptionListLayout (Context context, View view, int tag) {
         mContext = context;
         optionView = view;
@@ -33,9 +46,9 @@ public class OptionListLayout implements OnItemClickListener {
         initOptionListView();
     }
 
+    ArrayList<HashMap<String, Object>> optionListData = new ArrayList<HashMap<String, Object>>();
     private void initOptionListView () {
         SimpleAdapter optionAdapter = null;
-        ArrayList<HashMap<String, Object>> optionListData = null;
         TextView title = (TextView)optionView.findViewById(R.id.option_title);
         OptionListView optionListView = (OptionListView)optionView.findViewById(R.id.option_list);
 
@@ -62,12 +75,52 @@ public class OptionListLayout implements OnItemClickListener {
                                                   R.layout.layout_option_single_text,
                                                   new String[] {SettingsManager.STRING_NAME}, new int[] {R.id.text_name});
                 break;
+            case OptionUiManager.OPTION_FBC_UPGRADE:
+                title.setText(mContext.getResources().getString(R.string.fbc_upgrade));
+                RecursionAddFile(FolderFilter(), optionListData);
+                optionAdapter = new SimpleAdapter(mContext, optionListData,
+                                                  R.layout.layout_option_single_text,
+                                                  new String[] { SettingsManager.STRING_NAME }, new int[] { R.id.text_name });
+                break;
         }
         if (optionAdapter != null) {
             optionListView.setAdapter(optionAdapter);
             optionListView.setOnItemClickListener(this);
         }
     }
+    public String FolderFilter(){
+        int buildVersion = Build.VERSION.SDK_INT;
+        if (buildVersion > 22 )
+            return "storage";
+        else
+            return "storage/udisk0";
+    }
+
+
+    public static void RecursionAddFile(String path, ArrayList<HashMap<String, Object>> result) {
+        try {
+            int level = 0;
+            for (int i = 0; i < path.length(); i++)
+                if (File.separatorChar == path.charAt(i))
+                    level++;
+            if (level > 3)
+                return;
+            File[] files = new File(path).listFiles();
+            if (files != null) {
+                for (File file : files) {
+                    if (file.isDirectory()) {
+                        RecursionAddFile(file.getAbsolutePath(), result);
+                    } else if (file.getName().endsWith(".bin")) {
+                        HashMap<String, Object> temp = new HashMap<String, Object>();
+                        temp.put(SettingsManager.STRING_NAME, file.getAbsolutePath());
+                        result.add(temp);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
 
     public void onItemClick (AdapterView<?> parent, View view, int position, long id) {
         switch (mTag) {
@@ -77,10 +130,66 @@ public class OptionListLayout implements OnItemClickListener {
             case OptionUiManager.OPTION_DEFAULT_LANGUAGE:
                 getSettingsManager().setDefLanguage(position);
                 break;
+            case OptionUiManager.OPTION_FBC_UPGRADE:
+                listitem = optionListData.get(position).get(SettingsManager.STRING_NAME).toString();
+                AlertDialog.Builder mbuiler = new Builder(mContext,AlertDialog.THEME_HOLO_LIGHT);
+                mbuiler.setTitle("Warning!");
+                mbuiler.setMessage("Please do not power off during the upgrade.");
+                mbuiler.setPositiveButton("Sure",mOnClickListener);
+                mbuiler.setNegativeButton("Cancel", mOnClickListener);
+                AlertDialog mdialog = mbuiler.create();
+                mdialog.show();
+                Window window = mdialog.getWindow();
+                WindowManager.LayoutParams lp = window.getAttributes();
+                lp.alpha = 0.8f;
+                window.setAttributes(lp);
+                break;
         }
         ((TvSettingsActivity) mContext).getCurrentFragment().refreshList();
     }
 
+    OnClickListener mOnClickListener = new OnClickListener() {
+        public void onClick(DialogInterface dialog, int which) {
+            switch (which) {
+              case Dialog.BUTTON_POSITIVE:
+                   mTvControlManager = TvControlManager.getInstance();
+                   mTvControlManager.SetUpgradeFBCListener(OptionListLayout.this);
+                   mTvControlManager.StartUpgradeFBC(listitem,0, 0x10000);
+              break;
+              case Dialog.BUTTON_NEGATIVE:
+                   Toast.makeText(mContext, "Upgrade cancelled!", Toast.LENGTH_LONG).show();
+              break;
+            }
+        }
+    };
+
+    public void onUpgradeStatus(int paramInt1, int paramInt2)
+    {
+        switch (paramInt2) {
+        case -1:
+            Toast.makeText(mContext, "Please check the connection of serial port!", Toast.LENGTH_LONG).show();
+            break;
+        case -2:
+            Toast.makeText(mContext, "Sorry,Open file failure!", Toast.LENGTH_LONG).show();
+            break;
+        case -3:
+            Toast.makeText(mContext, "Sorry,file size error!", Toast.LENGTH_LONG).show();
+            break;
+        case -4:
+            Toast.makeText(mContext, "Sorry,read file error!", Toast.LENGTH_LONG).show();
+            break;
+        case -5:
+            Toast.makeText(mContext, "Sorry,don't support upgrade mode!", Toast.LENGTH_LONG).show();
+            break;
+        case -6:
+            Toast.makeText(mContext, "Sorry,upgrade block size error!", Toast.LENGTH_LONG).show();
+            break;
+        case -7:
+            Toast.makeText(mContext, "Sorry,invalid upgrade file!", Toast.LENGTH_LONG).show();
+            break;
+        }
+    }
+
     private SettingsManager getSettingsManager() {
         return ((TvSettingsActivity)mContext).getSettingsManager();
     }
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/OptionUiManager.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/OptionUiManager.java
index 52affd5..376a40e 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/OptionUiManager.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/OptionUiManager.java
@@ -87,6 +87,7 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
     public static final int OPTION_DEFAULT_LANGUAGE = 405;
     public static final int OPTION_SUBTITLE_SWITCH = 406;
     public static final int OPTION_HDMI20 = 407;
+    public static final int OPTION_FBC_UPGRADE = 408;
 
     public static final int ALPHA_NO_FOCUS = 230;
     public static final int ALPHA_FOCUSED = 255;
@@ -252,6 +253,9 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
         } else if (item_name.equals(mResources.getString(R.string.hdmi20))) {
             optionTag = OPTION_HDMI20;
             optionKey = SettingsManager.KEY_HDMI20;
+        } else if (item_name.equals(mResources.getString(R.string.fbc_upgrade))){
+            optionTag = OPTION_FBC_UPGRADE;
+            optionKey = SettingsManager.KEY_FBC_UPGRADE;
         }
     }
 
@@ -345,6 +349,8 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
                 return R.layout.layout_settings_restore_factory;
             case OPTION_HDMI20:
                 return R.layout.layout_settings_hdmi20;
+            case OPTION_FBC_UPGRADE:
+                return R.layout.layout_option_list;
 
             default:
                 break;
@@ -549,6 +555,7 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
                 break;
             case R.id.sound_channel_right_channel:
                 mSettingsManager.setSoundChannel(TvControlManager.LEFT_RIGHT_SOUND_CHANNEL.LEFT_RIGHT_SOUND_CHANNEL_RIGHT.toInt());
+            // subtitle
             case R.id.sub_off:
                 mSettingsManager.setSubtitleSwitch(0);
                 Intent intent = new Intent(DroidLogicTvUtils.ACTION_SUBTITLE_SWITCH);
@@ -655,13 +662,14 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
             case R.id.switch_channel_black_frame:
                 mTvControlManager.setBlackoutEnable(1);
                 break;
-            // Restore Factory Settings
+            // startup app
             case R.id.startup_setting_launcher:
                 mSettingsManager.setStartupSetting(0);
                 break;
             case R.id.startup_setting_tv:
                 mSettingsManager.setStartupSetting(1);
                 break;
+            // Restore Factory Settings
             case R.id.restore_factory:
                 createFactoryResetUi();
                 break;
@@ -956,8 +964,7 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
                 break;
             default:
                 progress = getIntegerFromString(mSettingsManager.getStatus(optionKey));
-                if (progress >= 0)
-                    setProgress(progress);
+                setProgress(progress);
                 break;
         }
     }
@@ -1023,7 +1030,10 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
 
         switch (progress / 5) {
             case 0:
-                return R.drawable.progress_1;
+                if (progress > 0)
+                    return R.drawable.progress_1;
+                else
+                    return R.drawable.progress_m1;
             case 1:
                 return R.drawable.progress_2;
             case 2:
@@ -1064,6 +1074,48 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
                 return R.drawable.progress_20;
             case 20:
                 return R.drawable.progress_21;
+            // minus progress
+            case -1:
+                return R.drawable.progress_m2;
+            case -2:
+                return R.drawable.progress_m3;
+            case -3:
+                return R.drawable.progress_m4;
+            case -4:
+                return R.drawable.progress_m5;
+            case -5:
+                return R.drawable.progress_m6;
+            case -6:
+                return R.drawable.progress_m7;
+            case -7:
+                return R.drawable.progress_m8;
+            case -8:
+                return R.drawable.progress_m9;
+            case -9:
+                return R.drawable.progress_m10;
+            case -10:
+                return R.drawable.progress_m11;
+            case -11:
+                return R.drawable.progress_m12;
+            case -12:
+                return R.drawable.progress_m13;
+            case -13:
+                return R.drawable.progress_m14;
+            case -14:
+                return R.drawable.progress_m15;
+            case -15:
+                return R.drawable.progress_m16;
+            case -16:
+                return R.drawable.progress_m17;
+            case -17:
+                return R.drawable.progress_m18;
+            case -18:
+                return R.drawable.progress_m19;
+            case -19:
+                return R.drawable.progress_m20;
+            case -20:
+                return R.drawable.progress_m21;
+
             default:
                 break;
         }
@@ -1275,7 +1327,7 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
 
         item = new HashMap<String, Object>();
         item.put(SettingsManager.STRING_NAME, mResources.getString(R.string.strength) + ":");
-        item.put(SettingsManager.STRING_STATUS, event.strength + "%");
+        item.put(SettingsManager.STRING_STATUS, event.strength /1000.0 + "%");
         list.add(item);
 
         item = new HashMap<String, Object>();
@@ -1300,7 +1352,7 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
                     TvControlManager.tvin_color_system_e.COLOR_SYSTEM_AUTO.toInt(),
                     TvControlManager.ATV_AUDIO_STD_AUTO,
                     0, 0);*/
-            mTvControlManager.AtvAutoScan(TvControlManager.ATV_VIDEO_STD_PAL, TvControlManager.ATV_AUDIO_STD_I, 0, 1);
+            mTvControlManager.AtvAutoScan(TvControlManager.ATV_VIDEO_STD_PAL, TvControlManager.ATV_AUDIO_STD_I, 0, 0);
             Settings.System.putInt(mContext.getContentResolver(), DroidLogicTvUtils.TV_ATV_CHANNEL_INDEX, -1);
         } else if (mSettingsManager.getCurentTvSource() == TvControlManager.SourceInput_Type.SOURCE_TYPE_DTV) {
             mTvControlManager.PlayDTVProgram(TVChannelParams.MODE_DTMB, 470000000, 0, 0, 0, 0, -1, -1, 0, 0);
@@ -1555,8 +1607,6 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
 
             case TvControlManager.EVENT_STORE_END:
                 Log.d(TAG, "Store end");
-                SystemControlManager scm = new SystemControlManager(mContext);
-                scm.setProperty("tv.channels.count", ""+(channelNumber+radioNumber));
                 onTvChannelStoreEnd();
                 //((TvSettingsActivity) mContext).finish();
                 String prompt = mResources.getString(R.string.searched);
@@ -1577,6 +1627,8 @@ public class OptionUiManager implements OnClickListener, OnFocusChangeListener,
                 break;
             case TvControlManager.EVENT_SCAN_EXIT:
                 Log.d(TAG, "Scan exit.");
+                SystemControlManager scm = new SystemControlManager(mContext);
+                scm.setProperty("tv.channels.count", ""+(channelNumber+radioNumber));
                 isSearching = false;
                 ((TvSettingsActivity) mContext).finish();
                 if (channelNumber == 0 && radioNumber == 0) {
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/SettingsManager.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/SettingsManager.java
index 3371f3f..044ef4b 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/SettingsManager.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/SettingsManager.java
@@ -79,6 +79,7 @@ public class SettingsManager {
     public static final String KEY_DEFAULT_LANGUAGE                 = "default_language";
     public static final String KEY_SUBTITLE_SWITCH                  = "sub_switch";
     public static final String KEY_HDMI20                           = "hdmi20";
+    public static final String KEY_FBC_UPGRADE                      ="fbc_upgrade";
 
     public static final String STATUS_STANDARD                      = "standard";
     public static final String STATUS_VIVID                         = "vivid";
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/TvSettingsActivity.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/TvSettingsActivity.java
index 4cc66a0..9041d31 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/TvSettingsActivity.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/settings/TvSettingsActivity.java
@@ -328,6 +328,7 @@ public class TvSettingsActivity extends Activity implements OnClickListener, OnF
     public void onStop() {
         Log.d(TAG, "onStop");
         super.onStop();
+        finish();
     }
 
     public void onDestroy() {
diff --git a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/shortcut/ShortCutActivity.java b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/shortcut/ShortCutActivity.java
index bb56930..d530e37 100644
--- a/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/shortcut/ShortCutActivity.java
+++ b/amlogic/apps/TvInput/DroidLogicTvInput/src/com/droidlogic/tvinput/shortcut/ShortCutActivity.java
@@ -104,22 +104,27 @@ public class ShortCutActivity extends Activity implements ListItemSelectedListen
 
         int mode = getIntent().getIntExtra(DroidLogicTvUtils.EXTRA_KEY_CODE, 0);
         setShortcutMode(mode);
+    }
 
+    @Override
+    protected void onStart() {
+        Log.d(TAG, "------onStart");
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_TIME_TICK);
         filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
         registerReceiver(mReceiver, filter);
+        super.onStart();
     }
 
     @Override
     protected void onStop() {
-        super.onStop();
+        Log.d(TAG, "------onStop");
         unregisterReceiver(mReceiver);
         if (mProgramObserver != null) {
             getContentResolver().unregisterContentObserver(mProgramObserver);
             mProgramObserver = null;
         }
-        Log.d(TAG, "------onStop");
+        super.onStop();
     }
 
     public boolean onKeyDown(int keyCode, KeyEvent event) {
diff --git a/amlogic/apps/TvInput/DroidLogicTvSource/res/drawable-hdpi/icon_spdif.png b/amlogic/apps/TvInput/DroidLogicTvSource/res/drawable-hdpi/icon_spdif.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/TvInput/DroidLogicTvSource/res/values/strings.xml b/amlogic/apps/TvInput/DroidLogicTvSource/res/values/strings.xml
index 93f3692..3e681aa 100644
--- a/amlogic/apps/TvInput/DroidLogicTvSource/res/values/strings.xml
+++ b/amlogic/apps/TvInput/DroidLogicTvSource/res/values/strings.xml
@@ -12,6 +12,7 @@
     <string name="source_bt_hdmi2">HDMI2</string>
     <string name="source_bt_hdmi3">HDMI3</string>
     <string name="source_bt_hdmi4">HDMI4</string>
+    <string name="source_bt_spdif">SPDIF</string>
 
     <string name="signal_source">Signal source</string>
     <string name="no_signal">No Signal</string>
diff --git a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/AppointedProgramReceiver.java b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/AppointedProgramReceiver.java
index 086d4e5..a2dd0e7 100644
--- a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/AppointedProgramReceiver.java
+++ b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/AppointedProgramReceiver.java
@@ -72,7 +72,7 @@ public class AppointedProgramReceiver extends BroadcastReceiver implements OnCli
             }
             for (int i = 0; i < channelList.size(); i++) {
                 if (ChannelInfo.isSameChannel(channel, channelList.get(i))) {
-                    channelIndex = i;
+                    channelIndex = channelList.get(i).getNumber();
                     break;
                 }
             }
diff --git a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/DroidLogicTv.java b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/DroidLogicTv.java
index b59f0fc..a6053fe 100644
--- a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/DroidLogicTv.java
+++ b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/DroidLogicTv.java
@@ -11,6 +11,8 @@ import com.droidlogic.app.tv.Program;
 import com.droidlogic.app.tv.TvDataBaseManager;
 import com.droidlogic.app.tv.TVTime;
 import com.droidlogic.app.tv.ChannelInfo;
+import com.droidlogic.app.tv.TVInSignalInfo;
+import com.droidlogic.app.tv.TvControlManager;
 
 import com.droidlogic.tvsource.ui.ChannelListLayout;
 import com.droidlogic.tvsource.ui.ChannelListLayout.OnChannelSelectListener;
@@ -30,6 +32,7 @@ import android.content.IntentFilter;
 import android.content.res.Resources.NotFoundException;
 import android.hardware.input.InputManager;
 import android.hardware.hdmi.HdmiTvClient;
+import android.hardware.hdmi.HdmiTvClient.InputChangeListener;
 import android.hardware.hdmi.HdmiDeviceInfo;
 import android.hardware.hdmi.HdmiControlManager;
 import android.media.AudioManager;
@@ -80,7 +83,9 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
     private TvInputChangeCallback mTvInputChangeCallback;
     private ChannelDataManager mChannelDataManager;
     private TvDataBaseManager mTvDataBaseManager;
+    private TvControlManager mTvControlManager = TvControlManager.getInstance();
     private HdmiTvClient mHdmiTvClient = null;
+    private InputChangeListener mInputListener = null;
 
     private FrameLayout mRootView;
     private TvViewInputCallback mTvViewCallback = new TvViewInputCallback();
@@ -95,6 +100,7 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
 
     private int mSigType = 0;
     private boolean isMenuShowing;
+    private String mSourceInputId = null;
 
     private volatile int mNoSignalShutdownCount = -1;
     private TextView mTimePromptText = null;
@@ -225,6 +231,51 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
         mAudioManager = (AudioManager)getSystemService(Context.AUDIO_SERVICE);
         mSystemControlManager = new SystemControlManager(this);
         initThread(mThreadName);
+        mSourceInputId = getIntent().getStringExtra(DroidLogicTvUtils.SOURCE_INPUT_ID);
+        mInputListener = new InputChangeListener() {
+            @Override
+            public void onChanged(HdmiDeviceInfo info) {
+                if (mTvInputManager == null || info == null) return ;
+                List<TvInputInfo> inputList = mTvInputManager.getTvInputList();
+                // TODO: process hdmiId for repeat connections
+                // TODO: add configurations for One Touch Play features of CEC
+                int hdmiId = info.getPhysicalAddress() >> 12;
+                hdmiId += (DroidLogicTvUtils.DEVICE_ID_HDMI1 - 1);
+                for (TvInputInfo tvInfo : inputList) {
+                    int tvInputId = getDeviceId(tvInfo);
+                    if (tvInputId == hdmiId) {
+                        preSwitchSourceInput();
+                        mSourceInput = mSourceMenuLayout.getSourceInput(tvInfo);
+                        sendTuneMessage();
+                    }
+                }
+            }
+        };
+        if (mHdmiTvClient == null) {
+            HdmiControlManager hdmiManager = (HdmiControlManager) getSystemService(Context.HDMI_CONTROL_SERVICE);
+            if (hdmiManager == null) return;
+            mHdmiTvClient = hdmiManager.getTvClient();
+            mHdmiTvClient.setInputChangeListener(mInputListener);
+        }
+    }
+
+    private int getDeviceId(TvInputInfo info) {
+        String[] temp = info.getId().split(Utils.DELIMITER_INFO_IN_ID);
+        if (temp.length == 3) {
+            /*  ignore for HDMI CEC device */
+            if (temp[2].contains(Utils.PREFIX_HDMI_DEVICE))
+                return -1;
+            return Integer.parseInt(temp[2].substring(2));
+        } else {
+            return -1;
+        }
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        // TODO Auto-generated method stub
+        super.onNewIntent(intent);
+        mSourceInputId = intent.getStringExtra(DroidLogicTvUtils.SOURCE_INPUT_ID);
     }
 
     private void init() {
@@ -310,19 +361,28 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
             mSourceMenuLayout.getCurSourceInput().setAVType(mSourceInput.getAVType());
         }
         mSourceInput = mSourceMenuLayout.getCurSourceInput();
+        if (mSourceInput.getSourceType() == DroidLogicTvUtils.SOURCE_TYPE_HDMI1 ||
+            mSourceInput.getSourceType() == DroidLogicTvUtils.SOURCE_TYPE_HDMI2 ||
+            mSourceInput.getSourceType() == DroidLogicTvUtils.SOURCE_TYPE_HDMI3) {
+            TVInSignalInfo si = mTvControlManager.GetCurrentSignalInfo();
+            String[] strings = si.sigFmt.toString().split("_");
+            if (strings != null && strings.length <= 4)
+                mSourceInput.setChannelVideoFormat(" ");
+            else
+                mSourceInput.setChannelVideoFormat(strings[4] + "_" + si.reserved + "HZ");
+        }
     }
 
     private void startPlay() {
         if (mSourceMenuLayout.getSourceCount() == 0)
             return;
-        if (hasStopped || needUpdateSource) {
-            sendTuneMessage();
-        }
+        sendTuneMessage();
     }
 
     @Override
-    protected void onResume() {
-        Utils.logd(TAG, "== onResume ====");
+    protected void onStart() {
+        Utils.logd(TAG, "== onStart ====");
+        mTvInputManager.registerCallback(mTvInputChangeCallback, new Handler());
         closeTouchSound();
         closeScreenOffTimeout();
         initSourceMenuLayout();
@@ -331,10 +391,29 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
         addTvView();
         showUi(Utils.UI_TYPE_ALL_HIDE, false);
         startPlay();
-        showUi(Utils.UI_TYPE_SOURCE_INFO, false);
         hasStopped = false;
+        needUpdateSource = false;
+
+        if (!mReceiverRegisted) {
+            mReceiverRegisted = true;
+            IntentFilter intentFilter = new IntentFilter(DroidLogicTvUtils.ACTION_TIMEOUT_SUSPEND);
+            intentFilter.addAction(DroidLogicTvUtils.ACTION_UPDATE_TV_PLAY);
+            intentFilter.addAction(DroidLogicTvUtils.ACTION_SUBTITLE_SWITCH);
+            intentFilter.addAction(DroidLogicTvUtils.ACTION_DELETE_CHANNEL);
+            intentFilter.addAction(DroidLogicTvUtils.ACTION_SWITCH_CHANNEL);
+            registerReceiver(mReceiver, intentFilter);
+        }
+        super.onStart();
+    }
+
+    @Override
+    protected void onResume() {
+        Utils.logd(TAG, "== onResume ====");
+        if (needUpdateSource)
+            startPlay();
+        showUi(Utils.UI_TYPE_SOURCE_INFO, false);
+
         isMenuShowing = false;
-        needUpdateSource = true;
         isRunning = true;
         isSearchingChannel = false;
         if (mSignalState == SIGNAL_NOT_GOT)
@@ -344,17 +423,8 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
             showMuteIcon(true);
         else
             showMuteIcon(false);
+        switchHdmiChannel();
 
-        mTvInputManager.registerCallback(mTvInputChangeCallback, new Handler());
-        if (!mReceiverRegisted) {
-            mReceiverRegisted = true;
-            IntentFilter intentFilter = new IntentFilter(DroidLogicTvUtils.ACTION_TIMEOUT_SUSPEND);
-            intentFilter.addAction(DroidLogicTvUtils.ACTION_UPDATE_TV_PLAY);
-            intentFilter.addAction(DroidLogicTvUtils.ACTION_SUBTITLE_SWITCH);
-            intentFilter.addAction(DroidLogicTvUtils.ACTION_DELETE_CHANNEL);
-            intentFilter.addAction(DroidLogicTvUtils.ACTION_SWITCH_CHANNEL);
-            registerReceiver(mReceiver, intentFilter);
-        }
         super.onResume();
     }
 
@@ -419,7 +489,7 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
             Uri channel_uri = mSourceInput.getUri();
             Utils.logd(TAG, "channelUri switching to is " + channel_uri);
             mSourceView.tune(mSourceInput.getInputId(), channel_uri);
-            if (mSourceInput.isRadioChannel()) {
+            if (mSourceInput.isRadioChannel() || mSigType == DroidLogicTvUtils.SIG_INFO_TYPE_SPDIF) {
                 mMainView.setBackgroundDrawable(getResources().getDrawable(R.drawable.bg_radio));
             } else {
                 mMainView.setBackgroundDrawable(null);
@@ -467,6 +537,17 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
         }
     }
 
+    private void switchHdmiChannel() {
+        if (mSourceInputId != null) {
+            TvInputInfo info = mTvInputManager.getTvInputInfo(mSourceInputId);
+            if (info != null) {
+                mSourceInput = mSourceMenuLayout.getSourceInput(info);
+                if (mSourceInput != null) mSourceInput.switchSource();
+            }
+            mSourceInputId = null;
+        }
+    }
+
     private void startSetupActivity () {
         if (mSourceInput == null || mSourceInput.getTvInputInfo() == null)
             return;
@@ -732,12 +813,7 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
     }
 
     private void sendKeyEventToHdmi(int keyCode, boolean isPressed) {
-        if (mHdmiTvClient == null) {
-            HdmiControlManager hdmiManager = (HdmiControlManager) getSystemService(Context.HDMI_CONTROL_SERVICE);
-            if (hdmiManager == null) return;
-            mHdmiTvClient = hdmiManager.getTvClient();
-        }
-        if (mHdmiTvClient != null) {
+        if (mHdmiTvClient != null && mUiType != Utils.UI_TYPE_SOURCE_LIST) {
             mHdmiTvClient.sendKeyEvent(keyCode, isPressed);
         }
     }
@@ -773,23 +849,19 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
 
                 if (isToastShow) {
                     sTrackIndex ++;
-                    if (subtitleTrackId == null)
-                        sTrackIndex = 0;
-                    if (sTrackIndex == 0) {
-                        mSourceView.selectTrack(TvTrackInfo.TYPE_SUBTITLE, sTrackList.get(sTrackIndex).getId());
-                        updateTracksInfo(-1, sTrackIndex);
-                        showCustomToast(getResources().getString(R.string.subtitle), sTrackList.get(sTrackIndex).getLanguage());
-                        return;
-                    }
                     if (sTrackIndex == sTrackList.size()) {
                         mSourceView.selectTrack(TvTrackInfo.TYPE_SUBTITLE, null);
                         updateTracksInfo(-1, -2);
                         showCustomToast(getResources().getString(R.string.subtitle), getResources().getString(R.string.off));
                         return;
                     }
+                    if (subtitleTrackId == null) {
+                        sTrackIndex = 0;
+                    }
                     mSourceView.selectTrack(TvTrackInfo.TYPE_SUBTITLE, sTrackList.get(sTrackIndex).getId());
                     updateTracksInfo(-1, sTrackIndex);
                     showCustomToast(getResources().getString(R.string.subtitle), sTrackList.get(sTrackIndex).getLanguage());
+                    Settings.System.putInt(mContext.getContentResolver(), DroidLogicTvUtils.TV_KEY_SUBTITLE_SWITCH, 1);
                 } else {
                     showCustomToast(getResources().getString(R.string.subtitle), sTrackList.get(sTrackIndex).getLanguage());
                 }
@@ -920,6 +992,10 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
                     name = mSourceInput.getChannelVideoFormat();
                 }
                 break;
+            case DroidLogicTvUtils.SIG_INFO_TYPE_SPDIF:
+                label = mSourceInput.getSourceLabel();
+                name = "";
+                break;
             default:
                 label = mSourceInput.getSourceLabel();
                 number = mSourceInput.getChannelNumber();
@@ -953,6 +1029,7 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
                     break;
                 case DroidLogicTvUtils.SIG_INFO_TYPE_AV:
                 case DroidLogicTvUtils.SIG_INFO_TYPE_HDMI:
+                case DroidLogicTvUtils.SIG_INFO_TYPE_SPDIF:
                     mSourceInfoLayout.addView(inflate.inflate(R.layout.hdmi_av_info, mSourceInfoLayout, false));
                     mInfoLabel = (TextView) findViewById(R.id.ha_info_name);
                     mInfoName = (TextView) findViewById(R.id.ha_info_value);
@@ -1057,6 +1134,9 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
     }
 
     private void processSessionEvent(String inputId, String eventType, Bundle eventArgs) {
+        if (eventType == null || eventArgs == null)
+            return;
+
         if (eventType.equals(DroidLogicTvUtils.SIG_INFO_EVENT)) {//sig_info
             mSigType = mSourceInput.getSigType();
             String args = "";
@@ -1093,15 +1173,18 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
     @Override
     protected void onStop() {
         Utils.logd(TAG, "==== onStop ====");
-        if (toast != null)
-            toast.cancel();
-        hasStopped = true;
-        releaseTvView();
-        restoreTouchSound();
-        openScreenOffTimeout();
-        mTvInputManager.unregisterCallback(mTvInputChangeCallback);
-        unregisterReceiver(mReceiver);
-        mReceiverRegisted = false;
+        // prevent twice resources release
+        if (!hasStopped) {
+            if (toast != null)
+                toast.cancel();
+            hasStopped = true;
+            releaseTvView();
+            restoreTouchSound();
+            openScreenOffTimeout();
+            mTvInputManager.unregisterCallback(mTvInputChangeCallback);
+            unregisterReceiver(mReceiver);
+            mReceiverRegisted = false;
+        }
         super.onStop();
     }
 
@@ -1162,11 +1245,30 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
         return false;
     }
 
+    /**
+     * when {@code TvInputChangeCallback} is invoked, must distinguish whether the {@value inputId}
+     * is valid or a HDMI device.
+     */
+    private boolean isValidInputId(String inputId) {
+        Utils.logd(TAG, "isValidInputId, inputId = " + inputId);
+        if (TextUtils.isEmpty(inputId))
+            return false;
+
+        String[] temp = inputId.split(Utils.DELIMITER_INFO_IN_ID);
+        if (temp.length == 3 && temp[2].startsWith(Utils.PREFIX_HDMI_DEVICE))
+            return false;
+
+        return true;
+    }
+
     private final class TvInputChangeCallback extends TvInputManager.TvInputCallback {
 
         @Override
         public void onInputAdded(String inputId) {
             Utils.logd(TAG, "==== onInputAdded, inputId=" + inputId);
+            if (!isValidInputId(inputId))
+                return;
+
             int input_need_reset = mSourceMenuLayout.add(inputId);
             Utils.logd(TAG, "==== input_need_reset=" + input_need_reset);
             if (input_need_reset == SourceInputListLayout.ACTION_FAILED)
@@ -1186,6 +1288,9 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
         @Override
         public void onInputRemoved(String inputId) {
             Utils.logd(TAG, "==== onInputRemoved, inputId=" + inputId);
+            if (!isValidInputId(inputId))
+                return;
+
             int input_need_reset = mSourceMenuLayout.remove(inputId);
             Utils.logd(TAG, "==== input_need_reset=" + input_need_reset);
             if (input_need_reset == SourceInputListLayout.ACTION_FAILED)
@@ -1204,6 +1309,9 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
         @Override
         public void onInputStateChanged(String inputId, int state) {
             Utils.logd(TAG, "==== onInputStateChanged, inputId=" + inputId + ", state=" + state);
+            if (!isValidInputId(inputId))
+                return;
+
             int input_need_reset =  mSourceMenuLayout.stateChange(inputId, state);
             Utils.logd(TAG, "==== input_need_reset=" + input_need_reset);
             if (input_need_reset == SourceInputListLayout.ACTION_FAILED)
@@ -1222,6 +1330,9 @@ public class DroidLogicTv extends Activity implements Callback, onSourceInputCli
         @Override
         public void onInputUpdated(String inputId) {
             Utils.logd(TAG, "==== onInputUpdated, inputId=" + inputId);
+            if (!isValidInputId(inputId))
+                return;
+
             int input_need_reset =  mSourceMenuLayout.update(inputId);
             Utils.logd(TAG, "==== input_need_reset=" + input_need_reset);
             if (input_need_reset == SourceInputListLayout.ACTION_FAILED)
diff --git a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/Utils.java b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/Utils.java
index 0230811..a613528 100644
--- a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/Utils.java
+++ b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/Utils.java
@@ -17,6 +17,10 @@ public class Utils {
     public static final int UI_TYPE_DTV_FAV_LIST = 5;
     public static final int UI_TYPE_NO_SINAL = 6;
     public static final int UI_TYPE_ALL_HIDE = 7;
+    /**These strings are used to construct TvInputInfo, now we use them to parse TvInputInfo**/
+    public static final String DELIMITER_INFO_IN_ID = "/";
+    public static final String PREFIX_HDMI_DEVICE = "HDMI";
+    public static final String PREFIX_HARDWARE_DEVICE = "HW";
 
     public static void logd(String tag, String msg) {
         if (DEBUG)
diff --git a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/ui/SourceButton.java b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/ui/SourceButton.java
index 1985955..f51bdce 100644
--- a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/ui/SourceButton.java
+++ b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/ui/SourceButton.java
@@ -247,10 +247,10 @@ public class SourceButton extends LinearLayout {
         if (mInputInfo == null)
             return;
 
-        String[] temp = mInputInfo.getId().split("/");
+        String[] temp = mInputInfo.getId().split(Utils.DELIMITER_INFO_IN_ID);
         if (temp.length == 3) {
             /*  ignore for HDMI CEC device */
-            if (temp[2].contains("HDMI"))
+            if (temp[2].contains(Utils.PREFIX_HDMI_DEVICE))
                 return ;
             mHardwareDeviceId = Integer.parseInt(temp[2].substring(2));
             mIsHardware = true;
@@ -290,6 +290,9 @@ public class SourceButton extends LinearLayout {
                     mSourceLabel = mResources.getString(R.string.source_bt_hdmi3);
                     icon = mResources.getDrawable(R.drawable.icon_hdmi);
                     break;
+                case DroidLogicTvUtils.DEVICE_ID_SPDIF:
+                    mSourceLabel = mResources.getString(R.string.source_bt_spdif);
+                    icon = mResources.getDrawable(R.drawable.icon_spdif);
                 default:
                     break;
             }
diff --git a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/ui/SourceInputListLayout.java b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/ui/SourceInputListLayout.java
index 158fe67..1e3619c 100644
--- a/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/ui/SourceInputListLayout.java
+++ b/amlogic/apps/TvInput/DroidLogicTvSource/src/com/droidlogic/tvsource/ui/SourceInputListLayout.java
@@ -121,7 +121,7 @@ public class SourceInputListLayout extends LinearLayout implements OnSourceClick
             sb.setState(TvInputManager.INPUT_STATE_CONNECTED);
             initSourceInput(sb);
             mAvaiableSourceCount++;
-        } else {
+        } else if (info.getType() != TvInputInfo.TYPE_HDMI) {
             SourceButton sb = new SourceButton(mContext, info);
             mRoot.addView(sb);
             sb.setOnSourceClickListener(this);
@@ -183,7 +183,7 @@ public class SourceInputListLayout extends LinearLayout implements OnSourceClick
                 sb.setState(TvInputManager.INPUT_STATE_CONNECTED);
                 initSourceInput(sb);
                 mAvaiableSourceCount++;
-            } else {//non-hardware device
+            } else if (info.getType() != TvInputInfo.TYPE_HDMI) {//non-hardware device
                 SourceButton sb = new SourceButton(mContext, info);
                 mRoot.addView(sb);
                 sb.setOnSourceClickListener(this);
@@ -198,10 +198,10 @@ public class SourceInputListLayout extends LinearLayout implements OnSourceClick
     }
 
     private int getDeviceId(TvInputInfo info) {
-        String[] temp = info.getId().split("/");
+        String[] temp = info.getId().split(Utils.DELIMITER_INFO_IN_ID);
         if (temp.length == 3) {
             /*  ignore for HDMI CEC device */
-            if (temp[2].contains("HDMI"))
+            if (temp[2].contains(Utils.PREFIX_HDMI_DEVICE))
                 return -1;
             return Integer.parseInt(temp[2].substring(2));
         } else {
diff --git a/amlogic/apps/VideoPlayer/Android.mk b/amlogic/apps/VideoPlayer/Android.mk
index e359351..e33f0eb 100644
--- a/amlogic/apps/VideoPlayer/Android.mk
+++ b/amlogic/apps/VideoPlayer/Android.mk
@@ -19,9 +19,8 @@ LOCAL_SRC_FILES := $(call all-java-files-under, src)
 
 LOCAL_PACKAGE_NAME := VideoPlayer
 LOCAL_CERTIFICATE := platform
-
 LOCAL_JAVA_LIBRARIES := droidlogic
-LOCAL_SDK_VERSION := current
+LOCAL_STATIC_JAVA_LIBRARIES := android-support-v4
 
 #LOCAL_REQUIRED_MODULES := libamplayerjni libsubjni
 
diff --git a/amlogic/apps/VideoPlayer/AndroidManifest.xml b/amlogic/apps/VideoPlayer/AndroidManifest.xml
index 4795bde..8235ee4 100644
--- a/amlogic/apps/VideoPlayer/AndroidManifest.xml
+++ b/amlogic/apps/VideoPlayer/AndroidManifest.xml
@@ -6,7 +6,8 @@
 
     <original-package android:name="com.droidlogic.videoplayer" />
     <supports-screens android:largeScreens="true" android:anyDensity="true"/>
-    <uses-sdk android:minSdkVersion="14"  android:targetSdkVersion="14"/>
+    <uses-sdk android:minSdkVersion="14"  android:targetSdkVersion="23"/>
+    <uses-permission android:name="android.permission.WRITE_MEDIA_STORAGE"/>
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.WRITE_SETTINGS" />
     <uses-permission android:name="android.permission.WAKE_LOCK" />
diff --git a/amlogic/apps/VideoPlayer/res/drawable-hdpi/certifi_dobly_black.png b/amlogic/apps/VideoPlayer/res/drawable-hdpi/certifi_dobly_black.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/VideoPlayer/res/drawable-hdpi/certifi_dobly_white.png b/amlogic/apps/VideoPlayer/res/drawable-hdpi/certifi_dobly_white.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/VideoPlayer/res/drawable-mdpi/certifi_dobly_black.png b/amlogic/apps/VideoPlayer/res/drawable-mdpi/certifi_dobly_black.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/VideoPlayer/res/drawable-mdpi/certifi_dobly_white.png b/amlogic/apps/VideoPlayer/res/drawable-mdpi/certifi_dobly_white.png
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/apps/VideoPlayer/res/layout/control_bar.xml b/amlogic/apps/VideoPlayer/res/layout/control_bar.xml
index 156a833..35ccd2a 100644
--- a/amlogic/apps/VideoPlayer/res/layout/control_bar.xml
+++ b/amlogic/apps/VideoPlayer/res/layout/control_bar.xml
@@ -51,14 +51,14 @@
             android:id="@+id/CertificationDobly"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
-            android:src="@drawable/certifi_dobly"
+            android:src="@drawable/certifi_dobly_white"
             android:visibility="gone">
         </ImageView>
         <ImageView
             android:id="@+id/CertificationDoblyPlus"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
-            android:src="@drawable/certifi_dobly_plus"
+            android:src="@drawable/certifi_dobly_white"
             android:visibility="gone">
         </ImageView>
         <ImageView
@@ -292,6 +292,25 @@
                 </ImageButton>
             </LinearLayout>
             <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:id="@+id/subtitle_info"
+                android:orientation="horizontal"
+                android:layout_gravity="center_horizontal"
+                android:layout_marginLeft="60dp"
+                android:layout_marginRight="60dp">
+                <TextView
+                    android:id="@+id/sub_info"
+                    android:gravity="left|center_vertical"
+                    android:layout_width="match_parent"
+                    android:layout_height="60dp"
+                    android:textSize="24sp"
+                    android:layout_marginLeft="6dp"
+                    android:textColor="@drawable/black"
+                    android:visibility="gone">
+                </TextView>
+            </LinearLayout>
+            <LinearLayout
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:id="@+id/sub_font"
diff --git a/amlogic/apps/VideoPlayer/res/layout/left_align_list_row.xml b/amlogic/apps/VideoPlayer/res/layout/left_align_list_row.xml
new file mode 100644
index 0000000..0cf6055
--- /dev/null
+++ b/amlogic/apps/VideoPlayer/res/layout/left_align_list_row.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:orientation="horizontal">
+
+    <TextView android:layout_weight="1"
+        android:id="@+id/Text01"
+        android:textSize="18sp"
+        android:textColor="#000000"
+        android:gravity="left|center_vertical"
+        android:layout_marginLeft="10dp"
+        android:layout_width="wrap_content"
+        android:layout_height="fill_parent" />
+
+    <ImageView
+        android:id="@+id/imageview"
+        android:layout_width="wrap_content"
+        android:layout_height="fill_parent" />
+</LinearLayout>
diff --git a/amlogic/apps/VideoPlayer/res/layout/morebar.xml b/amlogic/apps/VideoPlayer/res/layout/morebar.xml
index 0684326..f0a95ed 100644
--- a/amlogic/apps/VideoPlayer/res/layout/morebar.xml
+++ b/amlogic/apps/VideoPlayer/res/layout/morebar.xml
@@ -58,6 +58,16 @@
         android:gravity="center">
     </ImageButton>
     <ImageButton
+        android:id="@+id/ChapterBtn"
+        android:src="@drawable/doc"
+        android:background="@drawable/btn_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:gravity="center"
+        android:visibility="gone">
+    </ImageButton>
+	<ImageButton
         android:id="@+id/DisplayBtn"
         android:src="@drawable/diplay"
         android:background="@drawable/btn_button"
diff --git a/amlogic/apps/VideoPlayer/res/values-zh-rCN/strings.xml b/amlogic/apps/VideoPlayer/res/values-zh-rCN/strings.xml
index 72e2716..2f7ba1a 100644
--- a/amlogic/apps/VideoPlayer/res/values-zh-rCN/strings.xml
+++ b/amlogic/apps/VideoPlayer/res/values-zh-rCN/strings.xml
@@ -26,10 +26,13 @@
     <string name="setting_soundtrack_rmono">右声道</string>
     <string name="setting_soundtrack_lrmix">混音</string>
     <string name="setting_subtitle">字幕</string>
+    <string name="setting_chapter">章节</string>
+    <string name="subtitle_insub">内嵌</string>
     <string name="setting_displaymode">显示模式</string>
     <string name="setting_displaymode_normal">正常</string>
     <string name="setting_displaymode_normal_noscaleup">正常不放大</string>
     <string name="setting_displaymode_fullscreen">全屏</string>
+    <string name="setting_displaymode_original">原始</string>
     <string name="setting_brightness">亮度</string>
     <string name="setting_3d_mode">3D模式</string>
     <string name="setting_3d_grating_open">打开光栅</string>
diff --git a/amlogic/apps/VideoPlayer/res/values-zh-rTW/strings.xml b/amlogic/apps/VideoPlayer/res/values-zh-rTW/strings.xml
index 3436a30..98e3539 100644
--- a/amlogic/apps/VideoPlayer/res/values-zh-rTW/strings.xml
+++ b/amlogic/apps/VideoPlayer/res/values-zh-rTW/strings.xml
@@ -30,6 +30,7 @@
     <string name="setting_displaymode_normal">正常</string>
     <string name="setting_displaymode_normal_noscaleup">正常不放大</string>
     <string name="setting_displaymode_fullscreen">全屏</string>
+    <string name="setting_displaymode_original">原始</string>
     <string name="setting_brightness">亮度</string>
     <string name="setting_3d_mode">Play 3D Mode</string>
     <string name="setting_3d_grating_open">Open Grating</string>
@@ -85,7 +86,8 @@
     <string name="no_file">沒有視頻文件！</string>
     <string name="searching">搜索中...</string>
     <string name="all_file">視頻列表</string>
-
+    <string name="setting_chapter">章節</string>
+    <string name="subtitle_insub">內嵌</string>
     <string name="unsupport_media">不支持媒體文件</string>
     <string name="unsupport_video_format">不支持視頻格式</string>
     <string name="unsupport_audio_format">不支持音頻格式</string>
diff --git a/amlogic/apps/VideoPlayer/res/values/strings.xml b/amlogic/apps/VideoPlayer/res/values/strings.xml
index 1617d98..c6d2749 100644
--- a/amlogic/apps/VideoPlayer/res/values/strings.xml
+++ b/amlogic/apps/VideoPlayer/res/values/strings.xml
@@ -26,10 +26,13 @@
     <string name="setting_soundtrack_rmono">Right Mono</string>
     <string name="setting_soundtrack_lrmix">Sound Mixing</string>
     <string name="setting_subtitle">Subtitle</string>
+    <string name="setting_chapter">Chapter</string>
+    <string name="subtitle_insub">INSUB</string>
     <string name="setting_displaymode">Display Mode</string>
     <string name="setting_displaymode_normal">Normal</string>
     <string name="setting_displaymode_normal_noscaleup">No Scale Up</string>
     <string name="setting_displaymode_fullscreen">Full Screen</string>
+    <string name="setting_displaymode_original">Original</string>
     <string name="setting_brightness">Brightness</string>
     <string name="setting_3d_mode">Play 3D Mode</string>
     <string name="setting_3d_diable">OFF</string>
diff --git a/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/FileList.java b/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/FileList.java
index dd64910..98fee96 100644
--- a/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/FileList.java
+++ b/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/FileList.java
@@ -12,10 +12,16 @@ import android.app.AlertDialog;
 import android.app.ListActivity;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.Manifest;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Environment;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.ContextCompat;
 import android.util.Log;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
@@ -59,7 +65,11 @@ public class FileList extends ListActivity {
         private static final String USB_DRIVE_PATH      = "/mnt/usbdrive";
         private static final String SHELL_PATH          = "/mnt/shell";
 
+        private Context mContext;
+        private ApplicationInfo mAppInfo;
+
         private boolean listAllFiles = true;
+        private boolean mFileFlag = false;
         private List<File> listFiles = null;
         private List<File> listVideos = null;
         private List<String> items = null;
@@ -273,6 +283,8 @@ public class FileList extends ListActivity {
             setContentView (R.layout.file_list);
             mSystemControl = new SystemControlManager(this);
             mStorageManager = (StorageManager)getSystemService(Context.STORAGE_SERVICE);
+            mContext = this.getApplicationContext();
+            mAppInfo = mContext.getApplicationInfo();
             PlayList.setContext (this);
             listAllFiles = mSystemControl.getPropertyBoolean("vplayer.listall.enable", false);
             currentlist = new ArrayList<String>();
@@ -737,20 +749,41 @@ public class FileList extends ListActivity {
             }
         }
 
-        public boolean isISOFile (File file) {
+        private static boolean hasBDFile(File[] files, String name) {
+           for (File file : files) {
+               if (name != null && name.equals(file.getName()) && file.isDirectory())
+                   return true;
+           }
+           return false;
+        }
+
+        public static boolean isISOFile (File file) {
             String fname = file.getName();
             String sname = ".iso";
             if (fname == "") {
                 Log.e (TAG, "NULL file");
                 return false;
             }
-            if (fname.toLowerCase().endsWith (sname)) {
+            if (file.isFile() && fname.toLowerCase().endsWith (sname)) {
                 return true;
             }
+            if (file.isDirectory()) {
+                File[] rootFiles = file.listFiles();
+                if (rootFiles != null && rootFiles.length >= 1 && hasBDFile(rootFiles, "BDMV")) {
+                    File bdDir = new File(file.getPath(), "BDMV");
+                    String[] files = bdDir.list();
+                    ArrayList<String> names = new ArrayList<String>();
+                    for (int i = 0; i < files.length; i++)
+                        names.add(files[i]);
+                    if (names.contains("index.bdmv") && names.contains("PLAYLIST")
+                        && names.contains("CLIPINF") && names.contains("STREAM"))
+                        return true;
+                }
+            }
             return false;
         }
 
-        public void execCmd (String cmd) {
+        public static void execCmd (String cmd) {
             int ch;
             Process p = null;
             Log.d (TAG, "exec command: " + cmd);
@@ -779,6 +812,7 @@ public class FileList extends ListActivity {
 
         @Override
         protected void onListItemClick (ListView l, View v, int position, long id) {
+            mFileFlag = true;
             File file = new File (paths.get (position));
             currentlist.clear();
             currentlist.addAll (paths);
@@ -789,7 +823,7 @@ public class FileList extends ListActivity {
             if (fileDirectory_position_piexl == null) {
                 fileDirectory_position_piexl = new ArrayList<Integer>();
             }
-            if (file.isDirectory()) {
+            if (file.isDirectory() && !isISOFile(file)) {
                 item_position_selected = getListView().getSelectedItemPosition();
                 item_position_first = getListView().getFirstVisiblePosition();
                 View cv = getListView().getChildAt (item_position_selected - item_position_first);
@@ -802,18 +836,38 @@ public class FileList extends ListActivity {
                     fileDirectory_position_piexl.add (fromtop_piexl);
                     pathLevel++;
                 }
+                mFileFlag = false;
             }
-            else if (isISOFile (file)) {
+            else if (isISOFile(file) && file.isFile()) {
                 ISOpath = file.getPath();
                 Log.i(TAG, "file.getPath():" + file.getPath()+", ISOpath:"+ISOpath);
                 mSystemControl.loopMountUnmount(false, null);
                 mSystemControl.loopMountUnmount(true, ISOpath);
-                waitForBrowserIsoFile();
-                fileDirectory_position_selected.add (item_position_selected);
-                fileDirectory_position_piexl.add (fromtop_piexl);
-                pathLevel++;
+                File isofile = new File(iso_mount_dir);
+                if (isofile.exists() && isofile.isDirectory()) {
+                    File[] rootFiles = isofile.listFiles();
+                    if (rootFiles != null && rootFiles.length >= 1 && hasBDFile(rootFiles, "BDMV")) {
+                        File bdfiles = new File(iso_mount_dir, "BDMV");
+                        String[] bdmvFiles = bdfiles.list();
+                        ArrayList<String> names = new ArrayList<String>();
+                        for (int i = 0; i < bdmvFiles.length; i++)
+                            names.add(bdmvFiles[i]);
+                        if (names.contains("index.bdmv") && names.contains("PLAYLIST")
+                            && names.contains("CLIPINF") && names.contains("STREAM"))
+                            mFileFlag = true;
+                    } else {
+                        waitForBrowserIsoFile();
+                        fileDirectory_position_selected.add (item_position_selected);
+                        fileDirectory_position_piexl.add (fromtop_piexl);
+                        pathLevel++;
+                        mFileFlag = false;
+                    }
+                } else
+                    mFileFlag = false;
+            } else if (isISOFile(file) && file.isDirectory()){
+                mFileFlag = true;
             }
-            else {
+            if (mFileFlag) {
                 if (!listAllFiles) {
                     int pos = filterDir (file);
                     if (pos < 0) {
@@ -900,8 +954,16 @@ public class FileList extends ListActivity {
             /*SettingsVP.setSystemWrite(sw);
             if (SettingsVP.chkEnableOSD2XScale() == true)
                 this.setVisible(false);*/
-            startActivity (intent);
-            FileList.this.finish();
+            if (mAppInfo.targetSdkVersion >= Build.VERSION_CODES.M &&
+                (PackageManager.PERMISSION_DENIED == ContextCompat.checkSelfPermission(mContext, Manifest.permission.READ_EXTERNAL_STORAGE))) {
+                ActivityCompat.requestPermissions(FileList.this,
+                    new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},
+                    /*MY_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE*/0);
+            }
+            else {
+                startActivity (intent);
+                FileList.this.finish();
+            }
         }
 
         public int filterDir (File file) {
@@ -916,7 +978,7 @@ public class FileList extends ListActivity {
             listVideos = new ArrayList<File>();
             for (int i = 0; i < the_Files.length; i++) {
                 File tempF = the_Files[i];
-                if (tempF.isFile()) {
+                if (tempF.isFile() || (tempF.isDirectory() && isISOFile(tempF))) {
                     listVideos.add (tempF);
                 }
             }
diff --git a/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/MediaInfo.java b/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/MediaInfo.java
index 4dc043e..45b096d 100644
--- a/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/MediaInfo.java
+++ b/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/MediaInfo.java
@@ -675,6 +675,11 @@ public class MediaInfo {
         public static final int MEDIA_INFO_AMLOGIC_SHOW_AUDIO_LIMITED = MEDIA_INFO_AMLOGIC_BASE+8;
         public static final int MEDIA_INFO_AMLOGIC_SHOW_DTS_MULASSETHINT = MEDIA_INFO_AMLOGIC_BASE+9;
         public static final int MEDIA_INFO_AMLOGIC_SHOW_DTS_HPS_NOTSUPPORT = MEDIA_INFO_AMLOGIC_BASE+10;
+        public static final int MEDIA_INFO_AMLOGIC_BLURAY_STREAM_PATH = MEDIA_INFO_AMLOGIC_BASE + 11;
+
+        public static final int BLURAY_STREAM_TYPE_VIDEO = 'V';
+        public static final int BLURAY_STREAM_TYPE_AUDIO = 'A';
+        public static final int BLURAY_STREAM_TYPE_SUB = 'S';
 
         public static boolean needShowOnUI (int info) {
             boolean ret = false;
diff --git a/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/MyAdapter.java b/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/MyAdapter.java
index a323b36..c14168c 100644
--- a/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/MyAdapter.java
+++ b/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/MyAdapter.java
@@ -69,6 +69,8 @@ public class MyAdapter extends BaseAdapter {
             holder.text.setText (txtf.getName());
             if (f.isDirectory()) {
                 holder.icon.setImageBitmap (iconFolder);
+                if (FileList.isISOFile(f))
+                    holder.icon.setImageBitmap (iconVideo);
             }
             else {
                 holder.icon.setImageBitmap (iconVideo);
diff --git a/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/VideoPlayer.java b/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/VideoPlayer.java
index d8e514b..0317dce 100644
--- a/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/VideoPlayer.java
+++ b/amlogic/apps/VideoPlayer/src/com/droidlogic/videoplayer/VideoPlayer.java
@@ -14,6 +14,7 @@ import android.content.DialogInterface.OnClickListener;
 import android.content.DialogInterface.OnDismissListener;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.pm.PackageManager;
 import android.content.SharedPreferences;
 import android.database.Cursor;
 import android.graphics.Bitmap;
@@ -65,6 +66,7 @@ import android.widget.TextView;
 import android.widget.Toast;
 //import android.widget.VideoView;
 import android.text.TextUtils;
+import com.android.internal.app.LocalePicker;
 
 import com.droidlogic.app.MediaPlayerExt;
 import com.droidlogic.app.SubtitleManager;
@@ -87,7 +89,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Timer;
 import java.util.TimerTask;
-
 import java.util.Random;
 import android.media.TimedText;
 //import android.media.SubtitleData;
@@ -127,6 +128,7 @@ public class VideoPlayer extends Activity {
         private ImageButton repeatModeBtn = null;
         private ImageButton audiooptionBtn = null;
         private ImageButton subtitleSwitchBtn = null;
+        private ImageButton chapterBtn = null;
         private ImageButton displayModeBtn = null;
         private ImageButton brigtnessBtn = null;
         private ImageButton fileinfoBtn = null;
@@ -192,9 +194,23 @@ public class VideoPlayer extends Activity {
         private SubtitleManager mSubtitleManager;
         private SystemControlManager mSystemControl;
 
+        private boolean mIsBluray = false;
+        private ArrayList<String> mBlurayVideoLang = null;
+        private ArrayList<String> mBlurayAudioLang = null;
+        private ArrayList<String> mBluraySubLang = null;
+        private static List<LocalePicker.LocaleInfo> LOCALES;
+        private int mSubIndex = 0;
+        private static final int SUBTITLE_PGS = 2;
+        private static final int SUBTITLE_DVB = 6;
+        private static final int SUBTITLE_TMD_TXT = 7;
+        private ArrayList<ChapterInfo> mBlurayChapter = null;
+        private int mListViewHeight = ViewGroup.LayoutParams.WRAP_CONTENT;
+        private static final String LOOP_DIR = "/mnt/loop";
+
         @Override
         public void onCreate (Bundle savedInstanceState) {
             super.onCreate (savedInstanceState);
+            LOCALES = LocalePicker.getAllAssetLocales(this, false);
             mSystemControl = new SystemControlManager(this);
             LOGI (TAG, "[onCreate]");
             setContentView (R.layout.control_bar);
@@ -215,12 +231,14 @@ public class VideoPlayer extends Activity {
             init();
             if (0 != checkUri()) { return; }
             storeFilePos();
+
             ////showCtlBar();
         }
 
         @Override
         public void onResume() {
             super.onResume();
+
             LOGI (TAG, "[onResume]mResumePlay.getEnable():" + mResumePlay.getEnable() + ",isHdmiPlugged:" + isHdmiPlugged);
             //close transition animation
             // shield for google tv 20140929 , opened for bug 101311 20141224
@@ -300,6 +318,7 @@ public class VideoPlayer extends Activity {
         @Override
         public void onPause() {
             super.onPause();
+
             LOGI (TAG, "[onPause] curtime:" + curtime);
             mErrorTime = 0;
             mErrorTimeBac = 0;
@@ -339,6 +358,7 @@ public class VideoPlayer extends Activity {
                 mHandler.removeMessages (MSG_RETRY_PLAY);
                 mHandler.removeMessages (MSG_RETRY_END);
                 mHandler.removeMessages (MSG_SEEK_BY_BAR);
+                mHandler.removeMessages (MSG_UPDATE_DISPLAY_MODE);
             }
             // shield for google tv 20140929, opened for bug 101311 20141224
             /*IWindowManager iWindowManager = IWindowManager.Stub.asInterface(ServiceManager.getService("window"));
@@ -375,7 +395,7 @@ public class VideoPlayer extends Activity {
 
         //@@--------this part for message handle---------------------------------------------------------------------
         private static final long MSG_SEND_DELAY = 0; //1000;//1s
-        private static final long MSG_SEEK_SEND_DELAY = 500; //500ms
+        private static final long MSG_SEND_DELAY_500MS = 500; //500ms
         private static final int MSG_UPDATE_PROGRESS = 0xF1;//random value
         private static final int MSG_PLAY = 0xF2;
         private static final int MSG_STOP = 0xF3;
@@ -383,6 +403,7 @@ public class VideoPlayer extends Activity {
         private static final int MSG_RETRY_END = 0xF5;
         private static final int MSG_SUB_OPTION_UPDATE = 0xF6;
         private static final int MSG_SEEK_BY_BAR = 0xF7;
+        private static final int MSG_UPDATE_DISPLAY_MODE = 0xF8;
         private boolean ignoreUpdateProgressbar = false;
         private Handler mHandler = new Handler() {
             @Override
@@ -459,6 +480,9 @@ public class VideoPlayer extends Activity {
                     case MSG_SEEK_BY_BAR:
                         seekByProgressBar();
                         break;
+                    case MSG_UPDATE_DISPLAY_MODE:
+                        displayModeImpl();
+                        break;
                 }
             }
         };
@@ -576,6 +600,12 @@ public class VideoPlayer extends Activity {
                 if (audio_init_list_idx >= audio_total_num) {
                     audio_init_list_idx = audio_total_num - 1;
                 }
+                Locale loc = Locale.getDefault();
+                if (loc != null && mIsBluray) {
+                    int index = getLanguageIndex(MediaInfo.BLURAY_STREAM_TYPE_AUDIO, loc.getISO3Language());
+                    if (index >= 0)
+                        audio_init_list_idx = index;
+                }
                 mOption.setAudioTrack (audio_init_list_idx);
                 mOption.setAudioDtsAsset (0); //dts test // default 0, should get current asset from player core 20140717
 
@@ -647,6 +677,7 @@ public class VideoPlayer extends Activity {
             repeatModeBtn = (ImageButton) findViewById (R.id.PlaymodeBtn);
             audiooptionBtn = (ImageButton) findViewById (R.id.ChangetrackBtn);
             subtitleSwitchBtn = (ImageButton) findViewById (R.id.SubtitleBtn);
+            chapterBtn = (ImageButton) findViewById (R.id.ChapterBtn);
             displayModeBtn = (ImageButton) findViewById (R.id.DisplayBtn);
             brigtnessBtn = (ImageButton) findViewById (R.id.BrightnessBtn);
             fileinfoBtn = (ImageButton) findViewById (R.id.InfoBtn);
@@ -765,6 +796,12 @@ public class VideoPlayer extends Activity {
                     subtitleSelect();
                 }
             });
+            chapterBtn.setOnClickListener (new View.OnClickListener() {
+                public void onClick (View v) {
+                    LOGI (TAG, "chapterBtn onClick");
+                    chapterSelect();
+                }
+            });
             displayModeBtn.setOnClickListener (new View.OnClickListener() {
                 public void onClick (View v) {
                     LOGI (TAG, "displayModeBtn onClick");
@@ -988,7 +1025,7 @@ public class VideoPlayer extends Activity {
         SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback() {
             public void surfaceChanged (SurfaceHolder holder, int format, int w, int h) {
                 LOGI (TAG, "[surfaceChanged]format:" + format + ",w:" + w + ",h:" + h);
-                if (mSurfaceView != null) {
+                if (mSurfaceView != null && mMediaPlayer != null && mMediaPlayer.isPlaying()) {
                     displayModeImpl();
                 }
             }
@@ -1069,6 +1106,9 @@ public class VideoPlayer extends Activity {
         private BroadcastReceiver mHdmiReceiver = new BroadcastReceiver() {
             public void onReceive (Context context, Intent intent) {
                 isHdmiPlugged = intent.getBooleanExtra (EXTRA_HDMI_PLUGGED_STATE, false);
+                if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
+                    sendUpdateDisplayModeMsg();
+                }
                 if ( (isHdmiPluggedbac != isHdmiPlugged) && (isHdmiPlugged == false)) {
                     if (mState == STATE_PLAYING) {
                         if (!getPlayIgnoreHdmiEnable()) {
@@ -1182,6 +1222,7 @@ public class VideoPlayer extends Activity {
         private final int apresentationMax = 32;
         private int[] assetsArrayNum = new int[apresentationMax];
         private int mApresentIdx = -1;
+        private static final String DISPLAY_MODE_SYSFS = "/sys/class/display/mode";
         private void resumeSelect() {
             LOGI (TAG, "[resumeSelect]");
             ListView listView = (ListView) findViewById (R.id.ListView);
@@ -1257,7 +1298,11 @@ public class VideoPlayer extends Activity {
 
         private void audiotrackSelect() {
             LOGI (TAG, "[audiotrackSelect]");
-            SimpleAdapter audioarray = getMorebarListAdapter (AUDIO_TRACK, mOption.getAudioTrack());
+            SimpleAdapter audioarray = null;
+            if (mIsBluray)
+                audioarray = getMorebarListAdapter(AUDIO_TRACK, mOption.getAudioTrack());
+            else
+                audioarray = getMorebarListAdapter(AUDIO_TRACK, mOption.getAudioTrack());
             ListView listView = (ListView) findViewById (R.id.ListView);
             listView.setAdapter (audioarray);
             listView.setOnItemClickListener (new AdapterView.OnItemClickListener() {
@@ -1399,6 +1444,32 @@ public class VideoPlayer extends Activity {
             subtitle_control();
         }
 
+        private void setListViewHeight(int height) {
+            ListView listView = (ListView) findViewById (R.id.ListView);
+            ViewGroup.LayoutParams params = listView.getLayoutParams();
+            if (params instanceof LinearLayout.LayoutParams) {
+                params.height = height;
+                listView.setLayoutParams(params);
+                mListViewHeight = height;
+            }
+        }
+
+        private void chapterSelect() {
+            LOGI (TAG, "[chapterSelect]");
+            ListView listView = (ListView) findViewById (R.id.ListView);
+            setListViewHeight((int)(getWindowManager().getDefaultDisplay().getHeight() * 0.4));
+            listView.setAdapter (getMorebarListAdapter(CHAPTER_MODE, 0));
+            listView.setOnItemClickListener (new AdapterView.OnItemClickListener() {
+                public void onItemClick (AdapterView<?> parent, View view, int position, long id) {
+                    if (mMediaPlayer != null && mMediaInfo != null) {
+                        seekTo(mBlurayChapter.get(position).start * 1000);
+                    }
+                    exitOtherWidget (chapterBtn);
+                }
+            });
+            showOtherWidget (R.string.setting_chapter);
+        }
+
         private void displayModeSelect() {
             LOGI (TAG, "[displayModeSelect]");
             // TODO: check 3D
@@ -1430,6 +1501,9 @@ public class VideoPlayer extends Activity {
                         case 3://mOption.DISP_MODE_RATIO16_9:
                             mOption.setDisplayMode (mOption.DISP_MODE_RATIO16_9);
                             break;
+                        case 4://mOption.DISP_MODE_ORIGINAL
+                            mOption.setDisplayMode (mOption.DISP_MODE_ORIGINAL);
+                            break;
                         default:
                             break;
                     }
@@ -1561,13 +1635,20 @@ public class VideoPlayer extends Activity {
             int frameHeight = -1;
             int width = -1;
             int height = -1;
+            boolean skipImgSubRatio = false;
 
+            String mode = mSystemControl.readSysFs(DISPLAY_MODE_SYSFS).replaceAll("\n","");
+            int[] curPosition = mSystemControl.getPosition(mode);
+            dispWidth = curPosition[2];
+            dispHeight = curPosition[3];
             DisplayMetrics dm = new DisplayMetrics();
             this.getWindowManager().getDefaultDisplay().getRealMetrics (dm);
             frameWidth = dm.widthPixels;
             frameHeight = dm.heightPixels;
-            dispWidth = frameWidth;
-            dispHeight = frameHeight;
+            if (dispWidth == 0 || dispHeight == 0) {
+                dispWidth = frameWidth;
+                dispHeight = frameHeight;
+            }
 
             LOGI (TAG, "[displayModeImpl]dispWidth:" + dispWidth + ",dispHeight:" + dispHeight);
 
@@ -1583,7 +1664,7 @@ public class VideoPlayer extends Activity {
                 videoWidth = mMediaPlayer.getVideoWidth();
                 videoHeight = mMediaPlayer.getVideoHeight();
                 LOGI (TAG, "[displayModeImpl]videoWidth:" + videoWidth + ",videoHeight:" + videoHeight);
-                if (mOption.getDisplayMode() == 0) { // normal
+                if (mOption.getDisplayMode() == mOption.DISP_MODE_NORMAL) { // normal
                     if (videoWidth * dispHeight < dispWidth * videoHeight) {
                         //image too wide
                         width = dispHeight * videoWidth / videoHeight;
@@ -1599,11 +1680,11 @@ public class VideoPlayer extends Activity {
                         height = dispHeight;
                     }
                 }
-                else if (mOption.getDisplayMode() == 1) { // full screen
+                else if (mOption.getDisplayMode() == mOption.DISP_MODE_FULLSTRETCH) { // full screen
                     width = dispWidth;
                     height = dispHeight;
                 }
-                else if (mOption.getDisplayMode() == 2) { // 4:3
+                else if (mOption.getDisplayMode() == mOption.DISP_MODE_RATIO4_3) { // 4:3
                     videoWidth = 4 * videoHeight / 3;
                     if (videoWidth * dispHeight < dispWidth * videoHeight) {
                         //image too wide
@@ -1620,7 +1701,7 @@ public class VideoPlayer extends Activity {
                         height = dispHeight;
                     }
                 }
-                else if (mOption.getDisplayMode() == 3) { // 16:9
+                else if (mOption.getDisplayMode() == mOption.DISP_MODE_RATIO16_9) { // 16:9
                     videoWidth = 16 * videoHeight / 9;
                     if (videoWidth * dispHeight < dispWidth * videoHeight) {
                         //image too wide
@@ -1637,9 +1718,23 @@ public class VideoPlayer extends Activity {
                         height = dispHeight;
                     }
                 }
+                else if (mOption.getDisplayMode() == mOption.DISP_MODE_ORIGINAL) { // original
+                    videoWidth = mMediaInfo.getVideoWidth();
+                    videoHeight = mMediaInfo.getVideoHeight();
+                    float fbratio_div_outputratio = ((float)frameWidth / frameHeight) / ((float)dispWidth / dispHeight);
+                    if (videoWidth * fbratio_div_outputratio * frameHeight > videoHeight * frameWidth) {
+                        width = frameWidth;
+                        height = (int)((float)(frameWidth * videoHeight) / ((float)videoWidth * fbratio_div_outputratio));
+                    }
+                    else {
+                        width = (int)((float)(videoWidth * fbratio_div_outputratio * frameHeight) / (float)videoHeight);
+                        height = frameHeight;
+                    }
+                    skipImgSubRatio = true;
+                }
 
                 LOGI (TAG, "[displayModeImpl]width:" + width + ",height:" + height);
-                if (getImgSubRatioEnable() && dispWidth != 0 && dispHeight != 0) {
+                if (getImgSubRatioEnable() && dispWidth != 0 && dispHeight != 0 && !skipImgSubRatio) {
                     width = width * frameWidth / dispWidth;
                     height = height * frameHeight / dispHeight;
                     float ratioW = 1.000f;
@@ -1827,6 +1922,14 @@ public class VideoPlayer extends Activity {
             }
         }
 
+        private void sendUpdateDisplayModeMsg() {
+            if (mHandler != null) {
+                Message msg = mHandler.obtainMessage (MSG_UPDATE_DISPLAY_MODE);
+                mHandler.sendMessageDelayed (msg, MSG_SEND_DELAY_500MS);
+                LOGI (TAG, "[sendUpdateDisplayModeMsg]sendMessageDelayed MSG_UPDATE_DISPLAY_MODE");
+            }
+        }
+
         //@@--------random seek function-------------------------------------------------------------------------------------------
         private boolean randomSeekTestFlag = false;
         private Random r = new Random (99);
@@ -2270,7 +2373,7 @@ public class VideoPlayer extends Activity {
         private void sendSeekByProgressBarMsg() {
             if (mHandler != null) {
                 Message msg = mHandler.obtainMessage (MSG_SEEK_BY_BAR);
-                mHandler.sendMessageDelayed (msg, MSG_SEEK_SEND_DELAY);
+                mHandler.sendMessageDelayed (msg, MSG_SEND_DELAY_500MS);
                 LOGI (TAG, "[sendSeekByProgressBarMsg]sendMessageDelayed MSG_SEEK_BY_BAR");
             }
         }
@@ -2291,7 +2394,7 @@ public class VideoPlayer extends Activity {
             }
             LOGI (TAG, "[seekByProgressBar]seekTo:" + pos);
             seekTo (pos);
-            stopOsdTimeout();
+            //stopOsdTimeout();
             //curtime=pos;
         }
 
@@ -2372,6 +2475,20 @@ public class VideoPlayer extends Activity {
                                                      AudioManager.AUDIOFOCUS_GAIN);
                 }
                 mMediaPlayer.start();
+                Locale loc = Locale.getDefault();
+                if (loc != null && mIsBluray) {
+                    if (mSubIndex == 0) {
+                        mSubIndex = getLanguageIndex(MediaInfo.BLURAY_STREAM_TYPE_SUB, loc.getISO3Language());
+                        if (mSubIndex == -1)
+                            mSubIndex = 0;
+                        if (mSubtitleManager.total() > 0) {
+                            mSubtitleManager.openIdx(mSubIndex);
+                        }
+                    }
+                } else {
+                    mSubIndex = 0;
+                    mSubtitleManager.openIdx(mSubIndex);
+                }
                 mSubtitleManager.start();
                 mState = STATE_PLAYING;
                 updateIconResource();
@@ -2423,6 +2540,16 @@ public class VideoPlayer extends Activity {
                     mAudioManager.abandonAudioFocus (mAudioFocusListener);
                     mAudioFocused = false;
                 }
+                if (mBlurayVideoLang != null)
+                    mBlurayVideoLang.clear();
+                if (mBlurayAudioLang != null)
+                    mBlurayAudioLang.clear();
+                if (mBluraySubLang != null)
+                    mBluraySubLang.clear();
+                if (mBlurayChapter != null)
+                    mBlurayChapter.clear();
+                mIsBluray = false;
+                mSubIndex = 0;
             }
         }
 
@@ -2550,12 +2677,53 @@ public class VideoPlayer extends Activity {
                 }
             }*/
             LOGI (TAG, "[setVideoPath]Uri.parse(path):" + Uri.parse (path));
+            path = changeForIsoFile(path);
             setVideoURI (Uri.parse (path), path); //add path to resolve special character for uri, such as  ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |"$" | ","
             if (!isTimedTextDisable()) {
                 searchExternalSubtitle(path);
             }
         }
 
+        private void mount(String path) {
+               mSystemControl.loopMountUnmount(false, null);
+               mSystemControl.loopMountUnmount(true, path);
+        }
+
+        private String changeForIsoFile(String path) {
+            File file = new File(path);
+            String fpath = file.getPath();
+            if (fpath.toLowerCase().endsWith(".iso")) {
+                mount(fpath);
+                File f = new File(LOOP_DIR);
+                //File f = new File("/mnt/sdcard/loop");
+                if (!f.exists() || (f.exists() && !f.isDirectory())) {
+                    Log.e(TAG, "/storage/loop not exists");
+                    mount(fpath);
+                }
+                //fpath = "bluray:/mnt/sdcard/loop";
+                fpath = "bluray:/mnt/loop";
+                mIsBluray = true;
+                mBlurayVideoLang = new ArrayList<String>();
+                mBlurayAudioLang = new ArrayList<String>();
+                mBluraySubLang = new ArrayList<String>();
+                mBlurayChapter = new ArrayList<ChapterInfo>();
+                chapterBtn.setVisibility(View.VISIBLE);
+            } else if (file.isDirectory() && FileList.isISOFile(file)) {
+                fpath = "bluray:" + fpath;
+                mIsBluray = true;
+                mBlurayVideoLang = new ArrayList<String>();
+                mBlurayAudioLang = new ArrayList<String>();
+                mBluraySubLang = new ArrayList<String>();
+                mBlurayChapter = new ArrayList<ChapterInfo>();
+                chapterBtn.setVisibility(View.VISIBLE);
+            } else {
+                mIsBluray = false;
+                chapterBtn.setVisibility(View.GONE);
+            }
+            LOGI(TAG, "[changeForIsoFile]fpath: " + fpath);
+            return fpath;
+        }
+
         private void setVideoURI (Uri uri, String path) {
             LOGI (TAG, "[setVideoURI]uri:" + uri + ",path:" + path);
             setVideoURI (uri, null, path);
@@ -2689,6 +2857,7 @@ public class VideoPlayer extends Activity {
             mMediaPlayer.setOnSeekCompleteListener (mSeekCompleteListener);
             mMediaPlayer.setOnErrorListener (mErrorListener);
             mMediaPlayer.setOnInfoListener (mInfoListener);
+            mMediaPlayer.setOnBlurayInfoListener(mBlurayListener);
             mMediaPlayer.setDisplay (mSurfaceHolder);
             mMediaPlayer.setOnTimedTextListener(mTimedTextListener);
             //@@mMediaPlayer.setOnSubtitleDataListener(mSubtitleDataListener);
@@ -2706,13 +2875,15 @@ public class VideoPlayer extends Activity {
         new MediaPlayer.OnVideoSizeChangedListener() {
             public void onVideoSizeChanged (MediaPlayer mp, int width, int height) {
                 LOGI (TAG, "[onVideoSizeChanged]");
-                displayModeImpl();
+                if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
+                    displayModeImpl();
+                }
                 if (mMediaPlayer != null && mSurfaceView != null) {
                     int videoWidth = mMediaPlayer.getVideoWidth();
                     int videoHeight = mMediaPlayer.getVideoHeight();
                     LOGI (TAG, "[onVideoSizeChanged]videoWidth:" + videoWidth + ",videoHeight:" + videoHeight);
                     if (videoWidth != 0 && videoHeight != 0) {
-                        displayModeImpl();
+                        ////displayModeImpl();
                         mSurfaceView.requestLayout();
                         /*mSurfaceView.getHolder().setFixedSize(videoWidth, videoHeight);
                         mSurfaceView.requestLayout();*/
@@ -2835,6 +3006,7 @@ public class VideoPlayer extends Activity {
                 initMediaInfo(trackInfo);
                 displayModeImpl(); // init display mode //useless because it will reset when start playing, it should set after the moment playing
                 showCertification(); // show certification
+                startCertificationTimeout();
 
                 if (mResumePlay.getEnable() == true) {
                     mResumePlay.setEnable (false);
@@ -2864,6 +3036,16 @@ public class VideoPlayer extends Activity {
                 curtime = 0; // reset current time
                 curTimeTx.setText (secToTime (curtime / 1000));
                 progressBar.setProgress (0);
+                if (mBlurayVideoLang != null)
+                    mBlurayVideoLang.clear();
+                if (mBlurayAudioLang != null)
+                    mBlurayAudioLang.clear();
+                if (mBluraySubLang != null)
+                    mBluraySubLang.clear();
+                if (mBlurayChapter != null)
+                    mBlurayChapter.clear();
+                mIsBluray = false;
+                mSubIndex = 0;
                 if (mOption.getRepeatMode() == mOption.REPEATONE) {
                     playCur();
                 }
@@ -3056,6 +3238,59 @@ public class VideoPlayer extends Activity {
             }
         };*/
 
+        private MediaPlayerExt.OnBlurayListener mBlurayListener = new MediaPlayerExt.OnBlurayListener() {
+            @Override
+            public void onBlurayInfo(MediaPlayer mp, int arg1, int arg2, Object obj) {
+                LOGI (TAG, "[onBlurayInfo] mp: " + mp + ",arg1:" + arg1 + ",arg2:" + arg2);
+                if (mp == null)
+                    return;
+
+                if (arg1 == MediaInfo.MEDIA_INFO_AMLOGIC_BLURAY_STREAM_PATH) {
+                    if (obj instanceof Parcel) {
+                        Parcel parcel = (Parcel)obj;
+                        parcel.setDataPosition(0);
+                        String path = parcel.readString();
+                        int streamNum = parcel.readInt();
+                        mBlurayVideoLang.clear();
+                        mBlurayAudioLang.clear();
+                        mBluraySubLang.clear();
+                        for (int i = 0; i < streamNum; i++) {
+                            int type = parcel.readInt();
+                            String lang = parcel.readString();
+                            LOGI(TAG, "[onBlurayInfo]sub[" + i + "] type(" + type + ") lang: " + lang);
+                            switch (type) {
+                                case MediaInfo.BLURAY_STREAM_TYPE_VIDEO:
+                                    mBlurayVideoLang.add(lang);
+                                    break;
+                                case MediaInfo.BLURAY_STREAM_TYPE_AUDIO:
+                                    mBlurayAudioLang.add(lang);
+                                    break;
+                                case MediaInfo.BLURAY_STREAM_TYPE_SUB:
+                                    mBluraySubLang.add(lang);
+                                    break;
+                                default:
+                                    break;
+                            }
+                        }
+                        int chapterNum = parcel.readInt();
+                        mBlurayChapter.clear();
+                        for (int i = 0; i < chapterNum; i++) {
+                            int start = parcel.readInt();
+                            int duration = parcel.readInt();
+                            Log.d(TAG, "chapter[" + i + "]: start(" + start + ") duration(" + duration + ")");
+                            ChapterInfo info = new ChapterInfo();
+                            info.start = start;
+                            info.duration = duration;
+                            mBlurayChapter.add(info);
+                        }
+                        parcel.recycle();
+                        if (mSubtitleManager != null)
+                            mSubtitleManager.setSource(path);
+                    }
+                }
+            }
+        };
+
         //@@--------this part for book mark play-------------------------------------------------------------------
         private AlertDialog confirm_dialog = null;
         private int bmPos = 0; // book mark postion
@@ -3194,7 +3429,7 @@ public class VideoPlayer extends Activity {
         private static final int OSD_CTL_BAR = 0;
         private static final int OSD_OPT_BAR = 1;
         private int curOsdViewFlag = -1;
-        private final int OSD_FADE_TIME = 5000; // osd showing timeout
+        private final int FADE_TIME_5S = 5000; // osd showing timeout
 
         private final int RESUME_MODE = 0;
         private final int REPEAT_MODE = 1;
@@ -3207,6 +3442,7 @@ public class VideoPlayer extends Activity {
         private final int BRIGHTNESS = 8;
         private final int PLAY3D = 9;
         private final int VIDEO_TRACK = 10;
+        private final int CHAPTER_MODE = 11;
         private int otherwidgetStatus = 0;
 
         protected void startOsdTimeout() {
@@ -3234,7 +3470,7 @@ public class VideoPlayer extends Activity {
                 timer = new Timer();
             }
             if (timer != null) {
-                timer.schedule (task, OSD_FADE_TIME);
+                timer.schedule (task, FADE_TIME_5S);
             }
         }
 
@@ -3243,6 +3479,7 @@ public class VideoPlayer extends Activity {
                 timer.cancel();
             }
             timer = null;
+            stopCertificationTimeout();
         }
 
         private int getCurOsdViewFlag() {
@@ -3300,6 +3537,9 @@ public class VideoPlayer extends Activity {
         private void exitOtherWidget (ImageButton btn) {
             if ( (null != otherwidget) && (View.VISIBLE == otherwidget.getVisibility())) {
                 otherwidget.setVisibility (View.GONE);
+                if (mIsBluray && (mListViewHeight != ViewGroup.LayoutParams.WRAP_CONTENT)) {
+                    setListViewHeight(ViewGroup.LayoutParams.WRAP_CONTENT);
+                }
                 if ( (null != optbar) && (View.GONE == optbar.getVisibility())) {
                     optbar.setVisibility (View.VISIBLE);
                 }
@@ -3346,6 +3586,9 @@ public class VideoPlayer extends Activity {
                 }
                 if ( (null != otherwidget) && (View.VISIBLE == otherwidget.getVisibility())) {
                     otherwidget.setVisibility (View.GONE);
+                    if (mIsBluray && (mListViewHeight != ViewGroup.LayoutParams.WRAP_CONTENT)) {
+                        setListViewHeight(ViewGroup.LayoutParams.WRAP_CONTENT);
+                    }
                 }
                 if ( (null != infowidget) && (View.VISIBLE == infowidget.getVisibility())) {
                     infowidget.setVisibility (View.GONE);
@@ -3372,6 +3615,9 @@ public class VideoPlayer extends Activity {
                 }
                 if ( (null != otherwidget) && (View.VISIBLE == otherwidget.getVisibility())) {
                     otherwidget.setVisibility (View.GONE);
+                    if (mIsBluray && (mListViewHeight != ViewGroup.LayoutParams.WRAP_CONTENT)) {
+                        setListViewHeight(ViewGroup.LayoutParams.WRAP_CONTENT);
+                    }
                 }
                 if ( (null != infowidget) && (View.VISIBLE == infowidget.getVisibility())) {
                     infowidget.setVisibility (View.GONE);
@@ -3388,6 +3634,7 @@ public class VideoPlayer extends Activity {
 
         private void showNoOsdView() {
             stopOsdTimeout();
+            closeCertification();
             if ( (null != ctlbar) && (View.VISIBLE == ctlbar.getVisibility())) {
                 ctlbar.setVisibility (View.GONE);
             }
@@ -3399,6 +3646,9 @@ public class VideoPlayer extends Activity {
             }
             if ( (null != otherwidget) && (View.VISIBLE == otherwidget.getVisibility())) {
                 otherwidget.setVisibility (View.GONE);
+                if (mIsBluray && (mListViewHeight != ViewGroup.LayoutParams.WRAP_CONTENT)) {
+                    setListViewHeight(ViewGroup.LayoutParams.WRAP_CONTENT);
+                }
             }
             if ( (null != infowidget) && (View.VISIBLE == infowidget.getVisibility())) {
                 infowidget.setVisibility (View.GONE);
@@ -3416,6 +3666,7 @@ public class VideoPlayer extends Activity {
             if (null == optbar) {
                 return;
             }
+            showCertification();
             int flag = getCurOsdViewFlag();
             LOGI (TAG, "[showOsdView]flag:" + flag);
             switch (flag) {
@@ -3494,6 +3745,42 @@ public class VideoPlayer extends Activity {
         }
 
         //@@--------this part for showing certification of Dolby and DTS----------------------------------------------------
+        private Timer timerCertification = new Timer();
+        private static final int MSG_CERTIF_TIME_OUT = 0xe1;
+        protected void startCertificationTimeout() {
+            final Handler handler = new Handler() {
+                public void handleMessage (Message msg) {
+                    switch (msg.what) {
+                        case MSG_CERTIF_TIME_OUT:
+                            closeCertification();
+                            break;
+                    }
+                    super.handleMessage (msg);
+                }
+            };
+            TimerTask task = new TimerTask() {
+                public void run() {
+                    Message message = Message.obtain();
+                    message.what = MSG_CERTIF_TIME_OUT;
+                    handler.sendMessage (message);
+                }
+            };
+            stopCertificationTimeout();
+            if (timerCertification == null) {
+                timerCertification = new Timer();
+            }
+            if (timerCertification != null) {
+                timerCertification.schedule (task, FADE_TIME_5S);
+            }
+        }
+
+        private void stopCertificationTimeout() {
+            if (timerCertification != null) {
+                timerCertification.cancel();
+            }
+            timerCertification = null;
+        }
+
         private void showCertification() {
             if (certificationDoblyView == null && certificationDoblyPlusView == null && certificationDTSView == null && certificationDTSExpressView == null && certificationDTSHDMasterAudioView == null) {
                 return;
@@ -3722,6 +4009,10 @@ public class VideoPlayer extends Activity {
                                 subtitleSwitchBtn.requestFocusFromTouch();
                                 subtitleSwitchBtn.requestFocus();
                                 break;
+                            case R.string.setting_chapter:
+                                chapterBtn.requestFocusFromTouch();
+                                chapterBtn.requestFocus();
+                                break;
                             case R.string.setting_displaymode:
                                 displayModeBtn.requestFocusFromTouch();
                                 displayModeBtn.requestFocus();
@@ -4025,12 +4316,136 @@ public class VideoPlayer extends Activity {
                 LOGI(TAG,"[sendSubOptionUpdateMsg]sendMessageDelayed MSG_SUB_OPTION_UPDATE");
             }
         }
+
+        private int getLanguageIndex(int type, String lang) {
+            int index = -1;
+
+            switch (type) {
+                case MediaInfo.BLURAY_STREAM_TYPE_VIDEO:
+                    index = mBlurayVideoLang.indexOf(lang);
+                    break;
+                case MediaInfo.BLURAY_STREAM_TYPE_AUDIO:
+                    index = mBlurayAudioLang.indexOf(lang);
+                    break;
+                case MediaInfo.BLURAY_STREAM_TYPE_SUB:
+                    index = mBluraySubLang.indexOf(lang);
+                    if (index == -1)
+                        index = mBluraySubLang.indexOf("eng");
+                    break;
+                default:
+                    break;
+            }
+
+            return index;
+        }
+
+        private String getDisplayLanguage(String lang) {
+            if (TextUtils.isEmpty(lang))
+                return null;
+
+            for (LocalePicker.LocaleInfo info : LOCALES) {
+                Locale l = info.getLocale();
+                if (lang.equals(l.getISO3Language()))
+                    return l.getDisplayLanguage();
+            }
+
+            return null;
+        }
+
+        private String getLanguageInfoDisplayString(int type, int index) {
+            LOGI(TAG, "getLanguageInfoDisplayString, type:" + type  + " index:" + index);
+            String str = "";
+            switch (type) {
+                case MediaInfo.BLURAY_STREAM_TYPE_VIDEO: {
+                    break;
+                }
+                case MediaInfo.BLURAY_STREAM_TYPE_AUDIO: {
+                    if (index + 1 < 10)
+                        str += "0" + String.valueOf(index + 1) + "/";
+                    else
+                        str += String.valueOf(index + 1) + "/";
+                    int total = mMediaInfo.getAudioTotalNum();
+                    if (total < 10)
+                        str += "0" + String.valueOf(total) + " ";
+                    else
+                        str += String.valueOf(total) + " ";
+                    str += getDisplayLanguage(mBlurayAudioLang.get(index)) + " ";
+                    str += mMediaInfo.getAudioFormatStr(mMediaInfo.getAudioFormat(index)) + " ";
+                    // TODO: audio channel
+                    str += String.valueOf(mMediaInfo.getAudioSampleRate(index)) + "Hz";
+                    break;
+                }
+                 case MediaInfo.BLURAY_STREAM_TYPE_SUB: {
+                    str += mContext.getResources().getString(R.string.setting_subtitle) + ": ";
+                    String subType = mSubtitleManager.getSubTypeStr();
+                    if (subType.equals("INSUB")) {
+                        str += mContext.getResources().getString(R.string.subtitle_insub) + " ";
+                        int typeDetail = mSubtitleManager.getSubTypeDetial();
+                        switch (typeDetail) {
+                            case SUBTITLE_PGS:
+                                str += "PGS ";
+                                break;
+                            case SUBTITLE_DVB:
+                                str += "DVB ";
+                                break;
+                            case SUBTITLE_TMD_TXT:
+                                str += "TMD TXT ";
+                                break;
+                            default:
+                                break;
+                        }
+                    } else
+                        str += subType;
+                    str += getDisplayLanguage(mBluraySubLang.get(index));
+                    break;
+                }
+                default:
+                    break;
+            }
+            LOGI(TAG, "getLanguageInfoDisplayString, str:" + str);
+            return str;
+        }
+
+        private int getChapterIndex(int current) {
+            int count = mBlurayChapter.size();
+            int index;
+            for (index = 0; index < count; index++) {
+                if (current < mBlurayChapter.get(index).start) {
+                    return index - 1;
+                }
+            }
+            if (index == count) {
+                index--;
+                return index;
+            }
+
+            return -1;
+        }
+
+        private String getChapterInfoDisplayString(int index) {
+            String str = "";
+            if (index + 1 < 10)
+                str += "0" + String.valueOf(index + 1) + "/";
+            else
+                str += String.valueOf(index + 1) + "/";
+            int total = mBlurayChapter.size();
+            if (total < 10)
+                str += "0" + String.valueOf(total) + "    ";
+            else
+                str += String.valueOf(total) + "    ";
+            ChapterInfo info = mBlurayChapter.get(index);
+            str += secToTime(info.start) + " - ";
+            str += secToTime(info.start + info.duration);
+
+            return str;
+        }
+
         private void initSubtitle() {
             LOGI (TAG, "[initSubtitle]");
             SharedPreferences subSp = getSharedPreferences (subSettingStr, 0);
             sub_para = new subview_set();
             sub_para.totalnum = 0;
-            sub_para.curid = 0;
+            sub_para.curid = mSubIndex;
             sub_para.curidbac = 0;
             sub_para.color = android.graphics.Color.WHITE;
             sub_para.font = 20;
@@ -4097,6 +4512,7 @@ public class VideoPlayer extends Activity {
             ok.setOnClickListener (new View.OnClickListener() {
                 public void onClick (View v) {
                     sub_para.curid = sub_switch_state;
+                    mSubIndex = sub_switch_state;
                     sub_para.font = sub_font_state;
                     sub_para.position_v = sub_position_v_state;
                     LOGI (TAG, "[subtitle_control]sub_para.curid:" + sub_para.curid + ",sub_para.curidbac:" + sub_para.curidbac);
@@ -4158,7 +4574,6 @@ public class VideoPlayer extends Activity {
                     editor.putInt ("font", sub_para.font);
                     editor.putInt ("position_v", sub_para.position_v);
                     editor.commit();
-                    sendSubOptionUpdateMsg();
                     setSubtitleView();
                     if (isTimedTextDisable()) {
                         //still have error with new method
@@ -4169,18 +4584,16 @@ public class VideoPlayer extends Activity {
                             initSubSetOptions(color_text);
                         }*/
                         String subNameStr = mSubtitleManager.getCurName();
-                        if (subNameStr != null) {
-                            if (subNameStr.equals ("INSUB") || subNameStr.endsWith (".idx")) {
-                                disableSubSetOptions();
-                            }
-                            else {
-                                initSubSetOptions (color_text);
-                            }
+                        if (subNameStr != null && (subNameStr.equals ("INSUB") || subNameStr.endsWith (".idx"))) {
+                            disableSubSetOptions();
                         }
                         else {
                             initSubSetOptions (color_text);
                         }
                     }
+                    else {
+                        sendSubOptionUpdateMsg();
+                    }
                     exitSubWidget (subtitleSwitchBtn);
                 }
             });
@@ -4200,9 +4613,15 @@ public class VideoPlayer extends Activity {
                     }
                     if (sub_switch_state == sub_para.totalnum) {
                         t_subswitch.setText (R.string.str_off);
+                        t_subinfo.setVisibility(View.GONE);
                     }
                     else {
                         t_subswitch.setText (String.valueOf (sub_switch_state + 1) + "/" + String.valueOf (sub_para.totalnum));
+                        if (mIsBluray) {
+                            if (t_subinfo.getVisibility() == View.GONE)
+                                t_subinfo.setVisibility(View.VISIBLE);
+                            t_subinfo.setText(getLanguageInfoDisplayString(MediaInfo.BLURAY_STREAM_TYPE_SUB, sub_switch_state));
+                        }
                     }
                 }
             });
@@ -4216,10 +4635,16 @@ public class VideoPlayer extends Activity {
                     }
                     if (sub_switch_state == sub_para.totalnum) {
                         t_subswitch.setText (R.string.str_off);
+                        t_subinfo.setVisibility(View.GONE);
                     }
                     else {
                         t_subswitch.setText (String.valueOf (sub_switch_state + 1) + "/" + String.valueOf (sub_para.totalnum));
-                    };
+                        if (mIsBluray) {
+                            if (t_subinfo.getVisibility() == View.GONE)
+                                t_subinfo.setVisibility(View.VISIBLE);
+                            t_subinfo.setText(getLanguageInfoDisplayString(MediaInfo.BLURAY_STREAM_TYPE_SUB, sub_switch_state));
+                        }
+                    }
                 }
             });
             Bfont_l.setOnClickListener (new View.OnClickListener() {
@@ -4289,7 +4714,6 @@ public class VideoPlayer extends Activity {
                 }
             });
 
-            sendSubOptionUpdateMsg();
             if (isTimedTextDisable()) {
                 //still have error with new method
                 /*if(mMediaPlayer.subtitleGetSubType() == 1) { //bitmap
@@ -4299,22 +4723,21 @@ public class VideoPlayer extends Activity {
                     initSubSetOptions(color_text);
                 }*/
                 String subNameStr = mSubtitleManager.getCurName();
-                if (subNameStr != null) {
-                    if (subNameStr.equals ("INSUB") || subNameStr.endsWith (".idx")) {
-                        disableSubSetOptions();
-                    }
-                    else {
-                        initSubSetOptions (color_text);
-                    }
+                if (subNameStr != null && (subNameStr.equals ("INSUB") || subNameStr.endsWith (".idx"))) {
+                    disableSubSetOptions();
                 }
                 else {
                     initSubSetOptions (color_text);
                 }
             }
+            else {
+                sendSubOptionUpdateMsg();
+            }
         }
 
         private void initSubSetOptions (String color_text[]) {
             t_subswitch = (TextView) findViewById (R.id.sub_swith111);
+            t_subinfo = (TextView) findViewById (R.id.sub_info);
             t_subsfont = (TextView) findViewById (R.id.sub_font111);
             t_subscolor = (TextView) findViewById (R.id.sub_color111);
             t_subsposition_v = (TextView) findViewById (R.id.sub_position_v111);
@@ -4332,10 +4755,18 @@ public class VideoPlayer extends Activity {
             }
             if (sub_para.curid == sub_para.totalnum) {
                 sub_para.curid = sub_para.totalnum;
+                mSubIndex = sub_para.totalnum;
                 t_subswitch.setText (R.string.str_off);
+                t_subinfo.setVisibility(View.GONE);
             }
             else {
                 t_subswitch.setText (String.valueOf (sub_para.curid + 1) + "/" + String.valueOf (sub_para.totalnum));
+                if (mIsBluray) {
+                    if (t_subinfo.getVisibility() == View.GONE)
+                        t_subinfo.setVisibility(View.VISIBLE);
+                    if (mSubIndex != -1)
+                        t_subinfo.setText(getLanguageInfoDisplayString(MediaInfo.BLURAY_STREAM_TYPE_SUB, mSubIndex));
+                }
             }
             t_subsfont.setText (String.valueOf (sub_font_state));
             t_subscolor.setText (color_text[sub_color_state]);
@@ -4496,6 +4927,14 @@ public class VideoPlayer extends Activity {
             );
         }
 
+        /*private SimpleAdapter getLeftAlignMorebarListAdapter (int id, int pos) {
+            return new SimpleAdapter (this, getMorebarListData (id, pos),
+                                      R.layout.list_row,
+                                      new String[] {"item_img", "item_name", "item_sel"},
+                                      new int[] {R.id.item_img, R.id.Text01, R.id.item_sel}
+                                     );
+        }*/
+
         private List <? extends Map < String, ? >> getMorebarListData (int id, int pos) {
             // TODO Auto-generated method stub
             List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
@@ -4559,17 +4998,20 @@ public class VideoPlayer extends Activity {
                 case AUDIO_TRACK:
                     if (mMediaInfo != null) {
                         int audio_total_num = mMediaInfo.getAudioTotalNum();
+                        LOGI(TAG, "audio_total_num:" + audio_total_num);
                         for (int i = 0; i < audio_total_num; i++) {
                             map = new HashMap<String, Object>();
-                            map.put ("item_name", mMediaInfo.getAudioFormatStr (mMediaInfo.getAudioFormat (i)));
+                            LOGI(TAG, "i:" + i + " mMediaInfo.getAudioFormat:" + mMediaInfo.getAudioFormat(i));
+                            if (mIsBluray)
+                                map.put ("item_name", getLanguageInfoDisplayString(MediaInfo.BLURAY_STREAM_TYPE_AUDIO, i));
+                            else
+                                map.put ("item_name", mMediaInfo.getAudioFormatStr(mMediaInfo.getAudioFormat(i)));
                             map.put ("item_sel", R.drawable.item_img_unsel);
-                            if (mMediaInfo.getAudioFormat(i) == mMediaInfo.AFORMAT_AC3) {
-                                map.put ("item_name", null);
-                                map.put ("item_img", R.drawable.certifi_dobly);
-                            }
-                            else if (mMediaInfo.getAudioFormat(i) == mMediaInfo.AFORMAT_EAC3) {
-                                map.put ("item_name", null);
-                                map.put ("item_img", R.drawable.certifi_dobly_plus);
+                            if (mMediaInfo.getAudioFormat(i) == mMediaInfo.AFORMAT_AC3 || mMediaInfo.getAudioFormat(i) == mMediaInfo.AFORMAT_EAC3) {
+                                if (!mIsBluray) {
+                                    map.put ("item_name", null);
+                                }
+                                map.put ("item_img", R.drawable.certifi_dobly_black);
                             }
                             list.add (map);
                         }
@@ -4580,6 +5022,19 @@ public class VideoPlayer extends Activity {
                         list.get (pos).put ("item_sel", R.drawable.item_img_sel);
                     }
                     break;
+                 case CHAPTER_MODE: {
+                    int count = mBlurayChapter.size();
+                    for (int i = 0; i < count; i++) {
+                        map = new HashMap<String, Object>();
+                        map.put("item_name", getChapterInfoDisplayString(i));
+                        map.put("item_sel", R.drawable.item_img_unsel);
+                        list.add(map);
+                    }
+                    int index = getChapterIndex(getCurrentPosition() / 1000);
+                    if (index >= 0 && index < count)
+                        list.get(index).put("item_sel", R.drawable.item_img_sel);
+                    break;
+                }
 
                 case VIDEO_TRACK:
                     if (mMediaInfo != null) {
@@ -4650,6 +5105,10 @@ public class VideoPlayer extends Activity {
                     map.put ("item_name", "16:9");
                     map.put ("item_sel", R.drawable.item_img_unsel);
                     list.add (map);
+                    map = new HashMap<String, Object>();
+                    map.put ("item_name", getString (R.string.setting_displaymode_original));
+                    map.put ("item_sel", R.drawable.item_img_unsel);
+                    list.add (map);
                     // TODO: 3D
                     /*
                     if (mSystemControl.getPropertyBoolean("3D_setting.enable", false)) {
@@ -4715,6 +5174,7 @@ class Option {
         public static final int DISP_MODE_FULLSTRETCH = 1;
         public static final int DISP_MODE_RATIO4_3 = 2;
         public static final int DISP_MODE_RATIO16_9 = 3;
+        public static final int DISP_MODE_ORIGINAL = 4;
         private String RESUME_MODE = "ResumeMode";
         private String REPEAT_MODE = "RepeatMode";
         private String AUDIO_TRACK = "AudioTrack";
@@ -5016,3 +5476,8 @@ class subview_set {
         public int position_v;
 }
 
+class ChapterInfo {
+    public int start;
+    public int duration;
+}
+
diff --git a/amlogic/dvb/android/ndk/include/linux/amdsc.h b/amlogic/dvb/android/ndk/include/linux/amdsc.h
index 4be8d98..760fbe4 100755
--- a/amlogic/dvb/android/ndk/include/linux/amdsc.h
+++ b/amlogic/dvb/android/ndk/include/linux/amdsc.h
@@ -1,40 +1,26 @@
-/*
- * AMLOGIC descrambler driver.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- */
-
 #ifndef _AMDSC_H
 #define _AMDSC_H
 
-#include <asm/types.h>
-
-typedef enum {
-	AM_DSC_EVEN_KEY,
-	AM_DSC_ODD_KEY
-} am_dsc_key_type_t;
+#include <linux/types.h>
 
+enum am_dsc_key_type_t {
+	AM_DSC_EVEN_KEY = 0,
+	AM_DSC_ODD_KEY = 1,
+	AM_DSC_EVEN_KEY_AES = 2,
+	AM_DSC_ODD_KEY_AES = 3,
+	AM_DSC_EVEN_KEY_AES_IV = 4,
+	AM_DSC_ODD_KEY_AES_IV = 5,
+	AM_DSC_FROM_KL_KEY = (1<<7)
+};
 struct am_dsc_key {
-	am_dsc_key_type_t    type;
-	__u8                 key[8];
+	enum am_dsc_key_type_t    type;
+	__u8                 key[16];
 };
 
 #define AMDSC_IOC_MAGIC  'D'
 
 #define AMDSC_IOC_SET_PID      _IO(AMDSC_IOC_MAGIC, 0x00)
-#define AMDSC_IOC_SET_KEY      _IOW(AMDSC_IOC_MAGIC, 0x01, struct am_dsc_key)
+#define AMDSC_IOC_SET_KEY      _IOW(AMDSC_IOC_MAGIC, 0x01, int)
 
 #endif
 
diff --git a/amlogic/dvb/include/am_adp/am_av.h b/amlogic/dvb/include/am_adp/am_av.h
index a29ce48..5d12dca 100755
--- a/amlogic/dvb/include/am_adp/am_av.h
+++ b/amlogic/dvb/include/am_adp/am_av.h
@@ -86,6 +86,7 @@ enum AM_AV_EventType
 	AM_AV_EVT_AUDIO_AC3_NO_LICENCE,
 	AM_AV_EVT_AUDIO_AC3_LICENCE_RESUME,
 	AM_AV_EVT_VIDEO_NOT_SUPPORT,
+	AM_AV_EVT_VIDEO_AVAILABLE,
 	AM_AV_EVT_END
 };
 
diff --git a/amlogic/dvb/include/am_adp/am_dsc.h b/amlogic/dvb/include/am_adp/am_dsc.h
index d624ef6..8db30b4 100755
--- a/amlogic/dvb/include/am_adp/am_dsc.h
+++ b/amlogic/dvb/include/am_adp/am_dsc.h
@@ -55,8 +55,13 @@ typedef struct
 
 /**\brief 控制字类型*/
 typedef enum {
-        AM_DSC_KEY_TYPE_EVEN,   /**< 偶控制字*/
-        AM_DSC_KEY_TYPE_ODD     /**< 奇控制字*/
+        AM_DSC_KEY_TYPE_EVEN = 0,   /**< 偶控制字*/
+        AM_DSC_KEY_TYPE_ODD = 1,     /**< 奇控制字*/
+		AM_DSC_KEY_TYPE_AES_EVEN = 2,
+		AM_DSC_KEY_TYPE_AES_ODD = 3,
+		AM_DSC_KEY_TYPE_AES_IV_EVEN = 4,
+		AM_DSC_KEY_TYPE_AES_IV_ODD = 5,
+		AM_DSC_KEY_FROM_KL = (1<<7)
 } AM_DSC_KeyType_t;
 
 /**\brief 解扰器输入源*/
diff --git a/amlogic/dvb/include/am_mw/atsc/atsc_types.h b/amlogic/dvb/include/am_mw/atsc/atsc_types.h
index fc55b55..2f0b701 100644
--- a/amlogic/dvb/include/am_mw/atsc/atsc_types.h
+++ b/amlogic/dvb/include/am_mw/atsc/atsc_types.h
@@ -18,6 +18,7 @@ extern "C"
 *****************************************************************************/
 typedef int8_t		INT8S;
 typedef uint8_t		INT8U;
+typedef int16_t	    INT16S;
 typedef uint16_t	INT16U;
 typedef int32_t		INT32S;
 typedef uint32_t	INT32U;
diff --git a/amlogic/frameworks/av/AmFFmpegAdapter/Android.mk b/amlogic/frameworks/av/AmFFmpegAdapter/Android.mk
index f8f18d5..be5f290 100755
--- a/amlogic/frameworks/av/AmFFmpegAdapter/Android.mk
+++ b/amlogic/frameworks/av/AmFFmpegAdapter/Android.mk
@@ -30,6 +30,7 @@ LOCAL_C_INCLUDES:= \
     $(LOCAL_PATH)/include
 
 LOCAL_SHARED_LIBRARIES := \
+    libbinder \
     libcutils \
     libamffmpeg \
     libmedia \
diff --git a/amlogic/frameworks/av/AmFFmpegAdapter/codec/AmVideoCodec.cpp b/amlogic/frameworks/av/AmFFmpegAdapter/codec/AmVideoCodec.cpp
index ece0579..92af6c3 100644
--- a/amlogic/frameworks/av/AmFFmpegAdapter/codec/AmVideoCodec.cpp
+++ b/amlogic/frameworks/av/AmFFmpegAdapter/codec/AmVideoCodec.cpp
@@ -19,7 +19,8 @@
 //#define LOG_NDEBUG 0
 #define LOG_TAG "AmVideoCodec"
 #include <utils/Log.h>
-
+#include <binder/IPCThreadState.h>
+#include <fcntl.h>
 #include "codec/AmVideoCodec.h"
 #include "AmFFmpegUtils.h"
 
@@ -79,6 +80,22 @@ int32_t AmVideoCodec::video_decode_init(const char * codecMime, VIDEO_INFO_T *vi
     }
 
     int32_t thread_num = GetCPUCoreCount();
+
+    if (id == AV_CODEC_ID_VP8) {
+        char callProcess[64];
+        memset(callProcess, 0x0, sizeof(callProcess));
+        sprintf(callProcess,"/proc/%d/cmdline", IPCThreadState::self()->getCallingPid());
+        int fd = open(callProcess, O_RDONLY);
+            if (fd > 0) {
+                read(fd, callProcess, 64);
+                close(fd);
+            }
+            // ALOGD("callProcess:%s\n", callProcess);
+
+            if (!strcmp(callProcess,"com.google.android.xts.media")) {
+                thread_num = 1;
+            }
+    }
     ALOGI("decoder thread num : %d\n", thread_num);
     if (mCodec->capabilities & CODEC_CAP_FRAME_THREADS) {
         av_opt_set(mctx, "thread_type", "frame", 0);
diff --git a/amlogic/frameworks/av/Extractors/ADTSExtractor.cpp b/amlogic/frameworks/av/Extractors/ADTSExtractor.cpp
index 6b4feee..521c717 100644
--- a/amlogic/frameworks/av/Extractors/ADTSExtractor.cpp
+++ b/amlogic/frameworks/av/Extractors/ADTSExtractor.cpp
@@ -28,14 +28,15 @@
 #include <media/stagefright/MetaData.h>
 #include <utils/String8.h>
 
-namespace android {
+namespace android
+{
 
 struct ADTSSource : public MediaSource {
 public:
     ADTSSource(const sp<DataSource> &source,
-              const sp<MetaData> &meta,
-              const Vector<uint64_t> &offset_vector,
-              int64_t frame_duration_us);
+               const sp<MetaData> &meta,
+               const Vector<uint64_t> &offset_vector,
+               int64_t frame_duration_us);
 
     virtual status_t start(MetaData *params = NULL);
     virtual status_t stop();
@@ -43,7 +44,7 @@ public:
     virtual sp<MetaData> getFormat();
 
     virtual status_t read(
-            MediaBuffer **buffer, const ReadOptions *options = NULL);
+        MediaBuffer **buffer, const ReadOptions *options = NULL);
 
 protected:
     virtual ~ADTSSource();
@@ -57,7 +58,7 @@ private:
     int64_t mCurrentTimeUs;
     bool mStarted;
     MediaBufferGroup *mGroup;
-	
+
     Vector<uint64_t> mOffsetVector;
     int64_t mFrameDurationUs;
 
@@ -70,8 +71,7 @@ private:
 // Returns the sample rate based on the sampling frequency index
 uint32_t get_adts_samplerate(const uint8_t sf_index)
 {
-    static const uint32_t sample_rates[] =
-    {
+    static const uint32_t sample_rates[] = {
         96000, 88200, 64000, 48000, 44100, 32000,
         24000, 22050, 16000, 12000, 11025, 8000
     };
@@ -83,7 +83,8 @@ uint32_t get_adts_samplerate(const uint8_t sf_index)
     return 0;
 }
 
-static size_t get_Adts_FrameLength(const sp<DataSource> &source, off64_t offset, size_t* headerSize) {
+static size_t get_Adts_FrameLength(const sp<DataSource> &source, off64_t offset, size_t* headerSize)
+{
 
     const size_t kAdtsHeaderLengthNoCrc = 7;
     const size_t kAdtsHeaderLengthWithCrc = 9;
@@ -125,7 +126,8 @@ static size_t get_Adts_FrameLength(const sp<DataSource> &source, off64_t offset,
 ADTSExtractor::ADTSExtractor(const sp<DataSource> &source)
     : mDataSource(source),
       mInitCheck(NO_INIT),
-      mFrameDurationUs(0) {
+      mFrameDurationUs(0)
+{
     String8 mimeType;
     float confidence;
     if (!SniffADTS(mDataSource, &mimeType, &confidence, NULL)) {
@@ -146,19 +148,19 @@ ADTSExtractor::ADTSExtractor(const sp<DataSource> &source)
     channel = (header[0] & 0x1) << 2 | (header[1] >> 6);
 
     mMeta = new MetaData;//MakeAACCodecSpecificData(profile, sf_index, channel);
-	mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_ADTS_PROFILE);
-	mMeta->setInt32(kKeySampleRate, sr);
+    mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_ADTS_PROFILE);
+    mMeta->setInt32(kKeySampleRate, sr);
     mMeta->setInt32(kKeyChannelCount, channel);
-	
+
     off64_t offset = 0;
     off64_t streamSize, numFrames = 0;
     size_t frameSize = 0;
     int64_t duration = 0;
 
     if (mDataSource->getSize(&streamSize) == OK) {
-         while (offset < streamSize) {
+        while (offset < streamSize) {
             if ((frameSize = get_Adts_FrameLength(source, offset, NULL)) == 0) {
-                	break;
+                break;
             }
 
             mOffsetVector.push(offset);
@@ -176,10 +178,12 @@ ADTSExtractor::ADTSExtractor(const sp<DataSource> &source)
     mInitCheck = OK;
 }
 
-ADTSExtractor::~ADTSExtractor() {
+ADTSExtractor::~ADTSExtractor()
+{
 }
 
-sp<MetaData> ADTSExtractor::getMetaData() {
+sp<MetaData> ADTSExtractor::getMetaData()
+{
     sp<MetaData> meta = new MetaData;
 
     if (mInitCheck != OK) {
@@ -191,11 +195,13 @@ sp<MetaData> ADTSExtractor::getMetaData() {
     return meta;
 }
 
-size_t ADTSExtractor::countTracks() {
+size_t ADTSExtractor::countTracks()
+{
     return mInitCheck == OK ? 1 : 0;
 }
 
-sp<MediaSource> ADTSExtractor::getTrack(size_t index) {
+sp<MediaSource> ADTSExtractor::getTrack(size_t index)
+{
     if (mInitCheck != OK || index > 0) {
         return NULL;
     }
@@ -203,7 +209,8 @@ sp<MediaSource> ADTSExtractor::getTrack(size_t index) {
     return new ADTSSource(mDataSource, mMeta, mOffsetVector, mFrameDurationUs);
 }
 
-sp<MetaData> ADTSExtractor::getTrackMetaData(size_t index, uint32_t flags) {
+sp<MetaData> ADTSExtractor::getTrackMetaData(size_t index, uint32_t flags)
+{
     if (mInitCheck != OK || index > 0) {
         return NULL;
     }
@@ -217,9 +224,9 @@ sp<MetaData> ADTSExtractor::getTrackMetaData(size_t index, uint32_t flags) {
 const size_t ADTSSource::kMaxFrameSize = 8192;
 
 ADTSSource::ADTSSource(
-        const sp<DataSource> &source, const sp<MetaData> &meta,
-        const Vector<uint64_t> &offset_vector,
-        int64_t frame_duration_us)
+    const sp<DataSource> &source, const sp<MetaData> &meta,
+    const Vector<uint64_t> &offset_vector,
+    int64_t frame_duration_us)
     : mDataSource(source),
       mMeta(meta),
       mOffset(0),
@@ -227,16 +234,19 @@ ADTSSource::ADTSSource(
       mStarted(false),
       mGroup(NULL),
       mOffsetVector(offset_vector),
-      mFrameDurationUs(frame_duration_us) {
+      mFrameDurationUs(frame_duration_us)
+{
 }
 
-ADTSSource::~ADTSSource() {
+ADTSSource::~ADTSSource()
+{
     if (mStarted) {
         stop();
     }
 }
 
-status_t ADTSSource::start(MetaData *params) {
+status_t ADTSSource::start(MetaData *params)
+{
     CHECK(!mStarted);
 
     mOffset = 0;
@@ -248,7 +258,8 @@ status_t ADTSSource::start(MetaData *params) {
     return OK;
 }
 
-status_t ADTSSource::stop() {
+status_t ADTSSource::stop()
+{
     CHECK(mStarted);
 
     delete mGroup;
@@ -258,12 +269,14 @@ status_t ADTSSource::stop() {
     return OK;
 }
 
-sp<MetaData> ADTSSource::getFormat() {
+sp<MetaData> ADTSSource::getFormat()
+{
     return mMeta;
 }
 
 status_t ADTSSource::read(
-        MediaBuffer **out, const ReadOptions *options) {
+    MediaBuffer **out, const ReadOptions *options)
+{
     *out = NULL;
 
     int64_t seekTimeUs;
@@ -290,7 +303,7 @@ status_t ADTSSource::read(
 
     frameSizeWithoutHeader = frameSize;// - headerSize;
     if (mDataSource->readAt(mOffset /*+ headerSize*/, buffer->data(),
-                frameSizeWithoutHeader) != (ssize_t)frameSizeWithoutHeader) {
+                            frameSizeWithoutHeader) != (ssize_t)frameSizeWithoutHeader) {
         buffer->release();
         buffer = NULL;
 
@@ -311,28 +324,34 @@ status_t ADTSSource::read(
 ////////////////////////////////////////////////////////////////////////////////
 
 bool SniffADTS(
-        const sp<DataSource> &source, String8 *mimeType, float *confidence,
-        sp<AMessage> *) {
-       
+    const sp<DataSource> &source, String8 *mimeType, float *confidence,
+    sp<AMessage> *)
+{
+
     uint8_t header[4];
-	
+
     if (source->readAt(0, &header, 4) != 4) {
         return false;
     }
 
     // ADTS syncword
     if ((header[0] == 0xff) && ((header[1] & 0xf6) == 0xf0)) {
-		uint8_t channel = (header[2] & 0x1) << 2 | (header[3] >> 6);
-		if(channel <= 2){
-			if(((header[2] >> 6) & 0x3) == 1){
-				ALOGI("adts:yes LC\n");
-				return false;
-			} 
-		}
-		ALOGI("profile=%d\n", (header[2] >> 6) & 0x3);
-		ALOGI("adts:yes, channel:%d\n",channel);
+        //android aac decoder has some profile support limit,
+        //we limit some profile goes to our faad decode,use libfaad.
+        //AAC LC/HE-AAC V1/V2/ELD goes to google aac decoder. others goes to libfaad
+        uint8_t channel = (header[2] & 0x1) << 2 | (header[3] >> 6);
+        int profile = (header[2] >> 6) & 0x3;
+        if (channel <= 2) {
+            //LC,HE-AAC,LD
+            if (profile  == 1 || profile == 4 || profile == 22) {
+                ALOGI("profile %d goes google aac decoder\n", profile);
+                return false;
+            }
+        }
+        ALOGI("profile=%d,use libfaad\n", (header[2] >> 6) & 0x3);
+        ALOGI("adts:yes, channel:%d\n", channel);
         *mimeType = MEDIA_MIMETYPE_AUDIO_ADTS_PROFILE;
-        *confidence = 0.2;
+        *confidence = 0.3;
         return true;
     }
 
diff --git a/amlogic/frameworks/av/Extractors/DtshdExtractor.cpp b/amlogic/frameworks/av/Extractors/DtshdExtractor.cpp
index 2e6546f..c3c6c18 100644
--- a/amlogic/frameworks/av/Extractors/DtshdExtractor.cpp
+++ b/amlogic/frameworks/av/Extractors/DtshdExtractor.cpp
@@ -733,6 +733,8 @@ int Dcahd_probe( unsigned char *buf,int size)
    int i32Index=0;
    int result=0;
    unsigned int ui32Sync_word=0,ui32Sync_word2=0;
+   int first_sync_Detected=0,first_sync_pos=-1;
+   unsigned int ui32Sword0_save=0;
    for (i32Index=0; i32Index+7<size;i32Index++)
    {
         ui32Sync_word    = buf[i32Index];      ui32Sync_word <<= 8;
@@ -746,9 +748,19 @@ int Dcahd_probe( unsigned char *buf,int size)
         ui32Sync_word2  |= buf[i32Index + 7];
         result=AmlDcaDmuxMatchDTSSync2(ui32Sync_word,ui32Sync_word2);
         if (result) {
-            ALOGI("SyncWord detect: ui32Sync_word/0x%x ui32Sync_word2/0x%x ",ui32Sync_word,ui32Sync_word2);
-            break;
-        }
+            //ALOGI("SyncWord detect: ui32Sync_word/0x%x ui32Sync_word2/0x%x ",ui32Sync_word,ui32Sync_word2);
+            if (first_sync_Detected == 0){
+                first_sync_Detected=1;
+                first_sync_pos=i32Index;
+                ui32Sword0_save=ui32Sync_word;
+                ALOGI("dts first_sync_pos/%d ",first_sync_pos);
+            }else if(first_sync_Detected == 1){
+                if (ui32Sword0_save == ui32Sync_word){
+                   ALOGI("DTS Frame detected");
+                   break;
+                }
+            }
+         }
     }
 
     return result;
@@ -765,7 +777,7 @@ bool SniffDcahd(const sp<DataSource> &source, String8 *mimeType, float *confiden
     if (Dcahd_probe(tmp,i32BytesToRead)>0)
     {
         mimeType->setTo(MEDIA_MIMETYPE_AUDIO_DTSHD);
-        *confidence = 0.19f;
+        *confidence = 0.31f;
         return true;
     } else {
         return false;
diff --git a/amlogic/frameworks/av/LibMetadateRetriever/AmlPlayerMetadataRetriever.cpp b/amlogic/frameworks/av/LibMetadateRetriever/AmlPlayerMetadataRetriever.cpp
index f4dfc52..745f670 100644
--- a/amlogic/frameworks/av/LibMetadateRetriever/AmlPlayerMetadataRetriever.cpp
+++ b/amlogic/frameworks/av/LibMetadateRetriever/AmlPlayerMetadataRetriever.cpp
@@ -245,7 +245,7 @@ MediaAlbumArt *AmlPlayerMetadataRetriever::extractAlbumArt()
     }
 
     if (mAlbumArt) {
-        return new MediaAlbumArt(*mAlbumArt);
+        return mAlbumArt;
     }
 
     return NULL;
diff --git a/amlogic/frameworks/av/LibPlayer/amadec/Android.mk b/amlogic/frameworks/av/LibPlayer/amadec/Android.mk
index 20aa67c..bf466e9 100755
--- a/amlogic/frameworks/av/LibPlayer/amadec/Android.mk
+++ b/amlogic/frameworks/av/LibPlayer/amadec/Android.mk
@@ -197,7 +197,7 @@ else
         LOCAL_CFLAGS += -D_VERSION_ICS
     endif
 endif		
-		
+LOCAL_CFLAGS += -DANDROID_PLATFORM_SDK_VERSION=$(PLATFORM_SDK_VERSION)		
 LOCAL_C_INCLUDES:= \
     external/tinyalsa/include
 
diff --git a/amlogic/frameworks/av/LibPlayer/amadec/adec-ffmpeg-mgt.c b/amlogic/frameworks/av/LibPlayer/amadec/adec-ffmpeg-mgt.c
index ce94723..968fa79 100644
--- a/amlogic/frameworks/av/LibPlayer/amadec/adec-ffmpeg-mgt.c
+++ b/amlogic/frameworks/av/LibPlayer/amadec/adec-ffmpeg-mgt.c
@@ -444,7 +444,7 @@ static int OutBufferInit_raw(aml_audio_dec_t *audec)
     if (audec->adec_ops->nOutBufSize <= 0) { //set default if not set
         audec->adec_ops->nOutBufSize = DEFAULT_PCM_BUFFER_SIZE;
     }
-    if (audec->format == ACODEC_FMT_DTS && amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw") == 2) {
+    if ((audec->format == ACODEC_FMT_DTS || audec->format == ACODEC_FMT_TRUEHD) && amsysfs_get_sysfs_int("/sys/class/audiodsp/digital_raw") == 2) {
         audec->adec_ops->nOutBufSize *= 2;
     }
     int ret = init_buff(audec->g_bst_raw, audec->adec_ops->nOutBufSize);
diff --git a/amlogic/frameworks/av/LibPlayer/amadec/adec-wfd-out.cpp b/amlogic/frameworks/av/LibPlayer/amadec/adec-wfd-out.cpp
index 9fea253..e184560 100755
--- a/amlogic/frameworks/av/LibPlayer/amadec/adec-wfd-out.cpp
+++ b/amlogic/frameworks/av/LibPlayer/amadec/adec-wfd-out.cpp
@@ -80,7 +80,13 @@ static float get_android_stream_volume()
     unsigned int sr = 0;
 #else
     int sr = 0;
-#endif 
+#endif
+#if ANDROID_PLATFORM_SDK_VERSION >= 21
+    audio_stream_type_t media_type = AUDIO_STREAM_SYSTEM;
+#else
+    audio_stream_type_t media_type = AUDIO_STREAM_MUSIC;
+#endif
+
 	AudioSystem::getOutputSamplingRate(&sr,AUDIO_STREAM_MUSIC);
 	if(sr > 0){
 		audio_io_handle_t handle = -1;		
@@ -95,7 +101,7 @@ static float get_android_stream_volume()
 #endif	                            
 		);
 		if(handle > 0){
-			if(AudioSystem::getStreamVolume(AUDIO_STREAM_MUSIC,&vol,handle) == 	NO_ERROR){
+			if(AudioSystem::getStreamVolume(media_type,&vol,handle) == 	NO_ERROR){
 				last_vol = vol;
 			//	adec_print("stream volume %f \n",vol);
 			}
diff --git a/amlogic/frameworks/av/LibPlayer/amadec/adec_omx_brige.c b/amlogic/frameworks/av/LibPlayer/amadec/adec_omx_brige.c
index b41eaf8..2092dfe 100644
--- a/amlogic/frameworks/av/LibPlayer/amadec/adec_omx_brige.c
+++ b/amlogic/frameworks/av/LibPlayer/amadec/adec_omx_brige.c
@@ -223,7 +223,7 @@ exit_decode_loop:
                 audec->pcm_cache_size -= wlen;
             }
 
-            while (rawoutput_enable && !audec->exit_decode_thread && outlen_raw) {
+            while (rawoutput_enable && !audec->exit_decode_thread && outlen_raw && aout_ops->audio_out_raw_enable) {
                 if (g_bst_raw->buf_length - g_bst_raw->buf_level < outlen_raw) {
                     amthreadpool_thread_usleep(20000);
                     continue;
diff --git a/amlogic/frameworks/av/LibPlayer/amadec/audio_out/android-out.cpp b/amlogic/frameworks/av/LibPlayer/amadec/audio_out/android-out.cpp
index baddd99..a9488d4 100644
--- a/amlogic/frameworks/av/LibPlayer/amadec/audio_out/android-out.cpp
+++ b/amlogic/frameworks/av/LibPlayer/amadec/audio_out/android-out.cpp
@@ -875,6 +875,7 @@ extern "C" int android_init_raw(struct aml_audio_dec* audec)
               track = NULL;
               mpAudioTrack_raw.clear();
 #endif
+              out_ops->audio_out_raw_enable = 0;
               out_ops->private_data_raw=NULL;
              return -1;
        }
@@ -1575,6 +1576,7 @@ extern "C" void get_output_func(struct aml_audio_dec* audec)
     out_ops->set_volume = android_set_volume;
     out_ops->set_lrvolume = android_set_lrvolume;
     out_ops->set_track_rate = android_set_track_rate;
+    out_ops->audio_out_raw_enable = 1;
     /* default set a invalid value*/
     out_ops->track_rate = 8.8f;
 }
diff --git a/amlogic/frameworks/av/LibPlayer/amavutils/amdrmutils.c b/amlogic/frameworks/av/LibPlayer/amavutils/amdrmutils.c
index 11b6dc5..ced5032 100644
--- a/amlogic/frameworks/av/LibPlayer/amavutils/amdrmutils.c
+++ b/amlogic/frameworks/av/LibPlayer/amavutils/amdrmutils.c
@@ -14,6 +14,7 @@
 #define TVP_ENABLE_PATH     "/sys/class/codec_mm/tvp_enable"
 #define TVP_REGION_PATH     "/sys/class/codec_mm/tvp_region"
 #define FREE_KEEP_BUFFER_PATH   "/sys/class/video/free_keep_buffer"
+#define FREE_CMA_BUFFER_PATH   "/sys/class/video/free_cma_buffer"
 #define VFM_DEF_MAP_PATH    "/sys/class/vfm/map"
 #define DI_TVP_REGION_PATH  "/sys/class/deinterlace/di0/tvp_region"
 #define DISABLE_VIDEO_PATH  "/sys/class/video/disable_video"
@@ -61,6 +62,21 @@ int free_keep_buffer(void)
     return -1;
 }
 
+int free_cma_buffer(void)
+{
+    int fd;
+    char bcmd[16];
+    fd = open(FREE_CMA_BUFFER_PATH, O_CREAT | O_RDWR | O_TRUNC, 0644);
+    if (fd >= 0) {
+        sprintf(bcmd, "%d", 1);
+        write(fd, bcmd, strlen(bcmd));
+        close(fd);
+        return 0;
+    }
+
+    return -1;
+}
+
 int set_vfmmap_ppmgr_di(int enable)
 {
     int fd;
diff --git a/amlogic/frameworks/av/LibPlayer/amavutils/include/amdrmutils.h b/amlogic/frameworks/av/LibPlayer/amavutils/include/amdrmutils.h
index 625be90..f78eb56 100644
--- a/amlogic/frameworks/av/LibPlayer/amavutils/include/amdrmutils.h
+++ b/amlogic/frameworks/av/LibPlayer/amavutils/include/amdrmutils.h
@@ -17,6 +17,7 @@ struct tvp_region
 extern int tvp_mm_enable(int flags);
 extern int tvp_mm_disable(int flags);
 extern int tvp_mm_get_mem_region(struct tvp_region* region, int region_size);
+extern int free_cma_buffer(void);
 
 
 #ifdef  __cplusplus
diff --git a/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/allcodecs.c b/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/allcodecs.c
index 5980107..8962fc7 100644
--- a/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/allcodecs.c
+++ b/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/allcodecs.c
@@ -407,6 +407,7 @@ void avcodec_register_all(void)
     REGISTER_PARSER  (H261, h261);
     REGISTER_PARSER  (H263, h263);
     REGISTER_PARSER  (H264, h264);
+    REGISTER_PARSER  (H264, h264mvc);
     REGISTER_PARSER  (HEVC, hevc);
     REGISTER_PARSER  (MJPEG, mjpeg);
     REGISTER_PARSER  (MLP, mlp);
diff --git a/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/dca_parser.c b/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/dca_parser.c
index 21fb153..a3ece28 100755
--- a/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/dca_parser.c
+++ b/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/dca_parser.c
@@ -141,12 +141,20 @@ static const uint32_t avpriv_dca_sample_rates[16] =
     12000, 24000, 48000, 96000, 192000
 };
 
+static const uint32_t avpriv_dca_bit_rates[32] =
+{
+    32000, 56000, 64000, 96000, 112000, 128000, 192000, 224000, 256000, 320000, 384000,
+    448000, 512000, 576000, 640000, 768000,960000,1024000,1152000,1280000,1344000,1408000,
+    1411200,1472000,1536000,1920000,2048000,3072000,3840000,0,0,0
+};
+
+
 static int dca_parse_params(const uint8_t *buf, int buf_size, int *duration,
-                            int *sample_rate)
+                            int *sample_rate,int *fsize,int *bitrate, int *channels)
 {
     GetBitContext gb;
     uint8_t hdr[12 + FF_INPUT_BUFFER_PADDING_SIZE] = { 0 };
-    int ret, sample_blocks, sr_code;
+    int ret, sample_blocks, sr_code,br_code,lfe;
 
     if (buf_size < 12)
         return AVERROR_INVALIDDATA;
@@ -161,11 +169,17 @@ static int dca_parse_params(const uint8_t *buf, int buf_size, int *duration,
     if (sample_blocks < 8)
         return AVERROR_INVALIDDATA;
     *duration = 256 * (sample_blocks / 8);
-
-    skip_bits(&gb, 20);
+    //skip_bits(&gb, 20);
+    fsize = get_bits(&gb, 14);
+    channels = get_bits(&gb, 6);
     sr_code = get_bits(&gb, 4);
+    br_code = get_bits(&gb, 5);
+    skip_bits(&gb, 10);
+    lfe = get_bits(&gb, 2);
     *sample_rate = avpriv_dca_sample_rates[sr_code];
-    if (*sample_rate == 0)
+    *bitrate = avpriv_dca_bit_rates[br_code];
+    //av_log(NULL,AV_LOG_INFO,"sample_blocks:%d,fsize:%d,channels:%d,sample_rate:%d,bitrate:%d,lfe:%d\n",sample_blocks,fsize,channels,*sample_rate,*bitrate,lfe);
+    if (*sample_rate == 0 || *bitrate == 0)
         return AVERROR_INVALIDDATA;
 
     return 0;
@@ -177,7 +191,7 @@ static int dca_parse(AVCodecParserContext * s,
 {
     DCAParseContext *pc1 = s->priv_data;
     ParseContext *pc = &pc1->pc;
-    int next, duration, sample_rate;
+    int next, duration, sample_rate,fsize,bitrate,channels;
 
     if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {
         next = buf_size;
@@ -190,11 +204,13 @@ static int dca_parse(AVCodecParserContext * s,
             return buf_size;
         }
     }
-    /* read the duration and sample rate from the frame header */
-    if (!dca_parse_params(buf, buf_size, &duration, &sample_rate)) {
+    /* read the duration ,sample rate,bitrate from the frame header */
+    if (!dca_parse_params(buf, buf_size, &duration, &sample_rate,&fsize,&bitrate,&channels)) {
         s->duration = duration;
         if (!avctx->sample_rate)
             avctx->sample_rate = sample_rate;
+        if (!avctx->bit_rate && bitrate)
+            avctx->bit_rate = bitrate;
     } else
         s->duration = 0;
     *poutbuf = buf;
diff --git a/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/h264_parser.c b/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/h264_parser.c
index 054c9f2..2adb543 100755
--- a/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/h264_parser.c
+++ b/amlogic/frameworks/av/LibPlayer/amffmpeg/libavcodec/h264_parser.c
@@ -350,3 +350,13 @@ AVCodecParser ff_h264_parser = {
     close,
     h264_split,
 };
+
+AVCodecParser ff_h264mvc_parser = {
+    { CODEC_ID_H264MVC },
+    sizeof(H264Context),
+    init,
+    h264_parse,
+    close,
+    h264_split,
+};
+
diff --git a/amlogic/frameworks/av/LibPlayer/amffmpeg/libavformat/mpegts.c b/amlogic/frameworks/av/LibPlayer/amffmpeg/libavformat/mpegts.c
index 5886241..9734779 100644
--- a/amlogic/frameworks/av/LibPlayer/amffmpeg/libavformat/mpegts.c
+++ b/amlogic/frameworks/av/LibPlayer/amffmpeg/libavformat/mpegts.c
@@ -728,7 +728,6 @@ static int mpegts_set_stream_info(AVStream *st, PESContext *pes,
         st->need_check_avs_version = 1;
         st->need_parsing = AVSTREAM_PARSE_HEADERS;
     }
-
     if (st->codec->codec_id == CODEC_ID_NONE) {
         mpegts_find_stream_type(st, pes->stream_type, HDMV_types);
         if ((prog_reg_desc == AV_RL32("HDMV")) || (prog_reg_desc == AV_RL32("HDPR"))) {
@@ -779,8 +778,25 @@ static int mpegts_set_stream_info(AVStream *st, PESContext *pes,
                 sub_st->discard = AVDISCARD_ALL;
                 sub_pes->sub_st = pes->sub_st = sub_st;
             }
-        } 
-        else {
+        }else if (pes->stream_type == 0x82) {
+                AVStream *sub_st;
+                PESContext *sub_pes = av_malloc(sizeof(*sub_pes));
+                if (!sub_pes)
+                    return AVERROR(ENOMEM);
+                memcpy(sub_pes, pes, sizeof(*sub_pes));
+                sub_st = av_new_stream(pes->stream, pes->pid);
+                if (!sub_st) {
+                    av_free(sub_pes);
+                    return AVERROR(ENOMEM);
+                }
+
+                av_set_pts_info(sub_st, 33, 1, 90000);
+                sub_st->priv_data = sub_pes;
+                sub_st->codec->codec_type = AVMEDIA_TYPE_AUDIO;
+                sub_st->codec->codec_id   = CODEC_ID_DTS;
+                sub_st->need_parsing = AVSTREAM_PARSE_FULL;
+                sub_pes->sub_st = pes->sub_st = sub_st;
+            } else {
             if (st->codec->codec_id != CODEC_ID_NONE
                 || pes->stream_type == 0x15) {
                 /* wrong case, don't have to probe */
diff --git a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_av.c b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_av.c
index 95faa33..29acd92 100644
--- a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_av.c
+++ b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_av.c
@@ -2331,7 +2331,7 @@ int write_av_packet(play_para_t *para)
                     return PLAYER_WR_FAILED;
                 } else {
                     /* EAGAIN to see if buffer full or write time out too much */
-                    if (check_avbuffer_enough_for_ape(para)) {
+                    if (check_avbuffer_enough_for_ape(para, -1)) {
                         if (!para->playctrl_info.check_lowlevel_eagain_time) {
                             check_time_interrupt(&para->playctrl_info.check_lowlevel_eagain_time, -1);    //always update
                         }
@@ -2498,7 +2498,7 @@ int write_av_packet(play_para_t *para)
                     return PLAYER_WR_FAILED;
                 } else {
                     /* EAGAIN to see if buffer full or write time out too much */
-                    if (check_avbuffer_enough(para)) {
+                    if (check_avbuffer_enough(para, -1)) {
                         if (!para->playctrl_info.check_lowlevel_eagain_time) {
                             check_time_interrupt(&para->playctrl_info.check_lowlevel_eagain_time, -1);    //always update
                         }
@@ -2508,23 +2508,27 @@ int write_av_packet(play_para_t *para)
 
                     if (para->playctrl_info.check_lowlevel_eagain_time != 0 &&
                         check_time_interrupt(&para->playctrl_info.check_lowlevel_eagain_time, WRITE_BLOCK_TIMEOUT_MS)) {
-                        /* reset decoder */
-                        para->playctrl_info.check_lowlevel_eagain_time = 0;
-                        para->playctrl_info.reset_flag = 1;
-                        set_black_policy(0);
-                        para->playctrl_info.end_flag = 1;
-
-                        if (para->state.start_time != -1) {
-                            para->playctrl_info.time_point = (para->state.pts_video - para->state.start_time) / PTS_FREQ;
+                        if (pkt->type == CODEC_SUBTITLE) {
+						    len += write_bytes; /*dop current write datas when is subtitle blocked.*/
+                            log_print("$$$$$$[type:%d] subtile write blocked, droped data at %f\n",
+                                pkt->type,
+                                para->playctrl_info.time_point);
                         } else {
-                            para->playctrl_info.time_point = para->state.pts_video / PTS_FREQ;
-                        }
-
-                        if (para->stream_type == STREAM_RM) {
-                            para->playctrl_info.time_point = -1.0;    //if searchime is -1 ,just do reset;
+                            /* reset decoder */
+                            para->playctrl_info.check_lowlevel_eagain_time = 0;
+                            para->playctrl_info.reset_flag = 1;
+                            set_black_policy(0);
+                            para->playctrl_info.end_flag = 1;
+                            if (para->state.start_time != -1) {
+                                para->playctrl_info.time_point = (para->state.pts_video - para->state.start_time) / PTS_FREQ;
+                            } else {
+                                para->playctrl_info.time_point = para->state.pts_video / PTS_FREQ;
+                            }
+                            if (para->stream_type == STREAM_RM) {
+                                para->playctrl_info.time_point = -1.0;    //if searchime is -1 ,just do reset;
+                            }
+                            log_print("$$$$$$[type:%d] write blocked, need reset decoder!$$$$$$ at time =%f\n", pkt->type, para->playctrl_info.time_point);
                         }
-
-                        log_print("$$$$$$[type:%d] write blocked, need reset decoder!$$$$$$ at time =%f\n", pkt->type, para->playctrl_info.time_point);
                     }
 
                     pkt->data += len;
@@ -2539,7 +2543,10 @@ int write_av_packet(play_para_t *para)
                                   __FUNCTION__, pkt->data_size, pkt->type, para->read_size.total_bytes, \
                                   para->write_size.total_bytes, para->playctrl_info.check_lowlevel_eagain_time);
                     }
-
+                    if (pkt->data_size <= 0) {
+						pkt->avpkt_isvalid = 0;
+						return PLAYER_WR_FINISH;
+                    }
                     return PLAYER_SUCCESS;
                 }
             } else {
@@ -3217,11 +3224,12 @@ int read_sub_data(am_packet_t *pkt, char *buf, unsigned int length)
     }
 }
 
-int write_sub_data(am_packet_t *pkt, char *buf, unsigned int length)
+int write_sub_data(play_para_t *player, am_packet_t *pkt, char *buf, unsigned int length)
 {
     int write_bytes, size;
     unsigned int len = 0;
-
+	unsigned long starttime = 0;
+	check_time_interrupt(&starttime, 0);
     if (!pkt || !pkt->codec) {
         return 0;
     }
@@ -3248,11 +3256,15 @@ int write_sub_data(am_packet_t *pkt, char *buf, unsigned int length)
                 log_print("[%s:%d]write sub data failed!\n", __FUNCTION__, __LINE__);
                 return PLAYER_WR_FAILED;
             } else {
-                if (amthreadpool_on_requare_exit(0)) {
-                    return PLAYER_WR_FAILED;
-                }
-
-                continue;
+               if (amthreadpool_on_requare_exit(0)) {
+                   return PLAYER_WR_FAILED;
+               }
+               if (check_avbuffer_enough(player, CODEC_TYPE_SUBTITLE) || check_time_interrupt(&starttime, 1000)) {
+                   log_print("[%s:%d]write sub data header failed!\n", __FUNCTION__, __LINE__);
+                   break;
+               }
+			   player_thread_wait(player, 20);
+               continue;
             }
         } else {
             len += write_bytes;
@@ -3368,7 +3380,7 @@ int process_es_subtitle(play_para_t *para)
     log_print("## [ sizeof:%d , sub_index=%d, pkt_stream_index=%d,]\n", sizeof(sub_header), para->sstream_info.sub_index, pkt->avpkt->stream_index);
 
     if (para->sstream_info.sub_index == pkt->avpkt->stream_index) {
-        if (write_sub_data(pkt, (char *)&sub_header, sizeof(sub_header))) {
+        if (write_sub_data(para, pkt, (char *)&sub_header, sizeof(sub_header))) {
             log_print("[%s:%d]write sub header failed\n", __FUNCTION__, __LINE__);
         }
     }
@@ -4209,17 +4221,21 @@ int get_avbuf_min_size(play_para_t *p_para)
     return min_size;
 }
 
-int check_avbuffer_enough(play_para_t *para)
+int check_avbuffer_enough(play_para_t *para, int type)
 {
 #define VIDEO_RESERVED_SPACE    (0x10000)   // 64k
 #define AUDIO_RESERVED_SPACE    (0x2000)    // 8k
+
     am_packet_t *pkt = para->p_pkt;
     int vbuf_enough = 1;
     int abuf_enough = 1;
     int ret = 1;
     float high_limit = (para->buffering_threshhold_max > 0) ? para->buffering_threshhold_max : 0.8;
 
-    if (pkt->type == CODEC_COMPLEX) {
+	if (type == -1 && pkt && pkt->avpkt_isvalid)
+		type = pkt->type;
+
+    if (type == CODEC_COMPLEX) {
         if (para->vstream_info.has_video &&
             (para->state.video_bufferlevel >= high_limit)) {
             vbuf_enough = 0;
@@ -4231,23 +4247,35 @@ int check_avbuffer_enough(play_para_t *para)
         }
 
         ret = vbuf_enough && abuf_enough;
-    } else if (pkt->type == CODEC_VIDEO || pkt->type == CODEC_AUDIO) {
-        /*if(pkt->type == CODEC_VIDEO)
-            log_print("[%s]type:%d data=%x size=%x total=%x\n", __FUNCTION__, pkt->type, para->vbuffer.data_level,pkt->data_size,para->vbuffer.buffer_size);
-            if(pkt->type == CODEC_AUDIO)
-            log_print("[%s]type:%d data=%x size=%x total=%x\n", __FUNCTION__, pkt->type, para->abuffer.data_level,pkt->data_size,para->abuffer.buffer_size);
-        */
-        if (para->vstream_info.has_video && (pkt->type == CODEC_VIDEO) &&
+    } else if (type == CODEC_VIDEO || type == CODEC_AUDIO) {
+        if (para->vstream_info.has_video && (type == CODEC_VIDEO) &&
             ((para->vbuffer.data_level + pkt->data_size) >= (para->vbuffer.buffer_size - VIDEO_RESERVED_SPACE))) {
             vbuf_enough = 0;
         }
 
-        if (para->astream_info.has_audio && (pkt->type == CODEC_AUDIO) &&
+        if (para->astream_info.has_audio && (type == CODEC_AUDIO) &&
             ((para->abuffer.data_level + pkt->data_size) >= (para->abuffer.buffer_size - AUDIO_RESERVED_SPACE))) {
             abuf_enough = 0;
         }
 
         ret = vbuf_enough && abuf_enough;
+    } if (type == CODEC_SUBTITLE) {
+        int v_low = 0;
+        int a_low = 0;
+        if (para->vstream_info.has_video &&
+        (para->state.video_bufferlevel < 0.2)) {
+            v_low = 1;
+        }
+        if (para->astream_info.has_audio &&
+            (para->state.audio_bufferlevel < 0.2)) {
+            a_low = 1;
+        }
+        /*if vbuf level abuf level is low,we think subtile buffer is full, do drop.
+               if vbuf & abuf is high, do wait.
+               only one low, return 1; mean subtitle have buffers but blocked... wait some time to drop..
+               other return 0; enough buffers. always wait.
+           */
+        return (v_low || a_low);
     }
 
     /*if(!abuf_enough || !vbuf_enough) {
diff --git a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_av.h b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_av.h
index 1d5e498..44bfef0 100644
--- a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_av.h
+++ b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_av.h
@@ -60,7 +60,7 @@ void av_packet_release(am_packet_t *pkt);
 int poll_sub(am_packet_t *pkt);
 int get_sub_size(am_packet_t *pkt);
 int read_sub_data(am_packet_t *pkt, char *buf, unsigned int length);
-int write_sub_data(am_packet_t *pkt, char *buf, unsigned int length);
+int write_sub_data(play_para_t *player, am_packet_t *pkt, char *buf, unsigned int length);
 int process_es_subtitle(play_para_t *para);
 int poll_cntl(am_packet_t *pkt);
 int set_cntl_mode(play_para_t *para, unsigned int mode);
@@ -71,7 +71,7 @@ void player_switch_sub(play_para_t *para);
 int get_cntl_state(am_packet_t *pkt);
 int time_search(struct play_para *para, int flags);
 int player_reset(play_para_t *p_para);
-int check_avbuffer_enough(play_para_t *para);
+int check_avbuffer_enough(play_para_t *para, int type);
 int64_t gettime(void);
 
 
diff --git a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_ffmpeg_ctrl.c b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_ffmpeg_ctrl.c
index db1a368..c9eb09f 100644
--- a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_ffmpeg_ctrl.c
+++ b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_ffmpeg_ctrl.c
@@ -336,7 +336,9 @@ int ffmpeg_parse_file_type(play_para_t *am_p, player_file_type_t *type)
                     }
                 }
 
-                if (st->codec->codec_id == CODEC_ID_RV40 && (st->codec->width * st->codec->height > 1920 * 1088)) {
+                if (st->codec->codec_id == CODEC_ID_RV40 && (
+                    (st->codec->width * st->codec->height > 1920 * 1088) &&
+                     !am_p->vdec_profile.real_para.exceed_1080p_enable)) {
                     if (rm_flag == 0) {
                         rm_flag = 1;
                         sprintf(vpx_string, "%s", "rmsoft");
diff --git a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_hwdec.h b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_hwdec.h
index cee3d2f..8012cd2 100644
--- a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_hwdec.h
+++ b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_hwdec.h
@@ -6,7 +6,7 @@
 #include "player_priv.h"
 
 #define ADTS_HEADER_SIZE        (7)
-#define HDR_BUF_SIZE                (1024)
+#define HDR_BUF_SIZE                (2048)
 
 typedef struct {
     unsigned short syncword;
diff --git a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_para.c b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_para.c
index d203336..5ce1e0d 100644
--- a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_para.c
+++ b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_para.c
@@ -975,8 +975,11 @@ static void get_stream_info(play_para_t *p_para)
         }
         log_print("[%s:%d]real offset %lld\n", __FUNCTION__, __LINE__, p_para->data_offset);
 
-        if (p_para->vstream_info.video_height * p_para->vstream_info.video_width > 1920 * 1088) {
-            log_print("[%s:%d]real video_height=%d, exceed 1080p not support!\n", __FUNCTION__, __LINE__, p_para->vstream_info.video_height);
+        if (!p_para->vdec_profile.real_para.exceed_1080p_enable &&
+            (p_para->vstream_info.video_height * p_para->vstream_info.video_width > 1920 * 1088)) {
+            log_print("[%s:%d]real video size =%d X %d, exceed 1080p not support!\n", __FUNCTION__, __LINE__,
+            p_para->vstream_info.video_width,
+            p_para->vstream_info.video_height);
             p_para->vstream_info.has_video = 0;
         }
     } else {
@@ -985,7 +988,9 @@ static void get_stream_info(play_para_t *p_para)
     }
 
     if (video_index != -1) {
-        if (p_para->vstream_info.video_format == VFORMAT_VP9) {
+        if (p_para->stream_type == STREAM_RM) {
+            /*have check size before. not chek now.*/
+        } else if (p_para->vstream_info.video_format == VFORMAT_VP9) {
             if (p_para->vdec_profile.vp9_para.exist) {
                 ;
             } else {
diff --git a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_profile.c b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_profile.c
index 468d742..dbb832f 100644
--- a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_profile.c
+++ b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_profile.c
@@ -137,6 +137,9 @@ static int parse_vp9_param(char *str, sys_hevc_profile_t *para, int size)
 
 static int parse_real_param(char *str, sys_real_profile_t *para, int size)
 {
+    if (strstr(str, "1080p+")) {
+        para->exceed_1080p_enable = 1;
+    }
     return 0;
 }
 
diff --git a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_profile.h b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_profile.h
index e995e3c..0c2e872 100644
--- a/amlogic/frameworks/av/LibPlayer/amplayer/player/player_profile.h
+++ b/amlogic/frameworks/av/LibPlayer/amplayer/player/player_profile.h
@@ -40,6 +40,7 @@ typedef struct {
 typedef struct {
     int es_support;
     int exceed_720p_enable;
+    int exceed_1080p_enable;
 } sys_real_profile_t;
 
 typedef struct {
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/Am-Httplive/AmPlaylistFetcher.cpp b/amlogic/frameworks/av/media/Am-NuPlayer/Am-Httplive/AmPlaylistFetcher.cpp
index 7e8cb7f..b507bbe 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/Am-Httplive/AmPlaylistFetcher.cpp
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/Am-Httplive/AmPlaylistFetcher.cpp
@@ -1275,6 +1275,7 @@ FETCH:
         if (buffer == NULL) {  // maybe interrupt play
             status_t err = bytesRead;
             notifyError(err);
+            postMonitorQueue();
             goto FAIL;
         }
 
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/Am-mpeg2ts/AmESQueue.cpp b/amlogic/frameworks/av/media/Am-NuPlayer/Am-mpeg2ts/AmESQueue.cpp
index 7f7254e..efbab05 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/Am-mpeg2ts/AmESQueue.cpp
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/Am-mpeg2ts/AmESQueue.cpp
@@ -725,21 +725,20 @@ sp<ABuffer> AmElementaryStreamQueue::dequeueAccessUnitAAC() {
         bits.skipBits(3);  // ID, layer
         bool protection_absent = bits.getBits(1) != 0;
 
+        unsigned profile = bits.getBits(2);
+        if (profile == 3u) {
+            ALOGE("profile should not be 3");
+            return NULL;
+        }
+        unsigned sampling_freq_index = bits.getBits(4);
+        bits.getBits(1);  // private_bit
+        unsigned channel_configuration = bits.getBits(3);
+        if (channel_configuration == 0u) {
+            ALOGE("channel_config should not be 0");
+            return NULL;
+        }
+        bits.skipBits(2);  // original_copy, home
         if (mFormat == NULL) {
-            unsigned profile = bits.getBits(2);
-            if (profile == 3u) {
-                ALOGE("profile should not be 3");
-                return NULL;
-            }
-            unsigned sampling_freq_index = bits.getBits(4);
-            bits.getBits(1);  // private_bit
-            unsigned channel_configuration = bits.getBits(3);
-            if (channel_configuration == 0u) {
-                ALOGE("channel_config should not be 0");
-                return NULL;
-            }
-            bits.skipBits(2);  // original_copy, home
-
             mFormat = MakeAACCodecSpecificData(
                     profile, sampling_freq_index, channel_configuration);
 
@@ -755,13 +754,31 @@ sp<ABuffer> AmElementaryStreamQueue::dequeueAccessUnitAAC() {
                 ALOGE("ChannelCount not found");
                 return NULL;
             }
-
             ALOGI("found AAC codec config (%d Hz, %d channels)",
                  sampleRate, numChannels);
         } else {
-            // profile_ObjectType, sampling_frequency_index, private_bits,
-            // channel_configuration, original_copy, home
-            bits.skipBits(12);
+            CHECK_LE(sampling_freq_index, 11u);
+            static const int32_t kSamplingFreq[] = {
+                96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,
+                16000, 12000, 11025, 8000
+            };
+            int32_t sampleRate = kSamplingFreq[sampling_freq_index];
+            int32_t numChannels = channel_configuration;
+            int curSampleRate, curNumChannels;
+
+            if (!mFormat->findInt32(kKeySampleRate, &curSampleRate)) {
+                ALOGE("SampleRate not found");
+                return NULL;
+            }
+            if (!mFormat->findInt32(kKeyChannelCount, &curNumChannels)) {
+                ALOGE("ChannelCount not found");
+                return NULL;
+            }
+            if (curSampleRate != sampleRate || curNumChannels != numChannels) {
+                mFormat->setInt32(kKeySampleRate, sampleRate);
+                mFormat->setInt32(kKeyChannelCount, numChannels);
+                ALOGI("reset sample rate %d, channel %d\n", sampleRate, numChannels);
+            }
         }
 
         // adts_variable_header
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/AmHTTPLiveSource.cpp b/amlogic/frameworks/av/media/Am-NuPlayer/AmHTTPLiveSource.cpp
index d4ff1fe..0d0602a 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/AmHTTPLiveSource.cpp
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/AmHTTPLiveSource.cpp
@@ -75,9 +75,8 @@ AmNuPlayer::HTTPLiveSource::HTTPLiveSource(
 
 AmNuPlayer::HTTPLiveSource::~HTTPLiveSource() {
     ALOGI("[%s:%d] start !", __FUNCTION__, __LINE__);
+    release();
     if (mLiveSession != NULL) {
-        mLiveSession->disconnect();
-
         mLiveLooper->unregisterHandler(mLiveSession->id());
         //mLiveLooper->unregisterHandler(this);
         mLiveLooper->stop();
@@ -116,6 +115,10 @@ void AmNuPlayer::HTTPLiveSource::prepareAsync() {
 
 void AmNuPlayer::HTTPLiveSource::start() {
 }
+void AmNuPlayer::HTTPLiveSource::release() {
+    if (mLiveSession != NULL)
+        mLiveSession->disconnect();
+}
 
 void AmNuPlayer::HTTPLiveSource::setParentThreadId(android_thread_id_t thread_id) {
     mParentThreadId = thread_id;
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/AmHTTPLiveSource.h b/amlogic/frameworks/av/media/Am-NuPlayer/AmHTTPLiveSource.h
index 8d86dd0..a7f3c89 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/AmHTTPLiveSource.h
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/AmHTTPLiveSource.h
@@ -36,7 +36,7 @@ struct AmNuPlayer::HTTPLiveSource : public AmNuPlayer::Source {
 
     virtual void prepareAsync();
     virtual void start();
-
+    virtual void release();
     virtual status_t dequeueAccessUnit(bool audio, sp<ABuffer> *accessUnit);
     virtual sp<AMessage> getFormat(bool audio);
 
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayer.cpp b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayer.cpp
index d6e709b..6bdcab3 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayer.cpp
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayer.cpp
@@ -18,6 +18,18 @@
 #define LOG_TAG "NU-AmNuPlayer"
 #include <utils/Log.h>
 
+#include <stdio.h>
+#include <assert.h>
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sched.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <libavcodec/avcodec.h>
+
+
 #include "AmNuPlayer.h"
 
 #include "AmHTTPLiveSource.h"
@@ -47,6 +59,7 @@
 #include <media/stagefright/MetaData.h>
 #include <gui/IGraphicBufferProducer.h>
 
+
 #include "avc_utils.h"
 
 #include "ESDS.h"
@@ -194,7 +207,11 @@ AmNuPlayer::AmNuPlayer()
       mPausedByClient(false),
       mAutoSwitch(-1) {
     clearFlushComplete();
-
+    DtshdApreTotal=0;
+    DtsHdStreamType=0;
+    DtsHdMulAssetHint=0;
+    DtsHdHpsHint=0;
+    mStrCurrentAudioCodec = NULL;
     char value[PROPERTY_VALUE_MAX];
     if (property_get("media.hls.wait-seconds", value, NULL)) {
         mWaitSeconds = atoi(value);
@@ -206,6 +223,9 @@ AmNuPlayer::~AmNuPlayer() {
     if (mEnableFrameRate && mAutoSwitch > 0) {
         amsysfs_set_sysfs_int("/sys/class/tv/policy_fr_auto_switch", mAutoSwitch);
     }
+    if (mSource != NULL) {
+        mSource->release();
+    }
 }
 
 // static
@@ -260,6 +280,394 @@ int32_t AmNuPlayer::interrupt_callback(android_thread_id_t thread_id) {
     }
     return 0;
 }
+int AmNuPlayer::getintfromString8(String8 &s, const char*pre){
+    int off;
+    int val = 0;
+    if ((off = s.find(pre, 0)) >= 0) {
+        sscanf(s.string() + off + strlen(pre), "%d", &val);
+    }
+    return val;
+}
+
+
+#define DTSM6_EXCHANGE_INFO_NODE "/sys/class/amaudio/debug"
+static void dtsm6_get_exchange_info(int *streamtype,int *APreCnt,int *APreSel,int *ApreAssetSel,int32_t *ApresAssetsArray,int *MulAssetHint,int *HPs_hint){
+    int fd=open(DTSM6_EXCHANGE_INFO_NODE,  O_RDWR | O_TRUNC, 0644);
+    int bytes=0,i=0;
+
+    if (fd >= 0) {
+        uint8_t ubuf8[256]={0};
+        bytes=read(fd,ubuf8,256);
+
+        if (streamtype != NULL) {
+            uint8_t *pStreamType=(uint8_t *)strstr((const char*)ubuf8,"StreamType");
+            if (pStreamType != NULL) {
+               pStreamType+=10;
+               *streamtype=atoi((const char*)pStreamType);
+            }
+        }
+
+        if (APreCnt != NULL) {
+            uint8_t *pApreCnt=(uint8_t *)strstr((const char*)ubuf8,"ApreCnt");
+            if (pApreCnt != NULL) {
+               pApreCnt+=7;
+               *APreCnt=atoi((const char*)pApreCnt);
+            }
+        }
+
+        if (APreSel != NULL) {
+            uint8_t *pApreSel=(uint8_t *)strstr((const char*)ubuf8,"ApreSel");
+            if (pApreSel != NULL) {
+               pApreSel+=7;
+               *APreSel=atoi((const char*)pApreSel);
+            }
+        }
+
+        if (ApreAssetSel != NULL) {
+            uint8_t *pApreAssetSel=(uint8_t *)strstr((const char*)ubuf8,"ApreAssetSel");
+            if (pApreAssetSel != NULL) {
+                pApreAssetSel+=12;
+                *ApreAssetSel=atoi((const char*)pApreAssetSel);
+            }
+        }
+
+        if (ApresAssetsArray != NULL && APreCnt != NULL) {
+            uint8_t *pApresAssetsArray=(uint8_t *)strstr((const char*)ubuf8,"ApresAssetsArray");
+            if (pApresAssetsArray != NULL) {
+               pApresAssetsArray+=16;
+               for (i=0;i<*APreCnt;i++) {
+                 ApresAssetsArray[i]=pApresAssetsArray[i];
+                 ALOGI("[%s %d]ApresAssetsArray[%d]/%d",__FUNCTION__,__LINE__,i,ApresAssetsArray[i]);
+               }
+            }
+        }
+        if (MulAssetHint != NULL) {
+            uint8_t *pMulAssetHint=(uint8_t *)strstr((const char*)ubuf8,"MulAssetHint");
+            if (pMulAssetHint != NULL) {
+               pMulAssetHint+=12;
+               *MulAssetHint=atoi((const char*)pMulAssetHint);
+            }
+        }
+        if (HPs_hint != NULL) {
+            uint8_t *phps_hint=(uint8_t *)strstr((const char*)ubuf8,"HPSHint");
+            if (phps_hint != NULL) {
+               phps_hint +=7;
+               *HPs_hint=atoi((const char*)phps_hint);
+            }
+        }
+        close(fd);
+    }else{
+        ALOGI("[%s %d]open %s failed!\n",__FUNCTION__,__LINE__,DTSM6_EXCHANGE_INFO_NODE);
+       if (streamtype != NULL)  *streamtype=0;
+       if (APreCnt != NULL)     *APreCnt=0;
+       if (APreSel != NULL)     *APreSel=0;
+       if (ApreAssetSel != NULL)*ApreAssetSel=0;
+       if (HPs_hint != NULL)    *HPs_hint=0;
+       if (ApresAssetsArray != NULL&& APreCnt != NULL) memset(ApresAssetsArray,0,*APreCnt);
+    }
+}
+
+static void dtsm6_set_exchange_info(int *APreSel,int *ApreAssetSel)
+{
+    int fd=open(DTSM6_EXCHANGE_INFO_NODE,  O_RDWR | O_TRUNC, 0644);
+    int bytes,pos=0;
+    if (fd >= 0) {
+       char ubuf8[128]={0};
+       if (APreSel != NULL) {
+           bytes=sprintf(ubuf8,"dtsm6_apre_sel_set%d",*APreSel);
+           write(fd, ubuf8, bytes);
+       }
+       if (ApreAssetSel != NULL) {
+           bytes=sprintf(ubuf8,"dtsm6_apre_assets_sel_set%d",*ApreAssetSel);
+           write(fd, ubuf8, bytes);
+       }
+       close(fd);
+    }else{
+       ALOGI("[%s %d]open %s failed!\n",__FUNCTION__,__LINE__,DTSM6_EXCHANGE_INFO_NODE);
+    }
+}
+static aformat_t audioTypeConvert(enum CodecID id)
+{
+    aformat_t format = (aformat_t)-1;
+    switch (id) {
+    case CODEC_ID_PCM_MULAW:
+        //format = AFORMAT_MULAW;
+        format = AFORMAT_ADPCM;
+        break;
+
+    case CODEC_ID_PCM_ALAW:
+        //format = AFORMAT_ALAW;
+        format = AFORMAT_ADPCM;
+        break;
+
+
+    case CODEC_ID_MP1:
+    case CODEC_ID_MP2:
+    case CODEC_ID_MP3:
+        format = AFORMAT_MPEG;
+        break;
+
+    case CODEC_ID_AAC_LATM:
+        format = AFORMAT_AAC_LATM;
+        break;
+
+
+    case CODEC_ID_AAC:
+        format = AFORMAT_AAC;
+        break;
+
+    case CODEC_ID_AC3:
+        format = AFORMAT_AC3;
+        break;
+    case CODEC_ID_EAC3:
+        format = AFORMAT_EAC3;
+        break;
+    case CODEC_ID_DTS:
+        format = AFORMAT_DTS;
+        break;
+
+    case CODEC_ID_PCM_S16BE:
+        format = AFORMAT_PCM_S16BE;
+        break;
+
+    case CODEC_ID_PCM_S16LE:
+        format = AFORMAT_PCM_S16LE;
+        break;
+
+    case CODEC_ID_PCM_U8:
+        format = AFORMAT_PCM_U8;
+        break;
+
+    case CODEC_ID_COOK:
+        format = AFORMAT_COOK;
+        break;
+
+    case CODEC_ID_ADPCM_IMA_WAV:
+    case CODEC_ID_ADPCM_MS:
+        format = AFORMAT_ADPCM;
+        break;
+    case CODEC_ID_AMR_NB:
+    case CODEC_ID_AMR_WB:
+        format =  AFORMAT_AMR;
+        break;
+    case CODEC_ID_WMAV1:
+    case CODEC_ID_WMAV2:
+        format =  AFORMAT_WMA;
+        break;
+    case CODEC_ID_FLAC:
+        format = AFORMAT_FLAC;
+        break;
+
+    case CODEC_ID_WMAPRO:
+        format = AFORMAT_WMAPRO;
+        break;
+
+    case CODEC_ID_PCM_BLURAY:
+        format = AFORMAT_PCM_BLURAY;
+        break;
+    case CODEC_ID_ALAC:
+        format = AFORMAT_ALAC;
+        break;
+    case CODEC_ID_VORBIS:
+        format =    AFORMAT_VORBIS;
+        break;
+    case CODEC_ID_APE:
+        format =    AFORMAT_APE;
+        break;
+    case CODEC_ID_PCM_WIFIDISPLAY:
+        format = AFORMAT_PCM_WIFIDISPLAY;
+        break;
+    default:
+        format = AFORMAT_UNSUPPORT;
+        ALOGV("audio codec_id=0x%x\n", id);
+    }
+    ALOGV("[audioTypeConvert]audio codec_id=0x%x format=%d\n", id, format);
+
+    return format;
+}
+
+status_t AmNuPlayer::updateMediaInfo(void) {
+    ALOGI("updateMediaInfo");
+    maudio_info_t *ainfo;
+    mvideo_info_t *vinfo;
+    mStreamInfo.stream_info.total_video_num = 0;
+    mStreamInfo.stream_info.total_audio_num = 0;
+    sp<AMessage> aformat= mSource->getFormat(true);  //audio
+    sp<AMessage> vformat= mSource->getFormat(false);   // video
+    if (vformat != NULL) {
+        vinfo = (mvideo_info_t *)malloc(sizeof(mvideo_info_t));
+        memset(vinfo, 0, sizeof(mvideo_info_t));
+        int32_t codecid=-1,width=-1,height=-1,bitrate=-1;
+        int64_t duration = -1;
+        vinfo->index = 0;
+        if (vformat->findInt32("code-id", &codecid)) {
+            vinfo->id = codecid;
+        }
+        if (vformat->findInt32("width", &width)) {
+            vinfo->width = width;
+        }
+        if (vformat->findInt32("height", &height)) {
+            vinfo->height = height;
+        }
+        if (vformat->findInt64("durationUs", &duration)) {
+             vinfo->duartion = duration;
+        }
+        if (vformat->findInt32("bit-rate", &bitrate)) {
+            vinfo->bit_rate = bitrate;
+        }
+        vinfo->format  = (vformat_t)0;
+        vinfo->aspect_ratio_num = 0;
+        vinfo->aspect_ratio_den = 0;
+        vinfo->frame_rate_num   = 0;
+        vinfo->frame_rate_den   = 0;
+        vinfo->video_rotation_degree = 0;
+        mStreamInfo.video_info[mStreamInfo.stream_info.total_video_num] = vinfo;
+        mStreamInfo.stream_info.total_video_num++;
+    }
+    if (aformat != NULL) {
+        ainfo = (maudio_info_t *)malloc(sizeof(maudio_info_t));
+        memset(ainfo, 0, sizeof(maudio_info_t));
+        int32_t codecid=-1, bitrate=-1, samplerate=-1, channelcount=-1;
+        int64_t duration=-1;
+        ainfo->index = 0;
+        AString mime;
+        if (aformat->findInt32("code-id", &codecid)) {
+            ainfo->id = codecid;
+        }
+        if (aformat->findString("mime", &mime)) {
+            if (mime == MEDIA_MIMETYPE_AUDIO_DTSHD) {
+                ALOGI("mime:%s",MEDIA_MIMETYPE_AUDIO_DTSHD);
+                mStrCurrentAudioCodec = "DTSHD";
+                ainfo->id = CODEC_ID_DTS;
+            }
+        }
+        if (aformat->findInt32("bit-rate", &bitrate)) {
+            ainfo->bit_rate = bitrate;
+        }
+        if (aformat->findInt32("channel-count", &channelcount)) {
+            ainfo->channel = channelcount;
+        }
+        if (aformat->findInt32("sample-rate", &samplerate)) {
+            ainfo->sample_rate = samplerate;
+        }
+        if (vformat->findInt64("durationUs", &duration)) {
+            ainfo->duration = duration;
+        }
+        if (ainfo->id  > 0)
+            ainfo->aformat      = audioTypeConvert((enum CodecID)ainfo->id);
+        ALOGI("aformat %d",ainfo->aformat);
+        mStreamInfo.audio_info[mStreamInfo.stream_info.total_audio_num] = ainfo;
+        mStreamInfo.stream_info.total_audio_num++;
+
+    }
+    mStreamInfo.stream_info.cur_video_index = 0;
+    mStreamInfo.stream_info.cur_audio_index = 0;
+    mStreamInfo.stream_info.cur_sub_index   = -1;
+
+    return OK;
+
+}
+
+status_t AmNuPlayer::getMediaInfo(Parcel* reply){
+    //Mutex::Autolock autoLock(mLock);
+    ALOGI("AmNuPlayer::getMediaInfo");
+    int datapos=reply->dataPosition();
+    updateMediaInfo();
+    //filename
+    reply->writeString16(String16("-1"));
+    //duration
+    if (mStreamInfo.stream_info.duration > 0)
+        reply->writeInt32(mStreamInfo.stream_info.duration);
+    else
+        reply->writeInt32(-1);
+
+    reply->writeString16(String16("null"));
+
+    //bitrate
+      if (mStreamInfo.stream_info.bitrate > 0)
+        reply->writeInt32(mStreamInfo.stream_info.bitrate);
+    else
+        reply->writeInt32(-1);
+
+    //filetype
+    reply->writeInt32(mStreamInfo.stream_info.type);
+
+    /*select info*/
+    reply->writeInt32(mStreamInfo.stream_info.cur_video_index);
+    reply->writeInt32(mStreamInfo.stream_info.cur_audio_index);
+    reply->writeInt32(mStreamInfo.stream_info.cur_sub_index);
+    ALOGI("--cur video:%d cur audio:%d cur sub:%d \n",mStreamInfo.stream_info.cur_video_index,mStreamInfo.stream_info.cur_audio_index,mStreamInfo.stream_info.cur_sub_index);
+    /*build video info*/
+    reply->writeInt32(mStreamInfo.stream_info.total_video_num);
+    for (int i = 0;i < mStreamInfo.stream_info.total_video_num; i ++) {
+        reply->writeInt32(mStreamInfo.video_info[i]->index);
+        reply->writeInt32(mStreamInfo.video_info[i]->id);
+        reply->writeString16(String16("unknow"));
+        reply->writeInt32(mStreamInfo.video_info[i]->width);
+        reply->writeInt32(mStreamInfo.video_info[i]->height);
+        ALOGI("--video index:%d id:%d totlanum:%d width:%d height:%d \n",mStreamInfo.video_info[i]->index,mStreamInfo.video_info[i]->id,mStreamInfo.stream_info.total_video_num,mStreamInfo.video_info[i]->width,mStreamInfo.video_info[i]->height);
+    }
+
+    /*build audio info*/
+    reply->writeInt32(mStreamInfo.stream_info.total_audio_num);
+    for (int i = 0; i < mStreamInfo.stream_info.total_audio_num; i ++) {
+        reply->writeInt32(mStreamInfo.audio_info[i]->index);
+        reply->writeInt32(mStreamInfo.audio_info[i]->id);
+        reply->writeInt32(mStreamInfo.audio_info[i]->aformat);
+        reply->writeInt32(mStreamInfo.audio_info[i]->channel);
+        reply->writeInt32(mStreamInfo.audio_info[i]->sample_rate);
+        ALOGI("--audio index:%d id:%d totlanum:%d channel:%d samplerate:%d aformat=%d\n",mStreamInfo.audio_info[i]->index,mStreamInfo.audio_info[i]->id,mStreamInfo.stream_info.total_audio_num,mStreamInfo.audio_info[i]->channel,mStreamInfo.audio_info[i]->sample_rate,mStreamInfo.audio_info[i]->aformat);
+    }
+
+    /*build subtitle info*/
+    reply->writeInt32(0);
+    reply->writeInt32(0);
+    reply->setDataPosition(datapos);
+    return OK;
+}
+
+
+
+status_t AmNuPlayer::setParameter(int key , const Parcel &  request ) {
+    if (KEY_PARAMETER_AML_PLAYER_SET_DTS_ASSET == key) {
+        int ApreID =0,ApreAssetSel;
+        const String16 uri16 = request.readString16();
+        String8 keyStr = String8(uri16);
+        ALOGI("setParameter %d=[%s]\n", key, keyStr.string());
+        ApreID = getintfromString8(keyStr, "dtsApre:");
+        ApreAssetSel=getintfromString8(keyStr, "dtsAsset:");
+        if (ApreID >= 0 && ApreAssetSel >= 0) {
+            dtsm6_set_exchange_info(&ApreID,&ApreAssetSel);
+        }
+    }else{
+        ALOGI("unsupport setParameter value!=%d\n", key);
+    }
+    return OK;
+}
+
+status_t AmNuPlayer::getParameter(int key, Parcel *reply){
+    if (key == KEY_PARAMETER_AML_PLAYER_GET_DTS_ASSET_TOTAL) {
+        if (mSource == NULL)
+            return INVALID_OPERATION;
+        int32_t codecid;
+        if (mStrCurrentAudioCodec != NULL && !strncmp(mStrCurrentAudioCodec,"DTS",3)) {
+            int32_t ApresAssetsArray[32]={0};
+            dtsm6_get_exchange_info(NULL,&DtshdApreTotal,NULL,NULL,ApresAssetsArray,NULL,NULL);
+            reply->writeInt32(DtshdApreTotal);
+            reply->writeInt32Array(32,ApresAssetsArray);
+        }else{
+            int32_t ApresAssetsArray[32]={0};
+            reply->writeInt32(0);
+            reply->writeInt32Array(32,ApresAssetsArray);
+        }
+    }else if (KEY_PARAMETER_AML_PLAYER_GET_MEDIA_INFO == key) {
+        getMediaInfo(reply);
+    }else {
+        ALOGI("unsupport setParameter value!=%d\n", key);
+    }
+    return  OK;
+}
+
 
 void AmNuPlayer::setUID(uid_t uid) {
     mUIDValid = true;
@@ -1613,7 +2021,40 @@ status_t AmNuPlayer::getCurrentPosition(int64_t *mediaUs) {
     if (renderer == NULL) {
         return NO_INIT;
     }
+    //ALOGI("getcurrent:%s",(mStrCurrentAudioCodec != NULL) ? "dts" : "null" );
+    if ( mStrCurrentAudioCodec != NULL &&!strncmp(mStrCurrentAudioCodec,"DTS",3)) {
+        int stream_type=0;
+        int TotalApre=0;
+        int MulAssetHint=0;
+        int HPS_hint=0;
+        dtsm6_get_exchange_info(&stream_type,&TotalApre,NULL,NULL,NULL,&MulAssetHint,&HPS_hint);
+        ALOGI("%d:%d:%d:%d",stream_type,TotalApre,MulAssetHint,HPS_hint);
+        if (TotalApre != DtshdApreTotal && TotalApre>0 ) {
+            ALOGI("[%s %d]TotalApre changed:%d-->%d\n",__FUNCTION__,__LINE__,DtshdApreTotal,TotalApre);
+            DtshdApreTotal=TotalApre;
+            notifyListener(MEDIA_INFO, MEDIA_INFO_AMLOGIC_SHOW_DTS_ASSET,0,NULL);
+        }
+        if (stream_type != DtsHdStreamType) {
+            ALOGI("[%s %d]DtsHdStreamType changed:%d-->%d\n",__FUNCTION__,__LINE__,DtsHdStreamType,stream_type);
+             DtsHdStreamType=stream_type;
+             if (DtsHdStreamType == 0x0)
+                notifyListener(MEDIA_INFO, MEDIA_INFO_AMLOGIC_SHOW_DTS_ASSET,0,NULL);
+             if (DtsHdStreamType == 0x1)
+                notifyListener(MEDIA_INFO, MEDIA_INFO_AMLOGIC_SHOW_DTS_EXPRESS,0,NULL);
+             else if (DtsHdStreamType==0x2)
+                notifyListener(MEDIA_INFO, MEDIA_INFO_AMLOGIC_SHOW_DTS_HD_MASTER_AUDIO,0,NULL);
+        }
+        if (DtsHdMulAssetHint != MulAssetHint && MulAssetHint) {//TOTO:xiangliang.wang
+            ALOGI("[%s %d]MulAssetHint event send\n",__FUNCTION__,__LINE__);
+            notifyListener(MEDIA_INFO, MEDIA_INFO_AMLOGIC_SHOW_DTS_MULASSETHINT,0,NULL);
+            DtsHdMulAssetHint=MulAssetHint;
+        }
 
+        if (HPS_hint && DtsHdHpsHint == 0) {
+            notifyListener(MEDIA_INFO,MEDIA_INFO_AMLOGIC_SHOW_DTS_HPS_NOTSUPPORT,0,NULL);
+            DtsHdHpsHint=1;
+        }
+    }
     return renderer->getCurrentPosition(mediaUs);
 }
 
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayer.h b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayer.h
index 8dd17d7..5b76784 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayer.h
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayer.h
@@ -21,6 +21,7 @@
 #include <media/MediaPlayerInterface.h>
 #include <media/stagefright/foundation/AHandler.h>
 #include <NativeWindowWrapper.h>
+#include <mediainfo.h>
 
 namespace android {
 
@@ -77,6 +78,18 @@ struct AmNuPlayer : public AHandler {
     static void thread_uninterrupt();
     static int32_t interrupt_callback(android_thread_id_t thread_id);
 
+    status_t setParameter(int key, const Parcel &request);
+    status_t getParameter(int key, Parcel *reply);
+    int getintfromString8(String8 &s, const char*pre);
+    status_t getMediaInfo(Parcel* reply);
+    status_t updateMediaInfo(void);
+    //aformat_t audioTypeConvert(enum CodecID id);
+    char *mStrCurrentAudioCodec;
+    int DtshdApreTotal;
+    int DtsHdStreamType;
+    int DtsHdMulAssetHint;
+    int DtsHdHpsHint;
+
 protected:
     virtual ~AmNuPlayer();
 
@@ -88,6 +101,7 @@ public:
 
     static Mutex mThreadLock;
     static Vector<android_thread_id_t> mThreadId; // store the thread ids which need to be interrupted.
+    media_info_t        mStreamInfo;
 
 private:
     struct Decoder;
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerDriver.cpp b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerDriver.cpp
index 429fe2a..a1676bd 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerDriver.cpp
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerDriver.cpp
@@ -18,7 +18,6 @@
 #define LOG_TAG "NU-AmNuPlayerDriver"
 #include <inttypes.h>
 #include <utils/Log.h>
-
 #include "AmNuPlayerDriver.h"
 
 #include "AmNuPlayer.h"
@@ -543,13 +542,19 @@ void AmNuPlayerDriver::setAudioSink(const sp<AudioSink> &audioSink) {
     mAudioSink = audioSink;
 }
 
+
+
 status_t AmNuPlayerDriver::setParameter(
-        int /* key */, const Parcel & /* request */) {
-    return INVALID_OPERATION;
+        int key , const Parcel &  request ) {
+    Mutex::Autolock autoLock(mLock);
+    ALOGI("setParameter %d\n", key);
+    return mPlayer->setParameter(key,request);
 }
 
-status_t AmNuPlayerDriver::getParameter(int /* key */, Parcel * /* reply */) {
-    return INVALID_OPERATION;
+status_t AmNuPlayerDriver::getParameter(int  key , Parcel *  reply) {
+    Mutex::Autolock autoLock(mLock);
+    ALOGI("getParameter %d\n", key);
+    return mPlayer->getParameter(key,reply);
 }
 
 status_t AmNuPlayerDriver::getMetadata(
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerRenderer.cpp b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerRenderer.cpp
index 9bea2cb..aab413e 100755
--- a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerRenderer.cpp
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerRenderer.cpp
@@ -841,17 +841,21 @@ bool AmNuPlayer::Renderer::onDrainAudioQueue() {
     return !mAudioQueue.empty();
 }
 
+int64_t AmNuPlayer::Renderer::getDurationUsIfPlayedAtSampleRate(uint32_t numFrames) {
+    int32_t sampleRate = offloadingAudio() ?
+            mCurrentOffloadInfo.sample_rate : mCurrentPcmInfo.mSampleRate;
+    if (sampleRate == 0) {
+        ALOGE("sampleRate is 0 in %s mode", offloadingAudio() ? "offload" : "non-offload");
+        return 0;
+    }
+    // TODO: remove the (int32_t) casting below as it may overflow at 12.4 hours.
+    return (int64_t)((int32_t)numFrames * 1000000LL / sampleRate);
+}
+
+// Calculate duration of pending samples if played at normal rate (i.e., 1.0).
 int64_t AmNuPlayer::Renderer::getPendingAudioPlayoutDurationUs(int64_t nowUs) {
-#if 0
-    int64_t writtenAudioDurationUs =
-        mNumFramesWritten * 1000LL * mAudioSink->msecsPerFrame();
+    int64_t writtenAudioDurationUs = getDurationUsIfPlayedAtSampleRate(mNumFramesWritten);
     return writtenAudioDurationUs - getPlayedOutAudioDurationUs(nowUs);
-#endif
-    uint32_t numFramesPlayed;
-    mAudioSink->getPosition(&numFramesPlayed);
-    uint32_t numFramesPendingPlayout = mNumFramesWritten - numFramesPlayed;
-    int64_t realTimeOffsetUs = (mAudioSink->latency() / 2 + numFramesPendingPlayout * mAudioSink->msecsPerFrame()) * 1000ll;
-    return realTimeOffsetUs;
 }
 
 int64_t AmNuPlayer::Renderer::getRealTimeUs(int64_t mediaTimeUs, int64_t nowUs) {
@@ -914,7 +918,6 @@ void AmNuPlayer::Renderer::postDrainVideoQueue_l() {
     } else {
         int64_t mediaTimeUs;
         CHECK(entry.mBuffer->meta()->findInt64("timeUs", &mediaTimeUs));
-
         if (mAnchorTimeMediaUs < 0) {
             if (!mHasAudio) {
                 setAnchorTime(mediaTimeUs, nowUs);
@@ -937,7 +940,7 @@ void AmNuPlayer::Renderer::postDrainVideoQueue_l() {
         delayUs = realTimeUs - nowUs;
         if (mInSlowSync) {
             if (delayUs > kSlowSyncStepUs) {
-                delayUs = kSlowSyncStepUs;
+                realTimeUs = nowUs + kSlowSyncStepUs;
             }
         } else if (delayUs > 500000 && !mVideoTimeJump && !mAudioTimeJump) {
             int64_t postDelayUs = 500000;
@@ -977,13 +980,13 @@ void AmNuPlayer::Renderer::postDrainVideoQueue_l() {
     }
 
     /*realTimeUs = mVideoScheduler->schedule(realTimeUs * 1000) / 1000;*/
-    if (!mInSlowSync)/*when slowsync, do del before!!*/
-        delayUs = realTimeUs - nowUs;
+    delayUs = realTimeUs - nowUs;
     //ALOGW_IF(delayUs > 500000, "unusually high delayUs: %" PRId64, delayUs);
-
+    entry.mBuffer->meta()->setInt64("RealTimeUs", realTimeUs);
     // post 2 display refreshes before rendering is due
+    delayUs -= 2 * 1000000/30; /*send before 2 vsync,default 30hz*/
     mDrainVideoQueuePending = true;
-    msg->post(delayUs > 0 ? delayUs : 0 );
+    msg->post(delayUs > 0 ? delayUs : 0);
 
 }
 
@@ -1012,10 +1015,12 @@ void AmNuPlayer::Renderer::onDrainVideoQueue() {
         CHECK(entry->mBuffer->meta()->findInt64("timeUs", &realTimeUs));
     } else {
         int64_t mediaTimeUs;
-        CHECK(entry->mBuffer->meta()->findInt64("timeUs", &mediaTimeUs));
-        mLastVideoDrainTimeUs = mediaTimeUs;
-        nowUs = ALooper::GetNowUs();
-        realTimeUs = getRealTimeUs(mediaTimeUs, nowUs);
+        if (!entry->mBuffer->meta()->findInt64("RealTimeUs", &realTimeUs)) {
+            CHECK(entry->mBuffer->meta()->findInt64("timeUs", &mediaTimeUs));
+            mLastVideoDrainTimeUs = mediaTimeUs;
+            nowUs = ALooper::GetNowUs();
+            realTimeUs = getRealTimeUs(mediaTimeUs, nowUs);
+        }
     }
 
     bool tooLate = false;
@@ -1064,7 +1069,7 @@ void AmNuPlayer::Renderer::onDrainVideoQueue() {
         }
     }
 
-    entry->mNotifyConsumed->setInt64("timestampNs", nowUs * 1000ll);
+    entry->mNotifyConsumed->setInt64("timestampNs", realTimeUs * 1000ll);
     entry->mNotifyConsumed->setInt32("render", 1); // render anyhow
     entry->mNotifyConsumed->post();
     mVideoQueue.erase(mVideoQueue.begin());
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerRenderer.h b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerRenderer.h
index e8f3681..6ebf8e2 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerRenderer.h
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerRenderer.h
@@ -256,6 +256,7 @@ private:
     size_t fillAudioBuffer(void *buffer, size_t size);
 
     bool onDrainAudioQueue();
+    int64_t getDurationUsIfPlayedAtSampleRate(uint32_t numFrames);
     int64_t getPendingAudioPlayoutDurationUs(int64_t nowUs);
     int64_t getPlayedOutAudioDurationUs(int64_t nowUs);
     void postDrainAudioQueue_l(int64_t delayUs = 0);
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerSource.h b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerSource.h
index c194abc..ff28c9a 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerSource.h
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/AmNuPlayerSource.h
@@ -78,6 +78,9 @@ struct AmNuPlayer::Source : public AHandler {
     // Explicitly disconnect the underling data source
     virtual void disconnect() {}
 
+    // for http disconnect
+    virtual void release() {}
+
     // Returns OK iff more data was available,
     // an error or ERROR_END_OF_STREAM if not.
     virtual status_t feedMoreTSData() = 0;
diff --git a/amlogic/frameworks/av/media/Am-NuPlayer/Android.mk b/amlogic/frameworks/av/media/Am-NuPlayer/Android.mk
index b66d404..3a5ab5e 100644
--- a/amlogic/frameworks/av/media/Am-NuPlayer/Android.mk
+++ b/amlogic/frameworks/av/media/Am-NuPlayer/Android.mk
@@ -25,8 +25,8 @@ LOCAL_C_INCLUDES := \
 	$(TOP)/frameworks/native/include/media/openmax                \
     $(TOP)/external/curl/include                                  \
     $(TOP)/vendor/amlogic/frameworks/av/LibPlayer/third_parts/libcurl-ffmpeg/include \
-    $(TOP)/vendor/amlogic/frameworks/av/LibPlayer/amavutils/include
-
+    $(TOP)/vendor/amlogic/frameworks/av/LibPlayer/amavutils/include \
+    $(TOP)/vendor/amlogic/frameworks/av/LibPlayer/amffmpeg
 LOCAL_SHARED_LIBRARIES := \
         libbinder \
         libcrypto \
@@ -63,4 +63,4 @@ include $(BUILD_SHARED_LIBRARY)
 
 ################################################
 
-include $(call all-makefiles-under,$(LOCAL_PATH))
\ No newline at end of file
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/amlogic/frameworks/av/media/AmSuperPlayer.cpp b/amlogic/frameworks/av/media/AmSuperPlayer.cpp
index 10f3ab7..310495a 100644
--- a/amlogic/frameworks/av/media/AmSuperPlayer.cpp
+++ b/amlogic/frameworks/av/media/AmSuperPlayer.cpp
@@ -129,20 +129,10 @@ status_t    AmSuperPlayer::setDataSource(const sp<IMediaHTTPService> &httpServic
 	Mutex::Autolock l(mMutex);
 	TRACE();
 	mHTTPService = httpService;
-	if(muri!=NULL) free((void*)muri);
-	if((strncmp(uri,"http://",7)==0 || strncmp(uri,"https://",8)==0) &&
-		!IS_LOCAL_HTTP(uri) && /*not local http server.*/
-		PropIsEnable("media.amplayer.widevineenable")&&!IsManifestUrl(uri)&&
-		!strstr(uri, ".m3u8")){
-		char *turi;
-		turi=(char *)malloc(strlen(uri)+16);
-		sprintf(turi,"widevine%s",strchr(uri,':'));///changed the xxxx://..... to widevine:///
-		muri=turi;
-		mOUrl=uri;
-		isSwitchURL=true;
-	}else{
-		muri=strdup(uri);
-	}
+	isSwitchURL=false;
+	if (muri != NULL)
+		free((void*)muri);
+	muri=strdup(uri);
 	if (headers) {
         mheaders = *headers;
     }
@@ -536,6 +526,15 @@ void AmSuperPlayer::Notify(void* cookie, int msg, int ext1, int ext2,const Parce
 	TRACE();
 	Mutex::Autolock N(mNotifyMutex);
 	LOGV("cookie=%p,msg=%x,ext1=%x,ext2=%x\n",cookie,msg,ext1,ext2);
+	if (msg == MEDIA_BLURAY_INFO) {
+		if ((mPlayer == NULL) && (oldmsg_num < 9) && (!subplayer_inited)) {
+			oldmsg[oldmsg_num].msg=msg;
+			oldmsg[oldmsg_num].ext1=ext1;
+			oldmsg[oldmsg_num].ext2=ext2;
+			oldmsg[oldmsg_num].obj=obj;
+			oldmsg_num++;
+		}
+	}
 	switch(msg){
 			case MEDIA_NOP:	
 				break;
@@ -712,7 +711,7 @@ player_type AmSuperPlayer::SuperGetPlayerType(char *type,int videos,int audios)
                     && !strstr(type, "hevc"))   /* hevc/h.265 in ts format not support by libplayer now */
             return AMLOGIC_PLAYER;
         //}
-        if (PropIsEnable("media.amplayer.widevineenable") && match_codecs(type, "drm,DRM,DRMdemux"))
+        if (match_codecs(type, "drm,DRM,DRMdemux"))
             return AMLOGIC_PLAYER;	/* 	if DRM allways goto AMLOGIC_PLAYER	*/
         else if (match_codecs(type, "Demux_no_prot")) {
             return AMLOGIC_PLAYER;  //for SS
@@ -909,29 +908,23 @@ Retry:
 				FileTypeReady=!amplayer->GetFileType(&filetype,&mvideo,&maudio);
 				TRACE();		
 		}
-		if(FileTypeReady){
+		if (FileTypeReady) {
 			LOGV("SuperGetPlayerType:type=%s,videos=%d,audios=%d\n",filetype,mvideo,maudio);
 			newtype=SuperGetPlayerType(filetype,mvideo,maudio);
 			LOGV("GET New type =%d\n",newtype);
-			if(isSwitchURL)
-			{
-				/*in drm switch mode,and if not drm,we may need to more check,*/
-				if(strstr(filetype,"DRMdemux")==NULL && strcasestr(filetype,"drm")==NULL &&  mOUrl.length()>0)
-				{	/*not drm streaming,goto old url,*/
-					if(muri!=NULL) free((void*)muri);
-					muri=strdup(mOUrl.string());
-					needretry=1;	
-					isSwitchURL=false;
+			if (filetype && strncmp(filetype,"DRMdemux", 8) == 0 && isSwitchURL == false && muri) {
+				needretry=1;
+				LOGE("widevine retry set Data Source muri %s\n", muri);
+				if (strncmp(muri,"http://",7) == 0 || strncmp(muri,"https://",8) == 0) {
+					char *turi;
+					turi=(char *)malloc(strlen(muri)+16);
+					sprintf(turi,"widevine%s",strchr(muri,':'));///changed the xxxx://..... to widevine:///
+					muri=turi;
+					LOGE("widevine after switch url %s\n", muri);
 				}
+				isSwitchURL=true;
 			}
-		}else if(isSwitchURL && mOUrl.length()>0){		
-		 	/*is switched url for widevine,switched to orignal url,and try again*/
-			if(muri!=NULL) free((void*)muri);
-			muri=strdup(mOUrl.string());
-			needretry=1;	
-			isSwitchURL=false;
-		}else{
-			
+		} else {
 			newtype=SuperGetPlayerType(NULL,0,0);
 		}
 	}
diff --git a/amlogic/frameworks/av/media/AmlogicPlayer.cpp b/amlogic/frameworks/av/media/AmlogicPlayer.cpp
index f962593..b21dec3 100644
--- a/amlogic/frameworks/av/media/AmlogicPlayer.cpp
+++ b/amlogic/frameworks/av/media/AmlogicPlayer.cpp
@@ -217,6 +217,7 @@ AmlogicPlayer::AmlogicPlayer() :
     DtsHdStreamType=0;
     DtsHdMulAssetHint=0;
     DtsHdHpsHint=0;
+    mParcel = NULL;
     AudioDualMonoNeed=0;
     AudioDualMonoSetOK=0;
     mPlaybackSettings = AUDIO_PLAYBACK_RATE_DEFAULT;
@@ -364,7 +365,10 @@ int IsTheSameVfmPathDefault(char * path)
     return 1;
 }
 
+#define DISABLE_VIDEO "/sys/class/video/disable_video"
+
 typedef void *(*DTVPRelease)();
+int set_sys_int(const char *path, int val);
 
 void CheckTVPEnable()
 {
@@ -382,6 +386,8 @@ void CheckTVPEnable()
             if (TVPRelease)
                 TVPRelease();
         }
+        set_sys_int(DISABLE_VIDEO, 1);
+        free_cma_buffer();
         tvp_mm_disable(0);
     }
 }
@@ -543,7 +549,7 @@ bool IsVrVmUrl( const char* url) {
      else return false;
 }
 
-#define DISABLE_VIDEO "/sys/class/video/disable_video"
+
 void
 AmlogicPlayer::VideoViewOn(void)
 {
@@ -608,6 +614,10 @@ AmlogicPlayer::~AmlogicPlayer()
 {
     LOGV("AmlogicPlayer destructor\n");
     Mutex::Autolock l(mMutex);
+    if (mParcel != NULL) {
+        delete mParcel;
+        mParcel = NULL;
+    }
     release();
     if (mStrCurrentAudioCodec) {
         free(mStrCurrentAudioCodec);
@@ -666,8 +676,7 @@ status_t AmlogicPlayer::setDataSource(const sp<IMediaHTTPService> &httpService,
     if (PropIsEnable("media.amplayer.useandroidhttp") &&  !strncmp(uri, "http://", strlen("http://"))) {
         mSouceProtocol = AmlogicPlayerDataSouceProtocol::CreateFromUrl(mHTTPService,uri, headers);
         return setdatasource(mSouceProtocol->GetPathString(), -1, 0, 0x7ffffffffffffffLL, NULL);
-    } else if ((PropIsEnable("media.amplayer.widevineenable") &&
-                !strncmp(uri, "widevine://", strlen("widevine://"))) && !isNormalHLS) {
+    } else if (!strncmp(uri, "widevine://", strlen("widevine://")) && !isNormalHLS) {
         mSouceProtocol = AmlogicPlayerDataSouceProtocol::CreateFromUrl(mHTTPService,uri, headers);
         if (mSouceProtocol.get() != NULL) {
             mPlay_ctl.auto_buffing_enable = 1;
@@ -964,6 +973,38 @@ int AmlogicPlayer::NotifyHandle(int pid, int msg, unsigned long ext1, unsigned l
         free(sub);
     }
     break;
+    case PLAYER_EVENTS_BLURAY_INFO: {
+        LOGD("PLAYER_EVENTS_BLURAY_INFO");
+        bluray_info_t *info = (bluray_info_t *)ext1;
+        switch (info->info) {
+            case BLURAY_STREAM_PATH: {
+                if (mParcel != NULL)
+                    delete mParcel;
+                mParcel = new Parcel();
+                mParcel->freeData();
+                mParcel->writeString16(String16(info->stream_path));
+                mParcel->writeInt32(info->stream_info_num);
+                for (int i = 0; i < info->stream_info_num; i++) {
+                    mParcel->writeInt32(info->stream_info[i].type);
+                    mParcel->writeString16(String16(info->stream_info[i].lang));
+                }
+                mParcel->writeInt32(info->chapter_num);
+                for (int i = 0; i < info->chapter_num; i++) {
+                    mParcel->writeInt32(info->chapter_info[i].start);
+                    mParcel->writeInt32(info->chapter_info[i].duration);
+                }
+
+                if (mParcel->dataSize() > 0)
+                    sendEvent(MEDIA_BLURAY_INFO, MEDIA_INFO_AMLOGIC_BLURAY_STREAM_PATH, 0, mParcel);
+                else
+                    sendEvent(MEDIA_BLURAY_INFO, MEDIA_INFO_AMLOGIC_BLURAY_STREAM_PATH, 0, NULL);
+                break;
+            }
+            default:
+                break;
+        }
+        break;
+    }
     default:
         break;
     }
@@ -2172,6 +2213,7 @@ status_t AmlogicPlayer::getTrackInfo(Parcel* reply) const
     //trackCount+=
     LOGE("track_count:%d \n", trackCount);
     reply->writeInt32(trackCount);
+    char *lang = "und";
     for (int i = 0; i < mStreamInfo.stream_info.nb_streams; ++i) {
 
 
@@ -2189,11 +2231,16 @@ status_t AmlogicPlayer::getTrackInfo(Parcel* reply) const
         }
         if (mhasAudio) {
             for (int m = 0; m < mStreamInfo.stream_info.total_audio_num; m++) {
+				char *p8tmp=NULL;
                 if (i == mStreamInfo.audio_info[m]->index) {
                     reply->writeInt32(2); // 2 fields
                     reply->writeInt32(MEDIA_TRACK_TYPE_AUDIO);
                     reply->writeString16(String16("audio/"));
-                    reply->writeString16(String16("und"));
+                    if (strlen(mStreamInfo.audio_info[m]->language))
+                         p8tmp = mStreamInfo.audio_info[m]->language;
+                    else
+                         p8tmp = lang;
+                    reply->writeString16(String16(p8tmp));
                     //continue;
                     break;
                 }
@@ -2202,12 +2249,17 @@ status_t AmlogicPlayer::getTrackInfo(Parcel* reply) const
         //need to judge type, support 3gpp inband sub only
         if (mhasSub) {
             for (int m = 0; m < mStreamInfo.stream_info.total_sub_num; m++) {
+				char *p8tmp=NULL;
                 if (i == mStreamInfo.sub_info[m]->index) {
                     reply->writeInt32(2); // 2 fields
                     reply->writeInt32(MEDIA_TRACK_TYPE_TIMEDTEXT);
                     LOGE("we found 3gpp sub index:%d  id:%d  i:%d \n", mStreamInfo.sub_info[m]->index, mStreamInfo.sub_info[m]->id, i);
                     reply->writeString16(String16("text/"));
-                    reply->writeString16(String16("und"));
+                    if (strlen(mStreamInfo.sub_info[m]->sub_language))
+                       p8tmp = mStreamInfo.sub_info[m]->sub_language;
+                    else
+                       p8tmp = lang;
+                    reply->writeString16(String16(p8tmp));
                     break;
                     //continue;
                 }
diff --git a/amlogic/frameworks/av/media/AmlogicPlayer.h b/amlogic/frameworks/av/media/AmlogicPlayer.h
index 825ad8c..34ad5a9 100644
--- a/amlogic/frameworks/av/media/AmlogicPlayer.h
+++ b/amlogic/frameworks/av/media/AmlogicPlayer.h
@@ -284,6 +284,7 @@ private:
 
     bool mAuto3DDetected;
     int64_t mSeekPos;
+    Parcel* mParcel;
 };
 
 }; // namespace android
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/HdmiCecManager.java b/amlogic/frameworks/core/java/com/droidlogic/app/HdmiCecManager.java
index 42b5b67..4c57a0d 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/HdmiCecManager.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/HdmiCecManager.java
@@ -12,7 +12,10 @@ import java.lang.reflect.Method;
 public class HdmiCecManager {
     private static final boolean DEBUG = true;
     private static final String TAG = "HdmiCecManager";
-
+    //switch box cec control
+    public static final String HDMI_CONTROL_ONE_TOUCH_PLAY_ENABLED = "hdmi_control_one_touch_play_enabled";
+    public static final String HDMI_CONTROL_AUTO_CHANGE_LANGUAGE_ENABLED = "hdmi_control_auto_change_language_enabled";
+    //CEC device node
     public static final String CEC_DEVICE_FILE = "/sys/devices/virtual/switch/lang_config/state";
     public static final String CEC_SYS = "/sys/class/amhdmitx/amhdmitx0/cec_config";
     public static final String CEC_SUPPORT = "/sys/class/amhdmitx/amhdmitx0/tv_support_cec";
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/ImagePlayerManager.java b/amlogic/frameworks/core/java/com/droidlogic/app/ImagePlayerManager.java
index 8e9a371..052f788 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/ImagePlayerManager.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/ImagePlayerManager.java
@@ -1,6 +1,9 @@
 package com.droidlogic.app;
 
+import java.io.File;
+
 import android.content.Context;
+import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Binder;
 import android.os.IBinder;
@@ -14,6 +17,7 @@ public class ImagePlayerManager {
     private static final String TAG                 = "ImagePlayerManager";
 
     private static final String IMAGE_TOKEN         = "droidlogic.IImagePlayerService";
+    public static final int PERMISSION_DENIED_ERROR = -0xfffd;
     public static final int ARGUMENTS_ERROR         = -0xfffe;
     public static final int REMOTE_EXCEPTION        = -0xffff;
     int TRANSACTION_INIT                            = IBinder.FIRST_CALL_TRANSACTION;
@@ -117,6 +121,12 @@ public class ImagePlayerManager {
 
     //url start with http:// or https://
     public int setDataSourceURL(String url) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERNET)
+                != PackageManager.PERMISSION_GRANTED) {
+            Log.e(TAG, "setDataSourceURL Internet Permission Denial from pid="
+                + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
+            return PERMISSION_DENIED_ERROR;
+        }
         try {
             if (null != mIBinder) {
                 Parcel data = Parcel.obtain();
@@ -148,11 +158,16 @@ public class ImagePlayerManager {
         if (path.startsWith("http://") || path.startsWith("https://"))
             return setDataSourceURL(path);//it is a network picture
 
-        if (!path.startsWith("file://")) {
-            path = "file://" + path;
+        final File file = new File(path);
+        if (file.exists()) {
+            if (!path.startsWith("file://")) {
+                path = "file://" + path;
+            }
+            return _setDataSource(path);
+        } else {
+            Log.e(TAG, "dataSource file path:" + path + " not exists, setDataSource failed.");
+            return ARGUMENTS_ERROR;
         }
-
-        return _setDataSource(path);
     }
 
     private int _setDataSource(String path) {
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/MediaPlayerExt.java b/amlogic/frameworks/core/java/com/droidlogic/app/MediaPlayerExt.java
index 6f4340d..a8395b2 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/MediaPlayerExt.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/MediaPlayerExt.java
@@ -578,7 +578,7 @@ public class MediaPlayerExt extends MediaPlayer {
     }
 
     //must different with message value defined in MediaPlayer.java
-    private static final int MEDIA_BLURAY_INFO = 202;
+    private static final int MEDIA_BLURAY_INFO = 203;
     private class EventHandler extends Handler {
         private MediaPlayer mMediaPlayer;
 
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/OutputModeManager.java b/amlogic/frameworks/core/java/com/droidlogic/app/OutputModeManager.java
index ab6cb25..38e0b17 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/OutputModeManager.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/OutputModeManager.java
@@ -224,8 +224,7 @@ public class OutputModeManager {
         }
 
         int type = -1;
-        int intMode = -1;
-        int higMode = 0;
+        int intMode = -1, higMode = 0, lenMode = 0;
         String outputMode = null;
         if (supportList != null) {
             for (int i = 0; i < supportList.length; i++) {
@@ -233,17 +232,20 @@ public class OutputModeManager {
                 if (pref != null) {
                     if ((type = supportList[i].indexOf(FORMAT_P)) >= 3) {          //p
                         intMode = Integer.parseInt(pref[0].replace(FORMAT_P, "1"));
-                    } else if (type > 0) {                                          //smpte
-                        outputMode = "smpte24hz";
-                        break;
                     } else if ((type = supportList[i].indexOf(FORMAT_I)) > 0) {    //i
                         intMode = Integer.parseInt(pref[0].replace(FORMAT_I, "0"));
                     } else {                                                        //other
                         continue;
                     }
-                    if (intMode > higMode) {
+                    if (intMode >= higMode) {
+                        int len = supportList[i].length();
+                        if (intMode == higMode && lenMode >= len) continue;
+                        lenMode = len;
                         higMode = intMode;
-                        outputMode = pref[0] + KEY;
+                        if (supportList[i].contains("*"))
+                        	outputMode = supportList[i].substring(0, supportList[i].length()-1);
+                        else
+                        	outputMode = supportList[i];
                     }
                 }
             }
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/UsbCameraManager.java b/amlogic/frameworks/core/java/com/droidlogic/app/UsbCameraManager.java
index 0b8766c..c4fbc25 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/UsbCameraManager.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/UsbCameraManager.java
@@ -221,6 +221,8 @@ public class UsbCameraManager {
                     for (int i = 0; i < ACTIVITIES.length; i++) {
                         enableComponent(PACKAGES[i], ACTIVITIES[i]);
                     }
+                    ActivityManager am = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+                    am.forceStopPackage("com.skype.rover");
                     end = true;
                 }
                 else if (!mIsAttach && (devNum < mCamNum)) {//device path has been deleted by kernel
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/tv/ChannelInfo.java b/amlogic/frameworks/core/java/com/droidlogic/app/tv/ChannelInfo.java
index f633cbf..fc2ca1c 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/tv/ChannelInfo.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/tv/ChannelInfo.java
@@ -98,6 +98,7 @@ public class ChannelInfo {
     public static final String LABEL_HDMI1 = "HDMI1";
     public static final String LABEL_HDMI2 = "HDMI2";
     public static final String LABEL_HDMI3 = "HDMI3";
+    public static final String LABEL_SPDIF = "SPDIF";
 
     private long mId;
     private String mInputId;
@@ -535,6 +536,7 @@ public class ChannelInfo {
         mDisplayNumber = number;
         mNumber = stringToInteger(number);
     }
+
     public void setDisplayName(String name) {
         mDisplayName = name;
     }
@@ -543,6 +545,10 @@ public class ChannelInfo {
         mDisplayNameMulti = mDisplayNameMulti.replace(getDisplayNameLocal(), name);
     }
 
+    public void setDisplayNameMulti(String name) {
+        mDisplayNameMulti = name;
+    }
+
     public void setVideoStd(int std) {
         mVideoStd = std;
     }
@@ -599,6 +605,30 @@ public class ChannelInfo {
         mIsFavourite = enable;
     }
 
+    public void setSubtitleTypes(int[] types) {
+        mSubtitleTypes = types;
+    }
+
+    public void setSubtitlePids(int[] pids) {
+        mSubtitlePids = pids;
+    }
+
+    public void setSubtitleStypes(int[] types) {
+        mSubtitleStypes = types;
+    }
+
+    public void setSubtitleId1s(int[] id1s) {
+        mSubtitleId1s = id1s;
+    }
+
+    public void setSubtitleId2s(int[] id2s) {
+        mSubtitleId2s = id2s;
+    }
+
+    public void setSubtitleLangs(String[] langs) {
+        mSubtitleLangs = langs;
+    }
+
     public void setSubtitleTrackIndex(int index) {
         mSubtitleTrackIndex = index;
     }
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/tv/DroidLogicTvInputService.java b/amlogic/frameworks/core/java/com/droidlogic/app/tv/DroidLogicTvInputService.java
index 0ecac3c..9b25f7a 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/tv/DroidLogicTvInputService.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/tv/DroidLogicTvInputService.java
@@ -29,6 +29,18 @@ import android.text.TextUtils;
 import android.util.Log;
 import android.util.SparseArray;
 import android.media.tv.TvContract.Channels;
+import android.app.ActivityManager;
+import android.view.Surface;
+import android.net.Uri;
+import com.android.internal.os.SomeArgs;
+import android.os.Handler;
+import android.os.Message;
+import android.hardware.hdmi.HdmiControlManager;
+import android.hardware.hdmi.HdmiTvClient;
+import android.provider.Settings.Global;
+import android.hardware.hdmi.HdmiDeviceInfo;
+import android.hardware.hdmi.HdmiTvClient.SelectCallback;
+import java.util.HashMap;
 
 public class DroidLogicTvInputService extends TvInputService implements
         TVInSignalInfo.SigInfoChangeListener, TvControlManager.StorDBEventListener,
@@ -47,6 +59,18 @@ public class DroidLogicTvInputService extends TvInputService implements
     private int mDeviceId = -1;
     private String mInputId;
 
+    private SurfaceHandler mSessionHandler;
+    private static final int MSG_DO_TUNE = 0;
+    private static final int MSG_DO_SET_SURFACE = 3;
+    private static final int RETUNE_TIMEOUT = 20; // 1 second
+    private static int mSelectPort = -1;
+    private int timeout = RETUNE_TIMEOUT;
+    private Surface mSurface;
+    protected int ACTION_FAILED = -1;
+    protected int ACTION_SUCCESS = 1;
+    private Context mContext;
+    private int mCurrentSessionId = 0;
+
     private int c_displayNum = DISPLAY_NUM_START_DEF;
     private TvDataBaseManager mTvDataBaseManager;
     private TvControlManager mTvControlManager;
@@ -72,6 +96,7 @@ public class DroidLogicTvInputService extends TvInputService implements
      */
     @Override
     public Session onCreateSession(String inputId) {
+        mContext = getApplicationContext();
         TvInputManager tm = (TvInputManager)this.getSystemService(Context.TV_INPUT_SERVICE);
         mCurrentInputId = inputId;
 
@@ -84,6 +109,7 @@ public class DroidLogicTvInputService extends TvInputService implements
         mDeviceId = getHardwareDeviceId(inputId);
         mHardware = tm.acquireTvInputHardware(mDeviceId, mHardwareCallback, tm.getTvInputInfo(inputId));
 
+        mSessionHandler = new SurfaceHandler();
         return null;
     }
 
@@ -94,11 +120,12 @@ public class DroidLogicTvInputService extends TvInputService implements
     protected void registerInputSession(TvInputBaseSession session) {
         Log.d(TAG, "registerInputSession");
         mSession = session;
+        mCurrentSessionId = session.mId;
         mTvControlManager = TvControlManager.getInstance();
         mTvControlManager.SetSigInfoChangeListener(this);
         mTvControlManager.setStorDBListener(this);
         mTvControlManager.setScanningFrameStableListener(this);
-        mTvDataBaseManager = new TvDataBaseManager(getApplicationContext());
+        mTvDataBaseManager = new TvDataBaseManager(mContext);
     }
 
     /**
@@ -174,6 +201,9 @@ public class DroidLogicTvInputService extends TvInputService implements
         case DroidLogicTvUtils.DEVICE_ID_HDMI3:
             label = ChannelInfo.LABEL_HDMI3;
             break;
+        case DroidLogicTvUtils.DEVICE_ID_SPDIF:
+            label = ChannelInfo.LABEL_SPDIF;
+            break;
         default:
             break;
         }
@@ -184,9 +214,7 @@ public class DroidLogicTvInputService extends TvInputService implements
         if (TextUtils.isEmpty(cls_name))
             return null;
         ResolveInfo ret_ri = null;
-        Context context = getApplicationContext();
-
-        PackageManager pm = context.getPackageManager();
+        PackageManager pm = getApplicationContext().getPackageManager();
         List<ResolveInfo> services = pm.queryIntentServices(
                 new Intent(TvInputService.SERVICE_INTERFACE),
                 PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
@@ -1087,5 +1115,142 @@ public class DroidLogicTvInputService extends TvInputService implements
 
     public void onUpdateCurrentChannel(ChannelInfo channel, boolean store) {}
 
+    protected  boolean setSurfaceInService(Surface surface, TvInputBaseSession session ) {
+        Log.d(TAG, "SetSurface");
+        Message message = mSessionHandler.obtainMessage();
+        message.what = MSG_DO_SET_SURFACE;
+
+        SomeArgs args = SomeArgs.obtain();
+        args.arg1 = surface;
+        args.arg2 = session;
+
+        message.obj = args;
+        mSessionHandler.sendMessage(message);
+        return false;
+    }
+
+    protected  boolean doTuneInService(Uri channelUri, int sessionId) {
+        if (DEBUG)
+            Log.d(TAG, "onTune, channelUri=" + channelUri);
+
+        mSessionHandler.obtainMessage(MSG_DO_TUNE, sessionId, 0, channelUri).sendToTarget();
+        return false;
+    }
+
+    private final class SurfaceHandler extends Handler {
+        @Override
+        public void handleMessage(Message message) {
+        if (DEBUG)
+            Log.d(TAG, "handleMessage, msg.what=" + message.what);
+        switch (message.what) {
+            case MSG_DO_TUNE:
+                mSessionHandler.removeMessages(MSG_DO_TUNE);
+                doTune((Uri)message.obj, message.arg1);
+                break;
+            case MSG_DO_SET_SURFACE:
+                SomeArgs args = (SomeArgs) message.obj;
+                doSetSurface((Surface)args.arg1, (TvInputBaseSession)args.arg2);
+                break;
+            }
+        }
+    }
+    private void doSetSurface(Surface surface, TvInputBaseSession session) {
+        Log.d(TAG, "doSetSurface inputId=" + mInputId + " number=" + session.mId + " surface=" + surface);
+        timeout = RETUNE_TIMEOUT;
+
+        if (surface != null && !surface.isValid()) {
+            Log.d(TAG, "onSetSurface get invalid surface");
+            return;
+        } else if (surface != null) {
+            registerInputSession(session);
+            setCurrentSessionById(mSession.mId);
+        }
+
+        mSurface = surface;
+
+        if (mSurface == null && mHardware != null && session.mId == mSession.mId) {
+            Log.d(TAG, "surface is null, so stop TV play");
+            stopTvPlay(session.mId);
+        }
+    }
+
+    public int doTune(Uri uri, int sessionId) {
+        Log.d(TAG, "doTune, uri = " + uri);
+        if (mConfigs == null || startTvPlay() == ACTION_FAILED) {
+            Log.d(TAG, "doTune failed, timeout=" + timeout + ", retune 50ms later ...");
+
+            if (timeout > 0) {
+                Message msg = mSessionHandler.obtainMessage(MSG_DO_TUNE, uri);
+                mSessionHandler.sendMessageDelayed(msg, 50);
+                timeout--;
+                return ACTION_FAILED;
+            }
+        }
+        doTuneFinish(ACTION_SUCCESS, uri, sessionId);
+        return ACTION_SUCCESS;
+    }
+
+    private int startTvPlay() {
+        Log.d(TAG, "startTvPlay inputId=" + mInputId + " surface=" + mSurface);
+        if (mHardware != null && mSurface != null && mSurface.isValid()) {
+            mHardware.setSurface(mSurface, mConfigs[0]);
+            selectHdmiDevice(mDeviceId);
+            return ACTION_SUCCESS;
+        }
+        return ACTION_FAILED;
+    }
+
+    private int stopTvPlay(int sessionId) {
+        if (mHardware != null) {
+            mHardware.setSurface(null, null);
+        } else {
+            tvPlayStopped(sessionId);
+        }
+        selectHdmiDevice(-1);
+        return ACTION_SUCCESS;
+    }
+    public void setCurrentSessionById(int sessionId){}
+    public void doTuneFinish(int result, Uri uri, int sessionId){};
+    public void tvPlayStopped(int sessionId){};
+
+    protected int getCurrentSessionId() {
+        return mCurrentSessionId;
+    }
+
+    private boolean isInTvApp() {
+        ActivityManager am = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningTaskInfo> runTaskInfos = am.getRunningTasks(1);
+        ActivityManager.RunningTaskInfo runningTaskInfo = runTaskInfos.get(0);
+        return runningTaskInfo.topActivity.getPackageName().equals("com.droidlogic.tvsource");
+    }
+
+    public void selectHdmiDevice(final int port) {
+        int devAddr = 0;
+        if (!isInTvApp()) return;
+        HdmiControlManager manager = (HdmiControlManager) this.getSystemService(Context.HDMI_CONTROL_SERVICE);
+        if (manager == null) return;
+        HdmiTvClient client = manager.getTvClient();
+        boolean cecOption = (Global.getInt(this.getContentResolver(), Global.HDMI_CONTROL_ENABLED, 1) == 1);
+        if (!cecOption || client == null) return;
+        if (port >= DroidLogicTvUtils.DEVICE_ID_HDMI1) {
+            int id = port - DroidLogicTvUtils.DEVICE_ID_HDMI1 + 1;
+            for (HdmiDeviceInfo info : client.getDeviceList()) {
+                if (id == (info.getPhysicalAddress() >> 12)) {
+                    devAddr = info.getLogicalAddress();
+                }
+            }
+        }
+        if (mSelectPort < 0 && devAddr == 0) return;
+        if (mSelectPort != port) {
+            final int addr = devAddr;
+            client.deviceSelect(devAddr, new SelectCallback() {
+                @Override
+                public void onComplete(int result) {
+                    if (addr == 0) mSelectPort = -1;
+                    else mSelectPort = port;
+                }
+            });
+        }
+    }
 }
 
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/tv/DroidLogicTvUtils.java b/amlogic/frameworks/core/java/com/droidlogic/app/tv/DroidLogicTvUtils.java
index 4096939..5ec4e76 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/tv/DroidLogicTvUtils.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/tv/DroidLogicTvUtils.java
@@ -81,13 +81,14 @@ public class DroidLogicTvUtils
     public static final int SIG_INFO_TYPE_DTV    = 1;
     public static final int SIG_INFO_TYPE_HDMI   = 2;
     public static final int SIG_INFO_TYPE_AV     = 3;
-    public static final int SIG_INFO_TYPE_OTHER  = 4;
+    public static final int SIG_INFO_TYPE_SPDIF  = 4;
+    public static final int SIG_INFO_TYPE_OTHER  = 5;
 
     /**
      * source input type need to switch
      */
     private static final int SOURCE_TYPE_START  = 0;
-    private static final int SOURCE_TYPE_END    = 7;
+    private static final int SOURCE_TYPE_END    = 8;
 
     public static final int SOURCE_TYPE_ATV     = SOURCE_TYPE_START;
     public static final int SOURCE_TYPE_DTV     = SOURCE_TYPE_START + 1;
@@ -96,6 +97,7 @@ public class DroidLogicTvUtils
     public static final int SOURCE_TYPE_HDMI1   = SOURCE_TYPE_START + 4;
     public static final int SOURCE_TYPE_HDMI2   = SOURCE_TYPE_START + 5;
     public static final int SOURCE_TYPE_HDMI3   = SOURCE_TYPE_START + 6;
+    public static final int SOURCE_TYPE_SPDIF   = SOURCE_TYPE_START + 7;
     public static final int SOURCE_TYPE_OTHER   = SOURCE_TYPE_END;
 
     /**
@@ -108,6 +110,7 @@ public class DroidLogicTvUtils
     public static final int DEVICE_ID_HDMI2      = 6;
     public static final int DEVICE_ID_HDMI3      = 7;
     public static final int DEVICE_ID_DTV        = 10;
+    public static final int DEVICE_ID_SPDIF      = 14;
 
     public static final int RESULT_OK = 1;
     public static final int RESULT_UPDATE = 2;
@@ -141,6 +144,7 @@ public class DroidLogicTvUtils
     public static final String ACTION_ATV_RESUME_SCAN = "atv_resume_scan";
     public static final String ACTION_STOP_SCAN = "stop_scan";
     public static final String PARA_MANUAL_SCAN = "scan_freq";
+    public static final String ACTION_DTV_AUTO_TRACKS = "dtv_auto_tracks";
 
     /**
      * Other extra names for {@link TvInputInfo.createSetupIntent#intent} except for input id.
@@ -163,7 +167,7 @@ public class DroidLogicTvUtils
      * used for TvSettings to switch hdmi source
      * {@link #SOURCE_NAME}
      */
-    public static final String SOURCE_NAME = "source";
+    public static final String SOURCE_INPUT_ID = "id";
 
     /**
      * used for table {@link Settings#System}.
@@ -269,6 +273,9 @@ public class DroidLogicTvUtils
             case DEVICE_ID_HDMI3:
                 ret = SOURCE_TYPE_HDMI3;
                 break;
+            case DEVICE_ID_SPDIF:
+                ret = SOURCE_TYPE_SPDIF;
+                break;
             default:
                 break;
         }
@@ -293,6 +300,9 @@ public class DroidLogicTvUtils
             case SOURCE_TYPE_HDMI3:
                 ret = SIG_INFO_TYPE_HDMI;
                 break;
+            case SOURCE_TYPE_SPDIF:
+                ret = SIG_INFO_TYPE_SPDIF;
+                break;
             default:
                 ret = SIG_INFO_TYPE_OTHER;
                 break;
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TVMultilingualText.java b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TVMultilingualText.java
index 30e1cb3..c145e97 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TVMultilingualText.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TVMultilingualText.java
@@ -119,13 +119,15 @@ public class TVMultilingualText{
         return ret;
     }
 
+    private static final Locale HK_LOCAL = new Locale("zh", "HK");
     public static String getLocalLang() {
         String lang;
         Locale defaultLocale = Locale.getDefault();
         /* recover lang by the current local Android language */
         if (defaultLocale.equals(Locale.SIMPLIFIED_CHINESE)) {
             lang = "chs";
-        }else if (defaultLocale.equals(Locale.TRADITIONAL_CHINESE)) {
+        }else if (defaultLocale.equals(Locale.TRADITIONAL_CHINESE) ||
+            defaultLocale.equals(HK_LOCAL)) {
             lang = "chi";
         }else{
             lang = Locale.getDefault().getISO3Language();
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvControlCommand.java b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvControlCommand.java
index e02c86f..dd73c56 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvControlCommand.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvControlCommand.java
@@ -18,7 +18,7 @@ public interface TvControlCommand {
     int IS_VGA_TIMEING_IN_HDMI = 14;
     int GET_VIDEO_PATH_STATUS = 15;
     //int GET_VIDEO_STREAM_STATUS = 16;
-    //int GET_FIRST_START_SWITCH_TYPE = 17;
+    int SET_PREVIEW_WINDOW_MODE = 17;
     int SET_PREVIEW_WINDOW = 18;
     int GET_SOURCE_CONNECT_STATUS = 19;
     int GET_SOURCE_INPUT_LIST = 20;
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvControlManager.java b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvControlManager.java
index bfdc499..c67eced 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvControlManager.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvControlManager.java
@@ -670,6 +670,23 @@ public class TvControlManager {
     }
 
     /**
+     * only used for preview.
+     * need set preview mode to true when entering into preview window.
+     * of course, the mode need revert when exiting from preview window.
+     */
+    public int SetPreviewWindowMode(boolean enable) {
+        Parcel cmd = Parcel.obtain();
+        Parcel r = Parcel.obtain();
+        cmd.writeInt(SET_PREVIEW_WINDOW_MODE);
+        cmd.writeInt(enable ? 1 : 0);
+        sendCmdToTv(cmd, r);
+        int ret = r.readInt();
+        cmd.recycle();
+        r.recycle();
+        return ret;
+    }
+
+    /**
      * @Function: GetSourceConnectStatus
      * @Description: Get source connect status
      * @Param: source_input, refer to enum SourceInput
@@ -5254,6 +5271,7 @@ public class TvControlManager {
     public final static int EVENT_AV_PLAYBACK_RESUME            = 2;
     public final static int EVENT_AV_SCRAMBLED                  = 3;
     public final static int EVENT_AV_UNSUPPORT                  = 4;
+    public final static int EVENT_AV_VIDEO_AVAILABLE            = 5;
 
     public interface AVPlaybackListener {
         void onEvent(int msgType, int programID);
@@ -5373,7 +5391,8 @@ public class TvControlManager {
         USB4K2K(13),
         IPTV(14),
         DUMMY(15),
-        MAX(16);
+        SOURCE_SPDIF(16),
+        MAX(17);
         private int val;
 
         SourceInput(int val) {
@@ -5394,9 +5413,9 @@ public class TvControlManager {
         SOURCE_TYPE_MPEG(5),//only use for vpp, for display ,not a source
         SOURCE_TYPE_DTV(6),
         SOURCE_TYPE_SVIDEO(7),
-        SOURCE_TYPE_HDMI_4K2K(8),
-        SOURCE_TYPE_USB_4K2K(9),
-        SOURCE_TYPE_MAX(7);
+        SOURCE_TYPE_IPTV(8),
+        SOURCE_TYPE_SPDIF(9),
+        SOURCE_TYPE_MAX(10);
 
         private int val;
 
@@ -5537,7 +5556,7 @@ public class TvControlManager {
     /**
      * @description set gpio
      * @param portName name of gpio, e.g "GPIOAO_14"
-     * @param isOut true set gpio as out.
+     * @param isOut true set gpio as out, false gpio is in.
      * @param edge validly when {@param is_out} is true, 1/0 high/low
      */
     public int handleGPIO(String portName, boolean isOut, int edge) {
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvDataBaseManager.java b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvDataBaseManager.java
index fa72d67..f0ff42c 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvDataBaseManager.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvDataBaseManager.java
@@ -665,7 +665,7 @@ public class TvDataBaseManager {
     public void updateOrinsertAtvChannel(ChannelInfo channel) {
         int updateRet = updateAtvChannel(channel);
         if (updateRet != UPDATE_SUCCESS) {
-            insertAtvChannel(channel, updateRet);
+            insertAtvChannel(channel, channel.getNumber());
         }
     }
 
@@ -674,7 +674,7 @@ public class TvDataBaseManager {
     public void updateOrinsertAtvChannelFuzzy(ChannelInfo channel) {
         int updateRet = updateAtvChannelFuzzy(channel);
         if (updateRet != UPDATE_SUCCESS) {
-            insertAtvChannel(channel, updateRet);
+            insertAtvChannel(channel, channel.getNumber());
         }
     }
 
@@ -688,7 +688,7 @@ public class TvDataBaseManager {
     public void updateOrinsertAtvChannel(ChannelInfo toBeUpdated, ChannelInfo channel) {
         int updateRet = updateAtvChannel(toBeUpdated, channel);
         if (updateRet != UPDATE_SUCCESS) {
-            insertAtvChannel(channel, updateRet);
+            insertAtvChannel(channel, channel.getNumber());
         }
     }
 
diff --git a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvInputBaseSession.java b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvInputBaseSession.java
index 4d18c33..cce435c 100644
--- a/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvInputBaseSession.java
+++ b/amlogic/frameworks/core/java/com/droidlogic/app/tv/TvInputBaseSession.java
@@ -7,7 +7,7 @@ import android.media.tv.TvInputService;
 import android.media.tv.TvStreamConfig;
 import android.media.tv.TvInputManager.Hardware;
 import android.provider.Settings;
-import android.net.Uri;
+//import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerThread;
@@ -28,29 +28,17 @@ import android.hardware.hdmi.HdmiTvClient.SelectCallback;
 public abstract class TvInputBaseSession extends TvInputService.Session implements Handler.Callback {
     private static final boolean DEBUG = true;
     private static final String TAG = "TvInputBaseSession";
-    private static final int MSG_DO_TUNE = 0;
-    private static final int MSG_DO_SET_SURFACE = 3;
+
     private static final int MSG_DO_PRI_CMD = 9;
-    private static final int RETUNE_TIMEOUT = 20; // 1 second
 
     private Context mContext;
-    private int mNumber;
+    public int mId;
     private String mInputId;
     private int mDeviceId;
-    private Surface mSurface;
     private TvInputManager mTvInputManager;
-    private HdmiControlManager mHdmiManager;
-    private HdmiTvClient mHdmiTvClient = null;
     private boolean mHasRetuned = false;
     private Handler mSessionHandler;
     private TvControlManager mTvControlManager;
-    private int timeout = RETUNE_TIMEOUT;
-    private int mCurPort = -1;
-
-    protected int ACTION_FAILED = -1;
-    protected int ACTION_SUCCESS = 1;
-    private final int TV_SOURCE_EXTERNAL = 0;
-    private final int TV_SOURCE_INTERNAL = 1;
 
     public TvInputBaseSession(Context context, String inputId, int deviceId) {
         super(context);
@@ -60,16 +48,14 @@ public abstract class TvInputBaseSession extends TvInputService.Session implemen
 
         mTvControlManager = TvControlManager.getInstance();
         mSessionHandler = new Handler(context.getMainLooper(), this);
-        /* add DeviceEventListener for HDMI event */
-        mHdmiManager = (HdmiControlManager) mContext.getSystemService(Context.HDMI_CONTROL_SERVICE);
     }
 
-    public void setNumber(int number) {
-        mNumber = number;
+    public void setSessionId(int id) {
+        mId = id;
     }
 
-    public int getNumber() {
-        return mNumber;
+    public int getSessionId() {
+        return mId;
     }
 
     public String getInputId() {
@@ -80,56 +66,10 @@ public abstract class TvInputBaseSession extends TvInputService.Session implemen
         return mDeviceId;
     }
 
-    public abstract Hardware getHardware();
-    public abstract TvStreamConfig[] getConfigs();
-    public abstract int getCurrentSessionNumber();
-    public abstract void setCurrentSession();
-
-    private int startTvPlay() {
-        Log.d(TAG, "startTvPlay inputId=" + mInputId + " number=" + mNumber + " surface=" + mSurface);
-        if (getHardware() != null && mSurface != null && mSurface.isValid()) {
-            getHardware().setSurface(mSurface, getConfigs()[0]);
-            selectHdmiDevice(TV_SOURCE_EXTERNAL);
-            return ACTION_SUCCESS;
-        }
-        return ACTION_FAILED;
-    }
-
-    public int stopTvPlay() {
-        if (getHardware() != null) {
-
-            getHardware().setSurface(null, null);
-            return ACTION_SUCCESS;
-
-         }
-        return ACTION_SUCCESS;
-    }
-
-    public Surface getSurface() {
-        return mSurface;
-    }
-
     public void doRelease() {
         Log.d(TAG, "doRelease");
     }
 
-    public int doTune(Uri uri) {
-        Log.d(TAG, "doTune, uri = " + uri);
-
-        if (getConfigs() == null || startTvPlay() == ACTION_FAILED) {
-            Log.d(TAG, "doTune failed, timeout=" + timeout + ", retune 50ms later ...");
-
-            if (timeout > 0) {
-                Message msg = mSessionHandler.obtainMessage(MSG_DO_TUNE, uri);
-                mSessionHandler.sendMessageDelayed(msg, 50);
-                timeout--;
-                return ACTION_FAILED;
-            }
-        }
-
-        return ACTION_SUCCESS;
-    }
-
     public void doAppPrivateCmd(String action, Bundle bundle) {
         //do something
         if (DroidLogicTvUtils.ACTION_ATV_AUTO_SCAN.equals(action)) {
@@ -153,38 +93,12 @@ public abstract class TvInputBaseSession extends TvInputService.Session implemen
 
     public void doUnblockContent(TvContentRating rating) {}
 
-    public void doSetSurface(Surface surface) {
-        Log.d(TAG, "doSetSurface inputId=" + mInputId + " number=" + mNumber + " surface=" + surface);
-        timeout = RETUNE_TIMEOUT;
-
-        if (surface != null && !surface.isValid()) {
-            Log.d(TAG, "onSetSurface get invalid surface");
-            return;
-        } else if (surface != null) {
-            setCurrentSession();
-        }
-        mSurface = surface;
-
-        if (mSurface == null && getHardware() != null && mNumber == getCurrentSessionNumber()) {
-            Log.d(TAG, "surface is null, so stop TV play");
-            stopTvPlay();
-        }
-        if (surface == null)
-            selectHdmiDevice(TV_SOURCE_INTERNAL);
-    }
-
     @Override
     public void onRelease() {
         doRelease();
     }
 
     @Override
-    public boolean onSetSurface(Surface surface) {
-        mSessionHandler.obtainMessage(MSG_DO_SET_SURFACE, surface).sendToTarget();
-        return false;
-    }
-
-    @Override
     public void onSurfaceChanged(int format, int width, int height) {
     }
 
@@ -207,15 +121,6 @@ public abstract class TvInputBaseSession extends TvInputService.Session implemen
     }
 
     @Override
-    public boolean onTune(Uri channelUri) {
-        if (DEBUG)
-            Log.d(TAG, "onTune, channelUri=" + channelUri);
-
-        mSessionHandler.obtainMessage(MSG_DO_TUNE, channelUri).sendToTarget();
-        return false;
-    }
-
-    @Override
     public void onSetCaptionEnabled(boolean enabled) {
         // TODO Auto-generated method stub
     }
@@ -233,89 +138,10 @@ public abstract class TvInputBaseSession extends TvInputService.Session implemen
         if (DEBUG)
             Log.d(TAG, "handleMessage, msg.what=" + msg.what);
         switch (msg.what) {
-            case MSG_DO_TUNE:
-                mSessionHandler.removeMessages(MSG_DO_TUNE);
-                doTune((Uri)msg.obj);
-                break;
-            case MSG_DO_SET_SURFACE:
-                doSetSurface((Surface)msg.obj);
-                break;
             case MSG_DO_PRI_CMD:
                 doAppPrivateCmd((String)msg.obj, msg.getData());
                 break;
         }
         return false;
     }
-
-    private boolean mInHdmi = false;
-    private int mSourcePort = 0;
-
-    private void setCurPort(int port) {
-        mCurPort = port;
-    }
-
-    public void selectHdmiDevice(int mode) {
-        boolean cecOption = (Global.getInt(mContext.getContentResolver(), Global.HDMI_CONTROL_ENABLED, 1) == 1);
-        Log.d(TAG, "CEC selectHdmiDevice, deviceId:" + mDeviceId + ", cecOption:" + cecOption);
-        if (mHdmiTvClient == null) {
-            if (mHdmiManager == null) {
-                Log.d(TAG, "CEC NULL mHdmiManager");
-                return;
-            }
-            mHdmiTvClient = mHdmiManager.getTvClient();
-        }
-        if (!cecOption || mHdmiTvClient == null) {
-            Log.d(TAG, "cec not enabled or null mHdmiTvClient");
-            return ;
-        }
-        Log.d(TAG, "CEC selectHdmiDevice, mode:" + mode + ", mInHdmi:" + mInHdmi);
-        if (mode == TV_SOURCE_EXTERNAL) {
-            int fit = DroidLogicTvUtils.DEVICE_ID_HDMI1 - 1;
-            int id = mDeviceId - fit;
-            Log.d(TAG, "CEC selectHdmiDevice, id:"+ id + ", mInHdmi:" + mInHdmi+ ", curPort:" + mCurPort);
-            for (HdmiDeviceInfo info : mHdmiTvClient.getDeviceList()) {
-                mSourcePort = info.getPhysicalAddress() >> 12;
-                Log.d(TAG, "CEC selectHdmiDevice, id:"+ id + ", port:" + mSourcePort);
-                if (id == mSourcePort && mCurPort != id) {
-                    mHdmiTvClient.deviceSelect(info.getLogicalAddress(), new SelectCallback() {
-                        @Override
-                        public void onComplete(int result) {
-                            Log.d(TAG, "CEC selectHdmiDevice success");
-                            mInHdmi = true;
-                            setCurPort(mSourcePort);
-                        }
-                    });
-                    return;
-                } else if (id == mSourcePort && mCurPort == id) {
-                    Log.d(TAG, "CEC already selected port:" + id);
-                    return ;
-                }
-            }
-            if (mInHdmi) {
-                /* select internal source if no hdmi */
-                Log.d(TAG, "CEC selectHdmiDevice, check to internal source");
-                mHdmiTvClient.deviceSelect(0, new SelectCallback() {
-                    @Override
-                    public void onComplete(int result) {
-                        Log.d(TAG, "CEC selectInternal success");
-                        mInHdmi = false;
-                        setCurPort(-1);
-                    }
-                });
-            }
-        } else if (mode == TV_SOURCE_INTERNAL) {
-            if (mInHdmi) {
-                /* select internal source if no hdmi */
-                Log.d(TAG, "CEC selectHdmiDevice, check to internal source");
-                mHdmiTvClient.deviceSelect(0, new SelectCallback() {
-                    @Override
-                    public void onComplete(int result) {
-                        Log.d(TAG, "CEC selectInternal success");
-                        mInHdmi = false;
-                        setCurPort(-1);
-                    }
-                });
-            }
-        }
-    }
 }
diff --git a/amlogic/frameworks/core/res/AndroidManifest.xml b/amlogic/frameworks/core/res/AndroidManifest.xml
index 37241cc..928780e 100644
--- a/amlogic/frameworks/core/res/AndroidManifest.xml
+++ b/amlogic/frameworks/core/res/AndroidManifest.xml
@@ -16,6 +16,7 @@
         android:label="@string/droidlogic_perm_system_control_label"
         android:description="@string/droidlogic_perm_system_control_description" />
 
+    <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="droidlogic.permission.SYSTEM_CONTROL" />
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
     <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
@@ -46,8 +47,9 @@
         </service>
 
         <service android:name="com.droidlogic.Optimization" />
-
+        <service android:name="com.droidlogic.NtpService" />
         <service android:name="com.droidlogic.NetflixService" />
+        <service android:name="com.droidlogic.DialogBluetoothService" />
 
         <receiver android:name="com.droidlogic.BootComplete">
             <intent-filter>
diff --git a/amlogic/frameworks/core/res/res/values/array.xml b/amlogic/frameworks/core/res/res/values/array.xml
index 6cde077..de92ccd 100644
--- a/amlogic/frameworks/core/res/res/values/array.xml
+++ b/amlogic/frameworks/core/res/res/values/array.xml
@@ -50,5 +50,15 @@
         <item>SA</item>
         <item>IN</item>
     </array>
-
+    <string-array translatable="false" name="config_ntpServer_list">
+        <item>ntp.sjtu.edu.cn</item>
+        <item>cn.pool.ntp.org</item>
+        <item>ntp.api.bz</item>
+        <item>pool.ntp.org</item>
+        <item>asia.pool.ntp.org</item>
+        <item>0.asia.pool.ntp.org</item>
+        <item>1.asia.pool.ntp.org</item>
+        <item>2.asia.pool.ntp.org</item>
+        <item>3.asia.pool.ntp.org</item>
+    </string-array>
 </resources>
diff --git a/amlogic/frameworks/core/res/src/com/droidlogic/BootComplete.java b/amlogic/frameworks/core/res/src/com/droidlogic/BootComplete.java
index 68de7db..b9fa719 100644
--- a/amlogic/frameworks/core/res/src/com/droidlogic/BootComplete.java
+++ b/amlogic/frameworks/core/res/src/com/droidlogic/BootComplete.java
@@ -7,7 +7,9 @@ import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.os.RemoteException;
 import android.os.ServiceManager;
+import android.os.UserHandle;
 import android.provider.Settings;
+import android.content.ContentResolver;
 import android.util.Log;
 import android.view.IWindowManager;
 
@@ -28,6 +30,8 @@ public class BootComplete extends BroadcastReceiver {
         Log.i(TAG, "action: " + action);
 
         if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
+            Intent gattServiceIntent = new Intent(context, DialogBluetoothService.class);
+            context.startService(gattServiceIntent);
             SystemControlManager sm = new SystemControlManager(context);
             //register system control callback
             sm.setListener(new SystemControlEvent(context));
@@ -54,9 +58,7 @@ public class BootComplete extends BroadcastReceiver {
 
             new HdmiCecExtend(context);
 
-            if (sm.getPropertyBoolean("ro.platform.has.tvuimode", false)) {
-                new HdrManager(context).initHdrMode();
-            }
+            new HdrManager(context).initHdrMode();
 
             //start optimization service
             context.startService(new Intent(context, Optimization.class));
@@ -66,6 +68,22 @@ public class BootComplete extends BroadcastReceiver {
             }
 
             initDefaultAnimationSettings(context);
+
+            context.startService(new Intent(context,NtpService.class));
+            String rotProp = sm.getPropertyString("persist.sys.app.rotation", "");
+            ContentResolver res = context.getContentResolver();
+            int acceRotation = Settings.System.getIntForUser(res,
+                Settings.System.ACCELEROMETER_ROTATION,
+                0,
+                UserHandle.USER_CURRENT);
+            if (rotProp != null && ("middle_port".equals(rotProp) || "force_land".equals(rotProp))) {
+                    if (0 != acceRotation) {
+                        Settings.System.putIntForUser(res,
+                            Settings.System.ACCELEROMETER_ROTATION,
+                            0,
+                            UserHandle.USER_CURRENT);
+                    }
+            }
         }
     }
 
diff --git a/amlogic/frameworks/core/res/src/com/droidlogic/DialogBluetoothService.java b/amlogic/frameworks/core/res/src/com/droidlogic/DialogBluetoothService.java
new file mode 100644
index 0000000..95bf300
--- /dev/null
+++ b/amlogic/frameworks/core/res/src/com/droidlogic/DialogBluetoothService.java
@@ -0,0 +1,639 @@
+/*-----------------------------------------------------------------------------
+ *                 @@@           @@                  @@
+ *                @@@@@          @@   @@             @@
+ *                @@@@@          @@                  @@
+ *       .@@@@@.  @@@@@      @@@ @@   @@     @@@@    @@     @@@       @@@
+ *     @@@@@@   @@@@@@@    @@   @@@   @@        @@   @@   @@   @@   @@   @@
+ *    @@@@@    @@@@@@@@    @@    @@   @@    @@@@@@   @@   @@   @@   @@   @@
+ *   @@@@@@     @@@@@@@    @@    @@   @@   @@   @@   @@   @@   @@   @@   @@
+ *   @@@@@@@@     @@@@@    @@   @@@   @@   @@   @@   @@   @@   @@   @@   @@
+ *   @@@@@@@@@@@    @@@     @@@@ @@   @@    @@@@@    @@     @@@       @@@@@
+ *    @@@@@@@@@@@  @@@@                                                  @@
+ *     @@@@@@@@@@@@@@@@                                                  @@
+ *       "@@@@@"  @@@@@    S  E  M  I  C  O  N  D  U  C  T  O  R     @@@@@
+ *
+ *
+ * Copyright (C) 2014 Dialog Semiconductor GmbH and its Affiliates, unpublished
+ * work. This computer program includes Confidential, Proprietary Information
+ * and is a Trade Secret of Dialog Semiconductor GmbH and its Affiliates. All
+ * use, disclosure, and/or  reproduction is prohibited unless authorized in
+ * writing. All Rights Reserved.
+ *
+ * Filename: BluetoothLeService.java
+ * Purpose : Service to connect and communicate with Bluetooth LE devices
+ * Created : 08-2014
+ * By      : Johannes Steensma, Taronga Technology Inc.
+ * Country : USA
+ *
+ *-----------------------------------------------------------------------------
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+package com.droidlogic;
+
+import android.app.Service;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattDescriptor;
+import android.bluetooth.BluetoothGattService;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.BluetoothProfile;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Handler;
+import android.os.IBinder;
+import android.util.Log;
+import android.widget.Toast;
+
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+/**
+ * Service for managing connection and data communication with a GATT server hosted on a
+ * given Bluetooth LE device.
+ */
+public class DialogBluetoothService extends Service {
+    private final static String TAG = "BLE_Service"; // BluetoothLeService.class.getSimpleName();
+
+    // Supported devices GAP names
+    private static final String SUPPORTED_DEVICES [] = {
+        "DA14582 M&VRemote",
+        "DA14582 IR&M&VRemote",
+        "DA1458x RCU",
+        "RemoteB008",
+    };
+
+    // Time to wait before connecting to bonded devices
+    private static final int CONNECTION_DELAY_MS = 1000;
+    // Time to wait before canceling a connection attempt
+    private static final int CONNECTING_TIMEOUT = 10000;
+
+    // Writing to the client characteristic configuration descriptor of HID Report characteristics
+    // may not be necessary, because the Android BLE stack should already have done this.
+    private static final boolean WRITE_REPORT_CLIENT_CONFIGURATION = true;
+
+    private static final int STATE_DISCONNECTED = 0;
+    private static final int STATE_CONNECTING = 1;
+    private static final int STATE_CONNECTED = 2;
+
+    private static final String AUDIO_STREAM_TEXT_ON = "BTAudio stream ON";
+    private static final String AUDIO_STREAM_TEXT_OFF = "BTAudio stream OFF";
+    private static final String CONNECTING_TO_AUDIO_REMOTE = "Connecting to Audio Remote...";
+    private static final String CONNECTED_TO_AUDIO_REMOTE = "Connected to Audio Remote";
+    private static final String DISCONNECTED_FROM_AUDIO_REMOTE = "Disconnected from Audio Remote";
+    //private static final String CONNECTION_FAILED_MSG = "Connection to Audio Remote failed";
+
+    // Intent Actions and Intent Extra keys to send messages to MainDiaBleActivity
+    public final static String ACTION_GATT_CONNECTED        = "com.diasemi.bleconnector.action.GATT_CONNECTED";
+    public final static String ACTION_GATT_DISCONNECTED     = "com.diasemi.bleconnector.action.GATT_DISCONNECTED";
+    public final static String ACTION_AUDIO_TRANSFER        = "com.diasemi.bleconnector.action.AUDIO_TRANSFER";
+    public final static String EXTRA_DATA                   = "com.diasemi.bleconnector.extra.DATA";
+
+    // HID UUIDs
+    private static final UUID HID_SERVICE           = UUID.fromString("00001812-0000-1000-8000-00805f9b34fb");   // HID (Human Interface Device) Service
+    private static final UUID HID_INFORMATION_CHAR  = UUID.fromString("00002a4a-0000-1000-8000-00805f9b34fb");   // HID Information Characteristic
+    private static final UUID HID_REPORT_MAP        = UUID.fromString("00002a4b-0000-1000-8000-00805f9b34fb");   // HID Report Map Characteristic
+    private static final UUID HID_CONTROL_POINT     = UUID.fromString("00002a4c-0000-1000-8000-00805f9b34fb");   // HID Control Point Characteristic
+    private static final UUID HID_REPORT_CHAR       = UUID.fromString("00002a4d-0000-1000-8000-00805f9b34fb");   // HID Report Characteristic
+    // Client Characteristic Configuration Descriptor
+    private static final UUID CLIENT_CONFIG_DESCRIPTOR = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");
+
+    // Ble Remote HID Report Characteristic instance IDs (Audio)
+    private static final int  HID_STREAM_ENABLE_WRITE_INSTANCE = 3;
+    private static final int  HID_STREAM_ENABLE_READ_INSTANCE  = 4;
+    private static final int  HID_STREAM_DATA_MIN_INSTANCE     = 5;
+    private static final int  HID_STREAM_DATA_MAX_INSTANCE     = 7;
+    private static final int  HID_STREAM_DATA_REP5_INSTANCE    = 5;
+    private static final int  HID_STREAM_DATA_REP6_INSTANCE    = 6;
+    private static final int  HID_STREAM_DATA_REP7_INSTANCE    = 7;
+
+    // Data
+    private BluetoothManager mBluetoothManager;
+    private BluetoothAdapter mBluetoothAdapter;
+    private BluetoothGatt mBluetoothGatt;
+    private int mConnectionState = STATE_DISCONNECTED;
+    private HashSet<BluetoothDevice> pending = new HashSet<BluetoothDevice>();
+    private Handler mHandler;
+    private boolean isHidServiceInitialized = false;
+    private BluetoothGattCharacteristic enableCharacteristic = null;
+    private BluetoothGattCharacteristic rep5Characteristic = null;
+    private BluetoothGattCharacteristic rep6Characteristic = null;
+    private BluetoothGattCharacteristic rep7Characteristic = null;
+    private int prevInstance = 0; // for checking audio data notifications sequence
+
+
+    /**
+     * Used in order for the service to be notified about HID devices connection and bond state.
+     */
+    private final BroadcastReceiver receiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (mBluetoothAdapter == null || mBluetoothManager == null) {
+                Log.i(TAG, "Re-initializing bluetooth handlers on service side...");
+                if (!initializeBTManager())
+                    return;
+            }
+            if (intent == null)
+                return;
+
+            final String action = intent.getAction();
+            final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)) {
+                Log.i(TAG, ">ACL LINK CONNECTED ["+device.getName()+"] - checking for supported devices after delay");
+                if (isRemoteAudioCapable(device)) {
+                    pending.add(device);
+                    mHandler.removeCallbacks(mConnRunnable);
+                    mHandler.postDelayed(mConnRunnable, CONNECTION_DELAY_MS);
+                    // waiting some time to not overload BLE device with requests
+                }
+            }
+            else if (BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED.equals(action)) {
+                Log.i(TAG, ">ACL LINK DISCONNECT REQUEST ["+device.getName()+"]");
+            }
+            else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
+                Log.i(TAG, ">ACL LINK DISCONNECTED ["+device.getName()+"]");
+                pending.remove(device);
+                if (pending.isEmpty())
+                    mHandler.removeCallbacks(mConnRunnable);
+            }
+            else if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
+                int bondStateNow = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE);
+                int bondStatePrev = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, BluetoothDevice.BOND_NONE);
+
+                Log.i(TAG, "BOND STATE CHANGED ["+device.getName()+"] - was " + bondStatePrev + ", now is " + bondStateNow);
+                if (isRemoteAudioCapable(device) && bondStatePrev == BluetoothDevice.BOND_BONDING && bondStateNow == BluetoothDevice.BOND_BONDED) {
+                    Log.i(TAG, "Bonding complete ["+device.getName()+"] - checking for supported devices after delay");
+                    pending.add(device);
+                    mHandler.removeCallbacks(mConnRunnable);
+                    mHandler.postDelayed(mConnRunnable, CONNECTION_DELAY_MS);
+                }
+            }
+        }
+    };
+
+    private Runnable mConnRunnable = new Runnable() {
+        @Override
+        public void run() {
+            if (mConnectionState == STATE_DISCONNECTED && mBluetoothGatt == null) {
+                Log.i(TAG, "mConnRunnable, looking on bonded devices in order to find connection target...");
+                pending.clear();
+                connectToBondedDevices();
+            } else {
+                Log.e(TAG, "Ignoring connection attempt. State: " + mConnectionState);
+            }
+        }
+    };
+
+    private Runnable mDisconnRunnable = new Runnable() {
+        @Override
+        public void run() {
+            if (mConnectionState == STATE_CONNECTING && mBluetoothGatt != null) {
+                Log.d(TAG, "Connection attempt timeout!");
+                mConnectionState = STATE_DISCONNECTED;
+                mBluetoothGatt.disconnect();
+                close();
+            }
+        }
+    };
+
+
+    /**
+     * Connect to the first found bonded audio remote device
+     */
+    public void connectToBondedDevices()
+    {
+        Log.i(TAG, "connectToBondedDevices><");
+
+        if (mBluetoothGatt != null && mConnectionState != STATE_DISCONNECTED) {
+            Log.e(TAG, "Already connected to GATT instance. Aborting another connection attempt!");
+            return;
+        }
+
+        if (mBluetoothAdapter == null) {
+            Log.e(TAG, "Adapter not yet initialized, not continuing with connection!");
+            return;
+        }
+
+        Set<BluetoothDevice> bondedDevices = mBluetoothAdapter.getBondedDevices();
+		Log.i(TAG, "bondedDevices size:"+bondedDevices.size());
+        for (Iterator<BluetoothDevice> it = bondedDevices.iterator(); it.hasNext();) {
+            BluetoothDevice dev = (BluetoothDevice) it.next();
+            if (isRemoteAudioCapable(dev)) {
+                Log.i(TAG, "Initializing new connection....");
+                if (connect(dev))
+                    return; // only one audio device
+            }
+        }
+    }
+
+    public boolean isRemoteAudioCapable(BluetoothDevice device)
+    {
+        String name = device.getName();
+		Log.i(TAG, "isRemoteAudioCapable:" );
+        if (name == null)
+            return false;
+
+        for (String devName : SUPPORTED_DEVICES) {
+            if (devName.compareTo(name) == 0) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+
+    // Service lifecycle callbacks
+    @Override
+    public void onCreate() {
+
+        Log.d(TAG, "Service onCreate");
+
+        mHandler = new Handler();
+        initializeBTManager();
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
+        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);
+        filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+        //filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+        registerReceiver(receiver, filter);
+
+        // On service start, check for supported devices
+        connectToBondedDevices();
+    }
+
+    @Override
+    public void onDestroy() {
+        Log.d(TAG, "Service onDestroy");
+        mHandler.removeCallbacksAndMessages(null);
+        unregisterReceiver(receiver);
+        close();
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        Log.i(TAG, "!!!!!!!!Ble Remote Connector service started.");
+        return START_STICKY;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+
+    /**
+     * Initializes a reference to the local Bluetooth adapter.
+     *
+     * @return Return true if the initialization is successful.
+     */
+    private boolean initializeBTManager() {
+        if (mBluetoothManager == null) {
+            mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+            if (mBluetoothManager == null) {
+                Log.e(TAG, "Unable to initialize BluetoothManager.");
+                mBluetoothAdapter = null; //also re-setting bluetooth adapter for compatibility
+                return false;
+            }
+        }
+
+        mBluetoothAdapter = mBluetoothManager.getAdapter();
+        if (mBluetoothAdapter == null) {
+            Log.e(TAG, "Unable to obtain a BluetoothAdapter.");
+            return false;
+        }
+
+        return true;
+    }
+
+
+    /**
+     * Connects to the GATT server hosted on the Bluetooth LE device.
+     *
+     * @param btDevice The device to connect to.
+     *
+     * @return Return true if the connection is initiated successfully. The connection result
+     *         is reported asynchronously through the
+     *
+     *         {@code BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)}
+     *         callback.
+     */
+    public boolean connect(BluetoothDevice btDevice) {
+        if (btDevice == null) {
+            Log.w(TAG, "Device not found.  Unable to connect.");
+            return false;
+        }
+
+        // Connecting to GATT, not-allowing for auto-reconnect (mess with connection numbers at the same time)
+        Log.d(TAG, "Trying to create a new connection...");
+        showToast(CONNECTING_TO_AUDIO_REMOTE);
+        mHandler.removeCallbacks(mDisconnRunnable);
+        mConnectionState = STATE_CONNECTING;
+        mBluetoothGatt = btDevice.connectGatt(this, false, mGattCallback);
+        if (mBluetoothGatt == null) {
+            Log.e(TAG, "btDevice connectGatt returned NULL! Aborting connect!");
+            mConnectionState = STATE_DISCONNECTED;
+            return false;
+        }
+        mHandler.postDelayed(mDisconnRunnable, CONNECTING_TIMEOUT);
+        return true;
+    }
+
+    private void onConnectionSuccess(BluetoothGatt gatt) {
+        if (mConnectionState == STATE_CONNECTED) {
+            Log.e(TAG, "Already connected. Ignoring attempt to discover services again.");
+            return;
+        }
+
+        if (mBluetoothGatt == null) {
+            Log.e(TAG, "BluetoothGatt is NULL. Fixing that.");
+            mBluetoothGatt = gatt;
+        }
+
+        mConnectionState = STATE_CONNECTED;
+        broadcastUpdate(ACTION_GATT_CONNECTED);
+        Log.i(TAG, "Connected to GATT server.");
+        Log.i(TAG, "Starting service discovery...");
+
+        mBluetoothGatt.discoverServices();
+    }
+
+    /**
+     * After using a given BLE device, the app must call this method to ensure resources are
+     * released properly.
+     */
+    public void close() {
+        Log.w(TAG, "Close called!");
+        if (mBluetoothGatt == null) {
+            return;
+        }
+        mBluetoothGatt.close();
+        mBluetoothGatt = null;
+    }
+
+
+    /****
+     * Send enable report back to the Remote Control Unit, e.g. to enable/disable streaming.
+     * @param flag Data to send to Remote Control Unit in order to enable/disable audio stream.
+     */
+    private void sendEnable(int flag) {
+        if (enableCharacteristic == null)
+            return;
+        Log.i(TAG,"Write Enable: " + flag);
+
+        if (flag != 0) {
+            showToast(AUDIO_STREAM_TEXT_ON);
+            broadcastUpdate(ACTION_AUDIO_TRANSFER, AUDIO_STREAM_TEXT_ON);
+        } else {
+            showToast(AUDIO_STREAM_TEXT_OFF);
+            broadcastUpdate(ACTION_AUDIO_TRANSFER, AUDIO_STREAM_TEXT_OFF);
+        }
+
+        prevInstance = 0;
+        byte packet[] = new byte[20];
+        packet[0] = (byte) flag;
+        enableCharacteristic.setValue(packet);
+        mBluetoothGatt.writeCharacteristic(enableCharacteristic);
+    }
+
+
+    /**************************************************************************************
+     * BluetoothGattCallback
+     * Implements callback methods for GATT events that the app cares about.
+     * For example, connection change and services discovered.
+     */
+    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
+        @Override
+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
+            Log.i(TAG, "Connection state change: " + (newState == BluetoothGatt.STATE_CONNECTED ? "connected" : "disconnected") + ", status=" + status);
+
+            if (newState == BluetoothProfile.STATE_CONNECTED) {
+                // Attempt to discover services after successful connection.
+                onConnectionSuccess(gatt);
+            }
+            else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
+                if (gatt != mBluetoothGatt) {
+                    Log.e(TAG, "Disconnected different instance of gatt. No change for main gatt session");
+                    return;
+                }
+
+                Log.i(TAG, "Disconnected from GATT server.");
+                mConnectionState = STATE_DISCONNECTED;
+                isHidServiceInitialized = false;
+                close();
+                showToast(DISCONNECTED_FROM_AUDIO_REMOTE);
+                broadcastUpdate(ACTION_GATT_DISCONNECTED);
+            }
+        }
+
+        @Override
+        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
+            Log.i(TAG, "Services discovered.");
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                if (!isHidServiceInitialized) {
+                    initHidService(gatt);
+                    isHidServiceInitialized = true;
+                    showToast(CONNECTED_TO_AUDIO_REMOTE);
+                } else {
+                    Log.e(TAG, "HID service already initialized!");
+                }
+            } else {
+                Log.w(TAG, "onServicesDiscovered received: " + status + ". Disconnecting from GATT.");
+                gatt.disconnect();
+            }
+        }
+
+        @Override
+        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            Log.i(TAG,"OnRead "+characteristic.getUuid().toString() + ", id=" + characteristic.getInstanceId() + ", status=" + status);
+        }
+
+        @Override
+        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            Log.i(TAG,"OnWrite "+characteristic.getUuid().toString() + ", id=" + characteristic.getInstanceId() + ", status=" + status);
+        }
+
+        @Override
+        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
+            int instance = characteristic.getInstanceId();
+            // Audio data report
+            if ((HID_REPORT_CHAR.compareTo(characteristic.getUuid()) == 0) && (instance >= HID_STREAM_DATA_MIN_INSTANCE) && (instance <= HID_STREAM_DATA_MAX_INSTANCE)) {
+                //byte packet[] = characteristic.getValue();
+                //int n = ((packet[0])&0xFF) + ((packet[1]&0xFF)<<8);
+                //Log.i(TAG,String.format("HID data packet %d %02x %02x %d", instance, packet[0]&0xFF, packet[1]&0xFF, n));
+
+                if (prevInstance == 0)
+                    prevInstance = instance;
+                else
+                    ++prevInstance;
+                if (prevInstance > HID_STREAM_DATA_MAX_INSTANCE)
+                    prevInstance = HID_STREAM_DATA_MIN_INSTANCE;
+                if (prevInstance != instance) {
+                    Log.w(TAG,String.format("Error, packet sequence interruption, expected %d, received %d", prevInstance, instance));
+                    prevInstance = instance;
+                }
+            }
+            // Possible audio button report
+            else if ((HID_REPORT_CHAR.compareTo(characteristic.getUuid()) == 0) && (instance == HID_STREAM_ENABLE_READ_INSTANCE)) {
+                byte[] value = characteristic.getValue();
+                Log.i(TAG,"Enable char "+String.format("%x %x", value[0]&0xff, value[1]&0xff));
+                int type = value[1];
+                if (type == 0) {
+                    // got enable/disable
+                    sendEnable(value[0] != 0 ? 1 : 0);
+                }
+            }
+        }
+
+        @Override
+        public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
+            Log.i(TAG, "onDescriptorRead " + descriptor.getUuid()
+                    + ", char " + descriptor.getCharacteristic().getUuid().toString() + ", id=" + descriptor.getCharacteristic().getInstanceId()
+                    + ", status=" +  status);
+        }
+
+        @Override
+        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
+            Log.i(TAG, "onDescriptorWrite " + descriptor.getUuid()
+                    + ", char " + descriptor.getCharacteristic().getUuid().toString() + ", id=" + descriptor.getCharacteristic().getInstanceId()
+                    + ", status=" +  status);
+            if (!mDescWriteQueue.isEmpty()) {
+                gatt.writeDescriptor(mDescWriteQueue.poll());
+            }
+        }
+
+        @Override
+        public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {
+            Log.d(TAG, "Remote RSSI: " + rssi);
+        }
+
+        /**
+         * Initialize HID service characteristics and enable notifications.
+         *
+         * @param gatt Gatt connection to use.
+         */
+        private void initHidService(BluetoothGatt gatt) {
+            BluetoothGattService gattService;
+
+            // Loop through available GATT Services.
+            List<BluetoothGattService> serviceList =  gatt.getServices();
+            for (BluetoothGattService s : serviceList) {
+                Log.i(TAG,"Service "+s.getInstanceId()+" "+s.getUuid().toString());
+            }
+
+            // Find HID Service
+            gattService = gatt.getService(HID_SERVICE);
+            if (gattService == null)
+                return;
+            String uuid = gattService.getUuid().toString();
+            int gsInstance = gattService.getInstanceId();
+
+            Log.i(TAG, "Service UUID " + uuid + ", id=" + gsInstance);
+            List<BluetoothGattCharacteristic> gattCharacteristics = gattService.getCharacteristics();
+
+            // Loop through available Characteristics.
+            for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {
+                boolean setNotify = false;
+                UUID uuidc = gattCharacteristic.getUuid();
+                int instance = gattCharacteristic.getInstanceId();
+                // Find the enable, rep5, rep6, rep7 characteristics.
+                if (uuidc.compareTo(HID_REPORT_CHAR) == 0) {
+                    switch (instance) {
+                    case HID_STREAM_ENABLE_WRITE_INSTANCE:
+                        enableCharacteristic = gattCharacteristic;
+                        Log.i(TAG, "Found Enable Write Characteristic");
+                        break;
+                    case HID_STREAM_ENABLE_READ_INSTANCE:
+                        Log.i(TAG, "Found Enable Read Characteristic");
+                        setNotify = true;
+                        break;
+                    case HID_STREAM_DATA_REP5_INSTANCE:
+                        rep5Characteristic = gattCharacteristic;
+                        Log.i(TAG, "Found REP5 Characteristic");
+                        setNotify = true;
+                        break;
+                    case HID_STREAM_DATA_REP6_INSTANCE:
+                        rep6Characteristic = gattCharacteristic;
+                        Log.i(TAG, "Found REP6 Characteristic");
+                        setNotify = true;
+                        break;
+                    case HID_STREAM_DATA_REP7_INSTANCE:
+                        rep7Characteristic = gattCharacteristic;
+                        Log.i(TAG, "Found REP7 Characteristic");
+                        setNotify = true;
+                        break;
+                    }
+                }
+                Log.i(TAG, "Characteristic " + uuidc.toString() + ", id=" + instance + ", prop=" + gattCharacteristic.getProperties());
+
+                // Only setNotify for our HID streaming characteristics. Some of the Android devices don't support
+                // more than 4 local notifications (Nexus-5, Nexus-7 - API 19), although Samsung S5 does.
+                if (setNotify) {
+                    //Enable local notifications
+                    gatt.setCharacteristicNotification(gattCharacteristic, true);
+                    // Enable remote notifications
+                    if (WRITE_REPORT_CLIENT_CONFIGURATION) {
+                        BluetoothGattDescriptor ccc = gattCharacteristic.getDescriptor(CLIENT_CONFIG_DESCRIPTOR);
+                        if (ccc != null) {
+                            Log.i(TAG, "Found client configuration descriptor for report ID " + ccc.getCharacteristic().getInstanceId());
+                            ccc.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
+                            mDescWriteQueue.add(ccc);
+                        }
+                    }
+                }
+            }
+
+            if (!mDescWriteQueue.isEmpty()) {
+                gatt.writeDescriptor(mDescWriteQueue.poll());
+            }
+        }
+
+        // Descriptor write queue (needed because there can't be more than one pending gatt operations)
+        ConcurrentLinkedQueue<BluetoothGattDescriptor> mDescWriteQueue = new ConcurrentLinkedQueue<BluetoothGattDescriptor>();
+
+    };
+
+
+    /*****
+     * broadcastUpdate functions to send data back to BleActivity
+     */
+
+    private void broadcastUpdate(final String action) {
+        final Intent intent = new Intent(action);
+        sendBroadcast(intent);
+    }
+
+    private void broadcastUpdate(final String action, String data) {
+        final Intent intent = new Intent(action);
+        intent.putExtra(EXTRA_DATA, data);
+        sendBroadcast(intent);
+    }
+
+
+    private Toast toast; // Cancel last toast in order to show a new one
+
+    private void showToast(final String text) {
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                if (toast != null)
+                    toast.cancel();
+                toast = Toast.makeText(getApplicationContext(), text, Toast.LENGTH_SHORT);
+                toast.show();
+            }
+        });
+    }
+
+}
diff --git a/amlogic/frameworks/core/res/src/com/droidlogic/EthernetWifiSwitch.java b/amlogic/frameworks/core/res/src/com/droidlogic/EthernetWifiSwitch.java
index 6f871c2..1ad6487 100644
--- a/amlogic/frameworks/core/res/src/com/droidlogic/EthernetWifiSwitch.java
+++ b/amlogic/frameworks/core/res/src/com/droidlogic/EthernetWifiSwitch.java
@@ -7,10 +7,12 @@ import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.net.wifi.WifiManager;
 import android.util.Log;
+import com.droidlogic.app.SystemControlManager;
 
 public class EthernetWifiSwitch extends BroadcastReceiver {
     private static final String TAG = "EthernetWifiSwitch";
-
+    private static final String NETCONDITION_LED = "/sys/class/leds/led-net/brightness";
+    private SystemControlManager mSystemControlManager;
     @Override
     public void onReceive(Context context, Intent intent) {
         String action = intent.getAction();
@@ -19,6 +21,21 @@ public class EthernetWifiSwitch extends BroadcastReceiver {
             WifiManager wm = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
             ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
             NetworkInfo ethInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_ETHERNET);
+            NetworkInfo netInfo = (NetworkInfo)intent.getExtra(ConnectivityManager.EXTRA_NETWORK_INFO, null);
+            mSystemControlManager = new SystemControlManager(context);
+            if (netInfo != null) {
+                if (netInfo.getState() == NetworkInfo.State.CONNECTED) {
+                    Log.d ( TAG ,"TypeName " + netInfo.getTypeName()+ " connected");
+                    if (mSystemControlManager != null) {
+                        mSystemControlManager.writeSysFs(NETCONDITION_LED, "1");
+                    }
+                } else if (netInfo.getState() == NetworkInfo.State.DISCONNECTED) {
+                    Log.d ( TAG ,"TypeName " + netInfo.getTypeName()+ " disconnected");
+                    if (mSystemControlManager != null) {
+                        mSystemControlManager.writeSysFs(NETCONDITION_LED, "0");
+                    }
+                }
+            }
             if (ethInfo.getState() == NetworkInfo.State.CONNECTED) {
                 int wifiState = wm.getWifiState();
                 if ((wifiState == WifiManager.WIFI_STATE_ENABLING) ||
diff --git a/amlogic/frameworks/core/res/src/com/droidlogic/HdmiCecExtend.java b/amlogic/frameworks/core/res/src/com/droidlogic/HdmiCecExtend.java
index a98e905..f7ef2e1 100644
--- a/amlogic/frameworks/core/res/src/com/droidlogic/HdmiCecExtend.java
+++ b/amlogic/frameworks/core/res/src/com/droidlogic/HdmiCecExtend.java
@@ -2,23 +2,30 @@
 package com.droidlogic;
 
 import android.content.Context;
+import android.content.ContentResolver;
+import android.content.BroadcastReceiver;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.provider.Settings;
+import android.provider.Settings.Global;
+import android.database.ContentObserver;
 import android.hardware.hdmi.HdmiControlManager;
 import android.hardware.hdmi.HdmiPlaybackClient;
 import android.hardware.hdmi.HdmiHotplugEvent;
+import android.hardware.hdmi.HdmiTvClient;
 import android.hardware.hdmi.HdmiPortInfo;
 import android.hardware.hdmi.HdmiDeviceInfo;
 import android.hardware.hdmi.HdmiControlManager.VendorCommandListener;
 import android.hardware.hdmi.HdmiPlaybackClient.OneTouchPlayCallback;
 import android.hardware.hdmi.IHdmiControlService;
 import android.util.Slog;
+import android.net.Uri;
+import android.os.UserHandle;
 import android.os.ServiceManager;
-import android.os.PowerManager;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.os.Handler;
 import android.os.Build;
-import android.os.SystemClock;
-
 import com.android.internal.app.LocalePicker;
 
 import libcore.util.EmptyArray;
@@ -28,9 +35,14 @@ import java.util.List;
 import java.lang.reflect.Method;
 import java.io.UnsupportedEncodingException;
 import android.content.res.Configuration;
+import com.droidlogic.app.HdmiCecManager;
+import com.droidlogic.app.tv.DroidLogicTvUtils;
 
 public class HdmiCecExtend {
     private final String TAG = "HdmiCecExtend";
+    private static final int DISABLED = 0;
+    private static final int ENABLED = 1;
+
     static final int MESSAGE_FEATURE_ABORT = 0x00;
     static final int MESSAGE_IMAGE_VIEW_ON = 0x04;
     static final int MESSAGE_TUNER_STEP_INCREMENT = 0x05;
@@ -109,6 +121,9 @@ public class HdmiCecExtend {
     static final int SEND_RESULT_BUSY = 2;
     static final int SEND_RESULT_FAILURE = 3;
 
+    static final int STANDBY_SCREEN_OFF = 0;
+    static final int STANDBY_SHUTDOWN = 1;
+
     /** Logical address for TV */
     public static final int ADDR_TV = 0;
     /** Logical address for recorder 1 */
@@ -146,21 +161,25 @@ public class HdmiCecExtend {
     /** Logical address used to indicate it is not initialized or invalid. */
     public static final int ADDR_INVALID = -1;
 
+    public static final int ONE_TOUCH_PLAY_DELAY = 100;
+
     static final int MENU_STATE_ACTIVATED = 0;
     static final int MENU_STATE_DEACTIVATED = 1;
     private static final int OSD_NAME_MAX_LENGTH = 13;
 
+    private final SettingsObserver mSettingsObserver;
     private Context mContext = null;
+    private HdmiTvClient mHdmiTvClient = null;
     private HdmiControlManager mControl = null;
     private HdmiPlaybackClient mPlayback = null;
     private List<HdmiPortInfo> mPortInfo = null;
     private boolean mLanguangeChanged = false;
     private boolean mInitFinished = false;
     private IHdmiControlService mService = null;
-    private PowerManager mPowerManager = null;
-    private int mPhyAddr = 0x1000;
+    private int mPhyAddr = -1;
     private int mVendorId = 0;
     private Handler mHandler;
+    private HdmiExtendReceiver mReceiver = new HdmiExtendReceiver();
 
     public HdmiCecExtend(Context ctx) {
         Slog.d(TAG, "HdmiCecExtend start");
@@ -170,9 +189,10 @@ public class HdmiCecExtend {
         mContext = ctx;
         mControl = (HdmiControlManager) mContext.getSystemService(Context.HDMI_CONTROL_SERVICE);
         mService = IHdmiControlService.Stub.asInterface(ServiceManager.getService(Context.HDMI_CONTROL_SERVICE));
-        mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
-		
+        mHdmiTvClient = mControl.getTvClient();
         mHandler = new Handler();
+        mSettingsObserver = new SettingsObserver(mHandler);
+        registerContentObserver();
         if (mControl != null) {
             mPlayback = mControl.getPlaybackClient();
             Slog.d(TAG, "mHasPlaybackDevice:" + mPlayback);
@@ -181,12 +201,22 @@ public class HdmiCecExtend {
                 mPlayback.oneTouchPlay(mOneTouchPlay);
                 mVendorId = nativeGetVendorId();
                 Slog.d(TAG, "vendorId:" + mVendorId);
+                if (!mLanguangeChanged) {
+                    mHandler.postDelayed(mDelayedRun, ONE_TOUCH_PLAY_DELAY);
+                }
+                // Register broadcast receiver for power state change.
+                IntentFilter filter = new IntentFilter();
+                filter.addAction(Intent.ACTION_SCREEN_OFF);
+                filter.addAction(Intent.ACTION_SHUTDOWN);
+                filter.addAction(Intent.ACTION_SCREEN_ON);
+                ctx.getApplicationContext().registerReceiver(mReceiver, filter);
             }
             mControl.addHotplugEventListener(new HdmiControlManager.HotplugEventListener() {
                     @Override
                     public void onReceived(HdmiHotplugEvent event) {
                         Slog.d(TAG, "HdmiHotplugEvent, connected:" + event.isConnected());
                         if (mPlayback != null) {
+                            updatePortInfo();
                             if (event.isConnected() == true && mLanguangeChanged == false && mInitFinished == true) {
                                 /* TODO: */
                             } else {
@@ -202,7 +232,6 @@ public class HdmiCecExtend {
     }
 
     public void updatePortInfo() {
-        int timeout = 0;
         if (mService != null) {
             mPhyAddr = nativeGetPhysicalAddr();
         }
@@ -236,6 +265,9 @@ public class HdmiCecExtend {
          * menually start one touch play
          */
         Slog.d(TAG, "oneTouchPlayExt started, flag:" + String.format("0x%02X", flag));
+        if (mPhyAddr == -1) {
+            mPhyAddr = nativeGetPhysicalAddr();
+        }
         ReportPhysicalAddr(ADDR_BROADCAST, mPhyAddr, HdmiDeviceInfo.DEVICE_PLAYBACK);
         SendVendorId(ADDR_BROADCAST, mVendorId);
         SendImageViewOn(ADDR_TV);
@@ -276,6 +308,9 @@ public class HdmiCecExtend {
         dest = (msg[0] >> 0) & 0xf;
         if (size > 1) {
             opcode = (msg[1] & 0xFF);
+            if (mPhyAddr == -1) {
+                mPhyAddr = nativeGetPhysicalAddr();
+            }
             /* TODO: process messages service can't process */
             switch (opcode) {
             case MESSAGE_GIVE_OSD_NAME:
@@ -291,22 +326,19 @@ public class HdmiCecExtend {
                 break;
 
             case MESSAGE_GIVE_DEVICE_POWER_STATUS:
-                /*modify by wusc:fix report cec power status*/
-                int powerstatus =  HdmiControlManager.POWER_STATUS_ON;
-                if(mPowerManager != null && !mPowerManager.isScreenOn()){
-                    powerstatus = HdmiControlManager.POWER_STATUS_STANDBY;
-                }                 
-                SendReportPowerStatus(init, powerstatus);
+                SendReportPowerStatus(init, HdmiControlManager.POWER_STATUS_ON);
                 break;
 
             case MESSAGE_SET_MENU_LANGUAGE:
-                try {
-                    byte lan[] = new byte[3];
-                    System.arraycopy(msg, 2, lan, 0, 3);
-                    String iso3Language = new String(lan, 0, 3, "US-ASCII");
-                    onLanguageChange(iso3Language);
-                } catch (UnsupportedEncodingException e) {
-                    Slog.d(TAG, "process MESSAGE_SET_MENU_LANGUAGE failed");
+                if (isAutoChangeLanguageOn()) {
+                    try {
+                        byte lan[] = new byte[3];
+                        System.arraycopy(msg, 2, lan, 0, 3);
+                        String iso3Language = new String(lan, 0, 3, "US-ASCII");
+                        onLanguageChange(iso3Language);
+                    } catch (UnsupportedEncodingException e) {
+                        Slog.d(TAG, "process MESSAGE_SET_MENU_LANGUAGE failed");
+                    }
                 }
                 break;
 
@@ -351,17 +383,6 @@ public class HdmiCecExtend {
 
             /* these command will processed by system service */
             case MESSAGE_USER_CONTROL_PRESSED:
-		/*modify by wusc:if goto ap standby, cec should wake up from framework*/
-		boolean keepWakeWhenTethering = SystemProperties.getBoolean("sys.wakelock.tethering", false);
-		if(keepWakeWhenTethering && mPowerManager !=null && !mPowerManager.isScreenOn()){
-			int keycode = (msg[2] & 0xFF);
-			if( keycode == 0x40 || keycode == 0x6d || keycode == 0x09 ){
-				Slog.d(TAG, "cec hdmi wake up !!!" ); 
-				mPowerManager.wakeUp(SystemClock.uptimeMillis(), "android.server.hdmi:WAKE");
-			}
-		}	   
-		break;
-		
             case MESSAGE_USER_CONTROL_RELEASED:
             case MESSAGE_STANDBY:
                 break;
@@ -401,8 +422,10 @@ public class HdmiCecExtend {
     private final Runnable mDelayedRun = new Runnable() {
         @Override
         public void run() {
-            updatePortInfo();
-            oneTouchPlayExt(0);
+            if (isOneTouchPlayOn()) {
+                updatePortInfo();
+                oneTouchPlayExt(0);
+            }
         }
     };
 
@@ -429,6 +452,10 @@ public class HdmiCecExtend {
         SendCecMessage(dest, body);
     }
 
+    private void SendStandby(int dest) {
+        SendCecMessage(dest, buildCecMsg(MESSAGE_STANDBY, EmptyArray.BYTE));
+    }
+
     private void SendActiveSource(int dest, int physicalAddr) {
         byte[] msg = new byte[] {(byte)(MESSAGE_ACTIVE_SOURCE & 0xff),
                                  (byte)((physicalAddr >> 8) & 0xff),
@@ -437,6 +464,14 @@ public class HdmiCecExtend {
         SendCecMessage(dest, msg);
     }
 
+    private void SendInActiveSource(int dest, int physicalAddr) {
+        byte[] msg = new byte[] {(byte)(MESSAGE_INACTIVE_SOURCE & 0xff),
+                                 (byte)((physicalAddr >> 8) & 0xff),
+                                 (byte) (physicalAddr & 0xff)
+                                };
+        SendCecMessage(dest, msg);
+    }
+
     private void ReportPhysicalAddr(int dest, int phyAddr, int type) {
         byte[] msg = new byte[] {(byte)(MESSAGE_REPORT_PHYSICAL_ADDRESS & 0xff),
                                  (byte)((phyAddr >> 8) & 0xff),
@@ -573,6 +608,105 @@ public class HdmiCecExtend {
         return ret;
     }
 
+    private class SettingsObserver extends ContentObserver {
+        public SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            String option = uri.getLastPathSegment();
+            switch (option) {
+                case HdmiCecManager.HDMI_CONTROL_ONE_TOUCH_PLAY_ENABLED:
+                    break;
+                case HdmiCecManager.HDMI_CONTROL_AUTO_CHANGE_LANGUAGE_ENABLED:
+                    if (isAutoChangeLanguageOn()) {
+                        SendGetMenuLanguage(ADDR_TV);
+                    }
+                    break;
+                case DroidLogicTvUtils.TV_CURRENT_DEVICE_ID:
+                    boolean cecOption = (Global.getInt(mContext.getContentResolver(), Global.HDMI_CONTROL_ENABLED, 1) == 1);
+                    if (!cecOption) return;
+                    int id = Settings.System.getInt(mContext.getContentResolver(), DroidLogicTvUtils.TV_CURRENT_DEVICE_ID, 0);
+                    selectHdmiDevice(id);
+                    break;
+            }
+        }
+    }
+
+    private void registerContentObserver() {
+        ContentResolver resolver = mContext.getContentResolver();
+        String[] settings = new String[] {
+                HdmiCecManager.HDMI_CONTROL_ONE_TOUCH_PLAY_ENABLED,
+                HdmiCecManager.HDMI_CONTROL_AUTO_CHANGE_LANGUAGE_ENABLED
+        };
+        for (String s : settings) {
+            resolver.registerContentObserver(Global.getUriFor(s), false, mSettingsObserver,
+                    UserHandle.USER_ALL);
+        }
+        resolver.registerContentObserver(Settings.System.getUriFor(DroidLogicTvUtils.TV_CURRENT_DEVICE_ID),
+                    false, mSettingsObserver, UserHandle.USER_ALL);
+    }
+
+    private boolean isOneTouchPlayOn() {
+        ContentResolver cr = mContext.getContentResolver();
+        return Global.getInt(cr, HdmiCecManager.HDMI_CONTROL_ONE_TOUCH_PLAY_ENABLED, ENABLED) == ENABLED;
+    }
+
+    private boolean isAutoChangeLanguageOn() {
+        ContentResolver cr = mContext.getContentResolver();
+        return Global.getInt(cr, HdmiCecManager.HDMI_CONTROL_AUTO_CHANGE_LANGUAGE_ENABLED, ENABLED) == ENABLED;
+    }
+
+    public void selectHdmiDevice(int deviceId) {
+        if (mHdmiTvClient == null) return;
+        for (HdmiDeviceInfo info : mHdmiTvClient.getDeviceList()) {
+            int id = (info.getPhysicalAddress() >> 12) + DroidLogicTvUtils.DEVICE_ID_HDMI1 - 1;
+            if (id == deviceId) {
+                mHdmiTvClient.deviceSelect(info.getLogicalAddress(), new HdmiTvClient.SelectCallback() {
+                    @Override
+                    public void onComplete(int result) {
+                    }
+                });
+            }
+        }
+    }
+
+    private void onStandby(int reason) {
+        boolean canPowerTv = SystemProperties.getBoolean("sys.cec.auto_tv_off", false);
+        SendInActiveSource(ADDR_TV, mPhyAddr);
+        SendReportPowerStatus(ADDR_TV, HdmiControlManager.POWER_STATUS_STANDBY);
+        Slog.d(TAG, "auto tv off:" + canPowerTv);
+        if (!canPowerTv)
+            return ;
+        switch (reason) {
+            case STANDBY_SCREEN_OFF:
+                SendStandby(ADDR_TV);
+                break;
+            case STANDBY_SHUTDOWN:
+                // ACTION_SHUTDOWN is taken as a signal to power off all the devices.
+                SendStandby(ADDR_BROADCAST);
+                break;
+        }
+    }
+
+    /* for suspend/resume */
+    private class HdmiExtendReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            switch (intent.getAction()) {
+            case Intent.ACTION_SCREEN_OFF:
+                onStandby(STANDBY_SCREEN_OFF);
+                break;
+            case Intent.ACTION_SHUTDOWN:
+                onStandby(STANDBY_SHUTDOWN);
+                break;
+            case Intent.ACTION_SCREEN_ON:
+                break;
+            }
+        }
+    }
+
     /* for native */
     public native int  nativeSendCecMessage(int dest, byte[] body);
     public native void nativeInit(HdmiCecExtend ext);
diff --git a/amlogic/frameworks/core/res/src/com/droidlogic/NtpService.java b/amlogic/frameworks/core/res/src/com/droidlogic/NtpService.java
new file mode 100644
index 0000000..7f526ee
--- /dev/null
+++ b/amlogic/frameworks/core/res/src/com/droidlogic/NtpService.java
@@ -0,0 +1,132 @@
+package com.droidlogic;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.SystemClock;
+import android.util.Log;
+
+public class NtpService extends Service {
+    private static final String TAG = "NtpService";
+    private static final int NTP_TIMEOUT = 3000;
+    private HandlerThread requestTimeThread;
+    private Handler mHandler;
+    private boolean register = false;
+    private static String NtpServers[];
+
+    private BroadcastReceiver mConnectivityReceiver = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if ( ConnectivityManager.CONNECTIVITY_ACTION.equals(action) && ( mHandler != null ) ) {
+                mHandler.removeCallbacks(mSyncRunnable);
+                mHandler.post(mSyncRunnable);
+            }
+        }
+    };
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        NtpServers = getResources().getStringArray(R.array.config_ntpServer_list);
+        registerForConnectivityIntents();
+    }
+
+    @Override
+    public void onDestroy() {
+        cancelReceiver();
+        super.onDestroy();
+    }
+
+    private void cancelReceiver(){
+        if ( register ) {
+            this.unregisterReceiver(mConnectivityReceiver);
+            register = false;
+        }
+    }
+    private void registerForConnectivityIntents() {
+        if (!register) {
+            IntentFilter intentFilter = new IntentFilter();
+            intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+            registerReceiver(mConnectivityReceiver, intentFilter);
+            register = true;
+        }
+    }
+
+    private void init() {
+        requestTimeThread = new HandlerThread("ntp_request");
+        requestTimeThread.start();
+        mHandler = new Handler(requestTimeThread.getLooper());
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        // TODO: Return the communication channel to the service.
+        throw new UnsupportedOperationException("Not yet implemented");
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        if ( requestTimeThread == null ) {
+            init();
+        }
+        return super.onStartCommand(intent, flags, startId);
+    }
+
+    private Runnable mSyncRunnable = new Runnable(){
+        @Override
+        public void run() {
+            SyncTimeLock();
+        }
+    };
+
+    private void SyncTimeLock() {
+        try {
+            Class<?> sntpClass = Class.forName("android.net.SntpClient");
+            Object sntpObject = sntpClass.newInstance();
+            Method getnptMethod = sntpClass.getMethod("getNtpTime", null);
+            Method reqtimeMethod = sntpClass.getMethod("requestTime", String.class, int.class);
+            Method getreference = sntpClass.getMethod("getNtpTimeReference", null);
+            for ( int i=0; (NtpServers != null) && i<NtpServers.length; i++ ) {
+                boolean ret = (boolean) reqtimeMethod.invoke(sntpObject, NtpServers[i], NTP_TIMEOUT);
+                if (ret) {
+                    long now = (long) getnptMethod.invoke(sntpObject, null) + SystemClock.elapsedRealtime() - (long) getreference.invoke(sntpObject, null);
+                    Log.d(TAG,"TIME Set to"+now);
+                    SystemClock.setCurrentTimeMillis(now);
+                    cancelReceiver();
+                    break;
+                }
+            }
+
+        } catch(ClassNotFoundException e) {
+            e.printStackTrace();
+        }catch (InstantiationException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (NoSuchMethodException ex) {
+            ex.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (InvocationTargetException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/amlogic/frameworks/core/res/src/com/droidlogic/Optimization.java b/amlogic/frameworks/core/res/src/com/droidlogic/Optimization.java
index 8277ea4..112863b 100644
--- a/amlogic/frameworks/core/res/src/com/droidlogic/Optimization.java
+++ b/amlogic/frameworks/core/res/src/com/droidlogic/Optimization.java
@@ -1,6 +1,7 @@
 package com.droidlogic;
 
 import android.app.ActivityManager;
+import android.app.ActivityManager.RunningTaskInfo;
 import android.app.Service;
 import android.content.Context;
 import android.content.ComponentName;
@@ -12,6 +13,7 @@ import android.util.Log;
 
 import java.lang.Runnable;
 import java.lang.Thread;
+import java.util.List;
 
 public class Optimization extends Service {
     private static String TAG = "Optimization";
@@ -55,14 +57,17 @@ public class Optimization extends Service {
 
             while (true) {
                 try {
-                    ComponentName cn = am.getRunningTasks (1).get (0).topActivity;
-                    String pkg = cn.getPackageName();
-                    String cls = cn.getClassName();
+                    List< ActivityManager.RunningTaskInfo > task = am.getRunningTasks (1);
+                    if (!task.isEmpty()) {
+                        ComponentName cn = task.get (0).topActivity;
+                        String pkg = cn.getPackageName();
+                        String cls = cn.getClassName();
 
-                    nativeOptimization(pkg, cls);//bench match
+                        nativeOptimization(pkg, cls);//bench match
+                    }
 
                     Thread.sleep(500);
-                } catch (InterruptedException e) {
+                } catch (Exception e) {
                     e.printStackTrace();
                 }
             }
diff --git a/amlogic/frameworks/libtvbinder/include/tvcmd.h b/amlogic/frameworks/libtvbinder/include/tvcmd.h
index fa21b07..d45ff55 100644
--- a/amlogic/frameworks/libtvbinder/include/tvcmd.h
+++ b/amlogic/frameworks/libtvbinder/include/tvcmd.h
@@ -19,7 +19,7 @@ enum tvcmd_e {
     IS_VGA_TIMEING_IN_HDMI = 14,
     GET_VIDEO_PATH_STATUS = 15,
     //GET_VIDEO_STREAM_STATUS = 16,
-    //GET_FIRST_START_SWITCH_TYPE = 17,
+    SET_PREVIEW_WINDOW_MODE = 17,
     SET_PREVIEW_WINDOW = 18,
     GET_SOURCE_CONNECT_STATUS = 19,
     GET_SOURCE_INPUT_LIST = 20,
@@ -487,6 +487,8 @@ enum tvcmd_e {
     GET_AVERAGE_LUMA = 1480,
     GET_AUTO_BACKLIGHT_DATA = 1481,
     SET_AUTO_BACKLIGHT_DATA = 1482,
+
+    GET_ALL_TV_DEVICES = 1490,
 };
 
 #endif  //ANDROID_AMLOGIC_TVCMD_H
diff --git a/amlogic/frameworks/services/systemcontrol/Android.mk b/amlogic/frameworks/services/systemcontrol/Android.mk
index 417d7f5..e8b4350 100644
--- a/amlogic/frameworks/services/systemcontrol/Android.mk
+++ b/amlogic/frameworks/services/systemcontrol/Android.mk
@@ -48,7 +48,8 @@ LOCAL_SRC_FILES:= \
   SysTokenizer.cpp \
   HDCPKey/hdcp22_key.cpp \
   HDCPKey/HdcpRx22Key.cpp \
-  HDCPKey/HdcpKeyDecrypt.cpp
+  HDCPKey/HdcpKeyDecrypt.cpp \
+  HDCPKey/aes.cpp
 
 LOCAL_SHARED_LIBRARIES := \
   libsystemcontrolservice \
diff --git a/amlogic/frameworks/services/systemcontrol/DisplayMode.cpp b/amlogic/frameworks/services/systemcontrol/DisplayMode.cpp
index 0b97046..12f8ba5 100644
--- a/amlogic/frameworks/services/systemcontrol/DisplayMode.cpp
+++ b/amlogic/frameworks/services/systemcontrol/DisplayMode.cpp
@@ -226,7 +226,7 @@ static bool isMatch(uevent_data_t* ueventData, const char* matchName) {
     const char* field = ueventData->buf;
     const char* end = ueventData->buf + ueventData->len + 1;
     do {
-        if (strstr(field, matchName)) {
+        if (!strcmp(field, matchName)) {
             SYS_LOGI("Matched uevent message with pattern: %s", matchName);
             matched = true;
         }
@@ -356,7 +356,7 @@ void DisplayMode::reInit() {
 }
 
     SYS_LOGI("open osd0 and disable video\n");
-    pSysWrite->writeSysfs(SYS_DISABLE_VIDEO, "2");
+    pSysWrite->writeSysfs(SYS_DISABLE_VIDEO, VIDEO_LAYER_AUTO_ENABLE);
     pSysWrite->writeSysfs(DISPLAY_FB0_BLANK, "0");
 }
 
@@ -513,6 +513,10 @@ void DisplayMode::setMboxDisplay(char* hpdstate, output_mode_state state) {
     char outputmode[MODE_LEN] = {0};
     memset(&data, 0, sizeof(hdmi_data_t));
 
+    if (mDisplayType == DISPLAY_TYPE_TV) {
+        pSysWrite->writeSysfs(SYS_DISABLE_VIDEO, VIDEO_LAYER_DISABLE);
+    }
+
     initHdmiData(&data, hpdstate);
     if (pSysWrite->getPropertyBoolean(PROP_HDMIONLY, true)) {
         if (!strcmp(data.hpd_state, "1")) {
@@ -593,7 +597,7 @@ void DisplayMode::setMboxOutputMode(const char* outputmode, output_mode_state st
     bool cvbsMode = false;
 
     strcpy(finalMode, outputmode);
-    addSuffixForMode(finalMode);
+    addSuffixForMode(finalMode, state);
     if (state == OUPUT_MODE_STATE_SWITCH) {
         char curDisplayMode[MODE_LEN] = {0};
         pSysWrite->readSysfs(SYSFS_DISPLAY_MODE, curDisplayMode);
@@ -800,15 +804,16 @@ void DisplayMode::getBestHdmiMode(char* mode, hdmi_data_t* data) {
 
 //get the highest hdmi mode by edid
 void DisplayMode::getHighestHdmiMode(char* mode, hdmi_data_t* data) {
-    const char* KEY = "hz";
-    int intmode, higmode = 0;
-    int keylen = strlen(KEY);
+    const char PMODE = 'p';
+    const char IMODE = 'i';
+    const char* FREQ = "hz";
+    int lenmode = 0, intmode = 0, higmode = 0;
     char value[MODE_LEN] = {0};
     char* type;
     char* start;
     char* pos = data->edid;
     do {
-        pos = strstr(pos, KEY);
+        pos = strstr(pos, FREQ);
         if (pos == NULL) break;
         start = pos;
         while (*start != '\n' && start >= data->edid) {
@@ -817,27 +822,26 @@ void DisplayMode::getHighestHdmiMode(char* mode, hdmi_data_t* data) {
         start++;
         int len = pos - start;
         strncpy(value, start, len);
+        pos = strstr(pos, "\n");
 
-        if ((type = strchr(value, 'p')) != NULL) {
-            if (type - value < 3) {
-                strcpy(mode, MODE_4K2KSMPTE);
-                return;
-            } else {
-                value[type - value] = '1';
-            }
-        } else if ((type = strchr(value, 'i')) != NULL) {
+        if ((type = strchr(value, PMODE)) != NULL && type - value >= 3) {
+            value[type - value] = '1';
+        } else if ((type = strchr(value, IMODE)) != NULL) {
             value[type - value] = '0';
         } else {
-            pos += keylen;
             continue;
         }
         value[len] = '\0';
 
-        if ((intmode = atoi(value)) > higmode) {
+        if ((intmode = atoi(value)) >= higmode) {
+            len = pos - start;
+            if (intmode == higmode && lenmode >= len) continue;
+            lenmode = len;
             higmode = intmode;
-            strncpy(mode, start, (len + keylen));
+            strncpy(mode, start, len);
+            if (mode[len - 1] == '*')  mode[len - 1] = '\0';
+            else mode[len] = '\0';
         }
-        pos += keylen;
     } while (strlen(pos) > 0);
 
     if (higmode == 0) {
@@ -866,7 +870,13 @@ void DisplayMode::filterHdmiMode(char* mode, hdmi_data_t* data) {
         }
         pCmp = pos + step;
     }
-
+    if (DISPLAY_TYPE_TV == mDisplayType) {
+        #ifdef TEST_UBOOT_MODE
+            getBootEnv(UBOOTENV_TESTMODE, mode);
+            if (strlen(mode) != 0)
+               return;
+        #endif
+    }
     //old mode is not support in this TV, so switch to best mode.
 #ifdef USE_BEST_MODE
     getBestHdmiMode(mode, data);
@@ -888,7 +898,7 @@ void DisplayMode::standardMode(char* mode) {
     }
 }
 
-void DisplayMode::addSuffixForMode(char* mode) {
+void DisplayMode::addSuffixForMode(char* mode, output_mode_state state) {
     char save_mode[MODE_LEN] = {0};
 
     strcpy(save_mode, mode);
@@ -900,7 +910,8 @@ void DisplayMode::addSuffixForMode(char* mode) {
         case DISPLAY_MODE_4K2K30HZ:
         case DISPLAY_MODE_4K2K50HZ420:
         case DISPLAY_MODE_4K2K60HZ420:
-            pSysWrite->writeSysfs(DISPLAY_HDMI_MIC, "0");
+            if (OUPUT_MODE_STATE_INIT != state)
+                pSysWrite->writeSysfs(DISPLAY_HDMI_VIC, "0");
             if (isDeepColor()) {
 #if 0
                 char deepColor[MAX_STR_LEN];
@@ -927,6 +938,12 @@ void DisplayMode::addSuffixForMode(char* mode) {
 #endif
             }
             break;
+      case DISPLAY_MODE_4K2K50HZ422:
+            strcat(mode, SUFFIX_10BIT);
+            break;
+      case DISPLAY_MODE_4K2K60HZ422:
+            strcat(mode, SUFFIX_10BIT);
+            break;
     }
 }
 
@@ -1270,6 +1287,9 @@ bool DisplayMode::isEdidChange() {
 
 bool DisplayMode::isBestOutputmode() {
     char isBestMode[MODE_LEN] = {0};
+    if (DISPLAY_TYPE_TV == mDisplayType) {
+        return false;
+    }
     return !getBootEnv(UBOOTENV_ISBESTMODE, isBestMode) || strcmp(isBestMode, "true") == 0;
 }
 
@@ -1293,7 +1313,6 @@ void DisplayMode::setTVOutputMode(const char* outputmode, bool initState) {
     outputheight = position[3];
 
     pSysWrite->writeSysfs(SYSFS_DISPLAY_MODE, outputmode);
-
     char axis[MAX_STR_LEN] = {0};
     sprintf(axis, "%d %d %d %d",
             0, 0, mDisplayWidth - 1, mDisplayHeight - 1);
@@ -1871,10 +1890,14 @@ void* DisplayMode::hdcpTxThreadLoop(void* data) {
         pThiz->pSysWrite->writeSysfs(DISPLAY_FB0_BLANK, "1");
 
         pThiz->hdcpTxAuthenticate(hdcp22, hdcp14);
+        pThiz->pSysWrite->writeSysfs(SYS_DISABLE_VIDEO, VIDEO_LAYER_ENABLE);
 
         pThiz->pSysWrite->writeSysfs(DISPLAY_FB0_BLANK, "0");
         pThiz->pSysWrite->writeSysfs(DISPLAY_FB0_FREESCALE, "0x10001");
     }
+    else{
+        pThiz->pSysWrite->writeSysfs(SYS_DISABLE_VIDEO, VIDEO_LAYER_ENABLE);
+    }
     return NULL;
 }
 
diff --git a/amlogic/frameworks/services/systemcontrol/DisplayMode.h b/amlogic/frameworks/services/systemcontrol/DisplayMode.h
index 093cdf8..9d493dd 100644
--- a/amlogic/frameworks/services/systemcontrol/DisplayMode.h
+++ b/amlogic/frameworks/services/systemcontrol/DisplayMode.h
@@ -39,6 +39,7 @@ using namespace android;
 #endif
 
 //#define USE_BEST_MODE
+#define TEST_UBOOT_MODE
 
 #define DEVICE_STR_MID                  "MID"
 #define DEVICE_STR_MBOX                 "MBOX"
@@ -92,7 +93,7 @@ using namespace android;
 #define DISPLAY_HPD_STATE               "/sys/class/amhdmitx/amhdmitx0/hpd_state"
 #define DISPLAY_HDMI_EDID               "/sys/class/amhdmitx/amhdmitx0/disp_cap"//RX support display mode
 #define DISPLAY_HDMI_DEEP_COLOR         "/sys/class/amhdmitx/amhdmitx0/dc_cap"//RX supoort deep color
-#define DISPLAY_HDMI_MIC                "/sys/class/amhdmitx/amhdmitx0/vic"//if switch between 8bit and 10bit, clear mic first
+#define DISPLAY_HDMI_VIC                "/sys/class/amhdmitx/amhdmitx0/vic"//if switch between 8bit and 10bit, clear mic first
 
 #define DISPLAY_HDMI_AVMUTE             "/sys/devices/virtual/amhdmitx/amhdmitx0/avmute"
 #define DISPLAY_EDID_VALUE              "/sys/class/amhdmitx/amhdmitx0/edid"
@@ -125,6 +126,9 @@ using namespace android;
 #define HDMI_RX_KEY_COMBINE             "/sys/module/tvin_hdmirx/parameters/hdcp22_firmware_ok_flag"
 
 #define VIDEO_LAYER1_UEVENT             "DEVPATH=/devices/virtual/switch/video_layer1"
+#define VIDEO_LAYER_ENABLE    "0"
+#define VIDEO_LAYER_DISABLE    "1"
+#define VIDEO_LAYER_AUTO_ENABLE   "2"   //2:enable video layer when first frame data come
 
 #define PROP_HDMIONLY                   "ro.platform.hdmionly"
 #define PROP_LCD_DENSITY                "ro.sf.lcd_density"
@@ -198,6 +202,7 @@ using namespace android;
 
 #define UBOOTENV_DIGITAUDIO             "ubootenv.var.digitaudiooutput"
 #define UBOOTENV_HDMIMODE               "ubootenv.var.hdmimode"
+#define UBOOTENV_TESTMODE               "ubootenv.var.testmode"
 #define UBOOTENV_CVBSMODE               "ubootenv.var.cvbsmode"
 #define UBOOTENV_OUTPUTMODE             "ubootenv.var.outputmode"
 #define UBOOTENV_ISBESTMODE             "ubootenv.var.is.bestmode"
@@ -378,7 +383,7 @@ private:
     void getHighestHdmiMode(char* mode, hdmi_data_t* data);
     void filterHdmiMode(char * mode, hdmi_data_t* data);
     void standardMode(char* mode);
-    void addSuffixForMode(char* mode);
+    void addSuffixForMode(char* mode, output_mode_state state);
     void getHdmiOutputMode(char *mode, hdmi_data_t* data);
     bool isEdidChange();
     bool isBestOutputmode();
diff --git a/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpKeyDecrypt.cpp b/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpKeyDecrypt.cpp
index ccd0b52..eb1663a 100644
--- a/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpKeyDecrypt.cpp
+++ b/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpKeyDecrypt.cpp
@@ -28,15 +28,28 @@
 #include <string.h>
 #include <errno.h>
 #include "common.h"
+
 #include "HdcpRx22Key.h"
 #include "HdcpKeyDecrypt.h"
+#include "aes.h"
+
+#define KEY_MAX_SIZE   (1024 * 2)
+#define AES_KEY_BIT 128
+#define AES_IV_BIT 128
 
-#define debugP(fmt...) printf("[Debug]"fmt)
-#define errorP(fmt...) printf("[Error]"fmt)
+const unsigned char default_fixed_aeskey[] = {
+    'h',    'e',    'l',    'l',    'o',    '!' ,
+    'a' ,   'm' ,   'l' ,   'o' ,   'g' ,   'i' ,
+    'c' ,   '!' ,   'y',    'l',
+};
+unsigned char default_fixed_iv[] = {
+    'j' ,   'i' ,   'a' ,   'n' ,   'g' ,   'z' ,
+    'e' ,   'm' ,   'i' ,   'n' ,   'b' ,   't' ,
+    '.' ,   'c' ,   'o' ,   'm' ,
+};
 
-#define _KEY_MAX_SIZE   (1024 * 2)
 
-unsigned add_sum(const void* pBuf, const unsigned size)
+unsigned addSum(const void* pBuf, const unsigned size)
 {
     unsigned sum		 =	0;
     const unsigned* data = (const unsigned*)pBuf;
@@ -70,116 +83,44 @@ unsigned add_sum(const void* pBuf, const unsigned size)
     return sum;
 }
 
-#if 0
-static int _save_buf_as_files(const u8* data, const unsigned dataLen, const char* filePath)
-{
-    FILE* pFile = fopen(filePath, "wb");
-    if (!pFile) {
-        errorP("Fail in open (%s) in wb\n", filePath);
-        return __LINE__;
-    }
-    fwrite(data, sizeof(char), dataLen / sizeof(char), pFile);
-    fclose(pFile);
-
-    return 0;
-}
-
-/*
- * Return value, 0 if no error
- * */
-static int hdcp22_key_unpack(const char* keyPath, const char* unPackDir)
+int do_aes(bool isEncrypt, unsigned char* pIn, int nInLen, unsigned char* pOut, int* pOutLen)
 {
-    int ret = __LINE__;
-    char* keyBuf = NULL;
-    unsigned nread = 0;
-    AmlResImgHead_t*  packedImgHead = NULL;
-    AmlResItemHead_t* packedImgItem = NULL;
-    unsigned gensum = 0;
-    int i = 0;
+    int nRet = -1;
+    unsigned char* data = pIn;
+    const int dataLen         = ( ( nInLen + 0xf ) >> 4 ) << 4;
+    unsigned char* transferBuf = NULL;
 
-    FILE* pHdcpKey = fopen(keyPath, "rb");
-    if (!pHdcpKey) {
-        errorP("Fail in fopen(%s)\n", keyPath);
-        return __LINE__;
+    if(!pIn || !nInLen || !pOut || !pOutLen) {
+        //_MSG_BOX_ERR(_T("arg nul"));
+        return -__LINE__;
     }
-
-    fseeko(pHdcpKey, 0, SEEK_END);
-    const unsigned keyFileSz = (unsigned)ftell(pHdcpKey);
-    if ( keyFileSz > _KEY_MAX_SIZE ) {
-        errorP("FileSz %zd > max(%d)\n", keyFileSz, _KEY_MAX_SIZE);
-        ret = __LINE__; goto _exit;
-    }
-
-    keyBuf = new char [_KEY_MAX_SIZE / sizeof(char)];
-    if ( !keyBuf ) {
-        errorP("Fail in alloc buf for key read\n");
-        return __LINE__;
-    }
-
-    fseeko(pHdcpKey, 0, SEEK_SET);
-    nread = fread(keyBuf, 1, keyFileSz, pHdcpKey);
-    if ( nread != keyFileSz ) {
-        errorP("Fail in read key to buf, nread=%d\n", nread);
-        ret = __LINE__; goto _exit;
-    }
-
-    packedImgHead = (AmlResImgHead_t*)keyBuf;
-    packedImgItem = (AmlResItemHead_t*)(packedImgHead + 1);
-
-    gensum = add_sum(keyBuf + 4, keyFileSz - 4);
-    if (packedImgHead->crc != gensum) {
-        errorP("crc chcked failed, origsum[%8x] != gensum[%8x]\n", packedImgHead->crc, gensum);
-        ret = __LINE__; goto _exit;
-    }
-
-    for (i = 0; i < packedImgHead->imgItemNum; ++i)
+    if( nInLen & 0xf )
     {
-        const AmlResItemHead_t* pItem = packedImgItem + i;
-        u8*         itembuf         = (u8*)keyBuf + pItem->dataOffset;
-        const int   itemSz          = pItem->dataSz;
-        const char* itemName =      pItem->name;
-        char  fPath[128];
-
-        const int   dirPathLen  = strlen(unPackDir);
-        const int   itemPathLen = strlen(itemName);
-        if ( 128 - 1 < dirPathLen + itemPathLen ) {
-            errorP("dirPathLen(%d) + itemPathLen(%d) > maxLen(%d)\n", dirPathLen, itemPathLen, 127);
-            ret = __LINE__; goto _exit;
-        }
-        memcpy(fPath, unPackDir, dirPathLen);
-        memcpy(fPath + dirPathLen, itemName, itemPathLen);
-        fPath[dirPathLen + itemPathLen] = '\0';
-
-        ret = _save_buf_as_files(itembuf, itemSz, fPath);
-        if (ret) {
-            errorP("Fail in _save_buf_as_files\n");
-            ret = __LINE__; goto _exit;
-        }
+        transferBuf = new unsigned char [dataLen];
+        data = transferBuf;
     }
 
+    struct aes_context ctx;
+    unsigned char iv[16];
+    //memset(iv, 0, sizeof(iv));
+    memcpy(iv, default_fixed_iv, 16);
 
-    ret = 0;
-_exit:
-    delete[] keyBuf;
-    if (pHdcpKey) fclose(pHdcpKey);
-    return ret;
-}
+    unsigned char key[AES_KEY_BIT/8];
+    memcpy(key, default_fixed_aeskey, sizeof(default_fixed_aeskey));
 
-int main(int argc, char* argv[])
-{
-    int ret = 0;
-    if (argc < 3) {
-        errorP("usages: %s keyPath unpackDirPath\n", argv[0]);
-        return __LINE__;
+    if(isEncrypt) {
+        aes_setkey_enc(&ctx, key, AES_KEY_BIT);
+    }
+    else {
+        aes_setkey_dec(&ctx, key, AES_KEY_BIT);
     }
-    const char* keyPath     = argv[1];
-    const char* unpackDir   = argv[2];
 
-    ret = hdcp22_key_unpack(keyPath, unpackDir);
+    nRet = aes_crypt_cbc(&ctx, isEncrypt, dataLen, iv, pIn, pOut);
 
-    return ret;
+    *pOutLen = dataLen;
+    if(transferBuf) delete[] transferBuf;
+    return nRet;
 }
-#endif
 
 /*
  * inBuf: include random number and hdcp key
@@ -187,13 +128,13 @@ int main(int argc, char* argv[])
 bool hdcpKeyUnpack(const char* inBuf, int inBufLen,
     const char *srcAicPath, const char *desAicPath, const char *keyPath)
 {
-    AmlResImgHead_t*  packedImgHead = NULL;
-    AmlResItemHead_t* packedImgItem = NULL;
+    AmlResImgHead_t *packedImgHead = NULL;
+    AmlResItemHead_t *packedImgItem = NULL;
     unsigned gensum = 0;
     int i = 0;
 
-    if ( inBufLen > _KEY_MAX_SIZE ) {
-        SYS_LOGE("key size %d > max(%d)\n", inBufLen, _KEY_MAX_SIZE);
+    if ( inBufLen > KEY_MAX_SIZE ) {
+        SYS_LOGE("key size %d > max(%d)\n", inBufLen, KEY_MAX_SIZE);
         return false;
     }
 
@@ -205,7 +146,7 @@ bool hdcpKeyUnpack(const char* inBuf, int inBufLen,
     packedImgHead = (AmlResImgHead_t*)inBuf;
     packedImgItem = (AmlResItemHead_t*)(packedImgHead + 1);
 
-    gensum = add_sum(inBuf + 4, inBufLen - 4);
+    gensum = addSum(inBuf + 4, inBufLen - 4);
     if (packedImgHead->crc != gensum) {
         SYS_LOGE("crc chcked failed, origsum[%8x] != gensum[%8x]\n", packedImgHead->crc, gensum);
         return false;
@@ -213,10 +154,15 @@ bool hdcpKeyUnpack(const char* inBuf, int inBufLen,
 
     for (i = 0; i < (int)packedImgHead->imgItemNum; ++i) {
         const AmlResItemHead_t* pItem = packedImgItem + i;
-        u8 *itembuf = (u8*)inBuf + pItem->dataOffset;
-        const int itemSz = pItem->dataSz;
         const char* itemName = pItem->name;
-
+    #if 1
+        int itemSz = 0;
+        unsigned char itembuf[KEY_MAX_SIZE] = {0};
+        do_aes(false, (unsigned char *)(inBuf + pItem->dataOffset), pItem->dataSz, itembuf, &itemSz);
+    #else
+        char *itembuf = (char*)inBuf + pItem->dataOffset;
+        const int itemSz = pItem->dataSz;
+    #endif
         //this item is random number
         if (!strcmp(itemName, "firmware")) {
             int desFd;
@@ -266,4 +212,4 @@ bool hdcpKeyUnpack(const char* inBuf, int inBufLen,
     }
 
     return true;
-}
\ No newline at end of file
+}
diff --git a/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpKeyDecrypt.h b/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpKeyDecrypt.h
index 5269807..f524433 100644
--- a/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpKeyDecrypt.h
+++ b/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpKeyDecrypt.h
@@ -81,6 +81,8 @@ typedef struct {
  *
  */
 
+int do_aes(bool isEncrypt, unsigned char* pIn, int nInLen, unsigned char* pOut, int* pOutLen);
+
 bool hdcpKeyUnpack(const char* inBuf, int inBufLen,
     const char *srcAicPath, const char *desAicPath, const char *keyPath);
 
diff --git a/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpRx22Key.cpp b/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpRx22Key.cpp
index 335a35a..1559d0f 100644
--- a/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpRx22Key.cpp
+++ b/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpRx22Key.cpp
@@ -129,8 +129,8 @@ bool HdcpRx22Key::esmSwap() {
 
 bool HdcpRx22Key::aicTool() {
     char cmd[512] = {0};
-    sprintf(cmd, "%s --format=binary-le -o %s -f %s",
-        HDCP_RX_TOOL_AIC, HDCP_RX_OUT_FW_LE, HDCP_RX_CFG_AIC_DES);
+    sprintf(cmd, "%s --format=binary-le --dwb-only -o %s -f %s",
+        HDCP_RX_TOOL_AIC, HDCP_RX_OUT_2080_BYTE, HDCP_RX_CFG_AIC_DES);
 
     SYS_LOGI("aic tool cmd:%s\n", cmd);
     int ret = system (cmd);
@@ -139,15 +139,86 @@ bool HdcpRx22Key::aicTool() {
         return false;
     }
 
-    if (access(HDCP_RX_OUT_FW_LE, F_OK)) {
-        SYS_LOGE("generate %s fail \n", HDCP_RX_OUT_FW_LE);
+    if (access(HDCP_RX_OUT_2080_BYTE, F_OK)) {
+        SYS_LOGE("generate %s fail \n", HDCP_RX_OUT_2080_BYTE);
         return false;
     }
 
-    SYS_LOGI("generate %s success \n", HDCP_RX_OUT_FW_LE);
+    SYS_LOGI("generate %s success \n", HDCP_RX_OUT_2080_BYTE);
     return true;
 }
 
+//insert 2080 byte into origin firware, combine a new firware
+bool HdcpRx22Key::combineFirmware()
+{
+    bool ret = false;
+    int srcFd = -1;
+    int desFd = -1;
+    int insertFd = -1;
+    char *pSrcData = NULL;
+    char *pInsertData = NULL;
+    int srcSize = 0;
+    int insertSize = 0;
+
+    //read origin firmware.le to buffer
+    srcFd = open(HDCP_RX_SRC_FW_PATH, O_RDONLY);
+    srcSize = lseek(srcFd, 0, SEEK_END);
+    lseek(srcFd, 0, SEEK_SET);
+    pSrcData = (char *)malloc(srcSize + 1);
+    if (NULL == pSrcData) {
+        SYS_LOGE("combine firware, can not malloc source fw:%d memory\n", srcSize);
+        goto exit;
+    }
+    memset((void*)pSrcData, 0, srcSize + 1);
+    read(srcFd, (void*)pSrcData, srcSize);
+    close(srcFd);
+    srcFd = -1;
+
+    //read 2080 bytes to buffer
+    insertFd = open(HDCP_RX_OUT_2080_BYTE, O_RDONLY);
+    insertSize = lseek(insertFd, 0, SEEK_END);
+    if (2080 != insertSize)
+        SYS_LOGE("combine firware, key size is not 2080 bytes\n");
+    lseek(insertFd, 0, SEEK_SET);
+    pInsertData = (char *)malloc(insertSize + 1);
+    if (NULL == pInsertData) {
+        SYS_LOGE("combine firware, can not malloc insert:%d memory\n", insertSize);
+        goto exit;
+    }
+    memset((void*)pInsertData, 0, insertSize + 1);
+    read(insertFd, (void*)pInsertData, insertSize);
+    close(insertFd);
+    insertFd = -1;
+
+    //insert 2080 bytes to the origin firmware.le
+    memcpy(pSrcData + 0x2800, pInsertData, insertSize);
+
+    if ((desFd = open(HDCP_RX_DES_FW_PATH, O_CREAT | O_RDWR | O_TRUNC, 0644)) < 0) {
+        SYS_LOGE("combine firware, open %s error(%s)", HDCP_RX_DES_FW_PATH, strerror(errno));
+        goto exit;
+    }
+
+    //write firmware.le buffer to file
+    write(desFd, pSrcData, srcSize);
+    close(desFd);
+    desFd = -1;
+
+    ret= true;
+exit:
+    if (srcFd >= 0)
+        close(srcFd);
+    if (insertFd >= 0)
+        close(insertFd);
+    if (desFd >= 0)
+        close(desFd);
+
+    if (NULL != pSrcData)
+        free(pSrcData);
+    if (NULL != pInsertData)
+        free(pInsertData);
+    return ret;
+}
+
 bool HdcpRx22Key::generateHdcpRxFw()
 {
     int ret = false;
@@ -200,7 +271,7 @@ bool HdcpRx22Key::generateHdcpRxFw()
     readSys(HDCP_RX_KEY_CRC_PATH, lastCrcData, HDCP_RX_KEY_CRC_LEN);
     lastCrcValue = ((lastCrcData[3]<<24)|(lastCrcData[2]<<16)|(lastCrcData[1]<<8)|(lastCrcData[0]&0xff));
 
-    if (access(HDCP_RX_OUT_FW_LE, F_OK) || keyCrcValue != lastCrcValue) {
+    if (access(HDCP_RX_DES_FW_PATH, F_OK) || keyCrcValue != lastCrcValue) {
         SYS_LOGI("HDCP RX 2.2 firmware don't exist or crc different, need create it, last crc value:0x%x, cur crc value:0x%x\n",
             lastCrcValue, keyCrcValue);
 
@@ -218,10 +289,14 @@ bool HdcpRx22Key::generateHdcpRxFw()
             saveFile(HDCP_RX_KEY_CRC_PATH, keyCrcData, HDCP_RX_KEY_CRC_LEN);
             SYS_LOGI("HDCP RX 2.2 firmware generate success, save crc value:0x%x -> %s\n", keyCrcValue, HDCP_RX_KEY_CRC_PATH);
 
+            combineFirmware();
+
             //remove temporary files
             remove(HDCP_RX_KEY_PATH);
+            remove(HDCP_RX_CFG_AIC_DES);
             remove(HDCP_RX_OUT_KEY_IMG);
             remove(HDCP_RX_OUT_KEY_LE);
+            remove(HDCP_RX_OUT_2080_BYTE);
 
             ret = true;
         }
diff --git a/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpRx22Key.h b/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpRx22Key.h
index 8a83029..140a9ba 100644
--- a/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpRx22Key.h
+++ b/amlogic/frameworks/services/systemcontrol/HDCPKey/HdcpRx22Key.h
@@ -39,8 +39,10 @@
 
 #define HDCP_RX_OUT_KEY_IMG             "/param/dcp_rx.out"
 #define HDCP_RX_OUT_KEY_LE              "/param/hdcp_keys.le"
-#define HDCP_RX_OUT_FW_LE               "/param/firmware.le"
+#define HDCP_RX_OUT_2080_BYTE           "/param/2080.byte"
 
+#define HDCP_RX_SRC_FW_PATH             "/system/etc/firmware/hdcp_rx22/firmware.le"
+#define HDCP_RX_DES_FW_PATH             "/param/firmware.le"
 #define HDCP_RX_KEY_CRC_PATH            "/param/hdcprx22.crc"
 #define HDCP_RX_KEY_CRC_LEN             4
 
@@ -61,6 +63,7 @@ private:
     int writeSys(const char *path, const char *val);
     int readSys(const char *path, char *buf, int count);
     int saveFile(const char *path, const char *buf, int bufLen);
+    bool combineFirmware();
 };
 
 // ----------------------------------------------------------------------------
diff --git a/amlogic/frameworks/services/systemcontrol/HDCPKey/aes.cpp b/amlogic/frameworks/services/systemcontrol/HDCPKey/aes.cpp
new file mode 100644
index 0000000..e95e055
--- /dev/null
+++ b/amlogic/frameworks/services/systemcontrol/HDCPKey/aes.cpp
@@ -0,0 +1,1428 @@
+/*
+ *  FIPS-197 compliant AES implementation
+ *
+ *  Copyright (C) 2006-2010, Brainspark B.V.
+ *
+ *  This file is part of PolarSSL (http://www.polarssl.org)
+ *  Lead Maintainer: Paul Bakker <polarssl_maintainer at polarssl.org>
+ *
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+/* #include "polarssl/config.h" */
+#define POLARSSL_AES_C
+
+#if defined(POLARSSL_AES_C)
+
+/* #include "polarssl/aes.h" */
+/* #if defined(POLARSSL_PADLOCK_C) */
+/* #include "polarssl/padlock.h" */
+/* #endif */
+#include "aes.h"
+
+/*
+ * 32-bit integer manipulation macros (little endian)
+ */
+#ifndef GET_UINT32_LE
+#define GET_UINT32_LE(n, b, i)                            \
+{                                                       \
+	(n) = ((uint32_t) (b)[(i)])             \
+	| ((uint32_t) (b)[(i) + 1] <<  8)             \
+	| ((uint32_t) (b)[(i) + 2] << 16)             \
+	| ((uint32_t) (b)[(i) + 3] << 24);            \
+}
+#endif
+
+#ifndef PUT_UINT32_LE
+#define PUT_UINT32_LE(n, b, i)                            \
+{                                                       \
+	(b)[(i)] = (unsigned char) ((n));       \
+	(b)[(i) + 1] = (unsigned char) ((n) >>  8);       \
+	(b)[(i) + 2] = (unsigned char) ((n) >> 16);       \
+	(b)[(i) + 3] = (unsigned char) ((n) >> 24);       \
+}
+#endif
+
+#if defined(POLARSSL_PADLOCK_C) &&                      \
+	(defined(POLARSSL_HAVE_X86) || defined(PADLOCK_ALIGN16))
+static int aes_padlock_ace = -1;
+#endif
+
+#if defined(POLARSSL_AES_ROM_TABLES)
+/*
+ * Forward S-box
+ */
+static const unsigned char FSb[256] = {
+	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
+	0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
+	0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
+	0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
+	0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
+	0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
+	0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
+	0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
+	0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
+	0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
+	0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
+	0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
+	0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
+	0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
+	0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
+	0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
+	0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
+};
+
+/*
+ * Forward tables
+ */
+#define FT \
+( \
+	V(A5, 63, 63, C6), V(84, 7C, 7C, F8), \
+	V(99, 77, 77, EE), V(8D, 7B, 7B, F6), \
+	V(0D, F2, F2, FF), V(BD, 6B, 6B, D6), \
+	V(B1, 6F, 6F, DE), V(54, C5, C5, 91), \
+	V(50, 30, 30, 60), V(03, 01, 01, 02), \
+	V(A9, 67, 67, CE), V(7D, 2B, 2B, 56), \
+	V(19, FE, FE, E7), V(62, D7, D7, B5), \
+	V(E6, AB, AB, 4D), V(9A, 76, 76, EC), \
+	V(45, CA, CA, 8F), V(9D, 82, 82, 1F), \
+	V(40, C9, C9, 89), V(87, 7D, 7D, FA), \
+	V(15, FA, FA, EF), V(EB, 59, 59, B2), \
+	V(C9, 47, 47, 8E), V(0B, F0, F0, FB), \
+	V(EC, AD, AD, 41), V(67, D4, D4, B3), \
+	V(FD, A2, A2, 5F), V(EA, AF, AF, 45), \
+	V(BF, 9C, 9C, 23), V(F7, A4, A4, 53), \
+	V(96, 72, 72, E4), V(5B, C0, C0, 9B), \
+	V(C2, B7, B7, 75), V(1C, FD, FD, E1), \
+	V(AE, 93, 93, 3D), V(6A, 26, 26, 4C), \
+	V(5A, 36, 36, 6C), V(41, 3F, 3F, 7E), \
+	V(02, F7, F7, F5), V(4F, CC, CC, 83), \
+	V(5C, 34, 34, 68), V(F4, A5, A5, 51), \
+	V(34, E5, E5, D1), V(08, F1, F1, F9), \
+	V(93, 71, 71, E2), V(73, D8, D8, AB), \
+	V(53, 31, 31, 62), V(3F, 15, 15, 2A), \
+	V(0C, 04, 04, 08), V(52, C7, C7, 95), \
+	V(65, 23, 23, 46), V(5E, C3, C3, 9D), \
+	V(28, 18, 18, 30), V(A1, 96, 96, 37), \
+	V(0F, 05, 05, 0A), V(B5, 9A, 9A, 2F), \
+	V(09, 07, 07, 0E), V(36, 12, 12, 24), \
+	V(9B, 80, 80, 1B), V(3D, E2, E2, DF), \
+	V(26, EB, EB, CD), V(69, 27, 27, 4E), \
+	V(CD, B2, B2, 7F), V(9F, 75, 75, EA), \
+	V(1B, 09, 09, 12), V(9E, 83, 83, 1D), \
+	V(74, 2C, 2C, 58), V(2E, 1A, 1A, 34), \
+	V(2D, 1B, 1B, 36), V(B2, 6E, 6E, DC), \
+	V(EE, 5A, 5A, B4), V(FB, A0, A0, 5B), \
+	V(F6, 52, 52, A4), V(4D, 3B, 3B, 76), \
+	V(61, D6, D6, B7), V(CE, B3, B3, 7D), \
+	V(7B, 29, 29, 52), V(3E, E3, E3, DD), \
+	V(71, 2F, 2F, 5E), V(97, 84, 84, 13), \
+	V(F5, 53, 53, A6), V(68, D1, D1, B9), \
+	V(00, 00, 00, 00), V(2C, ED, ED, C1), \
+	V(60, 20, 20, 40), V(1F, FC, FC, E3), \
+	V(C8, B1, B1, 79), V(ED, 5B, 5B, B6), \
+	V(BE, 6A, 6A, D4), V(46, CB, CB, 8D), \
+	V(D9, BE, BE, 67), V(4B, 39, 39, 72), \
+	V(DE, 4A, 4A, 94), V(D4, 4C, 4C, 98), \
+	V(E8, 58, 58, B0), V(4A, CF, CF, 85), \
+	V(6B, D0, D0, BB), V(2A, EF, EF, C5), \
+	V(E5, AA, AA, 4F), V(16, FB, FB, ED), \
+	V(C5, 43, 43, 86), V(D7, 4D, 4D, 9A), \
+	V(55, 33, 33, 66), V(94, 85, 85, 11), \
+	V(CF, 45, 45, 8A), V(10, F9, F9, E9), \
+	V(06, 02, 02, 04), V(81, 7F, 7F, FE), \
+	V(F0, 50, 50, A0), V(44, 3C, 3C, 78), \
+	V(BA, 9F, 9F, 25), V(E3, A8, A8, 4B), \
+	V(F3, 51, 51, A2), V(FE, A3, A3, 5D), \
+	V(C0, 40, 40, 80), V(8A, 8F, 8F, 05), \
+	V(AD, 92, 92, 3F), V(BC, 9D, 9D, 21), \
+	V(48, 38, 38, 70), V(04, F5, F5, F1), \
+	V(DF, BC, BC, 63), V(C1, B6, B6, 77), \
+	V(75, DA, DA, AF), V(63, 21, 21, 42), \
+	V(30, 10, 10, 20), V(1A, FF, FF, E5), \
+	V(0E, F3, F3, FD), V(6D, D2, D2, BF), \
+	V(4C, CD, CD, 81), V(14, 0C, 0C, 18), \
+	V(35, 13, 13, 26), V(2F, EC, EC, C3), \
+	V(E1, 5F, 5F, BE), V(A2, 97, 97, 35), \
+	V(CC, 44, 44, 88), V(39, 17, 17, 2E), \
+	V(57, C4, C4, 93), V(F2, A7, A7, 55), \
+	V(82, 7E, 7E, FC), V(47, 3D, 3D, 7A), \
+	V(AC, 64, 64, C8), V(E7, 5D, 5D, BA), \
+	V(2B, 19, 19, 32), V(95, 73, 73, E6), \
+	V(A0, 60, 60, C0), V(98, 81, 81, 19), \
+	V(D1, 4F, 4F, 9E), V(7F, DC, DC, A3), \
+	V(66, 22, 22, 44), V(7E, 2A, 2A, 54), \
+	V(AB, 90, 90, 3B), V(83, 88, 88, 0B), \
+	V(CA, 46, 46, 8C), V(29, EE, EE, C7), \
+	V(D3, B8, B8, 6B), V(3C, 14, 14, 28), \
+	V(79, DE, DE, A7), V(E2, 5E, 5E, BC), \
+	V(1D, 0B, 0B, 16), V(76, DB, DB, AD), \
+	V(3B, E0, E0, DB), V(56, 32, 32, 64), \
+	V(4E, 3A, 3A, 74), V(1E, 0A, 0A, 14), \
+	V(DB, 49, 49, 92), V(0A, 06, 06, 0C), \
+	V(6C, 24, 24, 48), V(E4, 5C, 5C, B8), \
+	V(5D, C2, C2, 9F), V(6E, D3, D3, BD), \
+	V(EF, AC, AC, 43), V(A6, 62, 62, C4), \
+	V(A8, 91, 91, 39), V(A4, 95, 95, 31), \
+	V(37, E4, E4, D3), V(8B, 79, 79, F2), \
+	V(32, E7, E7, D5), V(43, C8, C8, 8B), \
+	V(59, 37, 37, 6E), V(B7, 6D, 6D, DA), \
+	V(8C, 8D, 8D, 01), V(64, D5, D5, B1), \
+	V(D2, 4E, 4E, 9C), V(E0, A9, A9, 49), \
+	V(B4, 6C, 6C, D8), V(FA, 56, 56, AC), \
+	V(07, F4, F4, F3), V(25, EA, EA, CF), \
+	V(AF, 65, 65, CA), V(8E, 7A, 7A, F4), \
+	V(E9, AE, AE, 47), V(18, 08, 08, 10), \
+	V(D5, BA, BA, 6F), V(88, 78, 78, F0), \
+	V(6F, 25, 25, 4A), V(72, 2E, 2E, 5C), \
+	V(24, 1C, 1C, 38), V(F1, A6, A6, 57), \
+	V(C7, B4, B4, 73), V(51, C6, C6, 97), \
+	V(23, E8, E8, CB), V(7C, DD, DD, A1), \
+	V(9C, 74, 74, E8), V(21, 1F, 1F, 3E), \
+	V(DD, 4B, 4B, 96), V(DC, BD, BD, 61), \
+	V(86, 8B, 8B, 0D), V(85, 8A, 8A, 0F), \
+	V(90, 70, 70, E0), V(42, 3E, 3E, 7C), \
+	V(C4, B5, B5, 71), V(AA, 66, 66, CC), \
+	V(D8, 48, 48, 90), V(05, 03, 03, 06), \
+	V(01, F6, F6, F7), V(12, 0E, 0E, 1C), \
+	V(A3, 61, 61, C2), V(5F, 35, 35, 6A), \
+	V(F9, 57, 57, AE), V(D0, B9, B9, 69), \
+	V(91, 86, 86, 17), V(58, C1, C1, 99), \
+	V(27, 1D, 1D, 3A), V(B9, 9E, 9E, 27), \
+	V(38, E1, E1, D9), V(13, F8, F8, EB), \
+	V(B3, 98, 98, 2B), V(33, 11, 11, 22), \
+	V(BB, 69, 69, D2), V(70, D9, D9, A9), \
+	V(89, 8E, 8E, 07), V(A7, 94, 94, 33), \
+	V(B6, 9B, 9B, 2D), V(22, 1E, 1E, 3C), \
+	V(92, 87, 87, 15), V(20, E9, E9, C9), \
+	V(49, CE, CE, 87), V(FF, 55, 55, AA), \
+	V(78, 28, 28, 50), V(7A, DF, DF, A5), \
+	V(8F, 8C, 8C, 03), V(F8, A1, A1, 59), \
+	V(80, 89, 89, 09), V(17, 0D, 0D, 1A), \
+	V(DA, BF, BF, 65), V(31, E6, E6, D7), \
+	V(C6, 42, 42, 84), V(B8, 68, 68, D0), \
+	V(C3, 41, 41, 82), V(B0, 99, 99, 29), \
+	V(77, 2D, 2D, 5A), V(11, 0F, 0F, 1E), \
+	V(CB, B0, B0, 7B), V(FC, 54, 54, A8), \
+	V(D6, BB, BB, 6D), V(3A, 16, 16, 2C))
+
+#define V(a, b, c, d) (0x##a##b##c##d)
+static const uint32_t FT0[256] = { FT };
+
+#undef V
+
+#define V(a, b, c, d) (0x##b##c##d##a)
+static const uint32_t FT1[256] = { FT };
+
+#undef V
+
+#define V(a, b, c, d) (0x##c##d##a##b)
+static const uint32_t FT2[256] = { FT };
+
+#undef V
+
+#define V(a, b, c, d) (0x##d##a##b##c)
+static const uint32_t FT3[256] = { FT };
+
+#undef V
+
+#undef FT
+
+/*
+ * Reverse S-box
+ */
+static const unsigned char RSb[256] = {
+	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
+	0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
+	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
+	0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
+	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
+	0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
+	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
+	0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
+	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
+	0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
+	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
+	0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
+	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
+	0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
+	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
+	0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
+	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
+	0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
+	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
+	0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
+	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
+	0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
+	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
+	0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
+	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
+	0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
+	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
+	0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
+	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
+	0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
+	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
+	0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
+};
+
+/*
+ * Reverse tables
+ */
+#define RT \
+	( \
+	V(50, A7, F4, 51), V(53, 65, 41, 7E), \
+	V(C3, A4, 17, 1A), V(96, 5E, 27, 3A), \
+	V(CB, 6B, AB, 3B), V(F1, 45, 9D, 1F), \
+	V(AB, 58, FA, AC), V(93, 03, E3, 4B), \
+	V(55, FA, 30, 20), V(F6, 6D, 76, AD), \
+	V(91, 76, CC, 88), V(25, 4C, 02, F5), \
+	V(FC, D7, E5, 4F), V(D7, CB, 2A, C5), \
+	V(80, 44, 35, 26), V(8F, A3, 62, B5), \
+	V(49, 5A, B1, DE), V(67, 1B, BA, 25), \
+	V(98, 0E, EA, 45), V(E1, C0, FE, 5D), \
+	V(02, 75, 2F, C3), V(12, F0, 4C, 81), \
+	V(A3, 97, 46, 8D), V(C6, F9, D3, 6B), \
+	V(E7, 5F, 8F, 03), V(95, 9C, 92, 15), \
+	V(EB, 7A, 6D, BF), V(DA, 59, 52, 95), \
+	V(2D, 83, BE, D4), V(D3, 21, 74, 58), \
+	V(29, 69, E0, 49), V(44, C8, C9, 8E), \
+	V(6A, 89, C2, 75), V(78, 79, 8E, F4), \
+	V(6B, 3E, 58, 99), V(DD, 71, B9, 27), \
+	V(B6, 4F, E1, BE), V(17, AD, 88, F0), \
+	V(66, AC, 20, C9), V(B4, 3A, CE, 7D), \
+	V(18, 4A, DF, 63), V(82, 31, 1A, E5), \
+	V(60, 33, 51, 97), V(45, 7F, 53, 62), \
+	V(E0, 77, 64, B1), V(84, AE, 6B, BB), \
+	V(1C, A0, 81, FE), V(94, 2B, 08, F9), \
+	V(58, 68, 48, 70), V(19, FD, 45, 8F), \
+	V(87, 6C, DE, 94), V(B7, F8, 7B, 52), \
+	V(23, D3, 73, AB), V(E2, 02, 4B, 72), \
+	V(57, 8F, 1F, E3), V(2A, AB, 55, 66), \
+	V(07, 28, EB, B2), V(03, C2, B5, 2F), \
+	V(9A, 7B, C5, 86), V(A5, 08, 37, D3), \
+	V(F2, 87, 28, 30), V(B2, A5, BF, 23), \
+	V(BA, 6A, 03, 02), V(5C, 82, 16, ED), \
+	V(2B, 1C, CF, 8A), V(92, B4, 79, A7), \
+	V(F0, F2, 07, F3), V(A1, E2, 69, 4E), \
+	V(CD, F4, DA, 65), V(D5, BE, 05, 06), \
+	V(1F, 62, 34, D1), V(8A, FE, A6, C4), \
+	V(9D, 53, 2E, 34), V(A0, 55, F3, A2), \
+	V(32, E1, 8A, 05), V(75, EB, F6, A4), \
+	V(39, EC, 83, 0B), V(AA, EF, 60, 40), \
+	V(06, 9F, 71, 5E), V(51, 10, 6E, BD), \
+	V(F9, 8A, 21, 3E), V(3D, 06, DD, 96), \
+	V(AE, 05, 3E, DD), V(46, BD, E6, 4D), \
+	V(B5, 8D, 54, 91), V(05, 5D, C4, 71), \
+	V(6F, D4, 06, 04), V(FF, 15, 50, 60), \
+	V(24, FB, 98, 19), V(97, E9, BD, D6), \
+	V(CC, 43, 40, 89), V(77, 9E, D9, 67), \
+	V(BD, 42, E8, B0), V(88, 8B, 89, 07), \
+	V(38, 5B, 19, E7), V(DB, EE, C8, 79), \
+	V(47, 0A, 7C, A1), V(E9, 0F, 42, 7C), \
+	V(C9, 1E, 84, F8), V(00, 00, 00, 00), \
+	V(83, 86, 80, 09), V(48, ED, 2B, 32), \
+	V(AC, 70, 11, 1E), V(4E, 72, 5A, 6C), \
+	V(FB, FF, 0E, FD), V(56, 38, 85, 0F), \
+	V(1E, D5, AE, 3D), V(27, 39, 2D, 36), \
+	V(64, D9, 0F, 0A), V(21, A6, 5C, 68), \
+	V(D1, 54, 5B, 9B), V(3A, 2E, 36, 24), \
+	V(B1, 67, 0A, 0C), V(0F, E7, 57, 93), \
+	V(D2, 96, EE, B4), V(9E, 91, 9B, 1B), \
+	V(4F, C5, C0, 80), V(A2, 20, DC, 61), \
+	V(69, 4B, 77, 5A), V(16, 1A, 12, 1C), \
+	V(0A, BA, 93, E2), V(E5, 2A, A0, C0), \
+	V(43, E0, 22, 3C), V(1D, 17, 1B, 12), \
+	V(0B, 0D, 09, 0E), V(AD, C7, 8B, F2), \
+	V(B9, A8, B6, 2D), V(C8, A9, 1E, 14), \
+	V(85, 19, F1, 57), V(4C, 07, 75, AF), \
+	V(BB, DD, 99, EE), V(FD, 60, 7F, A3), \
+	V(9F, 26, 01, F7), V(BC, F5, 72, 5C), \
+	V(C5, 3B, 66, 44), V(34, 7E, FB, 5B), \
+	V(76, 29, 43, 8B), V(DC, C6, 23, CB), \
+	V(68, FC, ED, B6), V(63, F1, E4, B8), \
+	V(CA, DC, 31, D7), V(10, 85, 63, 42), \
+	V(40, 22, 97, 13), V(20, 11, C6, 84), \
+	V(7D, 24, 4A, 85), V(F8, 3D, BB, D2), \
+	V(11, 32, F9, AE), V(6D, A1, 29, C7), \
+	V(4B, 2F, 9E, 1D), V(F3, 30, B2, DC), \
+	V(EC, 52, 86, 0D), V(D0, E3, C1, 77), \
+	V(6C, 16, B3, 2B), V(99, B9, 70, A9), \
+	V(FA, 48, 94, 11), V(22, 64, E9, 47), \
+	V(C4, 8C, FC, A8), V(1A, 3F, F0, A0), \
+	V(D8, 2C, 7D, 56), V(EF, 90, 33, 22), \
+	V(C7, 4E, 49, 87), V(C1, D1, 38, D9), \
+	V(FE, A2, CA, 8C), V(36, 0B, D4, 98), \
+	V(CF, 81, F5, A6), V(28, DE, 7A, A5), \
+	V(26, 8E, B7, DA), V(A4, BF, AD, 3F), \
+	V(E4, 9D, 3A, 2C), V(0D, 92, 78, 50), \
+	V(9B, CC, 5F, 6A), V(62, 46, 7E, 54), \
+	V(C2, 13, 8D, F6), V(E8, B8, D8, 90), \
+	V(5E, F7, 39, 2E), V(F5, AF, C3, 82), \
+	V(BE, 80, 5D, 9F), V(7C, 93, D0, 69), \
+	V(A9, 2D, D5, 6F), V(B3, 12, 25, CF), \
+	V(3B, 99, AC, C8), V(A7, 7D, 18, 10), \
+	V(6E, 63, 9C, E8), V(7B, BB, 3B, DB), \
+	V(09, 78, 26, CD), V(F4, 18, 59, 6E), \
+	V(01, B7, 9A, EC), V(A8, 9A, 4F, 83), \
+	V(65, 6E, 95, E6), V(7E, E6, FF, AA), \
+	V(08, CF, BC, 21), V(E6, E8, 15, EF), \
+	V(D9, 9B, E7, BA), V(CE, 36, 6F, 4A), \
+	V(D4, 09, 9F, EA), V(D6, 7C, B0, 29), \
+	V(AF, B2, A4, 31), V(31, 23, 3F, 2A), \
+	V(30, 94, A5, C6), V(C0, 66, A2, 35), \
+	V(37, BC, 4E, 74), V(A6, CA, 82, FC), \
+	V(B0, D0, 90, E0), V(15, D8, A7, 33), \
+	V(4A, 98, 04, F1), V(F7, DA, EC, 41), \
+	V(0E, 50, CD, 7F), V(2F, F6, 91, 17), \
+	V(8D, D6, 4D, 76), V(4D, B0, EF, 43), \
+	V(54, 4D, AA, CC), V(DF, 04, 96, E4), \
+	V(E3, B5, D1, 9E), V(1B, 88, 6A, 4C), \
+	V(B8, 1F, 2C, C1), V(7F, 51, 65, 46), \
+	V(04, EA, 5E, 9D), V(5D, 35, 8C, 01), \
+	V(73, 74, 87, FA), V(2E, 41, 0B, FB), \
+	V(5A, 1D, 67, B3), V(52, D2, DB, 92), \
+	V(33, 56, 10, E9), V(13, 47, D6, 6D), \
+	V(8C, 61, D7, 9A), V(7A, 0C, A1, 37), \
+	V(8E, 14, F8, 59), V(89, 3C, 13, EB), \
+	V(EE, 27, A9, CE), V(35, C9, 61, B7), \
+	V(ED, E5, 1C, E1), V(3C, B1, 47, 7A), \
+	V(59, DF, D2, 9C), V(3F, 73, F2, 55), \
+	V(79, CE, 14, 18), V(BF, 37, C7, 73), \
+	V(EA, CD, F7, 53), V(5B, AA, FD, 5F), \
+	V(14, 6F, 3D, DF), V(86, DB, 44, 78), \
+	V(81, F3, AF, CA), V(3E, C4, 68, B9), \
+	V(2C, 34, 24, 38), V(5F, 40, A3, C2), \
+	V(72, C3, 1D, 16), V(0C, 25, E2, BC), \
+	V(8B, 49, 3C, 28), V(41, 95, 0D, FF), \
+	V(71, 01, A8, 39), V(DE, B3, 0C, 08), \
+	V(9C, E4, B4, D8), V(90, C1, 56, 64), \
+	V(61, 84, CB, 7B), V(70, B6, 32, D5), \
+	V(74, 5C, 6C, 48), V(42, 57, B8, D0))
+
+#define V(a, b, c, d) (0x##a##b##c##d)
+static const uint32_t RT0[256] = { RT };
+
+#undef V
+
+#define V(a, b, c, d) (0x##b##c##d##a)
+static const uint32_t RT1[256] = { RT };
+
+#undef V
+
+#define V(a, b, c, d) (0x##c##d##a##b)
+static const uint32_t RT2[256] = { RT };
+
+#undef V
+
+#define V(a, b, c, d)  (0x##d##a##b##c)
+static const uint32_t RT3[256] = { RT };
+
+#undef V
+
+#undef RT
+
+/*
+ * Round constants
+ */
+static const uint32_t RCON[10] = {
+	0x00000001, 0x00000002, 0x00000004, 0x00000008,
+	0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x0000001B, 0x00000036
+};
+
+#else
+
+/*
+ * Forward S-box & tables
+ */
+static unsigned char FSb[256];
+static uint32_t FT0[256];
+static uint32_t FT1[256];
+static uint32_t FT2[256];
+static uint32_t FT3[256];
+
+/*
+ * Reverse S-box & tables
+ */
+static unsigned char RSb[256];
+static uint32_t RT0[256];
+static uint32_t RT1[256];
+static uint32_t RT2[256];
+static uint32_t RT3[256];
+
+/*
+ * Round constants
+ */
+static uint32_t RCON[10];
+
+/*
+ * Tables generation code
+ */
+#define ROTL8(x) (((x << 8) & 0xFFFFFFFF) | (x >> 24))
+#define XTIME(x) ((x << 1) ^ ((x & 0x80) ? 0x1B : 0x00))
+#define MUL(x, y) ((x && y) ? pow[(log[x]+log[y]) % 255] : 0)
+
+static int aes_init_done;
+
+static void aes_gen_tables(void)
+{
+	int i, x, y, z;
+	int pow[256];
+	int log[256];
+
+	/*
+	 * compute pow and log tables over GF(2^8)
+	 */
+	for (i = 0, x = 1; i < 256; i++) {
+		pow[i] = x;
+		log[x] = i;
+		x = (x ^ XTIME(x)) & 0xFF;
+	}
+
+	/*
+	 * calculate the round constants
+	 */
+	for (i = 0, x = 1; i < 10; i++) {
+		RCON[i] = (uint32_t) x;
+		x = XTIME(x) & 0xFF;
+	}
+
+	/*
+	 * generate the forward and reverse S-boxes
+	 */
+	FSb[0x00] = 0x63;
+	RSb[0x63] = 0x00;
+
+	for (i = 1; i < 256; i++) {
+		x = pow[255 - log[i]];
+
+		y = x;
+		y = ((y << 1) | (y >> 7)) & 0xFF;
+		x ^= y;
+		y = ((y << 1) | (y >> 7)) & 0xFF;
+		x ^= y;
+		y = ((y << 1) | (y >> 7)) & 0xFF;
+		x ^= y;
+		y = ((y << 1) | (y >> 7)) & 0xFF;
+		x ^= y ^ 0x63;
+
+		FSb[i] = (unsigned char)x;
+		RSb[x] = (unsigned char)i;
+	}
+
+	/*
+	 * generate the forward and reverse tables
+	 */
+	for (i = 0; i < 256; i++) {
+		x = FSb[i];
+		y = XTIME(x) & 0xFF;
+		z = (y ^ x) & 0xFF;
+
+		FT0[i] = ((uint32_t) y) ^
+		    ((uint32_t) x << 8) ^
+		    ((uint32_t) x << 16) ^ ((uint32_t) z << 24);
+
+		FT1[i] = ROTL8(FT0[i]);
+		FT2[i] = ROTL8(FT1[i]);
+		FT3[i] = ROTL8(FT2[i]);
+
+		x = RSb[i];
+
+		RT0[i] = ((uint32_t) MUL(0x0E, x)) ^
+		    ((uint32_t) MUL(0x09, x) << 8) ^
+		    ((uint32_t) MUL(0x0D, x) << 16) ^
+		    ((uint32_t) MUL(0x0B, x) << 24);
+
+		RT1[i] = ROTL8(RT0[i]);
+		RT2[i] = ROTL8(RT1[i]);
+		RT3[i] = ROTL8(RT2[i]);
+	}
+}
+
+#endif
+
+/*
+ * AES key schedule (encryption)
+ */
+int aes_setkey_enc(struct aes_context *ctx, const unsigned char *key,
+		   unsigned int keysize)
+{
+	unsigned int i;
+	uint32_t *RK;
+
+#if !defined(POLARSSL_AES_ROM_TABLES)
+	if (aes_init_done == 0) {
+		aes_gen_tables();
+		aes_init_done = 1;
+
+	}
+#endif
+
+	switch (keysize) {
+	case 128:
+		ctx->nr = 10;
+		break;
+	case 192:
+		ctx->nr = 12;
+		break;
+	case 256:
+		ctx->nr = 14;
+		break;
+	default:
+		return POLARSSL_ERR_AES_INVALID_KEY_LENGTH;
+	}
+
+#if defined(POLARSSL_PADLOCK_C) && defined(PADLOCK_ALIGN16)
+	if (aes_padlock_ace == -1)
+		aes_padlock_ace = padlock_supports(PADLOCK_ACE);
+
+	if (aes_padlock_ace)
+		ctx->rk = RK = PADLOCK_ALIGN16(ctx->buf);
+	else
+#endif
+		ctx->rk = RK = ctx->buf;
+
+	for (i = 0; i < (keysize >> 5); i++)
+		GET_UINT32_LE(RK[i], key, i << 2);
+
+	switch (ctx->nr) {
+	case 10:
+
+		for (i = 0; i < 10; i++, RK += 4) {
+			RK[4] = RK[0] ^ RCON[i] ^
+			    ((uint32_t) FSb[(RK[3] >> 8) & 0xFF]) ^
+			    ((uint32_t) FSb[(RK[3] >> 16) & 0xFF] << 8) ^
+			    ((uint32_t) FSb[(RK[3] >> 24) & 0xFF] << 16) ^
+			    ((uint32_t) FSb[(RK[3]) & 0xFF] << 24);
+
+			RK[5] = RK[1] ^ RK[4];
+			RK[6] = RK[2] ^ RK[5];
+			RK[7] = RK[3] ^ RK[6];
+		}
+		break;
+
+	case 12:
+
+		for (i = 0; i < 8; i++, RK += 6) {
+			RK[6] = RK[0] ^ RCON[i] ^
+			    ((uint32_t) FSb[(RK[5] >> 8) & 0xFF]) ^
+			    ((uint32_t) FSb[(RK[5] >> 16) & 0xFF] << 8) ^
+			    ((uint32_t) FSb[(RK[5] >> 24) & 0xFF] << 16) ^
+			    ((uint32_t) FSb[(RK[5]) & 0xFF] << 24);
+
+			RK[7] = RK[1] ^ RK[6];
+			RK[8] = RK[2] ^ RK[7];
+			RK[9] = RK[3] ^ RK[8];
+			RK[10] = RK[4] ^ RK[9];
+			RK[11] = RK[5] ^ RK[10];
+		}
+		break;
+
+	case 14:
+
+		for (i = 0; i < 7; i++, RK += 8) {
+			RK[8] = RK[0] ^ RCON[i] ^
+			    ((uint32_t) FSb[(RK[7] >> 8) & 0xFF]) ^
+			    ((uint32_t) FSb[(RK[7] >> 16) & 0xFF] << 8) ^
+			    ((uint32_t) FSb[(RK[7] >> 24) & 0xFF] << 16) ^
+			    ((uint32_t) FSb[(RK[7]) & 0xFF] << 24);
+
+			RK[9] = RK[1] ^ RK[8];
+			RK[10] = RK[2] ^ RK[9];
+			RK[11] = RK[3] ^ RK[10];
+
+			RK[12] = RK[4] ^
+			    ((uint32_t) FSb[(RK[11]) & 0xFF]) ^
+			    ((uint32_t) FSb[(RK[11] >> 8) & 0xFF] << 8) ^
+			    ((uint32_t) FSb[(RK[11] >> 16) & 0xFF] << 16) ^
+			    ((uint32_t) FSb[(RK[11] >> 24) & 0xFF] << 24);
+
+			RK[13] = RK[5] ^ RK[12];
+			RK[14] = RK[6] ^ RK[13];
+			RK[15] = RK[7] ^ RK[14];
+		}
+		break;
+
+	default:
+
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * AES key schedule (decryption)
+ */
+int aes_setkey_dec(struct aes_context *ctx, const unsigned char *key,
+		   unsigned int keysize)
+{
+	int i, j;
+	struct aes_context cty;
+	uint32_t *RK;
+	uint32_t *SK;
+	int ret;
+
+	switch (keysize) {
+	case 128:
+		ctx->nr = 10;
+		break;
+	case 192:
+		ctx->nr = 12;
+		break;
+	case 256:
+		ctx->nr = 14;
+		break;
+	default:
+		return POLARSSL_ERR_AES_INVALID_KEY_LENGTH;
+	}
+
+#if defined(POLARSSL_PADLOCK_C) && defined(PADLOCK_ALIGN16)
+	if (aes_padlock_ace == -1)
+		aes_padlock_ace = padlock_supports(PADLOCK_ACE);
+
+	if (aes_padlock_ace)
+		ctx->rk = RK = PADLOCK_ALIGN16(ctx->buf);
+	else
+#endif
+		ctx->rk = RK = ctx->buf;
+
+	ret = aes_setkey_enc(&cty, key, keysize);
+	if (ret != 0)
+		return ret;
+
+	SK = cty.rk + cty.nr * 4;
+
+	*RK++ = *SK++;
+	*RK++ = *SK++;
+	*RK++ = *SK++;
+	*RK++ = *SK++;
+
+	for (i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8) {
+		for (j = 0; j < 4; j++, SK++) {
+			*RK++ = RT0[FSb[(*SK) & 0xFF]] ^
+			    RT1[FSb[(*SK >> 8) & 0xFF]] ^
+			    RT2[FSb[(*SK >> 16) & 0xFF]] ^
+			    RT3[FSb[(*SK >> 24) & 0xFF]];
+		}
+	}
+
+	*RK++ = *SK++;
+	*RK++ = *SK++;
+	*RK++ = *SK++;
+	*RK++ = *SK++;
+
+	memset(&cty, 0, sizeof(struct aes_context));
+
+	return 0;
+}
+
+#define AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3)     \
+{                                               \
+	X0 = *RK++ ^ FT0[(Y0) & 0xFF] ^   \
+		FT1[(Y1 >>  8) & 0xFF] ^   \
+		FT2[(Y2 >> 16) & 0xFF] ^   \
+		FT3[(Y3 >> 24) & 0xFF];    \
+						\
+	X1 = *RK++ ^ FT0[(Y1) & 0xFF] ^   \
+		FT1[(Y2 >>  8) & 0xFF] ^   \
+		FT2[(Y3 >> 16) & 0xFF] ^   \
+		FT3[(Y0 >> 24) & 0xFF];    \
+						\
+	X2 = *RK++ ^ FT0[(Y2) & 0xFF] ^   \
+		FT1[(Y3 >>  8) & 0xFF] ^   \
+		FT2[(Y0 >> 16) & 0xFF] ^   \
+		FT3[(Y1 >> 24) & 0xFF];    \
+						\
+	X3 = *RK++ ^ FT0[(Y3) & 0xFF] ^   \
+		FT1[(Y0 >>  8) & 0xFF] ^   \
+		FT2[(Y1 >> 16) & 0xFF] ^   \
+		FT3[(Y2 >> 24) & 0xFF];    \
+}
+
+#define AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3)     \
+{                                               \
+	X0 = *RK++ ^ RT0[(Y0) & 0xFF] ^   \
+		 RT1[(Y3 >>  8) & 0xFF] ^   \
+		 RT2[(Y2 >> 16) & 0xFF] ^   \
+		 RT3[(Y1 >> 24) & 0xFF];    \
+					\
+	X1 = *RK++ ^ RT0[(Y1) & 0xFF] ^   \
+		RT1[(Y0 >>  8) & 0xFF] ^   \
+		RT2[(Y3 >> 16) & 0xFF] ^   \
+		RT3[(Y2 >> 24) & 0xFF];    \
+					\
+	X2 = *RK++ ^ RT0[(Y2) & 0xFF] ^   \
+		RT1[(Y1 >>  8) & 0xFF] ^   \
+		RT2[(Y0 >> 16) & 0xFF] ^   \
+		RT3[(Y3 >> 24) & 0xFF];    \
+					\
+	X3 = *RK++ ^ RT0[(Y3) & 0xFF] ^   \
+		RT1[(Y2 >>  8) & 0xFF] ^   \
+		RT2[(Y1 >> 16) & 0xFF] ^   \
+		 RT3[(Y0 >> 24) & 0xFF];    \
+}
+
+/*
+ * AES-ECB block encryption/decryption
+ */
+int aes_crypt_ecb(struct aes_context *ctx,
+		  int mode,
+		  const unsigned char input[16], unsigned char output[16])
+{
+	int i;
+	uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+#if defined(POLARSSL_PADLOCK_C) && defined(POLARSSL_HAVE_X86)
+	if (aes_padlock_ace) {
+		if (padlock_xcryptecb(ctx, mode, input, output) == 0)
+			return 0;
+
+		/* If padlock data misaligned, we just fall back to */
+		/* unaccelerated mode */
+		/*  */
+	}
+#endif
+
+	RK = ctx->rk;
+
+	GET_UINT32_LE(X0, input, 0);
+	X0 ^= *RK++;
+	GET_UINT32_LE(X1, input, 4);
+	X1 ^= *RK++;
+	GET_UINT32_LE(X2, input, 8);
+	X2 ^= *RK++;
+	GET_UINT32_LE(X3, input, 12);
+	X3 ^= *RK++;
+
+	if (mode == AES_DECRYPT) {
+		for (i = (ctx->nr >> 1) - 1; i > 0; i--) {
+			AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+			AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);
+		}
+
+		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+
+		X0 = *RK++ ^
+		    ((uint32_t) RSb[(Y0) & 0xFF]) ^
+		    ((uint32_t) RSb[(Y3 >> 8) & 0xFF] << 8) ^
+		    ((uint32_t) RSb[(Y2 >> 16) & 0xFF] << 16) ^
+		    ((uint32_t) RSb[(Y1 >> 24) & 0xFF] << 24);
+
+		X1 = *RK++ ^
+		    ((uint32_t) RSb[(Y1) & 0xFF]) ^
+		    ((uint32_t) RSb[(Y0 >> 8) & 0xFF] << 8) ^
+		    ((uint32_t) RSb[(Y3 >> 16) & 0xFF] << 16) ^
+		    ((uint32_t) RSb[(Y2 >> 24) & 0xFF] << 24);
+
+		X2 = *RK++ ^
+		    ((uint32_t) RSb[(Y2) & 0xFF]) ^
+		    ((uint32_t) RSb[(Y1 >> 8) & 0xFF] << 8) ^
+		    ((uint32_t) RSb[(Y0 >> 16) & 0xFF] << 16) ^
+		    ((uint32_t) RSb[(Y3 >> 24) & 0xFF] << 24);
+
+		X3 = *RK++ ^
+		    ((uint32_t) RSb[(Y3) & 0xFF]) ^
+		    ((uint32_t) RSb[(Y2 >> 8) & 0xFF] << 8) ^
+		    ((uint32_t) RSb[(Y1 >> 16) & 0xFF] << 16) ^
+		    ((uint32_t) RSb[(Y0 >> 24) & 0xFF] << 24);
+	} else {		/* AES_ENCRYPT */
+
+		for (i = (ctx->nr >> 1) - 1; i > 0; i--) {
+			AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+			AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);
+		}
+
+		AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+
+		X0 = *RK++ ^
+		    ((uint32_t) FSb[(Y0) & 0xFF]) ^
+		    ((uint32_t) FSb[(Y1 >> 8) & 0xFF] << 8) ^
+		    ((uint32_t) FSb[(Y2 >> 16) & 0xFF] << 16) ^
+		    ((uint32_t) FSb[(Y3 >> 24) & 0xFF] << 24);
+
+		X1 = *RK++ ^
+		    ((uint32_t) FSb[(Y1) & 0xFF]) ^
+		    ((uint32_t) FSb[(Y2 >> 8) & 0xFF] << 8) ^
+		    ((uint32_t) FSb[(Y3 >> 16) & 0xFF] << 16) ^
+		    ((uint32_t) FSb[(Y0 >> 24) & 0xFF] << 24);
+
+		X2 = *RK++ ^
+		    ((uint32_t) FSb[(Y2) & 0xFF]) ^
+		    ((uint32_t) FSb[(Y3 >> 8) & 0xFF] << 8) ^
+		    ((uint32_t) FSb[(Y0 >> 16) & 0xFF] << 16) ^
+		    ((uint32_t) FSb[(Y1 >> 24) & 0xFF] << 24);
+
+		X3 = *RK++ ^
+		    ((uint32_t) FSb[(Y3) & 0xFF]) ^
+		    ((uint32_t) FSb[(Y0 >> 8) & 0xFF] << 8) ^
+		    ((uint32_t) FSb[(Y1 >> 16) & 0xFF] << 16) ^
+		    ((uint32_t) FSb[(Y2 >> 24) & 0xFF] << 24);
+	}
+
+	PUT_UINT32_LE(X0, output, 0);
+	PUT_UINT32_LE(X1, output, 4);
+	PUT_UINT32_LE(X2, output, 8);
+	PUT_UINT32_LE(X3, output, 12);
+
+	return 0;
+}
+
+/*
+ * AES-CBC buffer encryption/decryption
+ */
+int aes_crypt_cbc(struct aes_context *ctx,
+		  int mode,
+		  size_t length,
+		  unsigned char iv[16],
+		  const unsigned char *input, unsigned char *output)
+{
+	int i;
+	unsigned char temp[16];
+
+	if (length % 16)
+		return POLARSSL_ERR_AES_INVALID_INPUT_LENGTH;
+
+#if defined(POLARSSL_PADLOCK_C) && defined(POLARSSL_HAVE_X86)
+	if (aes_padlock_ace) {
+		if (padlock_xcryptcbc(ctx, mode, length, iv, input, output) ==
+		    0)
+			return 0;
+
+		/* If padlock data misaligned, we just fall back to */
+		/* unaccelerated mode */
+		/*  */
+	}
+#endif
+
+	if (mode == AES_DECRYPT) {
+		while (length > 0) {
+			memcpy(temp, input, 16);
+			aes_crypt_ecb(ctx, mode, input, output);
+
+			for (i = 0; i < 16; i++)
+				output[i] = (unsigned char)(output[i] ^ iv[i]);
+
+			memcpy(iv, temp, 16);
+
+			input += 16;
+			output += 16;
+			length -= 16;
+		}
+	} else {
+		while (length > 0) {
+			for (i = 0; i < 16; i++)
+				output[i] = (unsigned char)(input[i] ^ iv[i]);
+
+			aes_crypt_ecb(ctx, mode, output, output);
+			memcpy(iv, output, 16);
+
+			input += 16;
+			output += 16;
+			length -= 16;
+		}
+	}
+
+	return 0;
+}
+
+#if defined(POLARSSL_CIPHER_MODE_CFB)
+/*
+ * AES-CFB128 buffer encryption/decryption
+ */
+int aes_crypt_cfb128(struct aes_context *ctx,
+		     int mode,
+		     size_t length,
+		     size_t *iv_off,
+		     unsigned char iv[16],
+		     const unsigned char *input, unsigned char *output)
+{
+	int c;
+	size_t n = *iv_off;
+
+	if (mode == AES_DECRYPT) {
+		while (length--) {
+			if (n == 0)
+				aes_crypt_ecb(ctx, AES_ENCRYPT, iv, iv);
+
+			c = *input++;
+			*output++ = (unsigned char)(c ^ iv[n]);
+			iv[n] = (unsigned char)c;
+
+			n = (n + 1) & 0x0F;
+		}
+	} else {
+		while (length--) {
+			if (n == 0)
+				aes_crypt_ecb(ctx, AES_ENCRYPT, iv, iv);
+
+			iv[n] = *output++ = (unsigned char)(iv[n] ^ *input++);
+
+			n = (n + 1) & 0x0F;
+		}
+	}
+
+	*iv_off = n;
+
+	return 0;
+}
+#endif				/*POLARSSL_CIPHER_MODE_CFB */
+
+#if defined(POLARSSL_CIPHER_MODE_CTR)
+/*
+ * AES-CTR buffer encryption/decryption
+ */
+int aes_crypt_ctr(struct aes_context *ctx,
+		  size_t length,
+		  size_t *nc_off,
+		  unsigned char nonce_counter[16],
+		  unsigned char stream_block[16],
+		  const unsigned char *input, unsigned char *output)
+{
+	int c, i;
+	size_t n = *nc_off;
+
+	while (length--) {
+		if (n == 0) {
+			aes_crypt_ecb(ctx, AES_ENCRYPT, nonce_counter,
+				      stream_block);
+
+			for (i = 16; i > 0; i--)
+				if (++nonce_counter[i - 1] != 0)
+					break;
+		}
+		c = *input++;
+		*output++ = (unsigned char)(c ^ stream_block[n]);
+
+		n = (n + 1) & 0x0F;
+	}
+
+	*nc_off = n;
+
+	return 0;
+}
+#endif				/* POLARSSL_CIPHER_MODE_CTR */
+
+#if defined(POLARSSL_SELF_TEST)
+
+#include <stdio.h>
+
+/*
+ * AES test vectors from:
+ *
+ * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip
+ */
+static const unsigned char aes_test_ecb_dec[3][16] = {
+	{0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,
+	 0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0},
+	{0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,
+	 0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4},
+	{0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,
+	 0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE}
+};
+
+static const unsigned char aes_test_ecb_enc[3][16] = {
+	{0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,
+	 0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F},
+	{0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,
+	 0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14},
+	{0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,
+	 0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4}
+};
+
+static const unsigned char aes_test_cbc_dec[3][16] = {
+	{0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,
+	 0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86},
+	{0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,
+	 0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B},
+	{0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,
+	 0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13}
+};
+
+static const unsigned char aes_test_cbc_enc[3][16] = {
+	{0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,
+	 0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D},
+	{0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,
+	 0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04},
+	{0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,
+	 0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0}
+};
+
+#if defined(POLARSSL_CIPHER_MODE_CFB)
+/*
+ * AES-CFB128 test vectors from:
+ *
+ * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
+ */
+static const unsigned char aes_test_cfb128_key[3][32] = {
+	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
+	 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
+	{0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,
+	 0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,
+	 0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B},
+	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,
+	 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,
+	 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,
+	 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4}
+};
+
+static const unsigned char aes_test_cfb128_iv[16] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
+};
+
+static const unsigned char aes_test_cfb128_pt[64] = {
+	0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
+	0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
+	0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
+	0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
+	0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
+	0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
+	0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
+	0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
+};
+
+static const unsigned char aes_test_cfb128_ct[3][64] = {
+	{0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,
+	 0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,
+	 0xC8, 0xA6, 0x45, 0x37, 0xA0, 0xB3, 0xA9, 0x3F,
+	 0xCD, 0xE3, 0xCD, 0xAD, 0x9F, 0x1C, 0xE5, 0x8B,
+	 0x26, 0x75, 0x1F, 0x67, 0xA3, 0xCB, 0xB1, 0x40,
+	 0xB1, 0x80, 0x8C, 0xF1, 0x87, 0xA4, 0xF4, 0xDF,
+	 0xC0, 0x4B, 0x05, 0x35, 0x7C, 0x5D, 0x1C, 0x0E,
+	 0xEA, 0xC4, 0xC6, 0x6F, 0x9F, 0xF7, 0xF2, 0xE6},
+	{0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,
+	 0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,
+	 0x67, 0xCE, 0x7F, 0x7F, 0x81, 0x17, 0x36, 0x21,
+	 0x96, 0x1A, 0x2B, 0x70, 0x17, 0x1D, 0x3D, 0x7A,
+	 0x2E, 0x1E, 0x8A, 0x1D, 0xD5, 0x9B, 0x88, 0xB1,
+	 0xC8, 0xE6, 0x0F, 0xED, 0x1E, 0xFA, 0xC4, 0xC9,
+	 0xC0, 0x5F, 0x9F, 0x9C, 0xA9, 0x83, 0x4F, 0xA0,
+	 0x42, 0xAE, 0x8F, 0xBA, 0x58, 0x4B, 0x09, 0xFF},
+	{0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,
+	 0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,
+	 0x39, 0xFF, 0xED, 0x14, 0x3B, 0x28, 0xB1, 0xC8,
+	 0x32, 0x11, 0x3C, 0x63, 0x31, 0xE5, 0x40, 0x7B,
+	 0xDF, 0x10, 0x13, 0x24, 0x15, 0xE5, 0x4B, 0x92,
+	 0xA1, 0x3E, 0xD0, 0xA8, 0x26, 0x7A, 0xE2, 0xF9,
+	 0x75, 0xA3, 0x85, 0x74, 0x1A, 0xB9, 0xCE, 0xF8,
+	 0x20, 0x31, 0x62, 0x3D, 0x55, 0xB1, 0xE4, 0x71}
+};
+#endif				/* POLARSSL_CIPHER_MODE_CFB */
+
+#if defined(POLARSSL_CIPHER_MODE_CTR)
+/*
+ * AES-CTR test vectors from:
+ *
+ * http://www.faqs.org/rfcs/rfc3686.html
+ */
+
+static const unsigned char aes_test_ctr_key[3][16] = {
+	{0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
+	 0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E},
+	{0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,
+	 0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63},
+	{0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,
+	 0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC}
+};
+
+static const unsigned char aes_test_ctr_nonce_counter[3][16] = {
+	{0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
+	{0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59,
+	 0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01},
+	{0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F,
+	 0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01}
+};
+
+static const unsigned char aes_test_ctr_pt[3][48] = {
+	{0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,
+	 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67},
+
+	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F},
+
+	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
+	 0x20, 0x21, 0x22, 0x23}
+};
+
+static const unsigned char aes_test_ctr_ct[3][48] = {
+	{0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,
+	 0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8},
+	{0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9,
+	 0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88,
+	 0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8,
+	 0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28},
+	{0xC1, 0xCF, 0x48, 0xA8, 0x9F, 0x2F, 0xFD, 0xD9,
+	 0xCF, 0x46, 0x52, 0xE9, 0xEF, 0xDB, 0x72, 0xD7,
+	 0x45, 0x40, 0xA4, 0x2B, 0xDE, 0x6D, 0x78, 0x36,
+	 0xD5, 0x9A, 0x5C, 0xEA, 0xAE, 0xF3, 0x10, 0x53,
+	 0x25, 0xB2, 0x07, 0x2F}
+};
+
+static const int aes_test_ctr_len[3] = { 16, 32, 36 };
+#endif				/* POLARSSL_CIPHER_MODE_CTR */
+
+/*
+ * Checkup routine
+ */
+int aes_self_test(int verbose)
+{
+	int i, j, u, v;
+	unsigned char key[32];
+	unsigned char buf[64];
+	unsigned char prv[16];
+	unsigned char iv[16];
+#if defined(POLARSSL_CIPHER_MODE_CTR) || defined(POLARSSL_CIPHER_MODE_CFB)
+	size_t offset;
+#endif
+#if defined(POLARSSL_CIPHER_MODE_CTR)
+	int len;
+	unsigned char nonce_counter[16];
+	unsigned char stream_block[16];
+#endif
+	struct aes_context ctx;
+
+	memset(key, 0, 32);
+
+	/*
+	 * ECB mode
+	 */
+	for (i = 0; i < 6; i++) {
+		u = i >> 1;
+		v = i & 1;
+
+		if (verbose != 0)
+			printf("  AES-ECB-%3d (%s): ", 128 + u * 64,
+			       (v == AES_DECRYPT) ? "dec" : "enc");
+
+		memset(buf, 0, 16);
+
+		if (v == AES_DECRYPT) {
+			aes_setkey_dec(&ctx, key, 128 + u * 64);
+
+			for (j = 0; j < 10000; j++)
+				aes_crypt_ecb(&ctx, v, buf, buf);
+
+			if (memcmp(buf, aes_test_ecb_dec[u], 16) != 0) {
+				if (verbose != 0)
+					printf("failed\n");
+
+				return 1;
+			}
+		} else {
+			aes_setkey_enc(&ctx, key, 128 + u * 64);
+
+			for (j = 0; j < 10000; j++)
+				aes_crypt_ecb(&ctx, v, buf, buf);
+
+			if (memcmp(buf, aes_test_ecb_enc[u], 16) != 0) {
+				if (verbose != 0)
+					printf("failed\n");
+
+				return 1;
+			}
+		}
+
+		if (verbose != 0)
+			printf("passed\n");
+	}
+
+	if (verbose != 0)
+		printf("\n");
+
+	/*
+	 * CBC mode
+	 */
+	for (i = 0; i < 6; i++) {
+		u = i >> 1;
+		v = i & 1;
+
+		if (verbose != 0)
+			printf("  AES-CBC-%3d (%s): ", 128 + u * 64,
+			       (v == AES_DECRYPT) ? "dec" : "enc");
+
+		memset(iv, 0, 16);
+		memset(prv, 0, 16);
+		memset(buf, 0, 16);
+
+		if (v == AES_DECRYPT) {
+			aes_setkey_dec(&ctx, key, 128 + u * 64);
+
+			for (j = 0; j < 10000; j++)
+				aes_crypt_cbc(&ctx, v, 16, iv, buf, buf);
+
+			if (memcmp(buf, aes_test_cbc_dec[u], 16) != 0) {
+				if (verbose != 0)
+					printf("failed\n");
+
+				return 1;
+			}
+		} else {
+			aes_setkey_enc(&ctx, key, 128 + u * 64);
+
+			for (j = 0; j < 10000; j++) {
+				unsigned char tmp[16];
+
+				aes_crypt_cbc(&ctx, v, 16, iv, buf, buf);
+
+				memcpy(tmp, prv, 16);
+				memcpy(prv, buf, 16);
+				memcpy(buf, tmp, 16);
+			}
+
+			if (memcmp(prv, aes_test_cbc_enc[u], 16) != 0) {
+				if (verbose != 0)
+					printf("failed\n");
+
+				return 1;
+			}
+		}
+
+		if (verbose != 0)
+			printf("passed\n");
+	}
+
+	if (verbose != 0)
+		printf("\n");
+
+#if defined(POLARSSL_CIPHER_MODE_CFB)
+	/*
+	 * CFB128 mode
+	 */
+	for (i = 0; i < 6; i++) {
+		u = i >> 1;
+		v = i & 1;
+
+		if (verbose != 0)
+			printf("  AES-CFB128-%3d (%s): ", 128 + u * 64,
+			       (v == AES_DECRYPT) ? "dec" : "enc");
+
+		memcpy(iv, aes_test_cfb128_iv, 16);
+		memcpy(key, aes_test_cfb128_key[u], 16 + u * 8);
+
+		offset = 0;
+		aes_setkey_enc(&ctx, key, 128 + u * 64);
+
+		if (v == AES_DECRYPT) {
+			memcpy(buf, aes_test_cfb128_ct[u], 64);
+			aes_crypt_cfb128(&ctx, v, 64, &offset, iv, buf, buf);
+
+			if (memcmp(buf, aes_test_cfb128_pt, 64) != 0) {
+				if (verbose != 0)
+					printf("failed\n");
+
+				return 1;
+			}
+		} else {
+			memcpy(buf, aes_test_cfb128_pt, 64);
+			aes_crypt_cfb128(&ctx, v, 64, &offset, iv, buf, buf);
+
+			if (memcmp(buf, aes_test_cfb128_ct[u], 64) != 0) {
+				if (verbose != 0)
+					printf("failed\n");
+
+				return 1;
+			}
+		}
+
+		if (verbose != 0)
+			printf("passed\n");
+	}
+
+	if (verbose != 0)
+		printf("\n");
+#endif				/* POLARSSL_CIPHER_MODE_CFB */
+
+#if defined(POLARSSL_CIPHER_MODE_CTR)
+	/*
+	 * CTR mode
+	 */
+	for (i = 0; i < 6; i++) {
+		u = i >> 1;
+		v = i & 1;
+
+		if (verbose != 0)
+			printf("  AES-CTR-128 (%s): ",
+			       (v == AES_DECRYPT) ? "dec" : "enc");
+
+		memcpy(nonce_counter, aes_test_ctr_nonce_counter[u], 16);
+		memcpy(key, aes_test_ctr_key[u], 16);
+
+		offset = 0;
+		aes_setkey_enc(&ctx, key, 128);
+
+		if (v == AES_DECRYPT) {
+			len = aes_test_ctr_len[u];
+			memcpy(buf, aes_test_ctr_ct[u], len);
+
+			aes_crypt_ctr(&ctx, len, &offset, nonce_counter,
+				      stream_block, buf, buf);
+
+			if (memcmp(buf, aes_test_ctr_pt[u], len) != 0) {
+				if (verbose != 0)
+					printf("failed\n");
+
+				return 1;
+			}
+		} else {
+			len = aes_test_ctr_len[u];
+			memcpy(buf, aes_test_ctr_pt[u], len);
+
+			aes_crypt_ctr(&ctx, len, &offset, nonce_counter,
+				      stream_block, buf, buf);
+
+			if (memcmp(buf, aes_test_ctr_ct[u], len) != 0) {
+				if (verbose != 0)
+					printf("failed\n");
+
+				return 1;
+			}
+		}
+
+		if (verbose != 0)
+			printf("passed\n");
+	}
+
+	if (verbose != 0)
+		printf("\n");
+#endif				/* POLARSSL_CIPHER_MODE_CTR */
+
+	return 0;
+}
+
+#endif
+
+#endif
diff --git a/amlogic/frameworks/services/systemcontrol/HDCPKey/aes.h b/amlogic/frameworks/services/systemcontrol/HDCPKey/aes.h
new file mode 100644
index 0000000..c03053d
--- /dev/null
+++ b/amlogic/frameworks/services/systemcontrol/HDCPKey/aes.h
@@ -0,0 +1,185 @@
+/**
+ * \file aes.h
+ *
+ * \brief AES block cipher
+ *
+ *  Copyright (C) 2006-2010, Brainspark B.V.
+ *
+ *  This file is part of PolarSSL (http://www.polarssl.org)
+ *  Lead Maintainer: Paul Bakker <polarssl_maintainer at polarssl.org>
+ *
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+#ifndef POLARSSL_AES_H
+#define POLARSSL_AES_H
+
+#include <string.h>
+#include <stddef.h>
+#include <stdint.h>
+/*#include <inttypes.h>*/
+
+#ifdef _MSC_VER
+#include <basetsd.h>
+/*typedef UINT32 uint32_t;*/
+#else
+/*#include <inttypes.h>*/
+#endif
+
+#define AES_ENCRYPT     1
+#define AES_DECRYPT     0
+
+#define POLARSSL_ERR_AES_INVALID_KEY_LENGTH \
+				  -0x0020  /**< Invalid key length. */
+#define POLARSSL_ERR_AES_INVALID_INPUT_LENGTH  \
+				-0x0022  /**< Invalid data input length. */
+
+/**
+ * \brief          AES context structure
+ */
+struct aes_context {
+	int nr;    /*!<  number of rounds  */
+	uint32_t *rk;   /*!<  AES round keys    */
+	uint32_t buf[68];  /*!<  unaligned data    */
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief          AES key schedule (encryption)
+ *
+ * \param ctx      AES context to be initialized
+ * \param key      encryption key
+ * \param keysize  must be 128, 192 or 256
+ *
+ * \return         0 if successful, or POLARSSL_ERR_AES_INVALID_KEY_LENGTH
+ */
+int aes_setkey_enc(struct aes_context *ctx,
+		const unsigned char *key, unsigned int keysize);
+
+/**
+ * \brief          AES key schedule (decryption)
+ *
+ * \param ctx      AES context to be initialized
+ * \param key      decryption key
+ * \param keysize  must be 128, 192 or 256
+ *
+ * \return         0 if successful, or POLARSSL_ERR_AES_INVALID_KEY_LENGTH
+ */
+int aes_setkey_dec(struct aes_context *ctx,
+		const unsigned char *key, unsigned int keysize);
+
+/**
+ * \brief          AES-ECB block encryption/decryption
+ *
+ * \param ctx      AES context
+ * \param mode     AES_ENCRYPT or AES_DECRYPT
+ * \param input    16-byte input block
+ * \param output   16-byte output block
+ *
+ * \return         0 if successful
+ */
+int aes_crypt_ecb(struct aes_context *ctx,
+		    int mode,
+		    const unsigned char input[16],
+		    unsigned char output[16]);
+
+/**
+ * \brief          AES-CBC buffer encryption/decryption
+ *                 Length should be a multiple of the block
+ *                 size (16 bytes)
+ *
+ * \param ctx      AES context
+ * \param mode     AES_ENCRYPT or AES_DECRYPT
+ * \param length   length of the input data
+ * \param iv       initialization vector (updated after use)
+ * \param input    buffer holding the input data
+ * \param output   buffer holding the output data
+ *
+ * \return         0 if successful, or POLARSSL_ERR_AES_INVALID_INPUT_LENGTH
+ */
+int aes_crypt_cbc(struct aes_context *ctx,
+		    int mode,
+		    size_t length,
+		    unsigned char iv[16],
+		    const unsigned char *input,
+		    unsigned char *output);
+
+/**
+ * \brief          AES-CFB128 buffer encryption/decryption.
+ *
+ * Note: Due to the nature of CFB you should use the same key schedule for
+ * both encryption and decryption. So a context initialized with
+ * aes_setkey_enc() for both AES_ENCRYPT and AES_DECRYPT.
+ *
+ * both
+ * \param ctx      AES context
+ * \param mode     AES_ENCRYPT or AES_DECRYPT
+ * \param length   length of the input data
+ * \param iv_off   offset in IV (updated after use)
+ * \param iv       initialization vector (updated after use)
+ * \param input    buffer holding the input data
+ * \param output   buffer holding the output data
+ *
+ * \return         0 if successful
+ */
+int aes_crypt_cfb128(struct aes_context *ctx,
+		       int mode,
+		       size_t length,
+		       size_t *iv_off,
+		       unsigned char iv[16],
+		       const unsigned char *input,
+		       unsigned char *output);
+
+/**
+ * \brief               AES-CTR buffer encryption/decryption
+ *
+ * Warning: You have to keep the maximum use of your counter in mind!
+ *
+ * Note: Due to the nature of CTR you should use the same key schedule for
+ * both encryption and decryption. So a context initialized with
+ * aes_setkey_enc() for both AES_ENCRYPT and AES_DECRYPT.
+ *
+ * \param length        The length of the data
+ * \param nc_off        The offset in the current stream_block (for resuming
+ *                      within current cipher stream). The offset pointer to
+ *                      should be 0 at the start of a stream.
+ * \param nonce_counter The 128-bit nonce and counter.
+ * \param stream_block  The saved stream-block for resuming. Is overwritten
+ *                      by the function.
+ * \param input         The input data stream
+ * \param output        The output data stream
+ *
+ * \return         0 if successful
+ */
+int aes_crypt_ctr(struct aes_context *ctx,
+		       size_t length,
+		       size_t *nc_off,
+		       unsigned char nonce_counter[16],
+		       unsigned char stream_block[16],
+		       const unsigned char *input,
+		       unsigned char *output);
+/**
+ * \brief          Checkup routine
+ *
+ * \return         0 if successful, or 1 if the test failed
+ */
+int aes_self_test(int verbose);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* aes.h */
diff --git a/amlogic/frameworks/services/systemcontrol/SystemControl.cpp b/amlogic/frameworks/services/systemcontrol/SystemControl.cpp
index 58f508a..f126c3a 100644
--- a/amlogic/frameworks/services/systemcontrol/SystemControl.cpp
+++ b/amlogic/frameworks/services/systemcontrol/SystemControl.cpp
@@ -60,6 +60,15 @@ SystemControl::SystemControl(const char *path)
     pDisplayMode->init();
 
     pDimension = new Dimension(pDisplayMode, pSysWrite);
+
+    //if ro.firstboot is true, we should clear first boot flag
+    const char* firstBoot = bootenv_get("ubootenv.var.firstboot");
+    if (firstBoot && (strcmp(firstBoot, "1") == 0)) {
+        ALOGI("ubootenv.var.firstboot first_boot:%s, clear it to 0", firstBoot);
+        if ( bootenv_update("ubootenv.var.firstboot", "0") < 0 ) {
+            ALOGE("set firstboot to 0 fail");
+        }
+    }
 }
 
 SystemControl::~SystemControl() {
diff --git a/amlogic/prebuilt/Android.mk b/amlogic/prebuilt/Android.mk
index 229504b..72f7380 100644
--- a/amlogic/prebuilt/Android.mk
+++ b/amlogic/prebuilt/Android.mk
@@ -34,7 +34,9 @@ endef
 
 prebuilt_apps := \
     FactoryTest \
-    RC_Service
+    RC_Service \
+    ReadLog
+
 
 $(foreach app,$(prebuilt_apps), \
     $(eval $(call PREBUILT_APP_template, $(app),)))
diff --git a/amlogic/prebuilt/ReadLog.apk b/amlogic/prebuilt/ReadLog.apk
new file mode 100644
index 0000000..e69de29
diff --git a/amlogic/system/libhealthd/Android.mk b/amlogic/system/libhealthd/Android.mk
index eb14d93..18454ab 100644
--- a/amlogic/system/libhealthd/Android.mk
+++ b/amlogic/system/libhealthd/Android.mk
@@ -7,14 +7,16 @@ LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 LOCAL_SRC_FILES := healthd_board_mbox_default.cpp
 LOCAL_MODULE := libhealthd.mboxdefault
-LOCAL_C_INCLUDES := system/core/healthd
+LOCAL_C_INCLUDES := system/core/healthd \
+                    system/core/healthd/include/healthd
 LOCAL_CFLAGS := -Werror
 include $(BUILD_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
 LOCAL_SRC_FILES := healthd_board_tablet_default.cpp
 LOCAL_MODULE := libhealthd.tablet
-LOCAL_C_INCLUDES := system/core/healthd
+LOCAL_C_INCLUDES := system/core/healthd \
+                    system/core/healthd/include/healthd
 LOCAL_CFLAGS := -Werror
 include $(BUILD_STATIC_LIBRARY)
 
diff --git a/amlogic/tools/logo_img_packer/res_pack.cpp b/amlogic/tools/logo_img_packer/res_pack.cpp
index 282bc4b..3c6ee9e 100755
--- a/amlogic/tools/logo_img_packer/res_pack.cpp
+++ b/amlogic/tools/logo_img_packer/res_pack.cpp
@@ -488,7 +488,7 @@ static int _img_pack(const char** const path_src, const char* const packedImg,
 
                 if(totalFileNum)//File list mode
                 {
-                        if((*getFile)(path_src, (__hdle*)itemIndex, filePath)) {
+                        if ((*getFile)(path_src, (__hdle*)(int64_t)itemIndex, filePath)) {
                                 break;
                         }
                 }
