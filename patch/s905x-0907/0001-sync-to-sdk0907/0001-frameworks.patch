diff --git a/av/camera/ICameraRecordingProxy.cpp b/av/camera/ICameraRecordingProxy.cpp
index 3dc0ffb..517b64f 100644
--- a/av/camera/ICameraRecordingProxy.cpp
+++ b/av/camera/ICameraRecordingProxy.cpp
@@ -31,6 +31,11 @@ enum {
     RELEASE_RECORDING_FRAME,
 };
 
+uint8_t ICameraRecordingProxy::baseObject = 0;
+
+size_t ICameraRecordingProxy::getCommonBaseAddress() {
+    return (size_t)&baseObject;
+}
 
 class BpCameraRecordingProxy: public BpInterface<ICameraRecordingProxy>
 {
@@ -106,4 +111,3 @@ status_t BnCameraRecordingProxy::onTransact(
 // ----------------------------------------------------------------------------
 
 }; // namespace android
-
diff --git a/av/include/camera/ICameraRecordingProxy.h b/av/include/camera/ICameraRecordingProxy.h
index 2aac284..4edf9cd 100644
--- a/av/include/camera/ICameraRecordingProxy.h
+++ b/av/include/camera/ICameraRecordingProxy.h
@@ -83,6 +83,12 @@ public:
     virtual status_t        startRecording(const sp<ICameraRecordingProxyListener>& listener) = 0;
     virtual void            stopRecording() = 0;
     virtual void            releaseRecordingFrame(const sp<IMemory>& mem) = 0;
+
+    // b/28466701
+    static  size_t          getCommonBaseAddress();
+  private:
+
+    static  uint8_t         baseObject;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/av/include/media/IMediaDeathNotifier.h b/av/include/media/IMediaDeathNotifier.h
index bb3d0d8..aca6678 100644
--- a/av/include/media/IMediaDeathNotifier.h
+++ b/av/include/media/IMediaDeathNotifier.h
@@ -30,7 +30,7 @@ public:
     virtual ~IMediaDeathNotifier() { removeObitRecipient(this); }
 
     virtual void died() = 0;
-    static const sp<IMediaPlayerService>& getMediaPlayerService();
+    static const sp<IMediaPlayerService> getMediaPlayerService();
 
 private:
     IMediaDeathNotifier &operator=(const IMediaDeathNotifier &);
diff --git a/av/include/media/mediaplayer.h b/av/include/media/mediaplayer.h
index 71ab772..d7dd0f5 100644
--- a/av/include/media/mediaplayer.h
+++ b/av/include/media/mediaplayer.h
@@ -54,6 +54,7 @@ enum media_event_type {
     MEDIA_INFO              = 200,
     MEDIA_SUBTITLE_DATA     = 201,
     MEDIA_META_DATA         = 202,
+    MEDIA_BLURAY_INFO       = 203,
 };
 
 // Generic error codes for the media player framework.  Errors are fatal, the
@@ -147,6 +148,7 @@ enum media_info_type {
     MEDIA_INFO_AMLOGIC_SHOW_AUDIO_LIMITED = MEDIA_INFO_AMLOGIC_BASE+8,
     MEDIA_INFO_AMLOGIC_SHOW_DTS_MULASSETHINT=MEDIA_INFO_AMLOGIC_BASE+9,
     MEDIA_INFO_AMLOGIC_SHOW_DTS_HPS_NOTSUPPORT=MEDIA_INFO_AMLOGIC_BASE+10,
+    MEDIA_INFO_AMLOGIC_BLURAY_STREAM_PATH = MEDIA_INFO_AMLOGIC_BASE+11,
 
     //notify java app the download bitrate
     MEDIA_INFO_DOWNLOAD_BITRATE = 0x9001,
diff --git a/av/include/media/stagefright/CameraSource.h b/av/include/media/stagefright/CameraSource.h
index 069e897..6c938a5 100644
--- a/av/include/media/stagefright/CameraSource.h
+++ b/av/include/media/stagefright/CameraSource.h
@@ -236,6 +236,9 @@ private:
     status_t checkFrameRate(const CameraParameters& params,
                     int32_t frameRate);
 
+    static void adjustIncomingANWBuffer(IMemory* data);
+    static void adjustOutgoingANWBuffer(IMemory* data);
+
     void stopCameraRecording();
     status_t reset();
 
diff --git a/av/media/libmedia/Android.mk b/av/media/libmedia/Android.mk
index 22d0f8a..72ef5e8 100644
--- a/av/media/libmedia/Android.mk
+++ b/av/media/libmedia/Android.mk
@@ -44,6 +44,7 @@ LOCAL_SRC_FILES:= \
     IResourceManagerService.cpp \
     IStreamSource.cpp \
     MediaCodecInfo.cpp \
+    MediaUtils.cpp \
     Metadata.cpp \
     mediarecorder.cpp \
     IMediaMetadataRetriever.cpp \
diff --git a/av/media/libmedia/AudioTrack.cpp b/av/media/libmedia/AudioTrack.cpp
index 9b77c99..0bba791 100644
--- a/av/media/libmedia/AudioTrack.cpp
+++ b/av/media/libmedia/AudioTrack.cpp
@@ -1037,7 +1037,7 @@ status_t AudioTrack::getPosition(uint32_t *position)
     }
 
     AutoMutex lock(mLock);
-    if (isOffloaded_l()) {
+    if (isOffloaded_l() || isDirect_l()) {
         uint32_t dspFrames = 0;
 
         if (isOffloaded_l() && ((mState == STATE_PAUSED) || (mState == STATE_PAUSED_STOPPING))) {
diff --git a/av/media/libmedia/IMediaDeathNotifier.cpp b/av/media/libmedia/IMediaDeathNotifier.cpp
index d4360ea..c43ef66 100644
--- a/av/media/libmedia/IMediaDeathNotifier.cpp
+++ b/av/media/libmedia/IMediaDeathNotifier.cpp
@@ -31,7 +31,7 @@ sp<IMediaDeathNotifier::DeathNotifier> IMediaDeathNotifier::sDeathNotifier;
 SortedVector< wp<IMediaDeathNotifier> > IMediaDeathNotifier::sObitRecipients;
 
 // establish binder interface to MediaPlayerService
-/*static*/const sp<IMediaPlayerService>&
+/*static*/const sp<IMediaPlayerService>
 IMediaDeathNotifier::getMediaPlayerService()
 {
     ALOGV("getMediaPlayerService");
diff --git a/av/media/libmedia/IOMX.cpp b/av/media/libmedia/IOMX.cpp
index 1bbf816..64661d8 100644
--- a/av/media/libmedia/IOMX.cpp
+++ b/av/media/libmedia/IOMX.cpp
@@ -700,8 +700,10 @@ status_t BnOMX::onTransact(
             size_t pageSize = 0;
             size_t allocSize = 0;
             bool isUsageBits = (index == (OMX_INDEXTYPE) OMX_IndexParamConsumerUsageBits);
+            bool isVendorBits = ((index > OMX_IndexVendorStartUnused) && (index < OMX_IndexMax));
+
             if ((isUsageBits && size < 4) ||
-                    (!isUsageBits && code != SET_INTERNAL_OPTION && size < 8)) {
+                    (!isUsageBits && code != SET_INTERNAL_OPTION && size < 8 && !isVendorBits)) {
                 // we expect the structure to contain at least the size and
                 // version, 8 bytes total
                 ALOGE("b/27207275 (%zu) (%d/%d)", size, int(index), int(code));
@@ -725,6 +727,7 @@ status_t BnOMX::onTransact(
                         OMX_U32 declaredSize = *(OMX_U32*)params;
                         if (code != SET_INTERNAL_OPTION &&
                                 index != (OMX_INDEXTYPE) OMX_IndexParamConsumerUsageBits &&
+                                !isVendorBits &&
                                 declaredSize > size) {
                             // the buffer says it's bigger than it actually is
                             ALOGE("b/27207275 (%u/%zu)", declaredSize, size);
diff --git a/av/media/libmedia/MediaUtils.cpp b/av/media/libmedia/MediaUtils.cpp
new file mode 100644
index 0000000..a02ca65
--- /dev/null
+++ b/av/media/libmedia/MediaUtils.cpp
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "MediaUtils"
+#define LOG_NDEBUG 0
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+#include <sys/resource.h>
+#include <unistd.h>
+
+#include "MediaUtils.h"
+
+namespace android {
+
+void limitProcessMemory(
+    const char *property,
+    size_t numberOfBytes,
+    size_t percentageOfTotalMem) {
+
+    long pageSize = sysconf(_SC_PAGESIZE);
+    long numPages = sysconf(_SC_PHYS_PAGES);
+    size_t maxMem = SIZE_MAX;
+
+    if (pageSize > 0 && numPages > 0) {
+        if (size_t(numPages) < SIZE_MAX / size_t(pageSize)) {
+            maxMem = size_t(numPages) * size_t(pageSize);
+        }
+        ALOGV("physMem: %zu", maxMem);
+        if (percentageOfTotalMem > 100) {
+            ALOGW("requested %zu%% of total memory, using 100%%", percentageOfTotalMem);
+            percentageOfTotalMem = 100;
+        }
+        maxMem = maxMem / 100 * percentageOfTotalMem;
+        if (numberOfBytes < maxMem) {
+            maxMem = numberOfBytes;
+        }
+        ALOGV("requested limit: %zu", maxMem);
+    } else {
+        ALOGW("couldn't determine total RAM");
+    }
+
+    int64_t propVal = property_get_int64(property, maxMem);
+    if (propVal > 0 && uint64_t(propVal) <= SIZE_MAX) {
+        maxMem = propVal;
+    }
+    ALOGV("actual limit: %zu", maxMem);
+
+    struct rlimit limit;
+    getrlimit(RLIMIT_AS, &limit);
+    ALOGV("original limits: %lld/%lld", (long long)limit.rlim_cur, (long long)limit.rlim_max);
+    limit.rlim_cur = maxMem;
+    setrlimit(RLIMIT_AS, &limit);
+    limit.rlim_cur = -1;
+    limit.rlim_max = -1;
+    getrlimit(RLIMIT_AS, &limit);
+    ALOGV("new limits: %lld/%lld", (long long)limit.rlim_cur, (long long)limit.rlim_max);
+
+}
+
+} // namespace android
diff --git a/av/media/libmedia/MediaUtils.h b/av/media/libmedia/MediaUtils.h
new file mode 100644
index 0000000..f80dd30
--- /dev/null
+++ b/av/media/libmedia/MediaUtils.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _MEDIA_UTILS_H
+#define _MEDIA_UTILS_H
+
+namespace android {
+
+/**
+   Limit the amount of memory a process can allocate using setrlimit(RLIMIT_AS).
+   The value to use will be read from the specified system property, or if the
+   property doesn't exist it will use the specified number of bytes or the
+   specified percentage of total memory, whichever is smaller.
+*/
+void limitProcessMemory(
+    const char *property,
+    size_t numberOfBytes,
+    size_t percentageOfTotalMem);
+
+}   // namespace android
+
+#endif  // _MEDIA_UTILS_H
diff --git a/av/media/libmedia/mediaplayer.cpp b/av/media/libmedia/mediaplayer.cpp
index 7c520f9..530d91a 100644
--- a/av/media/libmedia/mediaplayer.cpp
+++ b/av/media/libmedia/mediaplayer.cpp
@@ -152,7 +152,7 @@ status_t MediaPlayer::setDataSource(
     ALOGV("setDataSource(%s)", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
-        const sp<IMediaPlayerService>& service(getMediaPlayerService());
+        const sp<IMediaPlayerService> service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
@@ -169,7 +169,7 @@ status_t MediaPlayer::setDataSource(int fd, int64_t offset, int64_t length)
 {
     ALOGV("setDataSource(%d, %" PRId64 ", %" PRId64 ")", fd, offset, length);
     status_t err = UNKNOWN_ERROR;
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
@@ -185,7 +185,7 @@ status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)
 {
     ALOGV("setDataSource");
     status_t err = UNKNOWN_ERROR;
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
diff --git a/av/media/libmedia/mediarecorder.cpp b/av/media/libmedia/mediarecorder.cpp
index 8bbd8f1..0eb7de5 100644
--- a/av/media/libmedia/mediarecorder.cpp
+++ b/av/media/libmedia/mediarecorder.cpp
@@ -617,7 +617,7 @@ MediaRecorder::MediaRecorder(const String16& opPackageName) : mSurfaceMediaSourc
 {
     ALOGV("constructor");
 
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != NULL) {
         mMediaRecorder = service->createMediaRecorder(opPackageName);
     }
diff --git a/av/media/libmediaplayerservice/MediaPlayerService.cpp b/av/media/libmediaplayerservice/MediaPlayerService.cpp
index 667234d..96c7a40 100644
--- a/av/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/av/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -365,6 +365,10 @@ sp<IMediaPlayer> MediaPlayerService::create(const sp<IMediaPlayerClient>& client
     ALOGV("Create new client(%d) from pid %d, uid %d, ", connId, pid,
          IPCThreadState::self()->getCallingUid());
 
+    char str_pid[8];
+    sprintf(str_pid, "%d", pid);
+    property_set("media.player.pid", str_pid);
+
     wp<Client> w = c;
     {
         Mutex::Autolock lock(mLock);
@@ -1220,6 +1224,18 @@ status_t MediaPlayerService::Client::setVolume(float leftVolume, float rightVolu
                   reinterpret_cast<MediaPlayerHWInterface*>(p.get());
           return hwp->setVolume(leftVolume, rightVolume);
       } else {
+          {
+              ALOGV("Set amlogic player Volume(%f, %f)",leftVolume, rightVolume);
+              Parcel tmprequest;
+              Parcel reply;
+              tmprequest.setDataPosition(0);
+              tmprequest.writeInt32(INVOKE_ID_SET_TRACK_VOLUME);
+              tmprequest.writeFloat(leftVolume);
+              tmprequest.writeFloat(rightVolume);
+              tmprequest.setDataPosition(0);
+              p->invoke(tmprequest,&reply);
+          }
+          ALOGV("Set android track Volume(%f, %f)",leftVolume, rightVolume);
           if (mAudioOutput != 0) mAudioOutput->setVolume(leftVolume, rightVolume);
           return NO_ERROR;
       }
diff --git a/av/media/libmediaplayerservice/MetadataRetrieverClient.cpp b/av/media/libmediaplayerservice/MetadataRetrieverClient.cpp
index 45610ba..ccf955b 100755
--- a/av/media/libmediaplayerservice/MetadataRetrieverClient.cpp
+++ b/av/media/libmediaplayerservice/MetadataRetrieverClient.cpp
@@ -242,6 +242,7 @@ sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)
     ALOGV("rotation: %d", frameCopy->mRotationAngle);
     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);
     memcpy(frameCopy->mData, frame->mData, frame->mSize);
+    frameCopy->mData = 0;
     delete frame;  // Fix memory leakage
     return mThumbnail;
 }
diff --git a/av/media/libmediaplayerservice/nuplayer/GenericSource.cpp b/av/media/libmediaplayerservice/nuplayer/GenericSource.cpp
index 45da218..e8c28d5 100755
--- a/av/media/libmediaplayerservice/nuplayer/GenericSource.cpp
+++ b/av/media/libmediaplayerservice/nuplayer/GenericSource.cpp
@@ -211,6 +211,9 @@ status_t NuPlayer::GenericSource::initFromDataSource() {
 
     for (size_t i = 0; i < numtracks; ++i) {
         sp<MediaSource> track = extractor->getTrack(i);
+        if (track == NULL) {
+            continue;
+        }
 
         sp<MetaData> meta = extractor->getTrackMetaData(i);
 
@@ -253,24 +256,27 @@ status_t NuPlayer::GenericSource::initFromDataSource() {
             }
         }
 
-        if (track != NULL) {
-            mSources.push(track);
-            int64_t durationUs;
-            if (meta->findInt64(kKeyDuration, &durationUs)) {
-                if (durationUs > mDurationUs) {
-                    mDurationUs = durationUs;
-                }
+        mSources.push(track);
+        int64_t durationUs;
+        if (meta->findInt64(kKeyDuration, &durationUs)) {
+            if (durationUs > mDurationUs) {
+                mDurationUs = durationUs;
             }
+        }
 
-            int32_t bitrate;
-            if (totalBitrate >= 0 && meta->findInt32(kKeyBitRate, &bitrate)) {
-                totalBitrate += bitrate;
-            } else {
-                totalBitrate = -1;
-            }
+        int32_t bitrate;
+        if (totalBitrate >= 0 && meta->findInt32(kKeyBitRate, &bitrate)) {
+            totalBitrate += bitrate;
+        } else {
+            totalBitrate = -1;
         }
     }
 
+    if (mSources.size() == 0) {
+        ALOGE("b/23705695");
+        return UNKNOWN_ERROR;
+    }
+
     mBitrate = totalBitrate;
 
     return OK;
@@ -318,7 +324,7 @@ int64_t NuPlayer::GenericSource::getLastReadPosition() {
 
 status_t NuPlayer::GenericSource::setBuffers(
         bool audio, Vector<MediaBuffer *> &buffers) {
-    if (mIsSecure && !audio) {
+    if (mIsSecure && !audio && mVideoTrack.mSource != NULL) {
         return mVideoTrack.mSource->setBuffers(buffers);
     }
     return INVALID_OPERATION;
diff --git a/av/media/libstagefright/Android.mk b/av/media/libstagefright/Android.mk
index 8db6ad5..896d870 100755
--- a/av/media/libstagefright/Android.mk
+++ b/av/media/libstagefright/Android.mk
@@ -145,6 +145,10 @@ LOCAL_C_INCLUDES+= \
 	$(TOP)/frameworks/av/media/libstagefright/include  \
 	$(TOP)/frameworks/av/media/libmediaplayerservice  \
 
+ifeq ($(USE_MEDIACODEC_SECURE), true)
+LOCAL_CFLAGS += -DUSE_MEDIACODEC_SECURE
+endif
+
 
 ####	$(TOP)/external/ffmpeg
 
diff --git a/av/media/libstagefright/CameraSource.cpp b/av/media/libstagefright/CameraSource.cpp
index 66280da..fa30644 100644
--- a/av/media/libstagefright/CameraSource.cpp
+++ b/av/media/libstagefright/CameraSource.cpp
@@ -27,8 +27,10 @@
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/MetaData.h>
+#include <media/hardware/HardwareAPI.h>
 #include <camera/Camera.h>
 #include <camera/CameraParameters.h>
+#include <camera/ICameraRecordingProxy.h>
 #include <gui/Surface.h>
 #include <utils/String8.h>
 #include <cutils/properties.h>
@@ -792,6 +794,8 @@ void CameraSource::releaseQueuedFrames() {
     List<sp<IMemory> >::iterator it;
     while (!mFramesReceived.empty()) {
         it = mFramesReceived.begin();
+        // b/28466701
+        adjustOutgoingANWBuffer(it->get());
         releaseRecordingFrame(*it);
         mFramesReceived.erase(it);
         ++mNumFramesDropped;
@@ -812,6 +816,9 @@ void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();
          it != mFramesBeingEncoded.end(); ++it) {
         if ((*it)->pointer() ==  buffer->data()) {
+            // b/28466701
+            adjustOutgoingANWBuffer(it->get());
+
             releaseOneRecordingFrame((*it));
             mFramesBeingEncoded.erase(it);
             ++mNumFramesEncoded;
@@ -917,6 +924,10 @@ void CameraSource::dataCallbackTimestamp(int64_t timestampUs,
     ++mNumFramesReceived;
 
     CHECK(data != NULL && data->size() > 0);
+
+    // b/28466701
+    adjustIncomingANWBuffer(data.get());
+
     mFramesReceived.push_back(data);
     int64_t timeUs = mStartTimeUs + (timestampUs - mFirstFrameTimeUs);
     mFrameTimes.push_back(timeUs);
@@ -930,6 +941,24 @@ bool CameraSource::isMetaDataStoredInVideoBuffers() const {
     return mIsMetaDataStoredInVideoBuffers;
 }
 
+void CameraSource::adjustIncomingANWBuffer(IMemory* data) {
+    VideoNativeMetadata *payload =
+            reinterpret_cast<VideoNativeMetadata*>(data->pointer());
+    if (payload->eType == kMetadataBufferTypeANWBuffer) {
+        payload->pBuffer = (ANativeWindowBuffer*)(((uint8_t*)payload->pBuffer) +
+                ICameraRecordingProxy::getCommonBaseAddress());
+    }
+}
+
+void CameraSource::adjustOutgoingANWBuffer(IMemory* data) {
+    VideoNativeMetadata *payload =
+            reinterpret_cast<VideoNativeMetadata*>(data->pointer());
+    if (payload->eType == kMetadataBufferTypeANWBuffer) {
+        payload->pBuffer = (ANativeWindowBuffer*)(((uint8_t*)payload->pBuffer) -
+                ICameraRecordingProxy::getCommonBaseAddress());
+    }
+}
+
 CameraSource::ProxyListener::ProxyListener(const sp<CameraSource>& source) {
     mSource = source;
 }
diff --git a/av/media/libstagefright/DRMExtractor.cpp b/av/media/libstagefright/DRMExtractor.cpp
index 9cb6e86..e2bc89c 100644
--- a/av/media/libstagefright/DRMExtractor.cpp
+++ b/av/media/libstagefright/DRMExtractor.cpp
@@ -200,7 +200,17 @@ status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {
                 continue;
             }
 
-            CHECK(dstOffset + 4 <= (*buffer)->size());
+            if (dstOffset > SIZE_MAX - 4 ||
+                dstOffset + 4 > SIZE_MAX - nalLength ||
+                dstOffset + 4 + nalLength > (*buffer)->size()) {
+                (*buffer)->release();
+                (*buffer) = NULL;
+                if (decryptedDrmBuffer.data) {
+                    delete [] decryptedDrmBuffer.data;
+                    decryptedDrmBuffer.data = NULL;
+                }
+                return ERROR_MALFORMED;
+            }
 
             dstData[dstOffset++] = 0;
             dstData[dstOffset++] = 0;
diff --git a/av/media/libstagefright/FLACExtractor.cpp b/av/media/libstagefright/FLACExtractor.cpp
index d2287a1..d799563 100644
--- a/av/media/libstagefright/FLACExtractor.cpp
+++ b/av/media/libstagefright/FLACExtractor.cpp
@@ -691,8 +691,13 @@ MediaBuffer *FLACParser::readBuffer(bool doSeek, FLAC__uint64 sample)
     CHECK(bufferSize <= mMaxBufferSize);
     short *data = (short *) buffer->data();
     buffer->set_range(0, bufferSize);
-    // copy PCM from FLAC write buffer to our media buffer, with interleaving
-    (*mCopy)(data, mWriteBuffer, blocksize, getChannels());
+    if (doSeek && sample) {
+          //solve seek noise becase of buffer no explicit flush
+          ALOGI("seek skip this frame!!");
+    }else{
+         // copy PCM from FLAC write buffer to our media buffer, with interleaving
+         (*mCopy)(data, mWriteBuffer, blocksize, getChannels());
+    }
     // fill in buffer metadata
     CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
     FLAC__uint64 sampleNumber = mWriteHeader.number.sample_number;
diff --git a/av/media/libstagefright/MPEG4Extractor.cpp b/av/media/libstagefright/MPEG4Extractor.cpp
index 739a281..c0ba087 100644
--- a/av/media/libstagefright/MPEG4Extractor.cpp
+++ b/av/media/libstagefright/MPEG4Extractor.cpp
@@ -535,6 +535,10 @@ status_t MPEG4Extractor::readMetaData() {
     }
     if (psshsize > 0 && psshsize <= UINT32_MAX) {
         char *buf = (char*)malloc(psshsize);
+        if (!buf) {
+            ALOGE("b/28471206");
+            return NO_MEMORY;
+        }
         char *ptr = buf;
         for (size_t i = 0; i < mPssh.size(); i++) {
             memcpy(ptr, mPssh[i].uuid, 20); // uuid + length
@@ -929,6 +933,11 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             }
 
             if (isTrack) {
+                int32_t trackId;
+                // There must be exact one track header per track.
+                if (!mLastTrack->meta->findInt32(kKeyTrackID, &trackId)) {
+                    mLastTrack->skipTrack = true;
+                }
                 if (mLastTrack->skipTrack) {
                     Track *cur = mFirstTrack;
 
@@ -1702,6 +1711,11 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
             sp<ABuffer> buffer = new ABuffer(chunk_data_size);
 
+            if (buffer->data() == NULL) {
+                ALOGE("b/28471206");
+                return NO_MEMORY;
+            }
+
             if (mDataSource->readAt(
                         data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                 return ERROR_IO;
@@ -1719,6 +1733,11 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         {
             sp<ABuffer> buffer = new ABuffer(chunk_data_size);
 
+            if (buffer->data() == NULL) {
+                ALOGE("b/28471206");
+                return NO_MEMORY;
+            }
+
             if (mDataSource->readAt(
                         data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                 return ERROR_IO;
@@ -2054,6 +2073,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                     return ERROR_MALFORMED;
                 }
                 sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1);
+                if (buffer->data() == NULL) {
+                    ALOGE("b/28471206");
+                    return NO_MEMORY;
+                }
                 if (mDataSource->readAt(
                     data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {
                     return ERROR_IO;
@@ -2906,6 +2929,9 @@ sp<MediaSource> MPEG4Extractor::getTrack(size_t index) {
                 break;
             }
         }
+    } else {
+        ALOGE("b/21657957");
+        return NULL;
     }
 
     ALOGV("getTrack called, pssh: %zu", mPssh.size());
diff --git a/av/media/libstagefright/MediaCodec.cpp b/av/media/libstagefright/MediaCodec.cpp
index 6cbace6..0223b95 100644
--- a/av/media/libstagefright/MediaCodec.cpp
+++ b/av/media/libstagefright/MediaCodec.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #define LOG_TAG "MediaCodec"
 #include <inttypes.h>
 
@@ -52,8 +52,29 @@
 #include <utils/Log.h>
 #include <utils/Singleton.h>
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+
 namespace android {
 
+static int read_sysfs_int(const char *path) {
+    int fd;
+    int val = 0;
+    char  bcmd[16];
+    fd = open(path, O_RDONLY);
+    if (fd >= 0) {
+        read(fd, bcmd, sizeof(bcmd));
+        val = strtol(bcmd, NULL, 10);
+        close(fd);
+    } else {
+        ALOGD("unable to open file %s,err: %s", path, strerror(errno));
+    }
+    return val;
+}
+
+
 static int64_t getId(sp<IResourceManagerClient> client) {
     return (int64_t) client.get();
 }
@@ -436,7 +457,6 @@ status_t MediaCodec::configure(
             mRotationDegrees = 0;
         }
     }
-
     msg->setMessage("format", format);
     msg->setInt32("flags", flags);
     msg->setObject("surface", surface);
@@ -742,7 +762,6 @@ status_t MediaCodec::dequeueOutputBuffer(
         int64_t timeoutUs) {
     sp<AMessage> msg = new AMessage(kWhatDequeueOutputBuffer, this);
     msg->setInt64("timeoutUs", timeoutUs);
-
     sp<AMessage> response;
     status_t err;
     if ((err = PostAndAwaitResponse(msg, &response)) != OK) {
@@ -2007,7 +2026,13 @@ void MediaCodec::onMessageReceived(const sp<AMessage> &msg) {
                 PostReplyWithError(replyID, -EAGAIN);
                 break;
             }
-
+            if (timeoutUs > 100000 && mComponentName == AString("OMX.amlogic.vp9.decoder.awesome")) {
+                int nokeyframe = read_sysfs_int("/sys/module/amvdec_vp9/parameters/on_no_keyframe_skiped");
+                if (nokeyframe) {
+                    timeoutUs = 10000; /*no keyframe found, less wait for fast out.*/
+                    ALOGD("No keyframe found, less wait less time\n");
+                }
+            }
             mFlags |= kFlagDequeueOutputPending;
             mDequeueOutputReplyID = replyID;
 
diff --git a/av/media/libstagefright/MediaCodecList.cpp b/av/media/libstagefright/MediaCodecList.cpp
index 5edc04c..f172822 100644
--- a/av/media/libstagefright/MediaCodecList.cpp
+++ b/av/media/libstagefright/MediaCodecList.cpp
@@ -174,6 +174,9 @@ MediaCodecList::MediaCodecList()
     : mInitCheck(NO_INIT),
       mUpdate(false),
       mGlobalSettings(new AMessage()) {
+#ifdef USE_MEDIACODEC_SECURE
+    parseTopLevelXMLFile("/etc/media_codecs_secure.xml");
+#endif
     parseTopLevelXMLFile("/etc/media_codecs.xml");
     parseTopLevelXMLFile("/etc/media_codecs_performance.xml", true/* ignore_errors */);
     parseTopLevelXMLFile(kProfilingResults, true/* ignore_errors */);
diff --git a/av/media/libstagefright/OMXCodec.cpp b/av/media/libstagefright/OMXCodec.cpp
index 62dbaa3..99fc26c 100644
--- a/av/media/libstagefright/OMXCodec.cpp
+++ b/av/media/libstagefright/OMXCodec.cpp
@@ -2135,6 +2135,13 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     if (!meta->findInt32(kKeyRotation, &rotationDegrees)) {
         rotationDegrees = 0;
     }
+    if (rotationDegrees != 0)  {
+        OMX_U32 rotation= rotationDegrees;
+        OMX_INDEXTYPE index;
+        if (mOMX->getExtensionIndex(mNode,"OMX.amlogic.android.index.Rotation",&index) == OK) {
+            mOMX->setParameter(mNode, index, &rotation, sizeof(rotation));
+        }
+    }
 
     // Set up the native window.
     OMX_U32 usage = 0;
diff --git a/av/media/libstagefright/SampleIterator.cpp b/av/media/libstagefright/SampleIterator.cpp
index 2748349..c5f359e 100644
--- a/av/media/libstagefright/SampleIterator.cpp
+++ b/av/media/libstagefright/SampleIterator.cpp
@@ -84,6 +84,11 @@ status_t SampleIterator::seekTo(uint32_t sampleIndex) {
 
     CHECK(sampleIndex < mStopChunkSampleIndex);
 
+    if (mSamplesPerChunk == 0) {
+        ALOGE("b/22802344");
+        return ERROR_MALFORMED;
+    }
+
     uint32_t chunk =
         (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk
         + mFirstChunk;
diff --git a/av/media/libstagefright/WAVExtractor.cpp b/av/media/libstagefright/WAVExtractor.cpp
index 6f43e27..f061c6e 100644
--- a/av/media/libstagefright/WAVExtractor.cpp
+++ b/av/media/libstagefright/WAVExtractor.cpp
@@ -494,7 +494,8 @@ status_t WAVSource::read(
     } else {
         // read only integral amounts of audio unit frames.
         const size_t inputUnitFrameSize = mNumChannels * mBitsPerSample / 8;
-        maxBytesToRead -= maxBytesToRead % inputUnitFrameSize;
+        if (inputUnitFrameSize != 0)
+            maxBytesToRead -= maxBytesToRead % inputUnitFrameSize;
     }
 
     ssize_t n = mDataSource->readAt(
diff --git a/av/media/libstagefright/codecs/aacdec/SoftAAC2.cpp b/av/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
index 520ecb4..a1aa71a 100644
--- a/av/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
+++ b/av/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
@@ -68,13 +68,24 @@ SoftAAC2::SoftAAC2(
       mOutputBufferCount(0),
       mSignalledError(false),
       mLastInHeader(NULL),
+      mSbrChanged(false),
+      mSfIndex(0),
       mOutputPortSettingsChange(NONE) {
     initPorts();
+    //store codecconfig data,used for aacDecoder_ConfigRaw when mSbrChanged
+    mInBuffer[0] = (UCHAR *)malloc(FILEREAD_MAX_LAYERS);
+    if (mInBuffer[0]== NULL) {
+        ALOGE("mInBuffer malloc failed");
+    }
     CHECK_EQ(initDecoder(), (status_t)OK);
 }
 
 SoftAAC2::~SoftAAC2() {
     aacDecoder_Close(mAACDecoder);
+    if (mInBuffer[0] != NULL) {
+        free(mInBuffer[0]);
+        mInBuffer[0] = NULL;
+    }
     delete[] mOutputDelayRingBuffer;
 }
 
@@ -526,7 +537,7 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
     UCHAR* inBuffer[FILEREAD_MAX_LAYERS];
     UINT inBufferLength[FILEREAD_MAX_LAYERS] = {0};
     UINT bytesValid[FILEREAD_MAX_LAYERS] = {0};
-
+    uint8_t profile, sf_index, channel;
     List<BufferInfo *> &inQueue = getPortQueue(0);
     List<BufferInfo *> &outQueue = getPortQueue(1);
 
@@ -548,7 +559,7 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
 
                 inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;
                 inBufferLength[0] = inHeader->nFilledLen;
-
+                mSfIndex = ((inBuffer[0][0]&0x3) << 1) | (inBuffer[0][1]&0x80 >>7);
                 AAC_DECODER_ERROR decoderErr =
                     aacDecoder_ConfigRaw(mAACDecoder,
                                          inBuffer,
@@ -594,6 +605,43 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                 inHeader = NULL;
                 continue;
             }
+            if (mSbrChanged) {
+                initDecoder();
+                onReset();
+                UINT tmpinBufferLength[FILEREAD_MAX_LAYERS]= {2};
+                AAC_DECODER_ERROR decoderErr =
+                aacDecoder_ConfigRaw(mAACDecoder,
+                                     mInBuffer,
+                                     tmpinBufferLength);
+                if (decoderErr != AAC_DEC_OK) {
+                    ALOGW("aacDecoder_ConfigRaw decoderErr = 0x%4.4x", decoderErr);
+                    mSignalledError = true;
+                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
+                    continue;
+                }
+
+                mInputBufferCount++;
+                mOutputBufferCount++; // fake increase of outputBufferCount to keep the counters aligned
+
+                inInfo->mOwnedByUs = false;
+                inQueue.erase(inQueue.begin());
+                mLastInHeader = NULL;
+                inInfo = NULL;
+                notifyEmptyBufferDone(inHeader);
+                inHeader = NULL;
+                configureDownmix();
+                // Only send out port settings changed event if both sample rate
+                // and numChannels are valid.
+                if (mStreamInfo->sampleRate && mStreamInfo->numChannels) {
+                    ALOGI("Initially configuring decoder: %d Hz, %d channels",
+                    mStreamInfo->sampleRate,
+                    mStreamInfo->numChannels);
+                    notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
+                    mOutputPortSettingsChange = AWAITING_DISABLED;
+                 }
+                 mSbrChanged = false;
+                 continue;
+              }
 
             if (mIsADTS) {
                 size_t adtsHeaderSize = 0;
@@ -615,7 +663,17 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                         ((adtsHeader[3] & 3) << 11)
                         | (adtsHeader[4] << 3)
                         | (adtsHeader[5] >> 5);
-
+                    sf_index =(adtsHeader[2] >>2)&0xf;
+                    profile = (adtsHeader[2] >> 6) & 0x3;
+                    channel = (adtsHeader[2] & 0x1) << 2 | (adtsHeader[3] >> 6);
+                    if (sf_index != mSfIndex) {
+                       mSbrChanged =true;
+                       ALOGI("msbrchange:sf_index:%d,mSfIndex:%d",sf_index,mSfIndex);
+                       mInBuffer[0][0]=((profile + 1) << 3) | (sf_index >> 1);
+                       mInBuffer[0][1]=((sf_index << 7) & 0x80) | (channel << 3);
+                       mSfIndex = sf_index;
+                       continue;
+                    }
                     if (inHeader->nFilledLen < aac_frame_length) {
                         ALOGE("Not enough audio data for the complete frame. "
                                 "Got %d bytes, frame size according to the ADTS "
@@ -625,12 +683,15 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                         signalError = true;
                     } else {
                         adtsHeaderSize = (protectionAbsent ? 7 : 9);
-
-                        inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
-                        inBufferLength[0] = aac_frame_length - adtsHeaderSize;
-
-                        inHeader->nOffset += adtsHeaderSize;
-                        inHeader->nFilledLen -= adtsHeaderSize;
+                        if (aac_frame_length < adtsHeaderSize) {
+                            signalError = true;
+                        } else {
+                            inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
+                            inBufferLength[0] = aac_frame_length - adtsHeaderSize;
+
+                            inHeader->nOffset += adtsHeaderSize;
+                            inHeader->nFilledLen -= adtsHeaderSize;
+                        }
                     }
                 }
 
@@ -662,6 +723,7 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
             // Fill and decode
             bytesValid[0] = inBufferLength[0];
 
+
             INT prevSampleRate = mStreamInfo->sampleRate;
             INT prevNumChannels = mStreamInfo->numChannels;
 
@@ -704,7 +766,6 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                 if (decoderErr != AAC_DEC_OK) {
                     ALOGW("aacDecoder_DecodeFrame decoderErr = 0x%4.4x", decoderErr);
                 }
-
                 if (bytesValid[0] != 0) {
                     ALOGE("bytesValid[0] != 0 should never happen");
                     mSignalledError = true;
diff --git a/av/media/libstagefright/codecs/aacdec/SoftAAC2.h b/av/media/libstagefright/codecs/aacdec/SoftAAC2.h
index c3e4459..9969c8e 100644
--- a/av/media/libstagefright/codecs/aacdec/SoftAAC2.h
+++ b/av/media/libstagefright/codecs/aacdec/SoftAAC2.h
@@ -64,6 +64,9 @@ private:
     Vector<int64_t> mBufferTimestamps;
 
     CDrcPresModeWrapper mDrcWrap;
+    bool mSbrChanged;
+    uint8_t  mSfIndex;
+    UCHAR* mInBuffer[2];
 
     enum {
         NONE,
diff --git a/av/media/libstagefright/codecs/hevcdec/SoftHEVC.cpp b/av/media/libstagefright/codecs/hevcdec/SoftHEVC.cpp
index 982fd73..1ca7823 100644
--- a/av/media/libstagefright/codecs/hevcdec/SoftHEVC.cpp
+++ b/av/media/libstagefright/codecs/hevcdec/SoftHEVC.cpp
@@ -444,6 +444,9 @@ void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {
 
     if (NULL == mCodecCtx) {
         if (OK != initDecoder()) {
+            ALOGE("Failed to initialize decoder");
+            notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);
+            mSignalledError = true;
             return;
         }
     }
@@ -539,6 +542,25 @@ void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {
             IV_API_CALL_STATUS_T status;
             status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);
 
+            bool unsupportedResolution =
+                (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == (s_dec_op.u4_error_code & 0xFF));
+
+            /* Check for unsupported dimensions */
+            if (unsupportedResolution) {
+                ALOGE("Unsupported resolution : %dx%d", mWidth, mHeight);
+                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);
+                mSignalledError = true;
+                return;
+            }
+
+            bool allocationFailed = (IVD_MEM_ALLOC_FAILED == (s_dec_op.u4_error_code & 0xFF));
+            if (allocationFailed) {
+                ALOGE("Allocation failure in decoder");
+                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);
+                mSignalledError = true;
+                return;
+            }
+
             bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));
 
             GETTIME(&mTimeEnd, NULL);
diff --git a/av/media/libstagefright/codecs/on2/h264dec/source/h264bsd_dpb.c b/av/media/libstagefright/codecs/on2/h264dec/source/h264bsd_dpb.c
index 9517d0a..799bd16 100644
--- a/av/media/libstagefright/codecs/on2/h264dec/source/h264bsd_dpb.c
+++ b/av/media/libstagefright/codecs/on2/h264dec/source/h264bsd_dpb.c
@@ -60,6 +60,7 @@
 #include "h264bsd_util.h"
 #include "basetype.h"
 
+#include <log/log.h>
 /*------------------------------------------------------------------------------
     2. External compiler flags
 --------------------------------------------------------------------------------
@@ -998,6 +999,13 @@ u32 h264bsdInitDpb(
     ASSERT(maxFrameNum);
     ASSERT(dpbSize);
 
+    // see comment in loop below about size calculation
+    if (picSizeInMbs > (UINT32_MAX - 32 - 15) / 384) {
+        ALOGE("b/28533562");
+        android_errorWriteLog(0x534e4554, "28533562");
+        return(MEMORY_ALLOCATION_ERROR);
+    }
+
     dpb->maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES;
     dpb->maxRefFrames        = MAX(maxRefFrames, 1);
     if (noReordering)
diff --git a/av/media/libstagefright/codecs/on2/h264dec/source/h264bsd_storage.c b/av/media/libstagefright/codecs/on2/h264dec/source/h264bsd_storage.c
index 3234754..ff7a42a 100644
--- a/av/media/libstagefright/codecs/on2/h264dec/source/h264bsd_storage.c
+++ b/av/media/libstagefright/codecs/on2/h264dec/source/h264bsd_storage.c
@@ -58,6 +58,10 @@
     3. Module defines
 ------------------------------------------------------------------------------*/
 
+#ifndef UINT32_MAX
+#define UINT32_MAX       (4294967295U)
+#endif
+
 /*------------------------------------------------------------------------------
     4. Local function prototypes
 ------------------------------------------------------------------------------*/
@@ -326,9 +330,23 @@ u32 h264bsdActivateParamSets(storage_t *pStorage, u32 ppsId, u32 isIdr)
         pStorage->activePps = pStorage->pps[ppsId];
         pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;
         pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];
-        pStorage->picSizeInMbs =
-            pStorage->activeSps->picWidthInMbs *
-            pStorage->activeSps->picHeightInMbs;
+
+        /* report error before multiplication to prevent integer overflow */
+        if (pStorage->activeSps->picWidthInMbs == 0)
+        {
+            pStorage->picSizeInMbs = 0;
+        }
+        else if (pStorage->activeSps->picHeightInMbs >
+                 UINT32_MAX / pStorage->activeSps->picWidthInMbs)
+        {
+            return(MEMORY_ALLOCATION_ERROR);
+        }
+        else
+        {
+            pStorage->picSizeInMbs =
+                pStorage->activeSps->picWidthInMbs *
+                pStorage->activeSps->picHeightInMbs;
+        }
 
         pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;
         pStorage->currImage->height = pStorage->activeSps->picHeightInMbs;
diff --git a/av/media/libstagefright/include/OMXNodeInstance.h b/av/media/libstagefright/include/OMXNodeInstance.h
index e5fb45b..babf5b7 100644
--- a/av/media/libstagefright/include/OMXNodeInstance.h
+++ b/av/media/libstagefright/include/OMXNodeInstance.h
@@ -187,7 +187,7 @@ private:
 
     // For buffer id management
     OMX::buffer_id makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
-    OMX_BUFFERHEADERTYPE *findBufferHeader(OMX::buffer_id buffer);
+    OMX_BUFFERHEADERTYPE *findBufferHeader(OMX::buffer_id buffer, OMX_U32 portIndex);
     OMX::buffer_id findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
     void invalidateBufferID(OMX::buffer_id buffer);
 
diff --git a/av/media/libstagefright/mpeg2ts/ATSParser.cpp b/av/media/libstagefright/mpeg2ts/ATSParser.cpp
index e3c3e80..0f5c986 100644
--- a/av/media/libstagefright/mpeg2ts/ATSParser.cpp
+++ b/av/media/libstagefright/mpeg2ts/ATSParser.cpp
@@ -1713,6 +1713,13 @@ bool ATSParser::PSISection::isCRCOkay() const {
     unsigned sectionLength = U16_AT(data + 1) & 0xfff;
     ALOGV("sectionLength %u, skip %u", sectionLength, mSkipBytes);
 
+
+    if (sectionLength < mSkipBytes) {
+        ALOGE("b/28333006");
+        android_errorWriteLog(0x534e4554, "28333006");
+        return false;
+    }
+
     // Skip the preceding field present when payload start indicator is on.
     sectionLength -= mSkipBytes;
 
diff --git a/av/media/libstagefright/omx/OMXNodeInstance.cpp b/av/media/libstagefright/omx/OMXNodeInstance.cpp
index 2363d0f..a88b457 100755
--- a/av/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/av/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -103,19 +103,22 @@ static void InitOMXParams(T *params) {
 namespace android {
 
 struct BufferMeta {
-    BufferMeta(const sp<IMemory> &mem, bool is_backup = false)
+    BufferMeta(const sp<IMemory> &mem, OMX_U32 portIndex, bool is_backup = false)
         : mMem(mem),
-          mIsBackup(is_backup) {
+          mIsBackup(is_backup),
+          mPortIndex(portIndex) {
     }
 
-    BufferMeta(size_t size)
+    BufferMeta(size_t size, OMX_U32 portIndex)
         : mSize(size),
-          mIsBackup(false) {
+          mIsBackup(false),
+          mPortIndex(portIndex) {
     }
 
-    BufferMeta(const sp<GraphicBuffer> &graphicBuffer)
+    BufferMeta(const sp<GraphicBuffer> &graphicBuffer, OMX_U32 portIndex)
         : mGraphicBuffer(graphicBuffer),
-          mIsBackup(false) {
+          mIsBackup(false),
+          mPortIndex(portIndex) {
     }
 
     void CopyFromOMX(const OMX_BUFFERHEADERTYPE *header) {
@@ -162,11 +165,16 @@ struct BufferMeta {
         mGraphicBuffer = graphicBuffer;
     }
 
+    OMX_U32 getPortIndex() {
+        return mPortIndex;
+    }
+
 private:
     sp<GraphicBuffer> mGraphicBuffer;
     sp<IMemory> mMem;
     size_t mSize;
     bool mIsBackup;
+    OMX_U32 mPortIndex;
 
     BufferMeta(const BufferMeta &);
     BufferMeta &operator=(const BufferMeta &);
@@ -665,7 +673,7 @@ status_t OMXNodeInstance::useBuffer(
         return BAD_VALUE;
     }
 
-    BufferMeta *buffer_meta = new BufferMeta(params);
+    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);
 
     OMX_BUFFERHEADERTYPE *header;
 
@@ -717,7 +725,7 @@ status_t OMXNodeInstance::useGraphicBuffer2_l(
         return UNKNOWN_ERROR;
     }
 
-    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);
+    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer, portIndex);
 
     OMX_BUFFERHEADERTYPE *header = NULL;
     OMX_U8* bufferHandle = const_cast<OMX_U8*>(
@@ -775,7 +783,7 @@ status_t OMXNodeInstance::useGraphicBuffer(
         return StatusFromOMXError(err);
     }
 
-    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);
+    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer, portIndex);
 
     OMX_BUFFERHEADERTYPE *header;
 
@@ -816,6 +824,9 @@ status_t OMXNodeInstance::useGraphicBuffer(
 status_t OMXNodeInstance::updateGraphicBufferInMeta_l(
         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
         OMX::buffer_id buffer, OMX_BUFFERHEADERTYPE *header) {
+    if (header == NULL) {
+        return BAD_VALUE;
+    }
     if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {
         return BAD_VALUE;
     }
@@ -849,7 +860,7 @@ status_t OMXNodeInstance::updateGraphicBufferInMeta(
         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
         OMX::buffer_id buffer) {
     Mutex::Autolock autoLock(mLock);
-    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
+    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);
     return updateGraphicBufferInMeta_l(portIndex, graphicBuffer, buffer, header);
 }
 
@@ -978,7 +989,7 @@ status_t OMXNodeInstance::allocateBuffer(
         void **buffer_data) {
     Mutex::Autolock autoLock(mLock);
 
-    BufferMeta *buffer_meta = new BufferMeta(size);
+    BufferMeta *buffer_meta = new BufferMeta(size, portIndex);
 
     OMX_BUFFERHEADERTYPE *header;
 
@@ -1019,7 +1030,7 @@ status_t OMXNodeInstance::allocateBufferWithBackup(
         return BAD_VALUE;
     }
 
-    BufferMeta *buffer_meta = new BufferMeta(params, true);
+    BufferMeta *buffer_meta = new BufferMeta(params, portIndex, true);
 
     OMX_BUFFERHEADERTYPE *header;
 
@@ -1060,7 +1071,10 @@ status_t OMXNodeInstance::freeBuffer(
 
     removeActiveBuffer(portIndex, buffer);
 
-    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
+    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);
+    if (header == NULL) {
+        return BAD_VALUE;
+    }
     BufferMeta *buffer_meta = static_cast<BufferMeta *>(header->pAppPrivate);
 
     OMX_ERRORTYPE err = OMX_FreeBuffer(mHandle, portIndex, header);
@@ -1076,7 +1090,10 @@ status_t OMXNodeInstance::freeBuffer(
 status_t OMXNodeInstance::fillBuffer(OMX::buffer_id buffer, int fenceFd) {
     Mutex::Autolock autoLock(mLock);
 
-    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
+    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, kPortIndexOutput);
+    if (header == NULL) {
+        return BAD_VALUE;
+    }
     header->nFilledLen = 0;
     header->nOffset = 0;
     header->nFlags = 0;
@@ -1109,7 +1126,10 @@ status_t OMXNodeInstance::emptyBuffer(
         OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {
     Mutex::Autolock autoLock(mLock);
 
-    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
+    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, kPortIndexInput);
+    if (header == NULL) {
+        return BAD_VALUE;
+    }
     // rangeLength and rangeOffset must be a subset of the allocated data in the buffer.
     // corner case: we permit rangeOffset == end-of-buffer with rangeLength == 0.
     if (rangeOffset > header->nAllocLen
@@ -1398,7 +1418,10 @@ bool OMXNodeInstance::handleMessage(omx_message &msg) {
 
     if (msg.type == omx_message::FILL_BUFFER_DONE) {
         OMX_BUFFERHEADERTYPE *buffer =
-            findBufferHeader(msg.u.extended_buffer_data.buffer);
+            findBufferHeader(msg.u.extended_buffer_data.buffer, kPortIndexOutput);
+        if (buffer == NULL) {
+            return false;
+        }
 
         {
             Mutex::Autolock _l(mDebugLock);
@@ -1429,7 +1452,10 @@ bool OMXNodeInstance::handleMessage(omx_message &msg) {
         }
     } else if (msg.type == omx_message::EMPTY_BUFFER_DONE) {
         OMX_BUFFERHEADERTYPE *buffer =
-            findBufferHeader(msg.u.buffer_data.buffer);
+            findBufferHeader(msg.u.buffer_data.buffer, kPortIndexInput);
+        if (buffer == NULL) {
+            return false;
+        }
 
         {
             Mutex::Autolock _l(mDebugLock);
@@ -1645,7 +1671,8 @@ OMX::buffer_id OMXNodeInstance::makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader)
     return buffer;
 }
 
-OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) {
+OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(
+        OMX::buffer_id buffer, OMX_U32 portIndex) {
     if (buffer == 0) {
         return NULL;
     }
@@ -1655,7 +1682,15 @@ OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) {
         CLOGW("findBufferHeader: buffer %u not found", buffer);
         return NULL;
     }
-    return mBufferIDToBufferHeader.valueAt(index);
+    OMX_BUFFERHEADERTYPE *header = mBufferIDToBufferHeader.valueAt(index);
+    BufferMeta *buffer_meta =
+        static_cast<BufferMeta *>(header->pAppPrivate);
+    if (buffer_meta->getPortIndex() != portIndex) {
+        CLOGW("findBufferHeader: buffer %u found but with incorrect port index.", buffer);
+        android_errorWriteLog(0x534e4554, "28816827");
+        return NULL;
+    }
+    return header;
 }
 
 OMX::buffer_id OMXNodeInstance::findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
diff --git a/av/media/mediaserver/Android.mk b/av/media/mediaserver/Android.mk
index 0d6e7f2..3d072d3 100644
--- a/av/media/mediaserver/Android.mk
+++ b/av/media/mediaserver/Android.mk
@@ -47,6 +47,7 @@ endif
 
 LOCAL_C_INCLUDES := \
     frameworks/av/media/libmediaplayerservice \
+    frameworks/av/media/libmedia \
     frameworks/av/services/medialog \
     frameworks/av/services/audioflinger \
     frameworks/av/services/audiopolicy \
diff --git a/av/media/mediaserver/main_mediaserver.cpp b/av/media/mediaserver/main_mediaserver.cpp
index 3c860f5..1ba203d 100644
--- a/av/media/mediaserver/main_mediaserver.cpp
+++ b/av/media/mediaserver/main_mediaserver.cpp
@@ -36,6 +36,7 @@
 #include "MediaPlayerService.h"
 #include "ResourceManagerService.h"
 #include "service/AudioPolicyService.h"
+#include "MediaUtils.h"
 #include "SoundTriggerHwService.h"
 #include "RadioService.h"
 
@@ -43,6 +44,11 @@ using namespace android;
 
 int main(int argc __unused, char** argv)
 {
+    limitProcessMemory(
+        "ro.media.maxmem", /* property that defines limit */
+        SIZE_MAX, /* upper limit in bytes */
+        65 /* upper limit as percentage of physical RAM */);
+
     signal(SIGPIPE, SIG_IGN);
     char value[PROPERTY_VALUE_MAX];
     bool doLog = (property_get("ro.test_harness", value, "0") > 0) && (atoi(value) == 1);
diff --git a/av/services/audioflinger/Effects.cpp b/av/services/audioflinger/Effects.cpp
index 949c91d..eb52dee 100644
--- a/av/services/audioflinger/Effects.cpp
+++ b/av/services/audioflinger/Effects.cpp
@@ -558,6 +558,12 @@ status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
     if (mStatus != NO_ERROR) {
         return mStatus;
     }
+    if (cmdCode == EFFECT_CMD_GET_PARAM &&
+            (*replySize < sizeof(effect_param_t) ||
+                    ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {
+        android_errorWriteLog(0x534e4554, "29251553");
+        return -EINVAL;
+    }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
diff --git a/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index fcd66c4..7fd72f5 100644
--- a/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -1854,7 +1854,11 @@ status_t AudioPolicyManager::setStreamVolumeIndex(audio_stream_type_t stream,
     if (!audio_is_output_device(device)) {
         return BAD_VALUE;
     }
-
+    if ((stream == AUDIO_STREAM_SYSTEM) || (stream == AUDIO_STREAM_RING) ||
+    (stream == AUDIO_STREAM_NOTIFICATION ) || (stream == AUDIO_STREAM_ENFORCED_AUDIBLE))
+    {
+        index = index*2;
+    }
     // Force max volume if stream cannot be muted
     if (!mStreams.canBeMuted(stream)) index = mStreams.valueFor(stream).getVolumeIndexMax();
 
diff --git a/av/services/camera/libcameraservice/CameraService.cpp b/av/services/camera/libcameraservice/CameraService.cpp
index cb56a98..2d3a6ed 100644
--- a/av/services/camera/libcameraservice/CameraService.cpp
+++ b/av/services/camera/libcameraservice/CameraService.cpp
@@ -1576,6 +1576,10 @@ void CameraService::usbCameraAttach(bool isAttach){
         CameraService::pingCameraServiceProxy();
     }
 
+    if (mNumberOfCameras == 0) {
+        mModule->setCameraInfo(0, false);
+    }
+
     ALOGI("USB camera attach isAttach:%d, number:%d", isAttach, mNumberOfCameras);
 }
 
diff --git a/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp b/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp
index 66d7b00..9e6c0db 100644
--- a/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp
+++ b/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp
@@ -30,6 +30,7 @@
 #include <utils/Trace.h>
 #include <gui/BufferItem.h>
 #include <gui/Surface.h>
+#include <camera/ICameraRecordingProxy.h>
 #include <media/hardware/HardwareAPI.h>
 
 #include "common/CameraDeviceBase.h"
@@ -826,6 +827,9 @@ status_t StreamingProcessor::processRecordingFrame() {
             (uint8_t*)heap->getBase() + offset);
         payload->eType = kMetadataBufferTypeANWBuffer;
         payload->pBuffer = imgBuffer.mGraphicBuffer->getNativeBuffer();
+        // b/28466701
+        payload->pBuffer = (ANativeWindowBuffer*)((uint8_t*)payload->pBuffer -
+                ICameraRecordingProxy::getCommonBaseAddress());
         payload->nFenceFd = -1;
 
         ALOGVV("%s: Camera %d: Sending out ANWBuffer %p",
@@ -874,6 +878,10 @@ void StreamingProcessor::releaseRecordingFrame(const sp<IMemory>& mem) {
         return;
     }
 
+    // b/28466701
+    payload->pBuffer = (ANativeWindowBuffer*)(((uint8_t*)payload->pBuffer) +
+            ICameraRecordingProxy::getCommonBaseAddress());
+
     // Release the buffer back to the recording queue
     size_t itemIndex;
     for (itemIndex = 0; itemIndex < mRecordingBuffers.size(); itemIndex++) {
diff --git a/av/services/camera/libcameraservice/common/CameraModule.cpp b/av/services/camera/libcameraservice/common/CameraModule.cpp
index 16b8aba..d8671e9 100644
--- a/av/services/camera/libcameraservice/common/CameraModule.cpp
+++ b/av/services/camera/libcameraservice/common/CameraModule.cpp
@@ -216,11 +216,11 @@ int CameraModule::getCameraInfo(int cameraId, struct camera_info *info) {
             *info = rawInfo;
             return ret;
         }
-        CameraMetadata m;
-        m = rawInfo.static_camera_characteristics;
-        deriveCameraCharacteristicsKeys(rawInfo.device_version, m);
+        mCameraMeta = CameraMetadata((camera_metadata_t*)rawInfo.static_camera_characteristics);
+        deriveCameraCharacteristicsKeys(rawInfo.device_version, mCameraMeta);
         cameraInfo = rawInfo;
-        cameraInfo.static_camera_characteristics = m.release();
+        cameraInfo.static_camera_characteristics = mCameraMeta.release();
+        ALOGD("%s: cameraId%d build new Metadata %p", __FUNCTION__, cameraId, cameraInfo.static_camera_characteristics);
         index = mCameraInfoMap.add(cameraId, cameraInfo);
     }
 
@@ -230,6 +230,21 @@ int CameraModule::getCameraInfo(int cameraId, struct camera_info *info) {
     return OK;
 }
 
+int CameraModule::setCameraInfo(int cameraId, bool isCameraAttach) {
+    if (isCameraAttach) {
+        ALOGD("Camera %d is attached!", cameraId);
+    } else {
+        ALOGD("Camera %d is unattached!", cameraId);
+        ssize_t index = mCameraInfoMap.indexOfKey(cameraId);
+        if (index == NAME_NOT_FOUND) {
+            ALOGE("Camera %d is unattached, but CameraInfoMap is null!", cameraId);
+        } else {
+            mCameraInfoMap.removeItem(cameraId);
+        }
+    }
+    return OK;
+}
+
 int CameraModule::open(const char* id, struct hw_device_t** device) {
     int res;
     ATRACE_BEGIN("camera_module->open");
diff --git a/av/services/camera/libcameraservice/common/CameraModule.h b/av/services/camera/libcameraservice/common/CameraModule.h
index 36822c7..13d82b3 100644
--- a/av/services/camera/libcameraservice/common/CameraModule.h
+++ b/av/services/camera/libcameraservice/common/CameraModule.h
@@ -40,6 +40,7 @@ public:
     int init();
 
     int getCameraInfo(int cameraId, struct camera_info *info);
+    int setCameraInfo(int cameraId, bool isCameraAttach);
     int getNumberOfCameras(void);
     int open(const char* id, struct hw_device_t** device);
     int openLegacy(const char* id, uint32_t halVersion, struct hw_device_t** device);
@@ -60,6 +61,7 @@ private:
     status_t filterOpenErrorCode(status_t err);
 
     camera_module_t *mModule;
+    CameraMetadata mCameraMeta;
     KeyedVector<int, camera_info> mCameraInfoMap;
     Mutex mCameraInfoLock;
 };
diff --git a/base/api/current.txt b/base/api/current.txt
index 2e76095..9e919f1 100644
--- a/base/api/current.txt
+++ b/base/api/current.txt
@@ -26598,8 +26598,6 @@ package android.provider {
     field public static final deprecated java.lang.String LOCK_PATTERN_VISIBLE = "lock_pattern_visible_pattern";
     field public static final deprecated java.lang.String LOGGING_ID = "logging_id";
     field public static final deprecated java.lang.String NETWORK_PREFERENCE = "network_preference";
-    field public static final java.lang.String NTP_SERVER = "ntp_server";
-    field public static final java.lang.String NTP_SERVER2 = "ntp_server2";
     field public static final java.lang.String PARENTAL_CONTROL_ENABLED = "parental_control_enabled";
     field public static final java.lang.String PARENTAL_CONTROL_LAST_UPDATE = "parental_control_last_update";
     field public static final java.lang.String PARENTAL_CONTROL_REDIRECT_URL = "parental_control_redirect_url";
diff --git a/base/api/system-current.txt b/base/api/system-current.txt
index 4959634..85f6afe 100644
--- a/base/api/system-current.txt
+++ b/base/api/system-current.txt
@@ -14308,7 +14308,6 @@ package android.hardware.hdmi {
 
   public abstract class HdmiClient {
     method public android.hardware.hdmi.HdmiDeviceInfo getActiveSource();
-    method public boolean isRemoteCEC();
     method public void sendKeyEvent(int, boolean);
     method public void sendVendorCommand(int, byte[], boolean);
     method public void setVendorCommandListener(android.hardware.hdmi.HdmiControlManager.VendorCommandListener);
@@ -14467,7 +14466,6 @@ package android.hardware.hdmi {
     method public void oneTouchPlay(android.hardware.hdmi.HdmiPlaybackClient.OneTouchPlayCallback);
     method public void queryDisplayStatus(android.hardware.hdmi.HdmiPlaybackClient.DisplayStatusCallback);
     method public void sendStandby();
-    method public void sendImageViewOn();
   }
 
   public static abstract interface HdmiPlaybackClient.DisplayStatusCallback {
@@ -21093,7 +21091,7 @@ package android.net.wifi {
     field public static final java.lang.String ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE = "android.net.wifi.action.REQUEST_SCAN_ALWAYS_AVAILABLE";
     field public static final int CHANGE_REASON_ADDED = 0; // 0x0
     field public static final int CHANGE_REASON_CONFIG_CHANGE = 2; // 0x2
-    field public static final int CHANGE_REASON_REMOVED = 1; // 0x1    
+    field public static final int CHANGE_REASON_REMOVED = 1; // 0x1
     field public static final java.lang.String CONFIGURED_NETWORKS_CHANGED_ACTION = "android.net.wifi.CONFIGURED_NETWORKS_CHANGE";
     field public static final int ERROR_AUTHENTICATING = 1; // 0x1
     field public static final java.lang.String EXTRA_BSSID = "bssid";
diff --git a/base/core/java/android/hardware/hdmi/HdmiClient.java b/base/core/java/android/hardware/hdmi/HdmiClient.java
index 133e4f0..45a79e1 100644
--- a/base/core/java/android/hardware/hdmi/HdmiClient.java
+++ b/base/core/java/android/hardware/hdmi/HdmiClient.java
@@ -73,19 +73,6 @@ public abstract class HdmiClient {
     }
 
     /**
-     * add by wusc to check whether tv cec is supported
-     */	
-    public boolean  isRemoteCEC() {
-	try {
-		return mService.isRemoteCEC();
-	} catch (RemoteException e) {
-		Log.e(TAG, "failed to isRemoteCEC: ", e);
-	}
-	return false;
-    }
-
-	
-    /**
      * Sets a listener used to receive incoming vendor-specific command.
      *
      * @param listener listener object
diff --git a/base/core/java/android/hardware/hdmi/HdmiPlaybackClient.java b/base/core/java/android/hardware/hdmi/HdmiPlaybackClient.java
index 1ceb509..874b0c6 100644
--- a/base/core/java/android/hardware/hdmi/HdmiPlaybackClient.java
+++ b/base/core/java/android/hardware/hdmi/HdmiPlaybackClient.java
@@ -116,19 +116,6 @@ public final class HdmiPlaybackClient extends HdmiClient {
             Log.e(TAG, "sendStandby threw exception ", e);
         }
     }
-    
-    /**
-     * Send image view on command to TV. 
-     * add by wusc
-     */
-    public void sendImageViewOn() {
-        try {
-            mService.sendImageViewOn();
-        } catch (Exception e) {
-            Log.e(TAG, "sendImageViewOn threw exception ", e);
-        }
-    }
-
 
     private IHdmiControlCallback getCallbackWrapper(final OneTouchPlayCallback callback) {
         return new IHdmiControlCallback.Stub() {
diff --git a/base/core/java/android/hardware/hdmi/IHdmiControlService.aidl b/base/core/java/android/hardware/hdmi/IHdmiControlService.aidl
index 46d8053..c1e924e 100644
--- a/base/core/java/android/hardware/hdmi/IHdmiControlService.aidl
+++ b/base/core/java/android/hardware/hdmi/IHdmiControlService.aidl
@@ -71,6 +71,4 @@ interface IHdmiControlService {
     void clearTimerRecording(int recorderAddress, int sourceType, in byte[] recordSource);
     void sendMhlVendorCommand(int portId, int offset, int length, in byte[] data);
     void addHdmiMhlVendorCommandListener(IHdmiMhlVendorCommandListener listener);
-    boolean isRemoteCEC();
-    void sendImageViewOn();
 }
diff --git a/base/core/java/android/net/EthernetManager.java b/base/core/java/android/net/EthernetManager.java
index c5c0579..f45737a 100644
--- a/base/core/java/android/net/EthernetManager.java
+++ b/base/core/java/android/net/EthernetManager.java
@@ -37,13 +37,6 @@ public class EthernetManager {
 
     private final Context mContext;
     private final IEthernetManager mService;
-	
-    public static final String ETHERNET_STATE_CHANGED_ACTION =	
-		"android.net.ethernet.ETHERNET_STATE_CHANGE";
-    public static final String EXTRA_ETHERNET_STATE = "ethernet_state";
-	
-    public static final int EVENT_DHCP_CONNECT_FAILED = 11;
-    public static final int EVENT_STATIC_CONNECT_FAILED = 15;
     private final Handler mHandler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
diff --git a/base/core/java/android/provider/Settings.java b/base/core/java/android/provider/Settings.java
index db9b6c8..d81ae7e 100644
--- a/base/core/java/android/provider/Settings.java
+++ b/base/core/java/android/provider/Settings.java
@@ -1478,6 +1478,7 @@ public final class Settings {
             MOVED_TO_SECURE.add(Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY);
             MOVED_TO_SECURE.add(Secure.WIFI_NUM_OPEN_NETWORKS_KEPT);
             MOVED_TO_SECURE.add(Secure.WIFI_ON);
+            MOVED_TO_SECURE.add(Secure.WIFI_AP_ON);
             MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE);
             MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_AP_COUNT);
             MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS);
@@ -3623,7 +3624,11 @@ public final class Settings {
          */
         @Deprecated
         public static final String WIFI_ON = Global.WIFI_ON;
-
+        /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_AP_ON} instead
+         */
+        @Deprecated
+        public static final String WIFI_AP_ON = Global.WIFI_AP_ON;
         /**
          * @deprecated Use
          * {@link android.provider.Settings.Secure#WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE}
@@ -3821,6 +3826,7 @@ public final class Settings {
             MOVED_TO_GLOBAL.add(Settings.Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY);
             MOVED_TO_GLOBAL.add(Settings.Global.WIFI_NUM_OPEN_NETWORKS_KEPT);
             MOVED_TO_GLOBAL.add(Settings.Global.WIFI_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_AP_ON);
             MOVED_TO_GLOBAL.add(Settings.Global.WIFI_P2P_DEVICE_NAME);
             MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SAVED_STATE);
             MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS);
@@ -5033,6 +5039,13 @@ public final class Settings {
         public static final String WIFI_ON = Global.WIFI_ON;
 
         /**
+         * @deprecated Use {@link android.provider.Settings.Global#WIFI_AP_ON}
+         * instead.
+         */
+        @Deprecated
+        public static final String WIFI_AP_ON = Global.WIFI_AP_ON;
+
+        /**
          * The acceptable packet loss percentage (range 0 - 100) before trying
          * another AP on the same network.
          * @deprecated This setting is not used.
@@ -6446,7 +6459,6 @@ public final class Settings {
 
        /** Preferred NTP server. {@hide} */
        public static final String NTP_SERVER = "ntp_server";
-       public static final String NTP_SERVER2 = "ntp_server2";
        /** Timeout in milliseconds to wait for NTP server. {@hide} */
        public static final String NTP_TIMEOUT = "ntp_timeout";
 
@@ -6750,6 +6762,10 @@ public final class Settings {
        public static final String WIFI_ON = "wifi_on";
 
        /**
+        *Whether the Hot-Spot should be on.
+        */
+       public static final String WIFI_AP_ON = "wifi_ap_on";
+       /**
         * Setting to allow scans to be enabled even wifi is turned off for connectivity.
         * @hide
         */
diff --git a/base/core/java/android/util/NtpTrustedTime.java b/base/core/java/android/util/NtpTrustedTime.java
index 791f004..ed2d3c6 100644
--- a/base/core/java/android/util/NtpTrustedTime.java
+++ b/base/core/java/android/util/NtpTrustedTime.java
@@ -40,7 +40,6 @@ public class NtpTrustedTime implements TrustedTime {
     private static Context sContext;
 
     private final String mServer;
-    private final String mServer2;
     private final long mTimeout;
 
     private ConnectivityManager mCM;
@@ -50,11 +49,9 @@ public class NtpTrustedTime implements TrustedTime {
     private long mCachedNtpElapsedRealtime;
     private long mCachedNtpCertainty;
 
-    private NtpTrustedTime(String server, String server2, long timeout) {
-        Log.d(TAG, "creating NtpTrustedTime using " + server);
-		Log.d(TAG, "creating NtpTrustedTime using " + server2);
+    private NtpTrustedTime(String server, long timeout) {
+        if (LOGD) Log.d(TAG, "creating NtpTrustedTime using " + server);
         mServer = server;
-        mServer2 = server2;
         mTimeout = timeout;
     }
 
@@ -70,14 +67,11 @@ public class NtpTrustedTime implements TrustedTime {
 
             final String secureServer = Settings.Global.getString(
                     resolver, Settings.Global.NTP_SERVER);
-			final String secureServer2 = Settings.Global.getString(
-                    resolver, Settings.Global.NTP_SERVER2);
             final long timeout = Settings.Global.getLong(
                     resolver, Settings.Global.NTP_TIMEOUT, defaultTimeout);
 
             final String server = secureServer != null ? secureServer : defaultServer;
-            final String server2 = secureServer2 != null ? secureServer2 : defaultServer;
-            sSingleton = new NtpTrustedTime(server, server2, timeout);
+            sSingleton = new NtpTrustedTime(server, timeout);
             sContext = context;
         }
 
@@ -107,7 +101,7 @@ public class NtpTrustedTime implements TrustedTime {
 
         if (LOGD) Log.d(TAG, "forceRefresh() from cache miss");
         final SntpClient client = new SntpClient();
-        if (client.requestTime(mServer, (int) mTimeout) || client.requestTime(mServer2, (int) mTimeout) ) {
+        if (client.requestTime(mServer, (int) mTimeout)) {
             mHasCache = true;
             mCachedNtpTime = client.getNtpTime();
             mCachedNtpElapsedRealtime = client.getNtpTimeReference();
diff --git a/base/core/java/android/view/KeyEvent.java b/base/core/java/android/view/KeyEvent.java
index 7725ffa..952fed4 100644
--- a/base/core/java/android/view/KeyEvent.java
+++ b/base/core/java/android/view/KeyEvent.java
@@ -1844,7 +1844,6 @@ public class KeyEvent extends InputEvent implements Parcelable {
     /** @hide */
     public static final boolean isWakeKey(int keyCode) {
         switch (keyCode) {
-            /**
             case KeyEvent.KEYCODE_BACK:
             case KeyEvent.KEYCODE_MENU:
             case KeyEvent.KEYCODE_WAKEUP:
@@ -1852,8 +1851,6 @@ public class KeyEvent extends InputEvent implements Parcelable {
             case KeyEvent.KEYCODE_STEM_1:
             case KeyEvent.KEYCODE_STEM_2:
             case KeyEvent.KEYCODE_STEM_3:
-            */
-            case KeyEvent.KEYCODE_POWER:
                 return true;
         }
         return false;
diff --git a/base/core/res/res/layout/resolver_list.xml b/base/core/res/res/layout/resolver_list.xml
index 9a10ef7..00c25e6 100644
--- a/base/core/res/res/layout/resolver_list.xml
+++ b/base/core/res/res/layout/resolver_list.xml
@@ -77,7 +77,6 @@
     </LinearLayout>
 
     <ListView
-        android:layout_alwaysShow="true"
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:id="@+id/resolver_list"
diff --git a/base/core/res/res/values-ru/strings.xml b/base/core/res/res/values-ru/strings.xml
index 0f1feea..e1d344e 100644
--- a/base/core/res/res/values-ru/strings.xml
+++ b/base/core/res/res/values-ru/strings.xml
@@ -1553,9 +1553,4 @@
       <item quantity="many">Выбрано: <xliff:g id="COUNT_1">%1$d</xliff:g></item>
       <item quantity="other">Выбрано: <xliff:g id="COUNT_1">%1$d</xliff:g></item>
     </plurals>
-	
-	<string name="auto_standby_title">"Автоматически ждуший режим"</string>
-    <string name="auto_standby_message">"Привтавка входит в ждуший режим в течение %1$s секунд!"</string>
-    <string name="auto_standby_go_on_watch">"Продолжайте смотреть"</string>
-    <string name="auto_standby_setting">"Установка"</string>
 </resources>
diff --git a/base/core/res/res/values-zh-rCN/strings.xml b/base/core/res/res/values-zh-rCN/strings.xml
index d450670..700cbfd 100644
--- a/base/core/res/res/values-zh-rCN/strings.xml
+++ b/base/core/res/res/values-zh-rCN/strings.xml
@@ -1517,10 +1517,4 @@
       <item quantity="other">已选择 <xliff:g id="COUNT_1">%1$d</xliff:g> 项</item>
       <item quantity="one">已选择 <xliff:g id="COUNT_0">%1$d</xliff:g> 项</item>
     </plurals>
-	
-
-    <string name="auto_standby_title">"自动待机"</string>
-    <string name="auto_standby_message">"机顶盒将于%1$s秒后自动待机!"</string>
-    <string name="auto_standby_go_on_watch">"继续观看"</string>
-    <string name="auto_standby_setting">"设置"</string>
 </resources>
diff --git a/base/core/res/res/values/strings.xml b/base/core/res/res/values/strings.xml
index 8dd39c8..0793905 100644
--- a/base/core/res/res/values/strings.xml
+++ b/base/core/res/res/values/strings.xml
@@ -4109,10 +4109,4 @@
         <item quantity="one"><xliff:g id="count" example="1">%1$d</xliff:g> selected</item>
         <item quantity="other"><xliff:g id="count" example="3">%1$d</xliff:g> selected</item>
     </plurals>
-
-
-    <string name="auto_standby_title">"Auto_Shutdown"</string>
-    <string name="auto_standby_message">"It is going to power off in %1$s seconds!"</string>
-    <string name="auto_standby_go_on_watch">"GoOn Watch"</string>
-    <string name="auto_standby_setting">"Settings"</string>
 </resources>
diff --git a/base/core/res/res/values/symbols.xml b/base/core/res/res/values/symbols.xml
index 09db333..e709500 100644
--- a/base/core/res/res/values/symbols.xml
+++ b/base/core/res/res/values/symbols.xml
@@ -2342,9 +2342,4 @@
 
   <java-symbol type="string" name="config_iccHotswapPromptForRestartDialogComponent" />
   <java-symbol type="string" name="config_packagedKeyboardName" />
-
-  <java-symbol type="string" name="auto_standby_title" />
-  <java-symbol type="string" name="auto_standby_message" />
-  <java-symbol type="string" name="auto_standby_go_on_watch" />
-  <java-symbol type="string" name="auto_standby_setting" />
 </resources>
diff --git a/base/media/java/android/media/MediaPlayer.java b/base/media/java/android/media/MediaPlayer.java
index dcc9d55..9fe8cef 100644
--- a/base/media/java/android/media/MediaPlayer.java
+++ b/base/media/java/android/media/MediaPlayer.java
@@ -1681,6 +1681,7 @@ public class MediaPlayer implements SubtitleController.Listener
             mTimeProvider = null;
         }
         mOnSubtitleDataListener = null;
+        mOnBlurayInfoListener = null;
         _release();
     }
 
@@ -2788,6 +2789,7 @@ public class MediaPlayer implements SubtitleController.Listener
     private static final int MEDIA_INFO = 200;
     private static final int MEDIA_SUBTITLE_DATA = 201;
     private static final int MEDIA_META_DATA = 202;
+    private static final int MEDIA_BLURAY_INFO = 203;
 
     private TimeProvider mTimeProvider;
 
@@ -2957,6 +2959,12 @@ public class MediaPlayer implements SubtitleController.Listener
                 }
                 return;
 
+            case MEDIA_BLURAY_INFO:
+                if (mOnBlurayInfoListener == null)
+                    return;
+                mOnBlurayInfoListener.onBlurayInfo(mMediaPlayer, msg.arg1, msg.arg2, msg.obj);
+                return;
+
             case MEDIA_META_DATA:
                 if (mOnTimedMetaDataAvailableListener == null) {
                     return;
@@ -3245,6 +3253,36 @@ public class MediaPlayer implements SubtitleController.Listener
 
     private OnTimedMetaDataAvailableListener mOnTimedMetaDataAvailableListener;
 
+    /**
+     * Interface definition of a callback to be invoked when a
+     * bluray infomation is available for update.
+     */
+    public interface OnBlurayListener
+    {
+        /**
+         * Called to indicate an avaliable bluray info
+         *
+         * @param mp             the MediaPlayer associated with this callback
+         * @param ext1           the bluray info message arg1
+         * @param ext2           the bluray info message arg2
+         * @param obj            the bluray info message obj
+         */
+        public void onBlurayInfo(MediaPlayer mp, int ext1, int ext2, Object obj);
+    }
+
+    /**
+     * Register a callback to be invoked when a bluray info is available
+     * for update.
+     *
+     * @param listener the callback that will be run
+     */
+    public void setOnBlurayInfoListener(OnBlurayListener listener)
+    {
+        mOnBlurayInfoListener = listener;
+    }
+
+    private OnBlurayListener mOnBlurayInfoListener;
+
     /* Do not change these values without updating their counterparts
      * in include/media/mediaplayer.h!
      */
diff --git a/base/packages/PrintSpooler/src/com/android/printspooler/renderer/PdfManipulationService.java b/base/packages/PrintSpooler/src/com/android/printspooler/renderer/PdfManipulationService.java
index 7db2074..11a9a0e 100644
--- a/base/packages/PrintSpooler/src/com/android/printspooler/renderer/PdfManipulationService.java
+++ b/base/packages/PrintSpooler/src/com/android/printspooler/renderer/PdfManipulationService.java
@@ -56,6 +56,7 @@ public final class PdfManipulationService extends Service {
 
     private static final int MILS_PER_INCH = 1000;
     private static final int POINTS_IN_INCH = 72;
+    private final Object mLock = new Object();
 
     @Override
     public IBinder onBind(Intent intent) {
@@ -74,8 +75,6 @@ public final class PdfManipulationService extends Service {
     }
 
     private final class PdfRendererImpl extends IPdfRenderer.Stub {
-        private final Object mLock = new Object();
-
         private Bitmap mBitmap;
         private PdfRenderer mRenderer;
 
@@ -209,8 +208,6 @@ public final class PdfManipulationService extends Service {
     }
 
     private final class PdfEditorImpl extends IPdfEditor.Stub {
-        private final Object mLock = new Object();
-
         private PdfEditor mEditor;
 
         @Override
diff --git a/base/packages/SettingsProvider/res/values/defaults.xml b/base/packages/SettingsProvider/res/values/defaults.xml
index 5ba019f..dc6ab62 100644
--- a/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/base/packages/SettingsProvider/res/values/defaults.xml
@@ -49,6 +49,7 @@
     <bool name="def_netstats_enabled">true</bool>
     <bool name="def_usb_mass_storage_enabled">true</bool>
     <bool name="def_wifi_on">false</bool>
+    <bool name="def_wifi_ap_on">false</bool>
     <!-- 0 == never, 1 == only when plugged in, 2 == always -->
     <integer name="def_wifi_sleep_policy">2</integer>
     <bool name="def_networks_available_notification_on">true</bool>
@@ -213,6 +214,4 @@
 
     <!-- Default for Settings.Secure.NFC_PAYMENT_COMPONENT -->
     <string name="def_nfc_payment_component"></string>
-    <string name="def_ntp_server">cn.pool.ntp.org</string>
-    <string name="def_ntp_server2">2.android.pool.ntp.org</string>
 </resources>
diff --git a/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
index 3a40bae..4acb8c4 100644
--- a/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+++ b/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
@@ -346,6 +346,7 @@ class DatabaseHelper extends SQLiteOpenHelper {
                     Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
                     Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,
                     Settings.Secure.WIFI_ON,
+                    Settings.Secure.WIFI_AP_ON,
                     Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,
                     Settings.Secure.WIFI_WATCHDOG_AP_COUNT,
                     Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,
@@ -2595,6 +2596,9 @@ class DatabaseHelper extends SQLiteOpenHelper {
             loadBooleanSetting(stmt, Settings.Global.WIFI_ON,
                     R.bool.def_wifi_on);
 
+            loadBooleanSetting(stmt, Settings.Global.WIFI_AP_ON,
+                    R.bool.def_wifi_ap_on);
+
             loadBooleanSetting(stmt, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
                     R.bool.def_networks_available_notification_on);
 
@@ -2671,12 +2675,7 @@ class DatabaseHelper extends SQLiteOpenHelper {
 
             loadIntegerSetting(stmt, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED,
                     R.integer.def_dock_audio_media_enabled);
-			
-			loadStringSetting(stmt, Settings.Global.NTP_SERVER,
-                    R.string.def_ntp_server);
-			loadStringSetting(stmt, Settings.Global.NTP_SERVER2,
-                    R.string.def_ntp_server2);
-			
+
             loadSetting(stmt, Settings.Global.SET_INSTALL_LOCATION, 0);
             loadSetting(stmt, Settings.Global.DEFAULT_INSTALL_LOCATION,
                     PackageHelper.APP_INSTALL_AUTO);
diff --git a/base/services/core/java/com/android/server/AlarmManagerService.java b/base/services/core/java/com/android/server/AlarmManagerService.java
index 130a234..5ee13c4 100755
--- a/base/services/core/java/com/android/server/AlarmManagerService.java
+++ b/base/services/core/java/com/android/server/AlarmManagerService.java
@@ -70,6 +70,10 @@ import java.util.Locale;
 import java.util.Random;
 import java.util.TimeZone;
 import java.util.TreeSet;
+import java.io.FileInputStream;
+import java.io.InputStreamReader;
+import java.io.BufferedReader;
+import java.util.Iterator;
 
 import static android.app.AlarmManager.RTC_WAKEUP;
 import static android.app.AlarmManager.RTC;
@@ -97,6 +101,8 @@ class AlarmManagerService extends SystemService {
     static final boolean RECORD_ALARMS_IN_HISTORY = true;
     static final int ALARM_EVENT = 1;
     static final String TIMEZONE_PROPERTY = "persist.sys.timezone";
+    private final ArrayList<String> mAppWhitelist = new ArrayList<String>();
+    private static boolean mIsMboxMode = false;
 
     static final Intent mBackgroundIntent
             = new Intent().addFlags(Intent.FLAG_FROM_BACKGROUND);
@@ -828,6 +834,27 @@ class AlarmManagerService extends SystemService {
         }
 
         publishBinderService(Context.ALARM_SERVICE, mService);
+
+        String isMboxMode = SystemProperties.get("ro.platform.has.mbxuimode", "false");
+        if(isMboxMode.equals("true")){
+            mIsMboxMode = true;
+        }
+        if(mIsMboxMode){
+            try{
+               BufferedReader br = new BufferedReader(new InputStreamReader(
+                    new FileInputStream("/system/etc/alarm_whitelist.txt")));
+
+                String line ="";
+                while ((line = br.readLine()) != null){
+                    if (localLOGV)  Log.d(TAG, "white alarm" +line);
+                    mAppWhitelist.add(line);
+                }
+
+                br.close();
+            }catch(java.io.FileNotFoundException ex){
+            }catch(java.io.IOException ex){
+            }
+        }
     }
 
     @Override
@@ -960,7 +987,31 @@ class AlarmManagerService extends SystemService {
             long maxWhen, long interval, PendingIntent operation, int flags,
             boolean doValidate, WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock,
             int uid) {
-        Alarm a = new Alarm(type, when, whenElapsed, windowLength, maxWhen, interval,
+        int newType = type;
+        String targetPackage = null;
+        targetPackage = operation.getTargetPackage();
+        if( type == AlarmManager.RTC_WAKEUP||type == AlarmManager.ELAPSED_REALTIME_WAKEUP){
+            if(targetPackage != null){
+                if(mIsMboxMode){
+                    boolean isInWhitelist = false;
+                    Iterator<String> it = mAppWhitelist.iterator();
+                    while (it.hasNext()) {
+                        String whitelisItem = it.next();
+                        if (whitelisItem.equals(targetPackage)) {
+                            Log.d(TAG, targetPackage + " in whitelist");
+                            isInWhitelist = true;
+                            break;
+                        }
+                    }
+                    if(!isInWhitelist){
+                        if( AlarmManager.RTC_WAKEUP== type ) newType = AlarmManager.RTC;
+                        if( AlarmManager.ELAPSED_REALTIME_WAKEUP== type ) newType = AlarmManager.ELAPSED_REALTIME;
+                    }
+                }
+            }
+        }
+
+        Alarm a = new Alarm(newType, when, whenElapsed, windowLength, maxWhen, interval,
                 operation, workSource, flags, alarmClock, uid);
         removeLocked(operation);
         setImplLocked(a, false, doValidate);
diff --git a/base/services/core/java/com/android/server/ConnectivityService.java b/base/services/core/java/com/android/server/ConnectivityService.java
index 219fa61..75f5c15 100644
--- a/base/services/core/java/com/android/server/ConnectivityService.java
+++ b/base/services/core/java/com/android/server/ConnectivityService.java
@@ -2157,11 +2157,7 @@ public class ConnectivityService extends IConnectivityManager.Stub
                 if (VDBG) log("NetworkAgent connected");
                 // A network agent has requested a connection.  Establish the connection.
                 mNetworkAgentInfos.get(msg.replyTo).asyncChannel.
-                    sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
-                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
-                //added by oujiangping@dvt.dvt.com 22716
-                setNetLed(nai.networkInfo, true);
-                //added end
+                        sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
             } else {
                 loge("Error connecting NetworkAgent");
                 NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
@@ -2247,19 +2243,6 @@ public class ConnectivityService extends IConnectivityManager.Stub
             synchronized (mNetworkForNetId) {
                 mNetIdInUse.delete(nai.network.netId);
             }
-
-            //added by oujiangping@dvt.dvt.com 22716
-            NetworkInfo mInfos[] = getAllNetworkInfo();
-            boolean disable_net_led = true;
-            for(int i = 0; i < mInfos.length; i++) {
-                if(mInfos[i] != null && mInfos[i].isConnected()) { 
-                    disable_net_led = false;
-                }
-            }
-            if(disable_net_led) {
-                setNetLed(nai.networkInfo, false);
-            }
-            //added end
         } else {
             NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
             if (DBG && nfi != null) log("unregisterNetworkFactory for " + nfi.name);
@@ -4916,30 +4899,4 @@ public class ConnectivityService extends IConnectivityManager.Stub
         return new NetworkMonitor(context, handler, nai, defaultRequest);
     }
 
-    //added by oujiangping@dvt.dvt.com 22716
-    private void setNetLed(NetworkInfo info, boolean open) {
-        if(info == null) {
-            loge("setNetLed info is null");
-            return;
-        }
-        int netType = info.getType();
-        if((netType != ConnectivityManager.TYPE_WIFI) 
-                && (netType != ConnectivityManager.TYPE_ETHERNET) 
-                /*&& (netType != ConnectivityManager.TYPE_PPPOE)*/) {
-            loge("setNetLed netype " + netType + " is not wifi/eth");
-            return;
-                }
-        enforceAccessPermission();
-        log("ojp, setnetled " + open);
-        String buf = open ? "on" : "off";
-        try {
-            final String prefix = "/proc/ledlight/netled/state";
-            FileUtils.stringToFile(prefix, buf);
-        } catch (Exception e) {
-            loge("ojp, Can't set net led:" + e);
-            e.printStackTrace();
-        }
-    }
-    //added end
-
 }
diff --git a/base/services/core/java/com/android/server/audio/AudioService.java b/base/services/core/java/com/android/server/audio/AudioService.java
index 56ad1db..4e71fd7 100644
--- a/base/services/core/java/com/android/server/audio/AudioService.java
+++ b/base/services/core/java/com/android/server/audio/AudioService.java
@@ -171,6 +171,7 @@ public class AudioService extends IAudioService.Stub {
 
     private Object mTvControlManager;
     private boolean mSupportTvAudio;
+    private boolean mIsTvProduct;
 
     // the platform type affects volume and silent mode behavior
     private final int mPlatformType;
@@ -695,6 +696,7 @@ public class AudioService extends IAudioService.Stub {
                 0, 0, null, 0);
 
         if (isPlatformTelevision()) {
+            mIsTvProduct = SystemProperties.getBoolean("ro.platform.has.tvuimode", false);
             mSupportTvAudio = SystemProperties.getBoolean("ro.product.support.tvaudio", false);
             if (mSupportTvAudio) {
                 try {
@@ -5142,7 +5144,9 @@ public class AudioService extends IAudioService.Stub {
                 // Television devices without CEC service apply software volume on HDMI output
                 if (isPlatformTelevision() && ((device & AudioSystem.DEVICE_OUT_HDMI) != 0)) {
                     mFixedVolumeDevices |= AudioSystem.DEVICE_OUT_HDMI;
-                    checkAllFixedVolumeDevices();
+                    if (mIsTvProduct) {
+                        checkAllFixedVolumeDevices();
+                    }
                     if (mHdmiManager != null) {
                         synchronized (mHdmiManager) {
                             if (mHdmiPlaybackClient != null) {
@@ -5790,7 +5794,9 @@ public class AudioService extends IAudioService.Stub {
                     if (isPlatformTelevision() && !mHdmiCecSink) {
                         mFixedVolumeDevices &= ~AudioSystem.DEVICE_OUT_HDMI;
                     }
-                    checkAllFixedVolumeDevices();
+                    if (mIsTvProduct) {
+                        checkAllFixedVolumeDevices();
+                    }
 
                     // Television devices without CEC service apply software volume on HDMI output,set device volume
                     if (isPlatformTelevision() && !mHdmiCecSink) {
diff --git a/base/services/core/java/com/android/server/connectivity/Tethering.java b/base/services/core/java/com/android/server/connectivity/Tethering.java
index 80a7e4c..c1aaf07 100644
--- a/base/services/core/java/com/android/server/connectivity/Tethering.java
+++ b/base/services/core/java/com/android/server/connectivity/Tethering.java
@@ -40,10 +40,6 @@ import android.os.Binder;
 import android.os.INetworkManagementService;
 import android.os.Looper;
 import android.os.Message;
-import android.os.PowerManager;
-//added by oujiangping@dvt.dvt.com 22716 to keep wake when ap open
-import android.os.SystemProperties;
-//added end
 import android.os.UserHandle;
 import android.telephony.TelephonyManager;
 import android.util.Log;
@@ -92,10 +88,6 @@ public class Tethering extends BaseNetworkObserver {
     private String[] mTetherableBluetoothRegexs;
     private Collection<Integer> mUpstreamIfaceTypes;
 
-    //added by oujiangping@dvt.dvt.com 22716 to keep wake when ap open
-    private PowerManager.WakeLock mShutdownLock;
-    //added end
-
     // used to synchronize public access to members
     private Object mPublicSync;
 
@@ -145,10 +137,6 @@ public class Tethering extends BaseNetworkObserver {
     private boolean mUsbTetherRequested; // true if USB tethering should be started
                                          // when RNDIS is enabled
 
-    //added by oujiangping@dvt.dvt.com 22716 to keep wake when ap open
-    private boolean mWifiTethered = false;
-    //added end
-
     public Tethering(Context context, INetworkManagementService nmService,
             INetworkStatsService statsService, Looper looper) {
         mContext = context;
@@ -178,13 +166,6 @@ public class Tethering extends BaseNetworkObserver {
         filter.addDataScheme("file");
         mContext.registerReceiver(mStateReceiver, filter);
 
-        //added by oujiangping@dvt.dvt.com 22716 to keep wake when ap open
-        filter = new IntentFilter();
-        filter.addAction(Intent.ACTION_SCREEN_ON);
-        filter.addAction(Intent.ACTION_SCREEN_OFF);
-        mContext.registerReceiver(mStateReceiver, filter);
-        //added end
-
         mDhcpRange = context.getResources().getStringArray(
                 com.android.internal.R.array.config_tether_dhcp_range);
         if ((mDhcpRange.length == 0) || (mDhcpRange.length % 2 ==1)) {
@@ -198,11 +179,6 @@ public class Tethering extends BaseNetworkObserver {
         mDefaultDnsServers = new String[2];
         mDefaultDnsServers[0] = DNS_DEFAULT_SERVER1;
         mDefaultDnsServers[1] = DNS_DEFAULT_SERVER2;
-
-        //added by oujiangping@dvt.dvt.com 22716 to keep wake when ap open
-        PowerManager powerManager = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
-        mShutdownLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
-        //added end
     }
 
     // We can't do this once in the Tethering() constructor and cache the value, because the
@@ -434,11 +410,6 @@ public class Tethering extends BaseNetworkObserver {
                 }
             }
         }
-
-        //added by oujiangping@dvt.dvt.com 22716 to keep wake when ap open
-        mWifiTethered = wifiTethered;
-        //added end
-
         Intent broadcast = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
         broadcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING |
                 Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
@@ -530,22 +501,6 @@ public class Tethering extends BaseNetworkObserver {
         }
     }
 
-    //added by oujiangping@dvt.dvt.com 22716 to keep wake when ap open
-    private void acquireShutdownLock() {
-        if (!mShutdownLock.isHeld()) {
-            Log.d(TAG, "ojp, acquireShutdownLock");
-            mShutdownLock.acquire();
-        }
-    }
-
-    private void releaseShutdownLock() {
-        if (mShutdownLock.isHeld()) {
-            Log.d(TAG, "ojp, releaseShutdownLock");
-            mShutdownLock.release();
-        }
-    }
-    //added end
-
     private class StateReceiver extends BroadcastReceiver {
         @Override
         public void onReceive(Context content, Intent intent) {
@@ -571,16 +526,7 @@ public class Tethering extends BaseNetworkObserver {
                 }
             } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
                 updateConfiguration();
-    //added by oujiangping@dvt.dvt.com 22716 to keep wake when ap open
-            } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
-                releaseShutdownLock();
-            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
-                boolean keepWakeWhenTethering = SystemProperties.getBoolean("sys.wakelock.tethering", false);
-                if (keepWakeWhenTethering && mWifiTethered) {
-                    acquireShutdownLock();
-                }
             }
-    //added end
         }
     }
 
diff --git a/base/services/core/java/com/android/server/display/LocalDisplayAdapter.java b/base/services/core/java/com/android/server/display/LocalDisplayAdapter.java
index 088d96e..5b6730e 100644
--- a/base/services/core/java/com/android/server/display/LocalDisplayAdapter.java
+++ b/base/services/core/java/com/android/server/display/LocalDisplayAdapter.java
@@ -610,9 +610,13 @@ final class LocalDisplayAdapter extends DisplayAdapter {
      */
     private static final class DisplayModeRecord {
         public final Display.Mode mMode;
+        public final float mXDpi;
+        public final float mYDpi;
 
         public DisplayModeRecord(SurfaceControl.PhysicalDisplayInfo phys) {
             mMode = createMode(phys.width, phys.height, phys.refreshRate);
+            mXDpi = phys.xDpi;
+            mYDpi = phys.yDpi;
         }
 
         /**
@@ -627,11 +631,13 @@ final class LocalDisplayAdapter extends DisplayAdapter {
             int displayInfoRefreshRate = Float.floatToIntBits(info.refreshRate);
             return mMode.getPhysicalWidth() == info.width
                     && mMode.getPhysicalHeight() == info.height
-                    && modeRefreshRate == displayInfoRefreshRate;
+                    && modeRefreshRate == displayInfoRefreshRate
+                    && mXDpi == info.xDpi
+                    && mYDpi == info.yDpi;
         }
 
         public String toString() {
-            return "DisplayModeRecord{mMode=" + mMode + "}";
+            return "DisplayModeRecord{mMode=" + mMode + " mXDpi=" + mXDpi + " mYDpi=" + mYDpi + "}";
         }
     }
 
diff --git a/base/services/core/java/com/android/server/display/LogicalDisplay.java b/base/services/core/java/com/android/server/display/LogicalDisplay.java
index 6dae397..3d23624 100644
--- a/base/services/core/java/com/android/server/display/LogicalDisplay.java
+++ b/base/services/core/java/com/android/server/display/LogicalDisplay.java
@@ -134,8 +134,10 @@ final class LogicalDisplay {
                 mInfo.overscanBottom = mOverrideDisplayInfo.overscanBottom;
                 mInfo.rotation = mOverrideDisplayInfo.rotation;
                 mInfo.logicalDensityDpi = mOverrideDisplayInfo.logicalDensityDpi;
-                mInfo.physicalXDpi = mOverrideDisplayInfo.physicalXDpi;
-                mInfo.physicalYDpi = mOverrideDisplayInfo.physicalYDpi;
+                // Always use physicalXDpi from mBaseDisplayInfo, which
+                // reflects the updated info after HDMI hot-plug
+                //mInfo.physicalXDpi = mOverrideDisplayInfo.physicalXDpi;
+                //mInfo.physicalYDpi = mOverrideDisplayInfo.physicalYDpi;
             }
         }
         return mInfo;
diff --git a/base/services/core/java/com/android/server/hdmi/DeviceSelectAction.java b/base/services/core/java/com/android/server/hdmi/DeviceSelectAction.java
index 615cbb9..4c8f7ef 100644
--- a/base/services/core/java/com/android/server/hdmi/DeviceSelectAction.java
+++ b/base/services/core/java/com/android/server/hdmi/DeviceSelectAction.java
@@ -176,6 +176,14 @@ final class DeviceSelectAction extends HdmiCecFeatureAction {
                 getSourceAddress(), mTarget.getPhysicalAddress()));
         invokeCallback(HdmiControlManager.RESULT_SUCCESS);
         tv().setSelectAddr(getTargetAddress());
+        if (HdmiUtils.getTypeFromAddress(mTarget.getLogicalAddress()) == HdmiDeviceInfo.DEVICE_AUDIO_SYSTEM) {
+            /*
+             * some types of ARC device did not report any status of it-self
+             * after bring out of standby state. So we need to query system
+             * audio status again
+             */
+            tv().onNewAvrAdded(mTarget);
+        }
         finish();
     }
 
diff --git a/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java b/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
index 7999321..c55173b 100644
--- a/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
+++ b/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
@@ -306,6 +306,8 @@ abstract class HdmiCecLocalDevice {
                 return handleTimerStatus(message);
             case Constants.MESSAGE_RECORD_STATUS:
                 return handleRecordStatus(message);
+            case Constants.MESSAGE_REPORT_SHORT_AUDIO_DESCRIPTOR:
+                return handleReportShortAudioDescriptor(message);
             default:
                 return false;
         }
@@ -433,6 +435,10 @@ abstract class HdmiCecLocalDevice {
         return false;
     }
 
+    protected boolean handleReportShortAudioDescriptor(HdmiCecMessage message) {
+        return false;
+    }
+
     @ServiceThreadOnly
     protected boolean handleStandby(HdmiCecMessage message) {
         assertRunOnServiceThread();
diff --git a/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java b/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
index 9e1cee4..cb45c54 100644
--- a/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
+++ b/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
@@ -60,7 +60,7 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
     HdmiCecLocalDevicePlayback(HdmiControlService service) {
         super(service, HdmiDeviceInfo.DEVICE_PLAYBACK);
 
-        mAutoTvOff = mService.readBooleanSetting(Global.HDMI_CONTROL_AUTO_DEVICE_OFF_ENABLED, false);
+        mAutoTvOff = mService.readBooleanSetting(Global.HDMI_CONTROL_AUTO_DEVICE_OFF_ENABLED, true);
         // The option is false by default. Update settings db as well to have the right
         // initial setting on UI.
         /* this setting updated will cause service die in first boot */
@@ -157,6 +157,18 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         }
     }
 
+    @ServiceThreadOnly
+    protected boolean handleStandby(HdmiCecMessage message) {
+        assertRunOnServiceThread();
+        if (!mAutoTvOff) return false;
+        if (mService.isControlEnabled() && !mService.isProhibitMode()
+                && mService.isPowerOnOrTransient()) {
+            mService.standby();
+            return true;
+        }
+        return false;
+    }
+
     @Override
     @ServiceThreadOnly
     protected void onStandby(boolean initiatedByCec, int standbyAction) {
diff --git a/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java b/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
index 77fd8bd..d4a63f3 100644
--- a/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
+++ b/base/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
@@ -72,6 +72,13 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     @ServiceThreadOnly
     private boolean mArcEstablished = false;
 
+    // Whether tv is requesting audio descriptor from ARC.
+    @ServiceThreadOnly
+    private boolean isQueryingAudioDescriptor = false;
+
+    //All audio data block about ARC. Each Short Audio Descriptor is 3-bytes long.
+    private String mArcAudioDesData = "";
+
     // Stores whether ARC feature is enabled per port. True by default for all the ARC-enabled ports.
     private final SparseBooleanArray mArcFeatureEnabled = new SparseBooleanArray();
 
@@ -141,6 +148,10 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         @Override
         public void onInputAdded(String inputId) {
             TvInputInfo tvInfo = mService.getTvInputManager().getTvInputInfo(inputId);
+            if (tvInfo == null) {
+                Slog.w(TAG, "Get TvInputInfo(null) when add cec device !!!!!");
+                return;
+            }
             HdmiDeviceInfo info = tvInfo.getHdmiDeviceInfo();
             if (info == null) return;
             addTvInput(inputId, info.getId());
@@ -239,6 +250,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         if (mService.isPowerStandby() && mStandbyHandler.handleCommand(message)) {
             return true;
         }
+        checkMessageSource(message);
         return super.onMessage(message);
     }
 
@@ -486,6 +498,55 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         }
     }
 
+    /*
+     * check if message source is a new device
+     */
+    protected boolean checkMessageSource(HdmiCecMessage message) {
+        int source = message.getSource();
+        HdmiDeviceInfo device = getCecDeviceInfo(source);
+        if (device == null) {
+            Slog.d(TAG, "found new device:" + source);
+            List<HotplugDetectionAction> hotplugActions = getActions(HotplugDetectionAction.class);
+            /* only poll devices when connected */
+            if (!hotplugActions.isEmpty()) {
+                hotplugActions.get(0).setNewDeviceComming(true);
+                // start a device discovery if get new device
+                mService.sendCecCommand(HdmiCecMessageBuilder.buildGivePhysicalAddress(mAddress, source));
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private boolean addNewDevFromActiveSource(int logicalAddress, int physicalAddress) {
+        assertRunOnServiceThread();
+        int type = HdmiUtils.getTypeFromAddress(logicalAddress);
+
+        if (updateCecSwitchInfo(logicalAddress, type, physicalAddress)) {
+            Slog.d(TAG, "pure CEC switch found:" + physicalAddress);
+            return false;
+        }
+
+        // Ignore if [Device Discovery Action] is going on.
+        if (hasAction(DeviceDiscoveryAction.class)) {
+            Slog.i(TAG, "Ignored while Device Discovery Action is in progress");
+            return false;
+        }
+
+        if (!isInDeviceList(logicalAddress, physicalAddress)) {
+            handleNewDeviceAtTheTailOfActivePath(physicalAddress);
+        }
+
+        // Add the device ahead with default information to handle <Active Source>
+        // promptly, rather than waiting till the new device action is finished.
+        HdmiDeviceInfo deviceInfo = new HdmiDeviceInfo(logicalAddress, physicalAddress, getPortId(physicalAddress), type,
+                Constants.UNKNOWN_VENDOR_ID, HdmiUtils.getDefaultDeviceName(logicalAddress));
+        addCecDevice(deviceInfo);
+        startNewDeviceAction(ActiveSource.of(logicalAddress, physicalAddress), type);
+        Slog.d(TAG, "addNewDevFromActiveSource:" + deviceInfo);
+        return true;
+    }
+
     @Override
     @ServiceThreadOnly
     protected boolean handleActiveSource(HdmiCecMessage message) {
@@ -498,8 +559,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
             if (!handleNewDeviceAtTheTailOfActivePath(physicalAddress)) {
                 mDelayedMessageBuffer.add(message);
             }
-            // start a device discovery if get new device
-            mService.sendCecCommand(HdmiCecMessageBuilder.buildGivePhysicalAddress(mAddress, logicalAddress));
+            addNewDevFromActiveSource(logicalAddress, physicalAddress);
         } else if (!isInputReady(info.getId())) {
             Slog.d(TAG, "Input not ready for device:" + logicalAddress +", buffering the command");
             mDelayedMessageBuffer.add(message);
@@ -732,6 +792,17 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
 
     @Override
     @ServiceThreadOnly
+    protected boolean handleReportShortAudioDescriptor(HdmiCecMessage message) {
+        assertRunOnServiceThread();
+        if (isQueryingAudioDescriptor) {
+            setArcStatus(true);
+            isQueryingAudioDescriptor = false;
+        }
+        return true;
+    }
+
+    @Override
+    @ServiceThreadOnly
     protected boolean handleTextViewOn(HdmiCecMessage message) {
         assertRunOnServiceThread();
         if (mService.isPowerStandbyOrTransient() && mAutoWakeup) {
@@ -887,7 +958,12 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     }
 
     boolean getSystemAudioModeSetting() {
-        return mService.readBooleanSetting(Global.HDMI_SYSTEM_AUDIO_ENABLED, false);
+        /*
+         * some types of ARC devices don't report system audio mode status
+         * during device discovery stage, so force true to enable system
+         * audio mode polling of ARC device
+         */
+        return true;
     }
 
     /**
@@ -900,6 +976,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         assertRunOnServiceThread();
 
         HdmiLogger.debug("Set Arc Status[old:%b new:%b]", mArcEstablished, enabled);
+
         boolean oldStatus = mArcEstablished;
         // 1. Enable/disable ARC circuit.
         setAudioReturnChannel(enabled);
@@ -911,6 +988,36 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     }
 
     /**
+     * This function which gets the audio parameters about ARC
+     * is invoked when start ARC.
+     */
+    private boolean questAudioDescriptor() {
+        if (!isQueryingAudioDescriptor && !mArcEstablished
+            && !hasAction(ShortAudioDescriptorAction.class)) {
+            addAndStartAction(new ShortAudioDescriptorAction(this, Constants.ADDR_AUDIO_SYSTEM));
+            isQueryingAudioDescriptor = true;
+            return true;
+        }
+        return false;
+    }
+
+    @ServiceThreadOnly
+    void setArcAudioDescriptor(String data) {
+        Slog.d(TAG, "setArcAudioDescriptor, data = " + data);
+        mArcAudioDesData = data;
+
+        if (hasAction(ShortAudioDescriptorAction.class)) {
+            removeAction(ShortAudioDescriptorAction.class);
+        }
+
+        SetArcTransmissionStateAction action = new SetArcTransmissionStateAction(this,
+            Constants.ADDR_AUDIO_SYSTEM, true);
+        addAndStartAction(action);
+
+        isQueryingAudioDescriptor = false;
+    }
+
+    /**
      * Switch hardware ARC circuit in the system.
      */
     @ServiceThreadOnly
@@ -953,9 +1060,10 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
 
     private void notifyArcStatusToAudioService(boolean enabled) {
         // Note that we don't set any name to ARC.
+        Slog.d(TAG, "mArcAudioDesData = " + mArcAudioDesData);
         mService.getAudioManager().setWiredDeviceConnectionState(
                 AudioSystem.DEVICE_OUT_HDMI_ARC,
-                enabled ? 1 : 0, "", "");
+                enabled ? 1 : 0, mArcAudioDesData, "");
     }
 
     /**
@@ -1115,6 +1223,10 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         // In case where <Initiate Arc> is started by <Request ARC Initiation>
         // need to clean up RequestArcInitiationAction.
         removeAction(RequestArcInitiationAction.class);
+
+        if (questAudioDescriptor()) {
+            return true;
+        }
         SetArcTransmissionStateAction action = new SetArcTransmissionStateAction(this,
                 message.getSource(), true);
         addAndStartAction(action);
@@ -1459,6 +1571,10 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
             Slog.d(TAG, "has same physical address with local device:" + info + ", local size:" + mDeviceInfos.size());
             return ;
         }
+        if (info.getLogicalAddress() == Constants.ADDR_UNREGISTERED) {
+            Slog.d(TAG, "ignore info with UNREGISTERED address:" + info);
+            return ;
+        }
         for (int i = 0; i < mDeviceInfos.size(); i++) {
             HdmiDeviceInfo dev = mDeviceInfos.valueAt(i);
             /* check if old dev with same phy address is exist */
@@ -1482,10 +1598,11 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
             return;
         }
         if (old == null) {
+            Slog.d(TAG, "Add:" + info);
             invokeDeviceEventListener(info, HdmiControlManager.DEVICE_EVENT_ADD_DEVICE);
         } else if (!old.equals(info)) {
-            invokeDeviceEventListener(old, HdmiControlManager.DEVICE_EVENT_REMOVE_DEVICE);
-            invokeDeviceEventListener(info, HdmiControlManager.DEVICE_EVENT_ADD_DEVICE);
+            Slog.d(TAG, "Update:" + info);
+            invokeDeviceEventListener(info, HdmiControlManager.DEVICE_EVENT_UPDATE_DEVICE);
         }
     }
 
@@ -1500,6 +1617,8 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         HdmiDeviceInfo info = removeDeviceInfo(HdmiDeviceInfo.idForCecDevice(address));
 
         mCecMessageCache.flushMessagesFrom(address);
+        if (info != null && mSelectAddr == info.getLogicalAddress())
+            mSelectAddr = Constants.ADDR_INVALID;
         invokeDeviceEventListener(info, HdmiControlManager.DEVICE_EVENT_REMOVE_DEVICE);
     }
 
diff --git a/base/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java b/base/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
index aea1d4c..ba28ded 100644
--- a/base/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
+++ b/base/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
@@ -244,6 +244,17 @@ public class HdmiCecMessageBuilder {
     }
 
     /**
+     * Build &lt;Request Short Audio Descriptor&gt;
+     *
+     * @param src source address of command
+     * @param dest destination address of command
+     * @return newly created {@link HdmiCecMessage}
+     */
+    static HdmiCecMessage buildRequestShortAudioDescriptor(int src, int dest, byte[] params) {
+        return buildCommand(src, dest, Constants.MESSAGE_REQUEST_SHORT_AUDIO_DESCRIPTOR, params);
+    }
+
+    /**
      * Build &lt;Text View On&gt; command.
      *
      * @param src source address of command
@@ -566,14 +577,7 @@ public class HdmiCecMessageBuilder {
     }
 
     /***** Please ADD new buildXXX() methods above. ******/
-    //add by wusc:get cec version
-    static HdmiCecMessage buildGetCecVersion(int src, int dest) {
-        return buildCommand(src, dest, Constants.MESSAGE_GET_CEC_VERSION);
-    }
-    //add by wusc:image view on
-    static HdmiCecMessage buildImageViewOn(int src, int dest) {
-        return buildCommand(src, dest, Constants.MESSAGE_IMAGE_VIEW_ON);
-    }
+
     /**
      * Build a {@link HdmiCecMessage} without extra parameter.
      *
diff --git a/base/services/core/java/com/android/server/hdmi/HdmiControlService.java b/base/services/core/java/com/android/server/hdmi/HdmiControlService.java
index a072ccd..cbee73a 100644
--- a/base/services/core/java/com/android/server/hdmi/HdmiControlService.java
+++ b/base/services/core/java/com/android/server/hdmi/HdmiControlService.java
@@ -303,9 +303,6 @@ public final class HdmiControlService extends SystemService {
     // Set to true if the logical address allocation is completed.
     private boolean mAddressAllocated = false;
 
-    private boolean mRemoteCEC = false;
-
-
     // Buffer for processing the incoming cec messages while allocating logical addresses.
     private final class CecMessageBuffer {
         private List<HdmiCecMessage> mBuffer = new ArrayList<>();
@@ -415,16 +412,6 @@ public final class HdmiControlService extends SystemService {
         publishBinderService(Context.HDMI_CONTROL_SERVICE, new BinderService());
 
         if (mCecController != null) {
-           /*//add by wusc to send image view on when boot up
-            try {
-                if (mHdmiControlEnabled) {
-                    Slog.i(TAG, "HDMI-CEC send image view on!!!");
-                    sendCecCommand(HdmiCecMessageBuilder.buildImageViewOn(Constants.ADDR_PLAYBACK_1,Constants.ADDR_TV));
-                }
-            } catch (Exception e) {
-                Slog.i(TAG, "HDMI-CEC send image view on Exception " );
-            }*/
-            
             // Register broadcast receiver for power state change.
             IntentFilter filter = new IntentFilter();
             filter.addAction(Intent.ACTION_SCREEN_OFF);
@@ -1205,7 +1192,7 @@ public final class HdmiControlService extends SystemService {
     private void enforceAccessPermission() {
         getContext().enforceCallingOrSelfPermission(PERMISSION, TAG);
     }
-	
+
     private final class BinderService extends IHdmiControlService.Stub {
         @Override
         public int[] getSupportedTypes() {
@@ -1536,46 +1523,7 @@ public final class HdmiControlService extends SystemService {
                 }
             });
         }
-        
-        //add by wusc:return true if tv support cec
-        @Override
-        public boolean isRemoteCEC() {
-            enforceAccessPermission();
-            runOnServiceThread(new Runnable() {
-                @Override
-                public void run() {
-		SendMessageCallback callback = new SendMessageCallback(){
-	                @Override
-	                public void onSendCompleted(int error) {
-				if(error == 0){
-					mRemoteCEC = true;
-				}else{
-					mRemoteCEC = false;
-				}
-	                }
-		};
-		sendCecCommand(HdmiCecMessageBuilder.buildGetCecVersion(Constants.ADDR_PLAYBACK_1,Constants.ADDR_TV),callback);
-                }
-            });
-            Slog.w(TAG, "mRemoteCEC:: " + mRemoteCEC);
-	   return 	mRemoteCEC;
-        }
 
-        //add by wusc:send image view on mesg
-        @Override
-        public void sendImageViewOn() {
-            enforceAccessPermission();
-            runOnServiceThread(new Runnable() {
-                @Override
-                public void run() {
-                    if (mHdmiControlEnabled) {
-                        Slog.i(TAG, "HDMI-CEC send image view on!!!");
-                        sendCecCommand(HdmiCecMessageBuilder.buildImageViewOn(Constants.ADDR_PLAYBACK_1,Constants.ADDR_TV));
-                    }
-                }
-            });
-        }
-        
         @Override
         public void sendStandby(final int deviceType, final int deviceId) {
             enforceAccessPermission();
@@ -2136,7 +2084,7 @@ public final class HdmiControlService extends SystemService {
     @ServiceThreadOnly
     private void onStandbyCompleted(int standbyAction) {
         assertRunOnServiceThread();
-        Slog.v(TAG, "onStandbyCompleted"); 
+        Slog.v(TAG, "onStandbyCompleted");
 
         if (mPowerStatus != HdmiControlManager.POWER_STATUS_TRANSIENT_TO_STANDBY) {
             return;
@@ -2147,12 +2095,7 @@ public final class HdmiControlService extends SystemService {
         }
         mStandbyMessageReceived = false;
         mAddressAllocated = false;
-        //modify by wusc:when ap standby, cec wake up from framework
-        boolean keepWakeWhenTethering = SystemProperties.getBoolean("sys.wakelock.tethering", false);
-        if(!keepWakeWhenTethering){
-            mCecController.setOption(OPTION_CEC_SERVICE_CONTROL, DISABLED); 
-        }
-	//
+        mCecController.setOption(OPTION_CEC_SERVICE_CONTROL, DISABLED);
         mMhlController.setOption(OPTION_MHL_SERVICE_CONTROL, DISABLED);
     }
 
diff --git a/base/services/core/java/com/android/server/hdmi/HotplugDetectionAction.java b/base/services/core/java/com/android/server/hdmi/HotplugDetectionAction.java
index 76ba2a4..e305458 100644
--- a/base/services/core/java/com/android/server/hdmi/HotplugDetectionAction.java
+++ b/base/services/core/java/com/android/server/hdmi/HotplugDetectionAction.java
@@ -36,9 +36,9 @@ import java.util.List;
 final class HotplugDetectionAction extends HdmiCecFeatureAction {
     private static final String TAG = "HotPlugDetectionAction";
 
-    private static final int POLLING_INTERVAL_MS = 20000;
+    private static final int POLLING_INTERVAL_MS = 50000;
     private static final int POLLING_INTERVAL_MS_QUICK = 5000;
-    private static final int POLLING_INTERVAL_MS_FILTER = 1500;
+    private static final int POLLING_INTERVAL_MS_FILTER = 5000;
     private static final int TIMEOUT_COUNT = 4;
     private static final int AVR_COUNT_MAX = 2;
 
@@ -58,6 +58,7 @@ final class HotplugDetectionAction extends HdmiCecFeatureAction {
     private int mAvrStatusCount = 0;
 
     private boolean mInPolling = false;
+    private boolean mNewDeviceComming = false;
 
     /**
      * Constructor
@@ -94,8 +95,8 @@ final class HotplugDetectionAction extends HdmiCecFeatureAction {
         }
 
         if (mState == STATE_WAIT_FOR_NEXT_POLLING) {
-            mTimeoutCount = (mTimeoutCount + 1) % TIMEOUT_COUNT;
             pollDevices();
+            mTimeoutCount = (mTimeoutCount + 1) % TIMEOUT_COUNT;
         }
     }
 
@@ -107,15 +108,23 @@ final class HotplugDetectionAction extends HdmiCecFeatureAction {
         mActionTimer.clearTimerMessage();
 
         mTimeoutCount = 0;
+        mNewDeviceComming = false;
         mState = STATE_WAIT_FOR_NEXT_POLLING;
 
         addTimer(mState, POLLING_INTERVAL_MS_FILTER);
     }
 
+    void setNewDeviceComming(boolean come) {
+        mNewDeviceComming = come;
+        Slog.d(TAG, "New device comming:" + mNewDeviceComming);
+    }
+
     // This method is called every 5 seconds.
     private void pollDevices() {
-        // quickly poll 2 times then slow down
-        if (mTimeoutCount < AVR_COUNT_MAX) {
+        /*
+         * don't poll device if newDevice is found during FILTER time
+         */
+        if (mTimeoutCount < AVR_COUNT_MAX && !mNewDeviceComming) {
             pollAllDevices();
             addTimer(mState, POLLING_INTERVAL_MS_QUICK);
             return;
diff --git a/base/services/core/java/com/android/server/hdmi/NewDeviceAction.java b/base/services/core/java/com/android/server/hdmi/NewDeviceAction.java
index 6753368..5f6f03f 100644
--- a/base/services/core/java/com/android/server/hdmi/NewDeviceAction.java
+++ b/base/services/core/java/com/android/server/hdmi/NewDeviceAction.java
@@ -20,6 +20,7 @@ import android.util.Slog;
 
 import com.android.server.hdmi.HdmiCecLocalDevice.ActiveSource;
 import java.io.UnsupportedEncodingException;
+import android.hardware.hdmi.HdmiControlManager;
 
 /**
  * Feature action that discovers the information of a newly found logical device.
@@ -41,9 +42,13 @@ final class NewDeviceAction extends HdmiCecFeatureAction {
     // that contains the name of the device for display on screen.
     static final int STATE_WAITING_FOR_SET_OSD_NAME = 1;
 
+    // State in which the action sent <Give Device Power Status> and is waiting for
+    // <Report Power Status> that contains the power status of the device.
+    static final int STATE_WAITING_FOR_POWER_STATUS = 2;
+
     // State in which the action sent <Give Device Vendor ID> and is waiting for
     // <Device Vendor ID> that contains the vendor ID of the device.
-    static final int STATE_WAITING_FOR_DEVICE_VENDOR_ID = 2;
+    static final int STATE_WAITING_FOR_DEVICE_VENDOR_ID = 3;
 
     private final int mDeviceLogicalAddress;
     private final int mDevicePhysicalAddress;
@@ -52,6 +57,7 @@ final class NewDeviceAction extends HdmiCecFeatureAction {
     private int mVendorId;
     private String mDisplayName;
     private int mTimeoutRetry;
+    private int mPowerStatus;
 
     /**
      * Constructor.
@@ -68,6 +74,7 @@ final class NewDeviceAction extends HdmiCecFeatureAction {
         mDevicePhysicalAddress = devicePhysicalAddress;
         mDeviceType = deviceType;
         mVendorId = Constants.UNKNOWN_VENDOR_ID;
+        mPowerStatus = HdmiControlManager.POWER_STATUS_UNKNOWN;
     }
 
     @Override
@@ -111,11 +118,35 @@ final class NewDeviceAction extends HdmiCecFeatureAction {
                 } catch (UnsupportedEncodingException e) {
                     Slog.e(TAG, "Failed to get OSD name: " + e.getMessage());
                 }
-                requestVendorId(true);
+                requestPowerStatus(true);
                 return true;
             } else if (opcode == Constants.MESSAGE_FEATURE_ABORT) {
                 int requestOpcode = params[0] & 0xFF;
                 if (requestOpcode == Constants.MESSAGE_GIVE_OSD_NAME) {
+                    requestPowerStatus(true);
+                    return true;
+                }
+            }
+        } else if (mState == STATE_WAITING_FOR_POWER_STATUS) {
+            if (opcode == Constants.MESSAGE_REPORT_POWER_STATUS) {
+                int sourceAddress = cmd.getSource();
+                int newStatus = cmd.getParams()[0] & 0xFF;
+                if (sourceAddress != mDeviceLogicalAddress) {
+                    Slog.d(TAG, "ignore power status:" + sourceAddress);
+                    return false;
+                }
+                mPowerStatus = newStatus;
+                Slog.d(TAG, "power status:" + mPowerStatus);
+                requestVendorId(true);
+                return true;
+            } else if (opcode == Constants.MESSAGE_FEATURE_ABORT) {
+                int requestOpcode = params[0] & 0xFF;
+                int sourceAddress = cmd.getSource();
+                if (sourceAddress != mDeviceLogicalAddress) {
+                    Slog.d(TAG, "ignore power status abort:" + sourceAddress);
+                    return false;
+                }
+                if (requestOpcode == Constants.MESSAGE_REPORT_POWER_STATUS) {
                     requestVendorId(true);
                     return true;
                 }
@@ -146,6 +177,22 @@ final class NewDeviceAction extends HdmiCecFeatureAction {
         return false;
     }
 
+    private void requestPowerStatus(boolean firstTry) {
+        if (firstTry) {
+            mTimeoutRetry = 0;
+        }
+        // At first, transit to waiting status for <Give Device Power Status>.
+        mState = STATE_WAITING_FOR_POWER_STATUS;
+        // If the message is already in cache, process it.
+        if (mayProcessCommandIfCached(mDeviceLogicalAddress,
+                Constants.MESSAGE_REPORT_POWER_STATUS)) {
+            return;
+        }
+        sendCommand(HdmiCecMessageBuilder.buildGiveDevicePowerStatus(getSourceAddress(),
+                mDeviceLogicalAddress));
+        addTimer(mState, HdmiConfig.TIMEOUT_MS);
+    }
+
     private void requestVendorId(boolean firstTry) {
         if (firstTry) {
             mTimeoutRetry = 0;
@@ -175,14 +222,15 @@ final class NewDeviceAction extends HdmiCecFeatureAction {
         HdmiDeviceInfo deviceInfo = new HdmiDeviceInfo(
                 mDeviceLogicalAddress, mDevicePhysicalAddress,
                 tv().getPortId(mDevicePhysicalAddress),
-                mDeviceType, mVendorId, mDisplayName);
+                mDeviceType, mVendorId, mDisplayName, mPowerStatus);
         tv().addCecDevice(deviceInfo);
 
         // Consume CEC messages we already got for this newly found device.
         tv().processDelayedMessages(mDeviceLogicalAddress);
 
         if (HdmiUtils.getTypeFromAddress(mDeviceLogicalAddress)
-                == HdmiDeviceInfo.DEVICE_AUDIO_SYSTEM) {
+                == HdmiDeviceInfo.DEVICE_AUDIO_SYSTEM &&
+            mPowerStatus == HdmiControlManager.POWER_STATUS_ON) {
             tv().onNewAvrAdded(deviceInfo);
         }
     }
@@ -197,7 +245,13 @@ final class NewDeviceAction extends HdmiCecFeatureAction {
                 requestOsdName(false);
                 return;
             }
-            // Osd name request timed out. Try vendor id
+            // Osd name request timed out. Try power status
+            requestPowerStatus(true);
+        } else if (state == STATE_WAITING_FOR_POWER_STATUS) {
+            if (++mTimeoutRetry < HdmiConfig.TIMEOUT_RETRY) {
+                requestPowerStatus(false);
+                return;
+            }
             requestVendorId(true);
         } else if (state == STATE_WAITING_FOR_DEVICE_VENDOR_ID) {
             if (++mTimeoutRetry < HdmiConfig.TIMEOUT_RETRY) {
diff --git a/base/services/core/java/com/android/server/hdmi/ShortAudioDescriptorAction.java b/base/services/core/java/com/android/server/hdmi/ShortAudioDescriptorAction.java
new file mode 100644
index 0000000..6a3024b
--- /dev/null
+++ b/base/services/core/java/com/android/server/hdmi/ShortAudioDescriptorAction.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.hdmi;
+
+import android.hardware.hdmi.HdmiDeviceInfo;
+import android.util.Slog;
+
+/**
+ * Base feature action class for &lt;Request ARC Initiation&gt;/&lt;Request ARC Termination&gt;.
+ */
+class ShortAudioDescriptorAction extends HdmiCecFeatureAction {
+    private static final String TAG = "ShortAudioDescriptorAction";
+
+    // according CEA-861-D
+    private static final int AUDIO_FORMAT_RESERVED = 0;
+    private static final int AUDIO_FORMAT_LINEAR_PCM = 1;
+    private static final int AUDIO_FORMAT_AC_3 = 2;
+    private static final int AUDIO_FORMAT_MPEG1 = 3;
+    private static final int AUDIO_FORMAT_MP3 = 4;
+    private static final int AUDIO_FORMAT_MPEG2 = 5;
+    private static final int AUDIO_FORMAT_AAC = 6;
+    private static final int AUDIO_FORMAT_DTS = 7;
+    private static final int AUDIO_FORMAT_ATRAC = 8;
+    private static final int AUDIO_FORMAT_ONE_BIT_AUDIO = 9;
+    private static final int AUDIO_FORMAT_DOLBY_DIGITAL_PLUS = 10;
+    private static final int AUDIO_FORMAT_DTS_HD = 11;
+    private static final int AUDIO_FORMAT_MAT = 12;
+    private static final int AUDIO_FORMAT_DST = 13;
+    private static final int AUDIO_FORMAT_WMA_PRO = 14;
+    private static final int AUDIO_FORMAT_RESERVED1 = 15;
+
+    // State in which waits for ARC response.
+    private static final int STATE_WAITING_REPORT = 1;
+
+    private int mFormatStart;
+
+    // Logical address of AV Receiver.
+    private final int mDevAddr;
+    private int mState = 0;
+
+    private String mAudioDataBlock;
+
+    /**
+     * @Constructor
+     *
+     * @param source {@link HdmiCecLocalDevice} instance
+     * @param devAddr address of AV receiver. It should be AUDIO_SYSTEM type
+     * @throw IllegalArugmentException if device type of sourceAddress and devAddr
+     *                      is invalid
+     */
+    ShortAudioDescriptorAction(HdmiCecLocalDevice source, int devAddr) {
+        super(source);
+        HdmiUtils.verifyAddressType(getSourceAddress(), HdmiDeviceInfo.DEVICE_TV);
+        HdmiUtils.verifyAddressType(devAddr, HdmiDeviceInfo.DEVICE_AUDIO_SYSTEM);
+        mDevAddr = devAddr;
+        Slog.d(TAG, "devAddr:" + devAddr);
+    }
+
+    @Override
+    boolean start() {
+        mState = STATE_WAITING_REPORT;
+        mFormatStart = AUDIO_FORMAT_LINEAR_PCM;
+        mAudioDataBlock = "";
+        SendAudioDescriptorQueryMsg();
+        return true;
+    }
+
+    private boolean SendAudioDescriptorQueryMsg() {
+        byte[] params;
+        if (mFormatStart < AUDIO_FORMAT_RESERVED1) {
+            params = new byte[] {(byte)((mFormatStart) & 0xFF)};
+            mFormatStart += 1;
+        } else {
+            exitAction();
+            return true;
+        }
+
+        mActionTimer.clearTimerMessage();
+        mState = STATE_WAITING_REPORT;
+        addTimer(mState, HdmiConfig.TIMEOUT_MS);
+
+        HdmiCecMessage command = HdmiCecMessageBuilder.
+                                    buildRequestShortAudioDescriptor(getSourceAddress(),
+                                        mDevAddr, params);
+        sendCommand(command, new HdmiControlService.SendMessageCallback() {
+            @Override
+            public void onSendCompleted(int error) {
+                if (error != Constants.SEND_RESULT_SUCCESS) {
+                    Slog.e(TAG, "Failed to send RequestShortAudioDescriptor, error=" + error);
+                    finish();
+                }
+            }
+        });
+        return true;
+    }
+
+    private void exitAction() {
+        tv().setArcAudioDescriptor(mAudioDataBlock);
+    }
+
+    @Override
+    boolean processCommand(HdmiCecMessage cmd) {
+        if (mState != STATE_WAITING_REPORT) {
+            return false;
+        }
+        int opcode = cmd.getOpcode();
+        int nextCode = 0;
+        switch (opcode) {
+            case Constants.MESSAGE_FEATURE_ABORT:
+                int originalOpcode = cmd.getParams()[0] & 0xFF;;
+                if (originalOpcode == Constants.MESSAGE_REQUEST_SHORT_AUDIO_DESCRIPTOR) {
+                    Slog.d(TAG, "Feature aborted for <ShortAudioDescriptorAction>");
+                    return SendAudioDescriptorQueryMsg();
+                }
+                break;
+            case Constants.MESSAGE_REPORT_SHORT_AUDIO_DESCRIPTOR:
+                byte params[] = cmd.getParams();
+                for (byte param : params) {
+                    mAudioDataBlock += "" + String.format("%02x", param & 0xFF);
+                }
+                Slog.d(TAG, "mAudioDataBlock = " + mAudioDataBlock);
+                return SendAudioDescriptorQueryMsg();
+        }
+        return false;
+    }
+
+    @Override
+    final void handleTimerEvent(int state) {
+        if (mState != state || mState != STATE_WAITING_REPORT) {
+            return;
+        }
+        Slog.d(TAG, "end query");
+        finish();
+    }
+}
diff --git a/base/services/core/java/com/android/server/hdmi/SystemAudioAction.java b/base/services/core/java/com/android/server/hdmi/SystemAudioAction.java
index a209cd0..2c00192 100644
--- a/base/services/core/java/com/android/server/hdmi/SystemAudioAction.java
+++ b/base/services/core/java/com/android/server/hdmi/SystemAudioAction.java
@@ -113,12 +113,18 @@ abstract class SystemAudioAction extends HdmiCecFeatureAction {
         // 1) physical address of the active source
         // 2) active routing path
         // 3) physical address of TV
+        if (tv().getActivePath() == tv().getAvrDeviceInfo().getPhysicalAddress()) {
+            /*
+             * current ARC device is active soure, we should use self-physical address
+             */
+            return localDevice().getService().getPhysicalAddress();
+        }
         if (tv().getActiveSource().isValid()) {
             return tv().getActiveSource().physicalAddress;
         }
         int param = tv().getActivePath();
         return param != Constants.INVALID_PHYSICAL_ADDRESS
-                ? param : Constants.PATH_INTERNAL;
+                ? param : localDevice().getService().getPhysicalAddress();
     }
 
     private void handleSendSystemAudioModeRequestTimeout() {
diff --git a/base/services/core/java/com/android/server/policy/AutoStandby.java b/base/services/core/java/com/android/server/policy/AutoStandby.java
deleted file mode 100755
index d7d5d9e..0000000
--- a/base/services/core/java/com/android/server/policy/AutoStandby.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * @copyright Copyright (C) 2016 北京数码视讯软件技术发展有限公司
- */
-package com.android.server.policy;
-
-import java.io.File;
-import java.util.List;
-
-import android.app.AlertDialog;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.DialogInterface.OnClickListener;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.database.ContentObserver;
-import android.net.Uri;
-import android.os.CountDownTimer;
-import android.os.Handler;
-import android.os.PowerManager;
-import android.os.SystemClock;
-import android.os.SystemProperties;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.WindowManager;
-import com.android.internal.R;
-
-/**
- * @author Luozex
- * 
- *         2016-08-12 15:42
- */
-class AutoStandby {
-
-	private static final String TAG = "AutoStandby";
-
-	private final static long COUNT_DOWN_TIP_TIME = 30;
-	private final static long DEFAULT_AUTOSTANDBY_TIME = 3600 * 4;
-	private final static long HDMI_OFF_AUTOSTANDBY_TIME = 60 * 5;
-
-	private static final String AUTO_STANDBY_ENABLE = "auto_standby_enable";
-	private static final String AUTO_STANDBY_TIME = "auto_standby_time";
-    private static final String AUTO_STANDBY_TV_SUSPEND_ENABLE = "auto_standby_tv_suspend_enable";
-    private static final String FACTORY_DIR = "/cache/.bin";
-    private static final String PROPERTY_STANDBY = "vender.standby.open";
-
-	private Context context;
-	private Handler handler;
-	private boolean hdmiPluged = false;
-
-	public AlertDialog mShutDownDialog = null;
-	public Runnable shutdownRunnbale;
-	
-	public AutoStandby(Context context, Handler mHandler) {
-		Log.i(TAG, " AutoStandy() construct!");
-		this.context = context;
-		this.handler = mHandler;
-		
-		shutdownRunnbale = new Runnable() {
-			@Override
-			public void run() {
-				if (hdmiPluged) {
-					showShutDownDialog();
-				} else {
-					shutdown();
-				}
-			}
-		};
-		registerContentObserver();
-	}
-	
-	private void registerContentObserver() {
-		Log.i(TAG, "registerContentObserver");
-		Uri enableUri = Settings.Global.getUriFor(AUTO_STANDBY_ENABLE);
-		Uri timeUri = Settings.Global.getUriFor(AUTO_STANDBY_TIME);
-		ContentResolver resolver = context.getContentResolver();
-		ContentObserver observer = new AutoStandbyContentObserver(handler);
-		resolver.registerContentObserver(enableUri, false, observer);
-		resolver.registerContentObserver(timeUri, false, observer);
-	}
-	
-	private boolean isFactoryMode() {
-		File sumaFactoryTestDir = new File(FACTORY_DIR);
-        boolean result = (sumaFactoryTestDir.exists()) && (sumaFactoryTestDir.isDirectory());
-        Log.i(TAG, "isFactoryMode::" + result);
-        return result;
-	}
-	
-	private boolean isAutoStandbyOpen() {
-		if (!SystemProperties.getBoolean(PROPERTY_STANDBY, false)) return false;
-		
-		if (isFactoryMode()) return false;
-		
-		if (!hdmiPluged) {
-			boolean result = Settings.Global.getInt(context.getContentResolver(), AUTO_STANDBY_TV_SUSPEND_ENABLE, 1) == 1;
-			Log.i(TAG, "isAutoStandbyOpenWhenTvSuspend::" + result);
-			return result;
-		}
-		
-		boolean result =  Settings.Global.getInt(context.getContentResolver(), AUTO_STANDBY_ENABLE, 0) == 1;
-		Log.i(TAG, "isAutoStandbyOpen::" + result);
-		
-		if (!result) {
-			handler.removeCallbacks(shutdownRunnbale);
-		}
-		return result;
-	}
-	
-	private long getAutoStandbyTime() {
-		return Settings.Global.getLong(context.getContentResolver(), 
-				AUTO_STANDBY_TIME, DEFAULT_AUTOSTANDBY_TIME);
-	}
-	
-	public void onKeyPress() {
-		if (!isAutoStandbyOpen()) return;
-		Log.i(TAG, "hdmiPluged::" + hdmiPluged);
-		
-		if (hdmiPluged) {
-			reset(getAutoStandbyTime());
-		}
-	}
-	
-	public void onHdmiStateChange(boolean plug) {
-		this.hdmiPluged = plug;
-		Log.i(TAG, "hdmiPluged::" + hdmiPluged);
-
-		if (!isAutoStandbyOpen()) return;
-
-		if (hdmiPluged) {
-			reset(getAutoStandbyTime());
-		} else {
-			reset(HDMI_OFF_AUTOSTANDBY_TIME);
-		}
-	}
-	
-	public void onTVSuspendChange(boolean suspend) {
-		Log.i(TAG, "onTVSuspendChange::" + suspend);
-		onHdmiStateChange(!suspend);
-	}
-
-	private void reset(long time) {
-		if (mShutDownDialog != null) {
-			Log.i(TAG, "ShutDown Dialog is showing...");
-			return;
-		}
-		
-		Log.i(TAG, "reset::time=" + time);
-		if (time <= 0) {
-			Log.i(TAG, "rest::time error!!");
-			return;
-		}
-		handler.removeCallbacks(shutdownRunnbale);
-		handler.postDelayed(shutdownRunnbale, time * 1000);
-	}
-	
-	private void dismissDialog() {
-		if (mShutDownDialog != null) {
-			mShutDownDialog.dismiss();
-			mShutDownDialog = null;
-		}
-	}
-
-	private void showShutDownDialog() {
-		Log.i(TAG, "showShutDownDialog");
-		
-        AlertDialog.Builder builder = new AlertDialog.Builder(context);
-        builder.setTitle(R.string.auto_standby_title);
-    	String msg = context.getString(R.string.auto_standby_message, COUNT_DOWN_TIP_TIME);
-    	builder.setMessage(msg); 
-
-        final CountDownTimer mCounttimer = new CountDownTimer(COUNT_DOWN_TIP_TIME*1000, 1000) {
-            @Override  
-            public void onTick(long millisUntilFinished) {
-            	String msg = context.getString(R.string.auto_standby_message, millisUntilFinished/1000);
-            	mShutDownDialog.setMessage(msg); 
-            }
-        
-            @Override  
-            public void onFinish() {  
-            Log.i(TAG, " onFinish()  enter!");
-                dismissDialog();
-                shutdown();
-            }  
-        };    
-
-        builder.setNegativeButton(R.string.auto_standby_go_on_watch, new OnClickListener() {
-			
-			@Override
-			public void onClick(DialogInterface dialog, int which) {
-				if (mCounttimer != null) {
-                	mCounttimer.cancel();
-                }
-				mShutDownDialog = null;
-				onKeyPress();
-				onHdmiStateChange(hdmiPluged);
-			}
-		});
-        
-        String action = SystemProperties.get("vender.standby.action", "com.sumavision.settings.standby");
-        final Intent intent = new Intent(action);
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        List<ResolveInfo> infos = context.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
-        if (!infos.isEmpty()) {
-        	builder.setPositiveButton(R.string.auto_standby_setting, new OnClickListener() {
-				
-				@Override
-				public void onClick(DialogInterface dialog, int which) {
-					Log.i(TAG, " rightbutton  enter!");
-                    if (mCounttimer != null) {
-                    	mCounttimer.cancel();
-                    }
-                    try {
-                        context.startActivity(intent);
-                    }catch(Exception e){
-                    	e.printStackTrace();
-                    	Log.i(TAG, "Start Activity failed: Action com.sumavision.settings.standby");
-                    }
-                    mShutDownDialog = null;
-                    onKeyPress();
-    				onHdmiStateChange(hdmiPluged);
-				}
-			});
-        }
-        
-        builder.setCancelable(false);  
-        mShutDownDialog = builder.create();
-        mShutDownDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
-        mShutDownDialog.show();
-        mCounttimer.start();
-    }
-
-	private void shutdown() {
-		((PowerManager) context.getSystemService(Context.POWER_SERVICE)).goToSleep(SystemClock.uptimeMillis());
-	}
-	
-	class AutoStandbyContentObserver extends ContentObserver {
-
-		public AutoStandbyContentObserver(Handler handler) {
-			super(handler);
-		}
-		
-		@Override
-		public void onChange(boolean selfChange, Uri uri) {
-			super.onChange(selfChange, uri);
-			
-			Log.i(TAG, "onChange::" + uri.toString() + ":" + selfChange);
-			onKeyPress();
-		}
-	}
-}
diff --git a/base/services/core/java/com/android/server/policy/HotkeyManager.java b/base/services/core/java/com/android/server/policy/HotkeyManager.java
deleted file mode 100755
index e079026..0000000
--- a/base/services/core/java/com/android/server/policy/HotkeyManager.java
+++ /dev/null
@@ -1,288 +0,0 @@
-package com.android.server.policy;
-
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-
-import android.app.ActivityManager;
-import android.app.ActivityManager.RunningTaskInfo;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.text.TextUtils;
-import android.util.Log;
-import android.util.SparseArray;
-import android.util.Xml;
-import android.view.KeyEvent;
-
-class HotkeyManager {
-	
-	private static final String TAG = "HotkeyManager";
-
-	public static final String HOTKEY_FILE 		= "/etc/hotkey.xml";
-	public static final String XML_HOTKEY 		= "hotkey";
-	public static final String XML_KEYCODE 		= "keycode";
-	public static final String XML_KEYACTION 	= "keyAction";
-	public static final String XML_TYPE 		= "type";
-	public static final String XML_PACKAGE 		= "package";
-	public static final String XML_COMPONENT 	= "component";
-	public static final String XML_ACTION	 	= "action";
-	public static final String XML_PARAMS 		= "params";
-	public static final String XML_PARAM 		= "param";
-	public static final String XML_KEY 			= "key";
-	public static final String XML_VALUE 		= "value";
-	
-	private static HotkeyManager hotkeyManager;
-	
-	public static HotkeyManager getInstance() {
-		if (hotkeyManager == null)
-			hotkeyManager = new HotkeyManager();
-		else 
-			hotkeyManager.checkChange();
-		
-		return hotkeyManager;
-	}
-	
-	private SparseArray<HotKey> keyMap;
-	private long lastModified = -1;
-	
-	private HotkeyManager() {
-		keyMap = new SparseArray<HotKey>();
-		init();
-	}
-	
-	private void checkChange() {
-		try {
-			File file = new File(HOTKEY_FILE);
-			if (lastModified != file.lastModified()) {
-				lastModified = file.lastModified();
-				reset();
-			}
-		} catch (Exception e) {
-			Log.i(TAG, "CheckChange Failed.");
-		}
-	}
-	
-	private void init() {
-		try {
-			File file = new File(HOTKEY_FILE);
-			lastModified = file.lastModified();
-			XmlPullParser parser = Xml.newPullParser();
-			parser.setInput(new FileReader(file));
-			
-			Log.i(TAG, "Start Document");
-			
-			while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
-				if (parser.getEventType() == XmlPullParser.START_TAG 
-						&& TextUtils.equals(parser.getName(), XML_HOTKEY)) {
-					try {
-						HotKey hotKey = new HotKey();
-						hotKey.parse(parser);
-						Log.i(TAG, hotKey.toString());
-						keyMap.put(hotKey.keycode, hotKey);
-					} catch (Exception e) {
-						Log.i(TAG, "Hot Key Parse Exception");
-					}
-				}
-				parser.next();
-			}
-			Log.i(TAG, "End Document");
-		} catch (Exception e) {
-			Log.i(TAG, "Exception:" + e.getMessage());
-		}
-	}
-	
-	private void reset() {
-		keyMap.clear();
-		init();
-	}
-	
-	public class HotKey {
-		
-		public static final int TYPE_ACTIVITY 	= 0;
-		public static final int TYPE_BROADCAST 	= 1;
-		public static final int TYPE_SERVICE	= 2;
-		
-		public int keycode;
-		public int type = 0;
-		public int keyAction = 0;
-		public String packageName;
-		public String component;
-		public String action;
-		public Map<String, String> params = new HashMap<>();
-		
-		public void parse(XmlPullParser parser) throws XmlPullParserException, IOException {
-			parser.nextTag();
-			while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
-				String name = parser.getName();
-				String text = null;
-				switch (name) {
-				case XML_KEYCODE:
-					text = parser.nextText();
-					keycode = Integer.parseInt(text);
-					break;
-				case XML_TYPE:
-					text = parser.nextText();
-					type = Integer.parseInt(text);
-					break;
-				case XML_KEYACTION:
-					text = parser.nextText();
-					keyAction = Integer.parseInt(text);
-					break;
-				case XML_PACKAGE:
-					text = parser.nextText();
-					packageName = text;
-					break; 
-				case XML_COMPONENT:
-					text = parser.nextText();
-					component = text;
-					break;
-				case XML_ACTION:
-					text = parser.nextText();
-					action = text;
-					break;
-				case XML_PARAM :
-					text = parser.nextText();
-					String key = parser.getAttributeValue(null, XML_KEY);
-					String value = parser.getAttributeValue(null, XML_VALUE);
-					params.put(key, value);
-					break;
-				case XML_HOTKEY:
-					return;
-				}
-				parser.nextTag();
-			}
-		}
-		
-		public boolean onHappen(Context context) {
-			Log.i(TAG, "HotKey.onHappen :" + this);
-			try {
-				Intent intent = getIntent(context);
-				switch (type) {
-				case TYPE_ACTIVITY:
-					intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-					if (TextUtils.isEmpty(action) 
-							&& TextUtils.isEmpty(component) 
-							&& !TextUtils.isEmpty(packageName)) {
-						Intent tempIntent = context.getPackageManager().getLaunchIntentForPackage(packageName);
-						tempIntent.putExtras(intent);
-						intent = tempIntent;
-					}
-					
-					if (checkProcessForeground(context, intent.getPackage())) {
-						Log.i(TAG, "This is the top package: " + intent.getPackage() +"; and will not load it again.");
-						return false;
-					}
-					context.startActivity(intent);
-					break;
-				case TYPE_SERVICE:
-					context.startService(intent);
-					break;
-				case TYPE_BROADCAST:
-					context.sendBroadcast(intent);
-					break;
-				}
-				return true;
-			} catch (Exception e) {
-				Log.i(TAG, "HotKey.onHappen Exception:" + e.getMessage());
-			}
-			return false;
-		}
-		
-		private Intent getIntent(Context context) {
-			Intent intent = new Intent();
-			if (!TextUtils.isEmpty(packageName)) {
-				intent.setPackage(packageName);
-			} 
-			
-			if (!TextUtils.isEmpty(component)) {
-				if (component.contains("/")) {
-					String[] temp = component.split("/");
-					String tempPackage = TextUtils.isEmpty(packageName) ? temp[0] : packageName;
-					String tempCompnent = temp[1];
-					if (tempCompnent.startsWith(".")) {
-						tempCompnent = tempPackage + tempCompnent;
-					}
-					intent.setPackage(tempPackage);
-					intent.setComponent(new ComponentName(tempPackage, tempCompnent));
-				} else {
-					if (!TextUtils.isEmpty(packageName))
-						intent.setComponent(new ComponentName(packageName, component));
-				}
-			} 
-			
-			if (!TextUtils.isEmpty(action)) {
-				intent.setAction(action);
-			}
-			
-			for (String key : params.keySet()) {
-				intent.putExtra(key, params.get(key));
-			}
-			
-			return intent;
-		}
-
-		@Override
-		public String toString() {
-			StringBuilder paramBuilder = new StringBuilder();
-			for (String key: params.keySet()) {
-				if (paramBuilder.length() != 0) {
-					paramBuilder.append(", ");
-				}
-				paramBuilder.append(key).append("=").append(params.get(key));
-			}
-			String paramStr = String.format("params [%s]", paramBuilder.toString());
-			
-			return "HotKey [keycode="
-					+ keycode + ", type=" + type + ", keyAction=" + keyAction
-					+ ", packageName=" + packageName + ", component="
-					+ component + ", action=" + action + ", " + paramStr + "]";
-			
-			
-			
-		}
-	}
-	
-	public boolean onKeyEvent(Context context, KeyEvent event) {
-		HotKey hotKey = keyMap.get(event.getKeyCode());
-		if (hotKey == null) 
-			return false;
-		
-		if (hotKey.keyAction == event.getAction()) {
-			return hotKey.onHappen(context);
-		}
-		
-		return false;
-	}
-	
-    
-    private boolean checkProcessForeground(Context context, String packageName) {
-        if(packageName == null) {
-            Log.w(TAG, "checkProcessForeground, packageName is null!");
-            return false;
-        }
-        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-        List<RunningTaskInfo> list = activityManager.getRunningTasks(1);
-        if(list == null) {
-            return false;
-        }
-        for (RunningTaskInfo info : list) {
-            String topPkg = null;
-            String basePkg = null;
-            if((info != null) && (info.topActivity != null) && (info.baseActivity != null)) {
-                topPkg = info.topActivity.getPackageName();
-                basePkg = info.baseActivity.getPackageName();
-            }
-            if (packageName.equals(topPkg) && packageName.equals(basePkg)) {
-                return true;
-            }
-        }
-        return false;
-    }
-}
diff --git a/base/services/core/java/com/android/server/policy/PhoneWindowManager.java b/base/services/core/java/com/android/server/policy/PhoneWindowManager.java
index e80e196..3766df3 100644
--- a/base/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/base/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -129,12 +129,6 @@ import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.HashSet;
 import java.util.List;
-import java.io.BufferedWriter;
-import java.io.FileWriter;
-import java.io.BufferedReader;
-import java.io.FileNotFoundException;
-
-import android.text.TextUtils;
 
 import static android.view.WindowManager.LayoutParams.*;
 import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_ABSENT;
@@ -283,7 +277,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     AccessibilityManager mAccessibilityManager;
     BurnInProtectionHelper mBurnInProtectionHelper;
     AppOpsManager mAppOpsManager;
-    AutoStandby mAutoStandby;
 
     // Vibrator pattern for haptic feedback of a long press.
     long[] mLongPressVibePattern;
@@ -702,8 +695,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private UEventObserver mHDMIObserver = new UEventObserver() {
         @Override
         public void onUEvent(UEventObserver.UEvent event) {
-//            setHdmiPlugged("1".equals(event.get("SWITCH_STATE")));
-            dealWithHdmiEvent();
+            setHdmiPlugged("1".equals(event.get("SWITCH_STATE")));
         }
     };
 
@@ -1310,22 +1302,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 }
             });
         }
-
-        public void quickTurnOnTv() {
-            if (mClient == null) {
-                return;
-            }
-            Log.d(TAG, "quickTurnOnTv,sendImageViewOn to Tv!!!");
-            mClient.sendImageViewOn();
-        }
-
-	public boolean isRemoteCEC()  {
-		if (mClient == null) {
-			return false;
-		}
-		return mClient.isRemoteCEC();
-	}
-		
     }
 
     private void handleLongPressOnHome(int deviceId) {
@@ -1375,7 +1351,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
         mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
         mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
-        
+
         // Init display burn-in protection
         boolean burnInProtectionEnabled = context.getResources().getBoolean(
                 com.android.internal.R.bool.config_enableBurnInProtection);
@@ -1412,7 +1388,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
 
         mHandler = new PolicyHandler();
-        mAutoStandby = new AutoStandby(mContext, mHandler);
         mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
         mOrientationListener = new MyOrientationListener(mContext, mHandler);
         try {
@@ -1598,9 +1573,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mGlobalKeyManager = new GlobalKeyManager(mContext);
 
         // Controls rotation and the like.
-        startObserveHdmiState();
-        initHdmiState();
-		
+        initializeHdmiState();
+
         // Match current screen state.
         if (!mPowerManager.isInteractive()) {
             startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
@@ -2705,11 +2679,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed
                     + " canceled=" + canceled);
         }
-        
-        mAutoStandby.onKeyPress();
-	if (HotkeyManager.getInstance().onKeyEvent(mContext, event)) {
-		return -1;	
-	}
+
         // If we think we might have a volume down & power key chord on the way
         // but we're not sure, then tell the dispatcher to wait a little while and
         // try again later before dispatching.
@@ -2968,11 +2938,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
             return -1;
         }
-        if((keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) || (keyCode == KeyEvent.KEYCODE_VOLUME_UP)) {
-            if (dealWithCEC(event)) {
-                return -1;
-            }
-        }
+
         // Shortcuts are invoked through Search+key, so intercept those here
         // Any printing key that is chorded with Search should be consumed
         // even if no shortcut was invoked.  This prevents text from being
@@ -4826,10 +4792,43 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
             intent.putExtra(EXTRA_HDMI_PLUGGED_STATE, plugged);
             mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
-            mAutoStandby.onHdmiStateChange(plugged);
         }
     }
 
+    void initializeHdmiState() {
+        boolean plugged = false;
+        // watch for HDMI plug messages if the hdmi switch exists
+        if (new File("/sys/devices/virtual/switch/hdmi/state").exists()) {
+            mHDMIObserver.startObserving("DEVPATH=/devices/virtual/switch/hdmi");
+
+            final String filename = "/sys/class/switch/hdmi/state";
+            FileReader reader = null;
+            try {
+                reader = new FileReader(filename);
+                char[] buf = new char[15];
+                int n = reader.read(buf);
+                if (n > 1) {
+                    plugged = 0 != Integer.parseInt(new String(buf, 0, n-1));
+                }
+            } catch (IOException ex) {
+                Slog.w(TAG, "Couldn't read hdmi state from " + filename + ": " + ex);
+            } catch (NumberFormatException ex) {
+                Slog.w(TAG, "Couldn't read hdmi state from " + filename + ": " + ex);
+            } finally {
+                if (reader != null) {
+                    try {
+                        reader.close();
+                    } catch (IOException ex) {
+                    }
+                }
+            }
+        }
+        // This dance forces the code in setHdmiPlugged to run.
+        // Always do this so the sticky intent is stuck (to false) if there is no hdmi.
+        mHdmiPlugged = !plugged;
+        setHdmiPlugged(!mHdmiPlugged);
+    }
+
     final Object mScreenshotLock = new Object();
     ServiceConnection mScreenshotConnection = null;
 
@@ -4951,14 +4950,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
                 isWakeKey = false;
             }
-            //added by oujiangping@dvt.dvt.com 22716, reboot when power key
-            if(isWakeKey && event.isWakeKey() && isWakeKeyWhenScreenOff(keyCode) && "true".equals(SystemProperties.get("vender.power.reboot_when_dream", "true"))) {
-                getHdmiControl().quickTurnOnTv();//add by wusc to send image view on
-                Log.d(TAG, "ojp, press power key, reboot system!");
-                PowerManager pm = (PowerManager) mContext.getSystemService(mContext.POWER_SERVICE);
-                pm.reboot("");
-            }
-            //added end
         }
 
         // If the key would be handled globally, just return the result, don't worry about special
@@ -4980,9 +4971,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             case KeyEvent.KEYCODE_VOLUME_DOWN:
             case KeyEvent.KEYCODE_VOLUME_UP:
             case KeyEvent.KEYCODE_VOLUME_MUTE: {
-				if (dealWithCEC(event)) {
-					return 0;
-				}
                 if (mUseTvRouting) {
                     // On TVs volume keys never go to the foreground app
                     result &= ~ACTION_PASS_TO_USER;
@@ -5226,9 +5214,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (useHapticFeedback) {
             performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
         }
-        
-        //edify by wusc to fix bug:any key of cellphone can wake up mbox
-        if (isWakeKey&& event.isWakeKey()) {
+
+        if (isWakeKey) {
             wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
         }
 
@@ -5652,7 +5639,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     @Override
     public void screenTurningOn(final ScreenOnListener screenOnListener) {
         if (DEBUG_WAKEUP) Slog.i(TAG, "Screen turning on...");
-		initHdmiState();
+
         updateScreenOffSleepToken(false);
         synchronized (mLock) {
             mScreenOnEarly = true;
@@ -6187,9 +6174,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     @Override
     public void showBootMessage(final CharSequence msg, final boolean always) {
-        if (!mContext.getPackageManager().isUpgrade()) {
-            return;
-        }
         mHandler.post(new Runnable() {
             @Override public void run() {
                 if (mBootMsgDialog == null) {
@@ -7103,171 +7087,4 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             mKeyguardDelegate.dump(prefix, pw);
         }
     }
-	
-	
-	
-    private long lastKeyTime = 0;
-    private boolean dealWithCEC(KeyEvent event) {
-	if (!SystemProperties.getBoolean("config.enable.cec_audio", false)) {
-		Log.i(TAG, " config.enable.cec_audio  false"); 		
-		return false;
-	}
-	
-    	int cecSound = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.HDMI_CONTROL_ENABLED, 1);
-    	int keyCode = event.getKeyCode();
-	if (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && 
-		cecSound == 1 && getHdmiControl().isRemoteCEC()){
-            Log.i(TAG, " dealWithCEC : support....! keyevent is " +  event.toString());    		
-            String data = null;
-            if (event.getAction() == KeyEvent.ACTION_DOWN) {
-                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
-        			data = "down";
-                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
-        			data = "up";
-                }
-                if (data != null && (event.getEventTime()-lastKeyTime)<400) {
-                    return true;
-                }
-                lastKeyTime = event.getEventTime();
-            } else {
-        		data = "rls";
-                lastKeyTime = 0;
-            }
-        	
-            if (TextUtils.isEmpty(data)) {
-		return false;
-            }
-    		
-            Log.i(TAG, " dealWithCEC : data = " + data);
-            writeSysfs("/sys/class/cec/cec_key", data);
-            return true;
-    	}
-    	return false;
-    }
-	
-    private String readSysfs(String path) {		
-        if (!new File(path).exists()) {
-            Slog.e(TAG, "File not found: " + path);
-            return null; 
-        }
-
-        String str = null;
-        StringBuilder value = new StringBuilder();
-        
-        if(DEBUG)
-            Slog.i(TAG, "readSysfs path:" + path);
-        
-        FileReader fr = null;
-        BufferedReader br = null;
-        try {
-            fr = new FileReader(path);
-            br = new BufferedReader(fr);
-            try {
-                while ((str = br.readLine()) != null) {
-                    if(str != null)
-                        value.append(str);
-                };
-				fr.close();
-				br.close();
-                if(value != null)
-                    return value.toString();
-                else 
-                    return null;
-            } catch (IOException e) {
-                e.printStackTrace();
-                return null;
-            }
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-            return null;
-        }finally {
-            try {
-                if(fr != null)
-                    fr.close();
-                if(br != null)
-                    br.close();
-            }catch (IOException e) {
-            e.printStackTrace();
-            }
-        }   
-    }
-
-	
-    private boolean writeSysfs(String path, String value) {
-        if (!new File(path).exists()) {
-            Slog.e(TAG, "File not found: " + path);
-            return false; 
-        }
-
-        FileWriter fr = null;
-        BufferedWriter writer = null;
-        try {
-            fr = new FileWriter(path);
-            writer = new BufferedWriter(fr, 64);
-            try {
-                writer.write(value);
-            } finally {
-                writer.close();
-                fr.close();
-            }           
-            return true;
-                
-        } catch (IOException e) { 
-            Slog.e(TAG, "IO Exception when write: " + path, e);
-            return false;
-        }finally {
-            try {
-                if(fr != null)
-                    fr.close();
-                if(writer != null){
-                    writer.close();
-                    }
-            }catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-	
-	private  UEventObserver mRxSenseObserver = new UEventObserver() {
-        @Override
-        public void onUEvent(UEventObserver.UEvent event) {
-            Log.d(TAG, " enter mRxSenseObserver when tv suspend");
-            try{
-            	dealWithHdmiEvent();
-             }catch(Exception e){
-                 e.printStackTrace(); 
-             }
-        }
-    };
-	
-	void initHdmiState(){
-        dealWithHdmiEvent();
-    }
-	
-	void startObserveHdmiState() {
-		if (new File("/sys/devices/virtual/switch/hdmi/state").exists()) {
-            mHDMIObserver.startObserving("DEVPATH=/devices/virtual/switch/hdmi");
-		}
-
-        if(new File("/sys/class/switch/hdmi_rxsense/state").exists()){
-            mRxSenseObserver.startObserving("SWITCH_NAME=hdmi_rxsense");
-        }
-	}
-	
-	private void dealWithHdmiEvent() {
-		String rx_sense = readSysfs("/sys/class/switch/hdmi_rxsense/state");
-        String hpd_state = readSysfs("/sys/class/amhdmitx/amhdmitx0/hpd_state");
-        String hdmi_state = readSysfs("/sys/class/switch/hdmi/state");
-        
-        Log.d(TAG, String.format("rx_sense=%s; hpd_state=%s; hdmi_state=%s", rx_sense, hpd_state, hdmi_state));
-        boolean hdmiPlugged = (hdmi_state.contains("1") || hpd_state.contains("1"));
-        boolean tvSuspend = (rx_sense.contains("0"));
-        
-        setHdmiPlugged(hdmiPlugged);
-        setTVSuspend(tvSuspend);
-	}
-	
-	void setTVSuspend(boolean suspend) {
-		mAutoStandby.onTVSuspendChange(suspend);
-	}
 }
diff --git a/base/services/core/java/com/android/server/power/ShutdownThread.java b/base/services/core/java/com/android/server/power/ShutdownThread.java
index dd8648d..42f2491 100644
--- a/base/services/core/java/com/android/server/power/ShutdownThread.java
+++ b/base/services/core/java/com/android/server/power/ShutdownThread.java
@@ -525,7 +525,8 @@ public final class ShutdownThread extends Thread {
                     bluetoothOff = bluetooth == null || !bluetooth.isEnabled();
                     if (!bluetoothOff) {
                         Log.w(TAG, "Disabling Bluetooth...");
-                        bluetooth.disable(false);  // disable but don't persist new state
+                        //bluetooth.disable(false);  // disable but don't persist new state
+                        Log.w(TAG, "not disable Bluetooth for BT wakeup");
                     }
                 } catch (RemoteException ex) {
                     Log.e(TAG, "RemoteException during bluetooth shutdown", ex);
@@ -553,14 +554,14 @@ public final class ShutdownThread extends Thread {
                         status += PACKAGE_MANAGER_STOP_PERCENT;
                         sInstance.setRebootProgress(status, null);
                     }
-
                     if (!bluetoothOff) {
-                        try {
-                            bluetoothOff = !bluetooth.isEnabled();
+                     /*    try {
+                            bluetoothOff = true;//!bluetooth.isEnabled();
                         } catch (RemoteException ex) {
                             Log.e(TAG, "RemoteException during bluetooth shutdown", ex);
                             bluetoothOff = true;
-                        }
+                        } */
+                        bluetoothOff = true;
                         if (bluetoothOff) {
                             Log.i(TAG, "Bluetooth turned off.");
                         }
diff --git a/base/services/usb/java/com/android/server/usb/UsbDebuggingManager.java b/base/services/usb/java/com/android/server/usb/UsbDebuggingManager.java
index 8eeda1a..ae17fde 100644
--- a/base/services/usb/java/com/android/server/usb/UsbDebuggingManager.java
+++ b/base/services/usb/java/com/android/server/usb/UsbDebuggingManager.java
@@ -260,13 +260,6 @@ public class UsbDebuggingManager {
                     break;
 
                 case MESSAGE_ADB_CONFIRM: {
-                    if (!SystemProperties.getBoolean("vender.adb.confirm", true)) {
-                        if (mThread != null) {
-                            mThread.sendResponse("OK");
-                        }
-                        break;
-                    }
-
                     if ("trigger_restart_min_framework".equals(
                             SystemProperties.get("vold.decrypt"))) {
                         Slog.d(TAG, "Deferring adb confirmation until after vold decrypt");
diff --git a/base/wifi/java/android/net/wifi/WifiManager.java b/base/wifi/java/android/net/wifi/WifiManager.java
index 2b62c58..cf88df4 100644
--- a/base/wifi/java/android/net/wifi/WifiManager.java
+++ b/base/wifi/java/android/net/wifi/WifiManager.java
@@ -629,7 +629,6 @@ public class WifiManager {
     // per-WifiManager callback.
     private PinningNetworkCallback mNetworkCallback;
 
-    public static final String DHCP_FAIALED_ACTION = "android.net.wifi.DHCP_FAILED";
     /**
      * Create a new WifiManager instance.
      * Applications will almost always want to use
diff --git a/native/include/ui/FrameStats.h b/native/include/ui/FrameStats.h
index 5fdf94d..6bfe635 100644
--- a/native/include/ui/FrameStats.h
+++ b/native/include/ui/FrameStats.h
@@ -25,6 +25,7 @@ namespace android {
 
 class FrameStats : public LightFlattenable<FrameStats> {
 public:
+    FrameStats() : refreshPeriodNano(0) {};
 
     /*
      * Approximate refresh time, in nanoseconds.
diff --git a/native/libs/binder/Parcel.cpp b/native/libs/binder/Parcel.cpp
index 22d7ef3..4a660d1 100644
--- a/native/libs/binder/Parcel.cpp
+++ b/native/libs/binder/Parcel.cpp
@@ -1377,7 +1377,13 @@ native_handle* Parcel::readNativeHandle() const
 
     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
         h->data[i] = dup(readFileDescriptor());
-        if (h->data[i] < 0) err = BAD_VALUE;
+        if (h->data[i] < 0) {
+            for (int j = 0; j < i; j++) {
+                close(h->data[j]);
+            }
+            native_handle_delete(h);
+            return 0;
+        }
     }
     err = read(h->data + numFds, sizeof(int)*numInts);
     if (err != NO_ERROR) {
diff --git a/native/services/inputflinger/InputWindow.cpp b/native/services/inputflinger/InputWindow.cpp
index c731863..0f8b221 100755
--- a/native/services/inputflinger/InputWindow.cpp
+++ b/native/services/inputflinger/InputWindow.cpp
@@ -20,6 +20,7 @@
 #include "InputWindow.h"
 
 #include <cutils/log.h>
+#include <cutils/properties.h>
 
 #include <ui/Rect.h>
 #include <ui/Region.h>
@@ -32,6 +33,11 @@ void InputWindowInfo::addTouchableRegion(const Rect& region) {
 }
 
 bool InputWindowInfo::touchableRegionContainsPoint(int32_t x, int32_t y) const {
+    char property[PROPERTY_VALUE_MAX] = {0};
+    int len = property_get("persist.sys.app.rotation", property, NULL);
+    if ((len <= 0) || (len > 0 && strncmp(property, "middle_port", 11)))
+        return touchableRegion.contains(x, y);
+
     const Rect r(touchableRegion.getBounds());
     return touchableRegion.contains(x + r.left, y);
 }
diff --git a/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index c3e5365..c20ac37 100644
--- a/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -310,11 +310,14 @@ void HWComposer::hotplug(int disp, int connected) {
                 disp, connected);
         return;
     }
+    if (disp == HWC_DISPLAY_PRIMARY) {
+        mDisplayData[HWC_DISPLAY_PRIMARY].configs.clear();
+    }
     queryDisplayProperties(disp);
     // Do not teardown or recreate the primary display
-    if (disp != HWC_DISPLAY_PRIMARY) {
+    //if (disp != HWC_DISPLAY_PRIMARY) {
         mEventHandler.onHotplugReceived(disp, bool(connected));
-    }
+    //}
 }
 
 static float getDefaultDensity(uint32_t width, uint32_t height) {
diff --git a/native/services/surfaceflinger/Layer.cpp b/native/services/surfaceflinger/Layer.cpp
index 24483ae..f1fb629 100644
--- a/native/services/surfaceflinger/Layer.cpp
+++ b/native/services/surfaceflinger/Layer.cpp
@@ -99,6 +99,7 @@ Layer::Layer(SurfaceFlinger* flinger, const sp<Client>& client,
         mOmxVideoHandle(0),
         mOmxOverlayLayer(false),
         mOmxFrameCount(0),
+        mOmxFrameCountLock(),
 #endif
         mIsQuickBootAnimation(false)
 {
@@ -194,6 +195,100 @@ void Layer::onLayerDisplayed(const sp<const DisplayDevice>& /* hw */,
     }
 }
 
+#ifdef VIDEO_WORKLOAD_CUT_DOWN
+bool Layer::dropOmxFrame(status_t &updateResult) {
+    struct Reject : public SurfaceFlingerConsumer::BufferRejecter {
+        Layer::State& front;
+        Layer::State& current;
+        bool stickyTransformSet;
+        Reject(Layer::State& front, Layer::State& current,
+                bool stickySet)
+            : front(front), current(current),
+              stickyTransformSet(stickySet) {
+        }
+
+        virtual bool reject(const sp<GraphicBuffer>& buf,
+                const BufferItem& item) {
+            if (buf == NULL) {
+                return false;
+            }
+
+            uint32_t bufWidth  = buf->getWidth();
+            uint32_t bufHeight = buf->getHeight();
+
+            // check that we received a buffer of the right size
+            // (Take the buffer's orientation into account)
+            if (item.mTransform & Transform::ROT_90) {
+                swap(bufWidth, bufHeight);
+            }
+
+            bool isFixedSize = item.mScalingMode != NATIVE_WINDOW_SCALING_MODE_FREEZE;
+
+            if (!isFixedSize && !stickyTransformSet) {
+                if (front.active.w != bufWidth ||
+                    front.active.h != bufHeight) {
+                    // reject this buffer
+                    ALOGE("rejecting buffer: bufWidth=%d, bufHeight=%d, front.active.{w=%d, h=%d}",
+                            bufWidth, bufHeight, front.active.w, front.active.h);
+                    return true;
+                }
+            }
+
+            return false;
+        }
+    };
+
+    Reject r(mDrawingState, getCurrentState(), getProducerStickyTransform() != 0);
+
+    updateResult =
+        mSurfaceFlingerConsumer->updateAndReleaseNoTextureBuffer(&r,
+                            mFlinger->mPrimaryDispSync);
+    if (updateResult == BufferQueue::PRESENT_LATER) {
+        // Producer doesn't want buffer to be displayed yet.  Signal a
+        // layer update so we check again at the next opportunity.
+        return false;
+    } else if (updateResult == SurfaceFlingerConsumer::BUFFER_REJECTED) {
+        // If the buffer has been rejected, remove it from the shadow queue
+        // and return early
+        Mutex::Autolock lock(mQueueItemLock);
+        mQueueItems.removeAt(0);
+        android_atomic_dec(&mQueuedFrames);
+        return true;
+    } else if (updateResult != NO_ERROR || mUpdateTexImageFailed) {
+        // This can occur if something goes wrong when trying to create the
+        // EGLImage for this buffer. If this happens, the buffer has already
+        // been released, so we need to clean up the queue and bug out
+        // early.
+        {
+            Mutex::Autolock lock(mQueueItemLock);
+            mQueueItems.clear();
+            android_atomic_and(0, &mQueuedFrames);
+        }
+
+        // Once we have hit this state, the shadow queue may no longer
+        // correctly reflect the incoming BufferQueue's contents, so even if
+        // updateTexImage starts working, the only safe course of action is
+        // to continue to ignore updates.
+        mUpdateTexImageFailed = true;
+        return true;
+    }
+
+    { // Autolock scope
+        auto currentFrameNumber = mSurfaceFlingerConsumer->getFrameNumber();
+
+        Mutex::Autolock lock(mQueueItemLock);
+
+        mQueueItems.removeAt(0);
+
+        // Decrement the queued-frames count.  Signal another event if we
+        // have more frames pending.
+        if (android_atomic_dec(&mQueuedFrames) > 1) return false;
+    }
+
+    return true;
+}
+#endif
+
 void Layer::onFrameAvailable(const BufferItem& item) {
     // Add this buffer from our internal queue tracker
     { // Autolock scope
@@ -231,37 +326,38 @@ void Layer::onFrameAvailable(const BufferItem& item) {
         set_omx_pts((char*)vaddr, &mOmxVideoHandle);
         activeBuffer->unlock();
         mOmxOverlayLayer = true;
-        if (mOmxFrameCount <= 3) {
-            mOmxFrameCount++;
+        {
+            Mutex::Autolock lock(mOmxFrameCountLock);
+            if (mOmxFrameCount <= 3) android_atomic_inc(&mOmxFrameCount);
         }
 
         // this layer do not need update
-        // update and release buffer
-        //ALOGE("Stark: mQueuedFrames: %d", mQueuedFrames);
         if (mOmxFrameCount > 3) {
-            do {
-                if (mQueuedFrames > 0) {
-                    //ALOGE("Stark: update buffer, mQueuedFrames: %d", mQueuedFrames);
-                    status_t updateResult =
-                        mSurfaceFlingerConsumer->updateAndReleaseNoTextureBuffer(mFlinger->mPrimaryDispSync);
-                    if (updateResult == BufferQueue::PRESENT_LATER) {
-                        // Producer doesn't want buffer to be displayed yet.  Signal a
-                        // layer update so we check again at the next opportunity.
-                        mOmxFrameCount = 0;
-                        break;
-                    }
-                    // Remove this buffer from our internal queue tracker
-                    { // Autolock scope
-                        Mutex::Autolock lock(mQueueItemLock);
-                        mQueueItems.removeAt(0);
+            status_t updateResult;
+            if (mQueuedFrames > 0) {
+                do {
+                    updateResult = 0;
+                    if (dropOmxFrame(updateResult)) return;
+                    else if (updateResult == BufferQueue::PRESENT_LATER) {
+                        struct timespec spec;
+                        nsecs_t nextRefreshTime = mFlinger->mPrimaryDispSync.computeNextRefresh(0);
+                        spec.tv_sec  = nextRefreshTime / 1000000000;
+                        spec.tv_nsec = nextRefreshTime % 1000000000;
+                        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &spec, NULL);
+                    } else {
+                        Mutex::Autolock lock(mOmxFrameCountLock);
+                        android_atomic_and(0, &mOmxFrameCount);
                     }
-                }
-            } while (android_atomic_dec(&mQueuedFrames) > 1);
-            if (mOmxFrameCount > 3) return;
+                } while (updateResult == BufferQueue::PRESENT_LATER);
+            } else {
+                ALOGE("this should not happend, mQueuedFrames: %d!", mQueuedFrames);
+                return;
+            }
         }
     } else {
         mOmxOverlayLayer = false;
-        mOmxFrameCount = 0;
+        Mutex::Autolock lock(mOmxFrameCountLock);
+        android_atomic_and(0, &mOmxFrameCount);
     }
 
     if (!mOmxOverlayLayer && mOmxVideoHandle != 0) {
diff --git a/native/services/surfaceflinger/Layer.h b/native/services/surfaceflinger/Layer.h
index 23154fc..a3ff824 100755
--- a/native/services/surfaceflinger/Layer.h
+++ b/native/services/surfaceflinger/Layer.h
@@ -194,6 +194,8 @@ public:
 
     virtual void setSkip3d(bool skip3d);
 
+    virtual bool dropOmxFrame(status_t &updateResult);
+
 protected:
     /*
      * onDraw - draws the surface.
@@ -424,7 +426,10 @@ private:
 #ifdef VIDEO_WORKLOAD_CUT_DOWN
     int32_t mOmxVideoHandle;
     bool mOmxOverlayLayer;
-    uint32_t mOmxFrameCount;
+
+    // thread-safe
+    volatile int32_t mOmxFrameCount;
+    mutable Mutex mOmxFrameCountLock;
 #endif
     // Local copy of the queued contents of the incoming BufferQueue
     mutable Mutex mQueueItemLock;
diff --git a/native/services/surfaceflinger/SurfaceFlinger.cpp b/native/services/surfaceflinger/SurfaceFlinger.cpp
index 72f8172..0249919 100644
--- a/native/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/native/services/surfaceflinger/SurfaceFlinger.cpp
@@ -942,13 +942,18 @@ void SurfaceFlinger::onHotplugReceived(int type, bool connected) {
 
     if (uint32_t(type) < DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) {
         Mutex::Autolock _l(mStateLock);
-        if (connected) {
-            createBuiltinDisplayLocked((DisplayDevice::DisplayType)type);
+        if (uint32_t(type) != DisplayDevice::DISPLAY_PRIMARY) {
+            if (connected) {
+                createBuiltinDisplayLocked((DisplayDevice::DisplayType)type);
+            } else {
+                mCurrentState.displays.removeItem(mBuiltinDisplays[type]);
+                mBuiltinDisplays[type].clear();
+            }
+            setTransactionFlags(eDisplayTransactionNeeded);
         } else {
-            mCurrentState.displays.removeItem(mBuiltinDisplays[type]);
-            mBuiltinDisplays[type].clear();
+            // mEventThread->onHotplugReceived(DisplayDevice::DISPLAY_PRIMARY, true);
+            setTransactionFlags(eDisplayTransactionNeeded | ePrimaryHotplugTransction);
         }
-        setTransactionFlags(eDisplayTransactionNeeded);
 
         // Defer EventThread notification until SF has updated mDisplays.
     }
@@ -1480,6 +1485,11 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
      */
 
     if (transactionFlags & eDisplayTransactionNeeded) {
+        // deal Primary display hotplug
+        if (transactionFlags & ePrimaryHotplugTransction) {
+            mEventThread->onHotplugReceived(DisplayDevice::DISPLAY_PRIMARY, true);
+        }
+
         // here we take advantage of Vector's copy-on-write semantics to
         // improve performance by skipping the transaction entirely when
         // know that the lists are identical
diff --git a/native/services/surfaceflinger/SurfaceFlinger.h b/native/services/surfaceflinger/SurfaceFlinger.h
index 2bd2c84..2dbf29c 100755
--- a/native/services/surfaceflinger/SurfaceFlinger.h
+++ b/native/services/surfaceflinger/SurfaceFlinger.h
@@ -77,7 +77,8 @@ enum {
     eTraversalNeeded          = 0x02,
     eDisplayTransactionNeeded = 0x04,
     eOtherNeeded                = 0x08,
-    eTransactionMask          = 0x0f
+    ePrimaryHotplugTransction = 0x10,
+    eTransactionMask          = 0x1f
 };
 
 static  int STEREOSCOPIC_3D_FORMAT_OFF=0;
diff --git a/native/services/surfaceflinger/SurfaceFlingerConsumer.cpp b/native/services/surfaceflinger/SurfaceFlingerConsumer.cpp
index e9ec9f2..400c4f8 100644
--- a/native/services/surfaceflinger/SurfaceFlingerConsumer.cpp
+++ b/native/services/surfaceflinger/SurfaceFlingerConsumer.cpp
@@ -98,9 +98,8 @@ status_t SurfaceFlingerConsumer::updateTexImage(BufferRejecter* rejecter,
 }
 
 #ifdef VIDEO_WORKLOAD_CUT_DOWN
-status_t SurfaceFlingerConsumer::updateAndReleaseNoTextureBuffer(
-        const DispSync& dispSync,
-        uint64_t maxFrameNumber)
+status_t SurfaceFlingerConsumer::updateAndReleaseNoTextureBuffer(BufferRejecter* rejecter,
+        const DispSync& dispSync, uint64_t maxFrameNumber)
 {
     ATRACE_CALL();
     ALOGV("updateNoTextureBuffer");
@@ -132,6 +131,14 @@ status_t SurfaceFlingerConsumer::updateAndReleaseNoTextureBuffer(
         }
         return err;
     }
+    // We call the rejecter here, in case the caller has a reason to
+    // not accept this buffer.  This is used by SurfaceFlinger to
+    // reject buffers which have the wrong size
+    int buf = item.mBuf;
+    if (rejecter && rejecter->reject(mSlots[buf].mGraphicBuffer, item)) {
+        releaseBufferLocked(buf, mSlots[buf].mGraphicBuffer, EGL_NO_SYNC_KHR);
+        return BUFFER_REJECTED;
+    }
 
     // Release the previous buffer.
     err = updateAndReleaseNoTextureBufferLocked(item);
diff --git a/native/services/surfaceflinger/SurfaceFlingerConsumer.h b/native/services/surfaceflinger/SurfaceFlingerConsumer.h
index 831081d..023d662 100644
--- a/native/services/surfaceflinger/SurfaceFlingerConsumer.h
+++ b/native/services/surfaceflinger/SurfaceFlingerConsumer.h
@@ -60,8 +60,8 @@ public:
             uint64_t maxFrameNumber = 0);
 
 #ifdef VIDEO_WORKLOAD_CUT_DOWN
-    status_t updateAndReleaseNoTextureBuffer(const DispSync& dispSync,
-            uint64_t maxFrameNumber = 0);
+    status_t updateAndReleaseNoTextureBuffer(BufferRejecter* rejecter,
+            const DispSync& dispSync, uint64_t maxFrameNumber = 0);
 #endif
 
     // See GLConsumer::bindTextureImageLocked().
diff --git a/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java b/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java
index c0b299c..0b98fa8 100644
--- a/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java
+++ b/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java
@@ -50,8 +50,7 @@ import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 
-import android.content.Intent;
-import android.os.UserHandle;
+
 /**
  * Manages connectivity for an Ethernet interface.
  *
@@ -105,7 +104,7 @@ class EthernetNetworkFactory {
     private static boolean mLinkUp;
     private NetworkInfo mNetworkInfo;
     private LinkProperties mLinkProperties;
-		
+
     EthernetNetworkFactory(RemoteCallbackList<IEthernetServiceListener> listeners) {
         mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_ETHERNET, 0, NETWORK_TYPE, "");
         mLinkProperties = new LinkProperties();
@@ -130,14 +129,7 @@ class EthernetNetworkFactory {
             }
         }
     }
-	
-    private void postNotification(int event) {
-        Log.d(TAG, "postNotification, event --> event : " + event);
-        final Intent intent = new Intent(EthernetManager.ETHERNET_STATE_CHANGED_ACTION); 
-        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-        intent.putExtra(EthernetManager.EXTRA_ETHERNET_STATE, event);
-        mContext.sendStickyBroadcastAsUser(intent, UserHandle.OWNER);   
-    }
+
 
     /**
      * Updates interface state variables.
@@ -151,11 +143,6 @@ class EthernetNetworkFactory {
         if (up) {
             setInterfaceCanUp(iface);
         }
-	else
-	{
-		postNotification(19/*EthernetManager.EVENT_PHY_LINK_DOWN*/);
-	}
-	
         if (!mIface.equals(iface)) {
             Log.v(TAG, "now mIface is " + mIface + "; Interface["+iface+"] State change, now status:"+up);
             if (up) {
@@ -201,7 +188,7 @@ class EthernetNetworkFactory {
             stopTrackingInterface(iface);
         }
     }
-	
+
     private void setInterfaceCanUp(String iface) {
         Log.v(TAG, "setInterfaceCanUp "+iface);
         try {
@@ -379,7 +366,6 @@ class EthernetNetworkFactory {
                         // If DHCP timed out (as opposed to failing), the DHCP client will still be
                         // running, because in M we changed its timeout to infinite. Stop it now.
                         NetworkUtils.stopDhcp(mIface);
-						postNotification(EthernetManager.EVENT_DHCP_CONNECT_FAILED);
                         return;
                     }
                     mIfaceUp = mIface;
diff --git a/opt/net/wifi/service/java/com/android/server/wifi/SupplicantStateTracker.java b/opt/net/wifi/service/java/com/android/server/wifi/SupplicantStateTracker.java
index 1b7d91c..219140d 100644
--- a/opt/net/wifi/service/java/com/android/server/wifi/SupplicantStateTracker.java
+++ b/opt/net/wifi/service/java/com/android/server/wifi/SupplicantStateTracker.java
@@ -47,7 +47,6 @@ import java.io.PrintWriter;
 class SupplicantStateTracker extends StateMachine {
 
     private static final String TAG = "SupplicantStateTracker";
-    private static final String	 ETHERNET_NETWORKID = "networkID";
     private static boolean DBG = false;
 
     private final WifiStateMachine mWifiStateMachine;
@@ -172,7 +171,7 @@ class SupplicantStateTracker extends StateMachine {
         }
     }
 
-    private void sendSupplicantStateChangedBroadcast(SupplicantState state, boolean failedAuth, int networkID) {
+    private void sendSupplicantStateChangedBroadcast(SupplicantState state, boolean failedAuth) {
         int supplState;
         switch (state) {
             case DISCONNECTED: supplState = BatteryStats.WIFI_SUPPL_STATE_DISCONNECTED; break;
@@ -205,16 +204,6 @@ class SupplicantStateTracker extends StateMachine {
                 | Intent.FLAG_RECEIVER_REPLACE_PENDING);
         intent.putExtra(WifiManager.EXTRA_NEW_STATE, (Parcelable) state);
         if (failedAuth) {
-
-		if(networkID >= 0)
-		{
-		 WifiConfiguration wificfg = mWifiConfigStore.getWifiConfiguration(networkID);
-	   	 if (wificfg != null) {
-	   		 intent.putExtra(WifiManager.EXTRA_WIFI_CREDENTIAL_SSID, wificfg.SSID);
-	   	 }
-		 intent.putExtra(ETHERNET_NETWORKID, networkID);
-		}
-			
             intent.putExtra(
                 WifiManager.EXTRA_SUPPLICANT_ERROR,
                 WifiManager.ERROR_AUTHENTICATING);
@@ -242,9 +231,7 @@ class SupplicantStateTracker extends StateMachine {
                 case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
                     StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
                     SupplicantState state = stateChangeResult.state;
-
-                    sendSupplicantStateChangedBroadcast(state, mAuthFailureInSupplicantBroadcast, stateChangeResult.networkId);
-		   
+                    sendSupplicantStateChangedBroadcast(state, mAuthFailureInSupplicantBroadcast);
                     mAuthFailureInSupplicantBroadcast = false;
                     transitionOnSupplicantStateChange(stateChangeResult);
                     break;
@@ -354,10 +341,9 @@ class SupplicantStateTracker extends StateMachine {
                             handleNetworkConnectionFailure(stateChangeResult.networkId,
                                     WifiConfiguration.DISABLED_AUTH_FAILURE);
                         }
-						
                         mLoopDetectIndex = state.ordinal();
                         sendSupplicantStateChangedBroadcast(state,
-                                mAuthFailureInSupplicantBroadcast, stateChangeResult.networkId);
+                                mAuthFailureInSupplicantBroadcast);
                     } else {
                         //Have the DefaultState handle the transition
                         return NOT_HANDLED;
@@ -389,7 +375,7 @@ class SupplicantStateTracker extends StateMachine {
                 case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
                     StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
                     SupplicantState state = stateChangeResult.state;
-                    sendSupplicantStateChangedBroadcast(state, mAuthFailureInSupplicantBroadcast, stateChangeResult.networkId);
+                    sendSupplicantStateChangedBroadcast(state, mAuthFailureInSupplicantBroadcast);
                     /* Ignore any connecting state in completed state. Group re-keying
                      * events and other auth events that do not affect connectivity are
                      * ignored
@@ -400,7 +386,7 @@ class SupplicantStateTracker extends StateMachine {
                     transitionOnSupplicantStateChange(stateChangeResult);
                     break;
                 case WifiStateMachine.CMD_RESET_SUPPLICANT_STATE:
-                    sendSupplicantStateChangedBroadcast(SupplicantState.DISCONNECTED, false, -1);
+                    sendSupplicantStateChangedBroadcast(SupplicantState.DISCONNECTED, false);
                     transitionTo(mUninitializedState);
                     break;
                 default:
diff --git a/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigStore.java b/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigStore.java
index 1ef6fb5..25d8ece 100644
--- a/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigStore.java
+++ b/opt/net/wifi/service/java/com/android/server/wifi/WifiConfigStore.java
@@ -1780,7 +1780,7 @@ public class WifiConfigStore extends IpConfigStore {
     /**
      * Should be called when multiple network configuration changes are made.
      */
-    public void sendConfiguredNetworksChangedBroadcast() {
+    private void sendConfiguredNetworksChangedBroadcast() {
         Intent intent = new Intent(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION);
         intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
         intent.putExtra(WifiManager.EXTRA_MULTIPLE_NETWORKS_CHANGED, true);
@@ -4277,7 +4277,6 @@ public class WifiConfigStore extends IpConfigStore {
                                 loge("DHCP failure, blacklist " + config.configKey() + " "
                                         + Integer.toString(config.networkId)
                                         + " num failures " + config.numIpConfigFailures);
-								
                             }
 
                             // Also blacklist the BSSId if we find it
diff --git a/opt/net/wifi/service/java/com/android/server/wifi/WifiService.java b/opt/net/wifi/service/java/com/android/server/wifi/WifiService.java
index 70e2c1d..ae2a13b 100644
--- a/opt/net/wifi/service/java/com/android/server/wifi/WifiService.java
+++ b/opt/net/wifi/service/java/com/android/server/wifi/WifiService.java
@@ -44,6 +44,7 @@ public final class WifiService extends SystemService {
     public void onBootPhase(int phase) {
         if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
             mImpl.checkAndStartWifi();
+            mImpl.checkAndStartWifiorAP();
         }
     }
 }
diff --git a/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java b/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
index 55c6040..de7002c 100644
--- a/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
+++ b/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
@@ -400,7 +400,17 @@ public final class WifiServiceImpl extends IWifiManager.Stub {
         mWifiWatchdogStateMachine = WifiWatchdogStateMachine.
                makeWifiWatchdogStateMachine(mContext, mWifiStateMachine.getMessenger());
     }
-
+    public void checkAndStartWifiorAP() {
+        mSettingsStore.enableReadSavedStateAgain();
+        boolean wifiApEnabled = mSettingsStore.isWifiAPToggleEnabled();
+        if (wifiApEnabled) {
+            Slog.i(TAG, "WifiApService starting up with Wi-Fi(AP) " +
+                (wifiApEnabled ? "enabled" : "disabled"));
+            setWifiApEnabled(null, true);
+            mWifiWatchdogStateMachine = WifiWatchdogStateMachine.
+            makeWifiWatchdogStateMachine(mContext, mWifiStateMachine.getMessenger());
+        }
+    }
     /**
      * see {@link android.net.wifi.WifiManager#pingSupplicant()}
      * @return {@code true} if the operation succeeds, {@code false} otherwise
@@ -646,6 +656,7 @@ public final class WifiServiceImpl extends IWifiManager.Stub {
         } else {
             Slog.e(TAG, "Invalid WifiConfiguration");
         }
+        mSettingsStore.handleWifiApToggled(enabled);
     }
 
     /**
diff --git a/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStore.java b/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStore.java
index 61399c0..0674234 100644
--- a/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStore.java
+++ b/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStore.java
@@ -54,6 +54,9 @@ final class WifiSettingsStore {
         mScanAlwaysAvailable = getPersistedScanAlwaysAvailable();
     }
 
+    synchronized void enableReadSavedStateAgain() {
+        mCheckSavedStateAtBoot = false;
+    }
     synchronized boolean isWifiToggleEnabled() {
         if (!mCheckSavedStateAtBoot) {
             mCheckSavedStateAtBoot = true;
@@ -67,6 +70,19 @@ final class WifiSettingsStore {
         }
     }
 
+    synchronized boolean isWifiAPToggleEnabled() {
+        if (!mCheckSavedStateAtBoot) {
+            mCheckSavedStateAtBoot = true;
+        }
+
+        mAirplaneModeOn=isAirplaneModeOn();
+        if (mAirplaneModeOn) {
+            return getPersistedWifiApState() == WIFI_ENABLED_AIRPLANE_OVERRIDE;
+        } else {
+            return getPersistedWifiApState() != WIFI_DISABLED;
+        }
+    }
+
     /**
      * Returns true if airplane mode is currently on.
      * @return {@code true} if airplane mode is on.
@@ -100,6 +116,22 @@ final class WifiSettingsStore {
         }
         return true;
     }
+    synchronized boolean handleWifiApToggled(boolean wifiEnabled) {
+        if (wifiEnabled) {
+            if (mAirplaneModeOn) {
+                persistWifiApState(WIFI_ENABLED_AIRPLANE_OVERRIDE);
+            } else {
+                persistWifiApState(WIFI_ENABLED);
+            }
+        } else {
+            // When wifi state is disabled, we do not care
+            // if airplane mode is on or not. The scenario of
+            // wifi being disabled due to airplane mode being turned on
+            // is handled handleAirplaneModeToggled()
+            persistWifiApState(WIFI_DISABLED);
+        }
+        return true;
+    }
 
     synchronized boolean handleAirplaneModeToggled() {
         // Is Wi-Fi sensitive to airplane mode changes ?
@@ -138,6 +170,12 @@ final class WifiSettingsStore {
         Settings.Global.putInt(cr, Settings.Global.WIFI_ON, state);
     }
 
+    private void persistWifiApState(int state) {
+        final ContentResolver cr = mContext.getContentResolver();
+        mPersistWifiState = state;
+        Settings.Global.putInt(cr, Settings.Global.WIFI_AP_ON, state);
+    }
+
     /* Does Wi-Fi need to be disabled when airplane mode is on ? */
     private boolean isAirplaneSensitive() {
         String airplaneModeRadios = Settings.Global.getString(mContext.getContentResolver(),
@@ -183,6 +221,15 @@ final class WifiSettingsStore {
             return WIFI_DISABLED;
         }
     }
+    private int getPersistedWifiApState() {
+        final ContentResolver cr = mContext.getContentResolver();
+        try {
+            return Settings.Global.getInt(cr, Settings.Global.WIFI_AP_ON);
+        } catch (Settings.SettingNotFoundException e) {
+            Settings.Global.putInt(cr, Settings.Global.WIFI_AP_ON, WIFI_DISABLED);
+            return WIFI_DISABLED;
+        }
+    }
 
     private boolean getPersistedAirplaneModeOn() {
         return Settings.Global.getInt(mContext.getContentResolver(),
diff --git a/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java b/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java
index 4dcc584..1200382 100644
--- a/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java
+++ b/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java
@@ -4843,12 +4843,6 @@ public class WifiStateMachine extends StateMachine implements WifiNative.WifiPno
         mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
     }
 
-    private void sendDhcpFailedBroadcast() {
-        Intent intent = new Intent(WifiManager.DHCP_FAIALED_ACTION);
-        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
-    }
-
     /**
      * Record the detailed state of a network.
      *
@@ -5196,7 +5190,6 @@ public class WifiStateMachine extends StateMachine implements WifiNative.WifiPno
         if (PDBG) {
             logd("handleIPv4Failure");
         }
-		sendDhcpFailedBroadcast();
         updateLinkProperties(reason);
     }
 
diff --git a/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp b/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp
index 31166e3..acc02d6 100644
--- a/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp
+++ b/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp
@@ -697,15 +697,23 @@ static byte parseHexChar(char ch) {
 }
 
 static byte parseHexByte(const char * &str) {
+    if (str[0] == '\0') {
+        ALOGE("Passed an empty string");
+        return 0;
+    }
     byte b = parseHexChar(str[0]);
-    if (str[1] == ':' || str[1] == '\0') {
-        str += 2;
-        return b;
+    if (str[1] == '\0' || str[1] == ':') {
+        str ++;
     } else {
         b = b << 4 | parseHexChar(str[1]);
-        str += 3;
-        return b;
+        str += 2;
+    }
+
+    // Skip trailing delimiter if not at the end of the string.
+    if (str[0] != '\0') {
+        str++;
     }
+    return b;
 }
 
 static void parseMacAddress(const char *str, mac_addr addr) {
diff --git a/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 1635f2d..fa48d88 100644
--- a/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -101,6 +101,8 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     private static final int NITZ_UPDATE_DIFF_DEFAULT = 2000;
     private int mNitzUpdateDiff = SystemProperties.getInt("ro.nitz_update_diff",
             NITZ_UPDATE_DIFF_DEFAULT);
+    /** Time stamp after 19 January 2038 is not supported under 32 bit */
+    private static final int MAX_NITZ_YEAR = 2037;
 
     private int mRoamingIndicator;
     private boolean mIsInPrl;
@@ -1616,6 +1618,10 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             String[] nitzSubs = nitz.split("[/:,+-]");
 
             int year = 2000 + Integer.parseInt(nitzSubs[0]);
+            if (year > MAX_NITZ_YEAR) {
+              if (DBG) loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
+              return;
+            }
             c.set(Calendar.YEAR, year);
 
             // month is 0 based!
diff --git a/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 1ff2d08..53a3388 100755
--- a/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -136,6 +136,8 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
 
     /** Boolean is true is setTimeFromNITZString was called */
     private boolean mNitzUpdatedTime = false;
+    /** Time stamp after 19 January 2038 is not supported under 32 bit */
+    private static final int MAX_NITZ_YEAR = 2037;
 
     String mSavedTimeZone;
     long mSavedTime;
@@ -1744,6 +1746,10 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
             String[] nitzSubs = nitz.split("[/:,+-]");
 
             int year = 2000 + Integer.parseInt(nitzSubs[0]);
+            if (year > MAX_NITZ_YEAR) {
+              if (DBG) loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
+              return;
+            }
             c.set(Calendar.YEAR, year);
 
             // month is 0 based!
